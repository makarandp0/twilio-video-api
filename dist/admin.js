/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/admin.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayLikeToArray; });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayWithoutHoles; });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _assertThisInitialized; });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _createClass; });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _extends; });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _inheritsLoose; });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  Object(_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _iterableToArray; });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _nonIterableSpread; });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutPropertiesLoose; });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _setPrototypeOf; });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _toConsumableArray; });
/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return Object(_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || Object(_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arr) || Object(_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arr) || Object(_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _unsupportedIterableToArray; });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
}

/***/ }),

/***/ "./node_modules/backoff/index.js":
/*!***************************************!*\
  !*** ./node_modules/backoff/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var Backoff = __webpack_require__(/*! ./lib/backoff */ "./node_modules/backoff/lib/backoff.js");
var ExponentialBackoffStrategy = __webpack_require__(/*! ./lib/strategy/exponential */ "./node_modules/backoff/lib/strategy/exponential.js");
var FibonacciBackoffStrategy = __webpack_require__(/*! ./lib/strategy/fibonacci */ "./node_modules/backoff/lib/strategy/fibonacci.js");
var FunctionCall = __webpack_require__(/*! ./lib/function_call.js */ "./node_modules/backoff/lib/function_call.js");

module.exports.Backoff = Backoff;
module.exports.FunctionCall = FunctionCall;
module.exports.FibonacciStrategy = FibonacciBackoffStrategy;
module.exports.ExponentialStrategy = ExponentialBackoffStrategy;

// Constructs a Fibonacci backoff.
module.exports.fibonacci = function(options) {
    return new Backoff(new FibonacciBackoffStrategy(options));
};

// Constructs an exponential backoff.
module.exports.exponential = function(options) {
    return new Backoff(new ExponentialBackoffStrategy(options));
};

// Constructs a FunctionCall for the given function and arguments.
module.exports.call = function(fn, vargs, callback) {
    var args = Array.prototype.slice.call(arguments);
    fn = args[0];
    vargs = args.slice(1, args.length - 1);
    callback = args[args.length - 1];
    return new FunctionCall(fn, vargs, callback);
};


/***/ }),

/***/ "./node_modules/backoff/lib/backoff.js":
/*!*********************************************!*\
  !*** ./node_modules/backoff/lib/backoff.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var events = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var precond = __webpack_require__(/*! precond */ "./node_modules/precond/index.js");
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

// A class to hold the state of a backoff operation. Accepts a backoff strategy
// to generate the backoff delays.
function Backoff(backoffStrategy) {
    events.EventEmitter.call(this);

    this.backoffStrategy_ = backoffStrategy;
    this.maxNumberOfRetry_ = -1;
    this.backoffNumber_ = 0;
    this.backoffDelay_ = 0;
    this.timeoutID_ = -1;

    this.handlers = {
        backoff: this.onBackoff_.bind(this)
    };
}
util.inherits(Backoff, events.EventEmitter);

// Sets a limit, greater than 0, on the maximum number of backoffs. A 'fail'
// event will be emitted when the limit is reached.
Backoff.prototype.failAfter = function(maxNumberOfRetry) {
    precond.checkArgument(maxNumberOfRetry > 0,
        'Expected a maximum number of retry greater than 0 but got %s.',
        maxNumberOfRetry);

    this.maxNumberOfRetry_ = maxNumberOfRetry;
};

// Starts a backoff operation. Accepts an optional parameter to let the
// listeners know why the backoff operation was started.
Backoff.prototype.backoff = function(err) {
    precond.checkState(this.timeoutID_ === -1, 'Backoff in progress.');

    if (this.backoffNumber_ === this.maxNumberOfRetry_) {
        this.emit('fail', err);
        this.reset();
    } else {
        this.backoffDelay_ = this.backoffStrategy_.next();
        this.timeoutID_ = setTimeout(this.handlers.backoff, this.backoffDelay_);
        this.emit('backoff', this.backoffNumber_, this.backoffDelay_, err);
    }
};

// Handles the backoff timeout completion.
Backoff.prototype.onBackoff_ = function() {
    this.timeoutID_ = -1;
    this.emit('ready', this.backoffNumber_, this.backoffDelay_);
    this.backoffNumber_++;
};

// Stops any backoff operation and resets the backoff delay to its inital value.
Backoff.prototype.reset = function() {
    this.backoffNumber_ = 0;
    this.backoffStrategy_.reset();
    clearTimeout(this.timeoutID_);
    this.timeoutID_ = -1;
};

module.exports = Backoff;


/***/ }),

/***/ "./node_modules/backoff/lib/function_call.js":
/*!***************************************************!*\
  !*** ./node_modules/backoff/lib/function_call.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var events = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var precond = __webpack_require__(/*! precond */ "./node_modules/precond/index.js");
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

var Backoff = __webpack_require__(/*! ./backoff */ "./node_modules/backoff/lib/backoff.js");
var FibonacciBackoffStrategy = __webpack_require__(/*! ./strategy/fibonacci */ "./node_modules/backoff/lib/strategy/fibonacci.js");

// Wraps a function to be called in a backoff loop.
function FunctionCall(fn, args, callback) {
    events.EventEmitter.call(this);

    precond.checkIsFunction(fn, 'Expected fn to be a function.');
    precond.checkIsArray(args, 'Expected args to be an array.');
    precond.checkIsFunction(callback, 'Expected callback to be a function.');

    this.function_ = fn;
    this.arguments_ = args;
    this.callback_ = callback;
    this.lastResult_ = [];
    this.numRetries_ = 0;

    this.backoff_ = null;
    this.strategy_ = null;
    this.failAfter_ = -1;
    this.retryPredicate_ = FunctionCall.DEFAULT_RETRY_PREDICATE_;

    this.state_ = FunctionCall.State_.PENDING;
}
util.inherits(FunctionCall, events.EventEmitter);

// States in which the call can be.
FunctionCall.State_ = {
    // Call isn't started yet.
    PENDING: 0,
    // Call is in progress.
    RUNNING: 1,
    // Call completed successfully which means that either the wrapped function
    // returned successfully or the maximal number of backoffs was reached.
    COMPLETED: 2,
    // The call was aborted.
    ABORTED: 3
};

// The default retry predicate which considers any error as retriable.
FunctionCall.DEFAULT_RETRY_PREDICATE_ = function(err) {
  return true;
};

// Checks whether the call is pending.
FunctionCall.prototype.isPending = function() {
    return this.state_ == FunctionCall.State_.PENDING;
};

// Checks whether the call is in progress.
FunctionCall.prototype.isRunning = function() {
    return this.state_ == FunctionCall.State_.RUNNING;
};

// Checks whether the call is completed.
FunctionCall.prototype.isCompleted = function() {
    return this.state_ == FunctionCall.State_.COMPLETED;
};

// Checks whether the call is aborted.
FunctionCall.prototype.isAborted = function() {
    return this.state_ == FunctionCall.State_.ABORTED;
};

// Sets the backoff strategy to use. Can only be called before the call is
// started otherwise an exception will be thrown.
FunctionCall.prototype.setStrategy = function(strategy) {
    precond.checkState(this.isPending(), 'FunctionCall in progress.');
    this.strategy_ = strategy;
    return this; // Return this for chaining.
};

// Sets the predicate which will be used to determine whether the errors
// returned from the wrapped function should be retried or not, e.g. a
// network error would be retriable while a type error would stop the
// function call.
FunctionCall.prototype.retryIf = function(retryPredicate) {
    precond.checkState(this.isPending(), 'FunctionCall in progress.');
    this.retryPredicate_ = retryPredicate;
    return this;
};

// Returns all intermediary results returned by the wrapped function since
// the initial call.
FunctionCall.prototype.getLastResult = function() {
    return this.lastResult_.concat();
};

// Returns the number of times the wrapped function call was retried.
FunctionCall.prototype.getNumRetries = function() {
    return this.numRetries_;
};

// Sets the backoff limit.
FunctionCall.prototype.failAfter = function(maxNumberOfRetry) {
    precond.checkState(this.isPending(), 'FunctionCall in progress.');
    this.failAfter_ = maxNumberOfRetry;
    return this; // Return this for chaining.
};

// Aborts the call.
FunctionCall.prototype.abort = function() {
    if (this.isCompleted() || this.isAborted()) {
      return;
    }

    if (this.isRunning()) {
        this.backoff_.reset();
    }

    this.state_ = FunctionCall.State_.ABORTED;
    this.lastResult_ = [new Error('Backoff aborted.')];
    this.emit('abort');
    this.doCallback_();
};

// Initiates the call to the wrapped function. Accepts an optional factory
// function used to create the backoff instance; used when testing.
FunctionCall.prototype.start = function(backoffFactory) {
    precond.checkState(!this.isAborted(), 'FunctionCall is aborted.');
    precond.checkState(this.isPending(), 'FunctionCall already started.');

    var strategy = this.strategy_ || new FibonacciBackoffStrategy();

    this.backoff_ = backoffFactory ?
        backoffFactory(strategy) :
        new Backoff(strategy);

    this.backoff_.on('ready', this.doCall_.bind(this, true /* isRetry */));
    this.backoff_.on('fail', this.doCallback_.bind(this));
    this.backoff_.on('backoff', this.handleBackoff_.bind(this));

    if (this.failAfter_ > 0) {
        this.backoff_.failAfter(this.failAfter_);
    }

    this.state_ = FunctionCall.State_.RUNNING;
    this.doCall_(false /* isRetry */);
};

// Calls the wrapped function.
FunctionCall.prototype.doCall_ = function(isRetry) {
    if (isRetry) {
        this.numRetries_++;
    }
    var eventArgs = ['call'].concat(this.arguments_);
    events.EventEmitter.prototype.emit.apply(this, eventArgs);
    var callback = this.handleFunctionCallback_.bind(this);
    this.function_.apply(null, this.arguments_.concat(callback));
};

// Calls the wrapped function's callback with the last result returned by the
// wrapped function.
FunctionCall.prototype.doCallback_ = function() {
    this.callback_.apply(null, this.lastResult_);
};

// Handles wrapped function's completion. This method acts as a replacement
// for the original callback function.
FunctionCall.prototype.handleFunctionCallback_ = function() {
    if (this.isAborted()) {
        return;
    }

    var args = Array.prototype.slice.call(arguments);
    this.lastResult_ = args; // Save last callback arguments.
    events.EventEmitter.prototype.emit.apply(this, ['callback'].concat(args));

    var err = args[0];
    if (err && this.retryPredicate_(err)) {
        this.backoff_.backoff(err);
    } else {
        this.state_ = FunctionCall.State_.COMPLETED;
        this.doCallback_();
    }
};

// Handles the backoff event by reemitting it.
FunctionCall.prototype.handleBackoff_ = function(number, delay, err) {
    this.emit('backoff', number, delay, err);
};

module.exports = FunctionCall;


/***/ }),

/***/ "./node_modules/backoff/lib/strategy/exponential.js":
/*!**********************************************************!*\
  !*** ./node_modules/backoff/lib/strategy/exponential.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");
var precond = __webpack_require__(/*! precond */ "./node_modules/precond/index.js");

var BackoffStrategy = __webpack_require__(/*! ./strategy */ "./node_modules/backoff/lib/strategy/strategy.js");

// Exponential backoff strategy.
function ExponentialBackoffStrategy(options) {
    BackoffStrategy.call(this, options);
    this.backoffDelay_ = 0;
    this.nextBackoffDelay_ = this.getInitialDelay();
    this.factor_ = ExponentialBackoffStrategy.DEFAULT_FACTOR;

    if (options && options.factor !== undefined) {
        precond.checkArgument(options.factor > 1,
            'Exponential factor should be greater than 1 but got %s.',
            options.factor);
        this.factor_ = options.factor;
    }
}
util.inherits(ExponentialBackoffStrategy, BackoffStrategy);

// Default multiplication factor used to compute the next backoff delay from
// the current one. The value can be overridden by passing a custom factor as
// part of the options.
ExponentialBackoffStrategy.DEFAULT_FACTOR = 2;

ExponentialBackoffStrategy.prototype.next_ = function() {
    this.backoffDelay_ = Math.min(this.nextBackoffDelay_, this.getMaxDelay());
    this.nextBackoffDelay_ = this.backoffDelay_ * this.factor_;
    return this.backoffDelay_;
};

ExponentialBackoffStrategy.prototype.reset_ = function() {
    this.backoffDelay_ = 0;
    this.nextBackoffDelay_ = this.getInitialDelay();
};

module.exports = ExponentialBackoffStrategy;


/***/ }),

/***/ "./node_modules/backoff/lib/strategy/fibonacci.js":
/*!********************************************************!*\
  !*** ./node_modules/backoff/lib/strategy/fibonacci.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

var BackoffStrategy = __webpack_require__(/*! ./strategy */ "./node_modules/backoff/lib/strategy/strategy.js");

// Fibonacci backoff strategy.
function FibonacciBackoffStrategy(options) {
    BackoffStrategy.call(this, options);
    this.backoffDelay_ = 0;
    this.nextBackoffDelay_ = this.getInitialDelay();
}
util.inherits(FibonacciBackoffStrategy, BackoffStrategy);

FibonacciBackoffStrategy.prototype.next_ = function() {
    var backoffDelay = Math.min(this.nextBackoffDelay_, this.getMaxDelay());
    this.nextBackoffDelay_ += this.backoffDelay_;
    this.backoffDelay_ = backoffDelay;
    return backoffDelay;
};

FibonacciBackoffStrategy.prototype.reset_ = function() {
    this.nextBackoffDelay_ = this.getInitialDelay();
    this.backoffDelay_ = 0;
};

module.exports = FibonacciBackoffStrategy;


/***/ }),

/***/ "./node_modules/backoff/lib/strategy/strategy.js":
/*!*******************************************************!*\
  !*** ./node_modules/backoff/lib/strategy/strategy.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var events = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

function isDef(value) {
    return value !== undefined && value !== null;
}

// Abstract class defining the skeleton for the backoff strategies. Accepts an
// object holding the options for the backoff strategy:
//
//  * `randomisationFactor`: The randomisation factor which must be between 0
//     and 1 where 1 equates to a randomization factor of 100% and 0 to no
//     randomization.
//  * `initialDelay`: The backoff initial delay in milliseconds.
//  * `maxDelay`: The backoff maximal delay in milliseconds.
function BackoffStrategy(options) {
    options = options || {};

    if (isDef(options.initialDelay) && options.initialDelay < 1) {
        throw new Error('The initial timeout must be greater than 0.');
    } else if (isDef(options.maxDelay) && options.maxDelay < 1) {
        throw new Error('The maximal timeout must be greater than 0.');
    }

    this.initialDelay_ = options.initialDelay || 100;
    this.maxDelay_ = options.maxDelay || 10000;

    if (this.maxDelay_ <= this.initialDelay_) {
        throw new Error('The maximal backoff delay must be ' +
                        'greater than the initial backoff delay.');
    }

    if (isDef(options.randomisationFactor) &&
        (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {
        throw new Error('The randomisation factor must be between 0 and 1.');
    }

    this.randomisationFactor_ = options.randomisationFactor || 0;
}

// Gets the maximal backoff delay.
BackoffStrategy.prototype.getMaxDelay = function() {
    return this.maxDelay_;
};

// Gets the initial backoff delay.
BackoffStrategy.prototype.getInitialDelay = function() {
    return this.initialDelay_;
};

// Template method that computes and returns the next backoff delay in
// milliseconds.
BackoffStrategy.prototype.next = function() {
    var backoffDelay = this.next_();
    var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;
    var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);
    return randomizedDelay;
};

// Computes and returns the next backoff delay. Intended to be overridden by
// subclasses.
BackoffStrategy.prototype.next_ = function() {
    throw new Error('BackoffStrategy.next_() unimplemented.');
};

// Template method that resets the backoff delay to its initial value.
BackoffStrategy.prototype.reset = function() {
    this.reset_();
};

// Resets the backoff delay to its initial value. Intended to be overridden by
// subclasses.
BackoffStrategy.prototype.reset_ = function() {
    throw new Error('BackoffStrategy.reset_() unimplemented.');
};

module.exports = BackoffStrategy;


/***/ }),

/***/ "./node_modules/css-vendor/dist/css-vendor.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/css-vendor/dist/css-vendor.esm.js ***!
  \********************************************************/
/*! exports provided: prefix, supportedKeyframes, supportedProperty, supportedValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prefix", function() { return prefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportedKeyframes", function() { return supportedKeyframes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportedProperty", function() { return supportedProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportedValue", function() { return supportedValue; });
/* harmony import */ var is_in_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-in-browser */ "./node_modules/is-in-browser/dist/module.js");
/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");



// Export javascript style and css style vendor prefixes.
var js = '';
var css = '';
var vendor = '';
var browser = '';
var isTouch = is_in_browser__WEBPACK_IMPORTED_MODULE_0__["default"] && 'ontouchstart' in document.documentElement; // We should not do anything if required serverside.

if (is_in_browser__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  // Order matters. We need to check Webkit the last one because
  // other vendors use to add Webkit prefixes to some properties
  var jsCssMap = {
    Moz: '-moz-',
    ms: '-ms-',
    O: '-o-',
    Webkit: '-webkit-'
  };

  var _document$createEleme = document.createElement('p'),
      style = _document$createEleme.style;

  var testProp = 'Transform';

  for (var key in jsCssMap) {
    if (key + testProp in style) {
      js = key;
      css = jsCssMap[key];
      break;
    }
  } // Correctly detect the Edge browser.


  if (js === 'Webkit' && 'msHyphens' in style) {
    js = 'ms';
    css = jsCssMap.ms;
    browser = 'edge';
  } // Correctly detect the Safari browser.


  if (js === 'Webkit' && '-apple-trailing-word' in style) {
    vendor = 'apple';
  }
}
/**
 * Vendor prefix string for the current browser.
 *
 * @type {{js: String, css: String, vendor: String, browser: String}}
 * @api public
 */


var prefix = {
  js: js,
  css: css,
  vendor: vendor,
  browser: browser,
  isTouch: isTouch
};

/**
 * Test if a keyframe at-rule should be prefixed or not
 *
 * @param {String} vendor prefix string for the current browser.
 * @return {String}
 * @api public
 */

function supportedKeyframes(key) {
  // Keyframes is already prefixed. e.g. key = '@-webkit-keyframes a'
  if (key[1] === '-') return key; // No need to prefix IE/Edge. Older browsers will ignore unsupported rules.
  // https://caniuse.com/#search=keyframes

  if (prefix.js === 'ms') return key;
  return "@" + prefix.css + "keyframes" + key.substr(10);
}

// https://caniuse.com/#search=appearance

var appearence = {
  noPrefill: ['appearance'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'appearance') return false;
    if (prefix.js === 'ms') return "-webkit-" + prop;
    return prefix.css + prop;
  }
};

// https://caniuse.com/#search=color-adjust

var colorAdjust = {
  noPrefill: ['color-adjust'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'color-adjust') return false;
    if (prefix.js === 'Webkit') return prefix.css + "print-" + prop;
    return prop;
  }
};

var regExp = /[-\s]+(.)?/g;
/**
 * Replaces the letter with the capital letter
 *
 * @param {String} match
 * @param {String} c
 * @return {String}
 * @api private
 */

function toUpper(match, c) {
  return c ? c.toUpperCase() : '';
}
/**
 * Convert dash separated strings to camel-cased.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */


function camelize(str) {
  return str.replace(regExp, toUpper);
}

/**
 * Convert dash separated strings to pascal cased.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function pascalize(str) {
  return camelize("-" + str);
}

// but we can use a longhand property instead.
// https://caniuse.com/#search=mask

var mask = {
  noPrefill: ['mask'],
  supportedProperty: function supportedProperty(prop, style) {
    if (!/^mask/.test(prop)) return false;

    if (prefix.js === 'Webkit') {
      var longhand = 'mask-image';

      if (camelize(longhand) in style) {
        return prop;
      }

      if (prefix.js + pascalize(longhand) in style) {
        return prefix.css + prop;
      }
    }

    return prop;
  }
};

// https://caniuse.com/#search=text-orientation

var textOrientation = {
  noPrefill: ['text-orientation'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'text-orientation') return false;

    if (prefix.vendor === 'apple' && !prefix.isTouch) {
      return prefix.css + prop;
    }

    return prop;
  }
};

// https://caniuse.com/#search=transform

var transform = {
  noPrefill: ['transform'],
  supportedProperty: function supportedProperty(prop, style, options) {
    if (prop !== 'transform') return false;

    if (options.transform) {
      return prop;
    }

    return prefix.css + prop;
  }
};

// https://caniuse.com/#search=transition

var transition = {
  noPrefill: ['transition'],
  supportedProperty: function supportedProperty(prop, style, options) {
    if (prop !== 'transition') return false;

    if (options.transition) {
      return prop;
    }

    return prefix.css + prop;
  }
};

// https://caniuse.com/#search=writing-mode

var writingMode = {
  noPrefill: ['writing-mode'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'writing-mode') return false;

    if (prefix.js === 'Webkit' || prefix.js === 'ms' && prefix.browser !== 'edge') {
      return prefix.css + prop;
    }

    return prop;
  }
};

// https://caniuse.com/#search=user-select

var userSelect = {
  noPrefill: ['user-select'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'user-select') return false;

    if (prefix.js === 'Moz' || prefix.js === 'ms' || prefix.vendor === 'apple') {
      return prefix.css + prop;
    }

    return prop;
  }
};

// https://caniuse.com/#search=multicolumn
// https://github.com/postcss/autoprefixer/issues/491
// https://github.com/postcss/autoprefixer/issues/177

var breakPropsOld = {
  supportedProperty: function supportedProperty(prop, style) {
    if (!/^break-/.test(prop)) return false;

    if (prefix.js === 'Webkit') {
      var jsProp = "WebkitColumn" + pascalize(prop);
      return jsProp in style ? prefix.css + "column-" + prop : false;
    }

    if (prefix.js === 'Moz') {
      var _jsProp = "page" + pascalize(prop);

      return _jsProp in style ? "page-" + prop : false;
    }

    return false;
  }
};

// See https://github.com/postcss/autoprefixer/issues/324.

var inlineLogicalOld = {
  supportedProperty: function supportedProperty(prop, style) {
    if (!/^(border|margin|padding)-inline/.test(prop)) return false;
    if (prefix.js === 'Moz') return prop;
    var newProp = prop.replace('-inline', '');
    return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
  }
};

// Camelization is required because we can't test using.
// CSS syntax for e.g. in FF.

var unprefixed = {
  supportedProperty: function supportedProperty(prop, style) {
    return camelize(prop) in style ? prop : false;
  }
};

var prefixed = {
  supportedProperty: function supportedProperty(prop, style) {
    var pascalized = pascalize(prop); // Return custom CSS variable without prefixing.

    if (prop[0] === '-') return prop; // Return already prefixed value without prefixing.

    if (prop[0] === '-' && prop[1] === '-') return prop;
    if (prefix.js + pascalized in style) return prefix.css + prop; // Try webkit fallback.

    if (prefix.js !== 'Webkit' && "Webkit" + pascalized in style) return "-webkit-" + prop;
    return false;
  }
};

// https://caniuse.com/#search=scroll-snap

var scrollSnap = {
  supportedProperty: function supportedProperty(prop) {
    if (prop.substring(0, 11) !== 'scroll-snap') return false;

    if (prefix.js === 'ms') {
      return "" + prefix.css + prop;
    }

    return prop;
  }
};

// https://caniuse.com/#search=overscroll-behavior

var overscrollBehavior = {
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'overscroll-behavior') return false;

    if (prefix.js === 'ms') {
      return prefix.css + "scroll-chaining";
    }

    return prop;
  }
};

var propMap = {
  'flex-grow': 'flex-positive',
  'flex-shrink': 'flex-negative',
  'flex-basis': 'flex-preferred-size',
  'justify-content': 'flex-pack',
  order: 'flex-order',
  'align-items': 'flex-align',
  'align-content': 'flex-line-pack' // 'align-self' is handled by 'align-self' plugin.

}; // Support old flex spec from 2012.

var flex2012 = {
  supportedProperty: function supportedProperty(prop, style) {
    var newProp = propMap[prop];
    if (!newProp) return false;
    return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
  }
};

var propMap$1 = {
  flex: 'box-flex',
  'flex-grow': 'box-flex',
  'flex-direction': ['box-orient', 'box-direction'],
  order: 'box-ordinal-group',
  'align-items': 'box-align',
  'flex-flow': ['box-orient', 'box-direction'],
  'justify-content': 'box-pack'
};
var propKeys = Object.keys(propMap$1);

var prefixCss = function prefixCss(p) {
  return prefix.css + p;
}; // Support old flex spec from 2009.


var flex2009 = {
  supportedProperty: function supportedProperty(prop, style, _ref) {
    var multiple = _ref.multiple;

    if (propKeys.indexOf(prop) > -1) {
      var newProp = propMap$1[prop];

      if (!Array.isArray(newProp)) {
        return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
      }

      if (!multiple) return false;

      for (var i = 0; i < newProp.length; i++) {
        if (!(prefix.js + pascalize(newProp[0]) in style)) {
          return false;
        }
      }

      return newProp.map(prefixCss);
    }

    return false;
  }
};

// plugins = [
//   ...plugins,
//    breakPropsOld,
//    inlineLogicalOld,
//    unprefixed,
//    prefixed,
//    scrollSnap,
//    flex2012,
//    flex2009
// ]
// Plugins without 'noPrefill' value, going last.
// 'flex-*' plugins should be at the bottom.
// 'flex2009' going after 'flex2012'.
// 'prefixed' going after 'unprefixed'

var plugins = [appearence, colorAdjust, mask, textOrientation, transform, transition, writingMode, userSelect, breakPropsOld, inlineLogicalOld, unprefixed, prefixed, scrollSnap, overscrollBehavior, flex2012, flex2009];
var propertyDetectors = plugins.filter(function (p) {
  return p.supportedProperty;
}).map(function (p) {
  return p.supportedProperty;
});
var noPrefill = plugins.filter(function (p) {
  return p.noPrefill;
}).reduce(function (a, p) {
  a.push.apply(a, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(p.noPrefill));
  return a;
}, []);

var el;
var cache = {};

if (is_in_browser__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  el = document.createElement('p'); // We test every property on vendor prefix requirement.
  // Once tested, result is cached. It gives us up to 70% perf boost.
  // http://jsperf.com/element-style-object-access-vs-plain-object
  //
  // Prefill cache with known css properties to reduce amount of
  // properties we need to feature test at runtime.
  // http://davidwalsh.name/vendor-prefix

  var computed = window.getComputedStyle(document.documentElement, '');

  for (var key$1 in computed) {
    // eslint-disable-next-line no-restricted-globals
    if (!isNaN(key$1)) cache[computed[key$1]] = computed[key$1];
  } // Properties that cannot be correctly detected using the
  // cache prefill method.


  noPrefill.forEach(function (x) {
    return delete cache[x];
  });
}
/**
 * Test if a property is supported, returns supported property with vendor
 * prefix if required. Returns `false` if not supported.
 *
 * @param {String} prop dash separated
 * @param {Object} [options]
 * @return {String|Boolean}
 * @api public
 */


function supportedProperty(prop, options) {
  if (options === void 0) {
    options = {};
  }

  // For server-side rendering.
  if (!el) return prop; // Remove cache for benchmark tests or return property from the cache.

  if ( true && cache[prop] != null) {
    return cache[prop];
  } // Check if 'transition' or 'transform' natively supported in browser.


  if (prop === 'transition' || prop === 'transform') {
    options[prop] = prop in el.style;
  } // Find a plugin for current prefix property.


  for (var i = 0; i < propertyDetectors.length; i++) {
    cache[prop] = propertyDetectors[i](prop, el.style, options); // Break loop, if value found.

    if (cache[prop]) break;
  } // Reset styles for current property.
  // Firefox can even throw an error for invalid properties, e.g., "0".


  try {
    el.style[prop] = '';
  } catch (err) {
    return false;
  }

  return cache[prop];
}

var cache$1 = {};
var transitionProperties = {
  transition: 1,
  'transition-property': 1,
  '-webkit-transition': 1,
  '-webkit-transition-property': 1
};
var transPropsRegExp = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g;
var el$1;
/**
 * Returns prefixed value transition/transform if needed.
 *
 * @param {String} match
 * @param {String} p1
 * @param {String} p2
 * @return {String}
 * @api private
 */

function prefixTransitionCallback(match, p1, p2) {
  if (p1 === 'var') return 'var';
  if (p1 === 'all') return 'all';
  if (p2 === 'all') return ', all';
  var prefixedValue = p1 ? supportedProperty(p1) : ", " + supportedProperty(p2);
  if (!prefixedValue) return p1 || p2;
  return prefixedValue;
}

if (is_in_browser__WEBPACK_IMPORTED_MODULE_0__["default"]) el$1 = document.createElement('p');
/**
 * Returns prefixed value if needed. Returns `false` if value is not supported.
 *
 * @param {String} property
 * @param {String} value
 * @return {String|Boolean}
 * @api public
 */

function supportedValue(property, value) {
  // For server-side rendering.
  var prefixedValue = value;
  if (!el$1 || property === 'content') return value; // It is a string or a number as a string like '1'.
  // We want only prefixable values here.
  // eslint-disable-next-line no-restricted-globals

  if (typeof prefixedValue !== 'string' || !isNaN(parseInt(prefixedValue, 10))) {
    return prefixedValue;
  } // Create cache key for current value.


  var cacheKey = property + prefixedValue; // Remove cache for benchmark tests or return value from cache.

  if ( true && cache$1[cacheKey] != null) {
    return cache$1[cacheKey];
  } // IE can even throw an error in some cases, for e.g. style.content = 'bar'.


  try {
    // Test value as it is.
    el$1.style[property] = prefixedValue;
  } catch (err) {
    // Return false if value not supported.
    cache$1[cacheKey] = false;
    return false;
  } // If 'transition' or 'transition-property' property.


  if (transitionProperties[property]) {
    prefixedValue = prefixedValue.replace(transPropsRegExp, prefixTransitionCallback);
  } else if (el$1.style[property] === '') {
    // Value with a vendor prefix.
    prefixedValue = prefix.css + prefixedValue; // Hardcode test to convert "flex" to "-ms-flexbox" for IE10.

    if (prefixedValue === '-ms-flex') el$1.style[property] = '-ms-flexbox'; // Test prefixed value.

    el$1.style[property] = prefixedValue; // Return false if value not supported.

    if (el$1.style[property] === '') {
      cache$1[cacheKey] = false;
      return false;
    }
  } // Reset styles for current property.


  el$1.style[property] = ''; // Write current value to cache.

  cache$1[cacheKey] = prefixedValue;
  return cache$1[cacheKey];
}




/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/hyphenate-style-name/index.js":
/*!****************************************************!*\
  !*** ./node_modules/hyphenate-style-name/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* eslint-disable no-var, prefer-template */
var uppercasePattern = /[A-Z]/g
var msPattern = /^ms-/
var cache = {}

function toHyphenLower(match) {
  return '-' + match.toLowerCase()
}

function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) {
    return cache[name]
  }

  var hName = name.replace(uppercasePattern, toHyphenLower)
  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
}

/* harmony default export */ __webpack_exports__["default"] = (hyphenateStyleName);


/***/ }),

/***/ "./node_modules/is-in-browser/dist/module.js":
/*!***************************************************!*\
  !*** ./node_modules/is-in-browser/dist/module.js ***!
  \***************************************************/
/*! exports provided: isBrowser, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

/* harmony default export */ __webpack_exports__["default"] = (isBrowser);


/***/ }),

/***/ "./node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hyphenate-style-name */ "./node_modules/hyphenate-style-name/index.js");


/**
 * Convert camel cased property names to dash separated.
 *
 * @param {Object} style
 * @return {Object}
 */

function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    var key = prop.indexOf('--') === 0 ? prop : Object(hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__["default"])(prop);
    converted[key] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}
/**
 * Allow camel cased property names by converting them back to dasherized.
 *
 * @param {Rule} rule
 */


function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }

      return style;
    }

    return convertCase(style);
  }

  function onChangeValue(value, prop, rule) {
    if (prop.indexOf('--') === 0) {
      return value;
    }

    var hyphenatedProp = Object(hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__["default"])(prop); // There was no camel case in place

    if (prop === hyphenatedProp) return value;
    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

    return null;
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

/* harmony default export */ __webpack_exports__["default"] = (camelCase);


/***/ }),

/***/ "./node_modules/jss-plugin-compose/dist/jss-plugin-compose.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/jss-plugin-compose/dist/jss-plugin-compose.esm.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");


/**
 * Set selector.
 *
 * @param {Object} original rule
 * @param {String} className class string
 * @return {Boolean} flag, indicating function was successfull or not
 */
function registerClass(rule, className) {
  // Skip falsy values
  if (!className) return true; // Support array of class names `{composes: ['foo', 'bar']}`

  if (Array.isArray(className)) {
    for (var index = 0; index < className.length; index++) {
      var isSetted = registerClass(rule, className[index]);
      if (!isSetted) return false;
    }

    return true;
  } // Support space separated class names `{composes: 'foo bar'}`


  if (className.indexOf(' ') > -1) {
    return registerClass(rule, className.split(' '));
  }

  var _ref = rule.options,
      parent = _ref.parent; // It is a ref to a local rule.

  if (className[0] === '$') {
    var refRule = parent.getRule(className.substr(1));

    if (!refRule) {
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_0__["default"])(false, "[JSS] Referenced rule is not defined. \n" + rule.toString()) : undefined;
      return false;
    }

    if (refRule === rule) {
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_0__["default"])(false, "[JSS] Cyclic composition detected. \n" + rule.toString()) : undefined;
      return false;
    }

    parent.classes[rule.key] += " " + parent.classes[refRule.key];
    return true;
  }

  parent.classes[rule.key] += " " + className;
  return true;
}
/**
 * Convert compose property to additional class, remove property from original styles.
 *
 * @param {Rule} rule
 * @api public
 */


function jssCompose() {
  function onProcessStyle(style, rule) {
    if (!('composes' in style)) return style;
    registerClass(rule, style.composes); // Remove composes property to prevent infinite loop.

    delete style.composes;
    return style;
  }

  return {
    onProcessStyle: onProcessStyle
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssCompose);


/***/ }),

/***/ "./node_modules/jss-plugin-default-unit/dist/jss-plugin-default-unit.esm.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/jss-plugin-default-unit/dist/jss-plugin-default-unit.esm.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jss */ "./node_modules/jss/dist/jss.esm.js");


var px = jss__WEBPACK_IMPORTED_MODULE_0__["hasCSSTOMSupport"] && CSS ? CSS.px : 'px';
var ms = jss__WEBPACK_IMPORTED_MODULE_0__["hasCSSTOMSupport"] && CSS ? CSS.ms : 'ms';
var percent = jss__WEBPACK_IMPORTED_MODULE_0__["hasCSSTOMSupport"] && CSS ? CSS.percent : '%';
/**
 * Generated jss-plugin-default-unit CSS property units
 *
 * @type object
 */

var defaultUnits = {
  // Animation properties
  'animation-delay': ms,
  'animation-duration': ms,
  // Background properties
  'background-position': px,
  'background-position-x': px,
  'background-position-y': px,
  'background-size': px,
  // Border Properties
  border: px,
  'border-bottom': px,
  'border-bottom-left-radius': px,
  'border-bottom-right-radius': px,
  'border-bottom-width': px,
  'border-left': px,
  'border-left-width': px,
  'border-radius': px,
  'border-right': px,
  'border-right-width': px,
  'border-top': px,
  'border-top-left-radius': px,
  'border-top-right-radius': px,
  'border-top-width': px,
  'border-width': px,
  'border-block': px,
  'border-block-end': px,
  'border-block-end-width': px,
  'border-block-start': px,
  'border-block-start-width': px,
  'border-block-width': px,
  'border-inline': px,
  'border-inline-end': px,
  'border-inline-end-width': px,
  'border-inline-start': px,
  'border-inline-start-width': px,
  'border-inline-width': px,
  'border-start-start-radius': px,
  'border-start-end-radius': px,
  'border-end-start-radius': px,
  'border-end-end-radius': px,
  // Margin properties
  margin: px,
  'margin-bottom': px,
  'margin-left': px,
  'margin-right': px,
  'margin-top': px,
  'margin-block': px,
  'margin-block-end': px,
  'margin-block-start': px,
  'margin-inline': px,
  'margin-inline-end': px,
  'margin-inline-start': px,
  // Padding properties
  padding: px,
  'padding-bottom': px,
  'padding-left': px,
  'padding-right': px,
  'padding-top': px,
  'padding-block': px,
  'padding-block-end': px,
  'padding-block-start': px,
  'padding-inline': px,
  'padding-inline-end': px,
  'padding-inline-start': px,
  // Mask properties
  'mask-position-x': px,
  'mask-position-y': px,
  'mask-size': px,
  // Width and height properties
  height: px,
  width: px,
  'min-height': px,
  'max-height': px,
  'min-width': px,
  'max-width': px,
  // Position properties
  bottom: px,
  left: px,
  top: px,
  right: px,
  inset: px,
  'inset-block': px,
  'inset-block-end': px,
  'inset-block-start': px,
  'inset-inline': px,
  'inset-inline-end': px,
  'inset-inline-start': px,
  // Shadow properties
  'box-shadow': px,
  'text-shadow': px,
  // Column properties
  'column-gap': px,
  'column-rule': px,
  'column-rule-width': px,
  'column-width': px,
  // Font and text properties
  'font-size': px,
  'font-size-delta': px,
  'letter-spacing': px,
  'text-decoration-thickness': px,
  'text-indent': px,
  'text-stroke': px,
  'text-stroke-width': px,
  'word-spacing': px,
  // Motion properties
  motion: px,
  'motion-offset': px,
  // Outline properties
  outline: px,
  'outline-offset': px,
  'outline-width': px,
  // Perspective properties
  perspective: px,
  'perspective-origin-x': percent,
  'perspective-origin-y': percent,
  // Transform properties
  'transform-origin': percent,
  'transform-origin-x': percent,
  'transform-origin-y': percent,
  'transform-origin-z': percent,
  // Transition properties
  'transition-delay': ms,
  'transition-duration': ms,
  // Alignment properties
  'vertical-align': px,
  'flex-basis': px,
  // Some random properties
  'shape-margin': px,
  size: px,
  gap: px,
  // Grid properties
  grid: px,
  'grid-gap': px,
  'row-gap': px,
  'grid-row-gap': px,
  'grid-column-gap': px,
  'grid-template-rows': px,
  'grid-template-columns': px,
  'grid-auto-rows': px,
  'grid-auto-columns': px,
  // Not existing properties.
  // Used to avoid issues with jss-plugin-expand integration.
  'box-shadow-x': px,
  'box-shadow-y': px,
  'box-shadow-blur': px,
  'box-shadow-spread': px,
  'font-line-height': px,
  'text-shadow-x': px,
  'text-shadow-y': px,
  'text-shadow-blur': px
};

/**
 * Clones the object and adds a camel cased property version.
 */
function addCamelCasedVersion(obj) {
  var regExp = /(-[a-z])/g;

  var replace = function replace(str) {
    return str[1].toUpperCase();
  };

  var newObj = {};

  for (var _key in obj) {
    newObj[_key] = obj[_key];
    newObj[_key.replace(regExp, replace)] = obj[_key];
  }

  return newObj;
}

var units = addCamelCasedVersion(defaultUnits);
/**
 * Recursive deep style passing function
 */

function iterate(prop, value, options) {
  if (value == null) return value;

  if (Array.isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      value[i] = iterate(prop, value[i], options);
    }
  } else if (typeof value === 'object') {
    if (prop === 'fallbacks') {
      for (var innerProp in value) {
        value[innerProp] = iterate(innerProp, value[innerProp], options);
      }
    } else {
      for (var _innerProp in value) {
        value[_innerProp] = iterate(prop + "-" + _innerProp, value[_innerProp], options);
      }
    } // eslint-disable-next-line no-restricted-globals

  } else if (typeof value === 'number' && isNaN(value) === false) {
    var unit = options[prop] || units[prop]; // Add the unit if available, except for the special case of 0px.

    if (unit && !(value === 0 && unit === px)) {
      return typeof unit === 'function' ? unit(value).toString() : "" + value + unit;
    }

    return value.toString();
  }

  return value;
}
/**
 * Add unit to numeric values.
 */


function defaultUnit(options) {
  if (options === void 0) {
    options = {};
  }

  var camelCasedOptions = addCamelCasedVersion(options);

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    for (var prop in style) {
      style[prop] = iterate(prop, style[prop], camelCasedOptions);
    }

    return style;
  }

  function onChangeValue(value, prop) {
    return iterate(prop, value, camelCasedOptions);
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

/* harmony default export */ __webpack_exports__["default"] = (defaultUnit);


/***/ }),

/***/ "./node_modules/jss-plugin-expand/dist/jss-plugin-expand.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jss-plugin-expand/dist/jss-plugin-expand.esm.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A scheme for converting properties from array to regular style.
 * All properties listed below will be transformed to a string separated by space.
 */
var propArray = {
  'background-size': true,
  'background-position': true,
  border: true,
  'border-bottom': true,
  'border-left': true,
  'border-top': true,
  'border-right': true,
  'border-radius': true,
  'border-image': true,
  'border-width': true,
  'border-style': true,
  'border-color': true,
  'box-shadow': true,
  flex: true,
  margin: true,
  padding: true,
  outline: true,
  'transform-origin': true,
  transform: true,
  transition: true
  /**
   * A scheme for converting arrays to regular styles inside of objects.
   * For e.g.: "{position: [0, 0]}" => "background-position: 0 0;".
   */

};
var propArrayInObj = {
  position: true,
  // background-position
  size: true // background-size

  /**
   * A scheme for parsing and building correct styles from passed objects.
   */

};
var propObj = {
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  margin: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  background: {
    attachment: null,
    color: null,
    image: null,
    position: null,
    repeat: null
  },
  border: {
    width: null,
    style: null,
    color: null
  },
  'border-top': {
    width: null,
    style: null,
    color: null
  },
  'border-right': {
    width: null,
    style: null,
    color: null
  },
  'border-bottom': {
    width: null,
    style: null,
    color: null
  },
  'border-left': {
    width: null,
    style: null,
    color: null
  },
  outline: {
    width: null,
    style: null,
    color: null
  },
  'list-style': {
    type: null,
    position: null,
    image: null
  },
  transition: {
    property: null,
    duration: null,
    'timing-function': null,
    timingFunction: null,
    // Needed for avoiding comilation issues with jss-plugin-camel-case
    delay: null
  },
  animation: {
    name: null,
    duration: null,
    'timing-function': null,
    timingFunction: null,
    // Needed to avoid compilation issues with jss-plugin-camel-case
    delay: null,
    'iteration-count': null,
    iterationCount: null,
    // Needed to avoid compilation issues with jss-plugin-camel-case
    direction: null,
    'fill-mode': null,
    fillMode: null,
    // Needed to avoid compilation issues with jss-plugin-camel-case
    'play-state': null,
    playState: null // Needed to avoid compilation issues with jss-plugin-camel-case

  },
  'box-shadow': {
    x: 0,
    y: 0,
    blur: 0,
    spread: 0,
    color: null,
    inset: null
  },
  'text-shadow': {
    x: 0,
    y: 0,
    blur: null,
    color: null
  }
  /**
   * A scheme for converting non-standart properties inside object.
   * For e.g.: include 'border-radius' property inside 'border' object.
   */

};
var customPropObj = {
  border: {
    radius: 'border-radius',
    image: 'border-image',
    width: 'border-width',
    style: 'border-style',
    color: 'border-color'
  },
  'border-bottom': {
    width: 'border-bottom-width',
    style: 'border-bottom-style',
    color: 'border-bottom-color'
  },
  'border-top': {
    width: 'border-top-width',
    style: 'border-top-style',
    color: 'border-top-color'
  },
  'border-left': {
    width: 'border-left-width',
    style: 'border-left-style',
    color: 'border-left-color'
  },
  'border-right': {
    width: 'border-right-width',
    style: 'border-right-style',
    color: 'border-right-color'
  },
  background: {
    size: 'background-size',
    image: 'background-image'
  },
  font: {
    style: 'font-style',
    variant: 'font-variant',
    weight: 'font-weight',
    stretch: 'font-stretch',
    size: 'font-size',
    family: 'font-family',
    lineHeight: 'line-height',
    // Needed to avoid compilation issues with jss-plugin-camel-case
    'line-height': 'line-height'
  },
  flex: {
    grow: 'flex-grow',
    basis: 'flex-basis',
    direction: 'flex-direction',
    wrap: 'flex-wrap',
    flow: 'flex-flow',
    shrink: 'flex-shrink'
  },
  align: {
    self: 'align-self',
    items: 'align-items',
    content: 'align-content'
  },
  grid: {
    'template-columns': 'grid-template-columns',
    templateColumns: 'grid-template-columns',
    'template-rows': 'grid-template-rows',
    templateRows: 'grid-template-rows',
    'template-areas': 'grid-template-areas',
    templateAreas: 'grid-template-areas',
    template: 'grid-template',
    'auto-columns': 'grid-auto-columns',
    autoColumns: 'grid-auto-columns',
    'auto-rows': 'grid-auto-rows',
    autoRows: 'grid-auto-rows',
    'auto-flow': 'grid-auto-flow',
    autoFlow: 'grid-auto-flow',
    row: 'grid-row',
    column: 'grid-column',
    'row-start': 'grid-row-start',
    rowStart: 'grid-row-start',
    'row-end': 'grid-row-end',
    rowEnd: 'grid-row-end',
    'column-start': 'grid-column-start',
    columnStart: 'grid-column-start',
    'column-end': 'grid-column-end',
    columnEnd: 'grid-column-end',
    area: 'grid-area',
    gap: 'grid-gap',
    'row-gap': 'grid-row-gap',
    rowGap: 'grid-row-gap',
    'column-gap': 'grid-column-gap',
    columnGap: 'grid-column-gap'
  }
};

/* eslint-disable no-use-before-define */

/**
 * Map values by given prop.
 *
 * @param {Array} array of values
 * @param {String} original property
 * @param {String} original rule
 * @return {String} mapped values
 */
function mapValuesByProp(value, prop, rule) {
  return value.map(function (item) {
    return objectToArray(item, prop, rule, false, true);
  });
}
/**
 * Convert array to nested array, if needed
 */


function processArray(value, prop, scheme, rule) {
  if (scheme[prop] == null) return value;
  if (value.length === 0) return [];
  if (Array.isArray(value[0])) return processArray(value[0], prop, scheme, rule);

  if (typeof value[0] === 'object') {
    return mapValuesByProp(value, prop, rule);
  }

  return [value];
}
/**
 * Convert object to array.
 */


function objectToArray(value, prop, rule, isFallback, isInArray) {
  if (!(propObj[prop] || customPropObj[prop])) return [];
  var result = []; // Check if exists any non-standard property

  if (customPropObj[prop]) {
    // eslint-disable-next-line no-param-reassign
    value = customPropsToStyle(value, rule, customPropObj[prop], isFallback);
  } // Pass throught all standart props


  if (Object.keys(value).length) {
    for (var baseProp in propObj[prop]) {
      if (value[baseProp]) {
        if (Array.isArray(value[baseProp])) {
          result.push(propArrayInObj[baseProp] === null ? value[baseProp] : value[baseProp].join(' '));
        } else result.push(value[baseProp]);

        continue;
      } // Add default value from props config.


      if (propObj[prop][baseProp] != null) {
        result.push(propObj[prop][baseProp]);
      }
    }
  }

  if (!result.length || isInArray) return result;
  return [result];
}
/**
 * Convert custom properties values to styles adding them to rule directly
 */


function customPropsToStyle(value, rule, customProps, isFallback) {
  for (var prop in customProps) {
    var propName = customProps[prop]; // If current property doesn't exist already in rule - add new one

    if (typeof value[prop] !== 'undefined' && (isFallback || !rule.prop(propName))) {
      var _styleDetector;

      var appendedValue = styleDetector((_styleDetector = {}, _styleDetector[propName] = value[prop], _styleDetector), rule)[propName]; // Add style directly in rule

      if (isFallback) rule.style.fallbacks[propName] = appendedValue;else rule.style[propName] = appendedValue;
    } // Delete converted property to avoid double converting


    delete value[prop];
  }

  return value;
}
/**
 * Detect if a style needs to be converted.
 */


function styleDetector(style, rule, isFallback) {
  for (var prop in style) {
    var value = style[prop];

    if (Array.isArray(value)) {
      // Check double arrays to avoid recursion.
      if (!Array.isArray(value[0])) {
        if (prop === 'fallbacks') {
          for (var index = 0; index < style.fallbacks.length; index++) {
            style.fallbacks[index] = styleDetector(style.fallbacks[index], rule, true);
          }

          continue;
        }

        style[prop] = processArray(value, prop, propArray, rule); // Avoid creating properties with empty values

        if (!style[prop].length) delete style[prop];
      }
    } else if (typeof value === 'object') {
      if (prop === 'fallbacks') {
        style.fallbacks = styleDetector(style.fallbacks, rule, true);
        continue;
      }

      style[prop] = objectToArray(value, prop, rule, isFallback); // Avoid creating properties with empty values

      if (!style[prop].length) delete style[prop];
    } // Maybe a computed value resulting in an empty string
    else if (style[prop] === '') delete style[prop];
  }

  return style;
}
/**
 * Adds possibility to write expanded styles.
 */


function jssExpand() {
  function onProcessStyle(style, rule) {
    if (!style || rule.type !== 'style') return style;

    if (Array.isArray(style)) {
      // Pass rules one by one and reformat them
      for (var index = 0; index < style.length; index++) {
        style[index] = styleDetector(style[index], rule);
      }

      return style;
    }

    return styleDetector(style, rule);
  }

  return {
    onProcessStyle: onProcessStyle
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssExpand);


/***/ }),

/***/ "./node_modules/jss-plugin-extend/dist/jss-plugin-extend.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jss-plugin-extend/dist/jss-plugin-extend.esm.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");



var isObject = function isObject(obj) {
  return obj && typeof obj === 'object' && !Array.isArray(obj);
};

var valueNs = "extendCurrValue" + Date.now();

function mergeExtend(style, rule, sheet, newStyle) {
  var extendType = typeof style.extend; // Extend using a rule name.

  if (extendType === 'string') {
    if (!sheet) return;
    var refRule = sheet.getRule(style.extend);
    if (!refRule) return;

    if (refRule === rule) {
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_1__["default"])(false, "[JSS] A rule tries to extend itself \n" + rule.toString()) : undefined;
      return;
    }

    var parent = refRule.options.parent;

    if (parent) {
      var originalStyle = parent.rules.raw[style.extend];
      extend(originalStyle, rule, sheet, newStyle);
    }

    return;
  } // Extend using an array.


  if (Array.isArray(style.extend)) {
    for (var index = 0; index < style.extend.length; index++) {
      var singleExtend = style.extend[index];
      var singleStyle = typeof singleExtend === 'string' ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, style, {
        extend: singleExtend
      }) : style.extend[index];
      extend(singleStyle, rule, sheet, newStyle);
    }

    return;
  } // Extend is a style object.


  for (var prop in style.extend) {
    if (prop === 'extend') {
      extend(style.extend.extend, rule, sheet, newStyle);
      continue;
    }

    if (isObject(style.extend[prop])) {
      if (!(prop in newStyle)) newStyle[prop] = {};
      extend(style.extend[prop], rule, sheet, newStyle[prop]);
      continue;
    }

    newStyle[prop] = style.extend[prop];
  }
}

function mergeRest(style, rule, sheet, newStyle) {
  // Copy base style.
  for (var prop in style) {
    if (prop === 'extend') continue;

    if (isObject(newStyle[prop]) && isObject(style[prop])) {
      extend(style[prop], rule, sheet, newStyle[prop]);
      continue;
    }

    if (isObject(style[prop])) {
      newStyle[prop] = extend(style[prop], rule, sheet);
      continue;
    }

    newStyle[prop] = style[prop];
  }
}
/**
 * Recursively extend styles.
 */


function extend(style, rule, sheet, newStyle) {
  if (newStyle === void 0) {
    newStyle = {};
  }

  mergeExtend(style, rule, sheet, newStyle);
  mergeRest(style, rule, sheet, newStyle);
  return newStyle;
}
/**
 * Handle `extend` property.
 *
 * @param {Rule} rule
 * @api public
 */


function jssExtend() {
  function onProcessStyle(style, rule, sheet) {
    if ('extend' in style) return extend(style, rule, sheet);
    return style;
  }

  function onChangeValue(value, prop, rule) {
    if (prop !== 'extend') return value; // Value is empty, remove properties set previously.

    if (value == null || value === false) {
      // $FlowFixMe[prop-missing]
      for (var key in rule[valueNs]) {
        rule.prop(key, null);
      } // $FlowFixMe[prop-missing] Flow complains because there is no indexer property in StyleRule


      rule[valueNs] = null;
      return null;
    }

    if (typeof value === 'object') {
      // $FlowFixMe[invalid-in-rhs] This will be an object
      for (var _key in value) {
        // $FlowFixMe[incompatible-use] This will be an object
        rule.prop(_key, value[_key]);
      } // $FlowFixMe[prop-missing] Flow complains because there is no indexer property in StyleRule


      rule[valueNs] = value;
    } // Make sure we don't set the value in the core.


    return null;
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssExtend);


/***/ }),

/***/ "./node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss */ "./node_modules/jss/dist/jss.esm.js");



var at = '@global';
var atPrefix = '@global ';

var GlobalContainerRule =
/*#__PURE__*/
function () {
  function GlobalContainerRule(key, styles, options) {
    this.type = 'global';
    this.at = at;
    this.rules = void 0;
    this.options = void 0;
    this.key = void 0;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    this.rules = new jss__WEBPACK_IMPORTED_MODULE_1__["RuleList"](Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = GlobalContainerRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (rule) this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString() {
    return this.rules.toString();
  };

  return GlobalContainerRule;
}();

var GlobalPrefixedRule =
/*#__PURE__*/
function () {
  function GlobalPrefixedRule(key, style, options) {
    this.type = 'global';
    this.at = at;
    this.options = void 0;
    this.rule = void 0;
    this.isProcessed = false;
    this.key = void 0;
    this.key = key;
    this.options = options;
    var selector = key.substr(atPrefix.length);
    this.rule = options.jss.createRule(selector, style, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));
  }

  var _proto2 = GlobalPrefixedRule.prototype;

  _proto2.toString = function toString(options) {
    return this.rule ? this.rule.toString(options) : '';
  };

  return GlobalPrefixedRule;
}();

var separatorRegExp = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp);
  var scoped = '';

  for (var i = 0; i < parts.length; i++) {
    scoped += scope + " " + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }

  return scoped;
}

function handleNestedGlobalContainerRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;
  var rules = style ? style[at] : null;
  if (!rules) return;

  for (var name in rules) {
    sheet.addRule(name, rules[name], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[at];
}

function handlePrefixedGlobalRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    sheet.addRule(selector, style[prop], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}
/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */


function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (!name) return null;

    if (name === at) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;

    if (parent) {
      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
        options.scoped = false;
      }
    }

    if (options.scoped === false) {
      options.selector = name;
    }

    return null;
  }

  function onProcessRule(rule, sheet) {
    if (rule.type !== 'style' || !sheet) return;
    handleNestedGlobalContainerRule(rule, sheet);
    handlePrefixedGlobalRule(rule, sheet);
  }

  return {
    onCreateRule: onCreateRule,
    onProcessRule: onProcessRule
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssGlobal);


/***/ }),

/***/ "./node_modules/jss-plugin-nested/dist/jss-plugin-nested.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jss-plugin-nested/dist/jss-plugin-nested.esm.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");



var separatorRegExp = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp = /\$([\w-]+)/g;
/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */

function jssNested() {
  // Get a function to be used for $ref replacement.
  function getReplaceRef(container, sheet) {
    return function (match, key) {
      var rule = container.getRule(key) || sheet && sheet.getRule(key);

      if (rule) {
        rule = rule;
        return rule.selector;
      }

       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_1__["default"])(false, "[JSS] Could not find the referenced rule \"" + key + "\" in \"" + (container.options.meta || container.toString()) + "\".") : undefined;
      return key;
    };
  }

  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp);
    var nestedSelectors = nestedProp.split(separatorRegExp);
    var result = '';

    for (var i = 0; i < parentSelectors.length; i++) {
      var parent = parentSelectors[i];

      for (var j = 0; j < nestedSelectors.length; j++) {
        var nested = nestedSelectors[j];
        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.

        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
      }
    }

    return result;
  }

  function getOptions(rule, container, prevOptions) {
    // Options has been already created, now we only increase index.
    if (prevOptions) return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, prevOptions, {
      index: prevOptions.index + 1 // $FlowFixMe[prop-missing]

    });
    var nestingLevel = rule.options.nestingLevel;
    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

    var options = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, rule.options, {
      nestingLevel: nestingLevel,
      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.

    });

    delete options.name;
    return options;
  }

  function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style') return style;
    var styleRule = rule;
    var container = styleRule.options.parent;
    var options;
    var replaceRef;

    for (var prop in style) {
      var isNested = prop.indexOf('&') !== -1;
      var isNestedConditional = prop[0] === '@';
      if (!isNested && !isNestedConditional) continue;
      options = getOptions(styleRule, container, options);

      if (isNested) {
        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
        // all nested rules within the sheet.

        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.

        selector = selector.replace(refRegExp, replaceRef);
        container.addRule(selector, style[prop], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
          selector: selector
        }));
      } else if (isNestedConditional) {
        // Place conditional right after the parent rule to ensure right ordering.
        container.addRule(prop, {}, options) // Flow expects more options but they aren't required
        // And flow doesn't know this will always be a StyleRule which has the addRule method
        // $FlowFixMe[incompatible-use]
        // $FlowFixMe[prop-missing]
        .addRule(styleRule.key, style[prop], {
          selector: styleRule.selector
        });
      }

      delete style[prop];
    }

    return style;
  }

  return {
    onProcessStyle: onProcessStyle
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssNested);


/***/ }),

/***/ "./node_modules/jss-plugin-props-sort/dist/jss-plugin-props-sort.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/jss-plugin-props-sort/dist/jss-plugin-props-sort.esm.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Sort props by length.
 */
function jssPropsSort() {
  var sort = function sort(prop0, prop1) {
    if (prop0.length === prop1.length) {
      return prop0 > prop1 ? 1 : -1;
    }

    return prop0.length - prop1.length;
  };

  return {
    onProcessStyle: function onProcessStyle(style, rule) {
      if (rule.type !== 'style') return style;
      var newStyle = {};
      var props = Object.keys(style).sort(sort);

      for (var i = 0; i < props.length; i++) {
        newStyle[props[i]] = style[props[i]];
      }

      return newStyle;
    }
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssPropsSort);


/***/ }),

/***/ "./node_modules/jss-plugin-rule-value-function/dist/jss-plugin-rule-value-function.esm.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/jss-plugin-rule-value-function/dist/jss-plugin-rule-value-function.esm.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss */ "./node_modules/jss/dist/jss.esm.js");



var now = Date.now();
var fnValuesNs = "fnValues" + now;
var fnRuleNs = "fnStyle" + ++now;

var functionPlugin = function functionPlugin() {
  return {
    onCreateRule: function onCreateRule(name, decl, options) {
      if (typeof decl !== 'function') return null;
      var rule = Object(jss__WEBPACK_IMPORTED_MODULE_1__["createRule"])(name, {}, options);
      rule[fnRuleNs] = decl;
      return rule;
    },
    onProcessStyle: function onProcessStyle(style, rule) {
      // We need to extract function values from the declaration, so that we can keep core unaware of them.
      // We need to do that only once.
      // We don't need to extract functions on each style update, since this can happen only once.
      // We don't support function values inside of function rules.
      if (fnValuesNs in rule || fnRuleNs in rule) return style;
      var fnValues = {};

      for (var prop in style) {
        var value = style[prop];
        if (typeof value !== 'function') continue;
        delete style[prop];
        fnValues[prop] = value;
      } // $FlowFixMe[prop-missing]


      rule[fnValuesNs] = fnValues;
      return style;
    },
    onUpdate: function onUpdate(data, rule, sheet, options) {
      var styleRule = rule; // $FlowFixMe[prop-missing]

      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object
      // will be returned from that function.

      if (fnRule) {
        // Empty object will remove all currently defined props
        // in case function rule returns a falsy value.
        styleRule.style = fnRule(data) || {};

        if (true) {
          for (var prop in styleRule.style) {
            if (typeof styleRule.style[prop] === 'function') {
               true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_0__["default"])(false, '[JSS] Function values inside function rules are not supported.') : undefined;
              break;
            }
          }
        }
      } // $FlowFixMe[prop-missing]


      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.

      if (fnValues) {
        for (var _prop in fnValues) {
          styleRule.prop(_prop, fnValues[_prop](data), options);
        }
      }
    }
  };
};

/* harmony default export */ __webpack_exports__["default"] = (functionPlugin);


/***/ }),

/***/ "./node_modules/jss-plugin-rule-value-observable/dist/jss-plugin-rule-value-observable.esm.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/jss-plugin-rule-value-observable/dist/jss-plugin-rule-value-observable.esm.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! symbol-observable */ "./node_modules/symbol-observable/es/index.js");
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss */ "./node_modules/jss/dist/jss.esm.js");



var isObservable = function isObservable(value) {
  return value && value[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]] && value === value[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]]();
};

var observablePlugin = function observablePlugin(updateOptions) {
  return {
    onCreateRule: function onCreateRule(name, decl, options) {
      if (!isObservable(decl)) return null; // Cast `decl` to `Observable`, since it passed the type guard.

      var style$ = decl;
      var rule = Object(jss__WEBPACK_IMPORTED_MODULE_1__["createRule"])(name, {}, options); // TODO
      // Call `stream.subscribe()` returns a subscription, which should be explicitly
      // unsubscribed from when we know this sheet is no longer needed.

      style$.subscribe(function (style) {
        for (var prop in style) {
          rule.prop(prop, style[prop], updateOptions);
        }
      });
      return rule;
    },
    onProcessRule: function onProcessRule(rule) {
      if (rule && rule.type !== 'style') return;
      var styleRule = rule;
      var style = styleRule.style;

      var _loop = function _loop(prop) {
        var value = style[prop];
        if (!isObservable(value)) return "continue";
        delete style[prop];
        value.subscribe({
          next: function next(nextValue) {
            styleRule.prop(prop, nextValue, updateOptions);
          }
        });
      };

      for (var prop in style) {
        var _ret = _loop(prop);

        if (_ret === "continue") continue;
      }
    }
  };
};

/* harmony default export */ __webpack_exports__["default"] = (observablePlugin);


/***/ }),

/***/ "./node_modules/jss-plugin-template/dist/jss-plugin-template.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jss-plugin-template/dist/jss-plugin-template.esm.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");


var semiWithNl = /;\n/;

/**
 * Naive CSS parser.
 * - Supports only rule body (no selectors)
 * - Requires semicolon and new line after the value (except of last line)
 * - No nested rules support
 */
var parse = function parse(cssText) {
  var style = {};
  var split = cssText.split(semiWithNl);

  for (var i = 0; i < split.length; i++) {
    var decl = (split[i] || '').trim();
    if (!decl) continue;
    var colonIndex = decl.indexOf(':');

    if (colonIndex === -1) {
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_0__["default"])(false, "[JSS] Malformed CSS string \"" + decl + "\"") : undefined;
      continue;
    }

    var prop = decl.substr(0, colonIndex).trim();
    var value = decl.substr(colonIndex + 1).trim();
    style[prop] = value;
  }

  return style;
};

var onProcessRule = function onProcessRule(rule) {
  if (typeof rule.style === 'string') {
    // $FlowFixMe[prop-missing] We can safely assume that rule has the style property
    rule.style = parse(rule.style);
  }
};

function templatePlugin() {
  return {
    onProcessRule: onProcessRule
  };
}

/* harmony default export */ __webpack_exports__["default"] = (templatePlugin);


/***/ }),

/***/ "./node_modules/jss-plugin-vendor-prefixer/dist/jss-plugin-vendor-prefixer.esm.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/jss-plugin-vendor-prefixer/dist/jss-plugin-vendor-prefixer.esm.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var css_vendor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! css-vendor */ "./node_modules/css-vendor/dist/css-vendor.esm.js");
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss */ "./node_modules/jss/dist/jss.esm.js");



/**
 * Add vendor prefix to a property name when needed.
 *
 * @api public
 */

function jssVendorPrefixer() {
  function onProcessRule(rule) {
    if (rule.type === 'keyframes') {
      var atRule = rule;
      atRule.at = Object(css_vendor__WEBPACK_IMPORTED_MODULE_0__["supportedKeyframes"])(atRule.at);
    }
  }

  function prefixStyle(style) {
    for (var prop in style) {
      var value = style[prop];

      if (prop === 'fallbacks' && Array.isArray(value)) {
        style[prop] = value.map(prefixStyle);
        continue;
      }

      var changeProp = false;
      var supportedProp = Object(css_vendor__WEBPACK_IMPORTED_MODULE_0__["supportedProperty"])(prop);
      if (supportedProp && supportedProp !== prop) changeProp = true;
      var changeValue = false;
      var supportedValue$1 = Object(css_vendor__WEBPACK_IMPORTED_MODULE_0__["supportedValue"])(supportedProp, Object(jss__WEBPACK_IMPORTED_MODULE_1__["toCssValue"])(value));
      if (supportedValue$1 && supportedValue$1 !== value) changeValue = true;

      if (changeProp || changeValue) {
        if (changeProp) delete style[prop];
        style[supportedProp || prop] = supportedValue$1 || value;
      }
    }

    return style;
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;
    return prefixStyle(style);
  }

  function onChangeValue(value, prop) {
    return Object(css_vendor__WEBPACK_IMPORTED_MODULE_0__["supportedValue"])(prop, Object(jss__WEBPACK_IMPORTED_MODULE_1__["toCssValue"])(value)) || value;
  }

  return {
    onProcessRule: onProcessRule,
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssVendorPrefixer);


/***/ }),

/***/ "./node_modules/jss-preset-default/dist/jss-preset-default.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/jss-preset-default/dist/jss-preset-default.esm.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jss_plugin_rule_value_function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jss-plugin-rule-value-function */ "./node_modules/jss-plugin-rule-value-function/dist/jss-plugin-rule-value-function.esm.js");
/* harmony import */ var jss_plugin_rule_value_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss-plugin-rule-value-observable */ "./node_modules/jss-plugin-rule-value-observable/dist/jss-plugin-rule-value-observable.esm.js");
/* harmony import */ var jss_plugin_template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jss-plugin-template */ "./node_modules/jss-plugin-template/dist/jss-plugin-template.esm.js");
/* harmony import */ var jss_plugin_global__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jss-plugin-global */ "./node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js");
/* harmony import */ var jss_plugin_extend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! jss-plugin-extend */ "./node_modules/jss-plugin-extend/dist/jss-plugin-extend.esm.js");
/* harmony import */ var jss_plugin_nested__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jss-plugin-nested */ "./node_modules/jss-plugin-nested/dist/jss-plugin-nested.esm.js");
/* harmony import */ var jss_plugin_compose__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! jss-plugin-compose */ "./node_modules/jss-plugin-compose/dist/jss-plugin-compose.esm.js");
/* harmony import */ var jss_plugin_camel_case__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! jss-plugin-camel-case */ "./node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js");
/* harmony import */ var jss_plugin_default_unit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! jss-plugin-default-unit */ "./node_modules/jss-plugin-default-unit/dist/jss-plugin-default-unit.esm.js");
/* harmony import */ var jss_plugin_expand__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! jss-plugin-expand */ "./node_modules/jss-plugin-expand/dist/jss-plugin-expand.esm.js");
/* harmony import */ var jss_plugin_vendor_prefixer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! jss-plugin-vendor-prefixer */ "./node_modules/jss-plugin-vendor-prefixer/dist/jss-plugin-vendor-prefixer.esm.js");
/* harmony import */ var jss_plugin_props_sort__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! jss-plugin-props-sort */ "./node_modules/jss-plugin-props-sort/dist/jss-plugin-props-sort.esm.js");













var create = function create(options) {
  if (options === void 0) {
    options = {};
  }

  return {
    plugins: [Object(jss_plugin_rule_value_function__WEBPACK_IMPORTED_MODULE_0__["default"])(), Object(jss_plugin_rule_value_observable__WEBPACK_IMPORTED_MODULE_1__["default"])(options.observable), Object(jss_plugin_template__WEBPACK_IMPORTED_MODULE_2__["default"])(), Object(jss_plugin_global__WEBPACK_IMPORTED_MODULE_3__["default"])(), Object(jss_plugin_extend__WEBPACK_IMPORTED_MODULE_4__["default"])(), Object(jss_plugin_nested__WEBPACK_IMPORTED_MODULE_5__["default"])(), Object(jss_plugin_compose__WEBPACK_IMPORTED_MODULE_6__["default"])(), Object(jss_plugin_camel_case__WEBPACK_IMPORTED_MODULE_7__["default"])(), Object(jss_plugin_default_unit__WEBPACK_IMPORTED_MODULE_8__["default"])(options.defaultUnit), Object(jss_plugin_expand__WEBPACK_IMPORTED_MODULE_9__["default"])(), Object(jss_plugin_vendor_prefixer__WEBPACK_IMPORTED_MODULE_10__["default"])(), Object(jss_plugin_props_sort__WEBPACK_IMPORTED_MODULE_11__["default"])()]
  };
};

/* harmony default export */ __webpack_exports__["default"] = (create);


/***/ }),

/***/ "./node_modules/jss/dist/jss.esm.js":
/*!******************************************!*\
  !*** ./node_modules/jss/dist/jss.esm.js ***!
  \******************************************/
/*! exports provided: default, RuleList, SheetsManager, SheetsRegistry, create, createGenerateId, createRule, getDynamicStyles, hasCSSTOMSupport, sheets, toCssValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RuleList", function() { return RuleList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SheetsManager", function() { return SheetsManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SheetsRegistry", function() { return SheetsRegistry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createGenerateId", function() { return createGenerateId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRule", function() { return createRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDynamicStyles", function() { return getDynamicStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasCSSTOMSupport", function() { return hasCSSTOMSupport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sheets", function() { return registry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toCssValue", function() { return toCssValue; });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var is_in_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-in-browser */ "./node_modules/is-in-browser/dist/module.js");
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");








var plainObjectConstrurctor = {}.constructor;
function cloneStyle(style) {
  if (style == null || typeof style !== 'object') return style;
  if (Array.isArray(style)) return style.map(cloneStyle);
  if (style.constructor !== plainObjectConstrurctor) return style;
  var newStyle = {};

  for (var name in style) {
    newStyle[name] = cloneStyle(style[name]);
  }

  return newStyle;
}

/**
 * Create a rule instance.
 */

function createRule(name, decl, options) {
  if (name === void 0) {
    name = 'unnamed';
  }

  var jss = options.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule; // It is an at-rule and it has no instance.

  if (name[0] === '@') {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] Unknown rule " + name) : undefined;
  }

  return null;
}

var join = function join(value, by) {
  var result = '';

  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }

  return result;
};

/**
 * Converts array values to string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */
var toCssValue = function toCssValue(value, ignoreImportant) {
  if (ignoreImportant === void 0) {
    ignoreImportant = false;
  }

  if (!Array.isArray(value)) return value;
  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join(value[i], ' ');
    }
  } else cssValue = join(value, ', '); // Add !important, because it was ignored.


  if (!ignoreImportant && value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
};

/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */
function indentStr(str, indent) {
  var result = '';

  for (var index = 0; index < indent; index++) {
    result += '  ';
  }

  return result + str;
}
/**
 * Converts a Rule to CSS string.
 */


function toCss(selector, style, options) {
  if (options === void 0) {
    options = {};
  }

  var result = '';
  if (!style) return result;
  var _options = options,
      _options$indent = _options.indent,
      indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style.fallbacks;
  if (selector) indent++; // Apply fallbacks first.

  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];

        for (var prop in fallback) {
          var value = fallback[prop];

          if (value != null) {
            if (result) result += '\n';
            result += indentStr(prop + ": " + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      // Object syntax {fallbacks: {prop: value}}
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];

        if (_value != null) {
          if (result) result += '\n';
          result += indentStr(_prop + ": " + toCssValue(_value) + ";", indent);
        }
      }
    }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];

    if (_value2 != null && _prop2 !== 'fallbacks') {
      if (result) result += '\n';
      result += indentStr(_prop2 + ": " + toCssValue(_value2) + ";", indent);
    }
  } // Allow empty style in this case, because properties will be added dynamically.


  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

  if (!selector) return result;
  indent--;
  if (result) result = "\n" + result + "\n";
  return indentStr(selector + " {" + result, indent) + indentStr('}', indent);
}

var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
var escape = (function (str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
});

var BaseStyleRule =
/*#__PURE__*/
function () {
  function BaseStyleRule(key, style, options) {
    this.type = 'style';
    this.key = void 0;
    this.isProcessed = false;
    this.style = void 0;
    this.renderer = void 0;
    this.renderable = void 0;
    this.options = void 0;
    var sheet = options.sheet,
        Renderer = options.Renderer;
    this.key = key;
    this.options = options;
    this.style = style;
    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
  }
  /**
   * Get or set a style property.
   */


  var _proto = BaseStyleRule.prototype;

  _proto.prop = function prop(name, value, options) {
    // It's a getter.
    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

    var force = options ? options.force : false;
    if (!force && this.style[name] === value) return this;
    var newValue = value;

    if (!options || options.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
    }

    var isEmpty = newValue == null || newValue === false;
    var isDefined = name in this.style; // Value is empty and wasn't defined before.

    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

    var remove = isEmpty && isDefined;
    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

    if (this.renderable && this.renderer) {
      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
      return this;
    }

    var sheet = this.options.sheet;

    if (sheet && sheet.attached) {
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, '[JSS] Rule is not linked. Missing sheet option "link: true".') : undefined;
    }

    return this;
  };

  return BaseStyleRule;
}();
var StyleRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_4__["default"])(StyleRule, _BaseStyleRule);

  function StyleRule(key, style, options) {
    var _this;

    _this = _BaseStyleRule.call(this, key, style, options) || this;
    _this.selectorText = void 0;
    _this.id = void 0;
    _this.renderable = void 0;
    var selector = options.selector,
        scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;

    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__["default"])(_this)), sheet);
      _this.selectorText = "." + escape(_this.id);
    }

    return _this;
  }
  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  var _proto2 = StyleRule.prototype;

  /**
   * Apply rule to an element inline.
   */
  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;

    if (renderer) {
      var json = this.toJSON();

      for (var prop in json) {
        renderer.setProperty(renderable, prop, json[prop]);
      }
    }

    return this;
  }
  /**
   * Returns JSON representation of the rule.
   * Fallbacks are not supported.
   * Useful for inline styles.
   */
  ;

  _proto2.toJSON = function toJSON() {
    var json = {};

    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
    }

    return json;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto2.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.selectorText, this.style, opts);
  };

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(StyleRule, [{
    key: "selector",
    set: function set(selector) {
      if (selector === this.selectorText) return;
      this.selectorText = selector;
      var renderer = this.renderer,
          renderable = this.renderable;
      if (!renderable || !renderer) return;
      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    }
    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}(BaseStyleRule);
var pluginStyleRule = {
  onCreateRule: function onCreateRule(name, style, options) {
    if (name[0] === '@' || options.parent && options.parent.type === 'keyframes') {
      return null;
    }

    return new StyleRule(name, style, options);
  }
};

var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
/**
 * Conditional rule for @media, @supports
 */

var ConditionalRule =
/*#__PURE__*/
function () {
  function ConditionalRule(key, styles, options) {
    this.type = 'conditional';
    this.at = void 0;
    this.key = void 0;
    this.query = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    var atMatch = key.match(atRegExp);
    this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

    this.query = options.name || "@" + this.at;
    this.options = options;
    this.rules = new RuleList(Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = ConditionalRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions;
    }

    if (options.indent == null) options.indent = defaultToStringOptions.indent;
    if (options.children == null) options.children = defaultToStringOptions.children;

    if (options.children === false) {
      return this.query + " {}";
    }

    var children = this.rules.toString(options);
    return children ? this.query + " {\n" + children + "\n}" : '';
  };

  return ConditionalRule;
}();
var keyRegExp = /@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule(key, styles, options) {
    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
  }
};

var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
/**
 * Rule for @keyframes
 */

var KeyframesRule =
/*#__PURE__*/
function () {
  function KeyframesRule(key, frames, options) {
    this.type = 'keyframes';
    this.at = '@keyframes';
    this.key = void 0;
    this.name = void 0;
    this.id = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    var nameMatch = key.match(nameRegExp);

    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = 'noname';
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] Bad keyframes name " + key) : undefined;
    }

    this.key = this.type + "-" + this.name;
    this.options = options;
    var scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;
    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
    this.rules = new RuleList(Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));

    for (var name in frames) {
      this.rules.add(name, frames[name], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
        parent: this
      }));
    }

    this.rules.process();
  }
  /**
   * Generates a CSS string.
   */


  var _proto = KeyframesRule.prototype;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions$1;
    }

    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
    if (options.children == null) options.children = defaultToStringOptions$1.children;

    if (options.children === false) {
      return this.at + " " + this.id + " {}";
    }

    var children = this.rules.toString(options);
    if (children) children = "\n" + children + "\n";
    return this.at + " " + this.id + " {" + children + "}";
  };

  return KeyframesRule;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp = /\$([\w-]+)/g;

var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
  if (typeof val === 'string') {
    return val.replace(refRegExp, function (match, name) {
      if (name in keyframes) {
        return keyframes[name];
      }

       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] Referenced keyframes rule \"" + name + "\" is not defined.") : undefined;
      return match;
    });
  }

  return val;
};
/**
 * Replace the reference for a animation name.
 */


var replaceRef = function replaceRef(style, prop, keyframes) {
  var value = style[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes);

  if (refKeyframe !== value) {
    style[prop] = refKeyframe;
  }
};

var plugin = {
  onCreateRule: function onCreateRule(key, frames, options) {
    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style' || !sheet) return style;
    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
    return style;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;

    if (!sheet) {
      return val;
    }

    switch (prop) {
      case 'animation':
        return findReferencedKeyframe(val, sheet.keyframes);

      case 'animation-name':
        return findReferencedKeyframe(val, sheet.keyframes);

      default:
        return val;
    }
  }
};

var KeyframeRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_4__["default"])(KeyframeRule, _BaseStyleRule);

  function KeyframeRule() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BaseStyleRule.call.apply(_BaseStyleRule, [this].concat(args)) || this;
    _this.renderable = void 0;
    return _this;
  }

  var _proto = KeyframeRule.prototype;

  /**
   * Generates a CSS string.
   */
  _proto.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.key, this.style, opts);
  };

  return KeyframeRule;
}(BaseStyleRule);
var pluginKeyframeRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (options.parent && options.parent.type === 'keyframes') {
      return new KeyframeRule(key, style, options);
    }

    return null;
  }
};

var FontFaceRule =
/*#__PURE__*/
function () {
  function FontFaceRule(key, style, options) {
    this.type = 'font-face';
    this.at = '@font-face';
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = FontFaceRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.style)) {
      var str = '';

      for (var index = 0; index < this.style.length; index++) {
        str += toCss(this.at, this.style[index]);
        if (this.style[index + 1]) str += '\n';
      }

      return str;
    }

    return toCss(this.at, this.style, options);
  };

  return FontFaceRule;
}();
var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
  }
};

var ViewportRule =
/*#__PURE__*/
function () {
  function ViewportRule(key, style, options) {
    this.type = 'viewport';
    this.at = '@viewport';
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = ViewportRule.prototype;

  _proto.toString = function toString(options) {
    return toCss(this.key, this.style, options);
  };

  return ViewportRule;
}();
var pluginViewportRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
  }
};

var SimpleRule =
/*#__PURE__*/
function () {
  function SimpleRule(key, value, options) {
    this.type = 'simple';
    this.key = void 0;
    this.value = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.value = value;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  var _proto = SimpleRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.value)) {
      var str = '';

      for (var index = 0; index < this.value.length; index++) {
        str += this.key + " " + this.value[index] + ";";
        if (this.value[index + 1]) str += '\n';
      }

      return str;
    }

    return this.key + " " + this.value + ";";
  };

  return SimpleRule;
}();
var keysMap = {
  '@charset': true,
  '@import': true,
  '@namespace': true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule(key, value, options) {
    return key in keysMap ? new SimpleRule(key, value, options) : null;
  }
};

var plugins = [pluginStyleRule, pluginConditionalRule, plugin, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];

var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */

};

var RuleList =
/*#__PURE__*/
function () {
  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.
  // Original styles object.
  // Used to ensure correct rules order.
  function RuleList(options) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.counter = 0;
    this.options = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.options = options;
    this.classes = options.classes;
    this.keyframes = options.keyframes;
  }
  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  var _proto = RuleList.prototype;

  _proto.add = function add(name, decl, ruleOptions) {
    var _this$options = this.options,
        parent = _this$options.parent,
        sheet = _this$options.sheet,
        jss = _this$options.jss,
        Renderer = _this$options.Renderer,
        generateId = _this$options.generateId,
        scoped = _this$options.scoped;

    var options = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
      classes: this.classes,
      parent: parent,
      sheet: sheet,
      jss: jss,
      Renderer: Renderer,
      generateId: generateId,
      scoped: scoped,
      name: name,
      keyframes: this.keyframes,
      selector: undefined
    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
    // we need to make the key unique within this RuleList instance scope.


    var key = name;

    if (name in this.raw) {
      key = name + "-d" + this.counter++;
    } // We need to save the original decl before creating the rule
    // because cache plugin needs to use it as a key to return a cached rule.


    this.raw[key] = decl;

    if (key in this.classes) {
      // E.g. rules inside of @media container
      options.selector = "." + escape(this.classes[key]);
    }

    var rule = createRule(key, decl, options);
    if (!rule) return null;
    this.register(rule);
    var index = options.index === undefined ? this.index.length : options.index;
    this.index.splice(index, 0, rule);
    return rule;
  }
  /**
   * Get a rule.
   */
  ;

  _proto.get = function get(name) {
    return this.map[name];
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.remove = function remove(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.index.indexOf(rule), 1);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.index.indexOf(rule);
  }
  /**
   * Run `onProcessRule()` plugins on every rule.
   */
  ;

  _proto.process = function process() {
    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
    // we end up with very hard-to-track-down side effects.

    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
  }
  /**
   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
   */
  ;

  _proto.register = function register(rule) {
    this.map[rule.key] = rule;

    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id) this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  }
  /**
   * Unregister a rule.
   */
  ;

  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];

    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var name;
    var data;
    var options;

    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      name = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe[invalid-tuple-index]

      data = arguments.length <= 1 ? undefined : arguments[1]; // $FlowFixMe[invalid-tuple-index]

      options = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      data = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe[invalid-tuple-index]

      options = arguments.length <= 1 ? undefined : arguments[1];
      name = null;
    }

    if (name) {
      this.updateOne(this.map[name], data, options);
    } else {
      for (var index = 0; index < this.index.length; index++) {
        this.updateOne(this.index[index], data, options);
      }
    }
  }
  /**
   * Execute plugins, update rule props.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    if (options === void 0) {
      options = defaultUpdateOptions;
    }

    var _this$options2 = this.options,
        plugins = _this$options2.jss.plugins,
        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

    if (rule.rules instanceof RuleList) {
      rule.rules.update(data, options);
      return;
    }

    var styleRule = rule;
    var style = styleRule.style;
    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

    if (options.process && style && style !== styleRule.style) {
      // We need to run the plugins in case new `style` relies on syntax plugins.
      plugins.onProcessStyle(styleRule.style, styleRule, sheet); // Update and add props.

      for (var prop in styleRule.style) {
        var nextValue = styleRule.style[prop];
        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (nextValue !== prevValue) {
          styleRule.prop(prop, nextValue, forceUpdateOptions);
        }
      } // Remove props.


      for (var _prop in style) {
        var _nextValue = styleRule.style[_prop];
        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (_nextValue == null && _nextValue !== _prevValue) {
          styleRule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    var str = '';
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;

    for (var index = 0; index < this.index.length; index++) {
      var rule = this.index[index];
      var css = rule.toString(options); // No need to render an empty rule.

      if (!css && !link) continue;
      if (str) str += '\n';
      str += css;
    }

    return str;
  };

  return RuleList;
}();

var StyleSheet =
/*#__PURE__*/
function () {
  function StyleSheet(styles, options) {
    this.options = void 0;
    this.deployed = void 0;
    this.attached = void 0;
    this.rules = void 0;
    this.renderer = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.queue = void 0;
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });

    if (options.Renderer) {
      this.renderer = new options.Renderer(this);
    }

    this.rules = new RuleList(this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Attach renderable to the render tree.
   */


  var _proto = StyleSheet.prototype;

  _proto.attach = function attach() {
    if (this.attached) return this;
    if (this.renderer) this.renderer.attach();
    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

    if (!this.deployed) this.deploy();
    return this;
  }
  /**
   * Remove renderable from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.attached) return this;
    if (this.renderer) this.renderer.detach();
    this.attached = false;
    return this;
  }
  /**
   * Add a rule to the current stylesheet.
   * Will insert a rule also after the stylesheet has been rendered first time.
   */
  ;

  _proto.addRule = function addRule(name, decl, options) {
    var queue = this.queue; // Plugins can create rules.
    // In order to preserve the right order, we need to queue all `.addRule` calls,
    // which happen after the first `rules.add()` call.

    if (this.attached && !queue) this.queue = [];
    var rule = this.rules.add(name, decl, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);

    if (this.attached) {
      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (queue) queue.push(rule);else {
        this.insertRule(rule);

        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = undefined;
        }
      }
      return rule;
    } // We can't add rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return rule;
  }
  /**
   * Insert rule into the StyleSheet
   */
  ;

  _proto.insertRule = function insertRule(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  }
  /**
   * Create and add rules.
   * Will render also after Style Sheet was rendered the first time.
   */
  ;

  _proto.addRules = function addRules(styles, options) {
    var added = [];

    for (var name in styles) {
      var rule = this.addRule(name, styles[name], options);
      if (rule) added.push(rule);
    }

    return added;
  }
  /**
   * Get a rule by name.
   */
  ;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Delete a rule by name.
   * Returns `true`: if rule has been deleted from the DOM.
   */
  ;

  _proto.deleteRule = function deleteRule(name) {
    var rule = typeof name === 'object' ? name : this.rules.get(name);

    if (!rule || // Style sheet was created without link: true and attached, in this case we
    // won't be able to remove the CSS rule from the DOM.
    this.attached && !rule.renderable) {
      return false;
    }

    this.rules.remove(rule);

    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }

    return true;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Deploy pure CSS string to a renderable.
   */
  ;

  _proto.deploy = function deploy() {
    if (this.renderer) this.renderer.deploy();
    this.deployed = true;
    return this;
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var _this$rules;

    (_this$rules = this.rules).update.apply(_this$rules, arguments);

    return this;
  }
  /**
   * Updates a single rule.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    this.rules.updateOne(rule, data, options);
    return this;
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return StyleSheet;
}();

var PluginsRegistry =
/*#__PURE__*/
function () {
  function PluginsRegistry() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = void 0;
  }

  var _proto = PluginsRegistry.prototype;

  /**
   * Call `onCreateRule` hooks and return an object if returned by a hook.
   */
  _proto.onCreateRule = function onCreateRule(name, decl, options) {
    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
      var rule = this.registry.onCreateRule[i](name, decl, options);
      if (rule) return rule;
    }

    return null;
  }
  /**
   * Call `onProcessRule` hooks.
   */
  ;

  _proto.onProcessRule = function onProcessRule(rule) {
    if (rule.isProcessed) return;
    var sheet = rule.options.sheet;

    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
      this.registry.onProcessRule[i](rule, sheet);
    }

    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  }
  /**
   * Call `onProcessStyle` hooks.
   */
  ;

  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
      // $FlowFixMe[prop-missing]
      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    }
  }
  /**
   * Call `onProcessSheet` hooks.
   */
  ;

  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
      this.registry.onProcessSheet[i](sheet);
    }
  }
  /**
   * Call `onUpdate` hooks.
   */
  ;

  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
    for (var i = 0; i < this.registry.onUpdate.length; i++) {
      this.registry.onUpdate[i](data, rule, sheet, options);
    }
  }
  /**
   * Call `onChangeValue` hooks.
   */
  ;

  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
    var processedValue = value;

    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
    }

    return processedValue;
  }
  /**
   * Register a plugin.
   */
  ;

  _proto.use = function use(newPlugin, options) {
    if (options === void 0) {
      options = {
        queue: 'external'
      };
    }

    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

    if (plugins.indexOf(newPlugin) !== -1) {
      return;
    }

    plugins.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
      for (var name in plugin) {
        if (name in registry) {
          registry[name].push(plugin[name]);
        } else {
           true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] Unknown hook \"" + name + "\".") : undefined;
        }
      }

      return registry;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };

  return PluginsRegistry;
}();

/**
 * Sheets registry to access them all at one place.
 */
var SheetsRegistry =
/*#__PURE__*/
function () {
  function SheetsRegistry() {
    this.registry = [];
  }

  var _proto = SheetsRegistry.prototype;

  /**
   * Register a Style Sheet.
   */
  _proto.add = function add(sheet) {
    var registry = this.registry;
    var index = sheet.options.index;
    if (registry.indexOf(sheet) !== -1) return;

    if (registry.length === 0 || index >= this.index) {
      registry.push(sheet);
      return;
    } // Find a position.


    for (var i = 0; i < registry.length; i++) {
      if (registry[i].options.index > index) {
        registry.splice(i, 0, sheet);
        return;
      }
    }
  }
  /**
   * Reset the registry.
   */
  ;

  _proto.reset = function reset() {
    this.registry = [];
  }
  /**
   * Remove a Style Sheet.
   */
  ;

  _proto.remove = function remove(sheet) {
    var index = this.registry.indexOf(sheet);
    this.registry.splice(index, 1);
  }
  /**
   * Convert all attached sheets to a CSS string.
   */
  ;

  _proto.toString = function toString(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        attached = _ref.attached,
        options = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_6__["default"])(_ref, ["attached"]);

    var css = '';

    for (var i = 0; i < this.registry.length; i++) {
      var sheet = this.registry[i];

      if (attached != null && sheet.attached !== attached) {
        continue;
      }

      if (css) css += '\n';
      css += sheet.toString(options);
    }

    return css;
  };

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(SheetsRegistry, [{
    key: "index",

    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();

/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */

var registry = new SheetsRegistry();

/* eslint-disable */

/**
 * Now that `globalThis` is available on most platforms
 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
 * we check for `globalThis` first. `globalThis` is necessary for jss
 * to run in Agoric's secure version of JavaScript (SES). Under SES,
 * `globalThis` exists, but `window`, `self`, and `Function('return
 * this')()` are all undefined for security reasons.
 *
 * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
 */
var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();

var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.

var moduleId = globalThis$1[ns]++;

var maxRules = 1e10;

/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */
var createGenerateId = function createGenerateId(options) {
  if (options === void 0) {
    options = {};
  }

  var ruleCounter = 0;

  var generateId = function generateId(rule, sheet) {
    ruleCounter += 1;

    if (ruleCounter > maxRules) {
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] You might have a memory leak. Rule counter is at " + ruleCounter + ".") : undefined;
    }

    var jssId = '';
    var prefix = '';

    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix = sheet.options.classNamePrefix;
      }

      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }

    if (options.minify) {
      // Using "c" because a number can't be the first char in a class name.
      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
    }

    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
  };

  return generateId;
};

/**
 * Cache the value from the first time a function is called.
 */
var memoize = function memoize(fn) {
  var value;
  return function () {
    if (!value) value = fn();
    return value;
  };
};

/**
 * Get a style property value.
 */
var getPropertyValue = function getPropertyValue(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }

    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
};

/**
 * Set a style property.
 */
var setProperty = function setProperty(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = toCssValue(value, true);

      if (value[value.length - 1] === '!important') {
        cssRule.style.setProperty(prop, cssValue, 'important');
        return true;
      }
    } // Support CSSTOM.


    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      cssRule.style.setProperty(prop, cssValue);
    }
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }

  return true;
};

/**
 * Remove a style property.
 */
var removeProperty = function removeProperty(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] DOMException \"" + err.message + "\" was thrown. Tried to remove property \"" + prop + "\".") : undefined;
  }
};

/**
 * Set the selector.
 */
var setSelector = function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText; // Return false if setter was not successful.
  // Currently works in chrome only.

  return cssRule.selectorText === selectorText;
};
/**
 * Gets the `head` element upon the first call and caches it.
 * We assume it can't be null.
 */


var getHead = memoize(function () {
  return document.querySelector('head');
});
/**
 * Find attached sheet with an index higher than the passed one.
 */

function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find attached sheet with the highest index.
 */


function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find a comment with "jss" inside.
 */


function findCommentNode(text) {
  var head = getHead();

  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];

    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }

  return null;
}

/**
 * Find a node before which we can insert the sheet.
 */
function findPrevNode(options) {
  var registry$1 = registry.registry;

  if (registry$1.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry$1, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    } // Otherwise insert after the last attached.


    sheet = findHighestSheet(registry$1, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  } // Try to find a comment placeholder if registry is empty.


  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);

    if (comment) {
      return {
        parent: comment.parentNode,
        node: comment.nextSibling
      };
    } // If user specifies an insertion point and it can't be found in the document -
    // bad specificity issues may appear.


     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] Insertion point \"" + insertionPoint + "\" not found.") : undefined;
  }

  return false;
}
/**
 * Insert style element into the DOM.
 */


function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;
  var nextNode = findPrevNode(options);

  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style, nextNode.node);
    return;
  } // Works with iframes and any node types.


  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    // https://stackoverflow.com/questions/41328728/force-casting-in-flow
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);else  true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, '[JSS] Insertion point is not in the DOM.') : undefined;
    return;
  }

  getHead().appendChild(style);
}
/**
 * Read jss nonce setting from the page if the user has set it.
 */


var getNonce = memoize(function () {
  var node = document.querySelector('meta[property="csp-nonce"]');
  return node ? node.getAttribute('content') : null;
});

var _insertRule = function insertRule(container, rule, index) {
  try {
    if ('insertRule' in container) {
      var c = container;
      c.insertRule(rule, index);
    } // Keyframes rule.
    else if ('appendRule' in container) {
        var _c = container;

        _c.appendRule(rule);
      }
  } catch (err) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] " + err.message) : undefined;
    return false;
  }

  return container.cssRules[index];
};

var getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

  if (index === undefined || index > maxIndex) {
    // eslint-disable-next-line no-param-reassign
    return maxIndex;
  }

  return index;
};

var createStyle = function createStyle() {
  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
  // insert rules after we insert the style tag.
  // It seems to kick-off the source order specificity algorithm.

  el.textContent = '\n';
  return el;
};

var DomRenderer =
/*#__PURE__*/
function () {
  // HTMLStyleElement needs fixing https://github.com/facebook/flow/issues/2696
  // Will be empty if link: true option is not set, because
  // it is only for use together with insertRule API.
  function DomRenderer(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.element = void 0;
    this.sheet = void 0;
    this.hasInsertedRules = false;
    this.cssRules = [];
    // There is no sheet when the renderer is used from a standalone StyleRule.
    if (sheet) registry.add(sheet);
    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || createStyle();
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    var nonce = getNonce();
    if (nonce) this.element.setAttribute('nonce', nonce);
  }
  /**
   * Insert style element into render tree.
   */


  var _proto = DomRenderer.prototype;

  _proto.attach = function attach() {
    // In the case the element node is external and it is already in the DOM.
    if (this.element.parentNode || !this.sheet) return;
    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
    // most browsers create a new CSSStyleSheet, except of all IEs.

    var deployed = Boolean(this.sheet && this.sheet.deployed);

    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  }
  /**
   * Remove style element from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.sheet) return;
    var parentNode = this.element.parentNode;
    if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
    // Though IE will keep them and we need a consistent behavior.

    if (this.sheet.options.link) {
      this.cssRules = [];
      this.element.textContent = '\n';
    }
  }
  /**
   * Inject CSS string into element.
   */
  ;

  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet) return;

    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }

    this.element.textContent = "\n" + sheet.toString() + "\n";
  }
  /**
   * Insert RuleList into an element.
   */
  ;

  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i = 0; i < rules.index.length; i++) {
      this.insertRule(rules.index[i], i, nativeParent);
    }
  }
  /**
   * Insert a rule into element.
   */
  ;

  _proto.insertRule = function insertRule(rule, index, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }

    if (rule.rules) {
      var parent = rule;
      var latestNativeParent = nativeParent;

      if (rule.type === 'conditional' || rule.type === 'keyframes') {
        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.


        latestNativeParent = _insertRule(nativeParent, parent.toString({
          children: false
        }), _insertionIndex);

        if (latestNativeParent === false) {
          return false;
        }

        this.refCssRule(rule, _insertionIndex, latestNativeParent);
      }

      this.insertRules(parent.rules, latestNativeParent);
      return latestNativeParent;
    }

    var ruleStr = rule.toString();
    if (!ruleStr) return false;
    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);

    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);

    if (nativeRule === false) {
      return false;
    }

    this.hasInsertedRules = true;
    this.refCssRule(rule, insertionIndex, nativeRule);
    return nativeRule;
  };

  _proto.refCssRule = function refCssRule(rule, index, cssRule) {
    rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
    // like rules inside media queries or keyframes

    if (rule.options.parent instanceof StyleSheet) {
      this.cssRules[index] = cssRule;
    }
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return true;
  }
  /**
   * Get index of a CSS Rule.
   */
  ;

  _proto.indexOf = function indexOf(cssRule) {
    return this.cssRules.indexOf(cssRule);
  }
  /**
   * Generate a new CSS rule and replace the existing one.
   *
   * Only used for some old browsers because they can't set a selector.
   */
  ;

  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    this.element.sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return this.insertRule(rule, index);
  }
  /**
   * Get all rules elements.
   */
  ;

  _proto.getRules = function getRules() {
    return this.element.sheet.cssRules;
  };

  return DomRenderer;
}();

var instanceCounter = 0;

var Jss =
/*#__PURE__*/
function () {
  function Jss(options) {
    this.id = instanceCounter++;
    this.version = "10.7.1";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId: createGenerateId,
      Renderer: is_in_browser__WEBPACK_IMPORTED_MODULE_1__["default"] ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });

    for (var i = 0; i < plugins.length; i++) {
      this.plugins.use(plugins[i], {
        queue: 'internal'
      });
    }

    this.setup(options);
  }
  /**
   * Prepares various options, applies plugins.
   * Should not be used twice on the same instance, because there is no plugins
   * deduplication logic.
   */


  var _proto = Jss.prototype;

  _proto.setup = function setup(options) {
    if (options === void 0) {
      options = {};
    }

    if (options.createGenerateId) {
      this.options.createGenerateId = options.createGenerateId;
    }

    if (options.id) {
      this.options.id = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, this.options.id, options.id);
    }

    if (options.createGenerateId || options.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }

    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

    if ('Renderer' in options) {
      this.options.Renderer = options.Renderer;
    } // eslint-disable-next-line prefer-spread


    if (options.plugins) this.use.apply(this, options.plugins);
    return this;
  }
  /**
   * Create a Style Sheet.
   */
  ;

  _proto.createStyleSheet = function createStyleSheet(styles, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        index = _options.index;

    if (typeof index !== 'number') {
      index = registry.index === 0 ? 0 : registry.index + 1;
    }

    var sheet = new StyleSheet(styles, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      jss: this,
      generateId: options.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  }
  /**
   * Detach the Style Sheet and remove it from the registry.
   */
  ;

  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    registry.remove(sheet);
    return this;
  }
  /**
   * Create a rule without a Style Sheet.
   * [Deprecated] will be removed in the next major version.
   */
  ;

  _proto.createRule = function createRule$1(name, style, options) {
    if (style === void 0) {
      style = {};
    }

    if (options === void 0) {
      options = {};
    }

    // Enable rule without name for inline styles.
    if (typeof name === 'object') {
      // $FlowFixMe[incompatible-call]
      return this.createRule(undefined, name, style);
    } // $FlowFixMe[incompatible-type]


    var ruleOptions = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      name: name,
      jss: this,
      Renderer: this.options.Renderer
    });

    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes) ruleOptions.classes = {};
    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};

    var rule = createRule(name, style, ruleOptions);

    if (rule) this.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Register plugin. Passed function will be invoked with a rule instance.
   */
  ;

  _proto.use = function use() {
    var _this = this;

    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    plugins.forEach(function (plugin) {
      _this.plugins.use(plugin);
    });
    return this;
  };

  return Jss;
}();

/**
 * Extracts a styles object with only props that contain function values.
 */
function getDynamicStyles(styles) {
  var to = null;

  for (var key in styles) {
    var value = styles[key];
    var type = typeof value;

    if (type === 'function') {
      if (!to) to = {};
      to[key] = value;
    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);

      if (extracted) {
        if (!to) to = {};
        to[key] = extracted;
      }
    }
  }

  return to;
}

/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 */
var SheetsManager =
/*#__PURE__*/
function () {
  function SheetsManager() {
    this.length = 0;
    this.sheets = new WeakMap();
  }

  var _proto = SheetsManager.prototype;

  _proto.get = function get(key) {
    var entry = this.sheets.get(key);
    return entry && entry.sheet;
  };

  _proto.add = function add(key, sheet) {
    if (this.sheets.has(key)) return;
    this.length++;
    this.sheets.set(key, {
      sheet: sheet,
      refs: 0
    });
  };

  _proto.manage = function manage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs === 0) {
        entry.sheet.attach();
      }

      entry.refs++;
      return entry.sheet;
    }

    Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] SheetsManager: can't find sheet to manage");
    return undefined;
  };

  _proto.unmanage = function unmanage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs > 0) {
        entry.refs--;
        if (entry.refs === 0) entry.sheet.detach();
      }
    } else {
      Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "SheetsManager: can't find sheet to unmanage");
    }
  };

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(SheetsManager, [{
    key: "size",
    get: function get() {
      return this.length;
    }
  }]);

  return SheetsManager;
}();

/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */

/**
 * Export a constant indicating if this browser has CSSTOM support.
 * https://developers.google.com/web/updates/2018/03/cssom
 */
var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;
/**
 * Creates a new instance of Jss.
 */

var create = function create(options) {
  return new Jss(options);
};
/**
 * A global Jss instance.
 */

var jss = create();

/* harmony default export */ __webpack_exports__["default"] = (jss);



/***/ }),

/***/ "./node_modules/precond/index.js":
/*!***************************************!*\
  !*** ./node_modules/precond/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright (c) 2012 Mathieu Turcotte
 * Licensed under the MIT license.
 */

module.exports = __webpack_require__(/*! ./lib/checks */ "./node_modules/precond/lib/checks.js");

/***/ }),

/***/ "./node_modules/precond/lib/checks.js":
/*!********************************************!*\
  !*** ./node_modules/precond/lib/checks.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright (c) 2012 Mathieu Turcotte
 * Licensed under the MIT license.
 */

var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

var errors = module.exports = __webpack_require__(/*! ./errors */ "./node_modules/precond/lib/errors.js");

function failCheck(ExceptionConstructor, callee, messageFormat, formatArgs) {
    messageFormat = messageFormat || '';
    var message = util.format.apply(this, [messageFormat].concat(formatArgs));
    var error = new ExceptionConstructor(message);
    Error.captureStackTrace(error, callee);
    throw error;
}

function failArgumentCheck(callee, message, formatArgs) {
    failCheck(errors.IllegalArgumentError, callee, message, formatArgs);
}

function failStateCheck(callee, message, formatArgs) {
    failCheck(errors.IllegalStateError, callee, message, formatArgs);
}

module.exports.checkArgument = function(value, message) {
    if (!value) {
        failArgumentCheck(arguments.callee, message,
            Array.prototype.slice.call(arguments, 2));
    }
};

module.exports.checkState = function(value, message) {
    if (!value) {
        failStateCheck(arguments.callee, message,
            Array.prototype.slice.call(arguments, 2));
    }
};

module.exports.checkIsDef = function(value, message) {
    if (value !== undefined) {
        return value;
    }

    failArgumentCheck(arguments.callee, message ||
        'Expected value to be defined but was undefined.',
        Array.prototype.slice.call(arguments, 2));
};

module.exports.checkIsDefAndNotNull = function(value, message) {
    // Note that undefined == null.
    if (value != null) {
        return value;
    }

    failArgumentCheck(arguments.callee, message ||
        'Expected value to be defined and not null but got "' +
        typeOf(value) + '".', Array.prototype.slice.call(arguments, 2));
};

// Fixed version of the typeOf operator which returns 'null' for null values
// and 'array' for arrays.
function typeOf(value) {
    var s = typeof value;
    if (s == 'object') {
        if (!value) {
            return 'null';
        } else if (value instanceof Array) {
            return 'array';
        }
    }
    return s;
}

function typeCheck(expect) {
    return function(value, message) {
        var type = typeOf(value);

        if (type == expect) {
            return value;
        }

        failArgumentCheck(arguments.callee, message ||
            'Expected "' + expect + '" but got "' + type + '".',
            Array.prototype.slice.call(arguments, 2));
    };
}

module.exports.checkIsString = typeCheck('string');
module.exports.checkIsArray = typeCheck('array');
module.exports.checkIsNumber = typeCheck('number');
module.exports.checkIsBoolean = typeCheck('boolean');
module.exports.checkIsFunction = typeCheck('function');
module.exports.checkIsObject = typeCheck('object');


/***/ }),

/***/ "./node_modules/precond/lib/errors.js":
/*!********************************************!*\
  !*** ./node_modules/precond/lib/errors.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright (c) 2012 Mathieu Turcotte
 * Licensed under the MIT license.
 */

var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

function IllegalArgumentError(message) {
    Error.call(this, message);
    this.message = message;
}
util.inherits(IllegalArgumentError, Error);

IllegalArgumentError.prototype.name = 'IllegalArgumentError';

function IllegalStateError(message) {
    Error.call(this, message);
    this.message = message;
}
util.inherits(IllegalStateError, Error);

IllegalStateError.prototype.name = 'IllegalStateError';

module.exports.IllegalStateError = IllegalStateError;
module.exports.IllegalArgumentError = IllegalArgumentError;

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/symbol-observable/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/symbol-observable/es/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ "./node_modules/symbol-observable/es/ponyfill.js");
/* global window */


var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {}

var result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__["default"])(root);
/* harmony default export */ __webpack_exports__["default"] = (result);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/symbol-observable/es/ponyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/symbol-observable/es/ponyfill.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return symbolObservablePonyfill; });
function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};


/***/ }),

/***/ "./node_modules/tiny-warning/dist/tiny-warning.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/tiny-warning/dist/tiny-warning.esm.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var isProduction = "development" === 'production';
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

/* harmony default export */ __webpack_exports__["default"] = (warning);


/***/ }),

/***/ "./node_modules/twilio-video/es5/cancelableroompromise.js":
/*!****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/cancelableroompromise.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var CancelablePromise = __webpack_require__(/*! ./util/cancelablepromise */ "./node_modules/twilio-video/es5/util/cancelablepromise.js");
/**
 * Create a {@link CancelablePromise<Room>}.
 * @param {function(function(Array<LocalTrack>): CancelablePromise<RoomSignaling>):
 *   Promise<function(): CancelablePromise<RoomSignaling>>} getLocalTracks
 * @param {function(Array<LocalTrack>): LocalParticipant} createLocalParticipant
 * @param {function(Array<LocalTrack>): CancelablePromise<RoomSignaling>} createRoomSignaling
 * @param {function(LocalParticipant, RoomSignaling): Room} createRoom
 * @returns CancelablePromise<Room>
 */
function createCancelableRoomPromise(getLocalTracks, createLocalParticipant, createRoomSignaling, createRoom) {
    var cancelableRoomSignalingPromise;
    var cancellationError = new Error('Canceled');
    return new CancelablePromise(function onCreate(resolve, reject, isCanceled) {
        var localParticipant;
        getLocalTracks(function getLocalTracksSucceeded(localTracks) {
            if (isCanceled()) {
                return CancelablePromise.reject(cancellationError);
            }
            localParticipant = createLocalParticipant(localTracks);
            return createRoomSignaling(localParticipant).then(function createRoomSignalingSucceeded(getCancelableRoomSignalingPromise) {
                if (isCanceled()) {
                    throw cancellationError;
                }
                cancelableRoomSignalingPromise = getCancelableRoomSignalingPromise();
                return cancelableRoomSignalingPromise;
            });
        }).then(function roomSignalingConnected(roomSignaling) {
            if (isCanceled()) {
                roomSignaling.disconnect();
                throw cancellationError;
            }
            resolve(createRoom(localParticipant, roomSignaling));
        }).catch(function onError(error) {
            reject(error);
        });
    }, function onCancel() {
        if (cancelableRoomSignalingPromise) {
            cancelableRoomSignalingPromise.cancel();
        }
    });
}
module.exports = createCancelableRoomPromise;
//# sourceMappingURL=cancelableroompromise.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/connect.js":
/*!**************************************************!*\
  !*** ./node_modules/twilio-video/es5/connect.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var MediaStreamTrack = __webpack_require__(/*! ./webrtc */ "./node_modules/twilio-video/es5/webrtc/index.js").MediaStreamTrack;
var _a = __webpack_require__(/*! ./webrtc/util */ "./node_modules/twilio-video/es5/webrtc/util/index.js"), guessBrowser = _a.guessBrowser, guessBrowserVersion = _a.guessBrowserVersion;
var createCancelableRoomPromise = __webpack_require__(/*! ./cancelableroompromise */ "./node_modules/twilio-video/es5/cancelableroompromise.js");
var EncodingParametersImpl = __webpack_require__(/*! ./encodingparameters */ "./node_modules/twilio-video/es5/encodingparameters.js");
var LocalParticipant = __webpack_require__(/*! ./localparticipant */ "./node_modules/twilio-video/es5/localparticipant.js");
var InsightsPublisher = __webpack_require__(/*! ./util/insightspublisher */ "./node_modules/twilio-video/es5/util/insightspublisher/index.js");
var NullInsightsPublisher = __webpack_require__(/*! ./util/insightspublisher/null */ "./node_modules/twilio-video/es5/util/insightspublisher/null.js");
var _b = __webpack_require__(/*! ./media/track/es5 */ "./node_modules/twilio-video/es5/media/track/es5/index.js"), LocalAudioTrack = _b.LocalAudioTrack, LocalDataTrack = _b.LocalDataTrack, LocalVideoTrack = _b.LocalVideoTrack;
var NetworkQualityConfigurationImpl = __webpack_require__(/*! ./networkqualityconfiguration */ "./node_modules/twilio-video/es5/networkqualityconfiguration.js");
var Room = __webpack_require__(/*! ./room */ "./node_modules/twilio-video/es5/room.js");
var SignalingV2 = __webpack_require__(/*! ./signaling/v2 */ "./node_modules/twilio-video/es5/signaling/v2/index.js");
var _c = __webpack_require__(/*! ./util */ "./node_modules/twilio-video/es5/util/index.js"), asLocalTrack = _c.asLocalTrack, buildLogLevels = _c.buildLogLevels, filterObject = _c.filterObject, isNonArrayObject = _c.isNonArrayObject;
var _d = __webpack_require__(/*! ./util/constants */ "./node_modules/twilio-video/es5/util/constants.js"), DEFAULT_ENVIRONMENT = _d.DEFAULT_ENVIRONMENT, DEFAULT_LOG_LEVEL = _d.DEFAULT_LOG_LEVEL, DEFAULT_LOGGER_NAME = _d.DEFAULT_LOGGER_NAME, DEFAULT_REALM = _d.DEFAULT_REALM, DEFAULT_REGION = _d.DEFAULT_REGION, WS_SERVER = _d.WS_SERVER, SDK_NAME = _d.SDK_NAME, SDK_VERSION = _d.SDK_VERSION, E = _d.typeErrors;
var CancelablePromise = __webpack_require__(/*! ./util/cancelablepromise */ "./node_modules/twilio-video/es5/util/cancelablepromise.js");
var EventObserver = __webpack_require__(/*! ./util/eventobserver */ "./node_modules/twilio-video/es5/util/eventobserver.js");
var DefaultLog = __webpack_require__(/*! ./util/log */ "./node_modules/twilio-video/es5/util/log.js");
var validateBandwidthProfile = __webpack_require__(/*! ./util/validate */ "./node_modules/twilio-video/es5/util/validate.js").validateBandwidthProfile;
var safariVersion = guessBrowser() === 'safari' && guessBrowserVersion();
// This is used to make out which connect() call a particular Log statement
// belongs to. Each call to connect() increments this counter.
var connectCalls = 0;
var didPrintSafariWarning = false;
var isSafariWithoutVP8Support = false;
if (safariVersion) {
    var safariMajorVersion = safariVersion.major, safariMinorVersion = safariVersion.minor;
    isSafariWithoutVP8Support = safariMajorVersion < 12 || (safariMajorVersion === 12 && safariMinorVersion < 1);
}
var deprecatedConnectOptionsProps = new Set([
    { didWarn: false, shouldDelete: true, name: 'abortOnIceServersTimeout' },
    { didWarn: false, shouldDelete: true, name: 'dscpTagging', newName: 'enableDscp' },
    { didWarn: false, shouldDelete: true, name: 'iceServersTimeout' },
    { didWarn: false, shouldDelete: false, name: 'eventListener', newName: 'Video.Logger' },
    { didWarn: false, shouldDelete: false, name: 'logLevel', newName: 'Video.Logger' },
]);
var deprecatedVideoBandwidthProfileOptions = new Set([
    { didWarn: false, shouldDelete: false, name: 'maxTracks', newName: 'bandwidthProfile.video.clientTrackSwitchOffControl' },
    { didWarn: false, shouldDelete: false, name: 'renderDimensions', newName: 'bandwidthProfile.video.contentPreferencesMode' },
]);
/**
 * Connect to a {@link Room}.
 *   <br><br>
 *   By default, this will automatically acquire an array containing a
 *   {@link LocalAudioTrack} and {@link LocalVideoTrack} before connecting to
 *   the {@link Room}. These will be stopped when you disconnect from the
 *   {@link Room}.
 *   <br><br>
 *   You can override the default behavior by specifying
 *   <code>options</code>. For example, rather than acquiring a
 *   {@link LocalAudioTrack} and {@link LocalVideoTrack} automatically, you can
 *   pass your own array which you can stop yourself. See {@link ConnectOptions}
 *   for more information.
 *   <br><br>
 *   A "trackPublished" event is fired on the {@link LocalParticipant} for each
 *   LocalTrack that was successfully published. A "trackPublicationFailed" event
 *   is fired for each LocalTrack that was failed to be published.
 * @alias module:twilio-video.connect
 * @param {string} token - The Access Token string
 * @param {ConnectOptions} [options] - Options to override the default behavior, invalid options are ignored.
 * @returns {CancelablePromise<Room>}
 * @throws {RangeError}
 * @throws {TwilioError}
 * @throws {TypeError}
 * @example
 * var Video = require('twilio-video');
 * var token = getAccessToken();
 * Video.connect(token, {
 *   name: 'my-cool-room'
 * }).then(function(room) {
 *   room.on('participantConnected', function(participant) {
 *     console.log(participant.identity + ' has connected');
 *   });

 *   room.once('disconnected', function() {
 *     console.log('You left the Room:', room.name);
 *   });
 * }).catch(error => {
 *   console.log('Could not connect to the Room:', error.message);
 * });
 * @example
 * var Video = require('twilio-video');
 * var token = getAccessToken();
 *
 * // Connect with audio-only
 * Video.connect(token, {
 *   name: 'my-cool-room',
 *   audio: true
 * }).then(function(room) {
 *   room.on('participantConnected', function(participant) {
 *     console.log(participant.identity + ' has connected');
 *   });
 *
 *   room.once('disconnected', function() {
 *     console.log('You left the Room:', room.name);
 *   });
 * }).catch(error => {
 *   console.log('Could not connect to the Room:', error.message);
 * });
 * @example
 * var Video = require('twilio-video');
 * var token = getAccessToken();
 *
 * // Connect with media acquired using getUserMedia()
 * navigator.mediaDevices.getUserMedia({
 *   audio: true,
 *   video: true
 * }).then(function(mediaStream) {
 *   return Video.connect(token, {
 *     name: 'my-cool-room',
 *     tracks: mediaStream.getTracks()
 *   });
 * }).then(function(room) {
 *   room.on('participantConnected', function(participant) {
 *     console.log(participant.identity + ' has connected');
 *   });
 *
 *   room.once('disconnected', function() {
 *     console.log('You left the Room:', room.name);
 *   });
 * }).catch(error => {
 *   console.log('Could not connect to the Room:', error.message);
 * });
 * @example
 * var Video = require('twilio-video');
 * var token = getAccessToken();
 *
 * // Connect with custom names for LocalAudioTrack and LocalVideoTrack
 * Video.connect(token, {
 *   name: 'my-cool-room'
 *   audio: { name: 'microphone' },
 *   video: { name: 'camera' }
 * }).then(function(room) {
 *   room.localParticipant.on('trackPublished', function(publication) {
 *     console.log('The LocalTrack "' + publication.trackName + '" was successfully published');
 *   });
 * }).catch(error => {
 *   console.log('Could not connect to the Room:', error.message);
 * });
 * @example
 * // Accessing the SDK logger
 * var { Logger, connect } = require('twilio-video');
 * var token = getAccessToken();
 *
 * var logger = Logger.getLogger('twilio-video');
 *
 * // Listen for logs
 * var originalFactory = logger.methodFactory;
 * logger.methodFactory = function (methodName, logLevel, loggerName) {
 *   var method = originalFactory(methodName, logLevel, loggerName);
 *
 *   return function (datetime, logLevel, component, message, data) {
 *     method(datetime, logLevel, component, message, data);
 *     // Send to your own server
 *     postDataToServer(arguments);
 *   };
 * };
 * logger.setLevel('debug');
 *
 * connect(token, {
 *   name: 'my-cool-room'
 * }).then(function(room) {
 *   room.on('participantConnected', function(participant) {
 *     console.log(participant.identity + ' has connected');
 *   });
 * }).catch(error => {
 *   console.log('Could not connect to the Room:', error.message);
 * });
 */
function connect(token, options) {
    if (typeof options === 'undefined') {
        options = {};
    }
    if (!isNonArrayObject(options)) {
        return CancelablePromise.reject(E.INVALID_TYPE('options', 'object'));
    }
    var Log = options.Log || DefaultLog;
    var loggerName = options.loggerName || DEFAULT_LOGGER_NAME;
    var logLevel = options.logLevel || DEFAULT_LOG_LEVEL;
    var logLevels = buildLogLevels(logLevel);
    var logComponentName = "[connect #" + ++connectCalls + "]";
    var log;
    try {
        log = new Log('default', logComponentName, logLevels, loggerName);
    }
    catch (error) {
        return CancelablePromise.reject(error);
    }
    // NOTE(csantos): Log a warning for the deprecated ConnectOptions properties.
    // The warning is displayed only for the first call to connect() per browser session.
    // Additionally, the options that are no longer needed will be removed.
    deprecateOptions(options, 'ConnectOptions', log, deprecatedConnectOptionsProps);
    var adaptiveSimulcast = options.preferredVideoCodecs === 'auto';
    if (adaptiveSimulcast) {
        // NOTE(mpatwardhan): enable adaptiveSimulcast.
        options.preferredVideoCodecs = [{ codec: 'VP8', simulcast: true, adaptiveSimulcast: true }];
    }
    if (options.maxVideoBitrate && adaptiveSimulcast) {
        log.error('ConnectOptions "maxVideoBitrate" is not compatible with "preferredVideoCodecs=auto"');
        return CancelablePromise.reject(E.ILLEGAL_INVOKE('connect', 'ConnectOptions "maxVideoBitrate" is not compatible with "preferredVideoCodecs=auto"'));
    }
    options = Object.assign({
        automaticSubscription: true,
        dominantSpeaker: false,
        enableDscp: false,
        environment: DEFAULT_ENVIRONMENT,
        eventListener: null,
        insights: true,
        LocalAudioTrack: LocalAudioTrack,
        LocalDataTrack: LocalDataTrack,
        LocalParticipant: LocalParticipant,
        LocalVideoTrack: LocalVideoTrack,
        Log: Log,
        MediaStreamTrack: MediaStreamTrack,
        loggerName: loggerName,
        logLevel: logLevel,
        maxAudioBitrate: null,
        maxVideoBitrate: null,
        name: null,
        networkMonitor: true,
        networkQuality: false,
        preferredAudioCodecs: [],
        preferredVideoCodecs: [],
        realm: DEFAULT_REALM,
        region: DEFAULT_REGION,
        signaling: SignalingV2
    }, filterObject(options));
    /* eslint new-cap:0 */
    var eventPublisherOptions = {};
    if (typeof options.wsServerInsights === 'string') {
        eventPublisherOptions.gateway = options.wsServerInsights;
    }
    var EventPublisher = options.insights ? InsightsPublisher : NullInsightsPublisher;
    var eventPublisher = new EventPublisher(token, SDK_NAME, SDK_VERSION, options.environment, options.realm, eventPublisherOptions);
    var wsServer = WS_SERVER(options.environment, options.region);
    var eventObserver = new EventObserver(eventPublisher, Date.now(), log, options.eventListener);
    options = Object.assign({ eventObserver: eventObserver, wsServer: wsServer }, options);
    options.log = log;
    // NOTE(mroberts): Print the Safari warning once if the log-level is at least
    // "warn", i.e. neither "error" nor "off".
    // NOTE(mmalavalli): Print the Safari warning only for versions 12.0 and below.
    if (isSafariWithoutVP8Support
        && !didPrintSafariWarning
        && (log.logLevel !== 'error' && log.logLevel !== 'off')) {
        didPrintSafariWarning = true;
        log.warn([
            'Support for Safari 12.0 and below is limited because it does not support VP8.',
            'This means you may experience codec issues in Group Rooms. You may also',
            'experience codec issues in Peer-to-Peer (P2P) Rooms containing Android- or',
            'iOS-based Participants who do not support H.264. However, P2P Rooms',
            'with browser-based Participants should work. For more information, please',
            'refer to this guide: https://www.twilio.com/docs/video/javascript-v2-developing-safari-11'
        ].join(' '));
    }
    if (typeof token !== 'string') {
        return CancelablePromise.reject(E.INVALID_TYPE('token', 'string'));
    }
    // NOTE(mmalavalli): The Room "name" in "options" was being used
    // as the LocalTrack name in asLocalTrack(). So we pass a copy of
    // "options" without the "name".
    var localTrackOptions = Object.assign({}, options);
    delete localTrackOptions.name;
    if ('tracks' in options) {
        if (!Array.isArray(options.tracks)) {
            return CancelablePromise.reject(E.INVALID_TYPE('options.tracks', 'Array of LocalAudioTrack, LocalVideoTrack or MediaStreamTrack'));
        }
        try {
            options.tracks = options.tracks.map(function (track) { return asLocalTrack(track, localTrackOptions); });
        }
        catch (error) {
            return CancelablePromise.reject(error);
        }
    }
    var error = validateBandwidthProfile(options.bandwidthProfile);
    if (error) {
        return CancelablePromise.reject(error);
    }
    // Note(mpatwardhan): "clientTrackSwitchOffControl" allows tracks to be switched off
    // and "contentPreferencesMode" allows track dimensions to be specified dynamically.
    // The properties can have one of the three values internally:
    // 1) "auto" = sdk will decide and send the hints.
    // 2) "manual" - app can use api to send the hints.
    // 3) "disabled" = do not enable this feature. (this is internal only value)
    // 'disabled' is needed because clientTrackSwitchOffControl and contentPreferencesMode are incompatible with
    // deprecated properties maxTracks and renderDimensions respectively. once we make @breaking_version_change
    // we can remove 'disabled' state along with maxTracks and renderDimensions.
    options.clientTrackSwitchOffControl = 'disabled'; // should sdk turn off idle tracks automatically?
    options.contentPreferencesMode = 'disabled'; // should sdk  use video element dimensions for content hints?
    if (options.bandwidthProfile) {
        options.clientTrackSwitchOffControl = 'auto';
        options.contentPreferencesMode = 'auto';
        if (options.bandwidthProfile.video) {
            // log any warnings about deprecated bwp options
            deprecateOptions(options.bandwidthProfile.video, 'ConnectOptions.bandwidthProfile.video', log, deprecatedVideoBandwidthProfileOptions);
            if ('maxTracks' in options.bandwidthProfile.video) {
                // when deprecated maxTracks is specified. disable clientTrackSwitchOffControl
                options.clientTrackSwitchOffControl = 'disabled';
            }
            else if (options.bandwidthProfile.video.clientTrackSwitchOffControl === 'manual') {
                options.clientTrackSwitchOffControl = 'manual';
            }
            else {
                options.clientTrackSwitchOffControl = 'auto';
            }
            if ('maxTracks' in options.bandwidthProfile.video) {
                // move maxTracks over to new property that will be used to create RSP payload
                options.bandwidthProfile.video.maxSwitchedOnTracks = options.bandwidthProfile.video.maxTracks;
            }
            if ('renderDimensions' in options.bandwidthProfile.video) {
                options.contentPreferencesMode = 'disabled';
            }
            else if (options.bandwidthProfile.video.contentPreferencesMode === 'manual') {
                options.contentPreferencesMode = 'manual';
            }
            else {
                options.contentPreferencesMode = 'auto';
            }
        }
    }
    var Signaling = options.signaling;
    var signaling = new Signaling(options.wsServer, options);
    log.info('Connecting to a Room');
    log.debug('Options:', options);
    var encodingParameters = new EncodingParametersImpl({
        maxAudioBitrate: options.maxAudioBitrate,
        maxVideoBitrate: options.maxVideoBitrate
    }, adaptiveSimulcast);
    var preferredCodecs = {
        audio: options.preferredAudioCodecs.map(normalizeCodecSettings),
        video: options.preferredVideoCodecs.map(normalizeCodecSettings)
    };
    var networkQualityConfiguration = new NetworkQualityConfigurationImpl(isNonArrayObject(options.networkQuality) ? options.networkQuality : {});
    // Create a CancelableRoomPromise<Room> that resolves after these steps:
    // 1 - Get the LocalTracks.
    // 2 - Create the LocalParticipant using options.tracks.
    // 3 - Connect to rtc-room-service and create the RoomSignaling.
    // 4 - Create the Room and then resolve the CancelablePromise.
    var cancelableRoomPromise = createCancelableRoomPromise(getLocalTracks.bind(null, options), createLocalParticipant.bind(null, signaling, log, encodingParameters, networkQualityConfiguration, options), createRoomSignaling.bind(null, token, options, signaling, encodingParameters, preferredCodecs), createRoom.bind(null, options));
    cancelableRoomPromise.then(function (room) {
        eventPublisher.connect(room.sid, room.localParticipant.sid);
        log.info('Connected to Room:', room.toString());
        log.info('Room name:', room.name);
        log.debug('Room:', room);
        room.once('disconnected', function () { return eventPublisher.disconnect(); });
        return room;
    }, function (error) {
        eventPublisher.disconnect();
        if (cancelableRoomPromise._isCanceled) {
            log.info('Attempt to connect to a Room was canceled');
        }
        else {
            log.info('Error while connecting to a Room:', error);
        }
    });
    return cancelableRoomPromise;
}
/**
 * You may pass these options to {@link connect} in order to override the
 * default behavior.
 * @typedef {object} ConnectOptions
 * @property {boolean|CreateLocalTrackOptions} [audio=true] - Whether or not to
 *   get local audio with <code>getUserMedia</code> when <code>tracks</code>
 *   are not provided.
 * @property {boolean} [automaticSubscription=true] - By default, you will subscribe
 *   to all RemoteTracks shared by other Participants in a Room. You can now override this
 *   behavior by setting this flag to <code>false</code>. It will make sure that you will
 *   not subscribe to any RemoteTrack in a Group or Small Group Room. Setting it to
 *   <code>true</code>, or not setting it at all preserves the default behavior. This
 *   flag does not have any effect in a Peer-to-Peer Room.
 * @property {BandwidthProfile} [bandwidthProfile] - You can optionally configure
 *   how your available downlink bandwidth is shared among the RemoteTracks you have subscribed
 *   to in a Group Room. By default, bandwidth is shared equally among the RemoteTracks.
 *   This has no effect in Peer-to-Peer Rooms.
 * @property {boolean} [dominantSpeaker=false] - Whether to enable the Dominant
 *   Speaker API or not. This only takes effect in Group Rooms.
 * @property {boolean} [dscpTagging=false] - <code>(deprecated: use "enableDscp" instead)</code>
 *   DSCP tagging allows you to request enhanced QoS treatment for RTP media packets from any
 *   firewall that the client may be behind. Setting this option to <code>true</code> will
 *   request DSCP tagging for media packets on supported browsers (only Chrome supports this
 *   as of now). Audio packets will be sent with DSCP header value set to 0xb8 which corresponds
 *   to Expedited Forwarding (EF). Video packets will be sent with DSCP header value set to 0x88
 *   which corresponds to Assured Forwarding (AF41).
 * @property {boolean} [enableDscp=false] - DSCP tagging allows you to request enhanced
 *   QoS treatment for RTP media packets from any firewall that the client may be behind.
 *   Setting this option to <code>true</code> will request DSCP tagging for media packets
 *   on supported browsers (only Chrome supports this as of now). Audio packets will be
 *   sent with DSCP header value set to 0xb8 which corresponds to Expedited Forwarding (EF).
 *   Video packets will be sent with DSCP header value set to 0x88 which corresponds to
 *   Assured Forwarding (AF41).
 * @property {EventListener} [eventListener] - <code>(deprecated: use [Video.Logger](module-twilio-video.html)</code>
 *   you can listen to fine-grained events related to signaling and media that are
 *   not available in the public APIs. These events might be useful for your own reporting
 *   and diagnostics.
 * @property {Array<RTCIceServer>} iceServers - Override the STUN and TURN
 *   servers used when connecting to {@link Room}s
 * @property {RTCIceTransportPolicy} [iceTransportPolicy="all"] - Override the
 *   ICE transport policy to be one of "relay" or "all"
 * @property {boolean} [insights=true] - Whether publishing events
 *   to the Insights gateway is enabled or not
 * @property {?number} [maxAudioBitrate=null] - Max outgoing audio bitrate (bps);
 *   A <code>null</code> or a <code>0</code> value does not set any bitrate limit;
 *   This value is set as a hint for variable bitrate codecs, but will not take
 *   effect for fixed bitrate codecs; Based on our tests, Chrome, Firefox and Safari
 *   support a bitrate range of 12000 bps to 256000 bps for Opus codec; This parameter
 *   has no effect on iSAC, PCMU and PCMA codecs
 * @property {?number} [maxVideoBitrate=null] - Max outgoing video bitrate (bps);
 *   A <code>null</code> or <code>0</code> value does not set any bitrate limit;
 *   This value is set as a hint for variable bitrate codecs, but will not take
 *   effect for fixed bitrate codecs; Based on our tests, Chrome, Firefox and Safari
 *   all seem to support an average bitrate range of 20000 bps (20 kbps) to
 *   8000000 bps (8 mbps) for a 720p VideoTrack
 *   This parameter must not be set when when preferredVideoCodecs is set to `auto`.
 * @property {?string} [name=null] - Set to connect to a {@link Room} by name
 * @property {boolean|NetworkQualityConfiguration} [networkQuality=false] - Whether to enable the Network
 *   Quality API or not. This only takes effect in Group Rooms. Pass a {@link NetworkQualityConfiguration}
 *   to configure verbosity levels for network quality information for {@link LocalParticipant}
 *   and {@link RemoteParticipant}s. A <code>true</code> value will set the {@link NetworkQualityVerbosity}
 *   for the {@link LocalParticipant} to {@link NetworkQualityVerbosity}<code style="padding:0 0">#minimal</code>
 *   and the {@link NetworkQualityVerbosity} for {@link RemoteParticipant}s to
 *   {@link NetworkQualityVerbosity}<code style="padding:0 0">#none</code>.
 * @property {string} [region='gll'] - Preferred signaling region; By default, you will be connected to the
 *   nearest signaling server determined by latency based routing. Setting a value other
 *   than <code style="padding:0 0">gll</code> bypasses routing and guarantees that signaling traffic will be
 *   terminated in the region that you prefer. Please refer to this <a href="https://www.twilio.com/docs/video/ip-address-whitelisting#signaling-communication" target="_blank">table</a>
 *   for the list of supported signaling regions.
 * @property {Array<AudioCodec|AudioCodecSettings>} [preferredAudioCodecs=[]] - Preferred audio codecs;
 *  An empty array preserves the current audio codec preference order.
 * @property {Array<VideoCodec|VideoCodecSettings>|VideoEncodingMode} [preferredVideoCodecs=[]] -
 *  Preferred video codecs; when set to 'VideoEncodingMode.Auto', SDK manages the video codec,
 *  by preferring VP8 simulcast in group rooms. It also enables adaptive simulcast, which allows SDK
 *  to turn off simulcast layers that are not needed for efficient bandwidth and CPU usage.
 *  An empty array preserves the current video codec.
 *  preference order. If you want to set a preferred video codec on a Group Room,
 *  you will need to create the Room using the REST API and set the
 *  <code>VideoCodecs</code> property.
 *  See <a href="https://www.twilio.com/docs/api/video/rooms-resource#create-room">
 *  here</a> for more information.
 * @property {LogLevel|LogLevels} [logLevel='warn'] - <code>(deprecated: use [Video.Logger](module-twilio-video.html) instead.
 *   See [examples](module-twilio-video.html#.connect) for details)</code>
 *   Set the default log verbosity
 *   of logging. Passing a {@link LogLevel} string will use the same
 *   level for all components. Pass a {@link LogLevels} to set specific log
 *   levels.
 * @property {string} [loggerName='twilio-video'] - The name of the logger. Use this name when accessing the logger used by the SDK.
 *   See [examples](module-twilio-video.html#.connect) for details.
 * @property {Array<LocalTrack|MediaStreamTrack>} [tracks] - The
 *   {@link LocalTrack}s or MediaStreamTracks with which to join the
 *   {@link Room}. These tracks can be obtained either by calling
 *   {@link createLocalTracks}, or by constructing them from the MediaStream
 *   obtained by calling <code>getUserMedia()</code>.
 * @property {boolean|CreateLocalTrackOptions} [video=true] - Whether or not to
 *   get local video with <code>getUserMedia</code> when <code>tracks</code>
 *   are not provided.
 */
/**
 * {@link BandwidthProfile} allows you to configure how your available downlink
 * bandwidth is shared among the RemoteTracks you have subscribed to in a Group Room.
 * @typedef {object} BandwidthProfile
 * @property {VideoBandwidthProfile} [video] - Optional parameter to configure
 *   how your available downlink bandwidth is shared among the {@link RemoteVideoTrack}s you
 *   have subscribed to in a Group Room.
 * @property {AudioBandwidthProfile} [audio] - Optional parameter to configure
 *   how your available downlink bandwidth is shared among the {@link RemoteAudioTrack}s you
 *   have subscribed to in a Group Room.
 */
/**
 * {@link AudioBandwidthProfile} allows you to configure how your available downlink
 * bandwidth is shared among the {@link RemoteAudioTrack}s you have subscribed to in a Group Room.
 * @typedef {object} AudioBandwidthProfile
 * @property {number} [maxSwitchedOnTracks] - Optional
 *   parameter to specify the maximum number of {@link RemoteAudioTrack}s, which will be selected based on
 *   N-Loudest policy. If not specified server defaults will be used.
 */
/**
 * {@link VideoBandwidthProfile} allows you to configure how your available downlink
 * bandwidth is shared among the {@link RemoteVideoTrack}s you have subscribed to in a Group Room.
 * @typedef {object} VideoBandwidthProfile
 * @property {Track.Priority} [dominantSpeakerPriority="standard"] - Optional parameter to
 *   specify the minimum subscribe {@link Track.Priority} of the Dominant Speaker's {@link RemoteVideoTrack}s.
 *   This means that the Dominant Speaker's {@link RemoteVideoTrack}s that are published with
 *   lower {@link Track.Priority} will be subscribed to with the {@link Track.Priority} specified here.
 *   This has no effect on {@link RemoteVideoTrack}s published with higher {@link Track.Priority}, which will
 *   still be subscribed to with with the same {@link Track.Priority}. If not specified, this defaults to "standard".
 *   This parameter only applies to a Group Room Participant when {@link ConnectOptions}.dominantSpeaker is set to true.
 * @property {number} [maxSubscriptionBitrate] - Optional parameter to specify the maximum
 *   downlink video bandwidth in bits per second (bps). By default, there are no limits on
 *   the downlink video bandwidth.
 * @property {ClientTrackSwitchOffControl} [clientTrackSwitchOffControl="auto"] - Optional parameter that determines
 *    when to turn the {@link RemoteVideoTrack} on or off. When set to "auto", SDK will use the visibility of the
 *    attached elements to determine if the {@link RemoteVideoTrack} should be turned off or on. When the attached video elements become invisible the {@link RemoteVideoTrack} will
 *    be turned off, and when elements become visible they will be turned on. When set to "manual" you can turn the {@link RemoteVideoTrack}
 *    on and off using the api {@link RemoteVideoTrack#switchOn} and {@link RemoteVideoTrack#switchOff} respectively.
 * @property {VideoContentPreferencesMode} [contentPreferencesMode="auto"] - This Optional parameter configures
 *    the mode for specifying content preferences for the {@link RemoteVideoTrack}. When set to "auto" the
 *    SDK determines the render dimensions by inspecting the attached video elements. {@link RemoteVideoTrack}s rendered in smaller video elements
 *    will receive a lower resolution stream compared to the video rendered in larger video elements. When set to "manual" you can set
 *    the dimensions programmatically by calling {@link RemoteVideoTrack#setContentPreferences}.
 * @property {number} [maxTracks] - <code>(deprecated: use "clientTrackSwitchOffControl" instead)</code>. Optional
 *   parameter to specify the maximum number of visible {@link RemoteVideoTrack}s, which will be selected based on
 *   {@link Track.Priority} and an N-Loudest policy. By default there are no limits on the number of visible {@link RemoteVideoTrack}s.
 *   0 or a negative value will remove any limit on the maximum number of visible {@link RemoteVideoTrack}s.
 * @property {number} [maxSwitchedOnTracks] - Optional parameter to specify the maximum number of visible {@link RemoteVideoTrack}s,
 *   which will be selected based on {@link Track.Priority} and an N-Loudest policy. By default there are no limits
 *   on the number of visible {@link RemoteVideoTrack}s. 0 or a negative value will remove any limit
 *   on the maximum number of visible {@link RemoteVideoTrack}s.
 * @property {BandwidthProfileMode} [mode="grid"] - Optional parameter to specify how the {@link RemoteVideoTrack}s'
 *   TrackPriority values are mapped to bandwidth allocation in Group Rooms. This defaults to "grid",
 *   which results in equal bandwidth share allocation to all {@link RemoteVideoTrack}s.
 * @property {VideoRenderDimensions} [renderDimensions] - <code>(deprecated: use "contentPreferencesMode" instead)</code>. Optional
 *   parameter to specify the desired render dimensions of {@link RemoteVideoTrack}s.
 * @property {TrackSwitchOffMode} [trackSwitchOffMode="predicted"] - Optional parameter to configure
 *   how {@link RemoteVideoTrack}s are switched off in response to bandwidth pressure. Defaults to "predicted".
 */
/**
 * @deprecated
 * {@link VideoRenderDimensions} allows you to specify the desired render dimensions of {@link RemoteVideoTrack}s.
 * You can specify 'auto' for this field - which is also default value -  based on {@link Track.Priority}. The bandwidth allocation algorithm will distribute the available downlink bandwidth
 * proportional to the requested render dimensions. This is just an input for calculating the bandwidth to be allocated
 * and does not affect the actual resolution of the {@link RemoteVideoTrack}s.
 * @typedef {object} VideoRenderDimensions
 * @property {VideoTrack.Dimensions} [high] - Optional parameter to specify the desired rendering dimensions of
 *   {@link RemoteVideoTrack} whose {@link Track.Priority} is "high". 0 or a negative value will result in the lowest
 *   possible resolution. This defaults to 1280 x 720 (HD).
 * @property {VideoTrack.Dimensions} [low] - Optional parameter to specify the desired rendering dimensions of
 *   {@link RemoteVideoTrack} whose {@link Track.Priority} is "low". 0 or a negative value will result in the lowest
 *   possible resolution. This defaults to 176 x 144 (QCIF).
 * @property {VideoTrack.Dimensions} [standard] - Optional parameter to specify the desired rendering dimensions of
 *   {@link RemoteVideoTrack} whose {@link Track.Priority} is "standard". 0 or a negative value will result in the lowest
 *   possible resolution. This defaults to 640 x 480 (VGA).
 */
/**
 * Configure verbosity levels for network quality information for
 * {@link LocalParticipant} and {@link RemoteParticipant}s.
 * @typedef {object} NetworkQualityConfiguration
 * @property {NetworkQualityVerbosity} [local=1] - Verbosity level for {@link LocalParticipant}
 * @property {NetworkQualityVerbosity} [remote=0] - Verbosity level for {@link RemoteParticipant}s
 */
/**
 * You may pass these levels to {@link ConnectOptions} to override
 * log levels for individual components.
 * @typedef {object} LogLevels
 * @property {LogLevel} [default='warn'] - Log level for 'default' modules.
 * @property {LogLevel} [media='warn'] - Log level for 'media' modules.
 * @property {LogLevel} [signaling='warn'] - Log level for 'signaling' modules.
 * @property {LogLevel} [webrtc='warn'] - Log level for 'webrtc' modules.
 */
/**
 * Audio codec settings.
 * @typedef {object} AudioCodecSettings
 * @property {AudioCodec} codec - Audio codec name
 */
/**
 * Opus codec settings.
 * @typedef {AudioCodecSettings} OpusCodecSettings
 * @property {AudioCodec} name - "opus"
 * @property {boolean} [dtx=true] - Enable/disable discontinuous transmission (DTX);
 *   If enabled all published {@link LocalAudioTrack}s will reduce the outgoing bitrate
 *   to near-zero whenever speech is not detected, resulting in bandwidth and CPU savings;
 *   It defaults to true.
 */
/**
 * Video codec settings.
 * @typedef {object} VideoCodecSettings
 * @property {VideoCodec} codec - Video codec name
 */
/**
 * VP8 codec settings.
 * @typedef {VideoCodecSettings} VP8CodecSettings
 * @property {VideoCodec} name - "VP8"
 * @property {boolean} [simulcast=false] - Enable/disable VP8 simulcast; If
 *   enabled, Twilio's Video SDK will send three video streams of different
 *   qualities
 */
/**
 * Names of the supported audio codecs.
 * @enum {string}
 */
// eslint-disable-next-line
var AudioCodec = {
    isac: 'isac',
    opus: 'opus',
    PCMA: 'PCMA',
    PCMU: 'PCMU'
};
/**
 * Names of the supported VideoEncodingMode.
 * @enum {string}
 */
// eslint-disable-next-line
var VideoEncodingMode = {
    Auto: 'auto',
};
/**
 * Names of the supported video codecs.
 * @enum {string}
 */
// eslint-disable-next-line
var VideoCodec = {
    H264: 'H264',
    VP8: 'VP8'
};
// VP9 is supported by most browsers, but backend doesn't at the moment.
// Hide it from public documentation until then.
VideoCodec.VP9 = 'VP9';
/**
 * Levels for logging verbosity.
 * @enum {string}
 */
// eslint-disable-next-line
var LogLevel = {
    debug: 'debug',
    info: 'info',
    warn: 'warn',
    error: 'error',
    off: 'off'
};
/**
 * The verbosity level of network quality information of a {@link Participant}.
 * @enum {number}
 */
// eslint-disable-next-line
var NetworkQualityVerbosity = {
    /**
     * Nothing is reported for the {@link Participant}. This has no effect and
     * defaults to {@link NetworkQualityVerbosity}<code style="padding:0 0">#minimal</code>
     * for the {@link LocalParticipant}.
     */
    none: 0,
    /**
     * Reports {@link NetworkQualityLevel} for the {@link Participant}.
     */
    minimal: 1,
    /**
     * Reports {@link NetworkQualityLevel} and {@link NetworkQualityStats} for the {@link Participant}.
     * {@link NetworkQualityStats} is populated with audio and video {@link NetworkQualityLevel}s
     * based on which the {@link Participant}'s {@link NetworkQualityLevel} is calculated.
     */
    moderate: 2,
    /**
     * Reports {@link NetworkQualityLevel} and {@link NetworkQualityStats} for the {@link Participant}.
     * {@link NetworkQualityStats} is populated with audio and Video {@link NetworkQualityLevel}s
     * and their corresponding {@link NetworkQualityMediaStats} based on which the
     * {@link Participant}'s {@link NetworkQualityLevel} is calculated.
     */
    detailed: 3
};
/**
 * {@link TrackSwitchOffMode} specifies when {@link RemoteVideoTrack}s' are switched off.
 * @enum {string}
 */
// eslint-disable-next-line
var TrackSwitchOffMode = {
    /**
     * In this mode, {@link RemoteVideoTrack}s are switched off only when network congestion
     * is detected.
     */
    detected: 'detected',
    /**
     * In this mode, {@link RemoteVideoTrack}s are pro-actively switched off when network
     * congestion is predicted by the bandwidth estimation mechanism.
     */
    predicted: 'predicted',
    /**
     * In this mode, {@link RemoteVideoTrack}s are not switched off. Instead in response to network
     * congestion, tracks will be adjusted to lower quality.
     */
    disabled: 'disabled'
};
/**
 * {@link TrackSwitchOffReason} describes why a {@link RemoteTrack} is switched off. This reason
 * accompanies the {@link RemoteTrack} event <code>switchedOff</code> and is used for
 * the {@link RemoteTrack} property <code>switchOffReason</code>.
 * @enum {string}
 */
var TrackSwitchOffReason = {
    /**
     * The {@link RemoteTrack} was disabled by the publishing {@link Participant}.
     * The media server does not send media to the subscribing {@link Participant}s
     * for a disabled {@link Track}.
     */
    'disabled-by-publisher': 'disabled-by-publisher',
    /**
     * The {@link RemoteVideoTrack} was disabled by the subscribing {@link Participant}
     * and the media server stopped sending its media.
     */
    'disabled-by-subscriber': 'disabled-by-subscriber',
    /**
     * The {@link RemoteVideoTrack} was switched off because the remaining
     * downlink bandwidth is not sufficient to receive its media. The bandwidth
     * limit is configured by specifying <code>maxSubscriptionBitrate</code>
     * in {@link VideoBandwidthProfile} or a default value is selected
     * by the media server.
     */
    'max-bandwidth-reached': 'max-bandwidth-reached',
    /**
     * The {@link RemoteTrack} was switched off because the number of switched on
     * {@link Track}s reached the limit set by the media server.
     */
    'max-tracks-switched-on': 'max-tracks-switched-on',
    /**
     * The {@link RemoteVideoTrack} was switched off because network congestion
     * was detected or predicted. The <code>trackSwitchOffMode</code> property
     * on {@link VideoBandwidthProfile} allows you to specify how the
     * switch off is managed.
     */
    'network-congestion': 'network-congestion'
};
/**
 * {@link BandwidthProfileMode} specifies how {@link RemoteVideoTrack}s' {@link Track.Priority} values
 * are mapped to bandwidth allocation in Group Rooms.
 * @enum {string}
 */
// eslint-disable-next-line
var BandwidthProfileMode = {
    /**
     * This mode is for use cases where all the subscribed {@link RemoteVideoTrack}s are
     * equally important. The bandwidth allocation algorithm will share the available
     * downlink bandwidth equally among the subscribed {@link RemoteVideoTrack}s, irrespective
     * of their {@link Track.Priority}. In case of insufficient downlink bandwidth, the lower
     * priority {@link RemoteVideoTrack}s are switched off.
     */
    grid: 'grid',
    /**
     * This mode is for use cases where some {@link RemoteVideoTrack}s are prioritized more than
     * others. However, the lower priority {@link RemoteVideoTrack}s still need to be visible.
     * The bandwidth allocation algorithm will share the available downlink bandwidth proportional
     * to the requested {@link VideoRenderDimensions} corresponding to their {@link Track.Priority}.
     * In case of insufficient downlink bandwidth, the quality of higher priority {@link RemoteVideoTrack}s
     * may be degraded to avoid switching off lower priority {@link RemoteVideoTrack}s.
     */
    collaboration: 'collaboration',
    /**
     * This mode is for use cases where some {@link RemoteVideoTrack}s are deemed critical and must
     * be preserved at any cost over the other {@link RemoteVideoTrack}s. The bandwidth allocation
     * algorithm will allocate as big a share of the available downlink bandwidth as it possibly
     * can to the higher priority {@link RemoteVideoTrack}s, and only then consider the lower priority
     * {@link RemoteVideoTrack}s. In case of insufficient downlink bandwidth, the lower priority
     * {@link RemoteVideoTrack}s are switched off in order to preserve the quality of the higher
     * priority {@link RemoteVideoTrack}s.
     */
    presentation: 'presentation'
};
/**
 * {@link VideoContentPreferencesMode} specifies how {@link RemoteVideoTrack}s' render dimensions are
 * decided by the SDK.
 * @enum {string}
 */
// eslint-disable-next-line
var VideoContentPreferencesMode = {
    /**
     * when set to auto, SDK uses the sizes of the video elements attached to the to the  {@link RemoteVideoTrack} dynamically to
     * decide the render dimensions. {@link RemoteVideoTrack}s rendered in smaller video elements will be given smaller bandwidth allocation
     * compared to the tracks rendered in large video elements.
     */
    auto: 'auto',
    /**
     * When set to manual, application can use {@link RemoteVideoTrack#setContentPreference} to set the
     * desired render dimensions for the {@link RemoteVideoTrack}.
     */
    manual: 'manual'
};
/**
 * {@link ClientTrackSwitchOffControl} specifies how {@link RemoteVideoTrack}s' turned on and off
 * @enum {string}
 */
// eslint-disable-next-line
var ClientTrackSwitchOffControl = {
    /**
     * when set to auto, SDK uses the visibility of the video elements attached to the to the  {@link RemoteVideoTrack} to decide.
     * on turning tracks on or off. The track that are not attached to any video elements or not visible on the screen will be turned
     * off automatically.
     */
    auto: 'auto',
    /**
     * When set to manual, application can use {@link RemoteVideoTrack}s switchOff and switchOn apis to control turn the track on or off.
     */
    manual: 'manual'
};
/**
 * Names of the supported levels for {@link EventListenerEvent}s.
 * @enum {string}
 */
// eslint-disable-next-line
var EventListenerLevel = {
    debug: 'debug',
    error: 'error',
    info: 'info',
    warning: 'warning'
};
/**
 * Names of the supported groups for {@link EventListenerEvent}s.
 * @enum {string}
 */
// eslint-disable-next-line
var EventListenerGroup = {
    /**
     * Events associated with the connection to Twilio's signaling server
     */
    signaling: 'signaling'
};
/**
 * An {@link EventListener} allows you to listen to fine-grained {@link EventListenerEvent}s related
 * to signaling and media that are not available in the public APIs, which might be useful for your own
 * reporting and diagnostics.
 * @typedef {EventEmitter} EventListener
 * @example
 * const { EventEmitter } = require('events');
 * const { connect } = require('twilio-video');
 *
 * const eventListener = new EventEmitter();
 * eventListener.on('event', function(event) {
 *   console.log('The SDK raised an event:', event);
 * });
 *
 * connect('token', {
 *   eventListener: eventListener
 * });
 */
/**
 * The SDK raised an {@link EventListenerEvent}.
 * @event EventListener#event
 * @param {EventListenerEvent} event - Context about the event raised by the SDK.
 * This can be one of the following:
 *  * {@link EventListenerClosedEvent}
 *  * {@link EventListenerConnectingEvent}
 *  * {@link EventListenerEarlyEvent}
 *  * {@link EventListenerOpenEvent}
 *  * {@link EventListenerWaitingEvent}
 */
/**
 * An {@link EventListenerEvent} provides context about an event raised by the SDK on the
 * {@link EventListener}. Apart from the properties listed here, it may also include some
 * event-specific data within an optional "payload" property. The different types of
 * {@link EventListenerEvent}s are listed below:
 *  * {@link EventListenerClosedEvent}
 *  * {@link EventListenerConnectingEvent}
 *  * {@link EventListenerEarlyEvent}
 *  * {@link EventListenerOpenEvent}
 *  * {@link EventListenerWaitingEvent}
 * @typedef {object} EventListenerEvent
 * @property {number} elapsedTime - The time elapsed in milliseconds since connect() was called
 * @property {EventListenerGroup} group - The group under which the event is classified
 * @property {EventListenerLevel} level - The verbosity level of the event, which can be one of "debug", "error", "info", "warning"
 * @property {string} name - The name of the event
 * @property {*} [payload] - Optional event-specific data
 * @property {number} timestamp - The time in milliseconds relative to the Unix Epoch when the event was raised
 */
/**
 * The connection to Twilio's signaling server was closed.
 * @typedef {EventListenerEvent} EventListenerClosedEvent
 * @property {EventListenerGroup} group='signaling'
 * @property {EventListenerLevel} level - 'info' if the connection was closed by the client, 'error' otherwise
 * @property {string} name='closed'
 * @property {{reason: string}} payload - Reason for the connection being closed. It can be one of
 *   'busy', 'failed', 'local', 'remote' or 'timeout'
 */
/**
 * The SDK is connecting to Twilio's signaling server.
 * @typedef {EventListenerEvent} EventListenerConnectingEvent
 * @property {EventListenerGroup} group='signaling'
 * @property {EventListenerLevel} level='info'
 * @property {string} name='connecting'
 */
/**
 * The SDK is about to connect to Twilio's signaling server.
 * @typedef {EventListenerEvent} EventListenerEarlyEvent
 * @property {EventListenerGroup} group='signaling'
 * @property {EventListenerLevel} level='info'
 * @property {string} name='early'
 */
/**
 * The SDK has established a signaling connection to Twilio's signaling server.
 * @typedef {EventListenerEvent} EventListenerOpenEvent
 * @property {EventListenerGroup} group='signaling'
 * @property {EventListenerLevel} level='info'
 * @property {string} name='open'
 */
/**
 * The SDK is waiting to retry connecting th Twilio's signaling server. This can
 * happen if the server is busy with too many connection requests.
 * @typedef {EventListenerEvent} EventListenerWaitingEvent
 * @property {EventListenerGroup} group='signaling'
 * @property {EventListenerLevel} level='warning'
 * @property {string} name='waiting'
 */
function deprecateOptions(options, optionsName, log, deprecationTable) {
    deprecationTable.forEach(function (prop) {
        var didWarn = prop.didWarn, name = prop.name, newName = prop.newName, shouldDelete = prop.shouldDelete;
        if (name in options && typeof options[name] !== 'undefined') {
            if (newName && shouldDelete) {
                options[newName] = options[name];
            }
            if (shouldDelete) {
                delete options[name];
            }
            if (!didWarn && !['error', 'off'].includes(log.level)) {
                log.warn("The " + optionsName + " property \"" + name + "\" is " + (newName
                    ? "deprecated and scheduled for removal. Please use \"" + newName + "\" instead."
                    : 'no longer applicable and will be ignored.'));
                prop.didWarn = true;
            }
        }
    });
}
function createLocalParticipant(signaling, log, encodingParameters, networkQualityConfiguration, options, localTracks) {
    var localParticipantSignaling = signaling.createLocalParticipantSignaling(encodingParameters, networkQualityConfiguration);
    log.debug('Creating a new LocalParticipant:', localParticipantSignaling);
    return new options.LocalParticipant(localParticipantSignaling, localTracks, options);
}
function createRoom(options, localParticipant, roomSignaling) {
    var room = new Room(localParticipant, roomSignaling, options);
    var log = options.log;
    log.debug('Creating a new Room:', room);
    roomSignaling.on('stateChanged', function stateChanged(state) {
        if (state === 'disconnected') {
            log.info('Disconnected from Room:', room.toString());
            roomSignaling.removeListener('stateChanged', stateChanged);
        }
    });
    return room;
}
function createRoomSignaling(token, options, signaling, encodingParameters, preferredCodecs, localParticipant) {
    options.log.debug('Creating a new RoomSignaling');
    return signaling.connect(localParticipant._signaling, token, encodingParameters, preferredCodecs, options);
}
function getLocalTracks(options, handleLocalTracks) {
    var log = options.log;
    options.shouldStopLocalTracks = !options.tracks;
    if (options.shouldStopLocalTracks) {
        log.info('LocalTracks were not provided, so they will be acquired '
            + 'automatically before connecting to the Room. LocalTracks will '
            + 'be released if connecting to the Room fails or if the Room '
            + 'is disconnected');
    }
    else {
        log.info('Getting LocalTracks');
        log.debug('Options:', options);
    }
    return options.createLocalTracks(options).then(function getLocalTracksSucceeded(localTracks) {
        var promise = handleLocalTracks(localTracks);
        promise.catch(function handleLocalTracksFailed() {
            if (options.shouldStopLocalTracks) {
                log.info('The automatically acquired LocalTracks will now be stopped');
                localTracks.forEach(function (track) {
                    track.stop();
                });
            }
        });
        return promise;
    });
}
function normalizeCodecSettings(nameOrSettings) {
    var settings = typeof nameOrSettings === 'string'
        ? { codec: nameOrSettings }
        : nameOrSettings;
    switch (settings.codec.toLowerCase()) {
        case 'opus': {
            return Object.assign({ dtx: true }, settings);
        }
        case 'vp8': {
            return Object.assign({ simulcast: false }, settings);
        }
        default: {
            return settings;
        }
    }
}
module.exports = connect;
//# sourceMappingURL=connect.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/createlocaltrack.js":
/*!***********************************************************!*\
  !*** ./node_modules/twilio-video/es5/createlocaltrack.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a = __webpack_require__(/*! ./util/constants */ "./node_modules/twilio-video/es5/util/constants.js"), DEFAULT_LOG_LEVEL = _a.DEFAULT_LOG_LEVEL, DEFAULT_LOGGER_NAME = _a.DEFAULT_LOGGER_NAME;
/**
 * Request a {@link LocalAudioTrack} or {@link LocalVideoTrack}.
 * @param {Track.Kind} kind - "audio" or "video"
 * @param {CreateLocalTrackOptions} [options]
 * @returns {Promise<LocalAudioTrack|LocalVideoTrack>}
 * @private
 */
function createLocalTrack(kind, options) {
    options = Object.assign({
        loggerName: DEFAULT_LOGGER_NAME,
        logLevel: DEFAULT_LOG_LEVEL,
    }, options);
    var createOptions = {};
    createOptions.loggerName = options.loggerName;
    createOptions.logLevel = options.logLevel;
    delete options.loggerName;
    delete options.logLevel;
    var createLocalTracks = options.createLocalTracks;
    delete options.createLocalTracks;
    createOptions[kind] = Object.keys(options).length > 0 ? options : true;
    return createLocalTracks(createOptions).then(function (localTracks) { return localTracks[0]; });
}
/**
 * Request a {@link LocalAudioTrack}.
 * @alias module:twilio-video.createLocalAudioTrack
 * @param {CreateLocalTrackOptions} [options] - Options for requesting a {@link LocalAudioTrack}
 * @returns {Promise<LocalAudioTrack>}
 * @example
 * var Video = require('twilio-video');
 *
 * // Connect to the Room with just video
 * Video.connect('my-token', {
 *   name: 'my-cool-room',
 *   video: true
 * }).then(function(room) {
 *   // Add audio after connecting to the Room
 *   Video.createLocalAudioTrack().then(function(localTrack) {
 *     room.localParticipant.publishTrack(localTrack);
 *   });
 * });
 * @example
 * var Video = require('twilio-video');
 *
 * // Request the default LocalAudioTrack with a custom name
 * Video.createLocalAudioTrack({ name: 'microphone' }).then(function(localTrack) {
 *   console.log(localTrack.name); // 'microphone'
 * });
 */
function createLocalAudioTrack(options) {
    return createLocalTrack('audio', options);
}
/**
 * Request a {@link LocalVideoTrack}. Note that on mobile browsers,
 * the camera can be reserved by only one {@link LocalVideoTrack} at any given
 * time. If you attempt to create a second {@link LocalVideoTrack}, video frames
 * will no longer be supplied to the first {@link LocalVideoTrack}.
 * @alias module:twilio-video.createLocalVideoTrack
 * @param {CreateLocalTrackOptions} [options] - Options for requesting a {@link LocalVideoTrack}
 * @returns {Promise<LocalVideoTrack>}
 * @example
 * var Video = require('twilio-video');
 *
 * // Connect to the Room with just audio
 * Video.connect('my-token', {
 *   name: 'my-cool-room',
 *   audio: true
 * }).then(function(room) {
 *   // Add video after connecting to the Room
 *   Video.createLocalVideoTrack().then(function(localTrack) {
 *     room.localParticipant.publishTrack(localTrack);
 *   });
 * });
 * @example
 * var Video = require('twilio-video');
 *
 * // Request the default LocalVideoTrack with a custom name
 * Video.createLocalVideoTrack({ name: 'camera' }).then(function(localTrack) {
 *   console.log(localTrack.name); // 'camera'
 * });
 */
function createLocalVideoTrack(options) {
    return createLocalTrack('video', options);
}
/**
 * Create {@link LocalTrack} options. Apart from the properties listed here, you can
 * also specify any of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints" target="_blank">MediaTrackConstraints</a>
 * properties.
 * @typedef {MediaTrackConstraints} CreateLocalTrackOptions
 * @property {LogLevel|LogLevels} [logLevel='warn'] - <code>(deprecated: use [Video.Logger](module-twilio-video.html) instead.
 *   See [examples](module-twilio-video.html#.connect) for details)</code>
 *   Set the default log verbosity
 *   of logging. Passing a {@link LogLevel} string will use the same
 *   level for all components. Pass a {@link LogLevels} to set specific log
 *   levels.
 * @property {string} [loggerName='twilio-video'] - The name of the logger. Use this name when accessing the logger used by the SDK.
 *   See [examples](module-twilio-video.html#.connect) for details.
 * @property {string} [name] - The {@link LocalTrack}'s name; by default,
 *   it is set to the {@link LocalTrack}'s ID.
 * @property {boolean} [workaroundWebKitBug180748=false] - Only valid for
 *   {@link LocalAudioTrack}s; setting this attempts to workaround WebKit Bug
 *   180748, where, in Safari, getUserMedia may return a silent audio
 *   MediaStreamTrack.
 */
module.exports = {
    audio: createLocalAudioTrack,
    video: createLocalVideoTrack
};
//# sourceMappingURL=createlocaltrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/createlocaltracks.js":
/*!************************************************************!*\
  !*** ./node_modules/twilio-video/es5/createlocaltracks.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLocalTracks = void 0;
var _a = __webpack_require__(/*! ./util */ "./node_modules/twilio-video/es5/util/index.js"), asLocalTrack = _a.asLocalTrack, buildLogLevels = _a.buildLogLevels;
var _b = __webpack_require__(/*! ./webrtc */ "./node_modules/twilio-video/es5/webrtc/index.js"), getUserMedia = _b.getUserMedia, MediaStreamTrack = _b.MediaStreamTrack;
var _c = __webpack_require__(/*! ./media/track/es5 */ "./node_modules/twilio-video/es5/media/track/es5/index.js"), LocalAudioTrack = _c.LocalAudioTrack, LocalDataTrack = _c.LocalDataTrack, LocalVideoTrack = _c.LocalVideoTrack;
var Log = __webpack_require__(/*! ./util/log */ "./node_modules/twilio-video/es5/util/log.js");
var _d = __webpack_require__(/*! ./util/constants */ "./node_modules/twilio-video/es5/util/constants.js"), DEFAULT_LOG_LEVEL = _d.DEFAULT_LOG_LEVEL, DEFAULT_LOGGER_NAME = _d.DEFAULT_LOGGER_NAME;
var workaround180748 = __webpack_require__(/*! ./webaudio/workaround180748 */ "./node_modules/twilio-video/es5/webaudio/workaround180748.js");
// This is used to make out which createLocalTracks() call a particular Log
// statement belongs to. Each call to createLocalTracks() increments this
// counter.
var createLocalTrackCalls = 0;
/**
 * Request {@link LocalTrack}s. By default, it requests a
 * {@link LocalAudioTrack} and a {@link LocalVideoTrack}.
 * Note that on mobile browsers, the camera can be reserved by only one {@link LocalVideoTrack}
 * at any given time. If you attempt to create a second {@link LocalVideoTrack}, video frames
 * will no longer be supplied to the first {@link LocalVideoTrack}.
 * @alias module:twilio-video.createLocalTracks
 * @param {CreateLocalTracksOptions} [options]
 * @returns {Promise<Array<LocalTrack>>}
 * @example
 * var Video = require('twilio-video');
 * // Request audio and video tracks
 * Video.createLocalTracks().then(function(localTracks) {
 *   var localMediaContainer = document.getElementById('local-media-container-id');
 *   localTracks.forEach(function(track) {
 *     localMediaContainer.appendChild(track.attach());
 *   });
 * });
 * @example
 * var Video = require('twilio-video');
 * // Request just the default audio track
 * Video.createLocalTracks({ audio: true }).then(function(localTracks) {
 *   return Video.connect('my-token', {
 *     name: 'my-cool-room',
 *     tracks: localTracks
 *   });
 * });
 * @example
 * var Video = require('twilio-video');
 * // Request the audio and video tracks with custom names
 * Video.createLocalTracks({
 *   audio: { name: 'microphone' },
 *   video: { name: 'camera' }
 * }).then(function(localTracks) {
 *   localTracks.forEach(function(localTrack) {
 *     console.log(localTrack.name);
 *   });
 * });
 *
 * @example
 * var Video = require('twilio-video');
 * var localTracks;
 *
 * // Pre-acquire tracks to display camera preview.
 * Video.createLocalTracks().then(function(tracks) {
 *  localTracks = tracks;
 *  var localVideoTrack = localTracks.find(track => track.kind === 'video');
 *  divContainer.appendChild(localVideoTrack.attach());
 * })
 *
 * // Later, join the Room with the pre-acquired LocalTracks.
 * Video.connect('token', {
 *   name: 'my-cool-room',
 *   tracks: localTracks
 * });
 *
 */
function createLocalTracks(options) {
    return __awaiter(this, void 0, void 0, function () {
        var isAudioVideoAbsent, fullOptions, logComponentName, logLevels, log, localTrackOptions, extraLocalTrackOptions, mediaStreamConstraints, workaroundWebKitBug180748, mediaStream, mediaStreamTracks, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    isAudioVideoAbsent = !(options && ('audio' in options || 'video' in options));
                    fullOptions = __assign({ audio: isAudioVideoAbsent, getUserMedia: getUserMedia, loggerName: DEFAULT_LOGGER_NAME, logLevel: DEFAULT_LOG_LEVEL, LocalAudioTrack: LocalAudioTrack,
                        LocalDataTrack: LocalDataTrack,
                        LocalVideoTrack: LocalVideoTrack,
                        MediaStreamTrack: MediaStreamTrack,
                        Log: Log, video: isAudioVideoAbsent }, options);
                    logComponentName = "[createLocalTracks #" + ++createLocalTrackCalls + "]";
                    logLevels = buildLogLevels(fullOptions.logLevel);
                    log = new fullOptions.Log('default', logComponentName, logLevels, fullOptions.loggerName);
                    localTrackOptions = Object.assign({ log: log }, fullOptions);
                    // NOTE(mmalavalli): The Room "name" in "options" was being used
                    // as the LocalTrack name in asLocalTrack(). So we pass a copy of
                    // "options" without the "name".
                    // NOTE(joma): CreateLocalTracksOptions type does not really have a "name" property when used publicly by customers.
                    // But we are passing this property when used internally by other JS files.
                    // We can update this "any" type once those JS files are converted to TS.
                    delete localTrackOptions.name;
                    if (fullOptions.audio === false && fullOptions.video === false) {
                        log.info('Neither audio nor video requested, so returning empty LocalTracks');
                        return [2 /*return*/, []];
                    }
                    if (fullOptions.tracks) {
                        log.info('Adding user-provided LocalTracks');
                        log.debug('LocalTracks:', fullOptions.tracks);
                        return [2 /*return*/, fullOptions.tracks];
                    }
                    extraLocalTrackOptions = {
                        audio: typeof fullOptions.audio === 'object' && fullOptions.audio.name
                            ? { name: fullOptions.audio.name }
                            : {},
                        video: typeof fullOptions.video === 'object' && fullOptions.video.name
                            ? { name: fullOptions.video.name }
                            : {}
                    };
                    extraLocalTrackOptions.audio.isCreatedByCreateLocalTracks = true;
                    extraLocalTrackOptions.video.isCreatedByCreateLocalTracks = true;
                    if (typeof fullOptions.audio === 'object' && typeof fullOptions.audio.workaroundWebKitBug1208516 === 'boolean') {
                        extraLocalTrackOptions.audio.workaroundWebKitBug1208516 = fullOptions.audio.workaroundWebKitBug1208516;
                    }
                    if (typeof fullOptions.video === 'object' && typeof fullOptions.video.workaroundWebKitBug1208516 === 'boolean') {
                        extraLocalTrackOptions.video.workaroundWebKitBug1208516 = fullOptions.video.workaroundWebKitBug1208516;
                    }
                    if (typeof fullOptions.audio === 'object') {
                        delete fullOptions.audio.name;
                    }
                    if (typeof fullOptions.video === 'object') {
                        delete fullOptions.video.name;
                    }
                    mediaStreamConstraints = {
                        audio: fullOptions.audio,
                        video: fullOptions.video
                    };
                    workaroundWebKitBug180748 = typeof fullOptions.audio === 'object' && fullOptions.audio.workaroundWebKitBug180748;
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, (workaroundWebKitBug180748
                            ? workaround180748(log, fullOptions.getUserMedia, mediaStreamConstraints)
                            : fullOptions.getUserMedia(mediaStreamConstraints))];
                case 2:
                    mediaStream = _a.sent();
                    mediaStreamTracks = __spreadArray(__spreadArray([], __read(mediaStream.getAudioTracks())), __read(mediaStream.getVideoTracks()));
                    log.info('Call to getUserMedia successful; got MediaStreamTracks:', mediaStreamTracks);
                    return [2 /*return*/, mediaStreamTracks.map(function (mediaStreamTrack) { return asLocalTrack(mediaStreamTrack, __assign(__assign({}, extraLocalTrackOptions[mediaStreamTrack.kind]), localTrackOptions)); })];
                case 3:
                    error_1 = _a.sent();
                    log.warn('Call to getUserMedia failed:', error_1);
                    throw error_1;
                case 4: return [2 /*return*/];
            }
        });
    });
}
exports.createLocalTracks = createLocalTracks;
//# sourceMappingURL=createlocaltracks.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/data/receiver.js":
/*!********************************************************!*\
  !*** ./node_modules/twilio-video/es5/data/receiver.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DataTrackTransceiver = __webpack_require__(/*! ./transceiver */ "./node_modules/twilio-video/es5/data/transceiver.js");
var DataTransport = __webpack_require__(/*! ./transport */ "./node_modules/twilio-video/es5/data/transport.js");
/**
 * A {@link DataTrackReceiver} represents a {@link DataTrackTransceiver} over
 * which data can be received. Internally, it users a single RTCDataChannel to
 * receive data.
 * @extends DataTrackTransceiver
 * @emits DataTrackReceiver#message
 * @emits DataTrackReceiver#close
 */
var DataTrackReceiver = /** @class */ (function (_super) {
    __extends(DataTrackReceiver, _super);
    /**
     * Construct an {@link DataTrackReceiver}.
     * @param {RTCDataChannel} dataChannel
     */
    function DataTrackReceiver(dataChannel) {
        var _this = _super.call(this, dataChannel.label, dataChannel.maxPacketLifeTime, dataChannel.maxRetransmits, dataChannel.ordered) || this;
        Object.defineProperties(_this, {
            _dataChannel: {
                value: dataChannel
            }
        });
        // NOTE(mmalavalli): In Firefox, the default value for "binaryType" is "blob".
        // So, we set it to "arraybuffer" to ensure that it is consistent with Chrome
        // and Safari.
        dataChannel.binaryType = 'arraybuffer';
        dataChannel.addEventListener('message', function (event) {
            _this.emit('message', event.data);
        });
        dataChannel.addEventListener('close', function () {
            _this.emit('close');
        });
        return _this;
    }
    DataTrackReceiver.prototype.stop = function () {
        this._dataChannel.close();
        _super.prototype.stop.call(this);
    };
    /**
     * Create a {@link DataTransport} from the {@link DataTrackReceiver}.
     * @returns {DataTransport}
     */
    DataTrackReceiver.prototype.toDataTransport = function () {
        return new DataTransport(this._dataChannel);
    };
    return DataTrackReceiver;
}(DataTrackTransceiver));
/**
 * @event DataTrackReceiver#message
 * @param {string|ArrayBuffer} data
 */
/**
 * @event DataTrackReceiver#close
 */
module.exports = DataTrackReceiver;
//# sourceMappingURL=receiver.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/data/sender.js":
/*!******************************************************!*\
  !*** ./node_modules/twilio-video/es5/data/sender.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DataTrackTransceiver = __webpack_require__(/*! ./transceiver */ "./node_modules/twilio-video/es5/data/transceiver.js");
var makeUUID = __webpack_require__(/*! ../util */ "./node_modules/twilio-video/es5/util/index.js").makeUUID;
/**
 * A {@link DataTrackSender} represents a {@link DataTrackTransceiver} over
 * which data can be sent. Internally, it uses a collection of RTCDataChannels
 * to send data.
 * @extends DataTrackTransceiver
 */
var DataTrackSender = /** @class */ (function (_super) {
    __extends(DataTrackSender, _super);
    /**
     * Construct a {@link DataTrackSender}.
     * @param {?number} maxPacketLifeTime
     * @param {?number} maxRetransmits
     * @param {boolean} ordered
     */
    function DataTrackSender(maxPacketLifeTime, maxRetransmtis, ordered) {
        var _this = _super.call(this, makeUUID(), maxPacketLifeTime, maxRetransmtis, ordered) || this;
        Object.defineProperties(_this, {
            _clones: {
                value: new Set()
            },
            _dataChannels: {
                value: new Set()
            }
        });
        return _this;
    }
    /**
     * Add a cloned {@link DataTrackSender}.
     * @private
     * @returns {void}
     */
    DataTrackSender.prototype._addClone = function (clone) {
        this._clones.add(clone);
    };
    /**
     * Remove a cloned {@link DataTrackSender}.
     * @returns {void}
     */
    DataTrackSender.prototype.removeClone = function (clone) {
        this._clones.delete(clone);
    };
    /**
     * Add an RTCDataChannel to the {@link DataTrackSender}.
     * @param {RTCDataChannel} dataChannel
     * @returns {this}
     */
    DataTrackSender.prototype.addDataChannel = function (dataChannel) {
        this._dataChannels.add(dataChannel);
        return this;
    };
    /**
     * Return a new {@link DataTrackSender}. Any message sent over this
     * {@link DataTrackSender} will also be sent over the clone. Whenever this
     * {@link DataTrackSender} is stopped, so to will the clone.
     * @returns {DataTrackSender}
     */
    DataTrackSender.prototype.clone = function () {
        var _this = this;
        var clone = new DataTrackSender(this.maxPacketLifeTime, this.maxRetransmits, this.ordered);
        this._addClone(clone);
        clone.once('stopped', function () { return _this.removeClone(clone); });
        return clone;
    };
    /**
     * Remove an RTCDataChannel from the {@link DataTrackSender}.
     * @param {RTCDataChannel} dataChannel
     * @returns {this}
     */
    DataTrackSender.prototype.removeDataChannel = function (dataChannel) {
        this._dataChannels.delete(dataChannel);
        return this;
    };
    /**
     * Send data over the {@link DataTrackSender}. Internally, this calls
     * <code>send</code> over each of the underlying RTCDataChannels.
     * @param {string|Blob|ArrayBuffer|ArrayBufferView} data
     * @returns {this}
     */
    DataTrackSender.prototype.send = function (data) {
        this._dataChannels.forEach(function (dataChannel) {
            try {
                dataChannel.send(data);
            }
            catch (error) {
                // Do nothing.
            }
        });
        this._clones.forEach(function (clone) {
            try {
                clone.send(data);
            }
            catch (error) {
                // Do nothing.
            }
        });
        return this;
    };
    DataTrackSender.prototype.stop = function () {
        this._dataChannels.forEach(function (dataChannel) { return dataChannel.close(); });
        this._clones.forEach(function (clone) { return clone.stop(); });
        _super.prototype.stop.call(this);
    };
    return DataTrackSender;
}(DataTrackTransceiver));
module.exports = DataTrackSender;
//# sourceMappingURL=sender.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/data/transceiver.js":
/*!***********************************************************!*\
  !*** ./node_modules/twilio-video/es5/data/transceiver.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackTransceiver = __webpack_require__(/*! ../transceiver */ "./node_modules/twilio-video/es5/transceiver.js");
/**
 * A {@link DataTrackTransceiver} represents either one or more local
 * RTCDataChannels or a single remote RTCDataChannel. It can be used to send or
 * receive data.
 * @extends TrackTransceiver
 * @property {string} id
 * @property {string} kind - "data"
 * @property {?number} maxPacketLifeTime
 * @property {?number} maxRetransmits
 * @property {boolean} ordered
 */
var DataTrackTransceiver = /** @class */ (function (_super) {
    __extends(DataTrackTransceiver, _super);
    /**
     * Construct a {@link DataTrackTransceiver}.
     * @param {string} id
     * @param {?number} maxPacketLifeTime
     * @param {?number} maxRetransmits
     * @param {boolean} ordered
     */
    function DataTrackTransceiver(id, maxPacketLifeTime, maxRetransmits, ordered) {
        var _this = _super.call(this, id, 'data') || this;
        Object.defineProperties(_this, {
            maxPacketLifeTime: {
                enumerable: true,
                value: maxPacketLifeTime
            },
            maxRetransmits: {
                enumerable: true,
                value: maxRetransmits
            },
            ordered: {
                enumerable: true,
                value: ordered
            }
        });
        return _this;
    }
    return DataTrackTransceiver;
}(TrackTransceiver));
module.exports = DataTrackTransceiver;
//# sourceMappingURL=transceiver.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/data/transport.js":
/*!*********************************************************!*\
  !*** ./node_modules/twilio-video/es5/data/transport.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
/**
 * @classdesc A {@link DataTransport} implements {@link MediaSignalingTransport}
 *   in terms of an RTCDataChannel.
 * @extends EventEmitter
 * @implements MediaSignalingTransport
 * @emits DataTransport#message
 */
var DataTransport = /** @class */ (function (_super) {
    __extends(DataTransport, _super);
    /**
     * Construct a {@link DataTransport}.
     * @param {RTCDataChannel} dataChannel
     */
    function DataTransport(dataChannel) {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _dataChannel: {
                value: dataChannel
            },
            _messageQueue: {
                value: []
            }
        });
        dataChannel.addEventListener('open', function () {
            _this._messageQueue.splice(0).forEach(function (message) { return _this._publish(message); });
        });
        dataChannel.addEventListener('message', function (_a) {
            var data = _a.data;
            try {
                var message = JSON.parse(data);
                _this.emit('message', message);
            }
            catch (error) {
                // Do nothing.
            }
        });
        _this.publish({ type: 'ready' });
        return _this;
    }
    /**
     * @param message
     * @private
     */
    DataTransport.prototype._publish = function (message) {
        var data = JSON.stringify(message);
        try {
            this._dataChannel.send(data);
        }
        catch (error) {
            // Do nothing.
        }
    };
    /**
     * Publish a message. Returns true if calling the method resulted in
     * publishing (or eventually publishing) the update.
     * @param {object} message
     * @returns {boolean}
     */
    DataTransport.prototype.publish = function (message) {
        var dataChannel = this._dataChannel;
        if (dataChannel.readyState === 'closing' || dataChannel.readyState === 'closed') {
            return false;
        }
        if (dataChannel.readyState === 'connecting') {
            this._messageQueue.push(message);
            return true;
        }
        this._publish(message);
        return true;
    };
    return DataTransport;
}(EventEmitter));
/**
 * The {@link DataTransport} received a message.
 * @event DataTransport#message
 * @param {object} message
 */
module.exports = DataTransport;
//# sourceMappingURL=transport.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/encodingparameters.js":
/*!*************************************************************!*\
  !*** ./node_modules/twilio-video/es5/encodingparameters.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
/**
 * {@link EncodingParametersImpl} represents an object which notifies its
 * listeners of any changes in the values of its properties.
 * @extends EventEmitter
 * @implements EncodingParameters
 * @emits EncodingParametersImpl#changed
 * @property {?number} maxAudioBitrate
 * @property {?number} maxVideoBitrate
 */
var EncodingParametersImpl = /** @class */ (function (_super) {
    __extends(EncodingParametersImpl, _super);
    /**
     * Construct an {@link EncodingParametersImpl}.
     * @param {EncodingParamters} encodingParameters - Initial {@link EncodingParameters}
     * @param {Boolean} adaptiveSimulcast - true if adaptive simulcast was enabled by connect options.
     */
    function EncodingParametersImpl(encodingParameters, adaptiveSimulcast) {
        var _this = _super.call(this) || this;
        encodingParameters = Object.assign({
            maxAudioBitrate: null,
            maxVideoBitrate: null
        }, encodingParameters);
        Object.defineProperties(_this, {
            maxAudioBitrate: {
                value: encodingParameters.maxAudioBitrate,
                writable: true
            },
            maxVideoBitrate: {
                value: encodingParameters.maxVideoBitrate,
                writable: true
            },
            adaptiveSimulcast: {
                value: adaptiveSimulcast
            }
        });
        return _this;
    }
    /**
     * Returns the bitrate values in an {@link EncodingParameters}.
     * @returns {EncodingParameters}
     */
    EncodingParametersImpl.prototype.toJSON = function () {
        return {
            maxAudioBitrate: this.maxAudioBitrate,
            maxVideoBitrate: this.maxVideoBitrate
        };
    };
    /**
     * Update the bitrate values with those in the given {@link EncodingParameters}.
     * @param {EncodingParameters} encodingParameters - The new {@link EncodingParameters}
     * @fires EncodingParametersImpl#changed
     */
    EncodingParametersImpl.prototype.update = function (encodingParameters) {
        var _this = this;
        encodingParameters = Object.assign({
            maxAudioBitrate: this.maxAudioBitrate,
            maxVideoBitrate: this.maxVideoBitrate
        }, encodingParameters);
        var shouldEmitChanged = [
            'maxAudioBitrate',
            'maxVideoBitrate'
        ].reduce(function (shouldEmitChanged, maxKindBitrate) {
            if (_this[maxKindBitrate] !== encodingParameters[maxKindBitrate]) {
                _this[maxKindBitrate] = encodingParameters[maxKindBitrate];
                shouldEmitChanged = true;
            }
            return shouldEmitChanged;
        }, false);
        if (shouldEmitChanged) {
            this.emit('changed');
        }
    };
    return EncodingParametersImpl;
}(EventEmitter));
/**
 * At least one of the {@link EncodingParametersImpl}'s bitrate values changed.
 * @event EncodingParametersImpl#changed
 */
module.exports = EncodingParametersImpl;
//# sourceMappingURL=encodingparameters.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/eventemitter.js":
/*!*******************************************************!*\
  !*** ./node_modules/twilio-video/es5/eventemitter.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var hidePrivateAndCertainPublicPropertiesInClass = __webpack_require__(/*! ./util */ "./node_modules/twilio-video/es5/util/index.js").hidePrivateAndCertainPublicPropertiesInClass;
module.exports = hidePrivateAndCertainPublicPropertiesInClass(EventEmitter, ['domain']);
//# sourceMappingURL=eventemitter.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/index.js":
/*!************************************************!*\
  !*** ./node_modules/twilio-video/es5/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var createlocaltracks_1 = __webpack_require__(/*! ./createlocaltracks */ "./node_modules/twilio-video/es5/createlocaltracks.js");
var preflighttest_1 = __webpack_require__(/*! ./preflight/preflighttest */ "./node_modules/twilio-video/es5/preflight/preflighttest.js");
var internals = {
    connect: __webpack_require__(/*! ./connect */ "./node_modules/twilio-video/es5/connect.js"),
    createLocalAudioTrack: __webpack_require__(/*! ./createlocaltrack */ "./node_modules/twilio-video/es5/createlocaltrack.js").audio,
    createLocalVideoTrack: __webpack_require__(/*! ./createlocaltrack */ "./node_modules/twilio-video/es5/createlocaltrack.js").video,
    isSupported: __webpack_require__(/*! ./util/support */ "./node_modules/twilio-video/es5/util/support.js")(),
    version: __webpack_require__(/*! ../package.json */ "./node_modules/twilio-video/package.json").version,
    Logger: __webpack_require__(/*! ./vendor/loglevel */ "./node_modules/twilio-video/es5/vendor/loglevel.js"),
    LocalAudioTrack: __webpack_require__(/*! ./media/track/es5 */ "./node_modules/twilio-video/es5/media/track/es5/index.js").LocalAudioTrack,
    LocalDataTrack: __webpack_require__(/*! ./media/track/es5 */ "./node_modules/twilio-video/es5/media/track/es5/index.js").LocalDataTrack,
    LocalVideoTrack: __webpack_require__(/*! ./media/track/es5 */ "./node_modules/twilio-video/es5/media/track/es5/index.js").LocalVideoTrack
};
function connect(token, options) {
    var internalOptions = __assign({ createLocalTracks: createlocaltracks_1.createLocalTracks }, options);
    return internals.connect(token, internalOptions);
}
function createLocalAudioTrack(options) {
    var internalOptions = __assign({ createLocalTracks: createlocaltracks_1.createLocalTracks }, options);
    return internals.createLocalAudioTrack(internalOptions);
}
function createLocalVideoTrack(options) {
    var internalOptions = __assign({ createLocalTracks: createlocaltracks_1.createLocalTracks }, options);
    return internals.createLocalVideoTrack(internalOptions);
}
/**
 * @module twilio-video
 * @property {boolean} isSupported - true if the current browser is officially
 *   supported by twilio-video.js; In this context, "supported" means that
 *   twilio-video.js has been extensively tested with this browser; This
 *   <a href="https://www.twilio.com/docs/video/javascript#supported-browsers" target="_blank">table</a>
 *   specifies the list of officially supported browsers.
 *
 * @property {object} Logger - The <a href="https://www.npmjs.com/package/loglevel" target="_blank">loglevel</a>
 *    module used by the SDK. Use this object to access the internal loggers and perform actions as defined by the
 *   <a href="https://www.npmjs.com/package/loglevel" target="_blank">loglevel</a> APIs.
 *   See [connect](#.connect) for examples.
 *
 * @property {string} version - current version of twilio-video.js.
 */
var isSupported = internals.isSupported;
var version = internals.version;
var Logger = internals.Logger;
var LocalAudioTrack = internals.LocalAudioTrack;
var LocalVideoTrack = internals.LocalVideoTrack;
var LocalDataTrack = internals.LocalDataTrack;
module.exports = {
    connect: connect,
    createLocalAudioTrack: createLocalAudioTrack,
    createLocalVideoTrack: createLocalVideoTrack,
    createLocalTracks: createlocaltracks_1.createLocalTracks,
    runPreflight: preflighttest_1.runPreflight,
    isSupported: isSupported,
    version: version,
    Logger: Logger,
    LocalAudioTrack: LocalAudioTrack,
    LocalVideoTrack: LocalVideoTrack,
    LocalDataTrack: LocalDataTrack
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/localparticipant.js":
/*!***********************************************************!*\
  !*** ./node_modules/twilio-video/es5/localparticipant.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaStreamTrack = __webpack_require__(/*! ./webrtc */ "./node_modules/twilio-video/es5/webrtc/index.js").MediaStreamTrack;
var _a = __webpack_require__(/*! ./util */ "./node_modules/twilio-video/es5/util/index.js"), asLocalTrack = _a.asLocalTrack, asLocalTrackPublication = _a.asLocalTrackPublication, reemitTrackPublicationEvents = _a.reemitTrackPublicationEvents, trackClass = _a.trackClass;
var _b = __webpack_require__(/*! ./util/constants */ "./node_modules/twilio-video/es5/util/constants.js"), E = _b.typeErrors, trackPriority = _b.trackPriority;
var validateLocalTrack = __webpack_require__(/*! ./util/validate */ "./node_modules/twilio-video/es5/util/validate.js").validateLocalTrack;
var _c = __webpack_require__(/*! ./media/track/es5 */ "./node_modules/twilio-video/es5/media/track/es5/index.js"), LocalAudioTrack = _c.LocalAudioTrack, LocalDataTrack = _c.LocalDataTrack, LocalVideoTrack = _c.LocalVideoTrack;
var LocalAudioTrackPublication = __webpack_require__(/*! ./media/track/localaudiotrackpublication */ "./node_modules/twilio-video/es5/media/track/localaudiotrackpublication.js");
var LocalDataTrackPublication = __webpack_require__(/*! ./media/track/localdatatrackpublication */ "./node_modules/twilio-video/es5/media/track/localdatatrackpublication.js");
var LocalVideoTrackPublication = __webpack_require__(/*! ./media/track/localvideotrackpublication */ "./node_modules/twilio-video/es5/media/track/localvideotrackpublication.js");
var Participant = __webpack_require__(/*! ./participant */ "./node_modules/twilio-video/es5/participant.js");
/**
 * A {@link LocalParticipant} represents the local {@link Participant} in a
 * {@link Room}.
 * @extends Participant
 * @property {Map<Track.SID, LocalAudioTrackPublication>} audioTracks -
 *    The {@link LocalParticipant}'s {@link LocalAudioTrackPublication}s
 * @property {Map<Track.SID, LocalDataTrackPublication>} dataTracks -
 *    The {@link LocalParticipant}'s {@link LocalDataTrackPublication}s
 * @property {Map<Track.SID, LocalTrackPublication>} tracks -
 *    The {@link LocalParticipant}'s {@link LocalTrackPublication}s
 * @property {Map<Track.SID, LocalVideoTrackPublication>} videoTracks -
 *    The {@link LocalParticipant}'s {@link LocalVideoTrackPublication}s
 * @property {string} signalingRegion - The geographical region of the
 *     signaling edge the {@link LocalParticipant} is connected to.
 *
 * @emits RemoteParticipant#reconnected
 * @emits RemoteParticipant#reconnecting
 * @emits LocalParticipant#trackDimensionsChanged
 * @emits LocalParticipant#trackDisabled
 * @emits LocalParticipant#trackEnabled
 * @emits LocalParticipant#trackPublicationFailed
 * @emits LocalParticipant#trackPublished
 * @emits LocalParticipant#trackStarted
 * @emits LocalParticipant#trackStopped
 */
var LocalParticipant = /** @class */ (function (_super) {
    __extends(LocalParticipant, _super);
    /**
     * Construct a {@link LocalParticipant}.
     * @param {ParticipantSignaling} signaling
     * @param {Array<LocalTrack>} localTracks
     * @param {Object} options
     */
    function LocalParticipant(signaling, localTracks, options) {
        var _this = this;
        options = Object.assign({
            LocalAudioTrack: LocalAudioTrack,
            LocalVideoTrack: LocalVideoTrack,
            LocalDataTrack: LocalDataTrack,
            MediaStreamTrack: MediaStreamTrack,
            LocalAudioTrackPublication: LocalAudioTrackPublication,
            LocalVideoTrackPublication: LocalVideoTrackPublication,
            LocalDataTrackPublication: LocalDataTrackPublication,
            shouldStopLocalTracks: false,
            tracks: localTracks
        }, options);
        var tracksToStop = options.shouldStopLocalTracks
            ? new Set(localTracks.filter(function (localTrack) { return localTrack.kind !== 'data'; }))
            : new Set();
        _this = _super.call(this, signaling, options) || this;
        Object.defineProperties(_this, {
            _eventObserver: {
                value: options.eventObserver
            },
            _LocalAudioTrack: {
                value: options.LocalAudioTrack
            },
            _LocalDataTrack: {
                value: options.LocalDataTrack
            },
            _LocalVideoTrack: {
                value: options.LocalVideoTrack
            },
            _MediaStreamTrack: {
                value: options.MediaStreamTrack
            },
            _LocalAudioTrackPublication: {
                value: options.LocalAudioTrackPublication
            },
            _LocalDataTrackPublication: {
                value: options.LocalDataTrackPublication
            },
            _LocalVideoTrackPublication: {
                value: options.LocalVideoTrackPublication
            },
            _tracksToStop: {
                value: tracksToStop
            },
            signalingRegion: {
                enumerable: true,
                get: function () {
                    return signaling.signalingRegion;
                }
            }
        });
        _this._handleTrackSignalingEvents();
        return _this;
    }
    /**
     * @private
     * @param {LocalTrack} track
     * @param {Track.Priority} priority
     * @returns {?LocalTrack}
     */
    LocalParticipant.prototype._addTrack = function (track, priority) {
        var addedTrack = _super.prototype._addTrack.call(this, track, track.id);
        if (addedTrack && this.state !== 'disconnected') {
            this._addLocalTrack(track, priority);
        }
        return addedTrack;
    };
    /**
     * @private
     * @param {LocalTrackPublication} publication
     * @returns {?LocalTrackPublication}
     */
    LocalParticipant.prototype._addTrackPublication = function (publication) {
        publication = _super.prototype._addTrackPublication.call(this, publication);
        if (publication) {
            reemitTrackPublicationEvents(this, publication);
        }
        return publication;
    };
    /**
     * @private
     * @param {LocalTrack} track
     * @param {Track.Priority} priority
     * @returns {void}
     */
    LocalParticipant.prototype._addLocalTrack = function (track, priority) {
        this._signaling.addTrack(track._trackSender, track.name, priority);
        this._log.info("Added a new " + trackClass(track, true) + ":", track.id);
        this._log.debug(trackClass(track, true) + ":", track);
    };
    /**
     * @private
     * @param {LocalTrack} track
     * @returns {?LocalTrack}
     */
    LocalParticipant.prototype._removeTrack = function (track) {
        var removedTrack = _super.prototype._removeTrack.call(this, track, track.id);
        if (removedTrack && this.state !== 'disconnected') {
            this._signaling.removeTrack(track._trackSender);
            this._log.info("Removed a " + trackClass(track, true) + ":", track.id);
            this._log.debug(trackClass(track, true) + ":", track);
        }
        return removedTrack;
    };
    /**
     * Get the {@link LocalTrack} events to re-emit.
     * @private
     * @returns {Array<Array<string>>} events
     */
    LocalParticipant.prototype._getTrackEvents = function () {
        return _super.prototype._getTrackEvents.call(this).concat([
            ['disabled', 'trackDisabled'],
            ['enabled', 'trackEnabled'],
            ['stopped', 'trackStopped']
        ]);
    };
    LocalParticipant.prototype.toString = function () {
        return "[LocalParticipant #" + this._instanceId + (this.sid ? ": " + this.sid : '') + "]";
    };
    /**
     * @private
     */
    LocalParticipant.prototype._handleTrackSignalingEvents = function () {
        var _this = this;
        var log = this._log;
        if (this.state === 'disconnected') {
            return;
        }
        var signaling = this._signaling;
        function localTrackDisabled(localTrack) {
            var trackSignaling = signaling.getPublication(localTrack._trackSender);
            if (trackSignaling) {
                trackSignaling.disable();
                log.debug("Disabled the " + trackClass(localTrack, true) + ":", localTrack.id);
            }
        }
        function localTrackEnabled(localTrack) {
            var trackSignaling = signaling.getPublication(localTrack._trackSender);
            if (trackSignaling) {
                trackSignaling.enable();
                log.debug("Enabled the " + trackClass(localTrack, true) + ":", localTrack.id);
            }
        }
        function localTrackStopped(localTrack) {
            // NOTE(mroberts): We shouldn't need to check for `stop`, since DataTracks
            // do not emit "stopped".
            var trackSignaling = signaling.getPublication(localTrack._trackSender);
            if (trackSignaling) {
                trackSignaling.stop();
            }
            return trackSignaling;
        }
        this.on('trackDisabled', localTrackDisabled);
        this.on('trackEnabled', localTrackEnabled);
        this.on('trackStopped', localTrackStopped);
        this._tracks.forEach(function (track) {
            _this._addLocalTrack(track, trackPriority.PRIORITY_STANDARD);
            _this._getOrCreateLocalTrackPublication(track).catch(function (error) {
                // Just log a warning for now.
                log.warn("Failed to get or create LocalTrackPublication for " + track + ":", error);
            });
        });
        var self = this;
        signaling.on('stateChanged', function stateChanged(state) {
            log.debug('Transitioned to state:', state);
            if (state === 'disconnected') {
                log.debug('Removing LocalTrack event listeners');
                signaling.removeListener('stateChanged', stateChanged);
                self.removeListener('trackDisabled', localTrackDisabled);
                self.removeListener('trackEnabled', localTrackEnabled);
                self.removeListener('trackStopped', localTrackStopped);
                // NOTE(mmalavalli): Remove the stale MediaTrackSender clones so that we
                // do not call replaceTrack() on their RTCRtpSenders.
                self._tracks.forEach(function (track) {
                    var trackSignaling = localTrackStopped(track);
                    if (trackSignaling) {
                        track._trackSender.removeClone(trackSignaling._trackTransceiver);
                    }
                });
                log.info("LocalParticipant disconnected. Stopping " + self._tracksToStop.size + " automatically-acquired LocalTracks");
                self._tracksToStop.forEach(function (track) {
                    track.stop();
                });
            }
            else if (state === 'connected') {
                // NOTE(mmalavalli): Any transition to "connected" here is a result of
                // successful signaling reconnection, and not a first-time establishment
                // of the signaling connection.
                log.info('reconnected');
                // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.
                // Do not signal  public events synchronously with lock held.
                setTimeout(function () { return self.emit('reconnected'); }, 0);
            }
        });
    };
    /**
     * @private
     * @param {LocalTrack} localTrack
     * @returns {Promise<LocalTrackPublication>}
     */
    LocalParticipant.prototype._getOrCreateLocalTrackPublication = function (localTrack) {
        var localTrackPublication = getTrackPublication(this.tracks, localTrack);
        if (localTrackPublication) {
            return Promise.resolve(localTrackPublication);
        }
        var log = this._log;
        var self = this;
        var trackSignaling = this._signaling.getPublication(localTrack._trackSender);
        if (!trackSignaling) {
            return Promise.reject(new Error("Unexpected error: The " + localTrack + " cannot be published"));
        }
        function unpublish(publication) {
            self.unpublishTrack(publication.track);
        }
        return new Promise(function (resolve, reject) {
            function updated() {
                var error = trackSignaling.error;
                if (error) {
                    trackSignaling.removeListener('updated', updated);
                    log.warn("Failed to publish the " + trackClass(localTrack, true) + ": " + error.message);
                    self._removeTrack(localTrack);
                    setTimeout(function () {
                        self.emit('trackPublicationFailed', error, localTrack);
                    });
                    reject(error);
                    return;
                }
                if (!self._tracks.has(localTrack.id)) {
                    trackSignaling.removeListener('updated', updated);
                    reject(new Error("The " + localTrack + " was unpublished"));
                    return;
                }
                var sid = trackSignaling.sid;
                if (!sid) {
                    return;
                }
                trackSignaling.removeListener('updated', updated);
                var options = {
                    log: log,
                    LocalAudioTrackPublication: self._LocalAudioTrackPublication,
                    LocalDataTrackPublication: self._LocalDataTrackPublication,
                    LocalVideoTrackPublication: self._LocalVideoTrackPublication
                };
                localTrackPublication = getTrackPublication(self.tracks, localTrack);
                if (!localTrackPublication) {
                    localTrackPublication = asLocalTrackPublication(localTrack, trackSignaling, unpublish, options);
                    self._addTrackPublication(localTrackPublication);
                }
                var state = self._signaling.state;
                if (state === 'connected' || state === 'connecting') {
                    if (localTrack._processorEventObserver) {
                        localTrack._processorEventObserver.on('event', function (event) {
                            self._eventObserver.emit('event', {
                                name: event.name,
                                payload: event.data,
                                group: 'video-processor',
                                level: 'info'
                            });
                        });
                    }
                    // NOTE(csantos): For tracks created before joining a room or already joined but about to publish it
                    if (localTrack.processedTrack) {
                        localTrack._captureFrames();
                        localTrack._setSenderMediaStreamTrack(true);
                    }
                }
                if (state === 'connected') {
                    setTimeout(function () {
                        self.emit('trackPublished', localTrackPublication);
                    });
                }
                resolve(localTrackPublication);
            }
            trackSignaling.on('updated', updated);
        });
    };
    /**
     * Publishes a {@link LocalTrack} to the {@link Room}.
     * @param {LocalTrack} localTrack - The {@link LocalTrack} to publish
     * @param {LocalTrackPublishOptions} [options] - The {@link LocalTrackPublishOptions}
     *   for publishing the {@link LocalTrack}
     * @returns {Promise<LocalTrackPublication>} - Resolves with the corresponding
     *   {@link LocalTrackPublication} if successful; In a Large Group Room (Maximum
     *   Participants greater than 50), rejects with a {@link ParticipantMaxTracksExceededError}
     *   if either the total number of published Tracks in the Room exceeds 16, or the {@link LocalTrack}
     *   is part of a set of {@link LocalTrack}s which along with the published Tracks exceeds 16.
     * @throws {TypeError}
     * @throws {RangeError}
     * @example
     * var Video = require('twilio-video');
     *
     * Video.connect(token, {
     *   name: 'my-cool-room',
     *   audio: true
     * }).then(function(room) {
     *   return Video.createLocalVideoTrack({
     *     name: 'camera'
     *   }).then(function(localVideoTrack) {
     *     return room.localParticipant.publishTrack(localVideoTrack, {
     *       priority: 'high'
     *     });
     *   });
     * }).then(function(publication) {
     *   console.log('The LocalTrack "' + publication.trackName
     *     + '" was successfully published with priority "'
     *     * publication.priority + '"');
     * });
    */ /**
     * Publishes a MediaStreamTrack to the {@link Room}.
     * @param {MediaStreamTrack} mediaStreamTrack - The MediaStreamTrack
     *   to publish; if a corresponding {@link LocalAudioTrack} or
     *   {@link LocalVideoTrack} has not yet been published, this method will
     *   construct one
     * @param {MediaStreamTrackPublishOptions} [options] - The options for publishing
     *   the MediaStreamTrack
     * @returns {Promise<LocalTrackPublication>} - Resolves with the corresponding
     *   {@link LocalTrackPublication} if successful; In a Large Group Room (Maximum
     *   Participants greater than 50), rejects with a {@link ParticipantMaxTracksExceededError}
     *   if the total number of published Tracks in the Room exceeds 16, or the {@link LocalTrack}
     *   is part of a set of {@link LocalTrack}s which along with the published Tracks exceeds 16.
     * @throws {TypeError}
     * @throws {RangeError}
     * @example
     * var Video = require('twilio-video');
     *
     * Video.connect(token, {
     *   name: 'my-cool-room',
     *   audio: true
     * }).then(function(room) {
     *   return navigator.mediaDevices.getUserMedia({
     *     video: true
     *   }).then(function(mediaStream) {
     *     var mediaStreamTrack = mediaStream.getTracks()[0];
     *     return room.localParticipant.publishTrack(mediaStreamTrack, {
     *       name: 'camera',
     *       priority: 'high'
     *     });
     *   });
     * }).then(function(publication) {
     *   console.log('The LocalTrack "' + publication.trackName
     *     + '" was successfully published with priority "'
     *     * publication.priority + '"');
     * });
     */
    LocalParticipant.prototype.publishTrack = function (localTrackOrMediaStreamTrack, options) {
        var trackPublication = getTrackPublication(this.tracks, localTrackOrMediaStreamTrack);
        if (trackPublication) {
            return Promise.resolve(trackPublication);
        }
        options = Object.assign({
            log: this._log,
            priority: trackPriority.PRIORITY_STANDARD,
            LocalAudioTrack: this._LocalAudioTrack,
            LocalDataTrack: this._LocalDataTrack,
            LocalVideoTrack: this._LocalVideoTrack,
            MediaStreamTrack: this._MediaStreamTrack
        }, options);
        var localTrack;
        try {
            localTrack = asLocalTrack(localTrackOrMediaStreamTrack, options);
        }
        catch (error) {
            return Promise.reject(error);
        }
        var priorityValues = Object.values(trackPriority);
        if (!priorityValues.includes(options.priority)) {
            // eslint-disable-next-line new-cap
            return Promise.reject(E.INVALID_VALUE('LocalTrackPublishOptions.priority', priorityValues));
        }
        var addedLocalTrack = this._addTrack(localTrack, options.priority)
            || this._tracks.get(localTrack.id);
        return this._getOrCreateLocalTrackPublication(addedLocalTrack);
    };
    /**
     * Publishes multiple {@link LocalTrack}s to the {@link Room}.
     * @param {Array<LocalTrack|MediaStreamTrack>} tracks - The {@link LocalTrack}s
     *   to publish; for any MediaStreamTracks provided, if a corresponding
     *   {@link LocalAudioTrack} or {@link LocalVideoTrack} has not yet been
     *   published, this method will construct one
     * @returns {Promise<Array<LocalTrackPublication>>} - The resulting
     *   {@link LocalTrackPublication}s if successful; In a Large Group Room (Maximum
     *   Participants greater than 50), rejects with a {@link ParticipantMaxTracksExceededError}
     *   if the total number of published Tracks in the Room exceeds 16, or the {@link LocalTrack}s
     *   along with the published Tracks exceeds 16.
     * @throws {TypeError}
     */
    LocalParticipant.prototype.publishTracks = function (tracks) {
        if (!Array.isArray(tracks)) {
            // eslint-disable-next-line new-cap
            throw E.INVALID_TYPE('tracks', 'Array of LocalAudioTrack, LocalVideoTrack, LocalDataTrack, or MediaStreamTrack');
        }
        return Promise.all(tracks.map(this.publishTrack, this));
    };
    LocalParticipant.prototype.setBandwidthProfile = function () {
        this._log.warn('setBandwidthProfile is not implemented yet and may be available in future versions of twilio-video.js');
    };
    /**
     * Sets the {@link NetworkQualityVerbosity} for the {@link LocalParticipant} and
     * {@link RemoteParticipant}s. It does nothing if Network Quality is not enabled
     * while calling {@link connect}.
     * @param {NetworkQualityConfiguration} networkQualityConfiguration - The new
     *   {@link NetworkQualityConfiguration}; If either or both of the local and
     *   remote {@link NetworkQualityVerbosity} values are absent, then the corresponding
     *   existing values are retained
     * @returns {this}
     * @example
     * // Update verbosity levels for both LocalParticipant and RemoteParticipants
     * localParticipant.setNetworkQualityConfiguration({
     *   local: 1,
     *   remote: 2
     * });
     * @example
     * // Update verbosity level for only the LocalParticipant
     * localParticipant.setNetworkQualityConfiguration({
     *   local: 1
     * });
     *  @example
     * // Update verbosity level for only the RemoteParticipants
     * localParticipant.setNetworkQualityConfiguration({
     *   remote: 2
     * });
     */
    LocalParticipant.prototype.setNetworkQualityConfiguration = function (networkQualityConfiguration) {
        if (typeof networkQualityConfiguration !== 'object'
            || networkQualityConfiguration === null) {
            // eslint-disable-next-line new-cap
            throw E.INVALID_TYPE('networkQualityConfiguration', 'NetworkQualityConfiguration');
        }
        ['local', 'remote'].forEach(function (prop) {
            if (prop in networkQualityConfiguration && (typeof networkQualityConfiguration[prop] !== 'number' || isNaN(networkQualityConfiguration[prop]))) {
                // eslint-disable-next-line new-cap
                throw E.INVALID_TYPE("networkQualityConfiguration." + prop, 'number');
            }
        });
        this._signaling.setNetworkQualityConfiguration(networkQualityConfiguration);
        return this;
    };
    /**
     * Set the {@link LocalParticipant}'s {@link EncodingParameters}.
     * @param {?EncodingParameters} [encodingParameters] - The new
     *   {@link EncodingParameters}; If null, then the bitrate limits are removed;
     *   If not specified, then the existing bitrate limits are preserved
     * @returns {this}
     * @throws {TypeError}
     */
    LocalParticipant.prototype.setParameters = function (encodingParameters) {
        if (typeof encodingParameters !== 'undefined'
            && typeof encodingParameters !== 'object') {
            // eslint-disable-next-line new-cap
            throw E.INVALID_TYPE('encodingParameters', 'EncodingParameters, null or undefined');
        }
        if (encodingParameters) {
            if (this._signaling.getParameters().adaptiveSimulcast && encodingParameters.maxVideoBitrate) {
                // eslint-disable-next-line new-cap
                throw E.INVALID_TYPE('encodingParameters', 'encodingParameters.maxVideoBitrate is not compatible with "preferredVideoCodecs=auto"');
            }
            ['maxAudioBitrate', 'maxVideoBitrate'].forEach(function (prop) {
                if (typeof encodingParameters[prop] !== 'undefined'
                    && typeof encodingParameters[prop] !== 'number'
                    && encodingParameters[prop] !== null) {
                    // eslint-disable-next-line new-cap
                    throw E.INVALID_TYPE("encodingParameters." + prop, 'number, null or undefined');
                }
            });
        }
        else if (encodingParameters === null) {
            encodingParameters = { maxAudioBitrate: null, maxVideoBitrate: null };
        }
        this._signaling.setParameters(encodingParameters);
        return this;
    };
    /**
     * Stops publishing a {@link LocalTrack} to the {@link Room}.
     * @param {LocalTrack|MediaStreamTrack} track - The {@link LocalTrack}
     *   to stop publishing; if a MediaStreamTrack is provided, this method
     *   looks up the corresponding {@link LocalAudioTrack} or
     *   {@link LocalVideoTrack} to stop publishing
     * @returns {?LocalTrackPublication} - The corresponding
     *   {@link LocalTrackPublication} if the {@link LocalTrack} was previously
     *   published, null otherwise
     * @throws {TypeError}
    */
    LocalParticipant.prototype.unpublishTrack = function (track) {
        validateLocalTrack(track, {
            LocalAudioTrack: this._LocalAudioTrack,
            LocalDataTrack: this._LocalDataTrack,
            LocalVideoTrack: this._LocalVideoTrack,
            MediaStreamTrack: this._MediaStreamTrack
        });
        var localTrack = this._tracks.get(track.id);
        if (!localTrack) {
            return null;
        }
        var trackSignaling = this._signaling.getPublication(localTrack._trackSender);
        trackSignaling.publishFailed(new Error("The " + localTrack + " was unpublished"));
        localTrack = this._removeTrack(localTrack);
        if (!localTrack) {
            return null;
        }
        var localTrackPublication = getTrackPublication(this.tracks, localTrack);
        if (localTrackPublication) {
            this._removeTrackPublication(localTrackPublication);
        }
        return localTrackPublication;
    };
    /**
     * Stops publishing multiple {@link LocalTrack}s to the {@link Room}.
     * @param {Array<LocalTrack|MediaStreamTrack>} tracks - The {@link LocalTrack}s
     *   to stop publishing; for any MediaStreamTracks provided, this method looks
     *   up the corresponding {@link LocalAudioTrack} or {@link LocalVideoTrack} to
     *   stop publishing
     * @returns {Array<LocalTrackPublication>} - The corresponding
     *   {@link LocalTrackPublication}s that were successfully unpublished
     * @throws {TypeError}
     */
    LocalParticipant.prototype.unpublishTracks = function (tracks) {
        var _this = this;
        if (!Array.isArray(tracks)) {
            // eslint-disable-next-line new-cap
            throw E.INVALID_TYPE('tracks', 'Array of LocalAudioTrack, LocalVideoTrack, LocalDataTrack, or MediaStreamTrack');
        }
        return tracks.reduce(function (unpublishedTracks, track) {
            var unpublishedTrack = _this.unpublishTrack(track);
            return unpublishedTrack ? unpublishedTracks.concat(unpublishedTrack) : unpublishedTracks;
        }, []);
    };
    return LocalParticipant;
}(Participant));
/**
 * The {@link LocalParticipant} has reconnected to the {@link Room} after a signaling connection disruption.
 * @event LocalParticipant#reconnected
 */
/**
 * The {@link LocalParticipant} is reconnecting to the {@link Room} after a signaling connection disruption.
 * @event LocalParticipant#reconnecting
 */
/**
 * One of the {@link LocalParticipant}'s {@link LocalVideoTrack}'s dimensions changed.
 * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} whose dimensions changed
 * @event LocalParticipant#trackDimensionsChanged
 */
/**
 * A {@link LocalTrack} was disabled by the {@link LocalParticipant}.
 * @param {LocalTrack} track - The {@link LocalTrack} that was disabled
 * @event LocalParticipant#trackDisabled
 */
/**
 * A {@link LocalTrack} was enabled by the {@link LocalParticipant}.
 * @param {LocalTrack} track - The {@link LocalTrack} that was enabled
 * @event LocalParticipant#trackEnabled
 */
/**
 * A {@link LocalTrack} failed to publish. Check the error message for more
 * information. In a Large Group Room (Maximum Participants greater than 50),
 * this event is raised with a {@link ParticipantMaxTracksExceededError} either
 * when attempting to publish the {@link LocalTrack} will exceed the Maximum Published
 * Tracks limit of 16, or the {@link LocalTrack} is part of a set of {@link LocalTrack}s
 * which along with the published Tracks exceeds 16.
 * @param {TwilioError} error - A {@link TwilioError} explaining why publication
 *   failed
 * @param {LocalTrack} localTrack - The {@link LocalTrack} that failed to
 *   publish
 * @event LocalParticipant#trackPublicationFailed
 */
/**
 * A {@link LocalTrack} was successfully published.
 * @param {LocalTrackPublication} publication - The resulting
 *   {@link LocalTrackPublication} for the published {@link LocalTrack}
 * @event LocalParticipant#trackPublished
 */
/**
 * One of the {@link LocalParticipant}'s {@link LocalTrack}s started.
 * @param {LocalTrack} track - The {@link LocalTrack} that started
 * @event LocalParticipant#trackStarted
 */
/**
 * One of the {@link LocalParticipant}'s {@link LocalTrack}s stopped, either
 * because {@link LocalTrack#stop} was called or because the underlying
 * MediaStreamTrack ended).
 * @param {LocalTrack} track - The {@link LocalTrack} that stopped
 * @event LocalParticipant#trackStopped
 */
/**
 * Outgoing media encoding parameters.
 * @typedef {object} EncodingParameters
 * @property {?number} [maxAudioBitrate] - Max outgoing audio bitrate (bps);
 *   If not specified, retains the existing bitrate limit; A <code>null</code> or a
 *   <code>0</code> value removes any previously set bitrate limit; This value is set
 *   as a hint for variable bitrate codecs, but will not take effect for fixed bitrate
 *   codecs; Based on our tests, Chrome, Firefox and Safari support a bitrate range of
 *   12000 bps to 256000 bps for Opus codec; This parameter has no effect on iSAC, PCMU
 *   and PCMA codecs
 * @property {?number} [maxVideoBitrate] - Max outgoing video bitrate (bps);
 *   If not specified, retains the existing bitrate limit; A <code>null</code> or
 *   a <code>0</code> value removes any previously set bitrate limit; This value is
 *   set as a hint for variable bitrate codecs, but will not take effect for fixed
 *   bitrate codecs; Based on our tests, Chrome, Firefox and Safari all seem to support
 *   an average bitrate range of 20000 bps (20 kbps) to 8000000 bps (8 mbps) for a
 *   720p VideoTrack.
 *   Note: this limit is not applied for screen share tracks published on Chrome.
 */
/**
 * Options for publishing a {@link LocalTrack}.
 * @typedef {object} LocalTrackPublishOptions
 * @property {Track.Priority} [priority='standard'] - The priority with which the {@link LocalTrack}
 *   is to be published; In Group or Small Group Rooms, the appropriate bandwidth is
 *   allocated to the {@link LocalTrack} based on its {@link Track.Priority}; It has no
 *   effect in Peer-to-Peer Rooms; It defaults to "standard" when not provided
 */
/**
 * Options for publishing a {@link MediaStreamTrack}.
 * @typedef {LocalTrackOptions} MediaStreamTrackPublishOptions
 * @property {Track.Priority} [priority='standard'] - The priority with which the {@link LocalTrack}
 *   is to be published; In Group or Small Group Rooms, the appropriate bandwidth is
 *   allocated to the {@link LocalTrack} based on its {@link Track.Priority}; It has no
 *   effect in Peer-to-Peer Rooms; It defaults to "standard" when not provided
 */
/**
 * @private
 * @param {Map<Track.SID, LocalTrackPublication>} trackPublications
 * @param {LocalTrack|MediaStreamTrack} track
 * @returns {?LocalTrackPublication} trackPublication
 */
function getTrackPublication(trackPublications, track) {
    return Array.from(trackPublications.values()).find(function (trackPublication) { return trackPublication.track === track
        || trackPublication.track.mediaStreamTrack === track; }) || null;
}
module.exports = LocalParticipant;
//# sourceMappingURL=localparticipant.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/audiotrack.js":
/*!*****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/audiotrack.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaTrack = __webpack_require__(/*! ./mediatrack */ "./node_modules/twilio-video/es5/media/track/mediatrack.js");
/**
 * An {@link AudioTrack} is a {@link Track} representing audio.
 * @extends Track
 * @property {boolean} isStarted - Whether or not the {@link AudioTrack} has
 *   started; if the {@link AudioTrack} started, there is enough audio data to
 *   begin playback
 * @property {boolean} isEnabled - Whether or not the {@link AudioTrack} is
 *   enabled; if the {@link AudioTrack} is not enabled, it is "muted"
 * @property {Track.Kind} kind - "audio"
 * @property {?MediaStreamTrack} mediaStreamTrack - Provides access to the underlying
 *   MediaStreamTrack; It is set to <code>null</code> if it is a {@link RemoteAudioTrack}
 *   that is switched off
 * @property {?MediaStreamTrack} processedTrack - The source of processed audio samples.
 * It is always null as audio processing is not currently supported.
 * @emits AudioTrack#disabled
 * @emits AudioTrack#enabled
 * @emits AudioTrack#started
 */
var AudioTrack = /** @class */ (function (_super) {
    __extends(AudioTrack, _super);
    /**
     * Construct an {@link AudioTrack}.
     * @param {?MediaTrackTransceiver} mediaTrackTransceiver
     * @param {{log: Log, name: string}} options
     */
    function AudioTrack(mediaTrackTransceiver, options) {
        return _super.call(this, 'audio', mediaTrackTransceiver, options) || this;
    }
    /**
     * @private
     */
    AudioTrack.prototype._start = function () {
        _super.prototype._start.call(this);
        if (this._dummyEl) {
            // once started let go of dummy element
            this._dummyEl.srcObject = null;
            this._dummyEl = null;
        }
    };
    /**
     * Create an HTMLAudioElement and attach the {@link AudioTrack} to it.
     *
     * The HTMLAudioElement's <code>srcObject</code> will be set to a new
     * MediaStream containing the {@link AudioTrack}'s MediaStreamTrack.
     *
     * @returns {HTMLAudioElement} audioElement
     * @example
     * const Video = require('twilio-video');
     *
     * Video.createLocalAudioTrack().then(function(audioTrack) {
     *   const audioElement = audioTrack.attach();
     *   document.body.appendChild(audioElement);
     * });
    */ /**
     * Attach the {@link AudioTrack} to an existing HTMLMediaElement. The
     * HTMLMediaElement could be an HTMLAudioElement or an HTMLVideoElement.
     *
     * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,
     * this method sets it to a new MediaStream containing the {@link AudioTrack}'s
     * MediaStreamTrack; otherwise, it adds the {@link MediaTrack}'s
     * MediaStreamTrack to the existing MediaStream. Finally, if there are any other
     * MediaStreamTracks of the same kind on the MediaStream, this method removes
     * them.
     *
     * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement to attach to
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * const Video = require('twilio-video');
     *
     * const videoElement = document.createElement('video');
     * document.body.appendChild(videoElement);
     *
     * Video.createLocalAudioTrack().then(function(audioTrack) {
     *   audioTrack.attach(videoElement);
     * });
    */ /**
     * Attach the {@link AudioTrack} to an HTMLMediaElement selected by
     * <code>document.querySelector</code>. The HTMLMediaElement could be an
     * HTMLAudioElement or an HTMLVideoElement.
     *
     * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,
     * this method sets it to a new MediaStream containing the {@link AudioTrack}'s
     * MediaStreamTrack; otherwise, it adds the {@link AudioTrack}'s
     * MediaStreamTrack to the existing MediaStream. Finally, if there are any other
     * MediaStreamTracks of the same kind on the MediaStream, this method removes
     * them.
     *
     * @param {string} selector - A query selector for the HTMLMediaElement to
     *   attach to
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * const Video = require('twilio-video');
     *
     * const videoElement = document.createElement('video');
     * videoElement.id = 'my-video-element';
     * document.body.appendChild(videoElement);
     *
     * Video.createLocalAudioTrack().then(function(track) {
     *   track.attach('#my-video-element');
     * });
     */
    AudioTrack.prototype.attach = function () {
        return _super.prototype.attach.apply(this, arguments);
    };
    /**
     * Detach the {@link AudioTrack} from all previously attached HTMLMediaElements.
     * @returns {Array<HTMLMediaElement>} mediaElements
     * @example
     * const mediaElements = audioTrack.detach();
     * mediaElements.forEach(mediaElement => mediaElement.remove());
    */ /**
     * Detach the {@link AudioTrack} from a previously attached HTMLMediaElement.
     * @param {HTMLMediaElement} mediaElement - One of the HTMLMediaElements to
     *   which the {@link AudioTrack} is attached
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * const videoElement = document.getElementById('my-video-element');
     * audioTrack.detach(videoElement).remove();
    */ /**
     * Detach the {@link AudioTrack} from a previously attached HTMLMediaElement
     *   specified by <code>document.querySelector</code>.
     * @param {string} selector - The query selector of HTMLMediaElement to which
     *    the {@link AudioTrack} is attached
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * audioTrack.detach('#my-video-element').remove();
     */
    AudioTrack.prototype.detach = function () {
        return _super.prototype.detach.apply(this, arguments);
    };
    return AudioTrack;
}(MediaTrack));
/**
 * The {@link AudioTrack} was disabled, i.e. "muted".
 * @param {AudioTrack} track - The {@link AudioTrack} that was disabled
 * @event AudioTrack#disabled
 */
/**
 * The {@link AudioTrack} was enabled, i.e. "unmuted".
 * @param {AudioTrack} track - The {@link AudioTrack} that was enabled
 * @event AudioTrack#enabled
 */
/**
 * The {@link AudioTrack} started. This means there is enough audio data to
 * begin playback.
 * @param {AudioTrack} track - The {@link AudioTrack} that started
 * @event AudioTrack#started
 */
module.exports = AudioTrack;
//# sourceMappingURL=audiotrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/es5/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/es5/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {
    LocalAudioTrack: __webpack_require__(/*! ./localaudiotrack */ "./node_modules/twilio-video/es5/media/track/es5/localaudiotrack.js"),
    LocalVideoTrack: __webpack_require__(/*! ./localvideotrack */ "./node_modules/twilio-video/es5/media/track/es5/localvideotrack.js"),
    LocalDataTrack: __webpack_require__(/*! ./localdatatrack */ "./node_modules/twilio-video/es5/media/track/es5/localdatatrack.js")
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/es5/localaudiotrack.js":
/*!**************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/es5/localaudiotrack.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// eslint-disable-next-line no-warning-comments
// TODO(mroberts): Remove this when we go to the next major version. This is
// only in place so that we can support ES6 classes without requiring `new`.

var inherits = __webpack_require__(/*! util */ "./node_modules/util/util.js").inherits;
var LocalAudioTrackClass = __webpack_require__(/*! ../localaudiotrack */ "./node_modules/twilio-video/es5/media/track/localaudiotrack.js");
function LocalAudioTrack(mediaStreamTrack, options) {
    var track = new LocalAudioTrackClass(mediaStreamTrack, options);
    Object.setPrototypeOf(track, LocalAudioTrack.prototype);
    return track;
}
inherits(LocalAudioTrack, LocalAudioTrackClass);
module.exports = LocalAudioTrack;
//# sourceMappingURL=localaudiotrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/es5/localdatatrack.js":
/*!*************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/es5/localdatatrack.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// eslint-disable-next-line no-warning-comments
// TODO(mroberts): Remove this when we go to the next major version. This is
// only in place so that we can support ES6 classes without requiring `new`.

var inherits = __webpack_require__(/*! util */ "./node_modules/util/util.js").inherits;
var LocalDataTrackClass = __webpack_require__(/*! ../localdatatrack */ "./node_modules/twilio-video/es5/media/track/localdatatrack.js");
function LocalDataTrack(options) {
    var track = new LocalDataTrackClass(options);
    Object.setPrototypeOf(track, LocalDataTrack.prototype);
    return track;
}
inherits(LocalDataTrack, LocalDataTrackClass);
module.exports = LocalDataTrack;
//# sourceMappingURL=localdatatrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/es5/localvideotrack.js":
/*!**************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/es5/localvideotrack.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// eslint-disable-next-line no-warning-comments
// TODO(mroberts): Remove this when we go to the next major version. This is
// only in place so that we can support ES6 classes without requiring `new`.

var inherits = __webpack_require__(/*! util */ "./node_modules/util/util.js").inherits;
var LocalVideoTrackClass = __webpack_require__(/*! ../localvideotrack */ "./node_modules/twilio-video/es5/media/track/localvideotrack.js");
function LocalVideoTrack(mediaStreamTrack, options) {
    var track = new LocalVideoTrackClass(mediaStreamTrack, options);
    Object.setPrototypeOf(track, LocalVideoTrack.prototype);
    return track;
}
inherits(LocalVideoTrack, LocalVideoTrackClass);
module.exports = LocalVideoTrack;
//# sourceMappingURL=localvideotrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/index.js":
/*!************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! ../../eventemitter */ "./node_modules/twilio-video/es5/eventemitter.js");
var _a = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js"), buildLogLevels = _a.buildLogLevels, valueToJSON = _a.valueToJSON;
var DEFAULT_LOG_LEVEL = __webpack_require__(/*! ../../util/constants */ "./node_modules/twilio-video/es5/util/constants.js").DEFAULT_LOG_LEVEL;
var Log = __webpack_require__(/*! ../../util/log */ "./node_modules/twilio-video/es5/util/log.js");
var nInstances = 0;
/**
 * A {@link Track} represents a stream of audio, video, or data.
 * @extends EventEmitter
 * @property {Track.Kind} kind - The {@link Track}'s kind
 * @property {string} name - The {@link Track}'s name
 */
var Track = /** @class */ (function (_super) {
    __extends(Track, _super);
    /**
     * Construct a {@link Track}.
     * @param {Track.Kind} kind - The {@link Track}'s kind
     * @param {{ log: Log, name: string }} options
     */
    function Track(kind, options) {
        var _this = this;
        options = Object.assign({
            log: null,
            logLevel: DEFAULT_LOG_LEVEL
        }, options);
        _this = _super.call(this) || this;
        var name = String(options.name);
        var logLevels = buildLogLevels(options.logLevel);
        var log = options.log
            ? options.log.createLog('media', _this)
            : new Log('media', _this, logLevels, options.loggerName);
        Object.defineProperties(_this, {
            _instanceId: {
                value: ++nInstances
            },
            _log: {
                value: log
            },
            kind: {
                enumerable: true,
                value: kind
            },
            name: {
                enumerable: true,
                value: name
            }
        });
        return _this;
    }
    Track.prototype.toJSON = function () {
        return valueToJSON(this);
    };
    return Track;
}(EventEmitter));
/**
 * The {@link Track} ID is a string identifier for the {@link Track}.
 * @typedef {string} Track.ID
 */
/**
 * The {@link Track} kind is either "audio", "video", or "data".
 * @typedef {string} Track.Kind
 */
/**
 * The {@link Track}'s priority can be "low", "standard", or "high".
 * @typedef {string} Track.Priority
 */
/**
 * The {@link Track} SID is a unique string identifier for the {@link Track}
 * that is published to a {@link Room}.
 * @typedef {string} Track.SID
 */
/**
 * A {@link DataTrack} is a {@link LocalDataTrack} or {@link RemoteDataTrack}.
 * @typedef {LocalDataTrack|RemoteDataTrack} DataTrack
 */
/**
 * A {@link LocalTrack} is a {@link LocalAudioTrack}, {@link LocalVideoTrack},
 * or {@link LocalDataTrack}.
 * @typedef {LocalAudioTrack|LocalVideoTrack|LocalDataTrack} LocalTrack
 */
/**
 * {@link LocalTrack} options
 * @typedef {object} LocalTrackOptions
 * @property {LogLevel|LogLevels} logLevel - Log level for 'media' modules
 * @property {string} [name] - The {@link LocalTrack}'s name; by default,
 *   it is set to the {@link LocalTrack}'s ID.
 */
/**
 * A {@link RemoteTrack} is a {@link RemoteAudioTrack},
 * {@link RemoteVideoTrack}, or {@link RemoteDataTrack}.
 * @typedef {RemoteAudioTrack|RemoteVideoTrack|RemoteDataTrack} RemoteTrack
 */
module.exports = Track;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/localaudiotrack.js":
/*!**********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/localaudiotrack.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var AudioTrack = __webpack_require__(/*! ./audiotrack */ "./node_modules/twilio-video/es5/media/track/audiotrack.js");
var mixinLocalMediaTrack = __webpack_require__(/*! ./localmediatrack */ "./node_modules/twilio-video/es5/media/track/localmediatrack.js");
var LocalMediaAudioTrack = mixinLocalMediaTrack(AudioTrack);
/**
 * A {@link LocalAudioTrack} is an {@link AudioTrack} representing audio that
 * your {@link LocalParticipant} can publish to a {@link Room}. It can be
 * enabled and disabled with {@link LocalAudioTrack#enable} and
 * {@link LocalAudioTrack#disable} or stopped completely with
 * {@link LocalAudioTrack#stop}.
 * @extends AudioTrack
 * @property {Track.ID} id - The {@link LocalAudioTrack}'s ID
 * @property {boolean} isStopped - Whether or not the {@link LocalAudioTrack} is
 *   stopped
 * @emits LocalAudioTrack#disabled
 * @emits LocalAudioTrack#enabled
 * @emits LocalAudioTrack#started
 * @emits LocalAudioTrack#stopped
 */
var LocalAudioTrack = /** @class */ (function (_super) {
    __extends(LocalAudioTrack, _super);
    /**
     * Construct a {@link LocalAudioTrack} from a MediaStreamTrack.
     * @param {MediaStreamTrack} mediaStreamTrack - An audio MediaStreamTrack
     * @param {LocalTrackOptions} [options] - {@link LocalTrack} options
     */
    function LocalAudioTrack(mediaStreamTrack, options) {
        return _super.call(this, mediaStreamTrack, options) || this;
    }
    LocalAudioTrack.prototype.toString = function () {
        return "[LocalAudioTrack #" + this._instanceId + ": " + this.id + "]";
    };
    LocalAudioTrack.prototype.attach = function (el) {
        el = _super.prototype.attach.call(this, el);
        el.muted = true;
        return el;
    };
    /**
     * @private
     */
    LocalAudioTrack.prototype._end = function () {
        return _super.prototype._end.apply(this, arguments);
    };
    /**
     * Disable the {@link LocalAudioTrack}. This is effectively "mute".
     * @returns {this}
     * @fires LocalAudioTrack#disabled
     */
    LocalAudioTrack.prototype.disable = function () {
        return _super.prototype.disable.apply(this, arguments);
    };
    /**
     * Enable the {@link LocalAudioTrack}. This is effectively "unmute".
     * @returns {this}
     * @fires LocalAudioTrack#enabled
    */ /**
     * Enable or disable the {@link LocalAudioTrack}. This is effectively "unmute"
     * or "mute".
     * @param {boolean} [enabled] - Specify false to mute the
     *   {@link LocalAudioTrack}
     * @returns {this}
     * @fires LocalAudioTrack#disabled
     * @fires LocalAudioTrack#enabled
     */
    LocalAudioTrack.prototype.enable = function () {
        return _super.prototype.enable.apply(this, arguments);
    };
    /**
     * Restart the {@link LocalAudioTrack}. This stops the existing MediaStreamTrack
     * and creates a new MediaStreamTrack. If the {@link LocalAudioTrack} is being published
     * to a {@link Room}, then all the {@link RemoteParticipant}s will start receiving media
     * from the newly created MediaStreamTrack. You can access the new MediaStreamTrack via
     * the <code>mediaStreamTrack</code> property. If you want to listen to events on
     * the MediaStreamTrack directly, please do so in the "started" event handler. Also,
     * the {@link LocalAudioTrack}'s ID is no longer guaranteed to be the same as the
     * underlying MediaStreamTrack's ID.
     * @param {MediaTrackConstraints} [constraints] - The optional <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints" target="_blank">MediaTrackConstraints</a>
     *   for restarting the {@link LocalAudioTrack}; If not specified, then the current MediaTrackConstraints
     *   will be used; If <code>{}</code> (empty object) is specified, then the default MediaTrackConstraints
     *   will be used
     * @returns {Promise<void>} Rejects with a TypeError if the {@link LocalAudioTrack} was not created
     *   using an one of <code>createLocalAudioTrack</code>, <code>createLocalTracks</code> or <code>connect</code>;
     *   Also rejects with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Exceptions" target="_blank">DOMException</a>
     *   raised by <code>getUserMedia</code> when it fails
     * @fires LocalAudioTrack#stopped
     * @fires LocalAudioTrack#started
     * @example
     * const { connect, createLocalAudioTrack } = require('twilio-video');
     *
     * // Create a LocalAudioTrack that captures audio from a USB microphone.
     * createLocalAudioTrack({ deviceId: 'usb-mic-id' }).then(function(localAudioTrack) {
     *   return connect('token', {
     *     name: 'my-cool-room',
     *     tracks: [localAudioTrack]
     *   });
     * }).then(function(room) {
     *   // Restart the LocalAudioTrack to capture audio from the default microphone.
     *   const localAudioTrack = Array.from(room.localParticipant.audioTracks.values())[0].track;
     *   return localAudioTrack.restart({ deviceId: 'default-mic-id' });
     * });
     */
    LocalAudioTrack.prototype.restart = function () {
        return _super.prototype.restart.apply(this, arguments);
    };
    /**
     * Calls stop on the underlying MediaStreamTrack. If you choose to stop a
     * {@link LocalAudioTrack}, you should unpublish it after stopping.
     * @returns {this}
     * @fires LocalAudioTrack#stopped
     */
    LocalAudioTrack.prototype.stop = function () {
        return _super.prototype.stop.apply(this, arguments);
    };
    return LocalAudioTrack;
}(LocalMediaAudioTrack));
/**
 * The {@link LocalAudioTrack} was disabled, i.e. "muted".
 * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was
 *   disabled
 * @event LocalAudioTrack#disabled
 */
/**
 * The {@link LocalAudioTrack} was enabled, i.e. "unmuted".
 * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was enabled
 * @event LocalAudioTrack#enabled
 */
/**
 * The {@link LocalAudioTrack} started. This means there is enough audio data to
 * begin playback.
 * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that started
 * @event LocalAudioTrack#started
 */
/**
 * The {@link LocalAudioTrack} stopped, either because {@link LocalAudioTrack#stop}
 * or {@link LocalAudioTrack#restart} was called or because the underlying
 * MediaStreamTrack ended.
 * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that stopped
 * @event LocalAudioTrack#stopped
 */
module.exports = LocalAudioTrack;
//# sourceMappingURL=localaudiotrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/localaudiotrackpublication.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/localaudiotrackpublication.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalTrackPublication = __webpack_require__(/*! ./localtrackpublication */ "./node_modules/twilio-video/es5/media/track/localtrackpublication.js");
/**
 * A {@link LocalAudioTrackPublication} is a {@link LocalAudioTrack} that has
 * been published to a {@link Room}.
 * @extends LocalTrackPublication
 * @property {Track.Kind} kind - "audio"
 * @property {LocalAudioTrack} track - the {@link LocalAudioTrack}
 */
var LocalAudioTrackPublication = /** @class */ (function (_super) {
    __extends(LocalAudioTrackPublication, _super);
    /**
     * Construct a {@link LocalAudioTrackPublication}.
     * @param {LocalTrackPublicationSignaling} signaling - The corresponding
     *   {@link LocalTrackPublicationSignaling}
     * @param {LocalAudioTrack} track - the {@link LocalAudioTrack}
     * @param {function(LocalTrackPublication): void} unpublish - The callback
     *    that unpublishes the {@link LocalTrackPublication}
     * @param {TrackPublicationOptions} options - {@link LocalTrackPublication} options
     */
    function LocalAudioTrackPublication(signaling, track, unpublish, options) {
        return _super.call(this, signaling, track, unpublish, options) || this;
    }
    LocalAudioTrackPublication.prototype.toString = function () {
        return "[LocalAudioTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return LocalAudioTrackPublication;
}(LocalTrackPublication));
module.exports = LocalAudioTrackPublication;
//# sourceMappingURL=localaudiotrackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/localdatatrack.js":
/*!*********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/localdatatrack.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Track = __webpack_require__(/*! ./ */ "./node_modules/twilio-video/es5/media/track/index.js");
var DefaultDataTrackSender = __webpack_require__(/*! ../../data/sender */ "./node_modules/twilio-video/es5/data/sender.js");
/**
 * A {@link LocalDataTrack} is a {@link Track} representing data that your
 * {@link LocalParticipant} can publish to a {@link Room}.
 * @extends Track
 * @property {Track.ID} id - The {@link LocalDataTrack}'s ID
 * @property {Track.Kind} kind - "data"
 * @property {?number} maxPacketLifeTime - If non-null, this represents a time
 *   limit (in milliseconds) during which the {@link LocalDataTrack} will send
 *   or re-send data if not acknowledged on the underlying RTCDataChannel(s).
 * @property {?number} maxRetransmits - If non-null, this represents the number
 *   of times the {@link LocalDataTrack} will resend data if not successfully
 *   delivered on the underlying RTCDataChannel(s).
 * @property {boolean} ordered - true if data on the {@link LocalDataTrack} is
 *   guaranteed to be sent in order.
 * @property {boolean} reliable - This is true if both
 *   <code>maxPacketLifeTime</code> and <code>maxRetransmits</code> are set to
 *   null. In other words, if this is true, there is no bound on packet lifetime
 *   or the number of times the {@link LocalDataTrack} will attempt to send
 *   data, ensuring "reliable" transmission.
 * @example
 * var Video = require('twilio-video');
 *
 * var localDataTrack = new Video.LocalDataTrack();
 * window.addEventListener('mousemove', function(event) {
 *   localDataTrack.send(JSON.stringify({
 *     x: e.clientX,
 *     y: e.clientY
 *   }));
 * });
 *
 * var token1 = getAccessToken();
 * Video.connect(token1, {
 *   name: 'my-cool-room',
 *   tracks: [localDataTrack]
 * });
 *
 * var token2 = getAccessToken();
 * Video.connect(token2, {
 *   name: 'my-cool-room',
 *   tracks: []
 * }).then(function(room) {
 *   room.on('trackSubscribed', function(track) {
 *     track.on('message', function(message) {
 *       console.log(JSON.parse(message)); // { x: <number>, y: <number> }
 *     });
 *   });
 * });
 */
var LocalDataTrack = /** @class */ (function (_super) {
    __extends(LocalDataTrack, _super);
    /**
     * Construct a {@link LocalDataTrack}.
     * @param {LocalDataTrackOptions} [options] - {@link LocalDataTrack} options
     */
    function LocalDataTrack(options) {
        var _this = this;
        options = Object.assign({
            DataTrackSender: DefaultDataTrackSender,
            maxPacketLifeTime: null,
            maxRetransmits: null,
            ordered: true
        }, options);
        var DataTrackSender = options.DataTrackSender;
        var dataTrackSender = new DataTrackSender(options.maxPacketLifeTime, options.maxRetransmits, options.ordered);
        options = Object.assign({
            name: dataTrackSender.id
        }, options);
        _this = _super.call(this, 'data', options) || this;
        Object.defineProperties(_this, {
            _trackSender: {
                value: dataTrackSender
            },
            id: {
                enumerable: true,
                value: dataTrackSender.id
            },
            maxPacketLifeTime: {
                enumerable: true,
                value: options.maxPacketLifeTime
            },
            maxRetransmits: {
                enumerable: true,
                value: options.maxRetransmits
            },
            ordered: {
                enumerable: true,
                value: options.ordered
            },
            reliable: {
                enumerable: true,
                value: options.maxPacketLifeTime === null
                    && options.maxRetransmits === null
            }
        });
        return _this;
    }
    /**
     * Send a message over the {@link LocalDataTrack}.
     * @param {string|Blob|ArrayBuffer|ArrayBufferView} data
     * @returns {void}
     */
    LocalDataTrack.prototype.send = function (data) {
        this._trackSender.send(data);
    };
    return LocalDataTrack;
}(Track));
/**
 * {@link LocalDataTrack} options
 * @typedef {LocalTrackOptions} LocalDataTrackOptions
 * @property {?number} [maxPacketLifeTime=null] - Set this to limit the time
 *   (in milliseconds) during which the LocalDataTrack will send or re-send data
 *   if not successfully delivered on the underlying RTCDataChannel(s). It is an
 *   error to specify both this and <code>maxRetransmits</code>.
 * @property {?number} [maxRetransmits=null] - Set this to limit the number of
 *   times the {@link LocalDataTrack} will send or re-send data if not
 *   acknowledged on the underlying RTCDataChannel(s). It is an error to specify
 *   both this and <code>maxPacketLifeTime</code>.
 * @property {boolean} [ordered=true] - Set this to false to allow data on the
 *   LocalDataTrack to be sent out-of-order.
 */
module.exports = LocalDataTrack;
//# sourceMappingURL=localdatatrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/localdatatrackpublication.js":
/*!********************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/localdatatrackpublication.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalTrackPublication = __webpack_require__(/*! ./localtrackpublication */ "./node_modules/twilio-video/es5/media/track/localtrackpublication.js");
/**
 * A {@link LocalDataTrackPublication} is a {@link LocalDataTrack} that has been
 * published to a {@link Room}.
 * @extends LocalTrackPublication
 * @property {Track.Kind} kind - "data"
 * @property {LocalDataTrack} track - the {@link LocalDataTrack}
 */
var LocalDataTrackPublication = /** @class */ (function (_super) {
    __extends(LocalDataTrackPublication, _super);
    /**
     * Construct a {@link LocalDataTrackPublication}.
     * @param {LocalTrackPublicationSignaling} signaling - The corresponding
     *   {@link LocalTrackPublicationSignaling}
     * @param {LocalDataTrack} track - the {@link LocalDataTrack}
     * @param {function(LocalTrackPublication): void} unpublish - The callback
     *    that unpublishes the {@link LocalTrackPublication}
     * @param {TrackPublicationOptions} options - {@link LocalTrackPublication} options
     */
    function LocalDataTrackPublication(signaling, track, unpublish, options) {
        return _super.call(this, signaling, track, unpublish, options) || this;
    }
    LocalDataTrackPublication.prototype.toString = function () {
        return "[LocalDataTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return LocalDataTrackPublication;
}(LocalTrackPublication));
module.exports = LocalDataTrackPublication;
//# sourceMappingURL=localdatatrackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/localmediatrack.js":
/*!**********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/localmediatrack.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint new-cap:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var getUserMedia = __webpack_require__(/*! ../../webrtc */ "./node_modules/twilio-video/es5/webrtc/index.js").getUserMedia;
var _a = __webpack_require__(/*! ../../webrtc/util */ "./node_modules/twilio-video/es5/webrtc/util/index.js"), guessBrowser = _a.guessBrowser, isIOSChrome = _a.isIOSChrome;
var _b = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js"), capitalize = _b.capitalize, defer = _b.defer, isUserMediaTrack = _b.isUserMediaTrack, waitForSometime = _b.waitForSometime, waitForEvent = _b.waitForEvent;
var ILLEGAL_INVOKE = __webpack_require__(/*! ../../util/constants */ "./node_modules/twilio-video/es5/util/constants.js").typeErrors.ILLEGAL_INVOKE;
var detectSilentAudio = __webpack_require__(/*! ../../util/detectsilentaudio */ "./node_modules/twilio-video/es5/util/detectsilentaudio.js");
var detectSilentVideo = __webpack_require__(/*! ../../util/detectsilentvideo */ "./node_modules/twilio-video/es5/util/detectsilentvideo.js");
var documentVisibilityMonitor = __webpack_require__(/*! ../../util/documentvisibilitymonitor.js */ "./node_modules/twilio-video/es5/util/documentvisibilitymonitor.js");
var localMediaRestartDeferreds = __webpack_require__(/*! ../../util/localmediarestartdeferreds */ "./node_modules/twilio-video/es5/util/localmediarestartdeferreds.js");
var gUMSilentTrackWorkaround = __webpack_require__(/*! ../../webaudio/workaround180748 */ "./node_modules/twilio-video/es5/webaudio/workaround180748.js");
var MediaTrackSender = __webpack_require__(/*! ./sender */ "./node_modules/twilio-video/es5/media/track/sender.js");
function mixinLocalMediaTrack(AudioOrVideoTrack) {
    /**
     * A {@link LocalMediaTrack} represents audio or video that your
     * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be
     * enabled and disabled with {@link LocalMediaTrack#enable} and
     * {@link LocalMediaTrack#disable} or stopped completely with
     * {@link LocalMediaTrack#stop}.
     * @emits LocalMediaTrack#stopped
     */
    return /** @class */ (function (_super) {
        __extends(LocalMediaTrack, _super);
        /**
         * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.
         * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack
         * @param {LocalTrackOptions} [options] - {@link LocalTrack} options
         */
        function LocalMediaTrack(mediaStreamTrack, options) {
            var _this = this;
            // NOTE(mpatwardhan): by default workaround for WebKitBug1208516 will be enabled on Safari browsers
            // although the bug is seen  mainly on iOS devices, we do not have a reliable way to tell iOS from MacOs
            // userAgent on iOS pretends its macOs if Safari is set to request desktop pages.
            var workaroundWebKitBug1208516 = (guessBrowser() === 'safari' || isIOSChrome())
                && isUserMediaTrack(mediaStreamTrack)
                && typeof document === 'object'
                && typeof document.addEventListener === 'function'
                && typeof document.visibilityState === 'string';
            options = Object.assign({
                getUserMedia: getUserMedia,
                isCreatedByCreateLocalTracks: false,
                name: mediaStreamTrack.id,
                workaroundWebKitBug1208516: workaroundWebKitBug1208516,
                gUMSilentTrackWorkaround: gUMSilentTrackWorkaround
            }, options);
            var mediaTrackSender = new MediaTrackSender(mediaStreamTrack);
            var kind = mediaTrackSender.kind;
            _this = _super.call(this, mediaTrackSender, options) || this;
            Object.defineProperties(_this, {
                _constraints: {
                    value: typeof options[kind] === 'object'
                        ? options[kind]
                        : {},
                    writable: true
                },
                _getUserMedia: {
                    value: options.getUserMedia
                },
                _gUMSilentTrackWorkaround: {
                    value: options.gUMSilentTrackWorkaround
                },
                _workaroundWebKitBug1208516: {
                    value: options.workaroundWebKitBug1208516
                },
                _workaroundWebKitBug1208516Cleanup: {
                    value: null,
                    writable: true
                },
                _didCallEnd: {
                    value: false,
                    writable: true
                },
                _isCreatedByCreateLocalTracks: {
                    value: options.isCreatedByCreateLocalTracks
                },
                _trackSender: {
                    value: mediaTrackSender
                },
                id: {
                    enumerable: true,
                    value: mediaTrackSender.id
                },
                isEnabled: {
                    enumerable: true,
                    get: function () {
                        return mediaTrackSender.enabled;
                    }
                },
                isStopped: {
                    enumerable: true,
                    get: function () {
                        return mediaTrackSender.readyState === 'ended';
                    }
                }
            });
            // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,
            // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.
            if (_this._workaroundWebKitBug1208516) {
                _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);
            }
            return _this;
        }
        /**
         * @private
         */
        LocalMediaTrack.prototype._end = function () {
            if (this._didCallEnd) {
                return;
            }
            _super.prototype._end.call(this);
            this._didCallEnd = true;
            this.emit('stopped', this);
        };
        /**
         * @private
         */
        LocalMediaTrack.prototype._initialize = function () {
            if (this._didCallEnd) {
                this._didCallEnd = false;
            }
            _super.prototype._initialize.call(this);
        };
        /**
         * @private
         */
        LocalMediaTrack.prototype._reacquireTrack = function (constraints) {
            var _a;
            var _b = this, getUserMedia = _b._getUserMedia, gUMSilentTrackWorkaround = _b._gUMSilentTrackWorkaround, log = _b._log, kind = _b.mediaStreamTrack.kind;
            log.info('Re-acquiring the MediaStreamTrack');
            log.debug('Constraints:', constraints);
            var gUMConstraints = Object.assign({
                audio: false,
                video: false
            }, (_a = {}, _a[kind] = constraints, _a));
            var gUMPromise = this._workaroundWebKitBug1208516Cleanup
                ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints)
                : getUserMedia(gUMConstraints);
            return gUMPromise.then(function (mediaStream) {
                return mediaStream.getTracks()[0];
            });
        };
        /**
         * @private
         */
        LocalMediaTrack.prototype._restart = function (constraints) {
            var _this = this;
            var log = this._log;
            constraints = constraints || this._constraints;
            // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack
            // without stopping it first, then a NotReadableError is raised in case of
            // video, or the restarted audio will still be silent. Hence, we stop the
            // MediaStreamTrack here.
            this._stop();
            return this._reacquireTrack(constraints).catch(function (error) {
                log.error('Failed to re-acquire the MediaStreamTrack:', { error: error, constraints: constraints });
                throw error;
            }).then(function (newMediaStreamTrack) {
                log.info('Re-acquired the MediaStreamTrack');
                log.debug('MediaStreamTrack:', newMediaStreamTrack);
                _this._constraints = Object.assign({}, constraints);
                return _this._setMediaStreamTrack(newMediaStreamTrack);
            });
        };
        /**
         * @private
         */
        LocalMediaTrack.prototype._setMediaStreamTrack = function (mediaStreamTrack) {
            var _this = this;
            // NOTE(mpatwardhan): Preserve the value of the "enabled" flag.
            mediaStreamTrack.enabled = this.mediaStreamTrack.enabled;
            // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already
            // stopped, this should fire a "stopped" event.
            this._stop();
            // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has
            // the processedTrack already set, we don't want to replace that.
            return (this._unprocessedTrack ? Promise.resolve().then(function () {
                _this._unprocessedTrack = mediaStreamTrack;
            }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(function (error) {
                _this._log.warn('setMediaStreamTrack failed:', { error: error, mediaStreamTrack: mediaStreamTrack });
            })).then(function () {
                _this._initialize();
                _this._getAllAttachedElements().forEach(function (el) { return _this._attach(el); });
            });
        };
        /**
         * @private
         */
        LocalMediaTrack.prototype._stop = function () {
            this.mediaStreamTrack.stop();
            this._end();
            return this;
        };
        LocalMediaTrack.prototype.enable = function (enabled) {
            enabled = typeof enabled === 'boolean' ? enabled : true;
            if (enabled !== this.mediaStreamTrack.enabled) {
                this._log.info((enabled ? 'En' : 'Dis') + "abling");
                this.mediaStreamTrack.enabled = enabled;
                this.emit(enabled ? 'enabled' : 'disabled', this);
            }
            return this;
        };
        LocalMediaTrack.prototype.disable = function () {
            return this.enable(false);
        };
        LocalMediaTrack.prototype.restart = function (constraints) {
            var _this = this;
            var kind = this.kind;
            if (!this._isCreatedByCreateLocalTracks) {
                return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a'
                    + (" Local" + capitalize(kind) + "Track that is created using createLocalTracks")
                    + (" or createLocal" + capitalize(kind) + "Track.")));
            }
            if (this._workaroundWebKitBug1208516Cleanup) {
                this._workaroundWebKitBug1208516Cleanup();
                this._workaroundWebKitBug1208516Cleanup = null;
            }
            var promise = this._restart(constraints);
            if (this._workaroundWebKitBug1208516) {
                promise = promise.finally(function () {
                    _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);
                });
            }
            return promise;
        };
        LocalMediaTrack.prototype.stop = function () {
            this._log.info('Stopping');
            if (this._workaroundWebKitBug1208516Cleanup) {
                this._workaroundWebKitBug1208516Cleanup();
                this._workaroundWebKitBug1208516Cleanup = null;
            }
            return this._stop();
        };
        return LocalMediaTrack;
    }(AudioOrVideoTrack));
}
/**
 * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.
 * @private
 * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack
 * @returns {function} Clean up listeners attached by the workaround
 */
function restartWhenInadvertentlyStopped(localMediaTrack) {
    var log = localMediaTrack._log, kind = localMediaTrack.kind;
    var detectSilence = { audio: detectSilentAudio, video: detectSilentVideo }[kind];
    var el = localMediaTrack._dummyEl, mediaStreamTrack = localMediaTrack.mediaStreamTrack;
    var trackChangeInProgress = null;
    function checkSilence() {
        // The dummy element is paused, so play it and then detect silence.
        return el.play().then(function () { return detectSilence(el); }).then(function (isSilent) {
            if (isSilent) {
                log.warn('Silence detected');
            }
            else {
                log.info('Non-silence detected');
            }
            return isSilent;
        }).catch(function (error) {
            log.warn('Failed to detect silence:', error);
        }).finally(function () {
            // Pause the dummy element again.
            el.pause();
        });
    }
    function shouldReacquireTrack() {
        var _workaroundWebKitBug1208516Cleanup = localMediaTrack._workaroundWebKitBug1208516Cleanup, isStopped = localMediaTrack.isStopped, muted = localMediaTrack.mediaStreamTrack.muted;
        var isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup;
        // NOTE(mmalavalli): Restart the LocalMediaTrack if:
        // 1. The app is foregrounded, and
        // 2. A restart is not already in progress, and
        // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent
        return Promise.resolve().then(function () {
            return document.visibilityState === 'visible'
                && !trackChangeInProgress
                && (muted || isInadvertentlyStopped || checkSilence());
        });
    }
    function maybeRestart() {
        return Promise.race([
            waitForEvent(mediaStreamTrack, 'unmute'),
            waitForSometime(50)
        ]).then(function () { return shouldReacquireTrack(); }).then(function (shouldReacquire) {
            if (shouldReacquire && !trackChangeInProgress) {
                trackChangeInProgress = defer();
                localMediaTrack._restart().finally(function () {
                    el = localMediaTrack._dummyEl;
                    removeMediaStreamTrackListeners();
                    mediaStreamTrack = localMediaTrack.mediaStreamTrack;
                    addMediaStreamTrackListeners();
                    trackChangeInProgress.resolve();
                    trackChangeInProgress = null;
                }).catch(function (error) {
                    log.error('failed to restart track: ', error);
                });
            }
            // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,
            // then this makes sure that visibility callback for phase 2 is called only
            // after the MediaStreamTrack is re-acquired.
            var promise = (trackChangeInProgress && trackChangeInProgress.promise) || Promise.resolve();
            return promise.finally(function () { return localMediaRestartDeferreds.resolveDeferred(kind); });
        }).catch(function (ex) {
            log.error("error in maybeRestart: " + ex.message);
        });
    }
    function onMute() {
        var log = localMediaTrack._log, kind = localMediaTrack.kind;
        log.info('Muted');
        log.debug('LocalMediaTrack:', localMediaTrack);
        // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being
        // backgrounded, and the inadvertently paused elements are played before it
        // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,
        // setting this Deferred will make sure that the inadvertently paused elements
        // are played only after the LocalMediaTrack is unmuted.
        //
        // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853
        //
        localMediaRestartDeferreds.startDeferred(kind);
    }
    function addMediaStreamTrackListeners() {
        mediaStreamTrack.addEventListener('ended', maybeRestart);
        mediaStreamTrack.addEventListener('mute', onMute);
        mediaStreamTrack.addEventListener('unmute', maybeRestart);
    }
    function removeMediaStreamTrackListeners() {
        mediaStreamTrack.removeEventListener('ended', maybeRestart);
        mediaStreamTrack.removeEventListener('mute', onMute);
        mediaStreamTrack.removeEventListener('unmute', maybeRestart);
    }
    // NOTE(mpatwardhan): listen for document visibility callback on phase 1.
    // this ensures that we acquire media tracks before RemoteMediaTrack
    // tries to `play` them (in phase 2). This order is important because
    // play can fail on safari if audio is not being captured.
    var onVisibilityChange = function (isVisible) {
        return isVisible ? maybeRestart() : false;
    };
    documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);
    addMediaStreamTrackListeners();
    return function () {
        documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);
        removeMediaStreamTrackListeners();
    };
}
module.exports = mixinLocalMediaTrack;
//# sourceMappingURL=localmediatrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/localtrackpublication.js":
/*!****************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/localtrackpublication.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint new-cap:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackPublication = __webpack_require__(/*! ./trackpublication */ "./node_modules/twilio-video/es5/media/track/trackpublication.js");
var _a = __webpack_require__(/*! ../../util/constants */ "./node_modules/twilio-video/es5/util/constants.js"), E = _a.typeErrors, trackPriority = _a.trackPriority;
/**
 * A {@link LocalTrackPublication} is a {@link LocalTrack} that has been
 * published to a {@link Room}.
 * @extends TrackPublication
 * @property {boolean} isTrackEnabled - whether the published {@link LocalTrack}
 *   is enabled
 * @property {Track.Kind} kind - kind of the published {@link LocalTrack}
 * @property {Track.Priority} priority - the publish priority of the {@link LocalTrack}
 * @property {LocalTrack} track - the {@link LocalTrack}
 */
var LocalTrackPublication = /** @class */ (function (_super) {
    __extends(LocalTrackPublication, _super);
    /**
     * Construct a {@link LocalTrackPublication}.
     * @param {LocalTrackPublicationSignaling} signaling - The corresponding
     *   {@link LocalTrackPublicationSignaling}
     * @param {LocalTrack} track - The {@link LocalTrack}
     * @param {function(LocalTrackPublication): void} unpublish - The callback
     *   that unpublishes the {@link LocalTrackPublication}
     * @param {TrackPublicationOptions} options - {@link LocalTrackPublication}
     *   options
     */
    function LocalTrackPublication(signaling, track, unpublish, options) {
        var _this = _super.call(this, track.name, signaling.sid, options) || this;
        Object.defineProperties(_this, {
            _reemitTrackEvent: {
                value: function () { return _this.emit(_this.isTrackEnabled
                    ? 'trackEnabled'
                    : 'trackDisabled'); }
            },
            _signaling: {
                value: signaling
            },
            _unpublish: {
                value: unpublish
            },
            isTrackEnabled: {
                enumerable: true,
                get: function () {
                    return this.track.kind === 'data' ? true : this.track.isEnabled;
                }
            },
            kind: {
                enumerable: true,
                value: track.kind
            },
            priority: {
                enumerable: true,
                get: function () {
                    return signaling.updatedPriority;
                }
            },
            track: {
                enumerable: true,
                value: track
            }
        });
        track.on('disabled', _this._reemitTrackEvent);
        track.on('enabled', _this._reemitTrackEvent);
        return _this;
    }
    LocalTrackPublication.prototype.toString = function () {
        return "[LocalTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    /**
     * Update the {@link Track.Priority} of the published {@link LocalTrack}.
     * @param {Track.Priority} priority - the new {@link Track.priority}
     * @returns {this}
     * @throws {RangeError}
     */
    LocalTrackPublication.prototype.setPriority = function (priority) {
        var priorityValues = Object.values(trackPriority);
        if (!priorityValues.includes(priority)) {
            throw E.INVALID_VALUE('priority', priorityValues);
        }
        this._signaling.setPriority(priority);
        return this;
    };
    /**
     * Unpublish a {@link LocalTrackPublication}. This means that the media
     * from this {@link LocalTrackPublication} is no longer available to the
     * {@link Room}'s {@link RemoteParticipant}s.
     * @returns {this}
     */
    LocalTrackPublication.prototype.unpublish = function () {
        this.track.removeListener('disabled', this._reemitTrackEvent);
        this.track.removeListener('enabled', this._reemitTrackEvent);
        this._unpublish(this);
        return this;
    };
    return LocalTrackPublication;
}(TrackPublication));
module.exports = LocalTrackPublication;
//# sourceMappingURL=localtrackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/localvideotrack.js":
/*!**********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/localvideotrack.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _a = __webpack_require__(/*! ../../webrtc/util */ "./node_modules/twilio-video/es5/webrtc/util/index.js"), guessBrowser = _a.guessBrowser, isIOSChrome = _a.isIOSChrome;
var detectSilentVideo = __webpack_require__(/*! ../../util/detectsilentvideo */ "./node_modules/twilio-video/es5/util/detectsilentvideo.js");
var mixinLocalMediaTrack = __webpack_require__(/*! ./localmediatrack */ "./node_modules/twilio-video/es5/media/track/localmediatrack.js");
var VideoTrack = __webpack_require__(/*! ./videotrack */ "./node_modules/twilio-video/es5/media/track/videotrack.js");
var isUserMediaTrack = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js").isUserMediaTrack;
var LocalMediaVideoTrack = mixinLocalMediaTrack(VideoTrack);
/**
 * A {@link LocalVideoTrack} is a {@link VideoTrack} representing video that
 * your {@link LocalParticipant} can publish to a {@link Room}. It can be
 * enabled and disabled with {@link LocalVideoTrack#enable} and
 * {@link LocalVideoTrack#disable} or stopped completely with
 * {@link LocalVideoTrack#stop}.
 * @extends VideoTrack
 * @property {Track.ID} id - The {@link LocalVideoTrack}'s ID
 * @property {boolean} isStopped - Whether or not the {@link LocalVideoTrack} is
 *   stopped
 * @emits LocalVideoTrack#disabled
 * @emits LocalVideoTrack#enabled
 * @emits LocalVideoTrack#started
 * @emits LocalVideoTrack#stopped
 */
var LocalVideoTrack = /** @class */ (function (_super) {
    __extends(LocalVideoTrack, _super);
    /**
     * Construct a {@link LocalVideoTrack} from a MediaStreamTrack.
     * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack
     * @param {LocalTrackOptions} [options] - {@link LocalTrack} options
     */
    function LocalVideoTrack(mediaStreamTrack, options) {
        var _this = this;
        options = Object.assign({
            workaroundSilentLocalVideo: (guessBrowser() === 'safari' || isIOSChrome())
                && isUserMediaTrack(mediaStreamTrack)
                && typeof document !== 'undefined'
                && typeof document.createElement === 'function'
        }, options);
        _this = _super.call(this, mediaStreamTrack, options) || this;
        Object.defineProperties(_this, {
            _workaroundSilentLocalVideo: {
                value: options.workaroundSilentLocalVideo
                    ? workaroundSilentLocalVideo
                    : null
            },
            _workaroundSilentLocalVideoCleanup: {
                value: null,
                writable: true
            }
        });
        // NOTE(mmalavalli): In iOS Safari, we work around a bug where local video
        // MediaStreamTracks are silent (even though they are enabled, live and unmuted)
        // after accepting/rejecting a phone call.
        if (_this._workaroundSilentLocalVideo) {
            _this._workaroundSilentLocalVideoCleanup = _this._workaroundSilentLocalVideo(_this, document);
        }
        return _this;
    }
    LocalVideoTrack.prototype.toString = function () {
        return "[LocalVideoTrack #" + this._instanceId + ": " + this.id + "]";
    };
    /**
     * @private
     */
    LocalVideoTrack.prototype._checkIfCanCaptureFrames = function () {
        return _super.prototype._checkIfCanCaptureFrames.call(this, this._trackSender.isPublishing);
    };
    /**
     * @private
     */
    LocalVideoTrack.prototype._end = function () {
        return _super.prototype._end.apply(this, arguments);
    };
    /**
     * @private
     */
    LocalVideoTrack.prototype._setSenderMediaStreamTrack = function (useProcessed) {
        var _this = this;
        var unprocessedTrack = this.mediaStreamTrack;
        var mediaStreamTrack = useProcessed ? this.processedTrack : unprocessedTrack;
        return this._trackSender.setMediaStreamTrack(mediaStreamTrack)
            .catch(function (error) { return _this._log.warn('setMediaStreamTrack failed on LocalVideoTrack RTCRtpSender', { error: error, mediaStreamTrack: mediaStreamTrack }); })
            .then(function () {
            _this._unprocessedTrack = useProcessed ? unprocessedTrack : null;
        });
    };
    /**
     * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.
     * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.
     * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.
     * @returns {this}
     * @example
     * class GrayScaleProcessor {
     *   constructor(percentage) {
     *     this.percentage = percentage;
     *   }
     *   processFrame(inputFrameBuffer, outputFrameBuffer) {
     *     const context = outputFrameBuffer.getContext('2d');
     *     context.filter = `grayscale(${this.percentage}%)`;
     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
     *   }
     * }
     *
     * const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;
     * localVideoTrack.addProcessor(new GrayScaleProcessor(100));
     */
    LocalVideoTrack.prototype.addProcessor = function () {
        this._log.debug('Adding VideoProcessor to the LocalVideoTrack');
        var result = _super.prototype.addProcessor.apply(this, arguments);
        if (!this.processedTrack) {
            return this._log.warn('Unable to add a VideoProcessor to the LocalVideoTrack');
        }
        this._log.debug('Updating LocalVideoTrack\'s MediaStreamTrack with the processed MediaStreamTrack', this.processedTrack);
        this._setSenderMediaStreamTrack(true);
        return result;
    };
    /**
     * Remove the previously added {@link VideoProcessor} using `addProcessor` API.
     * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.
     * @returns {this}
     * @example
     * class GrayScaleProcessor {
     *   constructor(percentage) {
     *     this.percentage = percentage;
     *   }
     *   processFrame(inputFrameBuffer, outputFrameBuffer) {
     *     const context = outputFrameBuffer.getContext('2d');
     *     context.filter = `grayscale(${this.percentage}%)`;
     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
     *   }
     * }
     *
     * const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;
     * const grayScaleProcessor = new GrayScaleProcessor(100);
     * localVideoTrack.addProcessor(grayScaleProcessor);
     *
     * document.getElementById('remove-button').onclick = () => localVideoTrack.removeProcessor(grayScaleProcessor);
     */
    LocalVideoTrack.prototype.removeProcessor = function () {
        var _this = this;
        this._log.debug('Removing VideoProcessor from the LocalVideoTrack');
        var result = _super.prototype.removeProcessor.apply(this, arguments);
        this._log.debug('Updating LocalVideoTrack\'s MediaStreamTrack with the original MediaStreamTrack');
        this._setSenderMediaStreamTrack()
            .then(function () { return _this._updateElementsMediaStreamTrack(); });
        return result;
    };
    /**
     * Disable the {@link LocalVideoTrack}. This is effectively "pause".
     * If a {@link VideoProcessor} is added, then `processedTrack` is disabled as well.
     * @returns {this}
     * @fires VideoTrack#disabled
     */
    LocalVideoTrack.prototype.disable = function () {
        var result = _super.prototype.disable.apply(this, arguments);
        if (this.processedTrack) {
            this.processedTrack.enabled = false;
        }
        return result;
    };
    /**
     * Enable the {@link LocalVideoTrack}. This is effectively "unpause".
     * If a {@link VideoProcessor} is added, then `processedTrack` is enabled as well.
     * @returns {this}
     * @fires VideoTrack#enabled
    */ /**
     * Enable or disable the {@link LocalVideoTrack}. This is effectively "unpause"
     * or "pause". If a {@link VideoProcessor} is added,
     * then `processedTrack` is enabled or disabled as well.
     * @param {boolean} [enabled] - Specify false to pause the
     *   {@link LocalVideoTrack}
     * @returns {this}
     * @fires VideoTrack#disabled
     * @fires VideoTrack#enabled
     */
    LocalVideoTrack.prototype.enable = function (enabled) {
        if (enabled === void 0) { enabled = true; }
        var result = _super.prototype.enable.apply(this, arguments);
        if (this.processedTrack) {
            this.processedTrack.enabled = enabled;
            if (enabled) {
                this._captureFrames();
                this._log.debug('Updating LocalVideoTrack\'s MediaStreamTrack with the processed MediaStreamTrack', this.processedTrack);
                this._setSenderMediaStreamTrack(true);
            }
        }
        return result;
    };
    /**
     * Restart the {@link LocalVideoTrack}. This stops the existing MediaStreamTrack
     * and creates a new MediaStreamTrack. If the {@link LocalVideoTrack} is being published
     * to a {@link Room}, then all the {@link RemoteParticipant}s will start receiving media
     * from the newly created MediaStreamTrack. You can access the new MediaStreamTrack via
     * the <code>mediaStreamTrack</code> property. If you want to listen to events on
     * the MediaStreamTrack directly, please do so in the "started" event handler. Also,
     * the {@link LocalVideoTrack}'s ID is no longer guaranteed to be the same as the
     * underlying MediaStreamTrack's ID.
     * @param {MediaTrackConstraints} [constraints] - The optional <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints" target="_blank">MediaTrackConstraints</a>
     *   for restarting the {@link LocalVideoTrack}; If not specified, then the current MediaTrackConstraints
     *   will be used; If <code>{}</code> (empty object) is specified, then the default MediaTrackConstraints
     *   will be used
     * @returns {Promise<void>} Rejects with a TypeError if the {@link LocalVideoTrack} was not created
     *   using an one of <code>createLocalVideoTrack</code>, <code>createLocalTracks</code> or <code>connect</code>;
     *   Also rejects with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Exceptions" target="_blank">DOMException</a>
     *   raised by <code>getUserMedia</code> when it fails
     * @fires LocalVideoTrack#stopped
     * @fires LocalVideoTrack#started
     * @example
     * const { connect, createLocalVideoTrack } = require('twilio-video');
     *
     * // Create a LocalVideoTrack that captures video from the front-facing camera.
     * createLocalVideoTrack({ facingMode: 'user' }).then(function(localVideoTrack) {
     *   return connect('token', {
     *     name: 'my-cool-room',
     *     tracks: [localVideoTrack]
     *   });
     * }).then(function(room) {
     *   // Restart the LocalVideoTrack to capture video from the back-facing camera.
     *   const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;
     *   return localVideoTrack.restart({ facingMode: 'environment' });
     * });
     */
    LocalVideoTrack.prototype.restart = function () {
        var _this = this;
        if (this._workaroundSilentLocalVideoCleanup) {
            this._workaroundSilentLocalVideoCleanup();
            this._workaroundSilentLocalVideoCleanup = null;
        }
        var promise = _super.prototype.restart.apply(this, arguments);
        if (this.processor) {
            promise.then(function () {
                _this._restartProcessor();
            });
        }
        if (this._workaroundSilentLocalVideo) {
            promise.finally(function () {
                _this._workaroundSilentLocalVideoCleanup = _this._workaroundSilentLocalVideo(_this, document);
            });
        }
        return promise;
    };
    /**
     * Calls stop on the underlying MediaStreamTrack. If you choose to stop a
     * {@link LocalVideoTrack}, you should unpublish it after stopping.
     * @returns {this}
     * @fires LocalVideoTrack#stopped
     */
    LocalVideoTrack.prototype.stop = function () {
        if (this._workaroundSilentLocalVideoCleanup) {
            this._workaroundSilentLocalVideoCleanup();
            this._workaroundSilentLocalVideoCleanup = null;
        }
        return _super.prototype.stop.apply(this, arguments);
    };
    return LocalVideoTrack;
}(LocalMediaVideoTrack));
/**
 * Work around a bug where local video MediaStreamTracks are silent (even though
 * they are enabled, live and unmuted) after accepting/rejecting a phone call.
 * @private
 * @param {LocalVideoTrack} localVideoTrack
 * @param {HTMLDocument} doc
 * @returns {function} Cleans up listeners attached by the workaround
 */
function workaroundSilentLocalVideo(localVideoTrack, doc) {
    var log = localVideoTrack._log;
    var el = localVideoTrack._dummyEl, mediaStreamTrack = localVideoTrack.mediaStreamTrack;
    function onUnmute() {
        if (!localVideoTrack.isEnabled) {
            return;
        }
        log.info('Unmuted, checking silence');
        // The dummy element is paused, so play it and then detect silence.
        el.play().then(function () { return detectSilentVideo(el, doc); }).then(function (isSilent) {
            if (!isSilent) {
                log.info('Non-silent frames detected, so no need to restart');
                return;
            }
            log.warn('Silence detected, restarting');
            // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack
            // without stopping it first, then a NotReadableError is raised. Hence,
            // we stop the MediaStreamTrack here.
            localVideoTrack._stop();
            // Restart the LocalVideoTrack.
            // eslint-disable-next-line consistent-return
            return localVideoTrack._restart();
        }).catch(function (error) {
            log.warn('Failed to detect silence and restart:', error);
        }).finally(function () {
            // If silent frames were not detected, then pause the dummy element again.
            el = localVideoTrack._dummyEl;
            if (!el.paused) {
                el.pause();
            }
            // Reset the unmute handler.
            mediaStreamTrack.removeEventListener('unmute', onUnmute);
            mediaStreamTrack = localVideoTrack.mediaStreamTrack;
            mediaStreamTrack.addEventListener('unmute', onUnmute);
        });
    }
    // Set the unmute handler.
    mediaStreamTrack.addEventListener('unmute', onUnmute);
    return function () {
        mediaStreamTrack.removeEventListener('unmute', onUnmute);
    };
}
/**
 * The {@link LocalVideoTrack} was disabled, i.e. "muted".
 * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was
 *   disabled
 * @event LocalVideoTrack#disabled
 */
/**
 * The {@link LocalVideoTrack} was enabled, i.e. "unmuted".
 * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was enabled
 * @event LocalVideoTrack#enabled
 */
/**
 * The {@link LocalVideoTrack} started. This means there is enough video data
 * to begin playback.
 * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that started
 * @event LocalVideoTrack#started
 */
/**
 * The {@link LocalVideoTrack} stopped, either because {@link LocalVideoTrack#stop}
 * or {@link LocalVideoTrack#restart} was called or because the underlying
 * MediaStreamTrack ended.
 * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that stopped
 * @event LocalVideoTrack#stopped
 */
module.exports = LocalVideoTrack;
//# sourceMappingURL=localvideotrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/localvideotrackpublication.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/localvideotrackpublication.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalTrackPublication = __webpack_require__(/*! ./localtrackpublication */ "./node_modules/twilio-video/es5/media/track/localtrackpublication.js");
/**
 * A {@link LocalVideoTrackPublication} is a {@link LocalVideoTrack} that has
 * been published to a {@link Room}.
 * @extends LocalTrackPublication
 * @property {Track.Kind} kind - "video"
 * @property {LocalVideoTrack} track - the {@link LocalVideoTrack}
 */
var LocalVideoTrackPublication = /** @class */ (function (_super) {
    __extends(LocalVideoTrackPublication, _super);
    /**
     * Construct a {@link LocalVideoTrackPublication}.
     * @param {LocalTrackPublicationSignaling} signaling - The corresponding
     *   {@link LocalTrackPublicationSignaling}
     * @param {LocalVideoTrack} track - the {@link LocalVideoTrack}
     * @param {function(LocalTrackPublication): void} unpublish - The callback
     *    that unpublishes the {@link LocalTrackPublication}
     * @param {TrackPublicationOptions} options - {@link LocalTrackPublication} options
     */
    function LocalVideoTrackPublication(signaling, track, unpublish, options) {
        return _super.call(this, signaling, track, unpublish, options) || this;
    }
    LocalVideoTrackPublication.prototype.toString = function () {
        return "[LocalVideoTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return LocalVideoTrackPublication;
}(LocalTrackPublication));
module.exports = LocalVideoTrackPublication;
//# sourceMappingURL=localvideotrackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/mediatrack.js":
/*!*****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/mediatrack.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _a = __webpack_require__(/*! ../../webrtc/util */ "./node_modules/twilio-video/es5/webrtc/util/index.js"), guessBrowser = _a.guessBrowser, isIOSChrome = _a.isIOSChrome;
var MediaStream = __webpack_require__(/*! ../../webrtc */ "./node_modules/twilio-video/es5/webrtc/index.js").MediaStream;
var _b = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js"), waitForEvent = _b.waitForEvent, waitForSometime = _b.waitForSometime;
var localMediaRestartDeferreds = __webpack_require__(/*! ../../util/localmediarestartdeferreds */ "./node_modules/twilio-video/es5/util/localmediarestartdeferreds.js");
var Track = __webpack_require__(/*! ./ */ "./node_modules/twilio-video/es5/media/track/index.js");
/**
 * A {@link MediaTrack} represents audio or video that can be sent to or
 * received from a {@link Room}.
 * @extends Track
 * @property {Track.ID} id - This {@link Track}'s ID
 * @property {boolean} isStarted - Whether or not the {@link MediaTrack} has
 *   started
 * @property {Track.Kind} kind - The kind of the underlying
 *   MediaStreamTrack, "audio" or "video"
 * @property {?MediaStreamTrack} mediaStreamTrack - Provides access to the underlying
 *   MediaStreamTrack; It is set to <code>null</code> if it is a {@link RemoteTrack}
 *   that is switched off
 * @emits MediaTrack#started
 */
var MediaTrack = /** @class */ (function (_super) {
    __extends(MediaTrack, _super);
    /**
     * Construct a {@link MediaTrack}.
     * @param {Track.Kind} kind
     * @param {?MediaTrackTransceiver} mediaTrackTransceiver
     * @param {{ log: Log, name: string }} options
     */
    function MediaTrack(kind, mediaTrackTransceiver, options) {
        var _this = this;
        options = Object.assign({
            playPausedElementsIfNotBackgrounded: (guessBrowser() === 'safari' || isIOSChrome())
                && typeof document === 'object'
                && typeof document.addEventListener === 'function'
                && typeof document.visibilityState === 'string'
        }, options);
        _this = _super.call(this, kind, options) || this;
        options = Object.assign({
            MediaStream: MediaStream
        }, options);
        /* istanbul ignore next */
        Object.defineProperties(_this, {
            _attachments: {
                value: new Set()
            },
            _dummyEl: {
                value: null,
                writable: true
            },
            _elShims: {
                value: new WeakMap()
            },
            _isStarted: {
                value: false,
                writable: true
            },
            _mediaTrackTransceiver: {
                value: mediaTrackTransceiver,
                writable: true
            },
            _playPausedElementsIfNotBackgrounded: {
                value: options.playPausedElementsIfNotBackgrounded
            },
            _shouldShimAttachedElements: {
                value: options.workaroundWebKitBug212780
                    || options.playPausedElementsIfNotBackgrounded
            },
            _unprocessedTrack: {
                value: null,
                writable: true
            },
            _MediaStream: {
                value: options.MediaStream
            },
            isStarted: {
                enumerable: true,
                get: function () {
                    return this._isStarted;
                }
            },
            mediaStreamTrack: {
                enumerable: true,
                get: function () {
                    return this._unprocessedTrack || (this._mediaTrackTransceiver
                        ? this._mediaTrackTransceiver.track
                        : null);
                }
            },
            processedTrack: {
                enumerable: true,
                value: null,
                writable: true
            }
        });
        _this._initialize();
        return _this;
    }
    /**
     * @private
     */
    MediaTrack.prototype._start = function () {
        this._log.debug('Started');
        this._isStarted = true;
        if (this._dummyEl) {
            this._dummyEl.oncanplay = null;
        }
        // eslint-disable-next-line no-use-before-define
        this.emit('started', this);
    };
    /**
     * @private
     */
    MediaTrack.prototype._initialize = function () {
        var log = this._log;
        if (!this.mediaStreamTrack) {
            log.debug('Skipping initialization as .mediaStreamTrack is null');
            return;
        }
        var self = this;
        log.debug('Initializing');
        this._dummyEl = this._createElement();
        this.mediaStreamTrack.addEventListener('ended', function onended() {
            self._end();
            if (self.mediaStreamTrack) {
                self.mediaStreamTrack.removeEventListener('ended', onended);
            }
        });
        if (this._dummyEl) {
            this._dummyEl.muted = true;
            this._dummyEl.oncanplay = this._start.bind(this, this._dummyEl);
            // NOTE(csantos): We always want to attach the original mediaStreamTrack for dummyEl
            this._attach(this._dummyEl, this.mediaStreamTrack);
        }
    };
    /**
     * @private
     */
    MediaTrack.prototype._end = function () {
        var log = this._log;
        if (!this.mediaStreamTrack) {
            log.debug('Skipping ended as .mediaStreamTrack is null');
            return;
        }
        if (this._dummyEl) {
            this._log.debug('Ended');
            this._dummyEl.remove();
            this._dummyEl.srcObject = null;
            this._dummyEl.oncanplay = null;
            this._dummyEl = null;
        }
    };
    MediaTrack.prototype.attach = function (el) {
        var _this = this;
        if (typeof el === 'string') {
            el = this._selectElement(el);
        }
        else if (!el) {
            el = this._createElement();
        }
        this._log.debug('Attempting to attach to element:', el);
        el = this._attach(el);
        if (this._shouldShimAttachedElements && !this._elShims.has(el)) {
            var onUnintentionallyPaused = this._playPausedElementsIfNotBackgrounded
                ? function () { return playIfPausedAndNotBackgrounded(el, _this._log); }
                : null;
            this._elShims.set(el, shimMediaElement(el, onUnintentionallyPaused));
        }
        return el;
    };
    /**
     * Attach the provided MediaStreamTrack to the media element.
     * @param el - The media element to attach to
     * @param mediaStreamTrack - The MediaStreamTrack to attach. If this is
     * not provided, it uses the .processedTrack if it exists,
     * or it defaults to the current .mediaStreamTrack
     * @private
     */
    MediaTrack.prototype._attach = function (el, mediaStreamTrack) {
        if (mediaStreamTrack === void 0) { mediaStreamTrack = this.processedTrack || this.mediaStreamTrack; }
        var mediaStream = el.srcObject || new this._MediaStream();
        var getTracks = this.kind === 'audio' ? 'getAudioTracks' : 'getVideoTracks';
        mediaStream[getTracks]().forEach(function (track) { return mediaStream.removeTrack(track); });
        if (mediaStreamTrack) {
            mediaStream.addTrack(mediaStreamTrack);
        }
        // NOTE(mpatwardhan): resetting `srcObject` here, causes flicker (JSDK-2641), but it lets us
        // sidestep the chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1052353
        el.srcObject = mediaStream;
        el.autoplay = true;
        el.playsInline = true;
        if (el !== this._dummyEl) {
            this._attachments.add(el);
        }
        return el;
    };
    /**
     * @private
     */
    MediaTrack.prototype._selectElement = function (selector) {
        var el = document.querySelector(selector);
        if (!el) {
            throw new Error("Selector matched no element: " + selector);
        }
        return el;
    };
    /**
     * @private
     */
    MediaTrack.prototype._updateElementsMediaStreamTrack = function () {
        var _this = this;
        this._log.debug('Reattaching all elements to update .mediaStreamTrack');
        this._getAllAttachedElements().forEach(function (el) { return _this._attach(el); });
        // eslint-disable-next-line no-warning-comments
        // TODO(mpatwardhan): should we emit that mediaStreamTrack was updated?
    };
    /**
     * @private
     */
    MediaTrack.prototype._createElement = function () {
        return typeof document !== 'undefined'
            ? document.createElement(this.kind)
            : null;
    };
    MediaTrack.prototype.detach = function (el) {
        var els;
        if (typeof el === 'string') {
            els = [this._selectElement(el)];
        }
        else if (!el) {
            els = this._getAllAttachedElements();
        }
        else {
            els = [el];
        }
        this._log.debug('Attempting to detach from elements:', els);
        this._detachElements(els);
        return el ? els[0] : els;
    };
    /**
     * @private
     */
    MediaTrack.prototype._detachElements = function (elements) {
        return elements.map(this._detachElement.bind(this));
    };
    /**
     * @private
     */
    MediaTrack.prototype._detachElement = function (el) {
        if (!this._attachments.has(el)) {
            return el;
        }
        var mediaStream = el.srcObject;
        var mediaStreamTrack = this.processedTrack || this.mediaStreamTrack;
        if (mediaStream && mediaStreamTrack) {
            mediaStream.removeTrack(mediaStreamTrack);
        }
        this._attachments.delete(el);
        if (this._shouldShimAttachedElements && this._elShims.has(el)) {
            var shim = this._elShims.get(el);
            shim.unShim();
            this._elShims.delete(el);
        }
        return el;
    };
    /**
     * @private
     */
    MediaTrack.prototype._getAllAttachedElements = function () {
        return Array.from(this._attachments);
    };
    return MediaTrack;
}(Track));
/**
 * Play an HTMLMediaElement if it is paused and not backgrounded.
 * @private
 * @param {HTMLMediaElement} el
 * @param {Log} log
 * @returns {void}
 */
function playIfPausedAndNotBackgrounded(el, log) {
    var tag = el.tagName.toLowerCase();
    log.warn('Unintentionally paused:', el);
    // NOTE(mmalavalli): When the element is unintentionally paused, we wait one
    // second for the "onvisibilitychange" event on the HTMLDocument to see if the
    // app will be backgrounded. If not, then the element can be safely played.
    Promise.race([
        waitForEvent(document, 'visibilitychange'),
        waitForSometime(1000)
    ]).then(function () {
        if (document.visibilityState === 'visible') {
            // NOTE(mmalavalli): We play the inadvertently paused elements only after
            // the LocalAudioTrack is unmuted to work around WebKit Bug 213853.
            //
            // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853
            //
            localMediaRestartDeferreds.whenResolved('audio').then(function () {
                log.info("Playing unintentionally paused <" + tag + "> element");
                log.debug('Element:', el);
                return el.play();
            }).then(function () {
                log.info("Successfully played unintentionally paused <" + tag + "> element");
                log.debug('Element:', el);
            }).catch(function (error) {
                log.warn("Error while playing unintentionally paused <" + tag + "> element:", { error: error, el: el });
            });
        }
    });
}
/**
 * Shim the pause() and play() methods of the given HTMLMediaElement so that
 * we can detect if it was paused unintentionally.
 * @param {HTMLMediaElement} el
 * @param {?function} [onUnintentionallyPaused=null]
 * @returns {{pausedIntentionally: function, unShim: function}}
 */
function shimMediaElement(el, onUnintentionallyPaused) {
    if (onUnintentionallyPaused === void 0) { onUnintentionallyPaused = null; }
    var origPause = el.pause;
    var origPlay = el.play;
    var pausedIntentionally = false;
    el.pause = function () {
        pausedIntentionally = true;
        return origPause.call(el);
    };
    el.play = function () {
        pausedIntentionally = false;
        return origPlay.call(el);
    };
    var onPause = onUnintentionallyPaused ? function () {
        if (!pausedIntentionally) {
            onUnintentionallyPaused();
        }
    } : null;
    if (onPause) {
        el.addEventListener('pause', onPause);
    }
    return {
        pausedIntentionally: function () {
            return pausedIntentionally;
        },
        unShim: function () {
            el.pause = origPause;
            el.play = origPlay;
            if (onPause) {
                el.removeEventListener('pause', onPause);
            }
        }
    };
}
module.exports = MediaTrack;
//# sourceMappingURL=mediatrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/receiver.js":
/*!***************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/receiver.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaTrackTransceiver = __webpack_require__(/*! ./transceiver */ "./node_modules/twilio-video/es5/media/track/transceiver.js");
/**
 * A {@link MediaTrackReceiver} represents a remote MediaStreamTrack.
 * @extends MediaTrackTransceiver
 */
var MediaTrackReceiver = /** @class */ (function (_super) {
    __extends(MediaTrackReceiver, _super);
    /**
     * Construct a {@link MediaTrackReceiver}.
     * @param {Track.ID} id - The MediaStreamTrack ID signaled through RSP/SDP
     * @param {?string} mid - The MID associated with the MediaStreamTrack
     * @param {MediaStreamTrack} mediaStreamTrack - The remote MediaStreamTrack
     */
    function MediaTrackReceiver(id, mid, mediaStreamTrack) {
        return _super.call(this, id, mid, mediaStreamTrack) || this;
    }
    return MediaTrackReceiver;
}(MediaTrackTransceiver));
module.exports = MediaTrackReceiver;
//# sourceMappingURL=receiver.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/remoteaudiotrack.js":
/*!***********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/remoteaudiotrack.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var AudioTrack = __webpack_require__(/*! ./audiotrack */ "./node_modules/twilio-video/es5/media/track/audiotrack.js");
var mixinRemoteMediaTrack = __webpack_require__(/*! ./remotemediatrack */ "./node_modules/twilio-video/es5/media/track/remotemediatrack.js");
var RemoteMediaAudioTrack = mixinRemoteMediaTrack(AudioTrack);
/**
 * A {@link RemoteAudioTrack} represents an {@link AudioTrack} published to a
 * {@link Room} by a {@link RemoteParticipant}.
 * @extends AudioTrack
 * @property {boolean} isEnabled - <code>Deprecated: Use (.switchOffReason !== "disabled-by-publisher") instead</code>
 *   Whether the {@link RemoteAudioTrack} is enabled (Deprecated only for large group Rooms)
 * @property {boolean} isSwitchedOff - Whether the {@link RemoteAudioTrack} is switched off
 * @property {?TrackSwitchOffReason} switchOffReason - The reason for the {@link RemoteAudioTrack} being switched off;
 *   If switched on, it is set to <code>null</code>; The {@link RemoteAudioTrack} is initially switched off with this
 *   property set to <code>disabled-by-subscriber</code>
 * @property {Track.SID} sid - The {@link RemoteAudioTrack}'s SID
 * @property {?Track.Priority} priority - The subscribe priority of the {@link RemoteAudioTrack}
 * @emits RemoteAudioTrack#disabled
 * @emits RemoteAudioTrack#enabled
 * @emits RemoteAudioTrack#started
 * @emits RemoteAudioTrack#switchedOff
 * @emits RemoteAudioTrack#switchedOn
 */
var RemoteAudioTrack = /** @class */ (function (_super) {
    __extends(RemoteAudioTrack, _super);
    /**
     * Construct a {@link RemoteAudioTrack}.
     * @param {Track.SID} sid - The {@link RemoteAudioTrack}'s SID
     * @param {?MediaTrackReceiver} mediaTrackReceiver - An audio MediaStreamTrack container
     * @param {boolean} isEnabled - Whether the {@link RemoteAudioTrack} is enabled
     * @param {boolean} isSwitchedOff - Whether the {@link RemoteAudioTrack} is switched off
     * @param {?string} switchOffReason - The reason the {@link RemoteAudioTrack} is switched off
     * @param {function(?Track.Priority): void} setPriority - Set or clear the subscribe
     *  {@link Track.Priority} of the {@link RemoteAudioTrack}
     * @param {function(ClientRenderHint): void} setRenderHint - Set render hints.
     * @param {{log: Log, name: string}} options - The {@link RemoteTrack} options
     */
    function RemoteAudioTrack(sid, mediaTrackReceiver, isEnabled, isSwitchedOff, switchOffReason, setPriority, setRenderHint, options) {
        return _super.call(this, 'audio', sid, mediaTrackReceiver, isEnabled, isSwitchedOff, switchOffReason, setPriority, setRenderHint, options) || this;
    }
    RemoteAudioTrack.prototype.toString = function () {
        return "[RemoteAudioTrack #" + this._instanceId + ": " + this.sid + "]";
    };
    /**
     * Update the subscribe {@link Track.Priority} of the {@link RemoteAudioTrack}.
     * @param {?Track.Priority} priority - the new subscribe {@link Track.Priority};
     *   Currently setPriority has no effect on audio tracks.
     * @returns {this}
     * @throws {RangeError}
     */
    RemoteAudioTrack.prototype.setPriority = function (priority) {
        return _super.prototype.setPriority.call(this, priority);
    };
    return RemoteAudioTrack;
}(RemoteMediaAudioTrack));
/**
 * The {@link RemoteAudioTrack} was disabled, i.e. "muted" (Deprecated only for large group Rooms).
 * @deprecated Use <a href="#event:switchedOff"><code>switchedOff</code></a> (<code>.switchOffReason === "disabled-by-publisher"</code>) instead
 * @param {RemoteAudioTrack} track - The {@link RemoteAudioTrack} that was
 *   disabled
 * @event RemoteAudioTrack#disabled
 */
/**
 * The {@link RemoteAudioTrack} was enabled, i.e. "unmuted" (Deprecated only for large group Rooms).
 * @deprecated Use <a href="#event:switchedOn"><code>switchedOn</code></a> instead
 * @param {RemoteAudioTrack} track - The {@link RemoteAudioTrack} that was
 *   enabled
 * @event RemoteAudioTrack#enabled
 */
/**
 * The {@link RemoteAudioTrack} started. This means there is enough audio data
 * to begin playback.
 * @param {RemoteAudioTrack} track - The {@link RemoteAudioTrack} that started
 * @event RemoteAudioTrack#started
 */
/**
 * A {@link RemoteAudioTrack} was switched off. The media server stops sending media for the
 * {@link RemoteAudioTrack} until it is switched back on. Just before the event is raised,
 * <code>isSwitchedOff</code> is set to <code>true</code> and <code>switchOffReason</code> is
 * set to a {@link TrackSwitchOffReason} in large group Rooms (<code>switchOffReason</code> is
 * <code>null</code> non-large group Rooms). Also, the <code>mediaStreamTrack</code> property
 * is set to <code>null</code> (only in large group Rooms).
 * @param {RemoteAudioTrack} track - The {@link RemoteAudioTrack} that was
 *   switched off
 * @param {?TrackSwitchOffReason} switchOffReason - The reason the {@link RemoteAudioTrack}
 *   was switched off
 * @event RemoteAudioTrack#switchedOff
 */
/**
 * A {@link RemoteAudioTrack} was switched on. The media server starts sending media for the
 * {@link RemoteAudioTrack} until it is switched off. Just before the event is raised,
 * <code>isSwitchedOff</code> is set to <code>false</code> and <code>switchOffReason</code>
 * is set to <code>null</code>. Also, the <code>mediaStreamTrack</code> property is set to a
 * MediaStreamTrack that is the source of the {@link RemoteAudioTrack}'s media.
 * @param {RemoteAudioTrack} track - The {@link RemoteAudioTrack} that was
 *   switched on
 * @event RemoteAudioTrack#switchedOn
 */
module.exports = RemoteAudioTrack;
//# sourceMappingURL=remoteaudiotrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/remoteaudiotrackpublication.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/remoteaudiotrackpublication.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteTrackPublication = __webpack_require__(/*! ./remotetrackpublication */ "./node_modules/twilio-video/es5/media/track/remotetrackpublication.js");
/**
 * A {@link RemoteAudioTrackPublication} represents a {@link RemoteAudioTrack}
 * that has been published to a {@link Room}.
 * @property {Track.Kind} kind - "audio"
 * @property {?RemoteAudioTrack} track - unless you have subscribed to the
 *   {@link RemoteAudioTrack}, this property is null
 * @emits RemoteAudioTrackPublication#subscribed
 * @emits RemoteAudioTrackPublication#subscriptionFailed
 * @emits RemoteAudioTrackPublication#trackDisabled
 * @emits RemoteAudioTrackPublication#trackEnabled
 * @emits RemoteAudioTrackPublication#unsubscribed
 */
var RemoteAudioTrackPublication = /** @class */ (function (_super) {
    __extends(RemoteAudioTrackPublication, _super);
    /**
     * Construct a {@link RemoteAudioTrackPublication}.
     * @param {RemoteTrackPublicationSignaling} signaling - {@link RemoteTrackPublication} signaling
     * @param {RemoteTrackPublicationOptions} options - {@link RemoteTrackPublication}
     *   options
     */
    function RemoteAudioTrackPublication(signaling, options) {
        return _super.call(this, signaling, options) || this;
    }
    RemoteAudioTrackPublication.prototype.toString = function () {
        return "[RemoteAudioTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return RemoteAudioTrackPublication;
}(RemoteTrackPublication));
/**
 * Your {@link LocalParticipant} subscribed to the {@link RemoteAudioTrack}.
 * @param {RemoteAudioTrack} track - the {@link RemoteAudioTrack} that was subscribed to
 * @event RemoteAudioTrackPublication#subscribed
 */
/**
 * Your {@link LocalParticipant} failed to subscribe to the {@link RemoteAudioTrack}.
 * @param {TwilioError} error - the reason the {@link RemoteAudioTrack} could not be
 *   subscribed to
 * @event RemoteAudioTrackPublication#subscriptionFailed
 */
/**
 * The {@link RemoteAudioTrack} was disabled. It is fired only if <code>.isSubscribed</code>
 * is set to <code>true</code> (Deprecated only for large group Rooms).
 * @deprecated Use <a href="event:trackSwitchedOff"><code>trackSwitchedOff</code></a> (<code>track.switchOffReason === "disabled-by-publisher"</code>) instead
 * @event RemoteAudioTrackPublication#trackDisabled
 */
/**
 * The {@link RemoteAudioTrack} was enabled. It is fired only if <code>.isSubscribed</code>
 * is set to <code>true</code> (Deprecated only for large group Rooms).
 * @deprecated Use <a href="event:trackSwitchedOn"><code>trackSwitchedOn</code></a> instead
 * @event RemoteAudioTrackPublication#trackEnabled
 */
/**
 * The {@link RemoteAudioTrack} was switched off. The media server stops sending media for
 * the {@link RemoteAudioTrack} until it is switched back on. Just before the event is raised,
 * <code>isSwitchedOff</code> is set to <code>true</code> and <code>switchOffReason</code>
 * is set to a {@link TrackSwitchOffReason} in large group Rooms (<code>switchOffReason</code> is
 * <code>null</code> non-large group Rooms). Also, if the {@link RemoteAudioTrack} receives audio
 * media, the <code>mediaStreamTrack</code> property is set to <code>null</code>. (only in large
 * group Rooms)
 * @param {RemoteAudioTrack} track - the {@link RemoteAudioTrack} that was switched off
 * @param {?TrackSwitchOffReason} switchOffReason - the reason the {@link RemoteAudioTrack}
 *   was switched off
 * @event RemoteAudioTrackPublication#trackSwitchedOff
 */
/**
 * The {@link RemoteAudioTrack} was switched on. The media server starts sending media for
 * the {@link RemoteAudioTrack} until it is switched off. Just before the event is raised,
 * <code>isSwitchedOff</code> is set to <code>false</code> and <code>switchOffReason</code>
 * is set to <code>null</code>. Also, the <code>mediaStreamTrack</code> property is set to a
 * MediaStreamTrack that is the source of the {@link RemoteAudioTrack}'s media.
 * @param {RemoteAudioTrack} track - the {@link RemoteAudioTrack} that was switched on
 * @event RemoteAudioTrackPublication#trackSwitchedOn
 */
/**
 * Your {@link LocalParticipant} unsubscribed from the {@link RemoteAudioTrack}.
 * @param {RemoteAudioTrack} track - the {@link RemoteAudioTrack} that was unsubscribed from
 * @event RemoteAudioTrackPublication#unsubscribed
 */
module.exports = RemoteAudioTrackPublication;
//# sourceMappingURL=remoteaudiotrackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/remotedatatrack.js":
/*!**********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/remotedatatrack.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var Track = __webpack_require__(/*! ./ */ "./node_modules/twilio-video/es5/media/track/index.js");
var _a = __webpack_require__(/*! ../../util/constants */ "./node_modules/twilio-video/es5/util/constants.js"), E = _a.typeErrors, trackPriority = _a.trackPriority;
/**
 * A {@link RemoteDataTrack} represents data published to a {@link Room} by a
 * {@link RemoteParticipant}.
 * @extends Track
 * @property {boolean} isEnabled - true
 * @property {boolean} isSubscribed - Whether the {@link RemoteDataTrack} is
 *   subscribed to
 * @property {boolean} isSwitchedOff - Whether the {@link RemoteDataTrack} is
 *   switched off
 * @property {Track.Kind} kind - "data"
 * @property {?number} maxPacketLifeTime - If non-null, this represents a time
 *   limit (in milliseconds) during which data will be transmitted or
 *   retransmitted if not acknowledged on the underlying RTCDataChannel.
 * @property {?number} maxRetransmits - If non-null, this represents the number
 *   of times the data will be retransmitted if not successfully received on the
 *   underlying RTCDataChannel.
 * @property {boolean} ordered - true if data on the {@link RemoteDataTrack} can
 *   be received out-of-order.
 * @property {?Track.Priority} priority - The subscribe priority of the {@link RemoteDataTrack}
 * @property {boolean} reliable - This is true if both
 *   <code>maxPacketLifeTime</code> and <code>maxRetransmits</code> are set to
 *   null. In other words, if this is true, there is no bound on packet lifetime
 *   or the number of retransmits that will be attempted, ensuring "reliable"
 *   transmission.
 * @property {Track.SID} sid - The SID assigned to the {@link RemoteDataTrack}
 * @emits RemoteDataTrack#message
 * @emits RemoteDataTrack#switchedOff
 * @emits RemoteDataTrack#switchedOn
 */
var RemoteDataTrack = /** @class */ (function (_super) {
    __extends(RemoteDataTrack, _super);
    /**
     * Construct a {@link RemoteDataTrack} from a {@link DataTrackReceiver}.
     * @param {Track.SID} sid
     * @param {DataTrackReceiver} dataTrackReceiver
     * @param {{log: Log, name: ?string}} options
     */
    function RemoteDataTrack(sid, dataTrackReceiver, options) {
        var _this = _super.call(this, 'data', options) || this;
        Object.defineProperties(_this, {
            _isSwitchedOff: {
                value: false,
                writable: true
            },
            _priority: {
                value: null,
                writable: true
            },
            isEnabled: {
                enumerable: true,
                value: true
            },
            isSwitchedOff: {
                enumerable: true,
                get: function () {
                    return this._isSwitchedOff;
                }
            },
            maxPacketLifeTime: {
                enumerable: true,
                value: dataTrackReceiver.maxPacketLifeTime
            },
            maxRetransmits: {
                enumerable: true,
                value: dataTrackReceiver.maxRetransmits
            },
            ordered: {
                enumerable: true,
                value: dataTrackReceiver.ordered
            },
            priority: {
                enumerable: true,
                get: function () {
                    return this._priority;
                }
            },
            reliable: {
                enumerable: true,
                value: dataTrackReceiver.maxPacketLifeTime === null
                    && dataTrackReceiver.maxRetransmits === null
            },
            sid: {
                enumerable: true,
                value: sid
            }
        });
        dataTrackReceiver.on('message', function (data) {
            _this.emit('message', data, _this);
        });
        return _this;
    }
    /**
     * Update the subscriber {@link Track.Priority} of the {@link RemoteDataTrack}.
     * @param {?Track.Priority} priority - the new {@link Track.priority};
     *   Currently setPriority has no effect on data tracks.
     * @returns {this}
     * @throws {RangeError}
     */
    RemoteDataTrack.prototype.setPriority = function (priority) {
        var priorityValues = __spreadArray([null], __read(Object.values(trackPriority)));
        if (!priorityValues.includes(priority)) {
            // eslint-disable-next-line new-cap
            throw E.INVALID_VALUE('priority', priorityValues);
        }
        // Note: priority has no real effect on the data tracks.
        this._priority = priority;
        return this;
    };
    /**
     * @private
     */
    RemoteDataTrack.prototype._setEnabled = function () {
        // Do nothing.
    };
    /**
     * @private
     * @param {boolean} isSwitchedOff
     */
    RemoteDataTrack.prototype._setSwitchedOff = function (isSwitchedOff) {
        if (this._isSwitchedOff !== isSwitchedOff) {
            this._isSwitchedOff = isSwitchedOff;
            this.emit(isSwitchedOff ? 'switchedOff' : 'switchedOn', this);
        }
    };
    return RemoteDataTrack;
}(Track));
/**
 * A message was received over the {@link RemoteDataTrack}.
 * @event RemoteDataTrack#message
 * @param {string|ArrayBuffer} data
 * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} that received
 *   the message
 */
/**
 * A {@link RemoteDataTrack} was switched off.
 * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} that was
 *   switched off
 * @event RemoteDataTrack#switchedOff
 */
/**
 * A {@link RemoteDataTrack} was switched on.
 * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} that was
 *   switched on
 * @event RemoteDataTrack#switchedOn
 */
module.exports = RemoteDataTrack;
//# sourceMappingURL=remotedatatrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/remotedatatrackpublication.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/remotedatatrackpublication.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteTrackPublication = __webpack_require__(/*! ./remotetrackpublication */ "./node_modules/twilio-video/es5/media/track/remotetrackpublication.js");
/**
 * A {@link RemoteDataTrackPublication} represents a {@link RemoteDataTrack}
 * that has been published to a {@link Room}.
 * @property {Track.Kind} kind - "data"
 * @property {?RemoteDataTrack} track - unless you have subscribed to the
 *   {@link RemoteDataTrack}, this property is null
 * @emits RemoteDataTrackPublication#subscribed
 * @emits RemoteDataTrackPublication#subscriptionFailed
 * @emits RemoteDataTrackPublication#unsubscribed
 */
var RemoteDataTrackPublication = /** @class */ (function (_super) {
    __extends(RemoteDataTrackPublication, _super);
    /**
     * Construct a {@link RemoteDataTrackPublication}.
     * @param {RemoteTrackPublicationSignaling} signaling - {@link RemoteTrackPublication} signaling
     * @param {RemoteTrackPublicationOptions} options - {@link RemoteTrackPublication}
     *   options
     */
    function RemoteDataTrackPublication(signaling, options) {
        return _super.call(this, signaling, options) || this;
    }
    RemoteDataTrackPublication.prototype.toString = function () {
        return "[RemoteDataTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return RemoteDataTrackPublication;
}(RemoteTrackPublication));
/**
 * Your {@link LocalParticipant} subscribed to the {@link RemoteDataTrack}.
 * @param {RemoteDataTrack} track - the {@link RemoteDataTrack} that was subscribed to
 * @event RemoteDataTrackPublication#subscribed
 */
/**
 * Your {@link LocalParticipant} failed to subscribe to the {@link RemoteDataTrack}.
 * @param {TwilioError} error - the reason the {@link RemoteDataTrack} could not be
 *   subscribed to
 * @event RemoteDataTrackPublication#subscriptionFailed
 */
/**
 * Your {@link LocalParticipant} unsubscribed from the {@link RemoteDataTrack}.
 * @param {RemoteDataTrack} track - the {@link RemoteDataTrack} that was unsubscribed from
 * @event RemoteDataTrackPublication#unsubscribed
 */
module.exports = RemoteDataTrackPublication;
//# sourceMappingURL=remotedatatrackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/remotemediatrack.js":
/*!***********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/remotemediatrack.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var deprecateEvents = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js").deprecateEvents;
var _a = __webpack_require__(/*! ../../util/constants */ "./node_modules/twilio-video/es5/util/constants.js"), E = _a.typeErrors, trackPriority = _a.trackPriority, trackSwitchOffReason = _a.trackSwitchOffReason;
var _b = __webpack_require__(/*! ../../webrtc/util */ "./node_modules/twilio-video/es5/webrtc/util/index.js"), guessBrowser = _b.guessBrowser, isIOSChrome = _b.isIOSChrome;
var documentVisibilityMonitor = __webpack_require__(/*! ../../util/documentvisibilitymonitor.js */ "./node_modules/twilio-video/es5/util/documentvisibilitymonitor.js");
function mixinRemoteMediaTrack(AudioOrVideoTrack) {
    /**
     * A {@link RemoteMediaTrack} represents a {@link MediaTrack} published to a
     * {@link Room} by a {@link RemoteParticipant}.
     * @property {boolean} isEnabled - <code>Deprecated: Use (.switchOffReason !== "disabled-by-publisher") instead.</code>
     *   Whether the {@link RemoteAudioTrack} is enabled (Deprecated only for large group Rooms)
     * @property {boolean} isSwitchedOff - Whether the {@link RemoteMediaTrack} is switched off
     * @property {?TrackSwitchOffReason} switchOffReason - The reason for the {@link RemoteMediaTrack} being switched off;
     *   If switched on, it is set to <code>null</code>; The {@link RemoteMediaTrack} is initially switched off with this
     *   property set to <code>disabled-by-subscriber</code>
     * @property {Track.SID} sid - The SID assigned to the {@link RemoteMediaTrack}
     * @property {?Track.Priority} priority - The subscribe priority of the {@link RemoteMediaTrack}
     * @emits RemoteMediaTrack#disabled
     * @emits RemoteMediaTrack#enabled
     * @emits RemoteMediaTrack#switchedOff
     * @emits RemoteMediaTrack#switchedOn
     */
    return /** @class */ (function (_super) {
        __extends(RemoteMediaTrack, _super);
        /**
         * Construct a {@link RemoteMediaTrack}.
         * @param {Track.Kind} kind
         * @param {Track.SID} sid
         * @param {?MediaTrackReceiver} mediaTrackReceiver
         * @param {boolean} isEnabled
         * @param {boolean} isSwitchedOff
         * @param {?string} switchOffReason
         * @param {function(?Track.Priority): void} setPriority - Set or clear the subscribe
         *  {@link Track.Priority} of the {@link RemoteMediaTrack}
         * @param {function(ClientRenderHint): void} setRenderHint - Set render hints.
         * @param {{log: Log, name: string}} options
         */
        function RemoteMediaTrack(kind, sid, mediaTrackReceiver, isEnabled, isSwitchedOff, switchOffReason, setPriority, setRenderHint, options) {
            var _this = this;
            options = Object.assign({
                shouldDeprecateEnabledState: false,
                // NOTE(mpatwardhan): WebKit bug: 212780 sometimes causes the audio/video elements to stay paused when safari
                // regains foreground. To workaround it, when safari gains foreground - we will play any elements that were
                // playing before safari lost foreground.
                workaroundWebKitBug212780: (guessBrowser() === 'safari' || isIOSChrome())
                    && typeof document === 'object'
                    && typeof document.addEventListener === 'function'
                    && typeof document.visibilityState === 'string'
            }, options);
            var shouldDeprecateEnabledState = options.shouldDeprecateEnabledState;
            _this = _super.call(this, mediaTrackReceiver, options) || this;
            Object.defineProperties(_this, {
                _isEnabled: {
                    value: isEnabled,
                    writable: true
                },
                _isSwitchedOff: {
                    value: isSwitchedOff,
                    writable: true
                },
                _priority: {
                    value: null,
                    writable: true
                },
                _setPriority: {
                    value: setPriority
                },
                _setRenderHint: {
                    value: function (renderHint) {
                        _this._log.debug('updating render hint:', renderHint);
                        setRenderHint(renderHint);
                    }
                },
                _switchOffReason: {
                    value: switchOffReason,
                    writable: true
                },
                _workaroundWebKitBug212780: {
                    value: options.workaroundWebKitBug212780
                },
                _workaroundWebKitBug212780Cleanup: {
                    value: null,
                    writable: true
                },
                isEnabled: {
                    enumerable: true,
                    get: function () {
                        if (shouldDeprecateEnabledState) {
                            this._log.deprecated('.isEnabled is deprecated and scheduled for removal. '
                                + 'The RemoteMediaTrack is can be considered disabled if .switchOffReason '
                                + 'is set to "disabled-by-publisher".');
                        }
                        return this._isEnabled;
                    }
                },
                isSwitchedOff: {
                    enumerable: true,
                    get: function () {
                        return this._isSwitchedOff;
                    }
                },
                priority: {
                    enumerable: true,
                    get: function () {
                        return this._priority;
                    }
                },
                sid: {
                    enumerable: true,
                    value: sid
                },
                switchOffReason: {
                    enumerable: true,
                    get: function () {
                        return trackSwitchOffReason[this._switchOffReason] || null;
                    }
                }
            });
            var _a = _this, log = _a._log, name = _a.constructor.name;
            if (shouldDeprecateEnabledState) {
                deprecateEvents(name, _this, new Map([
                    ['disabled', 'switchedOff (.switchOffReason === "disabled-by-publisher")'],
                    ['enabled', 'switchedOn']
                ]), log);
            }
            return _this;
        }
        /**
         * Update the subscribe {@link Track.Priority} of the {@link RemoteMediaTrack}.
         * @param {?Track.Priority} priority - the new subscribe {@link Track.Priority};
         *   If <code>null</code>, then the subscribe {@link Track.Priority} is cleared, which
         *   means the {@link Track.Priority} set by the publisher is now the effective priority.
         * @returns {this}
         * @throws {RangeError}
         */
        RemoteMediaTrack.prototype.setPriority = function (priority) {
            var priorityValues = __spreadArray([null], __read(Object.values(trackPriority)));
            if (!priorityValues.includes(priority)) {
                // eslint-disable-next-line new-cap
                throw E.INVALID_VALUE('priority', priorityValues);
            }
            if (this._priority !== priority) {
                this._priority = priority;
                this._setPriority(priority);
            }
            return this;
        };
        /**
         * @private
         * @param {boolean} isEnabled
         */
        RemoteMediaTrack.prototype._setEnabled = function (isEnabled) {
            if (this._isEnabled !== isEnabled) {
                this._isEnabled = isEnabled;
                this.emit(this._isEnabled ? 'enabled' : 'disabled', this);
            }
        };
        /**
         * @private
         * @param {?MediaTrackReceiver} mediaTrackReceiver
         */
        RemoteMediaTrack.prototype._setMediaTrackReceiver = function (mediaTrackReceiver) {
            if (this._mediaTrackTransceiver !== mediaTrackReceiver) {
                this._mediaTrackTransceiver = mediaTrackReceiver;
                this._initialize();
                this._updateElementsMediaStreamTrack();
            }
        };
        /**
         * @private
         * @param {boolean} isSwitchedOff
         * @param {?string} [switchOffReason=null]
         */
        RemoteMediaTrack.prototype._setSwitchedOff = function (isSwitchedOff, switchOffReason) {
            if (switchOffReason === void 0) { switchOffReason = null; }
            if (this._isSwitchedOff !== isSwitchedOff || this._switchOffReason !== switchOffReason) {
                this._isSwitchedOff = isSwitchedOff;
                this._switchOffReason = switchOffReason;
                this.emit.apply(this, __spreadArray([isSwitchedOff ? 'switchedOff' : 'switchedOn', this], __read((isSwitchedOff ? [this.switchOffReason] : []))));
            }
        };
        RemoteMediaTrack.prototype._attach = function () {
            var returnVal = _super.prototype._attach.apply(this, arguments);
            if (this._attachments.size > 0 && this.mediaStreamTrack && this.mediaStreamTrack.enabled !== true) {
                // NOTE(mpatwardhan): we disable mediaStreamTrack when there
                // are no attachments to it (see notes in detach function below). Now that there
                // are attachments re-enable the track.
                // we handle this in _attach instead of public attach below because for large room, we switch mediaStreamTracks between
                // RemoteMediaTracks as mid changes, invoking this internal _attach.
                // if we got the mediaStreamTrack from RemoteMediaTrack that was detached, it would have
                // mediaStreamTrack.enabled set to false which needs to be fixed before attaching.
                this._log.debug('Enabling mediaStreamTrack that was disabled while detached.');
                this.mediaStreamTrack.enabled = true;
                if (this.processedTrack) {
                    this.processedTrack.enabled = true;
                }
                // NOTE(csantos): since remote tracks disables/enables the mediaStreamTrack,
                // captureFrames stops along with it. We need to start it again after re-enabling.
                // See attach/detach methods in this class and in VideoTrack class.
                if (this.processor) {
                    this._captureFrames();
                }
            }
            return returnVal;
        };
        RemoteMediaTrack.prototype.attach = function (el) {
            var result = _super.prototype.attach.call(this, el);
            if (this._workaroundWebKitBug212780) {
                this._workaroundWebKitBug212780Cleanup = this._workaroundWebKitBug212780Cleanup
                    || playIfPausedWhileInBackground(this);
            }
            return result;
        };
        RemoteMediaTrack.prototype.detach = function (el) {
            var result = _super.prototype.detach.call(this, el);
            if (this._attachments.size === 0) {
                // NOTE(mpatwardhan): chrome continues playing webrtc audio
                // track even after audio element is removed from the DOM.
                // https://bugs.chromium.org/p/chromium/issues/detail?id=749928
                // to workaround: here disable the track when
                // there are no elements attached to it.
                if (this.mediaStreamTrack) {
                    this.mediaStreamTrack.enabled = false;
                }
                if (this.processedTrack) {
                    this.processedTrack.enabled = false;
                }
                if (this._workaroundWebKitBug212780Cleanup) {
                    // unhook visibility change
                    this._workaroundWebKitBug212780Cleanup();
                    this._workaroundWebKitBug212780Cleanup = null;
                }
            }
            return result;
        };
        return RemoteMediaTrack;
    }(AudioOrVideoTrack));
}
function playIfPausedWhileInBackground(remoteMediaTrack) {
    var log = remoteMediaTrack._log, kind = remoteMediaTrack.kind;
    function onVisibilityChanged(isVisible) {
        if (!isVisible) {
            return;
        }
        remoteMediaTrack._attachments.forEach(function (el) {
            var shim = remoteMediaTrack._elShims.get(el);
            var isInadvertentlyPaused = el.paused && shim && !shim.pausedIntentionally();
            if (isInadvertentlyPaused) {
                log.info("Playing inadvertently paused <" + kind + "> element");
                log.debug('Element:', el);
                log.debug('RemoteMediaTrack:', remoteMediaTrack);
                el.play().then(function () {
                    log.info("Successfully played inadvertently paused <" + kind + "> element");
                    log.debug('Element:', el);
                    log.debug('RemoteMediaTrack:', remoteMediaTrack);
                }).catch(function (err) {
                    log.warn("Error while playing inadvertently paused <" + kind + "> element:", { err: err, el: el, remoteMediaTrack: remoteMediaTrack });
                });
            }
        });
    }
    // NOTE(mpatwardhan): listen for document visibility callback on phase 2.
    // this ensures that any LocalMediaTrack's restart (which listen on phase 1) gets executed
    // first. This order is important because we `play` tracks in the callback, and
    // play can fail on safari if audio is not being captured.
    documentVisibilityMonitor.onVisibilityChange(2, onVisibilityChanged);
    return function () {
        documentVisibilityMonitor.offVisibilityChange(2, onVisibilityChanged);
    };
}
/**
 * A {@link RemoteMediaTrack} was disabled (Deprecated only for large group Rooms).
 * @deprecated Use <a href="#event:switchedOff"><code>switchedOff</code></a> (<code>.switchOffReason !== "disabled-by-publisher"</code>) instead
 * @param {RemoteMediaTrack} track - The {@link RemoteMediaTrack} that was
 *   disabled
 * @event RemoteMediaTrack#disabled
 */
/**
 * A {@link RemoteMediaTrack} was enabled (Deprecated only for large group Rooms).
 * @deprecated Use <a href="#event:switchedOn"><code>switchedOn</code></a> instead
 * @param {RemoteMediaTrack} track - The {@link RemoteMediaTrack} that was
 *   enabled
 * @event RemoteMediaTrack#enabled
 */
/**
 * A {@link RemoteMediaTrack} was switched off. The media server stops sending media for the
 * {@link RemoteMediaTrack} until it is switched back on. Just before the event is raised,
 * <code>isSwitchedOff</code> is set to <code>true</code> and <code>switchOffReason</code> is
 * set to a {@link TrackSwitchOffReason} in large group Rooms (<code>switchOffReason</code> is
 * <code>null</code> non-large group Rooms). Also, the <code>mediaStreamTrack</code> property
 * is set to <code>null</code> (only in large group Rooms).
 * @param {RemoteMediaTrack} track - The {@link RemoteMediaTrack} that was
 *   switched off
 * @param {?TrackSwitchOffReason} switchOffReason - The reason the {@link RemoteMediaTrack}
 *   was switched off
 * @event RemoteMediaTrack#switchedOff
 */
/**
 * A {@link RemoteMediaTrack} was switched on. The media server starts sending media for the
 * {@link RemoteMediaTrack} until it is switched off. Just before the event is raised,
 * <code>isSwitchedOff</code> is set to <code>false</code> and <code>switchOffReason</code>
 * is set to <code>null</code>. Also, the <code>mediaStreamTrack</code> property is set to a
 * MediaStreamTrack that is the source of the {@link RemoteMediaTrack}'s media.
 * @param {RemoteMediaTrack} track - The {@link RemoteMediaTrack} that was
 *   switched on
 * @event RemoteMediaTrack#switchedOn
 */
/**
 * A {@link ClientRenderHint} object specifies track dimensions and /enabled disable state.
 * This state will be used by the server(SFU) to determine bandwidth allocation for the track,
 * and turn it on or off as needed.
 * @typedef {object} ClientRenderHint
 * @property {boolean} [enabled] - track is enabled or disabled. defaults to disabled.
 * @property {VideoTrack.Dimensions} [renderDimensions] - Optional parameter to specify the desired
 *   render dimensions of {@link RemoteVideoTrack}s. This property must be specified if enabled=true
 */
module.exports = mixinRemoteMediaTrack;
//# sourceMappingURL=remotemediatrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/remotetrackpublication.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/remotetrackpublication.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var deprecateEvents = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js").deprecateEvents;
var TrackPublication = __webpack_require__(/*! ./trackpublication */ "./node_modules/twilio-video/es5/media/track/trackpublication.js");
/**
 * A {@link RemoteTrackPublication} represents a {@link RemoteTrack} that has
 * been published to a {@link Room}.
 * @extends TrackPublication
 * @property {boolean} isSubscribed - whether the published {@link RemoteTrack}
 *   is subscribed to
 * @property {boolean} isTrackEnabled - <code>Deprecated: Use (track.switchOffReason !== "disabled-by-publisher") instead. This property is only valid if the corresponding RemoteTrack is subscribed to.</code>
 *   whether the published {@link RemoteTrack} is enabled (Deprecated only for large group Rooms)
 * @property {Track.Kind} kind - kind of the published {@link RemoteTrack}
 * @property {Track.Priority} publishPriority - the {@link Track.Priority} of the published
 *   {@link RemoteTrack} set by the {@link RemoteParticipant}
 * @property {?RemoteTrack} track - Unless you have subscribed to the
 *   {@link RemoteTrack}, this property is null
 * @emits RemoteTrackPublication#publishPriorityChanged
 * @emits RemoteTrackPublication#subscribed
 * @emits RemoteTrackPublication#subscriptionFailed
 * @emits RemoteTrackPublication#trackDisabled
 * @emits RemoteTrackPublication#trackEnabled
 * @emits RemoteTrackPublication#trackSwitchedOff
 * @emits RemoteTrackPublication#trackSwitchedOn
 * @emits RemoteTrackPublication#unsubscribed
 *
 */
var RemoteTrackPublication = /** @class */ (function (_super) {
    __extends(RemoteTrackPublication, _super);
    /**
     * Construct a {@link RemoteTrackPublication}.
     * @param {RemoteTrackPublicationV2|RemoteTrackPublicationV3} signaling - {@link RemoteTrackPublication} signaling
     * @param {RemoteTrackPublicationOptions} options - {@link RemoteTrackPublication}
     *   options
     */
    function RemoteTrackPublication(signaling, options) {
        var _this = this;
        options = Object.assign({
            reemitEventsToRemoteParticipant: function () { }
        }, options);
        var rspVersion = signaling.rspVersion, sid = signaling.sid, trackName = signaling.name;
        var shouldDeprecateEnabledState = rspVersion >= 3;
        _this = _super.call(this, trackName, sid, options) || this;
        Object.defineProperties(_this, {
            _signaling: {
                value: signaling
            },
            _track: {
                value: null,
                writable: true
            },
            isSubscribed: {
                enumerable: true,
                get: function () {
                    return !!this._track;
                }
            },
            isTrackEnabled: {
                enumerable: true,
                get: function () {
                    if (shouldDeprecateEnabledState) {
                        this._log.deprecated('.isTrackEnabled is deprecated and scheduled for removal. '
                            + 'During the deprecation period, this property is only valid if the corresponding '
                            + 'RemoteTrack is subscribed to. The RemoteTrack can be considered disabled if '
                            + '.switchOffReason is set to "disabled-by-publisher".');
                    }
                    return signaling.isEnabled;
                }
            },
            kind: {
                enumerable: true,
                value: signaling.kind
            },
            publishPriority: {
                enumerable: true,
                get: function () {
                    return signaling.priority;
                }
            },
            track: {
                enumerable: true,
                get: function () {
                    return this._track;
                }
            }
        });
        // remember original state, and fire events only on change.
        var error = signaling.error, isEnabled = signaling.isEnabled, isSwitchedOff = signaling.isSwitchedOff, priority = signaling.priority, _a = signaling.switchOffReason, switchOffReason = _a === void 0 ? null : _a, trackTransceiver = signaling.trackTransceiver;
        var _b = _this, log = _b._log, name = _b.constructor.name;
        signaling.on('updated', function () {
            if (error !== signaling.error) {
                error = signaling.error;
                _this.emit('subscriptionFailed', signaling.error);
                return;
            }
            if (isEnabled !== signaling.isEnabled) {
                isEnabled = signaling.isEnabled;
                if (_this.track) {
                    _this.track._setEnabled(signaling.isEnabled);
                }
                _this.emit(signaling.isEnabled ? 'trackEnabled' : 'trackDisabled');
            }
            var newSwitchOffReason = signaling.switchOffReason || null;
            if (isSwitchedOff !== signaling.isSwitchedOff || switchOffReason !== newSwitchOffReason) {
                log.debug(_this.trackSid + ": " + (isSwitchedOff ? 'OFF' : 'ON') + " => " + (signaling.isSwitchedOff ? 'OFF' : 'ON'));
                log.debug(_this.trackSid + " off_reason: " + switchOffReason + " => " + newSwitchOffReason);
                isSwitchedOff = signaling.isSwitchedOff;
                switchOffReason = newSwitchOffReason;
                if (_this.track) {
                    _this.track._setSwitchedOff(signaling.isSwitchedOff, switchOffReason);
                    _this.emit.apply(_this, __spreadArray([isSwitchedOff ? 'trackSwitchedOff' : 'trackSwitchedOn', _this.track], __read((isSwitchedOff ? [_this.track.switchOffReason] : []))));
                }
                else {
                    log.debug("Track was not subscribed to when switched " + (isSwitchedOff ? 'off' : 'on') + ".");
                }
            }
            if (trackTransceiver !== signaling.trackTransceiver) {
                log.debug(_this.trackSid + " MediaTrackReceiver changed:", trackTransceiver, signaling.trackTransceiver);
                trackTransceiver = signaling.trackTransceiver;
                if (_this.track && _this.kind !== 'data') {
                    _this.track._setMediaTrackReceiver(trackTransceiver);
                }
                else if (!_this.track) {
                    log.debug('Track was not subscribed to when TrackReceiver changed.');
                }
            }
            if (priority !== signaling.priority) {
                priority = signaling.priority;
                _this.emit('publishPriorityChanged', priority);
            }
        });
        options.reemitEventsToRemoteParticipant(_this);
        if (shouldDeprecateEnabledState) {
            deprecateEvents(name, _this, new Map([
                ['trackDisabled', 'trackSwitchedOff (track.switchOffReason === "disabled-by-publisher")'],
                ['trackEnabled', 'trackSwitchedOn']
            ]), log);
        }
        return _this;
    }
    RemoteTrackPublication.prototype.toString = function () {
        return "[RemoteTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    /**
     * @private
     * @param {RemoteTrack} track
     */
    RemoteTrackPublication.prototype._subscribed = function (track) {
        if (!this._track && track) {
            this._track = track;
            this.emit('subscribed', track);
        }
    };
    /**
     * @private
     */
    RemoteTrackPublication.prototype._unsubscribe = function () {
        if (this._track) {
            var track = this._track;
            this._track = null;
            this.emit('unsubscribed', track);
        }
    };
    return RemoteTrackPublication;
}(TrackPublication));
/**
 * The {@link RemoteTrack}'s publish {@link Track.Priority} was changed by the
 * {@link RemoteParticipant}.
 * @param {Track.Priority} priority - the {@link RemoteTrack}'s new publish
 *   {@link Track.Priority}; RemoteTrackPublication#publishPriority is also
 *   updated accordingly
 * @event RemoteTrackPublication#publishPriorityChanged
 */
/**
 * Your {@link LocalParticipant} subscribed to the {@link RemoteTrack}.
 * @param {RemoteTrack} track - the {@link RemoteTrack} that was subscribed to
 * @event RemoteTrackPublication#subscribed
 */
/**
 * Your {@link LocalParticipant} failed to subscribe to the {@link RemoteTrack}.
 * @param {TwilioError} error - the reason the {@link RemoteTrack} could not be
 *   subscribed to
 * @event RemoteTrackPublication#subscriptionFailed
 */
/**
 * The {@link RemoteTrack} was disabled. In large group Rooms, it is fired only if <code>.isSubscribed</code>
 * is set to <code>true</code> (Deprecated only for large group Rooms).
 * @deprecated Use <a href="event:trackSwitchedOff"><code>trackSwitchedOff</code></a> (<code>track.switchOffReason === "disabled-by-publisher"</code>) instead
 * @event RemoteTrackPublication#trackDisabled
 */
/**
 * The {@link RemoteTrack} was enabled. In large group Rooms, it is fired only if <code>.isSubscribed</code>
 * is set to <code>true</code> (Deprecated only for large group Rooms).
 * @deprecated Use <a href="event:trackSwitchedOn"><code>trackSwitchedOn</code></a> instead
 * @event RemoteTrackPublication#trackEnabled
 */
/**
 * The {@link RemoteTrack} was switched off. The media server stops sending media or data
 * for the {@link RemoteTrack} until it is switched back on. Just before the event is raised,
 * <code>isSwitchedOff</code> is set to <code>true</code> and <code>switchOffReason</code>
 * is set to a {@link TrackSwitchOffReason} in large group Rooms (<code>switchOffReason</code> is
 * <code>null</code> non-large group Rooms). Also, if the {@link RemoteTrack} receives either
 * audio or video media, the <code>mediaStreamTrack</code> property is set to <code>null</code>.
 * (only in large group Rooms)
 * @param {RemoteTrack} track - the {@link RemoteTrack} that was switched off
 * @param {?TrackSwitchOffReason} switchOffReason - the reason the {@link RemoteTrack}
 *   was switched off
 * @event RemoteTrackPublication#trackSwitchedOff
 */
/**
 * The {@link RemoteTrack} was switched on. The media server starts sending media or data
 * for the {@link RemoteMediaTrack} until it is switched off. Just before the event is raised,
 * <code>isSwitchedOff</code> is set to <code>false</code> and <code>switchOffReason</code>
 * is set to <code>null</code>. Also, if the {@link RemoteTrack} receives either audio or video
 * media,the <code>mediaStreamTrack</code> property is set to a MediaStreamTrack that is the
 * source of the {@link RemoteTrack}'s media.
 * @param {RemoteTrack} track - the {@link RemoteTrack} that was switched on
 * @event RemoteTrackPublication#trackSwitchedOn
 */
/**
 * Your {@link LocalParticipant} unsubscribed from the {@link RemoteTrack}.
 * @param {RemoteTrack} track - the {@link RemoteTrack} that was unsubscribed from
 * @event RemoteTrackPublication#unsubscribed
 */
/**
 * {@link RemoteTrackPublication} options
 * @typedef {object} RemoteTrackPublicationOptions
 * @property {LogLevel|LogLevels} logLevel - Log level for 'media' modules
 */
module.exports = RemoteTrackPublication;
//# sourceMappingURL=remotetrackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/remotevideotrack.js":
/*!***********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/remotevideotrack.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var mixinRemoteMediaTrack = __webpack_require__(/*! ./remotemediatrack */ "./node_modules/twilio-video/es5/media/track/remotemediatrack.js");
var VideoTrack = __webpack_require__(/*! ./videotrack */ "./node_modules/twilio-video/es5/media/track/videotrack.js");
var documentVisibilityMonitor = __webpack_require__(/*! ../../util/documentvisibilitymonitor.js */ "./node_modules/twilio-video/es5/util/documentvisibilitymonitor.js");
var NullObserver = __webpack_require__(/*! ../../util/nullobserver.js */ "./node_modules/twilio-video/es5/util/nullobserver.js").NullObserver;
var Timeout = __webpack_require__(/*! ../../util/timeout */ "./node_modules/twilio-video/es5/util/timeout.js");
var RemoteMediaVideoTrack = mixinRemoteMediaTrack(VideoTrack);
var TRACK_TURN_OF_DELAY_MS = 50;
/**
 * A {@link RemoteVideoTrack} represents a {@link VideoTrack} published to a
 * {@link Room} by a {@link RemoteParticipant}.
 * @extends VideoTrack
 * @property {boolean} isEnabled - <code>Deprecated: Use (.switchOffReason !== "disabled-by-publisher") instead</code>
 *   Whether the {@link RemoteVideoTrack} is enabled (Deprecated only for large group Rooms)
 * @property {boolean} isSwitchedOff - Whether the {@link RemoteVideoTrack} is switched off
 * @property {?TrackSwitchOffReason} switchOffReason - The reason for the {@link RemoteVideoTrack} being switched off;
 *   If switched on, it is set to <code>null</code>; The {@link RemoteVideoTrack} is initially switched off with this
 *   property set to <code>disabled-by-subscriber</code> * @property {Track.SID} sid - The {@link RemoteVideoTrack}'s SID
 * @property {?Track.Priority} priority - The subscribe priority of the {@link RemoteVideoTrack}
 * @emits RemoteVideoTrack#dimensionsChanged
 * @emits RemoteVideoTrack#disabled
 * @emits RemoteVideoTrack#enabled
 * @emits RemoteVideoTrack#started
 * @emits RemoteVideoTrack#switchedOff
 * @emits RemoteVideoTrack#switchedOn
 */
var RemoteVideoTrack = /** @class */ (function (_super) {
    __extends(RemoteVideoTrack, _super);
    /**
     * Construct a {@link RemoteVideoTrack}.
     * @param {Track.SID} sid - The {@link RemoteVideoTrack}'s SID
     * @param {?MediaTrackReceiver} mediaTrackReceiver - A video MediaStreamTrack container
     * @param {boolean} isEnabled - whether the {@link RemoteVideoTrack} is enabled
     * @param {boolean} isSwitchedOff - Whether the {@link RemoteVideoTrack} is switched off
     * @param {?string} switchOffReason - The reason the {@link RemoteVideoTrack} is switched off
     * @param {function(?Track.Priority): void} setPriority - Set or clear the subscribe
     *  {@link Track.Priority} of the {@link RemoteVideoTrack}
     * @param {function(ClientRenderHint): void} setRenderHint - Set render hints.
     * @param {{log: Log, name: string}} options - The {@link RemoteTrack} options
     */
    function RemoteVideoTrack(sid, mediaTrackReceiver, isEnabled, isSwitchedOff, switchOffReason, setPriority, setRenderHint, options) {
        var _this = this;
        options = Object.assign({
            clientTrackSwitchOffControl: 'auto',
            contentPreferencesMode: 'auto',
            enableDocumentVisibilityTurnOff: true
        }, options);
        options = Object.assign({
            IntersectionObserver: typeof IntersectionObserver === 'undefined' || options.clientTrackSwitchOffControl !== 'auto' ? NullObserver : IntersectionObserver,
            ResizeObserver: typeof ResizeObserver === 'undefined' || options.contentPreferencesMode !== 'auto' ? NullObserver : ResizeObserver
        }, options);
        _this = _super.call(this, 'video', sid, mediaTrackReceiver, isEnabled, isSwitchedOff, switchOffReason, setPriority, setRenderHint, options) || this;
        Object.defineProperties(_this, {
            _enableDocumentVisibilityTurnOff: {
                value: options.enableDocumentVisibilityTurnOff === true && options.clientTrackSwitchOffControl === 'auto',
            },
            _documentVisibilityTurnOffCleanup: {
                value: null,
                writable: true
            },
            _clientTrackSwitchOffControl: {
                value: options.clientTrackSwitchOffControl,
            },
            _contentPreferencesMode: {
                value: options.contentPreferencesMode,
            },
            _invisibleElements: {
                value: new WeakSet(),
            },
            _elToPipCallbacks: {
                value: new WeakMap(),
            },
            _elToPipWindows: {
                value: new WeakMap(),
            },
            _turnOffTimer: {
                value: new Timeout(function () {
                    _this._setRenderHint({ enabled: false });
                }, TRACK_TURN_OF_DELAY_MS, false),
            },
            _resizeObserver: {
                value: new options.ResizeObserver(function (entries) {
                    // NOTE(mpatwardhan): we ignore elements in _invisibleElements
                    // to ensure that ResizeObserver does not end-up turning off a track when a fresh Video element is
                    // attached and IntersectionObserver has not had its callback executed yet.
                    var visibleElementResized = entries.find(function (entry) { return !_this._invisibleElements.has(entry.target); });
                    if (visibleElementResized) {
                        maybeUpdateDimensionHint(_this);
                    }
                })
            },
            _intersectionObserver: {
                value: new options.IntersectionObserver(function (entries) {
                    var shouldSetRenderHint = false;
                    entries.forEach(function (entry) {
                        var wasVisible = !_this._invisibleElements.has(entry.target);
                        if (wasVisible !== entry.isIntersecting) {
                            if (entry.isIntersecting) {
                                _this._log.debug('intersectionObserver detected: Off => On');
                                _this._invisibleElements.delete(entry.target);
                            }
                            else {
                                _this._log.debug('intersectionObserver detected: On => Off');
                                _this._invisibleElements.add(entry.target);
                            }
                            shouldSetRenderHint = true;
                        }
                    });
                    if (shouldSetRenderHint) {
                        maybeUpdateEnabledHint(_this);
                        // when visibility of an element changes that may cause the "biggest" element to change,
                        // update dimensions as well. since dimensions are cached and de-duped at signaling layer,
                        // its okay if they got  resent.
                        maybeUpdateDimensionHint(_this);
                    }
                }, { threshold: 0.25 })
            },
        });
        return _this;
    }
    /**
     * @private
     */
    RemoteVideoTrack.prototype._start = function (dummyEl) {
        var result = _super.prototype._start.call(this, dummyEl);
        // NOTE(mpatwardhan): after emitting started, update turn off track if not visible.
        maybeUpdateEnabledHint(this);
        return result;
    };
    /**
     * @private
     * @override
     * @param {?MediaTrackReceiver} mediaTrackReceiver
     */
    RemoteVideoTrack.prototype._setMediaTrackReceiver = function (mediaTrackReceiver) {
        var processor = this.processor;
        if (processor) {
            this.removeProcessor(processor);
        }
        _super.prototype._setMediaTrackReceiver.call(this, mediaTrackReceiver);
        if (processor) {
            this.addProcessor(processor);
        }
    };
    /**
     * Request to switch on a {@link RemoteVideoTrack}, This method is applicable only for the group rooms and only when connected with
     * clientTrackSwitchOffControl in video bandwidth profile options set to 'manual'
     * @returns {this}
     */
    RemoteVideoTrack.prototype.switchOn = function () {
        if (this._clientTrackSwitchOffControl !== 'manual') {
            throw new Error('Invalid state. You can call switchOn only when bandwidthProfile.video.clientTrackSwitchOffControl is set to "manual"');
        }
        this._setRenderHint({ enabled: true });
        return this;
    };
    /**
     * Request to switch off a {@link RemoteVideoTrack}, This method is applicable only for the group rooms and only when connected with
     * clientTrackSwitchOffControl in video bandwidth profile options set to 'manual'
     * @returns {this}
     */
    RemoteVideoTrack.prototype.switchOff = function () {
        if (this._clientTrackSwitchOffControl !== 'manual') {
            throw new Error('Invalid state. You can call switchOff only when bandwidthProfile.video.clientTrackSwitchOffControl is set to "manual"');
        }
        this._setRenderHint({ enabled: false });
        return this;
    };
    /**
     * Set the {@link RemoteVideoTrack}'s content preferences. This method is applicable only for the group rooms and only when connected with
     * videoContentPreferencesMode in video bandwidth profile options set to 'manual'
     * @param {VideoContentPreferences} contentPreferences - requested preferences.
     * @returns {this}
     */
    RemoteVideoTrack.prototype.setContentPreferences = function (contentPreferences) {
        if (this._contentPreferencesMode !== 'manual') {
            throw new Error('Invalid state. You can call switchOn only when bandwidthProfile.video.contentPreferencesMode is set to "manual"');
        }
        if (contentPreferences.renderDimensions) {
            this._setRenderHint({ renderDimensions: contentPreferences.renderDimensions });
        }
        return this;
    };
    RemoteVideoTrack.prototype._unObservePip = function (el) {
        var pipCallbacks = this._elToPipCallbacks.get(el);
        if (pipCallbacks) {
            el.removeEventListener('enterpictureinpicture', pipCallbacks.onEnterPip);
            el.removeEventListener('leavepictureinpicture', pipCallbacks.onLeavePip);
            this._elToPipCallbacks.delete(el);
        }
    };
    RemoteVideoTrack.prototype._observePip = function (el) {
        var _this = this;
        var pipCallbacks = this._elToPipCallbacks.get(el);
        if (!pipCallbacks) {
            var onEnterPip = function (event) { return _this._onEnterPip(event, el); };
            var onLeavePip = function (event) { return _this._onLeavePip(event, el); };
            var onResizePip = function (event) { return _this._onResizePip(event, el); };
            el.addEventListener('enterpictureinpicture', onEnterPip);
            el.addEventListener('leavepictureinpicture', onLeavePip);
            this._elToPipCallbacks.set(el, { onEnterPip: onEnterPip, onLeavePip: onLeavePip, onResizePip: onResizePip });
        }
    };
    RemoteVideoTrack.prototype._onEnterPip = function (event, videoEl) {
        this._log.debug('onEnterPip');
        var pipWindow = event.pictureInPictureWindow;
        this._elToPipWindows.set(videoEl, pipWindow);
        var onResizePip = this._elToPipCallbacks.get(videoEl).onResizePip;
        pipWindow.addEventListener('resize', onResizePip);
        maybeUpdateEnabledHint(this);
    };
    RemoteVideoTrack.prototype._onLeavePip = function (event, videoEl) {
        this._log.debug('onLeavePip');
        this._elToPipWindows.delete(videoEl);
        var onResizePip = this._elToPipCallbacks.get(videoEl).onResizePip;
        var pipWindow = event.pictureInPictureWindow;
        pipWindow.removeEventListener('resize', onResizePip);
        maybeUpdateEnabledHint(this);
    };
    RemoteVideoTrack.prototype._onResizePip = function () {
        maybeUpdateDimensionHint(this);
    };
    RemoteVideoTrack.prototype.attach = function (el) {
        var result = _super.prototype.attach.call(this, el);
        if (this._clientTrackSwitchOffControl === 'auto') {
            // start off the element as invisible. will mark it
            // visible (and update render hints) once intersection observer calls back.
            this._invisibleElements.add(result);
        }
        this._intersectionObserver.observe(result);
        this._resizeObserver.observe(result);
        if (this._enableDocumentVisibilityTurnOff) {
            this._documentVisibilityTurnOffCleanup = this._documentVisibilityTurnOffCleanup || setupDocumentVisibilityTurnOff(this);
        }
        this._observePip(result);
        return result;
    };
    RemoteVideoTrack.prototype.detach = function (el) {
        var _this = this;
        var result = _super.prototype.detach.call(this, el);
        var elements = Array.isArray(result) ? result : [result];
        elements.forEach(function (element) {
            _this._intersectionObserver.unobserve(element);
            _this._resizeObserver.unobserve(element);
            _this._invisibleElements.delete(element);
            _this._unObservePip(element);
        });
        if (this._attachments.size === 0) {
            if (this._documentVisibilityTurnOffCleanup) {
                this._documentVisibilityTurnOffCleanup();
                this._documentVisibilityTurnOffCleanup = null;
            }
        }
        maybeUpdateEnabledHint(this);
        maybeUpdateDimensionHint(this);
        return result;
    };
    /**
     * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.
     * When a Participant un-publishes and re-publishes a VideoTrack, a new RemoteVideoTrack is created and
     * any VideoProcessors attached to the previous RemoteVideoTrack would have to be re-added again.
     * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.
     * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.
     * @returns {this}
     * @example
     * class GrayScaleProcessor {
     *   constructor(percentage) {
     *     this.percentage = percentage;
     *   }
     *   processFrame(inputFrameBuffer, outputFrameBuffer) {
     *     const context = outputFrameBuffer.getContext('2d');
     *     context.filter = `grayscale(${this.percentage}%)`;
     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
     *   }
     * }
     *
     * const grayscaleProcessor = new GrayScaleProcessor(100);
     *
     * Array.from(room.participants.values()).forEach(participant => {
     *   const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;
     *   remoteVideoTrack.addProcessor(grayscaleProcessor);
     * });
     */
    RemoteVideoTrack.prototype.addProcessor = function () {
        return _super.prototype.addProcessor.apply(this, arguments);
    };
    /**
     * Remove the previously added {@link VideoProcessor} using `addProcessor` API.
     * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.
     * @returns {this}
     * @example
     * class GrayScaleProcessor {
     *   constructor(percentage) {
     *     this.percentage = percentage;
     *   }
     *   processFrame(inputFrameBuffer, outputFrameBuffer) {
     *     const context = outputFrameBuffer.getContext('2d');
     *     context.filter = `grayscale(${this.percentage}%)`;
     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
     *   }
     * }
     *
     * const grayscaleProcessor = new GrayScaleProcessor(100);
     *
     * Array.from(room.participants.values()).forEach(participant => {
     *   const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;
     *   remoteVideoTrack.addProcessor(grayscaleProcessor);
     * });
     *
     * document.getElementById('remove-button').onclick = () => {
     *   Array.from(room.participants.values()).forEach(participant => {
     *     const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;
     *     remoteVideoTrack.removeProcessor(grayscaleProcessor);
     *   });
     * }
     */
    RemoteVideoTrack.prototype.removeProcessor = function () {
        return _super.prototype.removeProcessor.apply(this, arguments);
    };
    RemoteVideoTrack.prototype.toString = function () {
        return "[RemoteVideoTrack #" + this._instanceId + ": " + this.sid + "]";
    };
    /**
     * Update the subscribe {@link Track.Priority} of the {@link RemoteVideoTrack}.
     * @param {?Track.Priority} priority - the new subscribe {@link Track.Priority};
     *   If <code>null</code>, then the subscribe {@link Track.Priority} is cleared, which
     *   means the {@link Track.Priority} set by the publisher is now the effective priority.
     * @returns {this}
     * @throws {RangeError}
     */
    RemoteVideoTrack.prototype.setPriority = function (priority) {
        return _super.prototype.setPriority.call(this, priority);
    };
    return RemoteVideoTrack;
}(RemoteMediaVideoTrack));
function setupDocumentVisibilityTurnOff(removeVideoTrack) {
    function onVisibilityChanged() {
        maybeUpdateEnabledHint(removeVideoTrack);
    }
    documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChanged);
    return function () {
        documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChanged);
    };
}
function maybeUpdateEnabledHint(remoteVideoTrack) {
    if (remoteVideoTrack._clientTrackSwitchOffControl !== 'auto') {
        return;
    }
    var visibleElements = remoteVideoTrack._getAllAttachedElements().filter(function (el) { return !remoteVideoTrack._invisibleElements.has(el); });
    var pipWindows = remoteVideoTrack._getAllAttachedElements().filter(function (el) { return remoteVideoTrack._elToPipWindows.has(el); });
    // even when document is invisible we may have track playing in pip window.
    var enabled = pipWindows.length > 0 || (document.visibilityState === 'visible' && visibleElements.length > 0);
    if (enabled === true) {
        remoteVideoTrack._turnOffTimer.clear();
        remoteVideoTrack._setRenderHint({ enabled: true });
    }
    else if (!remoteVideoTrack._turnOffTimer.isSet) {
        // set the track to be turned off after some delay.
        remoteVideoTrack._turnOffTimer.start();
    }
}
function maybeUpdateDimensionHint(remoteVideoTrack) {
    if (remoteVideoTrack._contentPreferencesMode !== 'auto') {
        return;
    }
    var visibleElements = remoteVideoTrack._getAllAttachedElements().filter(function (el) { return !remoteVideoTrack._invisibleElements.has(el); });
    var pipElements = remoteVideoTrack._getAllAttachedElements().map(function (el) {
        var pipWindow = remoteVideoTrack._elToPipWindows.get(el);
        return pipWindow ? { clientHeight: pipWindow.height, clientWidth: pipWindow.width } : { clientHeight: 0, clientWidth: 0 };
    });
    var totalElements = visibleElements.concat(pipElements);
    if (totalElements.length > 0) {
        var _a = __read(totalElements.sort(function (el1, el2) {
            return el2.clientHeight + el2.clientWidth - el1.clientHeight - el1.clientWidth - 1;
        }), 1), _b = _a[0], clientHeight = _b.clientHeight, clientWidth = _b.clientWidth;
        var renderDimensions = { height: clientHeight, width: clientWidth };
        remoteVideoTrack._setRenderHint({ renderDimensions: renderDimensions });
    }
}
/**
 * @typedef {object} VideoContentPreferences
 * @property {VideoTrack.Dimensions} [renderDimensions] - Render Dimensions to request for the {@link RemoteVideoTrack}.
 */
/**
 * The {@link RemoteVideoTrack}'s dimensions changed.
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} whose
 *   dimensions changed
 * @event RemoteVideoTrack#dimensionsChanged
 */
/**
 * The {@link RemoteVideoTrack} was disabled, i.e. "paused" (Deprecated only for large group Rooms).
 * @deprecated Use <a href="#event:switchedOff"><code>switchedOff</code></a> (<code>.switchOffReason === "disabled-by-publisher"</code>) instead
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was
 *   disabled
 * @event RemoteVideoTrack#disabled
 */
/**
 * The {@link RemoteVideoTrack} was enabled, i.e. "resumed" (Deprecated only for large group Rooms).
 * @deprecated Use <a href="#event:switchedOn"><code>switchedOn</code></a> instead
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was
 *   enabled
 * @event RemoteVideoTrack#enabled
 */
/**
 * The {@link RemoteVideoTrack} started. This means there is enough video data
 * to begin playback.
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that started
 * @event RemoteVideoTrack#started
 */
/**
 * A {@link RemoteVideoTrack} was switched off. The media server stops sending media for the
 * {@link RemoteVideoTrack} until it is switched back on. Just before the event is raised,
 * <code>isSwitchedOff</code> is set to <code>true</code> and <code>switchOffReason</code> is
 * set to a {@link TrackSwitchOffReason} in large group Rooms (<code>switchOffReason</code> is
 * <code>null</code> non-large group Rooms). Also, the <code>mediaStreamTrack</code> property
 * is set to <code>null</code> (only in large group Rooms).
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was
 *   switched off
 * @param {?TrackSwitchOffReason} switchOffReason - The reason the {@link RemoteVideoTrack}
 *   was switched off
 * @event RemoteVideoTrack#switchedOff
 */
/**
 * A {@link RemoteVideoTrack} was switched on.
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was
 *   switched on
 * @event RemoteVideoTrack#switchedOn
 */
module.exports = RemoteVideoTrack;
//# sourceMappingURL=remotevideotrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/remotevideotrackpublication.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/remotevideotrackpublication.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteTrackPublication = __webpack_require__(/*! ./remotetrackpublication */ "./node_modules/twilio-video/es5/media/track/remotetrackpublication.js");
/**
 * A {@link RemoteVideoTrackPublication} represents a {@link RemoteVideoTrack}
 * that has been published to a {@link Room}.
 * @property {Track.Kind} kind - "video"
 * @property {?RemoteVideoTrack} track - unless you have subscribed to the
 *   {@link RemoteVideoTrack}, this property is null
 * @emits RemoteVideoTrackPublication#subscribed
 * @emits RemoteVideoTrackPublication#subscriptionFailed
 * @emits RemoteVideoTrackPublication#trackDisabled
 * @emits RemoteVideoTrackPublication#trackEnabled
 * @emits RemoteVideoTrackPublication#unsubscribed
 */
var RemoteVideoTrackPublication = /** @class */ (function (_super) {
    __extends(RemoteVideoTrackPublication, _super);
    /**
     * Construct a {@link RemoteVideoTrackPublication}.
     * @param {RemoteTrackPublicationSignaling} signaling - {@link RemoteTrackPublication} signaling
     * @param {RemoteTrackPublicationOptions} options - {@link RemoteTrackPublication}
     *   options
     */
    function RemoteVideoTrackPublication(signaling, options) {
        return _super.call(this, signaling, options) || this;
    }
    RemoteVideoTrackPublication.prototype.toString = function () {
        return "[RemoteVideoTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return RemoteVideoTrackPublication;
}(RemoteTrackPublication));
/**
 * Your {@link LocalParticipant} subscribed to the {@link RemoteVideoTrack}.
 * @param {RemoteVideoTrack} track - the {@link RemoteVideoTrack} that was subscribed to
 * @event RemoteVideoTrackPublication#subscribed
 */
/**
 * Your {@link LocalParticipant} failed to subscribe to the {@link RemoteVideoTrack}.
 * @param {TwilioError} error - the reason the {@link RemoteVideoTrack} could not be
 *   subscribed to
 * @event RemoteVideoTrackPublication#subscriptionFailed
 */
/**
 * The {@link RemoteVideoTrack} was disabled. It is fired only if <code>.isSubscribed</code>
 * is set to <code>true</code> (Deprecated only for large group Rooms).
 * @deprecated Use <a href="event:trackSwitchedOff"><code>trackSwitchedOff</code></a> (<code>track.switchOffReason === "disabled-by-publisher"</code>) instead
 * @event RemoteVideoTrackPublication#trackDisabled
 */
/**
 * The {@link RemoteVideoTrack} was enabled. It is fired only if <code>.isSubscribed</code>
 * is set to <code>true</code> (Deprecated only for large group Rooms).
 * @deprecated Use <a href="event:trackSwitchedOn"><code>trackSwitchedOn</code></a> instead
 * @event RemoteVideoTrackPublication#trackEnabled
 */
/**
 * The {@link RemoteVideoTrack} was switched off. The media server stops sending media for
 * the {@link RemoteVideoTrack} until it is switched back on. Just before the event is raised,
 * <code>isSwitchedOff</code> is set to <code>true</code> and <code>switchOffReason</code>
 * is set to a {@link TrackSwitchOffReason} in large group Rooms (<code>switchOffReason</code> is
 * <code>null</code> non-large group Rooms). Also, if the {@link RemoteVideoTrack} receives audio
 * media, the <code>mediaStreamTrack</code> property is set to <code>null</code>. (only in large
 * group Rooms)
 * @param {RemoteVideoTrack} track - the {@link RemoteVideoTrack} that was switched off
 * @param {?TrackSwitchOffReason} switchOffReason - the reason the {@link RemoteVideoTrack}
 *   was switched off
 * @event RemoteVideoTrackPublication#trackSwitchedOff
 */
/**
 * The {@link RemoteVideoTrack} was switched on. The media server starts sending media for
 * the {@link RemoteVideoTrack} until it is switched off. Just before the event is raised,
 * <code>isSwitchedOff</code> is set to <code>false</code> and <code>switchOffReason</code>
 * is set to <code>null</code>. Also, the <code>mediaStreamTrack</code> property is set to a
 * MediaStreamTrack that is the source of the {@link RemoteVideoTrack}'s media.
 * @param {RemoteVideoTrack} track - the {@link RemoteVideoTrack} that was switched on
 * @event RemoteVideoTrackPublication#trackSwitchedOn
 */
/**
 * Your {@link LocalParticipant} unsubscribed from the {@link RemoteVideoTrack}.
 * @param {RemoteVideoTrack} track - the {@link RemoteVideoTrack} that was unsubscribed from
 * @event RemoteVideoTrackPublication#unsubscribed
 */
module.exports = RemoteVideoTrackPublication;
//# sourceMappingURL=remotevideotrackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/sender.js":
/*!*************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/sender.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var MediaTrackTransceiver = __webpack_require__(/*! ./transceiver */ "./node_modules/twilio-video/es5/media/track/transceiver.js");
/**
 * A {@link MediaTrackSender} represents one or more local RTCRtpSenders.
 * @extends MediaTrackTransceiver
 * @emits MediaTrackSender#replaced
 */
var MediaTrackSender = /** @class */ (function (_super) {
    __extends(MediaTrackSender, _super);
    /**
     * Construct a {@link MediaTrackSender}.
     * @param {MediaStreamTrack} mediaStreamTrack
     */
    function MediaTrackSender(mediaStreamTrack) {
        var _this = _super.call(this, mediaStreamTrack.id, null, mediaStreamTrack) || this;
        Object.defineProperties(_this, {
            _clones: {
                value: new Set()
            },
            _senders: {
                value: new Set()
            },
            _senderToPublisherHintCallbacks: {
                value: new Map()
            },
            isPublishing: {
                get: function () {
                    return !!this._clones.size;
                }
            }
        });
        return _this;
    }
    /**
     * Return a new {@link MediaTrackSender} containing a clone of the underlying
     * MediaStreamTrack. No RTCRtpSenders are copied.
     * @returns {MediaTrackSender}
     */
    MediaTrackSender.prototype.clone = function () {
        var clone = new MediaTrackSender(this.track.clone());
        this._clones.add(clone);
        return clone;
    };
    /**
     * Remove a cloned {@link MediaTrackSender}.
     * @returns {void}
     */
    MediaTrackSender.prototype.removeClone = function (clone) {
        this._clones.delete(clone);
    };
    /**
     * Set the given MediaStreamTrack.
     * @param {MediaStreamTrack} mediaStreamTrack
     * @returns {Promise<void>}
     */
    MediaTrackSender.prototype.setMediaStreamTrack = function (mediaStreamTrack) {
        var _this = this;
        var clones = Array.from(this._clones);
        var senders = Array.from(this._senders);
        return Promise.all(clones.map(function (clone) {
            return clone.setMediaStreamTrack(mediaStreamTrack.clone());
        }).concat(senders.map(function (sender) {
            return _this._replaceTrack(sender, mediaStreamTrack);
        }))).finally(function () {
            _this._track = mediaStreamTrack;
        });
    };
    /**
     * Add an RTCRtpSender.
     * @param {RTCRtpSender} sender
     * @param {?()=>Promise<string>} publisherHintCallback
     * @returns {this}
     */
    MediaTrackSender.prototype.addSender = function (sender, publisherHintCallback) {
        this._senders.add(sender);
        if (publisherHintCallback) {
            this._senderToPublisherHintCallbacks.set(sender, publisherHintCallback);
        }
        return this;
    };
    /**
     * Remove an RTCRtpSender.
     * @param {RTCRtpSender} sender
     * @returns {this}
     */
    MediaTrackSender.prototype.removeSender = function (sender) {
        this._senders.delete(sender);
        this._senderToPublisherHintCallbacks.delete(sender);
        return this;
    };
    /**
     * Applies given encodings, or resets encodings if none specified.
     * @param {Array<{enabled: boolean, layer_index: number}>|null} encodings
     * @returns {Promise<string>}
     */
    MediaTrackSender.prototype.setPublisherHint = function (encodings) {
        // Note(mpatwardhan): since publisher hint applies only to group rooms we only look at 1st call callback.
        var _a = __read(Array.from(this._senderToPublisherHintCallbacks.values()), 1), publisherHintCallback = _a[0];
        return publisherHintCallback ? publisherHintCallback(encodings) : Promise.resolve('COULD_NOT_APPLY_HINT');
    };
    MediaTrackSender.prototype._replaceTrack = function (sender, mediaStreamTrack) {
        var _this = this;
        return sender.replaceTrack(mediaStreamTrack).then(function (replaceTrackResult) {
            // clear any publisherHints and apply default encodings.
            _this.setPublisherHint(null).catch(function () { });
            _this.emit('replaced');
            return replaceTrackResult;
        });
    };
    return MediaTrackSender;
}(MediaTrackTransceiver));
/**
 * The {@link MediaTrackSender} replaced the underlying mediaStreamTrack
 * @event MediaTrackSender#replaced
 */
module.exports = MediaTrackSender;
//# sourceMappingURL=sender.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/trackpublication.js":
/*!***********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/trackpublication.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! ../../eventemitter */ "./node_modules/twilio-video/es5/eventemitter.js");
var _a = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js"), buildLogLevels = _a.buildLogLevels, valueToJSON = _a.valueToJSON;
var DEFAULT_LOG_LEVEL = __webpack_require__(/*! ../../util/constants */ "./node_modules/twilio-video/es5/util/constants.js").DEFAULT_LOG_LEVEL;
var Log = __webpack_require__(/*! ../../util/log */ "./node_modules/twilio-video/es5/util/log.js");
var nInstances = 0;
/**
 * A {@link TrackPublication} represents a {@link Track} that
 * has been published to a {@link Room}.
 * @property {string} trackName - the published {@link Track}'s name
 * @property {Track.SID} trackSid - SID assigned to the published {@link Track}
 * @emits TrackPublication#trackDisabled
 * @emits TrackPublication#trackEnabled
 */
var TrackPublication = /** @class */ (function (_super) {
    __extends(TrackPublication, _super);
    /**
     * Construct a {@link TrackPublication}.
     * @param {string} trackName - the published {@link Track}'s name
     * @param {Track.SID} trackSid - SID assigned to the {@link Track}
     * @param {TrackPublicationOptions} options - {@link TrackPublication} options
     */
    function TrackPublication(trackName, trackSid, options) {
        var _this = _super.call(this) || this;
        options = Object.assign({
            logLevel: DEFAULT_LOG_LEVEL
        }, options);
        var logLevels = buildLogLevels(options.logLevel);
        Object.defineProperties(_this, {
            _instanceId: {
                value: nInstances++
            },
            _log: {
                value: options.log ? options.log.createLog('default', _this) : new Log('default', _this, logLevels, options.loggerName)
            },
            trackName: {
                enumerable: true,
                value: trackName
            },
            trackSid: {
                enumerable: true,
                value: trackSid
            }
        });
        return _this;
    }
    TrackPublication.prototype.toJSON = function () {
        return valueToJSON(this);
    };
    TrackPublication.prototype.toString = function () {
        return "[TrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return TrackPublication;
}(EventEmitter));
/**
 * The published {@link Track} was disabled.
 * @event TrackPublication#trackDisabled
 */
/**
 * The published {@link Track} was enabled.
 * @event TrackPublication#trackEnabled
 */
/**
 * A {@link LocalAudioTrackPublication} or a {@link RemoteAudioTrackPublication}.
 * @typedef {LocalAudioTrackPublication|RemoteAudioTrackPublication} AudioTrackPublication
 */
/**
 * A {@link LocalDataTrackPublication} or a {@link RemoteDataTrackPublication}.
 * @typedef {LocalDataTrackPublication|RemoteDataTrackPublication} DataTrackPublication
 */
/**
 * A {@link LocalVideoTrackPublication} or a {@link RemoteVideoTrackPublication}.
 * @typedef {LocalVideoTrackPublication|RemoteVideoTrackPublication} VideoTrackPublication
 */
/**
 * {@link TrackPublication} options
 * @typedef {object} TrackPublicationOptions
 * @property {LogLevel|LogLevels} logLevel - Log level for 'media' modules
 */
module.exports = TrackPublication;
//# sourceMappingURL=trackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/transceiver.js":
/*!******************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/transceiver.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackTransceiver = __webpack_require__(/*! ../../transceiver */ "./node_modules/twilio-video/es5/transceiver.js");
/**
 * A {@link MediaTrackTransceiver} represents either one or more local
 * RTCRtpSenders, or a single RTCRtpReceiver.
 * @extends TrackTransceiver
 * @property {MediaStreamTrack} track
 */
var MediaTrackTransceiver = /** @class */ (function (_super) {
    __extends(MediaTrackTransceiver, _super);
    /**
     * Construct a {@link MediaTrackTransceiver}.
     * @param {Track.ID} id - The MediaStreamTrack ID signaled through RSP/SDP
     * @param {?string} mid - The MID associated with the MediaStreamTrack
     * @param {MediaStreamTrack} mediaStreamTrack
     */
    function MediaTrackTransceiver(id, mid, mediaStreamTrack) {
        var _this = _super.call(this, id, mediaStreamTrack.kind) || this;
        Object.defineProperties(_this, {
            _track: {
                value: mediaStreamTrack,
                writable: true
            },
            enabled: {
                enumerable: true,
                get: function () {
                    return this._track.enabled;
                }
            },
            mid: {
                enumerable: true,
                value: mid
            },
            readyState: {
                enumerable: true,
                get: function () {
                    return this._track.readyState;
                }
            },
            track: {
                enumerable: true,
                get: function () {
                    return this._track;
                }
            }
        });
        return _this;
    }
    MediaTrackTransceiver.prototype.stop = function () {
        this.track.stop();
        _super.prototype.stop.call(this);
    };
    return MediaTrackTransceiver;
}(TrackTransceiver));
module.exports = MediaTrackTransceiver;
//# sourceMappingURL=transceiver.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/videoprocessoreventobserver.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/videoprocessoreventobserver.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var DEFAULT_VIDEO_PROCESSOR_STATS_INTERVAL_MS = __webpack_require__(/*! ../../util/constants */ "./node_modules/twilio-video/es5/util/constants.js").DEFAULT_VIDEO_PROCESSOR_STATS_INTERVAL_MS;
/**
 * VideoProcessorEventObserver listens to {@link VideoProcessor} related events
 * and re-emits them as a generic event with some additional information.
 * @extends EventEmitter
 * @emits VideoProcessorEventObserver#event
 */
var VideoProcessorEventObserver = /** @class */ (function (_super) {
    __extends(VideoProcessorEventObserver, _super);
    /**
     * Constructor.
     * @param {Log} log
     */
    function VideoProcessorEventObserver(log) {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _lastStatsSaveTime: {
                value: null,
                writable: true
            },
            _lastStatsPublishTime: {
                value: null,
                writable: true
            },
            _log: {
                value: log
            },
            _processorInfo: {
                value: null,
                writable: true
            },
            _stats: {
                value: null,
                writable: true
            }
        });
        _this.on('add', function (info) {
            _this._lastStatsSaveTime = Date.now();
            _this._lastStatsPublishTime = Date.now();
            _this._processorInfo = info;
            _this._stats = [];
            _this._reemitEvent('add', _this._getEventData());
        });
        _this.on('remove', function () {
            var data = _this._getEventData();
            _this._lastStatsSaveTime = null;
            _this._lastStatsPublishTime = null;
            _this._processorInfo = null;
            _this._stats = null;
            _this._reemitEvent('remove', data);
        });
        _this.on('start', function () {
            _this._reemitEvent('start', _this._getEventData());
        });
        _this.on('stop', function (message) {
            _this._reemitEvent('stop', Object.assign({ message: message }, _this._getEventData()));
        });
        _this.on('stats', function () { return _this._maybeEmitStats(); });
        return _this;
    }
    /**
     * @private
     */
    VideoProcessorEventObserver.prototype._getEventData = function () {
        if (!this._processorInfo) {
            return {};
        }
        var _a = this._processorInfo, processor = _a.processor, captureHeight = _a.captureHeight, captureWidth = _a.captureWidth, inputFrameRate = _a.inputFrameRate, isRemoteVideoTrack = _a.isRemoteVideoTrack;
        var data = { captureHeight: captureHeight, captureWidth: captureWidth, inputFrameRate: inputFrameRate, isRemoteVideoTrack: isRemoteVideoTrack };
        data.name = processor._name || 'VideoProcessor';
        ['assetsPath', 'blurFilterRadius', 'fitType', 'isSimdEnabled', 'maskBlurRadius', 'version'].forEach(function (prop) {
            var val = processor["_" + prop];
            if (typeof val !== 'undefined') {
                data[prop] = val;
            }
        });
        Object.keys(data).forEach(function (prop) {
            var val = data[prop];
            if (typeof val === 'boolean') {
                data[prop] = val ? 'true' : 'false';
            }
        });
        return data;
    };
    /**
     * Save stats every second. If a specific time interval has elapsed,
     * the stats event will be emitted
     * @private
     */
    VideoProcessorEventObserver.prototype._maybeEmitStats = function () {
        if (!this._stats || !this._processorInfo) {
            return;
        }
        var benchmark = this._processorInfo.processor._benchmark;
        if (!benchmark) {
            return;
        }
        var now = Date.now();
        if (now - this._lastStatsSaveTime < 1000) {
            return;
        }
        var entry = { outputFrameRate: benchmark.getRate('totalProcessingDelay') };
        ['captureFrameDelay', 'imageCompositionDelay', 'inputImageResizeDelay', 'processFrameDelay', 'segmentationDelay'].forEach(function (name) {
            entry[name] = benchmark.getAverageDelay(name);
        });
        this._lastStatsSaveTime = now;
        this._stats.push(entry);
        if (now - this._lastStatsPublishTime < DEFAULT_VIDEO_PROCESSOR_STATS_INTERVAL_MS) {
            return;
        }
        this._lastStatsPublishTime = now;
        var stats = this._stats.splice(0);
        var averages = stats.reduce(function (averages, current, n) {
            Object.keys(entry).forEach(function (name) {
                if (!averages[name]) {
                    averages[name] = 0;
                }
                averages[name] = ((averages[name] * n) + current[name]) / (n + 1);
            });
            return averages;
        }, {});
        Object.keys(averages).forEach(function (name) {
            averages[name] = parseFloat(averages[name].toFixed(2));
        });
        this._reemitEvent('stats', Object.assign({}, averages, this._getEventData()));
    };
    /**
     * @private
     */
    VideoProcessorEventObserver.prototype._reemitEvent = function (name, data) {
        this._log.debug("VideoProcessor:" + name, data);
        this.emit('event', { name: name, data: data });
    };
    return VideoProcessorEventObserver;
}(EventEmitter));
module.exports = VideoProcessorEventObserver;
//# sourceMappingURL=videoprocessoreventobserver.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/media/track/videotrack.js":
/*!*****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/media/track/videotrack.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaTrack = __webpack_require__(/*! ./mediatrack */ "./node_modules/twilio-video/es5/media/track/mediatrack.js");
var VideoProcessorEventObserver = __webpack_require__(/*! ./videoprocessoreventobserver */ "./node_modules/twilio-video/es5/media/track/videoprocessoreventobserver.js");
var DEFAULT_FRAME_RATE = __webpack_require__(/*! ../../util/constants */ "./node_modules/twilio-video/es5/util/constants.js").DEFAULT_FRAME_RATE;
/**
 * A {@link VideoTrack} is a {@link Track} representing video.
 * @extends Track
 * @property {boolean} isStarted - Whether or not the {@link VideoTrack} has
 *   started; if the {@link VideoTrack} started, there is enough video data to
 *   begin playback
 * @property {boolean} isEnabled - Whether or not the {@link VideoTrack} is
 *   enabled; if the {@link VideoTrack} is not enabled, it is "paused"
 * @property {VideoTrack.Dimensions} dimensions - The {@link VideoTrack}'s
 *   {@link VideoTrack.Dimensions}
 * @property {Track.Kind} kind - "video"
 * @property {?MediaStreamTrack} mediaStreamTrack - Provides access to the underlying
 *   MediaStreamTrack; It is set to <code>null</code> if it is a {@link RemoteVideoTrack}
 *   that is switched off
 * @property {?MediaStreamTrack} processedTrack - The source of processed video frames.
 * It is null if no VideoProcessor has been added.
 * @property {?VideoProcessor} processor - A {@link VideoProcessor} that is currently
 *   processing video frames. It is null if video frames are not being processed.
 * @emits VideoTrack#dimensionsChanged
 * @emits VideoTrack#disabled
 * @emits VideoTrack#enabled
 * @emits VideoTrack#started
 */
var VideoTrack = /** @class */ (function (_super) {
    __extends(VideoTrack, _super);
    /**
     * Construct a {@link VideoTrack}.
     * @param {?MediaTrackTransceiver} mediaTrackTransceiver
     * @param {{log: Log, name: string}} options
     */
    function VideoTrack(mediaTrackTransceiver, options) {
        var _this = this;
        options = Object.assign({
            VideoProcessorEventObserver: VideoProcessorEventObserver
        }, options);
        _this = _super.call(this, 'video', mediaTrackTransceiver, options) || this;
        Object.defineProperties(_this, {
            _captureTimeoutId: {
                value: null,
                writable: true
            },
            _isCapturing: {
                value: false,
                writable: true
            },
            _inputFrame: {
                value: null,
                writable: true
            },
            _outputFrame: {
                value: null,
                writable: true
            },
            _processorEventObserver: {
                value: new options.VideoProcessorEventObserver(_this._log),
                writable: true,
            },
            _unmuteHandler: {
                value: null,
                writable: true
            },
            dimensions: {
                enumerable: true,
                value: {
                    width: null,
                    height: null
                }
            },
            processor: {
                enumerable: true,
                value: null,
                writable: true
            }
        });
        return _this;
    }
    /**
     * @private
     */
    VideoTrack.prototype._checkIfCanCaptureFrames = function (isPublishing) {
        if (isPublishing === void 0) { isPublishing = false; }
        var canCaptureFrames = true;
        var message = '';
        if (!this.mediaStreamTrack) {
            canCaptureFrames = false;
            message = 'MediaStreamTrack is null';
        }
        else if (!this.mediaStreamTrack.enabled) {
            canCaptureFrames = false;
            message = 'MediaStreamTrack is disabled';
        }
        else if (this.mediaStreamTrack.readyState === 'ended') {
            canCaptureFrames = false;
            message = 'MediaStreamTrack is ended';
        }
        else if (!this.processor) {
            canCaptureFrames = false;
            message = 'VideoProcessor not detected.';
        }
        else if (!this._attachments.size && !isPublishing) {
            canCaptureFrames = false;
            message = 'VideoTrack is not publishing and there is no attached element.';
        }
        if (message) {
            this._log.debug(message);
        }
        return { canCaptureFrames: canCaptureFrames, message: message };
    };
    /**
     * @private
     */
    VideoTrack.prototype._captureFrames = function () {
        var _this = this;
        if (this._isCapturing) {
            this._log.debug('Ignoring captureFrames call. Capture is already in progress');
            return;
        }
        if (!this._checkIfCanCaptureFrames().canCaptureFrames) {
            this._isCapturing = false;
            this._log.debug('Cannot capture frames. Ignoring captureFrames call.');
            return;
        }
        this._isCapturing = true;
        this._processorEventObserver.emit('start');
        this._log.debug('Start capturing frames');
        var startTime = Date.now();
        var processFramePeriodMs;
        this._dummyEl.play().then(function () {
            var captureFrame = function (cb) {
                clearTimeout(_this._captureTimeoutId);
                var _a = (_this.mediaStreamTrack
                    ? _this.mediaStreamTrack.getSettings()
                    : {}).frameRate, frameRate = _a === void 0 ? DEFAULT_FRAME_RATE : _a;
                var capturePeriodMs = Math.floor(1000 / frameRate);
                var delay = capturePeriodMs - processFramePeriodMs;
                if (delay < 0 || typeof processFramePeriodMs !== 'number') {
                    delay = 0;
                }
                _this._captureTimeoutId = setTimeout(cb, delay);
            };
            var process = function () {
                var checkResult = _this._checkIfCanCaptureFrames();
                if (!checkResult.canCaptureFrames) {
                    _this._isCapturing = false;
                    _this._processorEventObserver.emit('stop', checkResult.message);
                    _this._log.debug('Cannot capture frames. Stopping capturing frames.');
                    return;
                }
                startTime = Date.now();
                var _a = _this.mediaStreamTrack.getSettings(), _b = _a.width, width = _b === void 0 ? 0 : _b, _c = _a.height, height = _c === void 0 ? 0 : _c;
                // Setting the canvas' dimension triggers a redraw.
                // Only set it if it has changed.
                if (_this._inputFrame.width !== width) {
                    _this._inputFrame.width = width;
                    _this._inputFrame.height = height;
                    if (_this._outputFrame) {
                        _this._outputFrame.width = width;
                        _this._outputFrame.height = height;
                    }
                }
                _this._inputFrame.getContext('2d').drawImage(_this._dummyEl, 0, 0, width, height);
                var result = null;
                try {
                    result = _this.processor.processFrame(_this._inputFrame, _this._outputFrame);
                }
                catch (ex) {
                    _this._log.debug('Exception detected after calling processFrame.', ex);
                }
                ((result instanceof Promise) ? result : Promise.resolve(result))
                    .then(function () {
                    if (_this._outputFrame) {
                        _this.processedTrack.requestFrame();
                        _this._processorEventObserver.emit('stats');
                    }
                })
                    .finally(function () {
                    processFramePeriodMs = Date.now() - startTime;
                    captureFrame(process);
                });
            };
            captureFrame(process);
        }).catch(function (error) { return _this._log.error('Video element cannot be played', { error: error, track: _this }); });
    };
    /**
     * @private
     */
    VideoTrack.prototype._initialize = function () {
        var _this = this;
        _super.prototype._initialize.call(this);
        if (this._dummyEl) {
            this._dummyEl.onloadedmetadata = function () {
                if (dimensionsChanged(_this, _this._dummyEl)) {
                    _this.dimensions.width = _this._dummyEl.videoWidth;
                    _this.dimensions.height = _this._dummyEl.videoHeight;
                }
            };
            this._dummyEl.onresize = function () {
                if (dimensionsChanged(_this, _this._dummyEl)) {
                    _this.dimensions.width = _this._dummyEl.videoWidth;
                    _this.dimensions.height = _this._dummyEl.videoHeight;
                    if (_this.isStarted) {
                        _this._log.debug('Dimensions changed:', _this.dimensions);
                        _this.emit(VideoTrack.DIMENSIONS_CHANGED, _this);
                    }
                }
            };
        }
    };
    /**
     * @private
     */
    VideoTrack.prototype._restartProcessor = function () {
        var processor = this.processor;
        if (processor) {
            this.removeProcessor(processor);
            this.addProcessor(processor);
        }
    };
    /**
     * @private
     */
    VideoTrack.prototype._start = function (dummyEl) {
        this.dimensions.width = dummyEl.videoWidth;
        this.dimensions.height = dummyEl.videoHeight;
        this._log.debug('Dimensions:', this.dimensions);
        return _super.prototype._start.call(this, dummyEl);
    };
    /**
     * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.
     * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.
     * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.
     * @returns {this}
     * @example
     * class GrayScaleProcessor {
     *   constructor(percentage) {
     *     this.percentage = percentage;
     *   }
     *   processFrame(inputFrameBuffer, outputFrameBuffer) {
     *     const context = outputFrameBuffer.getContext('2d');
     *     context.filter = `grayscale(${this.percentage}%)`;
     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
     *   }
     * }
     *
     * Video.createLocalVideoTrack().then(function(videoTrack) {
     *   videoTrack.addProcessor(new GrayScaleProcessor(100));
     * });
     */
    VideoTrack.prototype.addProcessor = function (processor) {
        var _this = this;
        if (typeof OffscreenCanvas !== 'function') {
            return this._log.warn('Adding a VideoProcessor is not supported in this browser.');
        }
        if (!processor || typeof processor.processFrame !== 'function') {
            throw new Error('Received an invalid VideoProcessor from addProcessor.');
        }
        if (this.processor) {
            throw new Error('A VideoProcessor has already been added.');
        }
        if (!this._dummyEl) {
            throw new Error('VideoTrack has not been initialized.');
        }
        this._log.debug('Adding VideoProcessor to the VideoTrack', processor);
        if (!this._unmuteHandler) {
            this._unmuteHandler = function () {
                _this._log.debug('mediaStreamTrack unmuted');
                // NOTE(csantos): On certain scenarios where mediaStreamTrack is coming from muted to unmuted state,
                // the processedTrack doesn't unmutes automatically although enabled is already set to true.
                // This is a terminal state for the processedTrack and should be restarted. (VIDEO-4176)
                if (_this.processedTrack.muted) {
                    _this._log.debug('mediaStreamTrack is unmuted but processedTrack is muted. Restarting processor.');
                    _this._restartProcessor();
                }
            };
            if (this.mediaStreamTrack) {
                this.mediaStreamTrack.addEventListener('unmute', this._unmuteHandler);
            }
        }
        var _a = this.mediaStreamTrack
            ? this.mediaStreamTrack.getSettings()
            : {}, _b = _a.width, width = _b === void 0 ? 0 : _b, _c = _a.height, height = _c === void 0 ? 0 : _c, _d = _a.frameRate, frameRate = _d === void 0 ? DEFAULT_FRAME_RATE : _d;
        this._inputFrame = new OffscreenCanvas(width, height);
        this._outputFrame = document.createElement('canvas');
        this._outputFrame.width = width;
        this._outputFrame.height = height;
        this.processedTrack = this._outputFrame.captureStream(0).getTracks()[0];
        this.processedTrack.enabled = this.mediaStreamTrack.enabled;
        this.processor = processor;
        this._processorEventObserver.emit('add', {
            processor: processor,
            captureHeight: height,
            captureWidth: width,
            inputFrameRate: frameRate,
            isRemoteVideoTrack: this.toString().includes('RemoteVideoTrack')
        });
        this._updateElementsMediaStreamTrack();
        this._captureFrames();
        return this;
    };
    /**
     * Create an HTMLVideoElement and attach the {@link VideoTrack} to it.
     *
     * The HTMLVideoElement's <code>srcObject</code> will be set to a new
     * MediaStream containing the {@link VideoTrack}'s MediaStreamTrack.
     *
     * @returns {HTMLVideoElement} videoElement
     * @example
     * const Video = require('twilio-video');
     *
     * Video.createLocalVideoTrack().then(function(videoTrack) {
     *   const videoElement = videoTrack.attach();
     *   document.body.appendChild(videoElement);
     * });
    */ /**
     * Attach the {@link VideoTrack} to an existing HTMLMediaElement. The
     * HTMLMediaElement could be an HTMLAudioElement or an HTMLVideoElement.
     *
     * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,
     * this method sets it to a new MediaStream containing the {@link VideoTrack}'s
     * MediaStreamTrack; otherwise, it adds the {@link MediaTrack}'s
     * MediaStreamTrack to the existing MediaStream. Finally, if there are any other
     * MediaStreamTracks of the same kind on the MediaStream, this method removes
     * them.
     *
     * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement to attach to
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * const Video = require('twilio-video');
     *
     * const videoElement = document.createElement('video');
     * document.body.appendChild(videoElement);
     *
     * Video.createLocalVideoTrack().then(function(videoTrack) {
     *   videoTrack.attach(videoElement);
     * });
    */ /**
     * Attach the {@link VideoTrack} to an HTMLMediaElement selected by
     * <code>document.querySelector</code>. The HTMLMediaElement could be an
     * HTMLAudioElement or an HTMLVideoElement.
     *
     * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,
     * this method sets it to a new MediaStream containing the {@link VideoTrack}'s
     * MediaStreamTrack; otherwise, it adds the {@link VideoTrack}'s
     * MediaStreamTrack to the existing MediaStream. Finally, if there are any other
     * MediaStreamTracks of the same kind on the MediaStream, this method removes
     * them.
     *
     * @param {string} selector - A query selector for the HTMLMediaElement to
     *   attach to
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * const Video = require('twilio-video');
     *
     * const videoElement = document.createElement('video');
     * videoElement.id = 'my-video-element';
     * document.body.appendChild(videoElement);
     *
     * Video.createLocalVideoTrack().then(function(track) {
     *   track.attach('#my-video-element');
     * });
     */
    VideoTrack.prototype.attach = function () {
        var result = _super.prototype.attach.apply(this, arguments);
        if (this.processor) {
            this._captureFrames();
        }
        return result;
    };
    /**
     * Detach the {@link VideoTrack} from all previously attached HTMLMediaElements.
     * @returns {Array<HTMLMediaElement>} mediaElements
     * @example
     * const mediaElements = videoTrack.detach();
     * mediaElements.forEach(mediaElement => mediaElement.remove());
    */ /**
     * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement.
     * @param {HTMLMediaElement} mediaElement - One of the HTMLMediaElements to
     *   which the {@link VideoTrack} is attached
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * const videoElement = document.getElementById('my-video-element');
     * videoTrack.detach(videoElement).remove();
    */ /**
     * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement
     *   specified by <code>document.querySelector</code>.
     * @param {string} selector - The query selector of HTMLMediaElement to which
     *    the {@link VideoTrack} is attached
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * videoTrack.detach('#my-video-element').remove();
     */
    VideoTrack.prototype.detach = function () {
        return _super.prototype.detach.apply(this, arguments);
    };
    /**
     * Remove the previously added {@link VideoProcessor} using `addProcessor` API.
     * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.
     * @returns {this}
     * @example
     * class GrayScaleProcessor {
     *   constructor(percentage) {
     *     this.percentage = percentage;
     *   }
     *   processFrame(inputFrameBuffer, outputFrameBuffer) {
     *     const context = outputFrameBuffer.getContext('2d');
     *     context.filter = `grayscale(${this.percentage}%)`;
     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
     *   }
     * }
     *
     * Video.createLocalVideoTrack().then(function(videoTrack) {
     *   const grayScaleProcessor = new GrayScaleProcessor(100);
     *   videoTrack.addProcessor(grayScaleProcessor);
     *   document.getElementById('remove-button').onclick = () => videoTrack.removeProcessor(grayScaleProcessor);
     * });
     */
    VideoTrack.prototype.removeProcessor = function (processor) {
        if (!processor) {
            throw new Error('Received an invalid VideoProcessor from removeProcessor.');
        }
        if (!this.processor) {
            throw new Error('No existing VideoProcessor detected.');
        }
        if (processor !== this.processor) {
            throw new Error('The provided VideoProcessor is different than the existing one.');
        }
        this._processorEventObserver.emit('remove');
        this._log.debug('Removing VideoProcessor from the VideoTrack', processor);
        clearTimeout(this._captureTimeoutId);
        if (this.mediaStreamTrack) {
            this.mediaStreamTrack.removeEventListener('unmute', this._unmuteHandler);
        }
        this._unmuteHandler = null;
        this._isCapturing = false;
        this.processor = null;
        this.processedTrack = null;
        this._inputFrame.getContext('2d').clearRect(0, 0, this._inputFrame.width, this._inputFrame.height);
        this._outputFrame.getContext('2d').clearRect(0, 0, this._outputFrame.width, this._outputFrame.height);
        this._inputFrame = null;
        this._outputFrame = null;
        this._updateElementsMediaStreamTrack();
        return this;
    };
    return VideoTrack;
}(MediaTrack));
VideoTrack.DIMENSIONS_CHANGED = 'dimensionsChanged';
function dimensionsChanged(track, elem) {
    return track.dimensions.width !== elem.videoWidth
        || track.dimensions.height !== elem.videoHeight;
}
/**
 * A {@link VideoTrack}'s width and height.
 * @typedef {object} VideoTrack.Dimensions
 * @property {?number} width - The {@link VideoTrack}'s width or null if the
 *   {@link VideoTrack} has not yet started
 * @property {?number} height - The {@link VideoTrack}'s height or null if the
 *   {@link VideoTrack} has not yet started
 */
/**
 * A {@link VideoProcessor}, when added via {@link VideoTrack#addProcessor},
 * is used to process incoming video frames before
 * sending to the encoder or renderer.
 * @typedef {object} VideoProcessor
 * @property {function} processFrame - A callback to receive input and output frame buffers for processing.
 * The input frame buffer contains the original video frame which can be used for additional processing
 * such as applying filters to it. The output frame buffer is used to receive the processed video frame
 * before sending to the encoder or renderer.
 *
 * Any exception raised (either synchronously or asynchronously) in `processFrame` will result in the frame being dropped.
 * This callback has the following signature:<br/><br/>
 * <code>processFrame(</code><br/>
 * &nbsp;&nbsp;<code>inputFrameBuffer: OffscreenCanvas,</code><br/>
 * &nbsp;&nbsp;<code>outputFrameBuffer: HTMLCanvasElement</code><br/>
 * <code>): Promise&lt;void&gt; | void;</code>
 *
 * @example
 * class GrayScaleProcessor {
 *   constructor(percentage) {
 *     this.percentage = percentage;
 *   }
 *   processFrame(inputFrameBuffer, outputFrameBuffer) {
 *     const context = outputFrameBuffer.getContext('2d');
 *     context.filter = `grayscale(${this.percentage}%)`;
 *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
 *   }
 * }
 */
/**
 * The {@link VideoTrack}'s dimensions changed.
 * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed
 * @event VideoTrack#dimensionsChanged
 */
/**
 * The {@link VideoTrack} was disabled, i.e. "paused".
 * @param {VideoTrack} track - The {@link VideoTrack} that was disabled
 * @event VideoTrack#disabled
 */
/**
 * The {@link VideoTrack} was enabled, i.e. "unpaused".
 * @param {VideoTrack} track - The {@link VideoTrack} that was enabled
 * @event VideoTrack#enabled
 */
/**
 * The {@link VideoTrack} started. This means there is enough video data to
 * begin playback.
 * @param {VideoTrack} track - The {@link VideoTrack} that started
 * @event VideoTrack#started
 */
module.exports = VideoTrack;
//# sourceMappingURL=videotrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/networkqualityconfiguration.js":
/*!**********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/networkqualityconfiguration.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var _a = __webpack_require__(/*! ./util/constants */ "./node_modules/twilio-video/es5/util/constants.js"), DEFAULT_NQ_LEVEL_LOCAL = _a.DEFAULT_NQ_LEVEL_LOCAL, DEFAULT_NQ_LEVEL_REMOTE = _a.DEFAULT_NQ_LEVEL_REMOTE, MAX_NQ_LEVEL = _a.MAX_NQ_LEVEL;
var inRange = __webpack_require__(/*! ./util */ "./node_modules/twilio-video/es5/util/index.js").inRange;
/**
 * {@link NetworkQualityConfigurationImpl} represents an object which notifies its
 * listeners of any changes in the values of its properties.
 * @extends EventEmitter
 * @implements NetworkQualityConfiguration
 * @property {?NetworkQualityVerbosity} local - Verbosity level for {@link LocalParticipant}
 * @property {?NetworkQualityVerbosity} remote - Verbosity level for {@link RemoteParticipant}s
 */
var NetworkQualityConfigurationImpl = /** @class */ (function (_super) {
    __extends(NetworkQualityConfigurationImpl, _super);
    /**
     * Construct an {@link NetworkQualityConfigurationImpl}.
     * @param {NetworkQualityConfiguration} networkQualityConfiguration - Initial {@link NetworkQualityConfiguration}
     */
    function NetworkQualityConfigurationImpl(networkQualityConfiguration) {
        var _this = _super.call(this) || this;
        networkQualityConfiguration = Object.assign({
            local: DEFAULT_NQ_LEVEL_LOCAL,
            remote: DEFAULT_NQ_LEVEL_REMOTE
        }, networkQualityConfiguration);
        Object.defineProperties(_this, {
            local: {
                value: inRange(networkQualityConfiguration.local, DEFAULT_NQ_LEVEL_LOCAL, MAX_NQ_LEVEL)
                    ? networkQualityConfiguration.local
                    : DEFAULT_NQ_LEVEL_LOCAL,
                writable: true
            },
            remote: {
                value: inRange(networkQualityConfiguration.remote, DEFAULT_NQ_LEVEL_REMOTE, MAX_NQ_LEVEL)
                    ? networkQualityConfiguration.remote
                    : DEFAULT_NQ_LEVEL_REMOTE,
                writable: true
            }
        });
        return _this;
    }
    /**
     * Update the verbosity levels for network quality information for
     * {@link LocalParticipant} and {@link RemoteParticipant} with those
     * in the given {@link NetworkQualityConfiguration}.
     * @param {NetworkQualityConfiguration} networkQualityConfiguration - The new {@link NetworkQualityConfiguration}
     */
    NetworkQualityConfigurationImpl.prototype.update = function (networkQualityConfiguration) {
        var _this = this;
        networkQualityConfiguration = Object.assign({
            local: this.local,
            remote: this.remote
        }, networkQualityConfiguration);
        [
            ['local', DEFAULT_NQ_LEVEL_LOCAL, 3],
            ['remote', DEFAULT_NQ_LEVEL_REMOTE, 3]
        ].forEach(function (_a) {
            var _b = __read(_a, 3), localOrRemote = _b[0], min = _b[1], max = _b[2];
            _this[localOrRemote] = typeof networkQualityConfiguration[localOrRemote] === 'number'
                && inRange(networkQualityConfiguration[localOrRemote], min, max)
                ? networkQualityConfiguration[localOrRemote]
                : min;
        });
    };
    return NetworkQualityConfigurationImpl;
}(EventEmitter));
module.exports = NetworkQualityConfigurationImpl;
//# sourceMappingURL=networkqualityconfiguration.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/participant.js":
/*!******************************************************!*\
  !*** ./node_modules/twilio-video/es5/participant.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var EventEmitter = __webpack_require__(/*! ./eventemitter */ "./node_modules/twilio-video/es5/eventemitter.js");
var RemoteAudioTrack = __webpack_require__(/*! ./media/track/remoteaudiotrack */ "./node_modules/twilio-video/es5/media/track/remoteaudiotrack.js");
var RemoteAudioTrackPublication = __webpack_require__(/*! ./media/track/remoteaudiotrackpublication */ "./node_modules/twilio-video/es5/media/track/remoteaudiotrackpublication.js");
var RemoteDataTrack = __webpack_require__(/*! ./media/track/remotedatatrack */ "./node_modules/twilio-video/es5/media/track/remotedatatrack.js");
var RemoteDataTrackPublication = __webpack_require__(/*! ./media/track/remotedatatrackpublication */ "./node_modules/twilio-video/es5/media/track/remotedatatrackpublication.js");
var RemoteVideoTrack = __webpack_require__(/*! ./media/track/remotevideotrack */ "./node_modules/twilio-video/es5/media/track/remotevideotrack.js");
var RemoteVideoTrackPublication = __webpack_require__(/*! ./media/track/remotevideotrackpublication */ "./node_modules/twilio-video/es5/media/track/remotevideotrackpublication.js");
var _a = __webpack_require__(/*! ./util */ "./node_modules/twilio-video/es5/util/index.js"), reemitTrackPublicationEvents = _a.reemitTrackPublicationEvents, trackClass = _a.trackClass, trackPublicationClass = _a.trackPublicationClass, valueToJSON = _a.valueToJSON;
var nInstances = 0;
/**
 * {@link NetworkQualityLevel} is a value from 0–5, inclusive, representing the
 * quality of a network connection.
 * @typedef {number} NetworkQualityLevel
 */
/**
 * @extends EventEmitter
 * @property {Map<Track.SID, AudioTrackPublication>} audioTracks -
 *    The {@link Participant}'s {@link AudioTrackPublication}s
 * @property {Map<Track.SID, DataTrackPublication>} dataTracks -
 *    The {@link Participant}'s {@link DataTrackPublication}s.
 * @property {Participant.Identity} identity - The identity of the {@link Participant}
 * @property {?NetworkQualityLevel} networkQualityLevel - The
 *    {@link Participant}'s current {@link NetworkQualityLevel}, if any
 * @property {?NetworkQualityStats} networkQualityStats - The
 *    {@link Participant}'s current {@link NetworkQualityStats}, if any
 * @property {Participant.SID} sid - The {@link Participant}'s SID
 * @property {string} state - "connected", "disconnected" or "reconnecting"
 * @property {Map<Track.SID, TrackPublication>} tracks -
 *    The {@link Participant}'s {@link TrackPublication}s
 * @property {Map<Track.SID, VideoTrackPublication>} videoTracks -
 *    The {@link Participant}'s {@link VideoTrackPublication}s
 * @emits Participant#disconnected
 * @emits Participant#networkQualityLevelChanged
 * @emits Participant#reconnected
 * @emits Participant#reconnecting
 * @emits Participant#trackDimensionsChanged
 * @emits Participant#trackStarted
 */
var Participant = /** @class */ (function (_super) {
    __extends(Participant, _super);
    /**
     * Construct a {@link Participant}.
     * @param {ParticipantSignaling} signaling
     * @param {object} [options]
     */
    function Participant(signaling, options) {
        var _this = _super.call(this) || this;
        options = Object.assign({
            RemoteAudioTrack: RemoteAudioTrack,
            RemoteAudioTrackPublication: RemoteAudioTrackPublication,
            RemoteDataTrack: RemoteDataTrack,
            RemoteDataTrackPublication: RemoteDataTrackPublication,
            RemoteVideoTrack: RemoteVideoTrack,
            RemoteVideoTrackPublication: RemoteVideoTrackPublication,
            tracks: []
        }, options);
        var indexed = indexTracksById(options.tracks);
        var log = options.log.createLog('default', _this);
        var audioTracks = new Map(indexed.audioTracks);
        var dataTracks = new Map(indexed.dataTracks);
        var tracks = new Map(indexed.tracks);
        var videoTracks = new Map(indexed.videoTracks);
        Object.defineProperties(_this, {
            _RemoteAudioTrack: {
                value: options.RemoteAudioTrack
            },
            _RemoteAudioTrackPublication: {
                value: options.RemoteAudioTrackPublication
            },
            _RemoteDataTrack: {
                value: options.RemoteDataTrack
            },
            _RemoteDataTrackPublication: {
                value: options.RemoteDataTrackPublication
            },
            _RemoteVideoTrack: {
                value: options.RemoteVideoTrack
            },
            _RemoteVideoTrackPublication: {
                value: options.RemoteVideoTrackPublication
            },
            _audioTracks: {
                value: audioTracks
            },
            _dataTracks: {
                value: dataTracks
            },
            _instanceId: {
                value: ++nInstances
            },
            _clientTrackSwitchOffControl: {
                value: options.clientTrackSwitchOffControl,
            },
            _contentPreferencesMode: {
                value: options.contentPreferencesMode,
            },
            _log: {
                value: log
            },
            _signaling: {
                value: signaling
            },
            _tracks: {
                value: tracks
            },
            _trackEventReemitters: {
                value: new Map()
            },
            _trackPublicationEventReemitters: {
                value: new Map()
            },
            _trackSignalingUpdatedEventCallbacks: {
                value: new Map()
            },
            _videoTracks: {
                value: videoTracks
            },
            audioTracks: {
                enumerable: true,
                value: new Map()
            },
            dataTracks: {
                enumerable: true,
                value: new Map()
            },
            identity: {
                enumerable: true,
                get: function () {
                    return signaling.identity;
                }
            },
            networkQualityLevel: {
                enumerable: true,
                get: function () {
                    return signaling.networkQualityLevel;
                }
            },
            networkQualityStats: {
                enumerable: true,
                get: function () {
                    return signaling.networkQualityStats;
                }
            },
            sid: {
                enumerable: true,
                get: function () {
                    return signaling.sid;
                }
            },
            state: {
                enumerable: true,
                get: function () {
                    return signaling.state;
                }
            },
            tracks: {
                enumerable: true,
                value: new Map()
            },
            videoTracks: {
                enumerable: true,
                value: new Map()
            }
        });
        _this._tracks.forEach(reemitTrackEvents.bind(null, _this));
        signaling.on('networkQualityLevelChanged', function () {
            return _this.emit('networkQualityLevelChanged', _this.networkQualityLevel, _this.networkQualityStats &&
                (_this.networkQualityStats.audio || _this.networkQualityStats.video)
                ? _this.networkQualityStats
                : null);
        });
        reemitSignalingStateChangedEvents(_this, signaling);
        log.info("Created a new Participant" + (_this.identity ? ": " + _this.identity : ''));
        return _this;
    }
    /**
     * Get the {@link RemoteTrack} events to re-emit.
     * @private
     * @returns {Array<Array<string>>} events
     */
    Participant.prototype._getTrackEvents = function () {
        return [
            ['dimensionsChanged', 'trackDimensionsChanged'],
            ['message', 'trackMessage'],
            ['started', 'trackStarted']
        ];
    };
    /**
     * @private
     */
    Participant.prototype._getTrackPublicationEvents = function () {
        return [];
    };
    Participant.prototype.toString = function () {
        return "[Participant #" + this._instanceId + ": " + this.sid + "]";
    };
    /**
     * @private
     * @param {Track} track
     * @param {key} key
     * @returns {?Track}
     */
    Participant.prototype._addTrack = function (track, key) {
        var log = this._log;
        if (this._tracks.has(key)) {
            return null;
        }
        this._tracks.set(key, track);
        var tracksByKind = {
            audio: this._audioTracks,
            video: this._videoTracks,
            data: this._dataTracks
        }[track.kind];
        tracksByKind.set(key, track);
        reemitTrackEvents(this, track, key);
        log.info("Added a new " + trackClass(track) + ":", key);
        log.debug(trackClass(track) + ":", track);
        return track;
    };
    /**
     * @private
     * @param {TrackPublication} publication
     * @returns {?TrackPublication}
     */
    Participant.prototype._addTrackPublication = function (publication) {
        var log = this._log;
        if (this.tracks.has(publication.trackSid)) {
            return null;
        }
        this.tracks.set(publication.trackSid, publication);
        var trackPublicationsByKind = {
            audio: this.audioTracks,
            data: this.dataTracks,
            video: this.videoTracks
        }[publication.kind];
        trackPublicationsByKind.set(publication.trackSid, publication);
        log.info("Added a new " + trackPublicationClass(publication) + ":", publication.trackSid);
        log.debug(trackPublicationClass(publication) + ":", publication);
        return publication;
    };
    /**
     * @private
     */
    Participant.prototype._handleTrackSignalingEvents = function () {
        var _a = this, log = _a._log, clientTrackSwitchOffControl = _a._clientTrackSwitchOffControl, contentPreferencesMode = _a._contentPreferencesMode;
        var self = this;
        if (this.state === 'disconnected') {
            return;
        }
        var RemoteAudioTrack = this._RemoteAudioTrack;
        var RemoteAudioTrackPublication = this._RemoteAudioTrackPublication;
        var RemoteVideoTrack = this._RemoteVideoTrack;
        var RemoteVideoTrackPublication = this._RemoteVideoTrackPublication;
        var RemoteDataTrack = this._RemoteDataTrack;
        var RemoteDataTrackPublication = this._RemoteDataTrackPublication;
        var participantSignaling = this._signaling;
        function trackSignalingAdded(signaling) {
            var reemitEventsToRemoteParticipant = function (publication) {
                reemitTrackPublicationEvents(self, publication);
            };
            var RemoteTrackPublication = {
                audio: RemoteAudioTrackPublication,
                data: RemoteDataTrackPublication,
                video: RemoteVideoTrackPublication
            }[signaling.kind];
            var publication = new RemoteTrackPublication(signaling, { log: log, reemitEventsToRemoteParticipant: reemitEventsToRemoteParticipant });
            self._addTrackPublication(publication);
            var isSubscribed = signaling.isSubscribed;
            if (isSubscribed) {
                trackSignalingSubscribed(signaling);
            }
            self._trackSignalingUpdatedEventCallbacks.set(signaling.sid, function () {
                if (isSubscribed !== signaling.isSubscribed) {
                    isSubscribed = signaling.isSubscribed;
                    if (isSubscribed) {
                        trackSignalingSubscribed(signaling);
                        return;
                    }
                    trackSignalingUnsubscribed(signaling);
                }
            });
            signaling.on('updated', self._trackSignalingUpdatedEventCallbacks.get(signaling.sid));
        }
        function trackSignalingRemoved(signaling) {
            if (signaling.isSubscribed) {
                signaling.setTrackTransceiver(null, false);
            }
            var updated = self._trackSignalingUpdatedEventCallbacks.get(signaling.sid);
            if (updated) {
                signaling.removeListener('updated', updated);
                self._trackSignalingUpdatedEventCallbacks.delete(signaling.sid);
            }
            var publication = self.tracks.get(signaling.sid);
            if (publication) {
                self._removeTrackPublication(publication);
            }
        }
        function trackSignalingSubscribed(signaling) {
            var isEnabled = signaling.isEnabled, name = signaling.name, kind = signaling.kind, sid = signaling.sid, trackTransceiver = signaling.trackTransceiver, isSwitchedOff = signaling.isSwitchedOff, rspVersion = signaling.rspVersion, _a = signaling.switchOffReason, switchOffReason = _a === void 0 ? null : _a;
            var RemoteTrack = {
                audio: RemoteAudioTrack,
                video: RemoteVideoTrack,
                data: RemoteDataTrack
            }[kind];
            var publication = self.tracks.get(sid);
            var options = { log: log, name: name, clientTrackSwitchOffControl: clientTrackSwitchOffControl, contentPreferencesMode: contentPreferencesMode, shouldDeprecateEnabledState: rspVersion >= 3 };
            var setPriority = function (newPriority) { return participantSignaling.updateSubscriberTrackPriority(sid, newPriority); };
            var setRenderHint = function (renderHint) {
                if (signaling.isSubscribed) {
                    participantSignaling.updateTrackRenderHint(sid, renderHint);
                }
            };
            var track = kind === 'data'
                ? new RemoteTrack(sid, trackTransceiver, options)
                : new RemoteTrack(sid, trackTransceiver, isEnabled, isSwitchedOff, switchOffReason, setPriority, setRenderHint, options);
            self._addTrack(track, publication);
        }
        function trackSignalingUnsubscribed(signaling) {
            var track = self._tracks.get(signaling.sid);
            var publication = self.tracks.get(signaling.sid);
            if (track) {
                self._removeTrack(track, publication);
            }
        }
        participantSignaling.on('trackAdded', trackSignalingAdded);
        participantSignaling.on('trackRemoved', trackSignalingRemoved);
        participantSignaling.tracks.forEach(trackSignalingAdded);
        participantSignaling.on('stateChanged', function stateChanged(state) {
            if (state === 'disconnected') {
                log.debug('Removing event listeners');
                participantSignaling.removeListener('stateChanged', stateChanged);
                participantSignaling.removeListener('trackAdded', trackSignalingAdded);
                participantSignaling.removeListener('trackRemoved', trackSignalingRemoved);
            }
            else if (state === 'connected') {
                // NOTE(mmalavalli): Any transition to "connected" here is a result of
                // successful signaling reconnection, and not a first-time establishment
                // of the signaling connection.
                log.info('reconnected');
                // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.
                // Do not signal  public events synchronously with lock held.
                setTimeout(function () { return self.emit('reconnected'); }, 0);
            }
        });
    };
    /**
     * @private
     * @param {Track} track
     * @param {string} key
     * @returns {?Track}
     */
    Participant.prototype._removeTrack = function (track, key) {
        if (!this._tracks.has(key)) {
            return null;
        }
        this._tracks.delete(key);
        var tracksByKind = {
            audio: this._audioTracks,
            video: this._videoTracks,
            data: this._dataTracks
        }[track.kind];
        tracksByKind.delete(key);
        var reemitters = this._trackEventReemitters.get(key) || new Map();
        reemitters.forEach(function (reemitter, event) {
            track.removeListener(event, reemitter);
        });
        var log = this._log;
        log.info("Removed a " + trackClass(track) + ":", key);
        log.debug(trackClass(track) + ":", track);
        return track;
    };
    /**
     * @private
     * @param {RemoteTrackPublication} publication
     * @returns {?RemoteTrackPublication}
     */
    Participant.prototype._removeTrackPublication = function (publication) {
        publication = this.tracks.get(publication.trackSid);
        if (!publication) {
            return null;
        }
        this.tracks.delete(publication.trackSid);
        var trackPublicationsByKind = {
            audio: this.audioTracks,
            data: this.dataTracks,
            video: this.videoTracks
        }[publication.kind];
        trackPublicationsByKind.delete(publication.trackSid);
        var reemitters = this._trackPublicationEventReemitters.get(publication.trackSid) || new Map();
        reemitters.forEach(function (reemitter, event) {
            publication.removeListener(event, reemitter);
        });
        var log = this._log;
        log.info("Removed a " + trackPublicationClass(publication) + ":", publication.trackSid);
        log.debug(trackPublicationClass(publication) + ":", publication);
        return publication;
    };
    Participant.prototype.toJSON = function () {
        return valueToJSON(this);
    };
    return Participant;
}(EventEmitter));
/**
 * A {@link Participant.SID} is a 34-character string starting with "PA"
 * that uniquely identifies a {@link Participant}.
 * @type string
 * @typedef Participant.SID
 */
/**
 * A {@link Participant.Identity} is a string that identifies a
 * {@link Participant}. You can think of it like a name.
 * @typedef {string} Participant.Identity
 */
/**
 * The {@link Participant} has disconnected.
 * @param {Participant} participant - The {@link Participant} that disconnected.
 * @event Participant#disconnected
 */
/**
 * The {@link Participant}'s {@link NetworkQualityLevel} changed.
 * @param {NetworkQualityLevel} networkQualityLevel - The new
 *   {@link NetworkQualityLevel}
 * @param {?NetworkQualityStats} networkQualityStats - The {@link NetworkQualityStats}
 *   based on which {@link NetworkQualityLevel} is calculated, if any
 * @event Participant#networkQualityLevelChanged
 */
/**
 * The {@link Participant} has reconnected to the {@link Room} after a signaling connection disruption.
 * @event Participant#reconnected
 */
/**
 * The {@link Participant} is reconnecting to the {@link Room} after a signaling connection disruption.
 * @event Participant#reconnecting
 */
/**
 * One of the {@link Participant}'s {@link VideoTrack}'s dimensions changed.
 * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed
 * @event Participant#trackDimensionsChanged
 */
/**
 * One of the {@link Participant}'s {@link Track}s started.
 * @param {Track} track - The {@link Track} that started
 * @event Participant#trackStarted
 */
/**
 * Indexed {@link Track}s by {@link Track.ID}.
 * @typedef {object} IndexedTracks
 * @property {Array<{0: Track.ID, 1: AudioTrack}>} audioTracks - Indexed
 *   {@link AudioTrack}s
 * @property {Array<{0: Track.ID, 1: DataTrack}>} dataTracks - Indexed
 *   {@link DataTrack}s
 * @property {Array<{0: Track.ID, 1: Track}>} tracks - Indexed {@link Track}s
 * @property {Array<{0: Track.ID, 1: VideoTrack}>} videoTracks - Indexed
 *   {@link VideoTrack}s
 * @private
 */
/**
 * Index tracks by {@link Track.ID}.
 * @param {Array<Track>} tracks
 * @returns {IndexedTracks}
 * @private
 */
function indexTracksById(tracks) {
    var indexedTracks = tracks.map(function (track) { return [track.id, track]; });
    var indexedAudioTracks = indexedTracks.filter(function (keyValue) { return keyValue[1].kind === 'audio'; });
    var indexedVideoTracks = indexedTracks.filter(function (keyValue) { return keyValue[1].kind === 'video'; });
    var indexedDataTracks = indexedTracks.filter(function (keyValue) { return keyValue[1].kind === 'data'; });
    return {
        audioTracks: indexedAudioTracks,
        dataTracks: indexedDataTracks,
        tracks: indexedTracks,
        videoTracks: indexedVideoTracks
    };
}
/**
 * Re-emit {@link ParticipantSignaling} 'stateChanged' events.
 * @param {Participant} participant
 * @param {ParticipantSignaling} signaling
 * @private
 */
function reemitSignalingStateChangedEvents(participant, signaling) {
    var log = participant._log;
    if (participant.state === 'disconnected') {
        return;
    }
    // Reemit state transition events from the ParticipantSignaling.
    signaling.on('stateChanged', function stateChanged(state) {
        log.debug('Transitioned to state:', state);
        participant.emit(state, participant);
        if (state === 'disconnected') {
            log.debug('Removing Track event reemitters');
            signaling.removeListener('stateChanged', stateChanged);
            participant._tracks.forEach(function (track) {
                // NOTE(mmalavalli): Event re-emitters for LocalTracks use the Track.ID as the key,
                // whereas event re-emitters for RemoteTracks use the Track.SID as the key.
                var reemitters = participant._trackEventReemitters.get(track.id || track.sid);
                if (track && reemitters) {
                    reemitters.forEach(function (reemitter, event) {
                        track.removeListener(event, reemitter);
                    });
                }
            });
            // eslint-disable-next-line no-warning-comments
            // TODO(joma): Removing this introduced unit test failures in the RemoteParticipant.
            // Investigate further before removing.
            signaling.tracks.forEach(function (trackSignaling) {
                var track = participant._tracks.get(trackSignaling.sid);
                var reemitters = participant._trackEventReemitters.get(trackSignaling.sid);
                if (track && reemitters) {
                    reemitters.forEach(function (reemitter, event) {
                        track.removeListener(event, reemitter);
                    });
                }
            });
            participant._trackEventReemitters.clear();
            participant.tracks.forEach(function (publication) {
                participant._trackPublicationEventReemitters.get(publication.trackSid)
                    .forEach(function (reemitter, event) {
                    publication.removeListener(event, reemitter);
                });
            });
            participant._trackPublicationEventReemitters.clear();
        }
    });
}
/**
 * Re-emit {@link Track} events.
 * @param {Participant} participant
 * @param {Track} track
 * @param {string} key
 * @private
 */
function reemitTrackEvents(participant, track, key) {
    var trackEventReemitters = new Map();
    if (participant.state === 'disconnected') {
        return;
    }
    participant._getTrackEvents().forEach(function (eventPair) {
        var trackEvent = eventPair[0];
        var participantEvent = eventPair[1];
        trackEventReemitters.set(trackEvent, function () {
            var args = [participantEvent].concat([].slice.call(arguments));
            return participant.emit.apply(participant, __spreadArray([], __read(args)));
        });
        track.on(trackEvent, trackEventReemitters.get(trackEvent));
    });
    participant._trackEventReemitters.set(key, trackEventReemitters);
}
module.exports = Participant;
//# sourceMappingURL=participant.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/preflight/getCombinedConnectionStats.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/preflight/getCombinedConnectionStats.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCombinedConnectionStats = void 0;
function getStatValues(report, statName, kind, reportTypes) {
    var results = [];
    report.forEach(function (stat) {
        if ((reportTypes.length === 0 || reportTypes.includes(stat.type)) &&
            (kind.length === 0 || kind.includes(stat.kind)) &&
            typeof stat[statName] === 'number') {
            results.push(stat[statName]);
        }
    });
    return results;
}
function getCombinedConnectionStats(_a) {
    var publisher = _a.publisher, subscriber = _a.subscriber;
    return __awaiter(this, void 0, void 0, function () {
        var _b, publisherStats, subscriberStats, timestamps, timestamp, jitter, packets, packetsLost, trackRoundTripTime, currentRoundTripTime, roundTripTime, bytesSent, bytesReceived, selectedIceCandidatePairStats, iceCandidateStats;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, Promise.all([publisher, subscriber].map(function (pc) { return pc.getStats(); }))];
                case 1:
                    _b = __read.apply(void 0, [_c.sent(), 2]), publisherStats = _b[0], subscriberStats = _b[1];
                    timestamps = getStatValues(subscriberStats, 'timestamp', ['audio'], ['inbound-rtp']);
                    timestamp = timestamps.length > 0 ? timestamps[0] : 0;
                    jitter = getStatValues(subscriberStats, 'jitter', ['audio'], ['inbound-rtp']).reduce(function (a, b) { return Math.max(a, b); }, 0);
                    packets = getStatValues(subscriberStats, 'packetsReceived', ['audio', 'video'], ['inbound-rtp']).reduce(function (a, b) { return a + b; }, 0);
                    packetsLost = getStatValues(subscriberStats, 'packetsLost', ['audio', 'video'], ['inbound-rtp']).reduce(function (a, b) { return a + b; }, 0);
                    trackRoundTripTime = getStatValues(publisherStats, 'roundTripTime', ['audio', 'video'], ['remote-inbound-rtp']).reduce(function (a, b) { return Math.max(a, b); }, 0);
                    currentRoundTripTime = getStatValues(subscriberStats, 'currentRoundTripTime', [], ['candidate-pair']).reduce(function (a, b) { return Math.max(a, b); }, 0);
                    roundTripTime = (currentRoundTripTime || trackRoundTripTime) * 1000;
                    bytesSent = getStatValues(publisherStats, 'bytesSent', [], ['candidate-pair']).reduce(function (a, b) { return a + b; }, 0);
                    bytesReceived = getStatValues(subscriberStats, 'bytesReceived', [], ['candidate-pair']).reduce(function (a, b) { return a + b; }, 0);
                    selectedIceCandidatePairStats = extractSelectedActiveCandidatePair(subscriberStats);
                    iceCandidateStats = [];
                    subscriberStats.forEach(function (stat) {
                        if (stat.type === 'local-candidate' || stat.type === 'remote-candidate') {
                            iceCandidateStats.push(makeStandardCandidateStats(stat));
                        }
                    });
                    return [2 /*return*/, { timestamp: timestamp, jitter: jitter, packets: packets, packetsLost: packetsLost, roundTripTime: roundTripTime, bytesSent: bytesSent, bytesReceived: bytesReceived, selectedIceCandidatePairStats: selectedIceCandidatePairStats, iceCandidateStats: iceCandidateStats }];
            }
        });
    });
}
exports.getCombinedConnectionStats = getCombinedConnectionStats;
function makeStandardCandidateStats(input) {
    var standardizedCandidateStatsKeys = [
        { key: 'transportId', type: 'string' },
        { key: 'candidateType', type: 'string' },
        { key: 'port', altKeys: ['portNumber'], type: 'number' },
        { key: 'address', altKeys: ['ip', 'ipAddress'], type: 'string' },
        { key: 'priority', type: 'number' },
        { key: 'protocol', altKeys: ['transport'], type: 'string' },
        { key: 'url', type: 'string' },
        { key: 'relayProtocol', type: 'string' },
    ];
    return standardizedCandidateStatsKeys.reduce(function (report, keyInfo) {
        var keysToLookFor = [keyInfo.key];
        if (keyInfo.altKeys) {
            keysToLookFor = keysToLookFor.concat(keyInfo.altKeys);
        }
        var key = keysToLookFor.find(function (key) { return key in input; });
        if (key && typeof input[key] === keyInfo.type) {
            report[keyInfo.key] = input[key];
        }
        return report;
    }, {});
}
function extractSelectedActiveCandidatePair(stats) {
    var selectedCandidatePairId = null;
    var candidatePairs = [];
    stats.forEach(function (stat) {
        if (stat.type === 'transport' && stat.selectedCandidatePairId) {
            selectedCandidatePairId = stat.selectedCandidatePairId;
        }
        else if (stat.type === 'candidate-pair') {
            candidatePairs.push(stat);
        }
    });
    var activeCandidatePairStatsFound = candidatePairs.find(function (pair) {
        // Firefox
        return pair.selected ||
            // Spec-compliant way
            (selectedCandidatePairId && pair.id === selectedCandidatePairId);
    });
    if (!activeCandidatePairStatsFound) {
        return null;
    }
    var activeCandidatePairStats = activeCandidatePairStatsFound;
    var activeLocalCandidateStats = stats.get(activeCandidatePairStats.localCandidateId);
    var activeRemoteCandidateStats = stats.get(activeCandidatePairStats.remoteCandidateId);
    if (!activeLocalCandidateStats || !activeRemoteCandidateStats) {
        return null;
    }
    return {
        localCandidate: makeStandardCandidateStats(activeLocalCandidateStats),
        remoteCandidate: makeStandardCandidateStats(activeRemoteCandidateStats)
    };
}
//# sourceMappingURL=getCombinedConnectionStats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/preflight/getturncredentials.js":
/*!***********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/preflight/getturncredentials.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getTurnCredentials = void 0;
/* eslint-disable camelcase */
var TwilioConnection = __webpack_require__(/*! ../twilioconnection.js */ "./node_modules/twilio-video/es5/twilioconnection.js");
var ICE_VERSION = __webpack_require__(/*! ../util/constants */ "./node_modules/twilio-video/es5/util/constants.js").ICE_VERSION;
var _a = __webpack_require__(/*! ../util/twilio-video-errors */ "./node_modules/twilio-video/es5/util/twilio-video-errors.js"), createTwilioError = _a.createTwilioError, SignalingConnectionError = _a.SignalingConnectionError;
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
function getTurnCredentials(token, wsServer) {
    return new Promise(function (resolve, reject) {
        var eventObserver = new events_1.EventEmitter();
        var connectionOptions = {
            networkMonitor: null,
            eventObserver: eventObserver,
            helloBody: {
                edge: 'roaming',
                preflight: true,
                token: token,
                type: 'ice',
                version: ICE_VERSION
            },
        };
        var twilioConnection = new TwilioConnection(wsServer, connectionOptions);
        var done = false;
        twilioConnection.once('close', function () {
            if (!done) {
                done = true;
                reject(new SignalingConnectionError());
            }
        });
        twilioConnection.on('message', function (messageData) {
            var code = messageData.code, message = messageData.message, ice_servers = messageData.ice_servers, type = messageData.type;
            if ((type === 'iced' || type === 'error') && !done) {
                done = true;
                if (type === 'iced') {
                    resolve(ice_servers);
                }
                else {
                    reject(createTwilioError(code, message));
                }
                twilioConnection.close();
            }
        });
    });
}
exports.getTurnCredentials = getTurnCredentials;
//# sourceMappingURL=getturncredentials.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/preflight/makestat.js":
/*!*************************************************************!*\
  !*** ./node_modules/twilio-video/es5/preflight/makestat.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeStat = void 0;
/**
 * Computes min, max, average for given array.
 * @param {Array<number>} values
 * @returns {{min: number, max: number: average: number}|null}
 */
function makeStat(values) {
    if (values && values.length) {
        var min = Math.min.apply(Math, __spreadArray([], __read(values)));
        var max = Math.max.apply(Math, __spreadArray([], __read(values)));
        var average = values.reduce(function (total, value) { return total + value; }, 0) / values.length;
        return { min: min, max: max, average: average };
    }
    return null;
}
exports.makeStat = makeStat;
//# sourceMappingURL=makestat.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/preflight/mos.js":
/*!********************************************************!*\
  !*** ./node_modules/twilio-video/es5/preflight/mos.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.mosToScore = exports.calculateMOS = void 0;
var r0 = 94.768; // Constant used in computing "rFactor".
// copied from https://code.hq.twilio.com/client/sdk-frd/blob/master/voice/voice-mos-calculation.md
function calculateMOS(rtt, jitter, fractionLost) {
    // Compute the effective latency.
    var effectiveLatency = rtt + (jitter * 2) + 10;
    // Compute the initial "rFactor" from effective latency.
    var rFactor = 0;
    switch (true) {
        case effectiveLatency < 160:
            rFactor = r0 - (effectiveLatency / 40);
            break;
        case effectiveLatency < 1000:
            rFactor = r0 - ((effectiveLatency - 120) / 10);
            break;
    }
    // Adjust "rFactor" with the fraction of packets lost.
    switch (true) {
        case fractionLost <= (rFactor / 2.5):
            rFactor = Math.max(rFactor - fractionLost * 2.5, 6.52);
            break;
        default:
            rFactor = 0;
            break;
    }
    // Compute MOS from "rFactor".
    var mos = 1 +
        (0.035 * rFactor) +
        (0.000007 * rFactor) *
            (rFactor - 60) *
            (100 - rFactor);
    return mos;
}
exports.calculateMOS = calculateMOS;
function mosToScore(mosValue) {
    var score = 0;
    if (!mosValue) {
        score = 0;
    }
    else if (mosValue > 4.2) {
        score = 5;
    }
    else if (mosValue > 4.0) {
        score = 4;
    }
    else if (mosValue > 3.6) {
        score = 3;
    }
    else if (mosValue > 3) {
        score = 2;
    }
    else {
        score = 1;
    }
    return score;
}
exports.mosToScore = mosToScore;
//# sourceMappingURL=mos.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/preflight/preflighttest.js":
/*!******************************************************************!*\
  !*** ./node_modules/twilio-video/es5/preflight/preflighttest.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runPreflight = exports.PreflightTest = void 0;
var constants_1 = __webpack_require__(/*! ../util/constants */ "./node_modules/twilio-video/es5/util/constants.js");
var timer_1 = __webpack_require__(/*! ./timer */ "./node_modules/twilio-video/es5/preflight/timer.js");
var mos_1 = __webpack_require__(/*! ./mos */ "./node_modules/twilio-video/es5/preflight/mos.js");
var getCombinedConnectionStats_1 = __webpack_require__(/*! ./getCombinedConnectionStats */ "./node_modules/twilio-video/es5/preflight/getCombinedConnectionStats.js");
var getturncredentials_1 = __webpack_require__(/*! ./getturncredentials */ "./node_modules/twilio-video/es5/preflight/getturncredentials.js");
var makestat_1 = __webpack_require__(/*! ./makestat */ "./node_modules/twilio-video/es5/preflight/makestat.js");
var syntheticaudio_1 = __webpack_require__(/*! ./syntheticaudio */ "./node_modules/twilio-video/es5/preflight/syntheticaudio.js");
var syntheticvideo_1 = __webpack_require__(/*! ./syntheticvideo */ "./node_modules/twilio-video/es5/preflight/syntheticvideo.js");
var util_1 = __webpack_require__(/*! ../util */ "./node_modules/twilio-video/es5/util/index.js");
var WS_SERVER = __webpack_require__(/*! ../util/constants */ "./node_modules/twilio-video/es5/util/constants.js").WS_SERVER;
var Log = __webpack_require__(/*! ../util/log */ "./node_modules/twilio-video/es5/util/log.js");
var EventEmitter = __webpack_require__(/*! ../eventemitter */ "./node_modules/twilio-video/es5/eventemitter.js");
var MovingAverageDelta = __webpack_require__(/*! ../util/movingaveragedelta */ "./node_modules/twilio-video/es5/util/movingaveragedelta.js");
var EventObserver = __webpack_require__(/*! ../util/eventobserver */ "./node_modules/twilio-video/es5/util/eventobserver.js");
var InsightsPublisher = __webpack_require__(/*! ../util/insightspublisher */ "./node_modules/twilio-video/es5/util/insightspublisher/index.js");
var _a = __webpack_require__(/*! ../util/sid */ "./node_modules/twilio-video/es5/util/sid.js"), createSID = _a.createSID, sessionSID = _a.sessionSID;
var _b = __webpack_require__(/*! ../util/twilio-video-errors */ "./node_modules/twilio-video/es5/util/twilio-video-errors.js"), SignalingConnectionTimeoutError = _b.SignalingConnectionTimeoutError, MediaConnectionError = _b.MediaConnectionError;
var SECOND = 1000;
var DEFAULT_TEST_DURATION = 10 * SECOND;
/**
 * progress values that are sent by {@link PreflightTest#event:progress}
 * @enum {string}
 */
var PreflightProgress = {
    /**
     * {@link PreflightTest} has successfully generated synthetic tracks
     */
    mediaAcquired: 'mediaAcquired',
    /**
     * {@link PreflightTest} has successfully connected to twilio server and obtained turn credentials
     */
    connected: 'connected',
    /**
     * SubscriberParticipant successfully subscribed to media tracks.
     */
    mediaSubscribed: 'mediaSubscribed',
    /**
     * Media flow was detected.
     */
    mediaStarted: 'mediaStarted',
    /**
     * Established DTLS connection. This is measured from RTCDtlsTransport `connecting` to `connected` state.
     * On Safari, Support for measuring this is missing, this event will be not be emitted on Safari.
     */
    dtlsConnected: 'dtlsConnected',
    /**
     * Established a PeerConnection, This is measured from PeerConnection `connecting` to `connected` state.
     * On Firefox, Support for measuring this is missing, this event will be not be emitted on Firefox.
     */
    peerConnectionConnected: 'peerConnectionConnected',
    /**
     * Established ICE connection. This is measured from ICE connection `checking` to `connected` state.
     */
    iceConnected: 'iceConnected'
};
function notEmpty(value) {
    return value !== null && typeof value !== 'undefined';
}
var nInstances = 0;
/**
 * A {@link PreflightTest} monitors progress of an ongoing preflight test.
 * <br><br>
 * Instance of {@link PreflightTest} is returned by calling {@link module:twilio-video.runPreflight}
 * @extends EventEmitter
 * @emits PreflightTest#completed
 * @emits PreflightTest#failed
 * @emits PreflightTest#progress
 */
var PreflightTest = /** @class */ (function (_super) {
    __extends(PreflightTest, _super);
    /**
     * Constructs {@link PreflightTest}.
     * @param {string} token
     * @param {?PreflightOptions} [options]
     */
    function PreflightTest(token, options) {
        var _this = _super.call(this) || this;
        _this._testTiming = new timer_1.Timer();
        _this._dtlsTiming = new timer_1.Timer();
        _this._iceTiming = new timer_1.Timer();
        _this._peerConnectionTiming = new timer_1.Timer();
        _this._mediaTiming = new timer_1.Timer();
        _this._connectTiming = new timer_1.Timer();
        _this._sentBytesMovingAverage = new MovingAverageDelta();
        _this._packetLossMovingAverage = new MovingAverageDelta();
        _this._progressEvents = [];
        _this._receivedBytesMovingAverage = new MovingAverageDelta();
        var internalOptions = options;
        var _a = internalOptions.environment, environment = _a === void 0 ? 'prod' : _a, _b = internalOptions.region, region = _b === void 0 ? 'gll' : _b, _c = internalOptions.duration, duration = _c === void 0 ? DEFAULT_TEST_DURATION : _c;
        // eslint-disable-next-line new-cap
        var wsServer = internalOptions.wsServer || WS_SERVER(environment, region);
        _this._log = new Log('default', _this, constants_1.DEFAULT_LOG_LEVEL, constants_1.DEFAULT_LOGGER_NAME);
        _this._testDuration = duration;
        _this._instanceId = nInstances++;
        _this._testTiming.start();
        _this._runPreflightTest(token, environment, wsServer);
        return _this;
    }
    PreflightTest.prototype.toString = function () {
        return "[Preflight #" + this._instanceId + "]";
    };
    /**
     * stops ongoing tests and emits error
     */
    PreflightTest.prototype.stop = function () {
        this._stopped = true;
    };
    PreflightTest.prototype._generatePreflightReport = function (collectedStats) {
        this._testTiming.stop();
        return {
            testTiming: this._testTiming.getTimeMeasurement(),
            networkTiming: {
                dtls: this._dtlsTiming.getTimeMeasurement(),
                ice: this._iceTiming.getTimeMeasurement(),
                peerConnection: this._peerConnectionTiming.getTimeMeasurement(),
                connect: this._connectTiming.getTimeMeasurement(),
                media: this._mediaTiming.getTimeMeasurement()
            },
            stats: {
                jitter: makestat_1.makeStat(collectedStats === null || collectedStats === void 0 ? void 0 : collectedStats.jitter),
                rtt: makestat_1.makeStat(collectedStats === null || collectedStats === void 0 ? void 0 : collectedStats.rtt),
                packetLoss: makestat_1.makeStat(collectedStats === null || collectedStats === void 0 ? void 0 : collectedStats.packetLoss),
            },
            selectedIceCandidatePairStats: collectedStats ? collectedStats.selectedIceCandidatePairStats : null,
            iceCandidateStats: collectedStats ? collectedStats.iceCandidateStats : [],
            progressEvents: this._progressEvents,
            // NOTE(mpatwardhan): internal properties.
            mos: makestat_1.makeStat(collectedStats === null || collectedStats === void 0 ? void 0 : collectedStats.mos),
        };
    };
    PreflightTest.prototype._executePreflightStep = function (stepName, step, timeoutError) {
        return __awaiter(this, void 0, void 0, function () {
            var MAX_STEP_DURATION, stepPromise, timer, timeoutPromise, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._log.debug('Executing step: ', stepName);
                        MAX_STEP_DURATION = this._testDuration + 10 * SECOND;
                        if (this._stopped) {
                            throw new Error('stopped');
                        }
                        stepPromise = Promise.resolve().then(step);
                        timer = null;
                        timeoutPromise = new Promise(function (_resolve, reject) {
                            timer = setTimeout(function () {
                                reject(timeoutError || new Error(stepName + " timeout."));
                            }, MAX_STEP_DURATION);
                        });
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, Promise.race([timeoutPromise, stepPromise])];
                    case 2:
                        result = _a.sent();
                        return [2 /*return*/, result];
                    case 3:
                        if (timer !== null) {
                            clearTimeout(timer);
                        }
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    PreflightTest.prototype._collectNetworkTimings = function (pc) {
        var _this = this;
        return new Promise(function (resolve) {
            var dtlsTransport;
            pc.addEventListener('iceconnectionstatechange', function () {
                if (pc.iceConnectionState === 'checking') {
                    _this._iceTiming.start();
                }
                if (pc.iceConnectionState === 'connected') {
                    _this._iceTiming.stop();
                    _this._updateProgress(PreflightProgress.iceConnected);
                    if (!dtlsTransport || dtlsTransport && dtlsTransport.state === 'connected') {
                        resolve();
                    }
                }
            });
            // firefox does not support connectionstatechange.
            pc.addEventListener('connectionstatechange', function () {
                if (pc.connectionState === 'connecting') {
                    _this._peerConnectionTiming.start();
                }
                if (pc.connectionState === 'connected') {
                    _this._peerConnectionTiming.stop();
                    _this._updateProgress(PreflightProgress.peerConnectionConnected);
                }
            });
            // Safari does not expose sender.transport.
            var senders = pc.getSenders();
            var transport = senders.map(function (sender) { return sender.transport; }).find(notEmpty);
            if (typeof transport !== 'undefined') {
                dtlsTransport = transport;
                dtlsTransport.addEventListener('statechange', function () {
                    if (dtlsTransport.state === 'connecting') {
                        _this._dtlsTiming.start();
                    }
                    if (dtlsTransport.state === 'connected') {
                        _this._dtlsTiming.stop();
                        _this._updateProgress(PreflightProgress.dtlsConnected);
                        if (pc.iceConnectionState === 'connected') {
                            resolve();
                        }
                    }
                });
            }
        });
    };
    PreflightTest.prototype._setupInsights = function (_a) {
        var token = _a.token, _b = _a.environment, environment = _b === void 0 ? constants_1.DEFAULT_ENVIRONMENT : _b, _c = _a.realm, realm = _c === void 0 ? constants_1.DEFAULT_REALM : _c;
        var eventPublisherOptions = {};
        var eventPublisher = new InsightsPublisher(token, constants_1.SDK_NAME, constants_1.SDK_VERSION, environment, realm, eventPublisherOptions);
        // event publisher requires room sid/participant sid. supply fake ones.
        eventPublisher.connect('PREFLIGHT_ROOM_SID', 'PREFLIGHT_PARTICIPANT');
        var eventObserver = new EventObserver(eventPublisher, Date.now(), this._log);
        // eslint-disable-next-line no-undefined
        var undefinedValue = undefined;
        return {
            reportToInsights: function (_a) {
                var _b, _c;
                var report = _a.report;
                var jitterStats = report.stats.jitter || undefinedValue;
                var rttStats = report.stats.rtt || undefinedValue;
                var packetLossStats = report.stats.packetLoss || undefinedValue;
                var mosStats = report.mos || undefinedValue;
                // stringify important info from ice candidates.
                var candidateTypeToProtocols = new Map();
                report.iceCandidateStats.forEach(function (candidateStats) {
                    if (candidateStats.candidateType && candidateStats.protocol) {
                        var protocols = candidateTypeToProtocols.get(candidateStats.candidateType) || [];
                        if (protocols.indexOf(candidateStats.protocol) < 0) {
                            protocols.push(candidateStats.protocol);
                        }
                        candidateTypeToProtocols.set(candidateStats.candidateType, protocols);
                    }
                });
                var iceCandidateStats = JSON.stringify(Object.fromEntries(candidateTypeToProtocols));
                var insightsReport = {
                    name: 'report',
                    group: 'preflight',
                    level: report.error ? 'error' : 'info',
                    payload: {
                        sessionSID: sessionSID,
                        preflightSID: createSID('PF'),
                        progressEvents: JSON.stringify(report.progressEvents),
                        testTiming: report.testTiming,
                        dtlsTiming: report.networkTiming.dtls,
                        iceTiming: report.networkTiming.ice,
                        peerConnectionTiming: report.networkTiming.peerConnection,
                        connectTiming: report.networkTiming.connect,
                        mediaTiming: report.networkTiming.media,
                        selectedLocalCandidate: (_b = report.selectedIceCandidatePairStats) === null || _b === void 0 ? void 0 : _b.localCandidate,
                        selectedRemoteCandidate: (_c = report.selectedIceCandidatePairStats) === null || _c === void 0 ? void 0 : _c.remoteCandidate,
                        iceCandidateStats: iceCandidateStats,
                        jitterStats: jitterStats,
                        rttStats: rttStats,
                        packetLossStats: packetLossStats,
                        mosStats: mosStats,
                        error: report.error
                    }
                };
                eventObserver.emit('event', insightsReport);
                setTimeout(function () { return eventPublisher.disconnect(); }, 2000);
            }
        };
    };
    PreflightTest.prototype._runPreflightTest = function (token, environment, wsServer) {
        return __awaiter(this, void 0, void 0, function () {
            var localTracks, pcs, reportToInsights, elements_1, iceServers, senderPC_1, receiverPC_1, remoteTracks_1, collectedStats_1, report, error_1, preflightReport;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        localTracks = [];
                        pcs = [];
                        reportToInsights = this._setupInsights({ token: token, environment: environment }).reportToInsights;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 8, 9, 10]);
                        elements_1 = [];
                        return [4 /*yield*/, this._executePreflightStep('Acquire media', function () { return [syntheticaudio_1.syntheticAudio(), syntheticvideo_1.syntheticVideo({ width: 640, height: 480 })]; })];
                    case 2:
                        localTracks = _a.sent();
                        this._updateProgress(PreflightProgress.mediaAcquired);
                        this.emit('debug', { localTracks: localTracks });
                        this._connectTiming.start();
                        return [4 /*yield*/, this._executePreflightStep('Get turn credentials', function () { return getturncredentials_1.getTurnCredentials(token, wsServer); }, new SignalingConnectionTimeoutError())];
                    case 3:
                        iceServers = _a.sent();
                        this._connectTiming.stop();
                        this._updateProgress(PreflightProgress.connected);
                        senderPC_1 = new RTCPeerConnection({ iceServers: iceServers, iceTransportPolicy: 'relay', bundlePolicy: 'max-bundle' });
                        receiverPC_1 = new RTCPeerConnection({ iceServers: iceServers, bundlePolicy: 'max-bundle' });
                        pcs.push(senderPC_1);
                        pcs.push(receiverPC_1);
                        this._mediaTiming.start();
                        return [4 /*yield*/, this._executePreflightStep('Setup Peer Connections', function () { return __awaiter(_this, void 0, void 0, function () {
                                var remoteTracksPromise, offer, updatedOffer, answer;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            senderPC_1.addEventListener('icecandidate', function (event) { return event.candidate && receiverPC_1.addIceCandidate(event.candidate); });
                                            receiverPC_1.addEventListener('icecandidate', function (event) { return event.candidate && senderPC_1.addIceCandidate(event.candidate); });
                                            localTracks.forEach(function (track) { return senderPC_1.addTrack(track); });
                                            remoteTracksPromise = new Promise(function (resolve) {
                                                var remoteTracks = [];
                                                receiverPC_1.addEventListener('track', function (event) {
                                                    remoteTracks.push(event.track);
                                                    if (remoteTracks.length === localTracks.length) {
                                                        resolve(remoteTracks);
                                                    }
                                                });
                                            });
                                            return [4 /*yield*/, senderPC_1.createOffer()];
                                        case 1:
                                            offer = _a.sent();
                                            updatedOffer = offer;
                                            return [4 /*yield*/, senderPC_1.setLocalDescription(updatedOffer)];
                                        case 2:
                                            _a.sent();
                                            return [4 /*yield*/, receiverPC_1.setRemoteDescription(updatedOffer)];
                                        case 3:
                                            _a.sent();
                                            return [4 /*yield*/, receiverPC_1.createAnswer()];
                                        case 4:
                                            answer = _a.sent();
                                            return [4 /*yield*/, receiverPC_1.setLocalDescription(answer)];
                                        case 5:
                                            _a.sent();
                                            return [4 /*yield*/, senderPC_1.setRemoteDescription(answer)];
                                        case 6:
                                            _a.sent();
                                            return [4 /*yield*/, this._collectNetworkTimings(senderPC_1)];
                                        case 7:
                                            _a.sent();
                                            return [2 /*return*/, remoteTracksPromise];
                                    }
                                });
                            }); }, new MediaConnectionError())];
                    case 4:
                        remoteTracks_1 = _a.sent();
                        this.emit('debug', { remoteTracks: remoteTracks_1 });
                        remoteTracks_1.forEach(function (track) {
                            track.addEventListener('ended', function () { return _this._log.warn(track.kind + ':ended'); });
                            track.addEventListener('mute', function () { return _this._log.warn(track.kind + ':muted'); });
                            track.addEventListener('unmute', function () { return _this._log.warn(track.kind + ':unmuted'); });
                        });
                        this._updateProgress(PreflightProgress.mediaSubscribed);
                        return [4 /*yield*/, this._executePreflightStep('Wait for tracks to start', function () {
                                return new Promise(function (resolve) {
                                    var element = document.createElement('video');
                                    element.autoplay = true;
                                    element.playsInline = true;
                                    element.muted = true;
                                    element.srcObject = new MediaStream(remoteTracks_1);
                                    elements_1.push(element);
                                    _this.emit('debugElement', element);
                                    element.oncanplay = resolve;
                                });
                            }, new MediaConnectionError())];
                    case 5:
                        _a.sent();
                        this._mediaTiming.stop();
                        this._updateProgress(PreflightProgress.mediaStarted);
                        return [4 /*yield*/, this._executePreflightStep('Collect stats for duration', function () { return _this._collectRTCStatsForDuration(_this._testDuration, initCollectedStats(), senderPC_1, receiverPC_1); })];
                    case 6:
                        collectedStats_1 = _a.sent();
                        return [4 /*yield*/, this._executePreflightStep('Generate report', function () { return _this._generatePreflightReport(collectedStats_1); })];
                    case 7:
                        report = _a.sent();
                        reportToInsights({ report: report });
                        this.emit('completed', report);
                        return [3 /*break*/, 10];
                    case 8:
                        error_1 = _a.sent();
                        preflightReport = this._generatePreflightReport();
                        reportToInsights({ report: __assign(__assign({}, preflightReport), { error: error_1 === null || error_1 === void 0 ? void 0 : error_1.toString() }) });
                        this.emit('failed', error_1, preflightReport);
                        return [3 /*break*/, 10];
                    case 9:
                        pcs.forEach(function (pc) { return pc.close(); });
                        localTracks.forEach(function (track) { return track.stop(); });
                        return [7 /*endfinally*/];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    PreflightTest.prototype._collectRTCStats = function (collectedStats, senderPC, receiverPC) {
        return __awaiter(this, void 0, void 0, function () {
            var combinedStats, timestamp, bytesSent, bytesReceived, packets, packetsLost, roundTripTime, jitter, selectedIceCandidatePairStats, iceCandidateStats, hasLastData, fractionPacketLost, percentPacketsLost, score;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getCombinedConnectionStats_1.getCombinedConnectionStats({ publisher: senderPC, subscriber: receiverPC })];
                    case 1:
                        combinedStats = _a.sent();
                        timestamp = combinedStats.timestamp, bytesSent = combinedStats.bytesSent, bytesReceived = combinedStats.bytesReceived, packets = combinedStats.packets, packetsLost = combinedStats.packetsLost, roundTripTime = combinedStats.roundTripTime, jitter = combinedStats.jitter, selectedIceCandidatePairStats = combinedStats.selectedIceCandidatePairStats, iceCandidateStats = combinedStats.iceCandidateStats;
                        hasLastData = collectedStats.jitter.length > 0;
                        collectedStats.jitter.push(jitter);
                        collectedStats.rtt.push(roundTripTime);
                        this._sentBytesMovingAverage.putSample(bytesSent, timestamp);
                        this._receivedBytesMovingAverage.putSample(bytesReceived, timestamp);
                        this._packetLossMovingAverage.putSample(packetsLost, packets);
                        if (hasLastData) {
                            // convert BytesMovingAverage which is in bytes/millisecond to bits/second
                            collectedStats.outgoingBitrate.push(this._sentBytesMovingAverage.get() * 1000 * 8);
                            collectedStats.incomingBitrate.push(this._receivedBytesMovingAverage.get() * 1000 * 8);
                            fractionPacketLost = this._packetLossMovingAverage.get();
                            percentPacketsLost = Math.min(100, fractionPacketLost * 100);
                            collectedStats.packetLoss.push(percentPacketsLost);
                            score = mos_1.calculateMOS(roundTripTime, jitter, fractionPacketLost);
                            collectedStats.mos.push(score);
                        }
                        if (!collectedStats.selectedIceCandidatePairStats) {
                            collectedStats.selectedIceCandidatePairStats = selectedIceCandidatePairStats;
                        }
                        if (collectedStats.iceCandidateStats.length === 0) {
                            collectedStats.iceCandidateStats = iceCandidateStats;
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    PreflightTest.prototype._collectRTCStatsForDuration = function (duration, collectedStats, senderPC, receiverPC) {
        return __awaiter(this, void 0, void 0, function () {
            var startTime, STAT_INTERVAL, remainingDuration;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        startTime = Date.now();
                        STAT_INTERVAL = Math.min(1000, duration);
                        return [4 /*yield*/, util_1.waitForSometime(STAT_INTERVAL)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this._collectRTCStats(collectedStats, senderPC, receiverPC)];
                    case 2:
                        _a.sent();
                        remainingDuration = duration - (Date.now() - startTime);
                        if (!(remainingDuration > 0)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this._collectRTCStatsForDuration(remainingDuration, collectedStats, senderPC, receiverPC)];
                    case 3:
                        collectedStats = _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/, collectedStats];
                }
            });
        });
    };
    PreflightTest.prototype._updateProgress = function (name) {
        var duration = Date.now() - this._testTiming.getTimeMeasurement().start;
        this._progressEvents.push({ duration: duration, name: name });
        this.emit('progress', name);
    };
    return PreflightTest;
}(EventEmitter));
exports.PreflightTest = PreflightTest;
function initCollectedStats() {
    return {
        mos: [],
        jitter: [],
        rtt: [],
        outgoingBitrate: [],
        incomingBitrate: [],
        packetLoss: [],
        selectedIceCandidatePairStats: null,
        iceCandidateStats: [],
    };
}
/**
 * Represents network timing measurements captured during preflight test
 * @typedef {object} NetworkTiming
 * @property {TimeMeasurement} [connect] - Time to establish signaling connection and acquire turn credentials
 * @property {TimeMeasurement} [media] - Time to start media. This is measured from calling connect to remote media getting started.
 * @property {TimeMeasurement} [dtls] - Time to establish dtls connection. This is measured from RTCDtlsTransport `connecting` to `connected` state. (Not available on Safari)
 * @property {TimeMeasurement} [ice] - Time to establish ice connectivity. This is measured from ICE connection `checking` to `connected` state.
 * @property {TimeMeasurement} [peerConnection] - Time to establish peer connectivity. This is measured from PeerConnection `connecting` to `connected` state. (Not available on Firefox)
 */
/**
 * Represents stats for a numerical metric.
 * @typedef {object} Stats
 * @property  {number} [average] - Average value observed.
 * @property  {number} [max] - Max value observed.
 * @property  {number} [min] - Min value observed.
 */
/**
 * Represents stats for a numerical metric.
 * @typedef {object} SelectedIceCandidatePairStats
 * @property  {RTCIceCandidateStats} [localCandidate] - Selected local ice candidate
 * @property  {RTCIceCandidateStats} [remoteCandidate] - Selected local ice candidate
 */
/**
 * Represents RTC related stats that were observed during preflight test
 * @typedef {object} PreflightReportStats
 * @property {Stats} [jitter] - Packet delay variation in seconds
 * @property {Stats} [rtt] - Round trip time, to the server back to the client in milliseconds.
 * @property {Stats} [packetLoss] - Packet loss as a percent of total packets sent.
*/
/**
 * A {@link PreflightProgress} event with timing information.
 * @typedef {object} ProgressEvent
 * @property {number} [duration] - The duration of the event, measured from the start of the test.
 * @property {string} [name] - The {@link PreflightProgress} event name.
 */
/**
 * Represents report generated by {@link PreflightTest}.
 * @typedef {object} PreflightTestReport
 * @property {TimeMeasurement} [testTiming] - Time measurements of test run time.
 * @property {NetworkTiming} [networkTiming] - Network related time measurements.
 * @property {PreflightReportStats} [stats] - RTC related stats captured during the test.
 * @property {Array<RTCIceCandidateStats>} [iceCandidateStats] - List of gathered ice candidates.
 * @property {SelectedIceCandidatePairStats} selectedIceCandidatePairStats - Stats for the ice candidates that were used for the connection.
 * @property {Array<ProgressEvent>} [progressEvents] - {@link ProgressEvent} events detected during the test.
 * Use this information to determine which steps were completed and which ones were not.
 */
/**
 * You may pass these options to {@link module:twilio-video.testPreflight} in order to override the
 * default behavior.
 * @typedef {object} PreflightOptions
 * @property {string} [region='gll'] - Preferred signaling region; By default, you will be connected to the
 *   nearest signaling server determined by latency based routing. Setting a value other
 *   than <code style="padding:0 0">gll</code> bypasses routing and guarantees that signaling traffic will be
 *   terminated in the region that you prefer. Please refer to this <a href="https://www.twilio.com/docs/video/ip-address-whitelisting#signaling-communication" target="_blank">table</a>
 *   for the list of supported signaling regions.
 * @property {number} [duration=10000] - number of milliseconds to run test for.
 *   once connected test will run for this duration before generating the stats report.
 */
/**
 * Preflight test has completed successfully.
 * @param {PreflightTestReport} report - Results of the test.
 * @event PreflightTest#completed
 */
/**
 * Preflight test has encountered a failure and is now stopped.
 * @param {TwilioError|Error} error - A TwilioError or a DOMException.
 * Possible TwilioErrors include Signaling and Media related errors which can be found
 * <a href="https://www.twilio.com/docs/video/build-js-video-application-recommendations-and-best-practices#connection-errors" target="_blank">here</a>.
 * @param {PreflightTestReport} report - Partial results gathered during the test. Use this information to help determine the cause of failure.
 * @event PreflightTest#failed
 */
/**
 * Emitted to indicate progress of the test
 * @param {PreflightProgress} progress - Indicates the status completed.
 * @event PreflightTest#progress
 */
/**
 * @method
 * @name runPreflight
 * @description Run a preflight test. This method will start a test to check the quality of network connection.
 * @memberof module:twilio-video
 * @param {string} token - The Access Token string
 * @param {PreflightOptions} options - Options for the test
 * @returns {PreflightTest} preflightTest - An instance to be used to monitor progress of the test.
 * @example
 * var { runPreflight } = require('twilio-video');
 * var preflight = runPreflight(token, preflightOptions);
 * preflightTest.on('progress', progress => {
 *   console.log('preflight progress:', progress);
 * });
 *
 * preflightTest.on('failed', (error, report) => {
 *   console.error('preflight error:', error, report);
 * });
 *
 * preflightTest.on('completed', report => {
 *   console.log('preflight completed:', report));
 * });
*/
function runPreflight(token, options) {
    if (options === void 0) { options = {}; }
    var preflight = new PreflightTest(token, options);
    return preflight;
}
exports.runPreflight = runPreflight;
//# sourceMappingURL=preflighttest.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/preflight/syntheticaudio.js":
/*!*******************************************************************!*\
  !*** ./node_modules/twilio-video/es5/preflight/syntheticaudio.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.syntheticAudio = void 0;
function syntheticAudio() {
    // NOTE(mpatwardhan): We have to delay require-ing AudioContextFactory, because
    // it exports a default instance whose constructor calls Object.assign.
    var audioContextFactory = __webpack_require__(/*! ../webaudio/audiocontext */ "./node_modules/twilio-video/es5/webaudio/audiocontext.js");
    var holder = {};
    var audioContext = audioContextFactory.getOrCreate(holder);
    var oscillator = audioContext.createOscillator();
    var dst = oscillator.connect(audioContext.createMediaStreamDestination());
    oscillator.start();
    var track = dst.stream.getAudioTracks()[0];
    var originalStop = track.stop;
    track.stop = function () {
        originalStop.call(track);
        audioContextFactory.release(holder);
    };
    return track;
}
exports.syntheticAudio = syntheticAudio;
//# sourceMappingURL=syntheticaudio.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/preflight/syntheticvideo.js":
/*!*******************************************************************!*\
  !*** ./node_modules/twilio-video/es5/preflight/syntheticvideo.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.syntheticVideo = void 0;
function syntheticVideo(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.width, width = _c === void 0 ? 640 : _c, _d = _b.height, height = _d === void 0 ? 480 : _d;
    var canvas = Object.assign(document.createElement('canvas'), { width: width, height: height });
    var ctx = canvas.getContext('2d');
    ctx.fillStyle = 'green';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    var stopped = false;
    requestAnimationFrame(function animate() {
        if (!stopped) {
            // draw random rect/circle.
            var r = Math.round(Math.random() * 255);
            var g = Math.round(Math.random() * 255);
            var b = Math.round(Math.random() * 255);
            var a = Math.round(Math.random() * 255);
            ctx.fillStyle = "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
            ctx.fillRect(Math.random() * width, Math.random() * height, 50, 50);
            requestAnimationFrame(animate);
        }
    });
    var stream = canvas.captureStream(30);
    var track = stream.getTracks()[0];
    var originalStop = track.stop;
    track.stop = function () {
        stopped = true;
        originalStop.call(track);
    };
    return track;
}
exports.syntheticVideo = syntheticVideo;
//# sourceMappingURL=syntheticvideo.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/preflight/timer.js":
/*!**********************************************************!*\
  !*** ./node_modules/twilio-video/es5/preflight/timer.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Timer = void 0;
var Timer = /** @class */ (function () {
    function Timer() {
        // eslint-disable-next-line no-undefined
        this._end = undefined;
        this.start();
    }
    Timer.prototype.start = function () {
        this._start = Date.now();
        return this;
    };
    Timer.prototype.stop = function () {
        this._end = Date.now();
        return this;
    };
    Timer.prototype.getTimeMeasurement = function () {
        return {
            start: this._start,
            end: this._end,
            // eslint-disable-next-line no-undefined
            duration: this._end === undefined ? undefined : this._end - this._start
        };
    };
    return Timer;
}());
exports.Timer = Timer;
//# sourceMappingURL=timer.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/queueingeventemitter.js":
/*!***************************************************************!*\
  !*** ./node_modules/twilio-video/es5/queueingeventemitter.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
/**
 * A {@link QueueingEventEmitter} can queue events until a listener has been
 * added.
 * @extends EventEmitter
 */
var QueueingEventEmitter = /** @class */ (function (_super) {
    __extends(QueueingEventEmitter, _super);
    /**
     * Construct a {@link QueueingEventEmitter}
     */
    function QueueingEventEmitter() {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _queuedEvents: {
                value: new Map()
            }
        });
        return _this;
    }
    /**
     * Emit any queued events.
     * @returns {boolean} true if every event had listeners, false otherwise
    */ /**
     * Emit any queued events matching the event name.
     * @param {string} event
     * @returns {boolean} true if every event had listeners, false otherwise
     */
    QueueingEventEmitter.prototype.dequeue = function (event) {
        var _this = this;
        var result = true;
        if (!event) {
            this._queuedEvents.forEach(function (_, queuedEvent) {
                result = this.dequeue(queuedEvent) && result;
            }, this);
            return result;
        }
        var queue = this._queuedEvents.get(event) || [];
        this._queuedEvents.delete(event);
        return queue.reduce(function (result, args) { return _this.emit.apply(_this, __spreadArray([], __read([event].concat(args)))) && result; }, result);
    };
    /**
     * If the event has listeners, emit the event; otherwise, queue the event.
     * @param {string} event
     * @param {...*} args
     * @returns {boolean} true if the event had listeners, false if the event was queued
     */
    QueueingEventEmitter.prototype.queue = function () {
        var args = [].slice.call(arguments);
        if (this.emit.apply(this, __spreadArray([], __read(args)))) {
            return true;
        }
        var event = args[0];
        if (!this._queuedEvents.has(event)) {
            this._queuedEvents.set(event, []);
        }
        this._queuedEvents.get(event).push(args.slice(1));
        return false;
    };
    return QueueingEventEmitter;
}(EventEmitter));
module.exports = QueueingEventEmitter;
//# sourceMappingURL=queueingeventemitter.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/remoteparticipant.js":
/*!************************************************************!*\
  !*** ./node_modules/twilio-video/es5/remoteparticipant.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var Participant = __webpack_require__(/*! ./participant */ "./node_modules/twilio-video/es5/participant.js");
/**
 * A {@link RemoteParticipant} represents a remote {@link Participant} in a
 * {@link Room}.
 * @extends Participant
 * @property {Map<Track.SID, RemoteAudioTrackPublication>} audioTracks -
 *    The {@link Participant}'s {@link RemoteAudioTrackPublication}s
 * @property {Map<Track.SID, RemoteDataTrackPublication>} dataTracks -
 *    The {@link Participant}'s {@link RemoteDataTrackPublication}s
 * @property {Map<Track.SID, RemoteTrackPublication>} tracks -
 *    The {@link Participant}'s {@link RemoteTrackPublication}s
 * @property {Map<Track.SID, RemoteVideoTrackPublication>} videoTracks -
 *    The {@link Participant}'s {@link RemoteVideoTrackPublication}s
 * @emits RemoteParticipant#reconnected
 * @emits RemoteParticipant#reconnecting
 * @emits RemoteParticipant#trackDimensionsChanged
 * @emits RemoteParticipant#trackDisabled
 * @emits RemoteParticipant#trackEnabled
 * @emits RemoteParticipant#trackMessage
 * @emits RemoteParticipant#trackPublished
 * @emits RemoteParticipant#trackPublishPriorityChanged
 * @emits RemoteParticipant#trackStarted
 * @emits RemoteParticipant#trackSubscribed
 * @emits RemoteParticipant#trackSubscriptionFailed
 * @emits RemoteParticipant#trackSwitchedOff
 * @emits RemoteParticipant#trackSwitchedOn
 * @emits RemoteParticipant#trackUnpublished
 * @emits RemoteParticipant#trackUnsubscribed
 */
var RemoteParticipant = /** @class */ (function (_super) {
    __extends(RemoteParticipant, _super);
    /**
     * Construct a {@link RemoteParticipant}.
     * @param {ParticipantSignaling} signaling
     * @param {object} [options]
     */
    function RemoteParticipant(signaling, options) {
        var _this = _super.call(this, signaling, options) || this;
        _this._handleTrackSignalingEvents();
        _this.once('disconnected', _this._unsubscribeTracks.bind(_this));
        return _this;
    }
    RemoteParticipant.prototype.toString = function () {
        return "[RemoteParticipant #" + this._instanceId + (this.sid ? ": " + this.sid : '') + "]";
    };
    /**
     * @private
     * @param {RemoteTrack} remoteTrack
     * @param {RemoteTrackPublication} publication
     * @returns {?RemoteTrack}
     */
    RemoteParticipant.prototype._addTrack = function (remoteTrack, publication) {
        if (!_super.prototype._addTrack.call(this, remoteTrack, remoteTrack.sid)) {
            return null;
        }
        publication._subscribed(remoteTrack);
        this.emit('trackSubscribed', remoteTrack, publication);
        return remoteTrack;
    };
    /**
     * @private
     * @param {RemoteTrackPublication} publication
     * @returns {?RemoteTrackPublication}
     */
    RemoteParticipant.prototype._addTrackPublication = function (publication) {
        var addedPublication = _super.prototype._addTrackPublication.call(this, publication);
        if (!addedPublication) {
            return null;
        }
        this.emit('trackPublished', addedPublication);
        return addedPublication;
    };
    /**
     * @private
     */
    RemoteParticipant.prototype._getTrackPublicationEvents = function () {
        return __spreadArray(__spreadArray([], __read(_super.prototype._getTrackPublicationEvents.call(this))), [
            ['subscriptionFailed', 'trackSubscriptionFailed'],
            ['trackDisabled', 'trackDisabled'],
            ['trackEnabled', 'trackEnabled'],
            ['publishPriorityChanged', 'trackPublishPriorityChanged'],
            ['trackSwitchedOff', 'trackSwitchedOff'],
            ['trackSwitchedOn', 'trackSwitchedOn']
        ]);
    };
    /**
     * @private
     */
    RemoteParticipant.prototype._unsubscribeTracks = function () {
        var _this = this;
        this.tracks.forEach(function (publication) {
            if (publication.isSubscribed) {
                var track = publication.track;
                publication._unsubscribe();
                _this.emit('trackUnsubscribed', track, publication);
            }
        });
    };
    /**
     * @private
     * @param {RemoteTrack} remoteTrack
     * @param {RemoteTrackPublication} publication
     * @returns {?RemoteTrack}
     */
    RemoteParticipant.prototype._removeTrack = function (remoteTrack, publication) {
        var unsubscribedTrack = this._tracks.get(remoteTrack.sid);
        if (!unsubscribedTrack) {
            return null;
        }
        _super.prototype._removeTrack.call(this, unsubscribedTrack, unsubscribedTrack.sid);
        publication._unsubscribe();
        this.emit('trackUnsubscribed', unsubscribedTrack, publication);
        return unsubscribedTrack;
    };
    /**
     * @private
     * @param {RemoteTrackPublication} publication
     * @returns {?RemoteTrackPublication}
     */
    RemoteParticipant.prototype._removeTrackPublication = function (publication) {
        this._signaling.clearTrackHint(publication.trackSid);
        var removedPublication = _super.prototype._removeTrackPublication.call(this, publication);
        if (!removedPublication) {
            return null;
        }
        this.emit('trackUnpublished', removedPublication);
        return removedPublication;
    };
    return RemoteParticipant;
}(Participant));
/**
 * The {@link RemoteParticipant} has reconnected to the {@link Room} after a signaling connection disruption.
 * @event RemoteParticipant#reconnected
 */
/**
 * The {@link RemoteParticipant} is reconnecting to the {@link Room} after a signaling connection disruption.
 * @event RemoteParticipant#reconnecting
 */
/**
 * One of the {@link RemoteParticipant}'s {@link RemoteVideoTrack}'s dimensions changed.
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} whose dimensions changed
 * @event RemoteParticipant#trackDimensionsChanged
 */
/**
 * A {@link RemoteTrack} was disabled by the {@link RemoteParticipant}.
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} associated with the disabled {@link RemoteTrack}
 * @event RemoteParticipant#trackDisabled
 */
/**
 * A {@link RemoteTrack} was enabled by the {@link RemoteParticipant}.
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} associated with the enabled {@link RemoteTrack}
 * @event RemoteParticipant#trackEnabled
 */
/**
 * A message was received over one of the {@link RemoteParticipant}'s
 * {@link RemoteDataTrack}s.
 * @event RemoteParticipant#trackMessage
 * @param {string|ArrayBuffer} data
 * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} over which the
 *   message was received
 */
/**
 * A {@link RemoteTrack} was published by the {@link RemoteParticipant} after
 * connecting to the {@link Room}. This event is not emitted for
 * {@link RemoteTrack}s that were published while the {@link RemoteParticipant}
 * was connecting to the {@link Room}.
 * @event RemoteParticipant#trackPublished
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   which represents the published {@link RemoteTrack}
 * @example
 * function trackPublished(publication) {
 *   console.log(`Track ${publication.trackSid} was published`);
 * }
 *
 * room.on('participantConnected', participant => {
 *   // Handle RemoteTracks published while connecting to the Room.
 *   participant.trackPublications.forEach(trackPublished);
 *
 *   // Handle RemoteTracks published after connecting to the Room.
 *   participant.on('trackPublished', trackPublished);
 * });
 */
/**
 * One of the {@link RemoteParticipant}'s {@link RemoteTrack}s started.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that started
 * @event RemoteParticipant#trackStarted
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was subscribed to.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was subscribed to
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was subscribed to
 * @event RemoteParticipant#trackSubscribed
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} could not be subscribed to.
 * @param {TwilioError} error - The reason the {@link RemoteTrack} could not be
 *   subscribed to
 * @param {RemoteTrackPublication} publication - The
 *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that could not
 *   be subscribed to
 * @event RemoteParticipant#trackSubscriptionFailed
 */
/**
 * The {@link RemoteTrackPublication}'s publish {@link Track.Priority} was changed by the
 * {@link RemoteParticipant}.
 * @param {Track.Priority} priority - the {@link RemoteTrack}'s new publish
 *   {@link Track.Priority};
 * @param {RemoteTrackPublication} publication - The
 *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that changed priority
 * @event RemoteParticipant#trackPublishPriorityChanged
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched off. The media server stops
 * sending media or data for the {@link RemoteTrack} until it is switched back on. Just before
 * the event is raised, <code>isSwitchedOff</code> is set to <code>true</code> and <code>switchOffReason</code>
 * is set to a {@link TrackSwitchOffReason}. Also, if the {@link RemoteTrack} receives either audio or video
 * media, the <code>mediaStreamTrack</code> property is set to <code>null</code>.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched off
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was switched off
 * @param {?TrackSwitchOffReason} switchOffReason - The reason the {@link RemoteMediaTrack}
 *   was switched off
 * @event RemoteParticipant#trackSwitchedOff
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched on. The media server starts
 * sending media for the {@link RemoteTrack} until it is switched off. Just before the event is raised,
 * <code>isSwitchedOff</code> is set to <code>false</code> and <code>switchOffReason</code>
 * is set to <code>null</code>. Also, if the {@link RemoteTrack} receives either audio or video media,
 * the <code>mediaStreamTrack</code> property is set to a MediaStreamTrack that is the source of the
 * {@link RemoteTrack}'s media.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched on.
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was switched on
 * @event RemoteParticipant#trackSwitchedOn
 */
/**
 * A {@link RemoteTrack} was unpublished by the {@link RemoteParticipant}.
 * @event RemoteParticipant#trackUnpublished
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   which represents the unpublished {@link RemoteTrack}
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was unsubscribed from.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was unsubscribed from
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was unsubscribed from
 * @event RemoteParticipant#trackUnsubscribed
 */
module.exports = RemoteParticipant;
//# sourceMappingURL=remoteparticipant.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/room.js":
/*!***********************************************!*\
  !*** ./node_modules/twilio-video/es5/room.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var EventEmitter = __webpack_require__(/*! ./eventemitter */ "./node_modules/twilio-video/es5/eventemitter.js");
var RemoteParticipant = __webpack_require__(/*! ./remoteparticipant */ "./node_modules/twilio-video/es5/remoteparticipant.js");
var StatsReport = __webpack_require__(/*! ./stats/statsreport */ "./node_modules/twilio-video/es5/stats/statsreport.js");
var valueToJSON = __webpack_require__(/*! ./util */ "./node_modules/twilio-video/es5/util/index.js").valueToJSON;
var nInstances = 0;
/**
 * A {@link Room} represents communication between you and one or more
 * {@link RemoteParticipant}s sharing {@link AudioTrack}s and
 * {@link VideoTrack}s.
 * <br><br>
 * You can connect to a {@link Room} by calling {@link module:twilio-video.connect}.
 * @extends EventEmitter
 * @property {?RemoteParticipant} dominantSpeaker - The Dominant Speaker in the
 *   {@link Room}, if any
 * @property {boolean} isRecording - Whether or not the {@link Room} is being
 *   recorded
 * @property {LocalParticipant} localParticipant - Your {@link LocalParticipant}
 *   in the {@link Room}
 * @property {string} mediaRegion - String indicating geographical region
 *    where  media is processed for the {@link Room}.
 * @property {string} name - The {@link Room}'s name
 * @property {Map<Participant.SID, RemoteParticipant>} participants -
 *   The {@link RemoteParticipant}s participating in this {@link Room}
 * @property {Room.SID} sid - The {@link Room}'s SID
 * @property {string} state - "connected", "reconnecting", or "disconnected"
 * @throws {SignalingConnectionDisconnectedError}
 * @emits Room#disconnected
 * @emits Room#participantConnected
 * @emits Room#participantDisconnected
 * @emits Room#participantReconnected
 * @emits Room#participantReconnecting
 * @emits Room#reconnected
 * @emits Room#reconnecting
 * @emits Room#recordingStarted
 * @emits Room#recordingStopped
 * @emits Room#trackDimensionsChanged
 * @emits Room#trackDisabled
 * @emits Room#trackEnabled
 * @emits Room#trackMessage
 * @emits Room#trackPublished
 * @emits Room#trackPublishPriorityChanged
 * @emits Room#trackStarted
 * @emits Room#trackSubscribed
 * @emits Room#trackSwitchedOff
 * @emits Room#trackSwitchedOn
 * @emits Room#trackUnpublished
 * @emits Room#trackUnsubscribed
 */
var Room = /** @class */ (function (_super) {
    __extends(Room, _super);
    /**
     * Construct a {@link Room}.
     * @param {RoomSignaling} signaling
     * @param {?object} [options={}]
     */
    function Room(localParticipant, signaling, options) {
        var _this = _super.call(this) || this;
        var log = options.log.createLog('default', _this);
        var participants = new Map();
        /* istanbul ignore next */
        Object.defineProperties(_this, {
            _log: {
                value: log
            },
            _clientTrackSwitchOffControl: {
                value: options.clientTrackSwitchOffControl || 'disabled'
            },
            _contentPreferencesMode: {
                value: options.contentPreferencesMode || 'disabled'
            },
            _instanceId: {
                value: ++nInstances
            },
            _options: {
                value: options
            },
            _participants: {
                value: participants
            },
            _signaling: {
                value: signaling
            },
            dominantSpeaker: {
                enumerable: true,
                get: function () {
                    return this.participants.get(signaling.dominantSpeakerSid) || null;
                }
            },
            isRecording: {
                enumerable: true,
                get: function () {
                    return signaling.recording.isEnabled || false;
                }
            },
            localParticipant: {
                enumerable: true,
                value: localParticipant
            },
            name: {
                enumerable: true,
                value: signaling.name
            },
            participants: {
                enumerable: true,
                value: participants
            },
            sid: {
                enumerable: true,
                value: signaling.sid
            },
            state: {
                enumerable: true,
                get: function () {
                    return signaling.state;
                }
            },
            mediaRegion: {
                enumerable: true,
                value: signaling.mediaRegion
            }
        });
        handleRecordingEvents(_this, signaling.recording);
        handleSignalingEvents(_this, signaling);
        log.info('Created a new Room:', _this.name);
        log.debug('Initial RemoteParticipants:', Array.from(_this._participants.values()));
        return _this;
    }
    Room.prototype.toString = function () {
        return "[Room #" + this._instanceId + ": " + this.sid + "]";
    };
    /**
     * Disconnect from the {@link Room}.
     * @returns {this}
     */
    Room.prototype.disconnect = function () {
        this._log.info('Disconnecting');
        this._signaling.disconnect();
        return this;
    };
    /**
     * Get the {@link Room}'s media statistics. This is not supported in Safari 12.0 or below
     * due to this bug : https://bugs.webkit.org/show_bug.cgi?id=192601
     *
     * @returns {Promise.<Array<StatsReport>>}
     */
    Room.prototype.getStats = function () {
        var _this = this;
        return this._signaling.getStats().then(function (responses) {
            return Array.from(responses).map(function (_a) {
                var _b = __read(_a, 2), id = _b[0], response = _b[1];
                return new StatsReport(id, Object.assign({}, response, {
                    localAudioTrackStats: rewriteLocalTrackIds(_this, response.localAudioTrackStats),
                    localVideoTrackStats: rewriteLocalTrackIds(_this, response.localVideoTrackStats)
                }));
            });
        });
    };
    Room.prototype.toJSON = function () {
        return valueToJSON(this);
    };
    return Room;
}(EventEmitter));
function rewriteLocalTrackIds(room, trackStats) {
    var localParticipantSignaling = room.localParticipant._signaling;
    return trackStats.reduce(function (trackStats, trackStat) {
        var publication = localParticipantSignaling.tracks.get(trackStat.trackId);
        var trackSender = localParticipantSignaling.getSender(publication);
        return trackSender
            ? [Object.assign({}, trackStat, { trackId: trackSender.id })].concat(trackStats)
            : trackStats;
    }, []);
}
/**
 * A {@link Room.SID} is a 34-character string starting with "RM"
 * that uniquely identifies a {@link Room}.
 * @type string
 * @typedef Room.SID
 */
/**
 * The Dominant Speaker in the {@link Room} changed. Either the Dominant Speaker
 * is a new {@link RemoteParticipant} or the Dominant Speaker has been reset and
 * is now null.
 * @param {?RemoteParticipant} dominantSpeaker - The Dominant Speaker in the
 *   {@link Room}, if any
 * @event Room#dominantSpeakerChanged
 */
/**
 * Your {@link LocalParticipant} was disconnected from the {@link Room} and all
 * other {@link RemoteParticipant}s.
 * @param {Room} room - The {@link Room} your
 *   {@link LocalParticipant} was disconnected from
 * @param {?TwilioError} error - Present when the {@link LocalParticipant} got
 *   disconnected from the {@link Room} unexpectedly
 * @event Room#disconnected
 * @example
 * myRoom.on('disconnected', function(room, error) {
 *   if (error) {
 *     console.log('Unexpectedly disconnected:', error);
 *   }
 *   myRoom.localParticipant.tracks.forEach(function(track) {
 *     track.stop();
 *     track.detach();
 *   });
 * });
 */
/**
 * A {@link RemoteParticipant} joined the {@link Room}. In Large Group Rooms (Maximum
 * Participants greater than 50), this event is raised only when a {@link RemoteParticipant}
 * publishes at least one {@link LocalTrack}.
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who joined
 * @event Room#participantConnected
 * @example
 * myRoom.on('participantConnected', function(participant) {
 *   console.log(participant.identity + ' joined the Room');
 * });
 */
/**
 * A {@link RemoteParticipant} left the {@link Room}. In Large Group Rooms (Maximum
 * Participants greater than 50), this event is raised only when a {@link RemoteParticipant}
 * unpublishes all its {@link LocalTrack}s.
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who left
 * @event Room#participantDisconnected
 * @example
 * myRoom.on('participantDisconnected', function(participant) {
 *   console.log(participant.identity + ' left the Room');
 *   participant.tracks.forEach(function(track) {
 *     track.detach().forEach(function(mediaElement) {
 *       mediaElement.remove();
 *     });
 *   });
 * });
 */
/**
 * A {@link RemoteParticipant} has reconnected to the {@link Room} after a signaling connection disruption.
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} that has reconnected.
 * @event Room#participantReconnected
 * @example
 * myRoom.on('participantReconnected', participant => {
 *   console.log(participant.identity + ' reconnected to the Room');
 * });
 */
/**
 * A {@link RemoteParticipant} is reconnecting to the {@link Room} after a signaling connection disruption.
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} that is reconnecting.
 * @event Room#participantReconnecting
 * @example
 * myRoom.on('participantReconnecting', participant => {
 *   console.log(participant.identity + ' is reconnecting to the Room');
 * });
 */
/**
 * Your application successfully reconnected to the {@link Room}. When this
 * event is emitted, the {@link Room} is in state "connected".
 * @event Room#reconnected
 * @example
 * myRoom.on('reconnected', () => {
 *   console.log('Reconnected!');
 * });
 */
/**
 * Your application is reconnecting to the {@link Room}. This happens when there
 * is a disruption in your signaling connection and/or your media connection. When
 * this event is emitted, the {@link Room} is in state "reconnecting". If reconnecting
 * succeeds, the {@link Room} will emit a "reconnected" event.
 * @param {MediaConnectionError|SignalingConnectionDisconnectedError} error - A
 *   {@link MediaConnectionError} if your application is reconnecting due to a
 *   disruption in your media connection, or a {@link SignalingConnectionDisconnectedError}
 *   if your application is reconnecting due to a disruption in your signaling connection
 * @event Room#reconnecting
 * @example
 * myRoom.on('reconnecting', error => {
 *   if (error.code === 53001) {
 *     console.log('Reconnecting your signaling connection!', error.message);
 *   } else if (error.code === 53405) {
 *     console.log('Reconnecting your media connection!', error.message);
 *   }
 * });
 */
/**
 * The {@link Room} is now being recorded
 * @event Room#recordingStarted
 */
/**
 * The {@link Room} is no longer being recorded
 * @event Room#recordingStopped
 */
/**
 * One of the {@link RemoteParticipant}'s {@link VideoTrack}'s dimensions changed.
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} whose dimensions changed
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteVideoTrack}'s dimensions changed
 * @event Room#trackDimensionsChanged
 */
/**
 * A {@link RemoteTrack} was disabled by a {@link RemoteParticipant} in the {@link Room}.
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} that represents disabled {@link RemoteTrack}
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who
 *   disabled the {@link RemoteTrack}
 * @event Room#trackDisabled
 */
/**
 * A {@link RemoteTrack} was enabled by a {@link RemoteParticipant} in the {@link Room}.
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} that represents enabled {@link RemoteTrack}
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who
 *   enabled the {@link RemoteTrack}
 * @event Room#trackEnabled
 */
/**
 * A message was received over one of the {@link RemoteParticipant}'s
 * {@link RemoteDataTrack}'s.
 * @param {string|ArrayBuffer} data
 * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} over which the
 *   message was received
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteDataTrack} received the message
 * @event Room#trackMessage
 */
/**
 * A {@link RemoteTrack} was published by a {@link RemoteParticipant} after
 * connecting to the {@link Room}. This event is not emitted for
 * {@link RemoteTrack}s that were published while the {@link RemoteParticipant}
 * was connecting to the {@link Room}.
 * @event Room#trackPublished
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   which represents the published {@link RemoteTrack}
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who
 *   published the {@link RemoteTrack}
 * @example
 * function trackPublished(publication, participant) {
 *   console.log(`RemoteParticipant ${participant.sid} published Track ${publication.trackSid}`);
 * }
 *
 * // Handle RemoteTracks published after connecting to the Room.
 * room.on('trackPublished', trackPublished);
 *
 * room.on('participantConnected', participant => {
 *   // Handle RemoteTracks published while connecting to the Room.
 *   participant.trackPublications.forEach(publication => trackPublished(publication, participant));
 * });
 */
/**
 * One of a {@link RemoteParticipant}'s {@link RemoteTrack}s in the {@link Room} started.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that started
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} started
 * @event Room#trackStarted
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was subscribed to.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was subscribed
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was subscribed to
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} was subscribed
 * @event Room#trackSubscribed
 * @example
 * room.on('trackSubscribed', function(track, publication, participant) {
 *   var participantView = document.getElementById('participant-view-' + participant.identity);
 *   participantView.appendChild(track.attach());
 * });
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched off. The media server stops
 * sending media or data for the {@link RemoteTrack} until it is switched back on. Just before
 * the event is raised, <code>isSwitchedOff</code> is set to <code>true</code> and <code>switchOffReason</code>
 * is set to a {@link TrackSwitchOffReason}. Also, if the {@link RemoteTrack} receives either audio or video
 * media, the <code>mediaStreamTrack</code> property is set to <code>null</code>.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched off
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was subscribed to
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} was switched off
 * @param {TrackSwitchOffReason} switchOffReason - The reason the {@link RemoteTrack}
 *   was switched off
 * @event Room#trackSwitchedOff
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched on. The media server starts
 * sending media for the {@link RemoteTrack} until it is switched off. Just before the event is raised,
 * <code>isSwitchedOff</code> is set to <code>false</code> and <code>switchOffReason</code>
 * is set to <code>null</code>. Also, if the {@link RemoteTrack} receives either audio or video media,
 * the <code>mediaStreamTrack</code> property is set to a MediaStreamTrack that is the source of the
 * {@link RemoteTrack}'s media.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched on
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was subscribed to
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} was switched on
 * @event Room#trackSwitchedOn
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} could not be subscribed to.
 * @param {TwilioError} error - The reason the {@link RemoteTrack} could not be
 *   subscribed to
 * @param {RemoteTrackPublication} publication - The
 *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that could not
 *   be subscribed to
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} could not be subscribed to
 * @event Room#trackSubscriptionFailed
 */
/**
 * The {@link RemoteTrack}'s publish {@link Track.Priority} was changed by the
 * {@link RemoteParticipant}.
 * @param {Track.Priority} priority - the {@link RemoteTrack}'s new publish
 *   {@link Track.Priority};
 * @param {RemoteTrackPublication} publication - The
 *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that changed priority
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} changed priority
 * @event Room#trackPublishPriorityChanged
 */
/**
 * A {@link RemoteTrack} was unpublished by a {@link RemoteParticipant} to the {@link Room}.
 * @event Room#trackUnpublished
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   which represents the unpublished {@link RemoteTrack}
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who
 *   unpublished the {@link RemoteTrack}
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was unsubscribed from.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was unsubscribed
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was unsubscribed from
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} was unsubscribed
 * @event Room#trackUnsubscribed
 * @example
 * room.on('trackUnsubscribed', function(track, publication, participant) {
 *   track.detach().forEach(function(mediaElement) {
 *     mediaElement.remove();
 *   });
 * });
 */
function connectParticipant(room, participantSignaling) {
    var log = room._log, clientTrackSwitchOffControl = room._clientTrackSwitchOffControl, contentPreferencesMode = room._contentPreferencesMode;
    var participant = new RemoteParticipant(participantSignaling, { log: log, clientTrackSwitchOffControl: clientTrackSwitchOffControl, contentPreferencesMode: contentPreferencesMode });
    log.info('A new RemoteParticipant connected:', participant);
    room._participants.set(participant.sid, participant);
    room.emit('participantConnected', participant);
    // Reemit Track and RemoteParticipant events.
    var eventListeners = [
        ['reconnected', 'participantReconnected'],
        ['reconnecting', 'participantReconnecting'],
        'trackDimensionsChanged',
        'trackDisabled',
        'trackEnabled',
        'trackMessage',
        'trackPublished',
        'trackPublishPriorityChanged',
        'trackStarted',
        'trackSubscribed',
        'trackSubscriptionFailed',
        'trackSwitchedOff',
        'trackSwitchedOn',
        'trackUnpublished',
        'trackUnsubscribed'
    ].map(function (eventOrPair) {
        var _a = __read(Array.isArray(eventOrPair)
            ? eventOrPair
            : [eventOrPair, eventOrPair], 2), event = _a[0], participantEvent = _a[1];
        function reemit() {
            var args = [].slice.call(arguments);
            args.unshift(participantEvent);
            if (participantEvent === 'trackSwitchedOff') {
                var switchOffReason = args.pop();
                args.push(participant, switchOffReason);
            }
            else {
                args.push(participant);
            }
            room.emit.apply(room, __spreadArray([], __read(args)));
        }
        participant.on(event, reemit);
        return [event, reemit];
    });
    participant.once('disconnected', function participantDisconnected() {
        var dominantSpeaker = room.dominantSpeaker;
        log.info('RemoteParticipant disconnected:', participant);
        room._participants.delete(participant.sid);
        eventListeners.forEach(function (args) {
            participant.removeListener(args[0], args[1]);
        });
        room.emit('participantDisconnected', participant);
        if (participant === dominantSpeaker) {
            room.emit('dominantSpeakerChanged', room.dominantSpeaker);
        }
    });
}
function handleRecordingEvents(room, recording) {
    recording.on('updated', function updated() {
        var started = recording.isEnabled;
        room._log.info("Recording " + (started ? 'started' : 'stopped'));
        room.emit("recording" + (started ? 'Started' : 'Stopped'));
    });
}
function handleSignalingEvents(room, signaling) {
    var log = room._log;
    // Reemit RemoteParticipant events from the RoomSignaling.
    log.debug('Creating a new RemoteParticipant for each ParticipantSignaling '
        + 'in the RoomSignaling');
    signaling.participants.forEach(connectParticipant.bind(null, room));
    log.debug('Setting up RemoteParticipant creation for all subsequent '
        + 'ParticipantSignalings that connect to the RoomSignaling');
    signaling.on('participantConnected', connectParticipant.bind(null, room));
    signaling.on('dominantSpeakerChanged', function () { return room.emit('dominantSpeakerChanged', room.dominantSpeaker); });
    // Reemit state transition events from the RoomSignaling.
    signaling.on('stateChanged', function stateChanged(state, error) {
        log.info('Transitioned to state:', state);
        switch (state) {
            case 'disconnected':
                room.participants.forEach(function (participant) {
                    participant._unsubscribeTracks();
                });
                room.emit(state, room, error);
                room.localParticipant.tracks.forEach(function (publication) {
                    publication.unpublish();
                });
                signaling.removeListener('stateChanged', stateChanged);
                break;
            case 'reconnecting':
                // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.
                // Do not signal  public events synchronously with lock held.
                setTimeout(function () { return room.emit('reconnecting', error); }, 0);
                break;
            default:
                // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.
                // Do not signal  public events synchronously with lock held.
                setTimeout(function () { return room.emit('reconnected'); }, 0);
        }
    });
}
module.exports = Room;
//# sourceMappingURL=room.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint consistent-return:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ParticipantSignaling = __webpack_require__(/*! ./participant */ "./node_modules/twilio-video/es5/signaling/participant.js");
var RoomSignaling = __webpack_require__(/*! ./room */ "./node_modules/twilio-video/es5/signaling/room.js");
var StateMachine = __webpack_require__(/*! ../statemachine */ "./node_modules/twilio-video/es5/statemachine.js");
/*
Signaling States
----------------

              +---------+
              |         |
              | opening |
         +--->|         |
         |    +---------+
    +--------+   |   |   +------+
    |        |<--+   +-->|      |
    | closed |<----------| open |
    |        |<--+   +-->|      |
    +--------+   |   |   +------+
              +---------+   |
              |         |<--+
              | closing |
              |         |
              +---------+

*/
var states = {
    closed: [
        'opening'
    ],
    opening: [
        'closed',
        'open'
    ],
    open: [
        'closed',
        'closing'
    ],
    closing: [
        'closed',
        'open'
    ]
};
/**
 * @extends StateMachine
 * @property {string} state - one of "closed", "opening", "open", or "closing"
 */
var Signaling = /** @class */ (function (_super) {
    __extends(Signaling, _super);
    /**
     * Construct {@link Signaling}.
     */
    function Signaling() {
        return _super.call(this, 'closed', states) || this;
    }
    /**
     * @private
     */
    // NOTE(mroberts): This is a dummy implementation suitable for testing.
    Signaling.prototype._close = function (key) {
        this.transition('closing', key);
        this.transition('closed', key);
        return Promise.resolve(this);
    };
    /**
     * @private
     */
    // NOTE(mroberts): This is a dummy implementation suitable for testing.
    Signaling.prototype._connect = function (localParticipant, token, encodingParameters, preferredCodecs, options) {
        localParticipant.connect('PA00000000000000000000000000000000', 'test');
        var sid = 'RM00000000000000000000000000000000';
        var promise = Promise.resolve(new RoomSignaling(localParticipant, sid, options));
        promise.cancel = function cancel() { };
        return promise;
    };
    /**
     * @private
     */
    // NOTE(mroberts): This is a dummy implementation suitable for testing.
    Signaling.prototype._open = function (key) {
        this.transition('opening', key);
        this.transition('open', key);
        return Promise.resolve(this);
    };
    /**
     * Close the {@link Signaling}.
     * @returns {Promise<this>}
     */
    Signaling.prototype.close = function () {
        var _this = this;
        return this.bracket('close', function (key) {
            switch (_this.state) {
                case 'closed':
                    return _this;
                case 'open':
                    return _this._close(key);
                default:
                    throw new Error("Unexpected Signaling state \"" + _this.state + "\"");
            }
        });
    };
    /**
     * Connect to a {@link RoomSignaling}.
     * @param {ParticipantSignaling} localParticipant
     * @param {string} token
     * @param {EncodingParametersImpl} encodingParameters
     * @param {PreferredCodecs} preferredCodecs
     * @param {object} options
     * @returns {Promise<function(): CancelablePromise<RoomSignaling>>}
     */
    Signaling.prototype.connect = function (localParticipant, token, encodingParameters, preferredCodecs, options) {
        var self = this;
        return this.bracket('connect', function transition(key) {
            switch (self.state) {
                case 'closed':
                    return self._open(key).then(transition.bind(null, key));
                case 'open':
                    // NOTE(mroberts): We don't need to hold the lock in _connect. Instead,
                    // we just need to ensure the Signaling remains open.
                    self.releaseLockCompletely(key);
                    return self._connect(localParticipant, token, encodingParameters, preferredCodecs, options);
                default:
                    throw new Error("Unexpected Signaling state \"" + self.state + "\"");
            }
        });
    };
    /**
     * Create a local {@link ParticipantSignaling}.
     * @returns {ParticipantSignaling}
     */
    Signaling.prototype.createLocalParticipantSignaling = function () {
        return new ParticipantSignaling();
    };
    /**
     * Open the {@link Signaling}.
     * @returns {Promise<this>}
     */
    Signaling.prototype.open = function () {
        var _this = this;
        return this.bracket('open', function (key) {
            switch (_this.state) {
                case 'closed':
                    return _this._open(key);
                case 'open':
                    return _this;
                default:
                    throw new Error("Unexpected Signaling state \"" + _this.state + "\"");
            }
        });
    };
    return Signaling;
}(StateMachine));
module.exports = Signaling;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/localparticipant.js":
/*!*********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/localparticipant.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ParticipantSignaling = __webpack_require__(/*! ./participant */ "./node_modules/twilio-video/es5/signaling/participant.js");
var LocalParticipantSignaling = /** @class */ (function (_super) {
    __extends(LocalParticipantSignaling, _super);
    function LocalParticipantSignaling() {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _publicationsToTrackSenders: {
                value: new Map()
            },
            _trackSendersToPublications: {
                value: new Map()
            }
        });
        return _this;
    }
    /**
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @param {string} name
     * @param {Track.Priority} priority
     * @returns {LocalTrackPublicationSignaling} publication
     */
    LocalParticipantSignaling.prototype.addTrack = function (trackSender, name, priority) {
        var publication = this._createLocalTrackPublicationSignaling(trackSender, name, priority);
        this._trackSendersToPublications.set(trackSender, publication);
        this._publicationsToTrackSenders.set(publication, trackSender);
        _super.prototype.addTrack.call(this, publication);
        return this;
    };
    /**
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @returns {?LocalTrackPublicationSignaling}
     */
    LocalParticipantSignaling.prototype.getPublication = function (trackSender) {
        return this._trackSendersToPublications.get(trackSender) || null;
    };
    /**
     * @param {LocalTrackPublicationSignaling} trackPublication
     * @returns {?DataTrackSender|MediaTrackSender}
     */
    LocalParticipantSignaling.prototype.getSender = function (trackPublication) {
        return this._publicationsToTrackSenders.get(trackPublication) || null;
    };
    /**
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @returns {?LocalTrackPublicationSignaling}
     */
    LocalParticipantSignaling.prototype.removeTrack = function (trackSender) {
        var publication = this._trackSendersToPublications.get(trackSender);
        if (!publication) {
            return null;
        }
        this._trackSendersToPublications.delete(trackSender);
        this._publicationsToTrackSenders.delete(publication);
        var didDelete = _super.prototype.removeTrack.call(this, publication);
        if (didDelete) {
            publication.stop();
        }
        return publication;
    };
    return LocalParticipantSignaling;
}(ParticipantSignaling));
module.exports = LocalParticipantSignaling;
//# sourceMappingURL=localparticipant.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/localtrackpublication.js":
/*!**************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/localtrackpublication.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackSignaling = __webpack_require__(/*! ./track */ "./node_modules/twilio-video/es5/signaling/track.js");
/**
 * A {@link LocalTrackPublication} implementation
 * @extends TrackSignaling
 * @property {Track.ID} id
 */
var LocalTrackPublicationSignaling = /** @class */ (function (_super) {
    __extends(LocalTrackPublicationSignaling, _super);
    /**
     * Construct a {@link LocalTrackPublicationSignaling}. {@link TrackSenders}
     * are always cloned.
     * @param {DataTrackSender|MediaTrackSender} trackSender - the {@link TrackSender}
     *   of the {@link LocalTrack} to be published
     * @param {string} name - the name of the {@link LocalTrack} to be published
     * @param {Track.Priority} priority - initial {@link Track.Priority}
     */
    function LocalTrackPublicationSignaling(trackSender, name, priority) {
        var _this = this;
        trackSender = trackSender.clone();
        var enabled = trackSender.kind === 'data' ? true : trackSender.track.enabled;
        _this = _super.call(this, name, trackSender.kind, enabled, priority) || this;
        _this.setTrackTransceiver(trackSender);
        Object.defineProperties(_this, {
            _updatedPriority: {
                value: priority,
                writable: true
            },
            id: {
                enumerable: true,
                value: trackSender.id
            }
        });
        return _this;
    }
    Object.defineProperty(LocalTrackPublicationSignaling.prototype, "updatedPriority", {
        /**
         * The updated {@link Track.Priority} of the {@link LocalTrack}.
         * @property {Track.priority}
         */
        get: function () {
            return this._updatedPriority;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Enable (or disable) the {@link LocalTrackPublicationSignaling} if it is not
     * already enabled (or disabled). This also updates the cloned
     * {@link MediaTrackSender}'s MediaStreamTracks `enabled` state.
     * @param {boolean} [enabled=true]
     * @return {this}
     */
    LocalTrackPublicationSignaling.prototype.enable = function (enabled) {
        enabled = typeof enabled === 'boolean' ? enabled : true;
        this.trackTransceiver.track.enabled = enabled;
        return _super.prototype.enable.call(this, enabled);
    };
    /**
     * Rejects the SID's deferred promise with the given Error.
     * @param {Error} error
     * @returns {this}
     */
    LocalTrackPublicationSignaling.prototype.publishFailed = function (error) {
        if (setError(this, error)) {
            this.emit('updated');
        }
        return this;
    };
    /**
     * Update the {@link Track.Priority} of the published {@link LocalTrack}.
     * @param {Track.priority} priority
     * @returns {this}
     */
    LocalTrackPublicationSignaling.prototype.setPriority = function (priority) {
        if (this._updatedPriority !== priority) {
            this._updatedPriority = priority;
            this.emit('updated');
        }
        return this;
    };
    /**
     * Set the published {@link LocalTrack}'s {@link Track.SID}.
     * @param {Track.SID} sid
     * @returns {this}
     */
    LocalTrackPublicationSignaling.prototype.setSid = function (sid) {
        if (this._error) {
            return this;
        }
        return _super.prototype.setSid.call(this, sid);
    };
    /**
     * Stop the cloned {@link TrackSender}.
     * @returns {void}
     */
    LocalTrackPublicationSignaling.prototype.stop = function () {
        this.trackTransceiver.stop();
    };
    return LocalTrackPublicationSignaling;
}(TrackSignaling));
/**
 * @param {LocalTrackPublication} publication
 * @param {Error} error
 * @returns {boolean} updated
 */
function setError(publication, error) {
    if (publication._sid !== null || publication._error) {
        return false;
    }
    publication._error = error;
    return true;
}
module.exports = LocalTrackPublicationSignaling;
//# sourceMappingURL=localtrackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/participant.js":
/*!****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/participant.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var StateMachine = __webpack_require__(/*! ../statemachine */ "./node_modules/twilio-video/es5/statemachine.js");
var NetworkQualityStats = __webpack_require__(/*! ../stats/networkqualitystats */ "./node_modules/twilio-video/es5/stats/networkqualitystats.js");
/*
ParticipantSignaling States
----------------------

    +------------+     +-----------+     +--------------+
    |            |     |           |     |              |
    | connecting |---->| connected |---->| disconnected |
    |            |     |           |     |              |
    +------------+     +-----------+     +--------------+
                           | ^                    ^
                           | |  +--------------+  |
                           | |--|              |  |
                           |--->| reconnecting |--|
                                |              |
                                +--------------+
*/
var states = {
    connecting: [
        'connected'
    ],
    connected: [
        'disconnected',
        'reconnecting'
    ],
    reconnecting: [
        'connected',
        'disconnected'
    ],
    disconnected: []
};
/**
 * A {@link Participant} implementation
 * @extends StateMachine
 * @property {?string} identity
 * @property {?Participant.SID} sid
 * @property {string} state - "connecting", "connected", or "disconnected"
 * @property {Map<Track.ID | Track.SID, TrackSignaling>} tracks
 * @emits ParticipantSignaling#networkQualityLevelChanged
 * @emits ParticipantSignaling#trackAdded
 * @emits ParticipantSignaling#trackRemoved
 */
var ParticipantSignaling = /** @class */ (function (_super) {
    __extends(ParticipantSignaling, _super);
    /**
     * Construct a {@link ParticipantSignaling}.
     */
    function ParticipantSignaling() {
        var _this = _super.call(this, 'connecting', states) || this;
        Object.defineProperties(_this, {
            _identity: {
                writable: true,
                value: null
            },
            _networkQualityLevel: {
                value: null,
                writable: true
            },
            _networkQualityStats: {
                value: null,
                writable: true
            },
            _sid: {
                writable: true,
                value: null
            },
            identity: {
                enumerable: true,
                get: function () {
                    return this._identity;
                }
            },
            sid: {
                enumerable: true,
                get: function () {
                    return this._sid;
                }
            },
            tracks: {
                enumerable: true,
                value: new Map()
            }
        });
        return _this;
    }
    Object.defineProperty(ParticipantSignaling.prototype, "networkQualityLevel", {
        /**
         * Get the current {@link NetworkQualityLevel}, if any.
         * @returns {?NetworkQualityLevel} networkQualityLevel - initially null
         */
        get: function () {
            return this._networkQualityLevel;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantSignaling.prototype, "networkQualityStats", {
        /**
         * Get the current {@link NetworkQualityStats}
         * @returns {?NetworkQualityStats} networkQualityStats - initially null
         */
        get: function () {
            return this._networkQualityStats;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Add the {@link TrackSignaling}, MediaStreamTrack, or
     * {@link DataTrackSender} to the {@link ParticipantSignaling}.
     * @param {TrackSignaling|DataTrackSender|MediaTrackSender} track
     * @returns {this}
     * @fires ParticipantSignaling#trackAdded
     */
    ParticipantSignaling.prototype.addTrack = function (track) {
        this.tracks.set(track.id || track.sid, track);
        this.emit('trackAdded', track);
        return this;
    };
    /**
     * Disconnect the {@link ParticipantSignaling}.
     * @returns {boolean}
     */
    ParticipantSignaling.prototype.disconnect = function () {
        if (this.state !== 'disconnected') {
            this.preempt('disconnected');
            return true;
        }
        return false;
    };
    /**
     * Remove the {@link TrackSignaling}, MediaStreamTrack, or
     * {@link DataTrackSender} from the {@link ParticipantSignaling}.
     * @param {TrackSignaling|DataTrackSender|MediaTrackSender} track
     * @returns {?TrackSignaling}
     * @fires ParticipantSignaling#trackRemoved
     */
    ParticipantSignaling.prototype.removeTrack = function (track) {
        var signaling = this.tracks.get(track.id || track.sid);
        this.tracks.delete(track.id || track.sid);
        if (signaling) {
            this.emit('trackRemoved', track);
        }
        return signaling || null;
    };
    /**
     * @param {NetworkQualityLevel} networkQualityLevel
     * @param {?NetworkQualityLevels} [networkQualityLevels=null]
     * @returns {void}
     */
    ParticipantSignaling.prototype.setNetworkQualityLevel = function (networkQualityLevel, networkQualityLevels) {
        if (this._networkQualityLevel !== networkQualityLevel) {
            this._networkQualityLevel = networkQualityLevel;
            this._networkQualityStats = networkQualityLevels
                && (networkQualityLevels.audio || networkQualityLevels.video)
                ? new NetworkQualityStats(networkQualityLevels)
                : null;
            this.emit('networkQualityLevelChanged');
        }
    };
    /**
     * Connect the {@link ParticipantSignaling}.
     * @param {Participant.SID} sid
     * @param {string} identity
     * @returns {boolean}
     */
    ParticipantSignaling.prototype.connect = function (sid, identity) {
        if (this.state === 'connecting' || this.state === 'reconnecting') {
            if (!this._sid) {
                this._sid = sid;
            }
            if (!this._identity) {
                this._identity = identity;
            }
            this.preempt('connected');
            return true;
        }
        return false;
    };
    /**
     * Transition to "reconnecting" state.
     * @returns {boolean}
     */
    ParticipantSignaling.prototype.reconnecting = function () {
        if (this.state === 'connecting' || this.state === 'connected') {
            this.preempt('reconnecting');
            return true;
        }
        return false;
    };
    return ParticipantSignaling;
}(StateMachine));
/**
 * @event ParticipantSignaling#event:networkQualityLevelChanged
 */
/**
 * {@link TrackSignaling} was added to the {@link ParticipantSignaling}.
 * @event ParticipantSignaling#trackAdded
 * @param {TrackSignaling} track
 */
/**
 * {@link TrackSignaling} was removed from the {@link ParticipantSignaling}.
 * @event ParticipantSignaling#trackRemoved
 * @param {TrackSignaling} track
 */
module.exports = ParticipantSignaling;
//# sourceMappingURL=participant.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/recording.js":
/*!**************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/recording.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
/**
 * Represents recording state
 * @extends EventEmitter
 * @property {?boolean} isEnabled
 */
var RecordingSignaling = /** @class */ (function (_super) {
    __extends(RecordingSignaling, _super);
    /**
     * Construct a {@link RecordingSignaling}.
     */
    function RecordingSignaling() {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _isEnabled: {
                value: null,
                writable: true
            },
            isEnabled: {
                enumerable: true,
                get: function () {
                    return this._isEnabled;
                }
            }
        });
        return _this;
    }
    /**
     * Disable the {@link RecordingSignaling} if it is not already disabled.
     * @return {this}
     */
    RecordingSignaling.prototype.disable = function () {
        return this.enable(false);
    };
    /**
     * Enable (or disable) the {@link RecordingSignaling} if it is not already enabled
     * (or disabled).
     * @param {boolean} [enabled=true]
     * @return {this}
     */
    RecordingSignaling.prototype.enable = function (enabled) {
        enabled = typeof enabled === 'boolean' ? enabled : true;
        if (this.isEnabled !== enabled) {
            this._isEnabled = enabled;
            this.emit('updated');
        }
        return this;
    };
    return RecordingSignaling;
}(EventEmitter));
/**
 * Emitted whenever the {@link RecordingSignaling} is updated
 * @event RecordingSignaling#updated
 */
module.exports = RecordingSignaling;
//# sourceMappingURL=recording.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/remoteparticipant.js":
/*!**********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/remoteparticipant.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ParticipantSignaling = __webpack_require__(/*! ./participant */ "./node_modules/twilio-video/es5/signaling/participant.js");
/**
 * A {@link Participant} implementation
 * @extends ParticipantSignaling
 * @property {string} identity
 * @property {Participant.SID} sid
 */
var RemoteParticipantSignaling = /** @class */ (function (_super) {
    __extends(RemoteParticipantSignaling, _super);
    /**
     * Construct a {@link RemoteParticipantSignaling}.
     * @param {Participant.SID} sid
     * @param {string} identity
     */
    function RemoteParticipantSignaling(sid, identity) {
        var _this = _super.call(this) || this;
        _this.connect(sid, identity);
        return _this;
    }
    return RemoteParticipantSignaling;
}(ParticipantSignaling));
module.exports = RemoteParticipantSignaling;
//# sourceMappingURL=remoteparticipant.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/remotetrackpublication.js":
/*!***************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/remotetrackpublication.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackSignaling = __webpack_require__(/*! ./track */ "./node_modules/twilio-video/es5/signaling/track.js");
/**
 * A {@link RemoteTrackPublication} implementation
 * @extends TrackSignaling
 */
var RemoteTrackPublicationSignaling = /** @class */ (function (_super) {
    __extends(RemoteTrackPublicationSignaling, _super);
    /**
     * Construct a {@link RemoteTrackPublicationSignaling}.
     * @param {Track.SID} sid
     * @param {string} name
     * @param {Track.Kind} kind
     * @param {boolean} isEnabled
     * @param {Track.Priority} priority
     * @param {boolean} isSwitchedOff
     * @param {number} rspVersion
     */
    function RemoteTrackPublicationSignaling(sid, name, kind, isEnabled, priority, isSwitchedOff, rspVersion) {
        var _this = _super.call(this, name, kind, isEnabled, priority) || this;
        Object.defineProperties(_this, {
            _isSwitchedOff: {
                value: isSwitchedOff,
                writable: true
            },
            _rspVersion: {
                value: rspVersion,
                writable: true
            }
        });
        _this.setSid(sid);
        return _this;
    }
    Object.defineProperty(RemoteTrackPublicationSignaling.prototype, "isSwitchedOff", {
        /**
         * Whether the {@link RemoteTrackPublicationSignaling} is switched off.
         * @property {boolean}
         */
        get: function () {
            return this._isSwitchedOff;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RemoteTrackPublicationSignaling.prototype, "rspVersion", {
        /**
         * Return the RSP version of the {@link RemoteTrackPublicationSignaling} object.
         * @return {number}
         */
        get: function () {
            return this._rspVersion;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @param {Error} error
     * @returns {this}
     */
    RemoteTrackPublicationSignaling.prototype.subscribeFailed = function (error) {
        if (!this.error) {
            this._error = error;
            this.emit('updated');
        }
        return this;
    };
    /**
     * Update the publish {@link Track.Priority}.
     * @param {Track.Priority} priority
     * @returns {this}
     */
    RemoteTrackPublicationSignaling.prototype.setPriority = function (priority) {
        if (this._priority !== priority) {
            this._priority = priority;
            this.emit('updated');
        }
        return this;
    };
    /**
     * Updates track switch on/off state.
     * @param {boolean} isSwitchedOff
     * @returns {this}
     */
    RemoteTrackPublicationSignaling.prototype.setSwitchedOff = function (isSwitchedOff) {
        if (this._isSwitchedOff !== isSwitchedOff) {
            this._isSwitchedOff = isSwitchedOff;
            this.emit('updated');
        }
        return this;
    };
    return RemoteTrackPublicationSignaling;
}(TrackSignaling));
module.exports = RemoteTrackPublicationSignaling;
//# sourceMappingURL=remotetrackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/room.js":
/*!*********************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/room.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DefaultRecordingSignaling = __webpack_require__(/*! ./recording */ "./node_modules/twilio-video/es5/signaling/recording.js");
var StateMachine = __webpack_require__(/*! ../statemachine */ "./node_modules/twilio-video/es5/statemachine.js");
var DefaultTimeout = __webpack_require__(/*! ../util/timeout */ "./node_modules/twilio-video/es5/util/timeout.js");
var buildLogLevels = __webpack_require__(/*! ../util */ "./node_modules/twilio-video/es5/util/index.js").buildLogLevels;
var DEFAULT_LOG_LEVEL = __webpack_require__(/*! ../util/constants */ "./node_modules/twilio-video/es5/util/constants.js").DEFAULT_LOG_LEVEL;
var Log = __webpack_require__(/*! ../util/log */ "./node_modules/twilio-video/es5/util/log.js");
var _a = __webpack_require__(/*! ../util/twilio-video-errors */ "./node_modules/twilio-video/es5/util/twilio-video-errors.js"), MediaConnectionError = _a.MediaConnectionError, MediaDTLSTransportFailedError = _a.MediaDTLSTransportFailedError, SignalingConnectionDisconnectedError = _a.SignalingConnectionDisconnectedError;
var nInstances = 0;
/*
RoomSignaling States
-----------------------

    +-----------+     +--------------+
    |           |     |              |
    | connected |---->| disconnected |
    |           |     |              |
    +-----------+     +--------------+
          |  ^               ^
          |  |               |
          |  |   +--------------+
          |  +---|              |
          |      | reconnecting |
          +----->|              |
                 +--------------+

*/
var states = {
    connected: [
        'reconnecting',
        'disconnected'
    ],
    reconnecting: [
        'connected',
        'disconnected'
    ],
    disconnected: []
};
/**
 * A {@link Room} implementation
 * @extends StateMachine
 * @property {RTCPeerConnectionState} connectionState
 * @property {?Participant.SID} dominantSpeakerSid
 * @property {ParticipantSignaling} localParticipant
 * @property {RTCIceConnectionState} iceConnectionState
 * @property {string} name
 * @property {Map<string, RemoteParticipantSignaling>} participants
 * @property {RecordingSignaling} recording
 * @property {Room.SID} sid
 * @property {string} state - "connected", "reconnecting", or "disconnected"
 * @property {string} signalingConnectionState - "connected",
 *   "reconnecting", or "disconnected"
 * @emits RoomSignaling#connectionStateChanged
 * @emits RoomSignaling#dominantSpeakerChanged
 * @emits RoomSignaling#iceConnectionStateChanged
 * @emits RoomSignaling#signalingConnectionStateChanged
 */
var RoomSignaling = /** @class */ (function (_super) {
    __extends(RoomSignaling, _super);
    /**
     * Construct a {@link RoomSignaling}.
     * @param {ParticipantSignaling} localParticipant
     * @param {Room.SID} sid
     * @param {string} name
     * @param {object} options
     */
    function RoomSignaling(localParticipant, sid, name, options) {
        var _this = this;
        options = Object.assign({
            logLevel: DEFAULT_LOG_LEVEL,
            RecordingSignaling: DefaultRecordingSignaling,
            Timeout: DefaultTimeout
        }, options);
        var logLevels = buildLogLevels(options.logLevel);
        _this = _super.call(this, 'connected', states) || this;
        var RecordingSignaling = options.RecordingSignaling;
        var sessionTimeout = new options.Timeout(function () {
            _this._disconnect(_this._reconnectingError);
        }, options.sessionTimeout, false);
        Object.defineProperties(_this, {
            _instanceId: {
                value: nInstances++
            },
            _log: {
                value: options.log
                    ? options.log.createLog('default', _this)
                    : new Log('default', _this, logLevels, options.loggerName)
            },
            _mediaConnectionIsReconnecting: {
                writable: true,
                value: false
            },
            _options: {
                value: options
            },
            _reconnectingError: {
                value: null,
                writable: true
            },
            _sessionTimeout: {
                value: sessionTimeout
            },
            dominantSpeakerSid: {
                enumerable: true,
                value: null,
                writable: true
            },
            localParticipant: {
                enumerable: true,
                value: localParticipant
            },
            name: {
                enumerable: true,
                value: name
            },
            participants: {
                enumerable: true,
                value: new Map()
            },
            recording: {
                enumerable: true,
                value: new RecordingSignaling()
            },
            sid: {
                enumerable: true,
                value: sid
            }
        });
        _this.on('connectionStateChanged', function () {
            if (_this.connectionState === 'failed'
                && !['disconnected', 'failed'].includes(_this.iceConnectionState)) {
                _this._disconnect(new MediaDTLSTransportFailedError());
            }
        });
        _this.on('iceConnectionStateChanged', function () { return maybeUpdateState(_this); });
        _this.on('signalingConnectionStateChanged', function () { return maybeUpdateState(_this); });
        // NOTE(mmalavalli): In case "iceConnectionState" is already failed, update
        // the RoomSignaling state. setTimeout() ensures that the state is updated
        // after RoomV2's constructor is fully executed, thereby making "signalingConnectionState"
        // available here.
        setTimeout(function () { return maybeUpdateState(_this); });
        return _this;
    }
    /**
     * Disconnect, possibly with an Error.
     * @private
     * @param {Error} [error]
     * @returns {boolean}
     */
    RoomSignaling.prototype._disconnect = function (error) {
        if (this.state !== 'disconnected') {
            this.preempt('disconnected', null, [error]);
            return true;
        }
        return false;
    };
    RoomSignaling.prototype.toString = function () {
        return "[RoomSignaling #" + this._instanceId + ": " + (this.localParticipant ? this.localParticipant.sid : 'null') + "]";
    };
    /**
     * Connect {@link RemoteParticipantSignaling} to the {@link RoomSignaling}.
     * @param {RemoteParticipantSignaling} participant
     * @returns {boolean}
     */
    RoomSignaling.prototype.connectParticipant = function (participant) {
        var self = this;
        if (participant.state === 'disconnected') {
            return false;
        }
        if (this.participants.has(participant.sid)) {
            return false;
        }
        this.participants.set(participant.sid, participant);
        participant.on('stateChanged', function stateChanged(state) {
            if (state === 'disconnected') {
                participant.removeListener('stateChanged', stateChanged);
                self.participants.delete(participant.sid);
                self.emit('participantDisconnected', participant);
            }
        });
        this.emit('participantConnected', participant);
        return true;
    };
    /**
     * Disconnect.
     * @returns {boolean}
     */
    RoomSignaling.prototype.disconnect = function () {
        return this._disconnect();
    };
    /**
     * Set (or unset) the Dominant Speaker.
     * @param {?Participant.SID} dominantSpeakerSid
     * @returns {void}
     */
    RoomSignaling.prototype.setDominantSpeaker = function (dominantSpeakerSid) {
        this.dominantSpeakerSid = dominantSpeakerSid;
        this.emit('dominantSpeakerChanged');
    };
    return RoomSignaling;
}(StateMachine));
/**
 * @event RoomSignaling#event:connectionStateChanged
 */
/**
 * @event RoomSignaling#event:dominantSpeakerChanged
 */
/**
 * {@link RemoteParticipantSignaling} connected to the {@link RoomSignaling}.
 * @event RoomSignaling#event:participantConnected
 * @param {RemoteParticipantSignaling} participantSignaling
 */
/**
 * {@link RemoteParticipantSignaling} disconnected from the {@link RoomSignaling}.
 * @event RoomSignaling#event:participantDisconnected
 * @param {RemoteParticipantSignaling} participantSignaling
 */
/**
 * @event RoomSignaling#event:iceConnectionStateChanged
 */
/**
 * @event RoomSignaling#event:signalingConnectionStateChanged
 */
/**
 * Maybe update the {@link RoomSignaling} state.
 * @param {RoomSignaling} roomSignaling
 */
function maybeUpdateState(roomSignaling) {
    if (roomSignaling.state === 'disconnected' || roomSignaling.signalingConnectionState === 'disconnected') {
        roomSignaling._sessionTimeout.clear();
        return;
    }
    var newState;
    if (roomSignaling.signalingConnectionState === 'reconnecting') {
        newState = roomSignaling.signalingConnectionState;
    }
    else if (roomSignaling.iceConnectionState === 'failed') {
        roomSignaling._mediaConnectionIsReconnecting = true;
        newState = 'reconnecting';
    }
    else if (roomSignaling.iceConnectionState === 'new' || roomSignaling.iceConnectionState === 'checking') {
        newState = roomSignaling._mediaConnectionIsReconnecting ? 'reconnecting' : 'connected';
    }
    else {
        roomSignaling._mediaConnectionIsReconnecting = false;
        roomSignaling._reconnectingError = null;
        roomSignaling._sessionTimeout.clear();
        newState = 'connected';
    }
    if (newState === roomSignaling.state) {
        return;
    }
    if (newState === 'reconnecting') {
        roomSignaling._reconnectingError = roomSignaling.signalingConnectionState === 'reconnecting'
            ? new SignalingConnectionDisconnectedError()
            : new MediaConnectionError();
        roomSignaling._sessionTimeout.start();
        roomSignaling.preempt(newState, null, [roomSignaling._reconnectingError]);
    }
    else {
        roomSignaling.preempt(newState);
    }
}
module.exports = RoomSignaling;
//# sourceMappingURL=room.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/track.js":
/*!**********************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/track.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
/**
 * A {@link Track} implementation
 * @extends EventEmitter
 * @property {Track.Kind} kind
 * @property {string} name
 */
var TrackSignaling = /** @class */ (function (_super) {
    __extends(TrackSignaling, _super);
    /**
     * Construct a {@link TrackSignaling}.
     * @param {string} name
     * @param {Track.Kind} kind
     * @param {boolean} isEnabled
     * @param {Track.Priority} priority
     */
    function TrackSignaling(name, kind, isEnabled, priority) {
        var _this = _super.call(this) || this;
        var sid = null;
        Object.defineProperties(_this, {
            _error: {
                value: null,
                writable: true
            },
            _isEnabled: {
                value: isEnabled,
                writable: true
            },
            _priority: {
                value: priority,
                writable: true
            },
            _trackTransceiver: {
                value: null,
                writable: true
            },
            _sid: {
                get: function () {
                    return sid;
                },
                set: function (_sid) {
                    if (sid === null) {
                        sid = _sid;
                    }
                }
            },
            kind: {
                enumerable: true,
                value: kind
            },
            name: {
                enumerable: true,
                value: name
            }
        });
        return _this;
    }
    Object.defineProperty(TrackSignaling.prototype, "error", {
        /**
         * Non-null if publication or subscription failed.
         * @property {?Error} error
         */
        get: function () {
            return this._error;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TrackSignaling.prototype, "isEnabled", {
        /**
         * Whether the {@link TrackSignaling} is enabled.
         * @property {boolean}
         */
        get: function () {
            return this._isEnabled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TrackSignaling.prototype, "priority", {
        /**
         * The {@link TrackSignaling}'s priority.
         * @property {Track.Priority}
         */
        get: function () {
            return this._priority;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TrackSignaling.prototype, "sid", {
        /**
         * The {@link TrackSignaling}'s {@link Track.SID}.
         * @property {Track.SID}
         */
        get: function () {
            return this._sid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TrackSignaling.prototype, "trackTransceiver", {
        /**
         * The {@link TrackSignaling}'s {@link TrackTransceiver}.
         * @property {TrackTransceiver}
         */
        get: function () {
            return this._trackTransceiver;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Disable the {@link TrackSignaling} if it is not already disabled.
     * @return {this}
     */
    TrackSignaling.prototype.disable = function () {
        return this.enable(false);
    };
    /**
     * Enable (or disable) the {@link TrackSignaling} if it is not already enabled
     * (or disabled).
     * @param {boolean} [enabled=true]
     * @return {this}
     */
    TrackSignaling.prototype.enable = function (enabled) {
        enabled = typeof enabled === 'boolean' ? enabled : true;
        if (this.isEnabled !== enabled) {
            this._isEnabled = enabled;
            this.emit('updated');
        }
        return this;
    };
    /**
     * Set the {@link TrackTransceiver} on the {@link TrackSignaling}.
     * @param {TrackTransceiver} trackTransceiver
     * @returns {this}
     */
    TrackSignaling.prototype.setTrackTransceiver = function (trackTransceiver) {
        trackTransceiver = trackTransceiver || null;
        if (this.trackTransceiver !== trackTransceiver) {
            this._trackTransceiver = trackTransceiver;
            this.emit('updated');
        }
        return this;
    };
    /**
     * Set the SID on the {@link TrackSignaling} once.
     * @param {string} sid
     * @returns {this}
     */
    TrackSignaling.prototype.setSid = function (sid) {
        if (this.sid === null) {
            this._sid = sid;
            this.emit('updated');
        }
        return this;
    };
    return TrackSignaling;
}(EventEmitter));
/**
 * Emitted whenever the {@link TrackSignaling} is updated
 * @event TrackSignaling#updated
 */
module.exports = TrackSignaling;
//# sourceMappingURL=track.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/cancelableroomsignalingpromise.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/cancelableroomsignalingpromise.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var CancelablePromise = __webpack_require__(/*! ../../util/cancelablepromise */ "./node_modules/twilio-video/es5/util/cancelablepromise.js");
var DefaultPeerConnectionManager = __webpack_require__(/*! ./peerconnectionmanager */ "./node_modules/twilio-video/es5/signaling/v2/peerconnectionmanager.js");
var DefaultRoomV2 = __webpack_require__(/*! ./room */ "./node_modules/twilio-video/es5/signaling/v2/room.js");
var DefaultRoomV3 = __webpack_require__(/*! ../v3/room */ "./node_modules/twilio-video/es5/signaling/v3/room.js");
var DefaultTransport = __webpack_require__(/*! ./twilioconnectiontransport */ "./node_modules/twilio-video/es5/signaling/v2/twilioconnectiontransport.js");
var _a = __webpack_require__(/*! ../../util/twilio-video-errors */ "./node_modules/twilio-video/es5/util/twilio-video-errors.js"), SignalingConnectionDisconnectedError = _a.SignalingConnectionDisconnectedError, SignalingIncomingMessageInvalidError = _a.SignalingIncomingMessageInvalidError;
var _b = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js"), flatMap = _b.flatMap, createRoomConnectEventPayload = _b.createRoomConnectEventPayload;
function createCancelableRoomSignalingPromise(token, wsServer, localParticipant, encodingParameters, preferredCodecs, options) {
    options = Object.assign({
        PeerConnectionManager: DefaultPeerConnectionManager,
        RoomV2: DefaultRoomV2,
        RoomV3: DefaultRoomV3,
        Transport: DefaultTransport
    }, options);
    var adaptiveSimulcast = preferredCodecs.video[0] && preferredCodecs.video[0].adaptiveSimulcast === true;
    var PeerConnectionManager = options.PeerConnectionManager, RoomV2 = options.RoomV2, RoomV3 = options.RoomV3, Transport = options.Transport, iceServers = options.iceServers, log = options.log;
    var peerConnectionManager = new PeerConnectionManager(encodingParameters, preferredCodecs, options);
    var trackSenders = flatMap(localParticipant.tracks, function (trackV2) { return [trackV2.trackTransceiver]; });
    peerConnectionManager.setTrackSenders(trackSenders);
    var cancellationError = new Error('Canceled');
    var transport;
    var cancelablePromise = new CancelablePromise(function (resolve, reject, isCanceled) {
        var onIced = function (iceServers) {
            if (isCanceled()) {
                reject(cancellationError);
                return Promise.reject(cancellationError);
            }
            log.debug('Got ICE servers:', iceServers);
            options.iceServers = iceServers;
            peerConnectionManager.setConfiguration(options);
            return peerConnectionManager.createAndOffer().then(function () {
                if (isCanceled()) {
                    reject(cancellationError);
                    throw cancellationError;
                }
                log.debug('createAndOffer() succeeded.');
                // NOTE(mmalavalli): PeerConnectionManager#createAndOffer() queues the
                // initial offer in the event queue for the 'description' event. So,
                // we are dequeueing to prevent the spurious 'update' message sent by
                // the client after connecting to a room.
                peerConnectionManager.dequeue('description');
            }).catch(function (error) {
                log.error('createAndOffer() failed:', error);
                reject(error);
                throw error;
            });
        };
        var automaticSubscription = options.automaticSubscription, bandwidthProfile = options.bandwidthProfile, dominantSpeaker = options.dominantSpeaker, environment = options.environment, eventObserver = options.eventObserver, loggerName = options.loggerName, logLevel = options.logLevel, name = options.name, networkMonitor = options.networkMonitor, networkQuality = options.networkQuality, realm = options.realm, sdpSemantics = options.sdpSemantics;
        // decide which msp channels to request
        // dominantSpeaker, networkQuality
        var trackPriority = !!bandwidthProfile;
        var trackSwitchOff = !!bandwidthProfile;
        var renderHints = !!bandwidthProfile &&
            (options.clientTrackSwitchOffControl !== 'disabled' || options.contentPreferencesMode !== 'disabled');
        var transportOptions = Object.assign({
            adaptiveSimulcast: adaptiveSimulcast,
            automaticSubscription: automaticSubscription,
            dominantSpeaker: dominantSpeaker,
            environment: environment,
            eventObserver: eventObserver,
            loggerName: loggerName,
            logLevel: logLevel,
            networkMonitor: networkMonitor,
            networkQuality: networkQuality,
            iceServers: iceServers,
            onIced: onIced,
            realm: realm,
            renderHints: renderHints,
            sdpSemantics: sdpSemantics,
            trackPriority: trackPriority,
            trackSwitchOff: trackSwitchOff
        }, bandwidthProfile ? {
            bandwidthProfile: bandwidthProfile
        } : {});
        transport = new Transport(name, token, localParticipant, peerConnectionManager, wsServer, transportOptions);
        var connectEventPayload = createRoomConnectEventPayload(options);
        eventObserver.emit('event', connectEventPayload);
        transport.once('connected', function (initialState) {
            log.debug('Transport connected:', initialState);
            if (isCanceled()) {
                reject(cancellationError);
                return;
            }
            var localParticipantState = initialState.participant;
            if (!localParticipantState) {
                reject(new SignalingIncomingMessageInvalidError());
                return;
            }
            var signalingRegion = initialState.options.signaling_region, version = initialState.version;
            localParticipant.setSignalingRegion(signalingRegion);
            var RoomSignaling = version === 3 ? RoomV3 : RoomV2;
            resolve(new RoomSignaling(localParticipant, initialState, transport, peerConnectionManager, options));
        });
        transport.once('stateChanged', function (state, error) {
            if (state === 'disconnected') {
                transport = null;
                reject(error || new SignalingConnectionDisconnectedError());
            }
            else {
                log.debug('Transport state changed:', state);
            }
        });
    }, function () {
        if (transport) {
            transport.disconnect();
            transport = null;
        }
    });
    cancelablePromise.catch(function () {
        if (transport) {
            transport.disconnect();
            transport = null;
        }
        peerConnectionManager.close();
    });
    return cancelablePromise;
}
module.exports = createCancelableRoomSignalingPromise;
//# sourceMappingURL=cancelableroomsignalingpromise.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/dominantspeakersignaling.js":
/*!********************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/dominantspeakersignaling.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaSignaling = __webpack_require__(/*! ./mediasignaling */ "./node_modules/twilio-video/es5/signaling/v2/mediasignaling.js");
/**
 * @property {?Track.SID} loudestParticipantSid
 * @emits DominantSpeakerSignaling#updated
 */
var DominantSpeakerSignaling = /** @class */ (function (_super) {
    __extends(DominantSpeakerSignaling, _super);
    /**
     * Construct an {@link DominantSpeakerSignaling}.
     */
    function DominantSpeakerSignaling(getReceiver, options) {
        var _this = _super.call(this, getReceiver, 'active_speaker', options) || this;
        Object.defineProperties(_this, {
            _loudestParticipantSid: {
                value: null,
                writable: true
            },
        });
        _this.on('ready', function (transport) {
            transport.on('message', function (message) {
                switch (message.type) {
                    case 'active_speaker':
                        _this._setLoudestParticipantSid(message.participant);
                        break;
                    default:
                        break;
                }
            });
        });
        return _this;
    }
    Object.defineProperty(DominantSpeakerSignaling.prototype, "loudestParticipantSid", {
        /**
         * Get the loudest {@link Track.SID}, if known.
         * @returns {?Track.SID}
         */
        get: function () {
            return this._loudestParticipantSid;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @private
     * @param {Track.SID} loudestParticipantSid
     * @returns {void}
     */
    DominantSpeakerSignaling.prototype._setLoudestParticipantSid = function (loudestParticipantSid) {
        if (this.loudestParticipantSid === loudestParticipantSid) {
            return;
        }
        this._loudestParticipantSid = loudestParticipantSid;
        this.emit('updated');
    };
    return DominantSpeakerSignaling;
}(MediaSignaling));
/**
 * @event DominantSpeakerSignaling#updated
 */
module.exports = DominantSpeakerSignaling;
//# sourceMappingURL=dominantspeakersignaling.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/icebox.js":
/*!**************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/icebox.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Filter = __webpack_require__(/*! ../../util/filter */ "./node_modules/twilio-video/es5/util/filter.js");
/**
 * An {@link IceBox} stores trickled ICE candidates. Candidates added to the
 * {@link IceBox} via {@link IceBox#update} are compared against previously
 * trickled candidates and only new candidates will be returned (assuming they
 * match the current ICE username fragment set by {@link IceBox#setUfrag}).
 * @property {?string} ufrag
 */
var IceBox = /** @class */ (function () {
    /**
     * Construct an {@link IceBox}.
     */
    function IceBox() {
        Object.defineProperties(this, {
            _filter: {
                value: new Filter({
                    getKey: function getKey(iceState) {
                        return iceState.ufrag;
                    },
                    isLessThanOrEqualTo: function isLessThanOrEqualTo(a, b) {
                        return a.revision <= b.revision;
                    }
                })
            },
            _ufrag: {
                writable: true,
                value: null
            },
            ufrag: {
                enumerable: true,
                get: function () {
                    return this._ufrag;
                }
            }
        });
    }
    /**
     * Set the ICE username fragment on the {@link IceBox}. This method returns any
     * ICE candidates associated with the username fragment.
     * @param {string} ufrag
     * @returns {Array<RTCIceCandidateInit>}
     */
    IceBox.prototype.setUfrag = function (ufrag) {
        this._ufrag = ufrag;
        var ice = this._filter.toMap().get(ufrag);
        return ice ? ice.candidates : [];
    };
    /**
     * Update the {@link IceBox}. This method returns any new ICE candidates
     * associated with the current username fragment.
     * @param {object} iceState
     * @returns {Array<RTCIceCandidateInit>}
     */
    IceBox.prototype.update = function (iceState) {
        // NOTE(mroberts): The Server sometimes does not set the candidates property.
        iceState.candidates = iceState.candidates || [];
        var oldIceState = this._filter.toMap().get(iceState.ufrag);
        var oldCandidates = oldIceState ? oldIceState.candidates : [];
        return this._filter.update(iceState) && this._ufrag === iceState.ufrag
            ? iceState.candidates.slice(oldCandidates.length)
            : [];
    };
    return IceBox;
}());
module.exports = IceBox;
//# sourceMappingURL=icebox.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/iceconnectionmonitor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/iceconnectionmonitor.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a = __webpack_require__(/*! ../../util/constants */ "./node_modules/twilio-video/es5/util/constants.js"), ICE_ACTIVITY_CHECK_PERIOD_MS = _a.ICE_ACTIVITY_CHECK_PERIOD_MS, ICE_INACTIVITY_THRESHOLD_MS = _a.ICE_INACTIVITY_THRESHOLD_MS;
/**
 * Monitors a {@link RTCPeerConnection}'s stats and notifies
 * caller when inactivity is detected.
 */
var IceConnectionMonitor = /** @class */ (function () {
    /**
     * Construct an {@link IceConnectionMonitor}.
     * @param {RTCPeerConnection} peerConnection
     * @param {object} [options]
     */
    function IceConnectionMonitor(peerConnection, options) {
        options = Object.assign({
            activityCheckPeriodMs: ICE_ACTIVITY_CHECK_PERIOD_MS,
            inactivityThresholdMs: ICE_INACTIVITY_THRESHOLD_MS,
        }, options);
        Object.defineProperties(this, {
            _activityCheckPeriodMs: {
                value: options.activityCheckPeriodMs
            },
            _inactivityThresholdMs: {
                value: options.inactivityThresholdMs
            },
            _lastActivity: {
                value: null,
                writable: true
            },
            _peerConnection: {
                value: peerConnection
            },
            _timer: {
                value: null,
                writable: true,
            },
            _onIceConnectionStateChanged: {
                value: null,
                writable: true
            }
        });
    }
    IceConnectionMonitor.prototype._getActivePairStat = function (stats) {
        var statsArray = Array.from(stats.values());
        var activePairStats = statsArray.find(function (stat) { return stat.type === 'candidate-pair' && stat.nominated; });
        // NOTE(mpatwardhan): sometimes (JSDK-2667) after getting disconnected while switching network
        // we may not find active pair. Treat this as 0 bytesReceived so that we count it towards inactivity.
        return activePairStats || {
            bytesReceived: 0,
            timestamp: Math.round((new Date()).getTime())
        };
    };
    /**
     * Get ICE connection stats, and extract received and send bytes.
     * @returns Promise<?RTCIceCandidatePairStats>
     */
    IceConnectionMonitor.prototype._getIceConnectionStats = function () {
        var _this = this;
        return this._peerConnection.getStats().then(function (stats) { return _this._getActivePairStat(stats); }).catch(function () {
            return null;
        });
    };
    /**
     * schedules/un-schedules inactivity callback.
     */
    IceConnectionMonitor.prototype._scheduleInactivityCallback = function (callback) {
        var _this = this;
        if (callback && this._onIceConnectionStateChanged === null) {
            // schedule callback
            this._onIceConnectionStateChanged = function () {
                if (_this._peerConnection.iceConnectionState === 'disconnected') {
                    // eslint-disable-next-line callback-return
                    callback();
                }
            };
            this._peerConnection.addEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);
        }
        else if (!callback && this._onIceConnectionStateChanged) {
            // unschedule callback
            this._peerConnection.removeEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);
            this._onIceConnectionStateChanged = null;
        }
    };
    /**
     * Start monitoring the ICE connection.
     * Monitors bytes received on active ice connection pair,
     * invokes onIceConnectionInactive when inactivity is detected.
     * @param {function} onIceConnectionInactive
     */
    IceConnectionMonitor.prototype.start = function (onIceConnectionInactive) {
        var _this = this;
        this.stop();
        this._timer = setInterval(function () {
            _this._getIceConnectionStats().then(function (iceStats) {
                if (!iceStats) {
                    return;
                }
                // NOTE(mpatwardhan): We look at bytesReceived on active candidate pair as an indication of active ice connection.
                // As per spec (https://w3c.github.io/webrtc-stats/#dom-rtcicecandidatepairstats-bytesreceived) this value
                // includes RTCP traffic and is +ve even when there are no tracks subscribed to.
                if (!_this._lastActivity || _this._lastActivity.bytesReceived !== iceStats.bytesReceived) {
                    _this._lastActivity = iceStats;
                    // detected activity, cancel scheduled callback if any.
                    _this._scheduleInactivityCallback(null);
                }
                if (iceStats.timestamp - _this._lastActivity.timestamp >= _this._inactivityThresholdMs) {
                    // detected inactivity.
                    if (_this._peerConnection.iceConnectionState === 'disconnected') {
                        onIceConnectionInactive();
                    }
                    else if (_this._onIceConnectionStateChanged === null) {
                        _this._scheduleInactivityCallback(onIceConnectionInactive);
                    }
                }
            });
        }, this._activityCheckPeriodMs);
    };
    /**
     * Stop monitoring the ICE connection state.
     * @returns {void}
     */
    IceConnectionMonitor.prototype.stop = function () {
        this._scheduleInactivityCallback(null);
        if (this._timer !== null) {
            clearInterval(this._timer);
            this._timer = null;
            this._lastActivity = null;
        }
    };
    return IceConnectionMonitor;
}());
module.exports = IceConnectionMonitor;
//# sourceMappingURL=iceconnectionmonitor.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var defaultCreateCancelableRoomSignalingPromise = __webpack_require__(/*! ./cancelableroomsignalingpromise */ "./node_modules/twilio-video/es5/signaling/v2/cancelableroomsignalingpromise.js");
var LocalParticipantV2 = __webpack_require__(/*! ./localparticipant */ "./node_modules/twilio-video/es5/signaling/v2/localparticipant.js");
var Signaling = __webpack_require__(/*! ../ */ "./node_modules/twilio-video/es5/signaling/index.js");
/**
 * {@link SignalingV2} implements version 2 of our signaling protocol.
 * @extends Signaling
 */
var SignalingV2 = /** @class */ (function (_super) {
    __extends(SignalingV2, _super);
    /**
     * Construct {@link SignalingV2}.
     * @param {string} wsServer
     * @param {?object} [options={}]
     */
    function SignalingV2(wsServer, options) {
        var _this = this;
        /* eslint new-cap:0 */
        options = Object.assign({
            createCancelableRoomSignalingPromise: defaultCreateCancelableRoomSignalingPromise
        }, options);
        _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _createCancelableRoomSignalingPromise: {
                value: options.createCancelableRoomSignalingPromise
            },
            _options: {
                value: options
            },
            _wsServer: {
                value: wsServer
            }
        });
        return _this;
    }
    /**
     * @private
     */
    SignalingV2.prototype._connect = function (localParticipant, token, encodingParameters, preferredCodecs, options) {
        options = Object.assign({}, this._options, options);
        return this._createCancelableRoomSignalingPromise.bind(null, token, this._wsServer, localParticipant, encodingParameters, preferredCodecs, options);
    };
    SignalingV2.prototype.createLocalParticipantSignaling = function (encodingParameters, networkQualityConfiguration) {
        return new LocalParticipantV2(encodingParameters, networkQualityConfiguration);
    };
    return SignalingV2;
}(Signaling));
module.exports = SignalingV2;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/localparticipant.js":
/*!************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/localparticipant.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalParticipantSignaling = __webpack_require__(/*! ../localparticipant */ "./node_modules/twilio-video/es5/signaling/localparticipant.js");
var LocalTrackPublicationV2 = __webpack_require__(/*! ./localtrackpublication */ "./node_modules/twilio-video/es5/signaling/v2/localtrackpublication.js");
var DEFAULT_LOG_LEVEL = __webpack_require__(/*! ../../util/constants */ "./node_modules/twilio-video/es5/util/constants.js").DEFAULT_LOG_LEVEL;
var Log = __webpack_require__(/*! ../../util/log */ "./node_modules/twilio-video/es5/util/log.js");
var _a = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js"), buildLogLevels = _a.buildLogLevels, isDeepEqual = _a.isDeepEqual;
/**
 * @extends ParticipantSignaling
 * @property {BandwidthProfile} bandwidthProfile
 * @property {NetworkQualityConfigurationImpl} networkQualityConfiguration
 * @property {number} revision
 * @emits LocalParticipantV2#updated
 */
var LocalParticipantV2 = /** @class */ (function (_super) {
    __extends(LocalParticipantV2, _super);
    /**
     * Construct a {@link LocalParticipantV2}.
     * @param {EncodingParametersImpl} encodingParameters
     * @param {NetworkQualityConfigurationImpl} networkQualityConfiguration
     * @param {object} [options]
     */
    function LocalParticipantV2(encodingParameters, networkQualityConfiguration, options) {
        var _this = this;
        options = Object.assign({
            logLevel: DEFAULT_LOG_LEVEL,
            LocalTrackPublicationV2: LocalTrackPublicationV2
        }, options);
        _this = _super.call(this) || this;
        var logLevels = buildLogLevels(options.logLevel);
        Object.defineProperties(_this, {
            _bandwidthProfile: {
                value: null,
                writable: true
            },
            _bandwidthProfileRevision: {
                value: 0,
                writable: true
            },
            _encodingParameters: {
                value: encodingParameters
            },
            _removeListeners: {
                value: new Map()
            },
            _LocalTrackPublicationV2: {
                value: options.LocalTrackPublicationV2
            },
            _log: {
                value: options.log
                    ? options.log.createLog('default', _this)
                    : new Log('default', _this, logLevels, options.loggerName)
            },
            _publishedRevision: {
                writable: true,
                value: 0
            },
            _revision: {
                writable: true,
                value: 1
            },
            _signalingRegion: {
                value: null,
                writable: true
            },
            bandwidthProfile: {
                enumerable: true,
                get: function () {
                    return this._bandwidthProfile;
                }
            },
            bandwidthProfileRevision: {
                enumerable: true,
                get: function () {
                    return this._bandwidthProfileRevision;
                }
            },
            networkQualityConfiguration: {
                enumerable: true,
                value: networkQualityConfiguration
            },
            revision: {
                enumerable: true,
                get: function () {
                    return this._revision;
                }
            },
            signalingRegion: {
                enumerable: true,
                get: function () {
                    return this._signalingRegion;
                }
            }
        });
        return _this;
    }
    LocalParticipantV2.prototype.toString = function () {
        return "[LocalParticipantSignaling: " + this.sid + "]";
    };
    /**
     * Set the signalingRegion.
     * @param {string} signalingRegion.
     */
    LocalParticipantV2.prototype.setSignalingRegion = function (signalingRegion) {
        if (!this._signalingRegion) {
            this._signalingRegion = signalingRegion;
        }
    };
    /**
     * Update the {@link BandwidthProfile}.
     * @param {BandwidthProfile} bandwidthProfile
     */
    LocalParticipantV2.prototype.setBandwidthProfile = function (bandwidthProfile) {
        if (!isDeepEqual(this._bandwidthProfile, bandwidthProfile)) {
            // NOTE(mmalavalli): Object.assign() copies the values of only
            // the top level properties. In order to deep copy the object, we
            // stringify and parse the object.
            this._bandwidthProfile = JSON.parse(JSON.stringify(bandwidthProfile));
            this._bandwidthProfileRevision++;
            this.didUpdate();
        }
    };
    /**
     * returns current {@link EncodingParametersImpl}.
     * @returns {EncodingParametersImpl}
     */
    LocalParticipantV2.prototype.getParameters = function () {
        return this._encodingParameters;
    };
    /**
     * Set the {@link EncodingParameters}.
     * @param {?EncodingParameters} encodingParameters
     * @returns {this}
     */
    LocalParticipantV2.prototype.setParameters = function (encodingParameters) {
        this._encodingParameters.update(encodingParameters);
        return this;
    };
    /**
     * Update the {@link LocalParticipantV2} with the new state.
     * @param {Published} published
     * @returns {this}
     */
    LocalParticipantV2.prototype.update = function (published) {
        if (this._publishedRevision >= published.revision) {
            return this;
        }
        this._publishedRevision = published.revision;
        published.tracks.forEach(function (publicationState) {
            var localTrackPublicationV2 = this.tracks.get(publicationState.id);
            if (localTrackPublicationV2) {
                localTrackPublicationV2.update(publicationState);
            }
        }, this);
        return this;
    };
    /**
     * @protected
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @param {string} name
     * @param {Track.Priority} priority
     * @returns {LocalTrackPublicationV2}
     */
    LocalParticipantV2.prototype._createLocalTrackPublicationSignaling = function (trackSender, name, priority) {
        return new this._LocalTrackPublicationV2(trackSender, name, priority);
    };
    /**
     * Add a {@link LocalTrackPublicationV2} for the given {@link DataTrackSender}
     * or {@link MediaTrackSender} to the {@link LocalParticipantV2}.
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @param {string} name
     * @param {Track.Priority} priority
     * @returns {this}
     */
    LocalParticipantV2.prototype.addTrack = function (trackSender, name, priority) {
        var _this = this;
        _super.prototype.addTrack.call(this, trackSender, name, priority);
        var publication = this.getPublication(trackSender);
        var isEnabled = publication.isEnabled, updatedPriority = publication.updatedPriority;
        var updated = function () {
            // NOTE(mmalavalli): The LocalParticipantV2's state is only published if
            // the "updated" event is emitted due to LocalTrackPublicationV2's
            // .isEnabled or .updatedPriority being changed. We do not publish if it is fired due to the
            // LocalTrackPublicationV2's .sid being set.
            if (isEnabled !== publication.isEnabled || updatedPriority !== publication.updatedPriority) {
                _this.didUpdate();
                isEnabled = publication.isEnabled;
                updatedPriority = publication.updatedPriority;
            }
        };
        publication.on('updated', updated);
        this._removeListener(publication);
        this._removeListeners.set(publication, function () { return publication.removeListener('updated', updated); });
        this.didUpdate();
        return this;
    };
    /**
     * @private
     * @param {LocalTrackPublicationV2} publication
     * @returns {void}
     */
    LocalParticipantV2.prototype._removeListener = function (publication) {
        var removeListener = this._removeListeners.get(publication);
        if (removeListener) {
            removeListener();
        }
    };
    /**
     * Get the current state of the {@link LocalParticipantV2}.
     * @returns {object}
     */
    LocalParticipantV2.prototype.getState = function () {
        return {
            revision: this.revision,
            tracks: Array.from(this.tracks.values()).map(function (track) { return track.getState(); })
        };
    };
    /**
     * Increment the revision for the {@link LocalParticipantV2}.
     * @private
     * @returns {void}
     */
    LocalParticipantV2.prototype.didUpdate = function () {
        this._revision++;
        this.emit('updated');
    };
    /**
     * Remove the {@link LocalTrackPublicationV2} for the given {@link DataTrackSender}
     * or {@link MediaTrackSender} from the {@link LocalParticipantV2}.
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @returns {?LocalTrackPublicationV2}
     */
    LocalParticipantV2.prototype.removeTrack = function (trackSender) {
        var publication = _super.prototype.removeTrack.call(this, trackSender);
        if (publication) {
            trackSender.removeClone(publication.trackTransceiver);
            this._removeListener(publication);
            this.didUpdate();
        }
        return publication;
    };
    /**
     * Updates the verbosity of network quality information.
     * @param {NetworkQualityConfiguration} networkQualityConfiguration
     * @returns {void}
     */
    LocalParticipantV2.prototype.setNetworkQualityConfiguration = function (networkQualityConfiguration) {
        this.networkQualityConfiguration.update(networkQualityConfiguration);
    };
    /**
     * updates encodings for simulcast layers.
     * @param {Track.SID} trackSid
     * @param {Array<{enabled: boolean, layer_index: number}>} encodings
     * @returns {Promise<string>} string indicating result of the operation. can be one of
     *  "OK", "INVALID_HINT", "COULD_NOT_APPLY_HINT", "UNKNOWN_TRACK"
     */
    LocalParticipantV2.prototype.setPublisherHint = function (trackSid, encodings) {
        var trackSignaling = Array.from(this.tracks.values()).find(function (trackPub) { return trackPub.sid === trackSid; });
        if (!trackSignaling) {
            this._log.warn("track:" + trackSid + " not found");
            return Promise.resolve('UNKNOWN_TRACK');
        }
        return trackSignaling.trackTransceiver.setPublisherHint(encodings);
    };
    return LocalParticipantV2;
}(LocalParticipantSignaling));
/**
 * @interface Published
 * @property {number} revision
 * @property {Array<PublishedTrack>} tracks
 */
/**
 * @typedef {CreatedTrack|ReadyTrack|FailedTrack} PublishedTrack
 */
/**
 * @interface CreatedTrack
 * @property {Track.ID} id
 * @property {string} state - "created"
 */
/**
 * @interface ReadyTrack
 * @property {Track.ID} id
 * @property {Track.SID} sid
 * @property {string} state - "ready"
 */
/**
 * @interface FailedTrack
 * @property {Track.ID} id
 * @property {TrackError} error
 * @property {string} state - "failed"
 */
/**
 * @interface TrackError
 * @property {number} code
 * @property {string} message
 */
/**
 * @event LocalParticipantV2#updated
 */
module.exports = LocalParticipantV2;
//# sourceMappingURL=localparticipant.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/localtrackpublication.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/localtrackpublication.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalTrackPublicationSignaling = __webpack_require__(/*! ../localtrackpublication */ "./node_modules/twilio-video/es5/signaling/localtrackpublication.js");
var createTwilioError = __webpack_require__(/*! ../../util/twilio-video-errors */ "./node_modules/twilio-video/es5/util/twilio-video-errors.js").createTwilioError;
/**
 * @extends LocalTrackPublicationSignaling
 */
var LocalTrackPublicationV2 = /** @class */ (function (_super) {
    __extends(LocalTrackPublicationV2, _super);
    /**
     * Construct a {@link LocalTrackPublicationV2}.
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @param {string} name
     * @param {Track.Priority} priority
     */
    function LocalTrackPublicationV2(trackSender, name, priority) {
        return _super.call(this, trackSender, name, priority) || this;
    }
    /**
     * Get the {@link LocalTrackPublicationV2#Representation} of a given {@link TrackSignaling}.
     * @returns {LocalTrackPublicationV2#Representation} - without the SID
     */
    LocalTrackPublicationV2.prototype.getState = function () {
        return {
            enabled: this.isEnabled,
            id: this.id,
            kind: this.kind,
            name: this.name,
            priority: this.updatedPriority
        };
    };
    /**
     * Compare the {@link LocalTrackPublicationV2} to a {@link LocalTrackPublicationV2#Representation} of itself
     * and perform any updates necessary.
     * @param {PublishedTrack} track
     * @returns {this}
     * @fires TrackSignaling#updated
     */
    LocalTrackPublicationV2.prototype.update = function (track) {
        switch (track.state) {
            case 'ready':
                this.setSid(track.sid);
                break;
            case 'failed': {
                var error = track.error;
                this.publishFailed(createTwilioError(error.code, error.message));
                break;
            }
            default: // 'created'
                break;
        }
        return this;
    };
    return LocalTrackPublicationV2;
}(LocalTrackPublicationSignaling));
/**
 * The Room Signaling Protocol (RSP) representation of a {@link LocalTrackPublicationV2}.
 * @typedef {object} LocalTrackPublicationV2#Representation
 * @property {boolean} enabled
 * @property {Track.ID} id
 * @property {Track.Kind} kind
 * @property {string} name
 * @priority {Track.Priority} priority
 * @property {Track.SID} sid
 */
module.exports = LocalTrackPublicationV2;
//# sourceMappingURL=localtrackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/mediasignaling.js":
/*!**********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/mediasignaling.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint callback-return:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var nInstances = 0;
var MediaSignaling = /** @class */ (function (_super) {
    __extends(MediaSignaling, _super);
    /**
     * Construct a {@link MediaSignaling}.
     * @param {Promise<DataTrackReceiver>} getReceive
     * @param {string} channel
     */
    function MediaSignaling(getReceiver, channel, options) {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _instanceId: {
                value: nInstances++
            },
            channel: {
                value: channel,
            },
            _log: {
                value: options.log.createLog('default', _this)
            },
            _getReceiver: {
                value: getReceiver
            },
            _receiverPromise: {
                value: null,
                writable: true,
            },
            _transport: {
                value: null,
                writable: true
            }
        });
        return _this;
    }
    Object.defineProperty(MediaSignaling.prototype, "isSetup", {
        get: function () {
            return !!this._receiverPromise;
        },
        enumerable: false,
        configurable: true
    });
    MediaSignaling.prototype.toString = function () {
        return "[MediaSignaling #" + this._instanceId + ":" + this.channel + "]";
    };
    MediaSignaling.prototype.setup = function (id) {
        var _this = this;
        this._teardown();
        this._log.info('setting up msp transport for id:', id);
        var receiverPromise = this._getReceiver(id).then(function (receiver) {
            if (receiver.kind !== 'data') {
                _this._log.error('Expected a DataTrackReceiver');
            }
            if (_this._receiverPromise !== receiverPromise) {
                return;
            }
            try {
                _this._transport = receiver.toDataTransport();
                _this.emit('ready', _this._transport);
            }
            catch (ex) {
                _this._log.error("Failed to toDataTransport: " + ex.message);
            }
            receiver.once('close', function () { return _this._teardown(); });
        });
        this._receiverPromise = receiverPromise;
    };
    MediaSignaling.prototype._teardown = function () {
        if (this._transport) {
            this._log.info('Tearing down');
            this._transport = null;
            this._receiverPromise = null;
            this.emit('teardown');
        }
    };
    return MediaSignaling;
}(EventEmitter));
module.exports = MediaSignaling;
//# sourceMappingURL=mediasignaling.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/networkqualitymonitor.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/networkqualitymonitor.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint callback-return:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var PeerConnectionReportFactory = __webpack_require__(/*! ../../stats/peerconnectionreportfactory */ "./node_modules/twilio-video/es5/stats/peerconnectionreportfactory.js");
/**
 * @emits NetworkQualityMonitor#updated
 */
var NetworkQualityMonitor = /** @class */ (function (_super) {
    __extends(NetworkQualityMonitor, _super);
    /**
     * Construct a {@link NetworkQualityMonitor}.
     * @param {PeerConnectionManager} manager
     * @param {NetworkQualitySignaling} signaling
     */
    function NetworkQualityMonitor(manager, signaling) {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _factories: {
                value: new WeakMap()
            },
            _manager: {
                value: manager
            },
            _signaling: {
                value: signaling
            }
        });
        signaling.on('updated', function () { return _this.emit('updated'); });
        return _this;
    }
    Object.defineProperty(NetworkQualityMonitor.prototype, "level", {
        /**
         * Get the current {@link NetworkQualityLevel}, if any.
         * @returns {?NetworkQualityLevel} level - initially null
         */
        get: function () {
            return this._signaling.level;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NetworkQualityMonitor.prototype, "levels", {
        /**
         * Get the current {@link NetworkQualityLevels}, if any.
         * @returns {?NetworkQualityLevels} levels - initially null
         */
        get: function () {
            return this._signaling.levels;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NetworkQualityMonitor.prototype, "remoteLevels", {
        /**
         * Get the current {@link NetworkQualityLevels} of remote participants, if any.
         * @returns {Map<String, NetworkQualityLevels>} remoteLevels
         */
        get: function () {
            return this._signaling.remoteLevels;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Start monitoring.
     * @returns {void}
     */
    NetworkQualityMonitor.prototype.start = function () {
        var _this = this;
        this.stop();
        var timeout = setTimeout(function () {
            if (_this._timeout !== timeout) {
                return;
            }
            next(_this).then(function (reports) {
                if (_this._timeout !== timeout) {
                    return;
                }
                if (reports.length) {
                    var _a = __read(reports, 1), report = _a[0];
                    _this._signaling.put(report);
                }
                _this.start();
            });
        }, 200);
        this._timeout = timeout;
    };
    /**
     * Stop monitoring.
     * @returns {void}
     */
    NetworkQualityMonitor.prototype.stop = function () {
        clearTimeout(this._timeout);
        this._timeout = null;
    };
    return NetworkQualityMonitor;
}(EventEmitter));
/**
 * @param {NetworkQualityMonitor}
 * @returns {Promise<NetworkQualityInputs>}
 */
function next(monitor) {
    var pcv2s = monitor._manager._peerConnections
        ? Array.from(monitor._manager._peerConnections.values())
        : [];
    var pcs = pcv2s
        .map(function (pcv2) { return pcv2._peerConnection; })
        .filter(function (pc) { return pc.signalingState !== 'closed'; });
    var factories = pcs.map(function (pc) {
        if (monitor._factories.has(pc)) {
            return monitor._factories.get(pc);
        }
        var factory = new PeerConnectionReportFactory(pc);
        monitor._factories.set(pc, factory);
        return factory;
    });
    var reportsOrNullPromises = factories.map(function (factory) { return factory.next().catch(function () { return null; }); });
    return Promise.all(reportsOrNullPromises).then(function (reportsOrNull) { return reportsOrNull
        .filter(function (reportOrNull) { return reportOrNull; })
        .map(function (report) { return report.summarize(); }); });
}
/**
 * The {@link NetworkQualityLevel} changed.
 * @event NetworkQualityMonitor#updated
 */
module.exports = NetworkQualityMonitor;
//# sourceMappingURL=networkqualitymonitor.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/networkqualitysignaling.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/networkqualitysignaling.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaSignaling = __webpack_require__(/*! ./mediasignaling */ "./node_modules/twilio-video/es5/signaling/v2/mediasignaling.js");
var AsyncVar = __webpack_require__(/*! ../../util/asyncvar */ "./node_modules/twilio-video/es5/util/asyncvar.js");
var Timeout = __webpack_require__(/*! ../../util/timeout */ "./node_modules/twilio-video/es5/util/timeout.js");
var NETWORK_QUALITY_RESPONSE_TIME_MS = 5000;
/**
 * @interface MediaSignalingTransport
 * @property {function(object): boolean} send
 * @emits MediaSignalingTransport#message
 */
/**
 * The {@link MediaSignalingTransport} received a message.
 * @event MediaSignalingTransport#message
 * @param {object} message
 */
/**
 * @interface LatencyStats
 * @property {number} jitter
 * @property {number} rtt
 * @property {number} level
 */
/**
 * @interface FractionLostStats
 * @property {number} fractionLost
 * @property {number} level
 */
/**
 * @interface BandwidthStats
 * @property {number} actual
 * @property {number} available
 * @property {number} level
 */
/**
 * @interface SendOrRecvStats
 * @property {BandwidthStats} bandwidth
 * @property {FractionLostStats} fractionLost
 * @property {LatencyStats} latency
 */
/**
 * @interface MediaLevels
 * @property {number} send
 * @property {SendOrRecvStats} sendStats
 * @property {number} recv
 * @property {SendOrRecvStats} recvStats
 */
/**
 * @interface NetworkQualityLevels
 * @property {number} level
 * @property {MediaLevels} audio
 * @property {MediaLevels} video
 */
/**
 * @typedef {PeerConnectionSummary} NetworkQualityInputs
 */
/**
 * @classdesc The {@link NetworkQualitySignaling} class allows submitting
 *   {@link NetworkQualityInputs} for computing {@link NetworkQualityLevel}. It
 *   does so by sending and receiving messages over a
 *   {@link MediaSignalingTransport}. The exact transport used depends on the
 *   topology of the {@link Room} that {@link NetworkQualitySignaling} is being
 *   used within: for P2P Rooms, we re-use the {@link TransportV2}; and for
 *   Group Rooms, we use a {@link DataTransport}.
 * @emits NetworkQualitySignaling#updated
 */
var NetworkQualitySignaling = /** @class */ (function (_super) {
    __extends(NetworkQualitySignaling, _super);
    /**
     * Construct a {@link NetworkQualitySignaling}.
     * @param {Promise<DataTrackReceiver>} getReceiver
     * @param {NetworkQualityConfigurationImpl} networkQualityConfiguration
     */
    function NetworkQualitySignaling(getReceiver, networkQualityConfiguration, options) {
        var _this = _super.call(this, getReceiver, 'network_quality', options) || this;
        Object.defineProperties(_this, {
            _level: {
                value: null,
                writable: true
            },
            _levels: {
                value: null,
                writable: true
            },
            _remoteLevels: {
                value: new Map(),
                writable: true
            },
            _networkQualityInputs: {
                value: new AsyncVar()
            },
            _resendTimer: {
                value: new Timeout(function () {
                    // and schedule next timer at x1.5 the delay..
                    _this._resendTimer.setDelay(_this._resendTimer.delay * 1.5);
                    _this._sendNetworkQualityInputs();
                }, NETWORK_QUALITY_RESPONSE_TIME_MS, false),
            },
            _networkQualityReportLevels: {
                get: function () {
                    return {
                        reportLevel: networkQualityConfiguration.local,
                        remoteReportLevel: networkQualityConfiguration.remote
                    };
                }
            }
        });
        _this.on('ready', function (transport) {
            transport.on('message', function (message) {
                _this._log.debug('Incoming: ', message);
                switch (message.type) {
                    case 'network_quality':
                        _this._handleNetworkQualityMessage(message);
                        break;
                    default:
                        break;
                }
            });
        });
        _this._sendNetworkQualityInputs();
        return _this;
    }
    Object.defineProperty(NetworkQualitySignaling.prototype, "level", {
        /**
         * Get the current {@link NetworkQualityLevel}, if any.
         * @returns {?NetworkQualityLevel} level - initially null
         */
        get: function () {
            return this._level;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NetworkQualitySignaling.prototype, "levels", {
        /**
         * Get the current {@link NetworkQualityLevels}, if any.
         * @returns {?NetworkQualityLevels} levels - initially null
         */
        get: function () {
            return this._levels;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NetworkQualitySignaling.prototype, "remoteLevels", {
        /**
         * Get the current {@link NetworkQualityLevels} of remote participants, if any.
         * @returns {Map<String, NetworkQualityLevels>} remoteLevels
         */
        get: function () {
            return this._remoteLevels;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Check to see if the {@link NetworkQualityLevel} is new, and raise an
     * event if necessary.
     * @private
     * @param {object} message
     * @returns {void}
     */
    NetworkQualitySignaling.prototype._handleNetworkQualityMessage = function (message) {
        var _this = this;
        var updated = false;
        var level = null;
        var local = message ? message.local : null;
        if (typeof local === 'number') {
            // NOTE(mroberts): In prod, we plan to only send the level.
            level = local;
            this._levels = null;
        }
        else if (typeof local === 'object' && local) {
            // NOTE(mroberts): In dev, we plan to send the decomposed levels. An early
            // VMS version does not compute `level` for us, so we fallback to taking
            // the minimum ourselves.
            this._levels = local;
            level = typeof local.level === 'number'
                ? local.level
                : Math.min(local.audio.send, local.audio.recv, local.video.send, local.video.recv);
        }
        if (level !== null && this.level !== level) {
            this._level = level;
            updated = true;
        }
        this._remoteLevels = message && message.remotes
            ? message.remotes.reduce(function (levels, obj) {
                var oldObj = _this._remoteLevels.get(obj.sid) || {};
                if (oldObj.level !== obj.level) {
                    updated = true;
                }
                return levels.set(obj.sid, obj);
            }, new Map())
            : this._remoteLevels;
        if (updated) {
            this.emit('updated');
        }
        // score is received. so reset the timer to default timeout.
        this._resendTimer.setDelay(NETWORK_QUALITY_RESPONSE_TIME_MS);
        // timer is cleared only while we are sending inputs.
        // if we are already sending inputs do not send them again.
        if (this._resendTimer.isSet) {
            setTimeout(function () { return _this._sendNetworkQualityInputs(); }, 1000);
        }
    };
    /**
     * Start sending {@link NetworkQualityInputs}.
     * @private
     * @returns {Promise<void>}
     */
    NetworkQualitySignaling.prototype._sendNetworkQualityInputs = function () {
        var _this = this;
        this._resendTimer.clear();
        return this._networkQualityInputs.take().then(function (networkQualityInputs) {
            if (_this._transport) {
                _this._transport.publish(createNetworkQualityInputsMessage(networkQualityInputs, _this._networkQualityReportLevels));
            }
        }).finally(function () {
            _this._resendTimer.start();
        });
    };
    /**
     * Put {@link NetworkQualityInputs} to be used for computing
     * {@link NetworkQualityLevel}.
     * @param {NetworkQualityInputs} networkQualityInputs
     * @returns {void}
     */
    NetworkQualitySignaling.prototype.put = function (networkQualityInputs) {
        this._networkQualityInputs.put(networkQualityInputs);
    };
    return NetworkQualitySignaling;
}(MediaSignaling));
/**
 * The {@link NetworkQualityLevel} changed.
 * @event NetworkQualitySignaling#updated
 */
/**
 * @typedef {object} NetworkQualityReportLevels
 * @param {number} reportLevel
 * @param {number} remoteReportLevel
 */
/**
 * @param {NetworkQualityInputs} networkQualityInputs
 * @param {NetworkQualityReportLevels} networkQualityReportLevels
 * @returns {object} message
 */
function createNetworkQualityInputsMessage(networkQualityInputs, networkQualityReportLevels) {
    return Object.assign({ type: 'network_quality' }, networkQualityInputs, networkQualityReportLevels);
}
module.exports = NetworkQualitySignaling;
//# sourceMappingURL=networkqualitysignaling.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/peerconnection.js":
/*!**********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/peerconnection.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var DefaultBackoff = __webpack_require__(/*! backoff */ "./node_modules/backoff/index.js");
var _a = __webpack_require__(/*! ../../webrtc */ "./node_modules/twilio-video/es5/webrtc/index.js"), DefaultRTCIceCandidate = _a.RTCIceCandidate, DefaultRTCPeerConnection = _a.RTCPeerConnection, DefaultRTCSessionDescription = _a.RTCSessionDescription, getStatistics = _a.getStats;
var util = __webpack_require__(/*! ../../webrtc/util */ "./node_modules/twilio-video/es5/webrtc/util/index.js");
var _b = __webpack_require__(/*! ../../util/constants */ "./node_modules/twilio-video/es5/util/constants.js"), DEFAULT_ICE_GATHERING_TIMEOUT_MS = _b.DEFAULT_ICE_GATHERING_TIMEOUT_MS, DEFAULT_LOG_LEVEL = _b.DEFAULT_LOG_LEVEL, DEFAULT_SESSION_TIMEOUT_SEC = _b.DEFAULT_SESSION_TIMEOUT_SEC, iceRestartBackoffConfig = _b.iceRestartBackoffConfig;
var _c = __webpack_require__(/*! ../../util/sdp */ "./node_modules/twilio-video/es5/util/sdp/index.js"), addOrRewriteNewTrackIds = _c.addOrRewriteNewTrackIds, addOrRewriteTrackIds = _c.addOrRewriteTrackIds, createCodecMapForMediaSection = _c.createCodecMapForMediaSection, disableRtx = _c.disableRtx, enableDtxForOpus = _c.enableDtxForOpus, filterLocalCodecs = _c.filterLocalCodecs, getMediaSections = _c.getMediaSections, removeSSRCAttributes = _c.removeSSRCAttributes, revertSimulcast = _c.revertSimulcast, setCodecPreferences = _c.setCodecPreferences, setSimulcast = _c.setSimulcast;
var DefaultTimeout = __webpack_require__(/*! ../../util/timeout */ "./node_modules/twilio-video/es5/util/timeout.js");
var _d = __webpack_require__(/*! ../../util/twilio-video-errors */ "./node_modules/twilio-video/es5/util/twilio-video-errors.js"), MediaClientLocalDescFailedError = _d.MediaClientLocalDescFailedError, MediaClientRemoteDescFailedError = _d.MediaClientRemoteDescFailedError;
var _e = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js"), buildLogLevels = _e.buildLogLevels, getPlatform = _e.getPlatform, isChromeScreenShareTrack = _e.isChromeScreenShareTrack, oncePerTick = _e.oncePerTick, defer = _e.defer;
var IceBox = __webpack_require__(/*! ./icebox */ "./node_modules/twilio-video/es5/signaling/v2/icebox.js");
var DefaultIceConnectionMonitor = __webpack_require__(/*! ./iceconnectionmonitor.js */ "./node_modules/twilio-video/es5/signaling/v2/iceconnectionmonitor.js");
var DataTrackReceiver = __webpack_require__(/*! ../../data/receiver */ "./node_modules/twilio-video/es5/data/receiver.js");
var MediaTrackReceiver = __webpack_require__(/*! ../../media/track/receiver */ "./node_modules/twilio-video/es5/media/track/receiver.js");
var StateMachine = __webpack_require__(/*! ../../statemachine */ "./node_modules/twilio-video/es5/statemachine.js");
var Log = __webpack_require__(/*! ../../util/log */ "./node_modules/twilio-video/es5/util/log.js");
var TrackMatcher = __webpack_require__(/*! ../../util/sdp/trackmatcher */ "./node_modules/twilio-video/es5/util/sdp/trackmatcher.js");
var workaroundIssue8329 = __webpack_require__(/*! ../../util/sdp/issue8329 */ "./node_modules/twilio-video/es5/util/sdp/issue8329.js");
var guess = util.guessBrowser();
var platform = getPlatform();
var isAndroid = /android/.test(platform);
var isChrome = guess === 'chrome';
var isFirefox = guess === 'firefox';
var isSafari = guess === 'safari';
var nInstances = 0;
/*
PeerConnectionV2 States
-----------------------

    +------+    +--------+
    |      |    |        |
    | open |--->| closed |
    |      |    |        |
    +------+    +--------+
      |  ^          ^
      |  |          |
      |  |          |
      v  |          |
  +----------+      |
  |          |      |
  | updating |------+
  |          |
  +----------+

*/
var states = {
    open: [
        'closed',
        'updating'
    ],
    updating: [
        'closed',
        'open'
    ],
    closed: []
};
/**
 * @extends StateMachine
 * @property {id}
 * @emits PeerConnectionV2#connectionStateChanged
 * @emits PeerConnectionV2#iceConnectionStateChanged
 * @emits PeerConnectionV2#candidates
 * @emits PeerConnectionV2#description
 */
var PeerConnectionV2 = /** @class */ (function (_super) {
    __extends(PeerConnectionV2, _super);
    /**
     * Construct a {@link PeerConnectionV2}.
     * @param {string} id
     * @param {EncodingParametersImpl} encodingParameters
     * @param {PreferredCodecs} preferredCodecs
     * @param {object} [options]
     */
    function PeerConnectionV2(id, encodingParameters, preferredCodecs, options) {
        var _this = _super.call(this, 'open', states) || this;
        options = Object.assign({
            enableDscp: false,
            dummyAudioMediaStreamTrack: null,
            isChromeScreenShareTrack: isChromeScreenShareTrack,
            iceServers: [],
            logLevel: DEFAULT_LOG_LEVEL,
            offerOptions: {},
            revertSimulcast: revertSimulcast,
            sessionTimeout: DEFAULT_SESSION_TIMEOUT_SEC * 1000,
            setCodecPreferences: setCodecPreferences,
            setSimulcast: setSimulcast,
            Backoff: DefaultBackoff,
            IceConnectionMonitor: DefaultIceConnectionMonitor,
            RTCIceCandidate: DefaultRTCIceCandidate,
            RTCPeerConnection: DefaultRTCPeerConnection,
            RTCSessionDescription: DefaultRTCSessionDescription,
            Timeout: DefaultTimeout
        }, options);
        var configuration = getConfiguration(options);
        var logLevels = buildLogLevels(options.logLevel);
        var RTCPeerConnection = options.RTCPeerConnection;
        if (options.enableDscp === true) {
            options.chromeSpecificConstraints = options.chromeSpecificConstraints || {};
            options.chromeSpecificConstraints.optional = options.chromeSpecificConstraints.optional || [];
            options.chromeSpecificConstraints.optional.push({ googDscp: true });
        }
        var log = options.log ? options.log.createLog('webrtc', _this) : new Log('webrtc', _this, logLevels, options.loggerName);
        var peerConnection = new RTCPeerConnection(configuration, options.chromeSpecificConstraints);
        if (options.dummyAudioMediaStreamTrack) {
            peerConnection.addTrack(options.dummyAudioMediaStreamTrack);
        }
        Object.defineProperties(_this, {
            _appliedTrackIdsToAttributes: {
                value: new Map(),
                writable: true
            },
            _dataChannels: {
                value: new Map()
            },
            _dataTrackReceivers: {
                value: new Set()
            },
            _descriptionRevision: {
                writable: true,
                value: 0
            },
            _didGenerateLocalCandidates: {
                writable: true,
                value: false
            },
            _enableDscp: {
                value: options.enableDscp
            },
            _encodingParameters: {
                value: encodingParameters
            },
            _isChromeScreenShareTrack: {
                value: options.isChromeScreenShareTrack,
            },
            _iceGatheringFailed: {
                value: false,
                writable: true
            },
            _iceGatheringTimeout: {
                value: new options.Timeout(function () { return _this._handleIceGatheringTimeout(); }, DEFAULT_ICE_GATHERING_TIMEOUT_MS, false)
            },
            _iceRestartBackoff: {
                value: options.Backoff.exponential(iceRestartBackoffConfig)
            },
            _instanceId: {
                value: ++nInstances
            },
            _isIceConnectionInactive: {
                writable: true,
                value: false
            },
            _isIceLite: {
                writable: true,
                value: false
            },
            _isIceRestartBackoffInProgress: {
                writable: true,
                value: false
            },
            _isRestartingIce: {
                writable: true,
                value: false
            },
            _lastIceConnectionState: {
                writable: true,
                value: null
            },
            _lastStableDescriptionRevision: {
                writable: true,
                value: 0
            },
            _localCandidates: {
                writable: true,
                value: []
            },
            _localCodecs: {
                value: new Set()
            },
            _localCandidatesRevision: {
                writable: true,
                value: 1
            },
            _localDescriptionWithoutSimulcast: {
                writable: true,
                value: null
            },
            _localDescription: {
                writable: true,
                value: null
            },
            _localUfrag: {
                writable: true,
                value: null
            },
            _log: {
                value: log
            },
            _eventObserver: {
                value: options.eventObserver
            },
            _remoteCodecMaps: {
                value: new Map()
            },
            _rtpSenders: {
                value: new Map()
            },
            _rtpNewSenders: {
                value: new Set()
            },
            _iceConnectionMonitor: {
                value: new options.IceConnectionMonitor(peerConnection)
            },
            _mediaTrackReceivers: {
                value: new Set()
            },
            _needsAnswer: {
                writable: true,
                value: false
            },
            _negotiationRole: {
                writable: true,
                value: null
            },
            _offerOptions: {
                writable: true,
                value: options.offerOptions
            },
            _onEncodingParametersChanged: {
                value: oncePerTick(function () {
                    if (!_this._needsAnswer) {
                        updateEncodingParameters(_this);
                    }
                })
            },
            _peerConnection: {
                value: peerConnection
            },
            _preferredAudioCodecs: {
                value: preferredCodecs.audio
            },
            _preferredVideoCodecs: {
                value: preferredCodecs.video
            },
            _shouldApplyDtx: {
                value: preferredCodecs.audio.every(function (_a) {
                    var codec = _a.codec;
                    return codec !== 'opus';
                })
                    || preferredCodecs.audio.some(function (_a) {
                        var codec = _a.codec, dtx = _a.dtx;
                        return codec === 'opus' && dtx;
                    })
            },
            _queuedDescription: {
                writable: true,
                value: null
            },
            _iceReconnectTimeout: {
                value: new options.Timeout(function () {
                    log.debug('ICE reconnect timed out');
                    _this.close();
                }, options.sessionTimeout, false)
            },
            _recycledTransceivers: {
                value: {
                    audio: [],
                    video: []
                }
            },
            _replaceTrackPromises: {
                value: new Map()
            },
            _remoteCandidates: {
                writable: true,
                value: new IceBox()
            },
            _setCodecPreferences: {
                // NOTE(mmalavalli): Re-ordering payload types in order to make sure a non-H264
                // preferred codec is selected does not work on Android Firefox due to this behavior:
                // https://bugzilla.mozilla.org/show_bug.cgi?id=1683258. So, we work around this by
                // not applying any non-H264 preferred video codec.
                value: isFirefox && isAndroid && preferredCodecs.video[0] && preferredCodecs.video[0].codec.toLowerCase() !== 'h264'
                    ? function (sdp) { return sdp; }
                    : options.setCodecPreferences
            },
            _setSimulcast: {
                value: options.setSimulcast
            },
            _revertSimulcast: {
                value: options.revertSimulcast
            },
            _RTCIceCandidate: {
                value: options.RTCIceCandidate
            },
            _RTCPeerConnection: {
                value: options.RTCPeerConnection
            },
            _RTCSessionDescription: {
                value: options.RTCSessionDescription
            },
            _shouldOffer: {
                writable: true,
                value: false
            },
            _shouldRestartIce: {
                writable: true,
                value: false
            },
            _trackIdsToAttributes: {
                value: new Map(),
                writable: true
            },
            _trackMatcher: {
                writable: true,
                value: null
            },
            _mediaTrackSenderToPublisherHints: {
                value: new Map()
            },
            id: {
                enumerable: true,
                value: id
            }
        });
        encodingParameters.on('changed', _this._onEncodingParametersChanged);
        peerConnection.addEventListener('connectionstatechange', _this._handleConnectionStateChange.bind(_this));
        peerConnection.addEventListener('datachannel', _this._handleDataChannelEvent.bind(_this));
        peerConnection.addEventListener('icecandidate', _this._handleIceCandidateEvent.bind(_this));
        peerConnection.addEventListener('iceconnectionstatechange', _this._handleIceConnectionStateChange.bind(_this));
        peerConnection.addEventListener('icegatheringstatechange', _this._handleIceGatheringStateChange.bind(_this));
        peerConnection.addEventListener('signalingstatechange', _this._handleSignalingStateChange.bind(_this));
        peerConnection.addEventListener('track', _this._handleTrackEvent.bind(_this));
        _this._iceRestartBackoff.on('ready', function () { return _this._initiateIceRestart(); });
        var self = _this;
        _this.on('stateChanged', function stateChanged(state) {
            if (state !== 'closed') {
                return;
            }
            self.removeListener('stateChanged', stateChanged);
            self._dataChannels.forEach(function (dataChannel, dataTrackSender) {
                self.removeDataTrackSender(dataTrackSender);
            });
        });
        return _this;
    }
    PeerConnectionV2.prototype.toString = function () {
        return "[PeerConnectionV2 #" + this._instanceId + ": " + this.id + "]";
    };
    PeerConnectionV2.prototype.setEffectiveAdaptiveSimulcast = function (effectiveAdaptiveSimulcast) {
        this._log.debug('Setting setEffectiveAdaptiveSimulcast: ', effectiveAdaptiveSimulcast);
        // clear adaptive simulcast from codec preferences if it was set.
        this._preferredVideoCodecs.forEach(function (cs) {
            if ('adaptiveSimulcast' in cs) {
                cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;
            }
        });
    };
    Object.defineProperty(PeerConnectionV2.prototype, "_shouldApplySimulcast", {
        get: function () {
            if (!isChrome && !isSafari) {
                return false;
            }
            // adaptiveSimulcast is set to false after connected message is received if other party does not support it.
            var simulcast = this._preferredVideoCodecs.some(function (cs) {
                return cs.codec.toLowerCase() === 'vp8' && cs.simulcast && cs.adaptiveSimulcast !== false;
            });
            return simulcast;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PeerConnectionV2.prototype, "connectionState", {
        /**
         * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's RTCPeerConnectionState
         * if supported by the browser, its RTCIceConnectionState otherwise.
         * @property {RTCPeerConnectionState}
         */
        get: function () {
            return this.iceConnectionState === 'failed'
                ? 'failed' : (this._peerConnection.connectionState || this.iceConnectionState);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PeerConnectionV2.prototype, "iceConnectionState", {
        /**
         * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's
         * RTCIceConnectionState.
         * @property {RTCIceConnectionState}
         */
        get: function () {
            return ((this._isIceConnectionInactive && this._peerConnection.iceConnectionState === 'disconnected') || this._iceGatheringFailed)
                ? 'failed' : this._peerConnection.iceConnectionState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PeerConnectionV2.prototype, "isApplicationSectionNegotiated", {
        /**
         * Whether the {@link PeerConnectionV2} has negotiated or is in the process
         * of negotiating the application m= section.
         * @returns {boolean}
         */
        get: function () {
            if (this._peerConnection.signalingState !== 'closed') {
                // accessing .localDescription in 'closed' state causes it throw exceptions.
                return this._peerConnection.localDescription
                    ? getMediaSections(this._peerConnection.localDescription.sdp, 'application').length > 0
                    : false;
            }
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PeerConnectionV2.prototype, "_isAdaptiveSimulcastEnabled", {
        /**
         * Whether adaptive simulcast is enabled.
         * @returns {boolean}
         */
        get: function () {
            var adaptiveSimulcastEntry = this._preferredVideoCodecs.find(function (cs) { return 'adaptiveSimulcast' in cs; });
            return adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === true;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @param {MediaStreamTrack} track
     * @param {Array<RTCRtpEncodingParameters>} encodings
     * @param {boolean} trackReplaced
     * @returns {boolean} true if encodings were updated.
     */
    PeerConnectionV2.prototype._maybeUpdateEncodings = function (track, encodings, trackReplaced) {
        if (trackReplaced === void 0) { trackReplaced = false; }
        if (track.kind !== 'video') {
            return false;
        }
        var browser = util.guessBrowser();
        // Note(mpatwardhan): always configure encodings for safari.
        // for chrome only when adaptive simulcast enabled.
        if (browser === 'safari' || (browser === 'chrome' && this._isAdaptiveSimulcastEnabled)) {
            this._updateEncodings(track, encodings, trackReplaced);
            return true;
        }
        return false;
    };
    /**
     * Configures with default encodings depending on track type and resolution.
     * Default configuration sets some encodings to disabled, and for others set scaleResolutionDownBy
     * values. When trackReplaced is set to true, it will clear 'active' for any encodings that
     * needs to be enabled.
     * @param {MediaStreamTrack} track
     * @param {Array<RTCRtpEncodingParameters>} encodings
     * @param {boolean} trackReplaced
     */
    PeerConnectionV2.prototype._updateEncodings = function (track, encodings, trackReplaced) {
        if (this._isChromeScreenShareTrack(track)) {
            var screenShareActiveLayerConfig_1 = [
                { scaleResolutionDownBy: 1 },
                { scaleResolutionDownBy: 1 }
            ];
            encodings.forEach(function (encoding, i) {
                var activeLayerConfig = screenShareActiveLayerConfig_1[i];
                if (activeLayerConfig) {
                    encoding.scaleResolutionDownBy = activeLayerConfig.scaleResolutionDownBy;
                    if (trackReplaced) {
                        delete encoding.active;
                    }
                }
                else {
                    encoding.active = false;
                    delete encoding.scaleResolutionDownBy;
                }
            });
        }
        else {
            var _a = track.getSettings(), width = _a.width, height = _a.height;
            // NOTE(mpatwardhan): for non-screen share tracks
            // enable layers depending on track resolutions
            var pixelsToMaxActiveLayers = [
                { pixels: 960 * 540, maxActiveLayers: 3 },
                { pixels: 480 * 270, maxActiveLayers: 2 },
                { pixels: 0, maxActiveLayers: 1 }
            ];
            var trackPixels_1 = width * height;
            var activeLayersInfo = pixelsToMaxActiveLayers.find(function (layer) { return trackPixels_1 >= layer.pixels; });
            var activeLayers_1 = Math.min(encodings.length, activeLayersInfo.maxActiveLayers);
            encodings.forEach(function (encoding, i) {
                var enabled = i < activeLayers_1;
                if (enabled) {
                    encoding.scaleResolutionDownBy = 1 << (activeLayers_1 - i - 1);
                    if (trackReplaced) {
                        encoding.active = true;
                    }
                }
                else {
                    encoding.active = false;
                    delete encoding.scaleResolutionDownBy;
                }
            });
        }
        this._log.debug('_updateEncodings:', encodings.map(function (_a, i) {
            var active = _a.active, scaleResolutionDownBy = _a.scaleResolutionDownBy;
            return "[" + i + ": " + active + ", " + (scaleResolutionDownBy || 0) + "]";
        }).join(', '));
    };
    /**
     * Add an ICE candidate to the {@link PeerConnectionV2}.
     * @private
     * @param {object} candidate
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._addIceCandidate = function (candidate) {
        var _this = this;
        return Promise.resolve().then(function () {
            candidate = new _this._RTCIceCandidate(candidate);
            return _this._peerConnection.addIceCandidate(candidate);
        }).catch(function (error) {
            // NOTE(mmalavalli): Firefox 68+ now generates an RTCIceCandidate with an
            // empty candidate string to signal end-of-candidates, followed by a null
            // candidate. As of now, Chrome and Safari reject this RTCIceCandidate. Since
            // this does not affect the media connection between Firefox 68+ and Chrome/Safari
            // in Peer-to-Peer Rooms, we suppress the Error and log a warning message.
            //
            // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=978582
            //
            _this._log.warn("Failed to add RTCIceCandidate " + (candidate ? "\"" + candidate.candidate + "\"" : 'null') + ": "
                + error.message);
        });
    };
    /**
     * Add ICE candidates to the {@link PeerConnectionV2}.
     * @private
     * @param {Array<object>} candidates
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._addIceCandidates = function (candidates) {
        return Promise.all(candidates.map(this._addIceCandidate, this)).then(function () { });
    };
    /**
     * Add a new RTCRtpTransceiver or update an existing RTCRtpTransceiver for the
     * given MediaStreamTrack.
     * @private
     * @param {MediaStreamTrack} track
     * @returns {RTCRtpTransceiver}
     */
    PeerConnectionV2.prototype._addOrUpdateTransceiver = function (track) {
        var _this = this;
        var transceiver = takeRecycledTransceiver(this, track.kind);
        if (transceiver && transceiver.sender) {
            var oldTrackId = transceiver.sender.track ? transceiver.sender.track.id : null;
            if (oldTrackId) {
                this._log.warn("Reusing transceiver: " + transceiver.mid + "] " + oldTrackId + " => " + track.id);
            }
            // NOTE(mpatwardhan):remember this transceiver while we replace track.
            // we recycle transceivers that are not in use after 'negotiationCompleted', but we want to prevent
            // this one from getting recycled while replaceTrack is pending.
            this._replaceTrackPromises.set(transceiver, transceiver.sender.replaceTrack(track).then(function () {
                transceiver.direction = 'sendrecv';
            }, function () {
                // Do nothing.
            }).finally(function () {
                _this._replaceTrackPromises.delete(transceiver);
            }));
            return transceiver;
        }
        return this._peerConnection.addTransceiver(track);
    };
    /**
     * Check the {@link IceBox}.
     * @private
     * @param {RTCSessionDescriptionInit} description
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._checkIceBox = function (description) {
        var ufrag = getUfrag(description);
        if (!ufrag) {
            return Promise.resolve();
        }
        var candidates = this._remoteCandidates.setUfrag(ufrag);
        return this._addIceCandidates(candidates);
    };
    /**
     * Create an answer and set it on the {@link PeerConnectionV2}.
     * @private
     * @param {RTCSessionDescriptionInit} offer
     * @returns {Promise<boolean>}
     */
    PeerConnectionV2.prototype._answer = function (offer) {
        var _this = this;
        return Promise.resolve().then(function () {
            if (!_this._negotiationRole) {
                _this._negotiationRole = 'answerer';
            }
            return _this._setRemoteDescription(offer);
        }).catch(function () {
            throw new MediaClientRemoteDescFailedError();
        }).then(function () {
            return _this._peerConnection.createAnswer();
        }).then(function (answer) {
            if (isFirefox) {
                // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling
                // RTX in Firefox 79+. For more details about the bug, please go here:
                // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157
                answer = new _this._RTCSessionDescription({
                    sdp: disableRtx(answer.sdp),
                    type: answer.type
                });
            }
            else {
                answer = workaroundIssue8329(answer);
            }
            // NOTE(mpatwardhan): Upcoming chrome versions are going to remove ssrc attributes
            // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110
            // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ
            // We are not referencing those attributes, but this changes goes ahead and removes them to see if it works.
            // this also helps reduce bytes on wires
            var updatedSdp = removeSSRCAttributes(answer.sdp, ['mslabel', 'label']);
            if (_this._shouldApplySimulcast) {
                var sdpWithoutSimulcast = updatedSdp;
                updatedSdp = _this._setSimulcast(sdpWithoutSimulcast, _this._trackIdsToAttributes);
                // NOTE(syerrapragada): VMS does not support H264 simulcast. So,
                // unset simulcast for sections in local offer where corresponding
                // sections in answer doesn't have vp8 as preferred codec and reapply offer.
                updatedSdp = _this._revertSimulcast(updatedSdp, sdpWithoutSimulcast, offer.sdp);
            }
            // NOTE(mmalavalli): Work around Chromium bug 1074421.
            // https://bugs.chromium.org/p/chromium/issues/detail?id=1074421
            updatedSdp = updatedSdp.replace(/42e015/g, '42e01f');
            return _this._setLocalDescription({
                type: answer.type,
                sdp: updatedSdp
            });
        }).then(function () {
            return _this._checkIceBox(offer);
        }).then(function () {
            return _this._queuedDescription
                && _this._updateDescription(_this._queuedDescription);
        }).then(function () {
            _this._queuedDescription = null;
            return _this._maybeReoffer(_this._peerConnection.localDescription);
        }).catch(function (error) {
            var errorToThrow = error instanceof MediaClientRemoteDescFailedError ? error : new MediaClientLocalDescFailedError();
            _this._publishMediaWarning({
                message: 'Failed to _answer',
                code: errorToThrow.code,
                error: error
            });
            throw errorToThrow;
        });
    };
    /**
     * Close the underlying RTCPeerConnection. Returns false if the
     * RTCPeerConnection was already closed.
     * @private
     * @returns {boolean}
     */
    PeerConnectionV2.prototype._close = function () {
        this._iceConnectionMonitor.stop();
        if (this._peerConnection.signalingState !== 'closed') {
            this._peerConnection.close();
            this.preempt('closed');
            this._encodingParameters.removeListener('changed', this._onEncodingParametersChanged);
            return true;
        }
        return false;
    };
    /**
     * Handle a "connectionstatechange" event.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleConnectionStateChange = function () {
        this.emit('connectionStateChanged');
    };
    /**
     * Handle a "datachannel" event.
     * @private
     * @param {RTCDataChannelEvent} event
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleDataChannelEvent = function (event) {
        var _this = this;
        var dataChannel = event.channel;
        var dataTrackReceiver = new DataTrackReceiver(dataChannel);
        this._dataTrackReceivers.add(dataTrackReceiver);
        dataChannel.addEventListener('close', function () {
            _this._dataTrackReceivers.delete(dataTrackReceiver);
        });
        this.emit('trackAdded', dataTrackReceiver);
    };
    /**
     * Handle a glare scenario on the {@link PeerConnectionV2}.
     * @private
     * @param {RTCSessionDescriptionInit} offer
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._handleGlare = function (offer) {
        var _this = this;
        this._log.debug('Glare detected; rolling back');
        if (this._isRestartingIce) {
            this._log.debug('An ICE restart was in progress; we\'ll need to restart ICE again after rolling back');
            this._isRestartingIce = false;
            this._shouldRestartIce = true;
        }
        return Promise.resolve().then(function () {
            _this._trackIdsToAttributes = new Map(_this._appliedTrackIdsToAttributes);
            return _this._setLocalDescription({ type: 'rollback' });
        }).then(function () {
            _this._needsAnswer = false;
            return _this._answer(offer);
        }).then(function (didReoffer) {
            return didReoffer ? Promise.resolve() : _this._offer();
        });
    };
    PeerConnectionV2.prototype._publishMediaWarning = function (_a) {
        var message = _a.message, code = _a.code, error = _a.error, sdp = _a.sdp;
        this._eventObserver.emit('event', { level: 'warning', name: 'error', group: 'media', payload: {
                message: message,
                code: code,
                context: JSON.stringify({ error: error.message, sdp: sdp })
            } });
    };
    /**
     * Handle an ICE candidate event.
     * @private
     * @param {Event} event
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleIceCandidateEvent = function (event) {
        if (event.candidate) {
            this._log.debug('Clearing ICE gathering timeout');
            this._didGenerateLocalCandidates = true;
            this._iceGatheringTimeout.clear();
            this._localCandidates.push(event.candidate);
        }
        var peerConnectionState = {
            ice: {
                candidates: this._isIceLite ? [] : this._localCandidates.slice(),
                ufrag: this._localUfrag
            },
            id: this.id
        };
        if (!event.candidate) {
            peerConnectionState.ice.complete = true;
        }
        if (!(this._isIceLite && event.candidate)) {
            peerConnectionState.ice.revision = this._localCandidatesRevision++;
            this.emit('candidates', peerConnectionState);
        }
    };
    /**
     * Handle an ICE connection state change event.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleIceConnectionStateChange = function () {
        var _this = this;
        var iceConnectionState = this._peerConnection.iceConnectionState;
        var isIceConnectedOrComplete = ['connected', 'completed'].includes(iceConnectionState);
        var log = this._log;
        log.debug("ICE connection state is \"" + iceConnectionState + "\"");
        if (isIceConnectedOrComplete) {
            this._iceReconnectTimeout.clear();
            this._iceRestartBackoff.reset();
        }
        if (this._lastIceConnectionState !== 'failed' && iceConnectionState === 'failed' && !this._shouldRestartIce && !this._isRestartingIce) {
            // Case 1: Transition to "failed".
            log.warn('ICE failed');
            this._initiateIceRestartBackoff();
        }
        else if (['disconnected', 'failed'].includes(this._lastIceConnectionState) && isIceConnectedOrComplete) {
            // Case 2: Transition from "disconnected" or "failed".
            log.debug('ICE reconnected');
        }
        // start monitor media when connected, and continue to monitor while state is complete-disconnected-connected.
        if (iceConnectionState === 'connected') {
            this._isIceConnectionInactive = false;
            this._iceConnectionMonitor.start(function () {
                // note: iceConnection monitor waits for iceConnectionState=disconnected for
                // detecting inactivity. Its possible that it may know about disconnected before _handleIceConnectionStateChange
                _this._iceConnectionMonitor.stop();
                if (!_this._shouldRestartIce && !_this._isRestartingIce) {
                    log.warn('ICE Connection Monitor detected inactivity');
                    _this._isIceConnectionInactive = true;
                    _this._initiateIceRestartBackoff();
                    _this.emit('iceConnectionStateChanged');
                    _this.emit('connectionStateChanged');
                }
            });
        }
        else if (!['disconnected', 'completed'].includes(iceConnectionState)) { // don't stop monitoring for disconnected or completed.
            this._iceConnectionMonitor.stop();
            this._isIceConnectionInactive = false;
        }
        this._lastIceConnectionState = iceConnectionState;
        this.emit('iceConnectionStateChanged');
    };
    /**
     * Handle ICE gathering timeout.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleIceGatheringTimeout = function () {
        this._log.warn('ICE failed to gather any local candidates');
        this._iceGatheringFailed = true;
        this._initiateIceRestartBackoff();
        this.emit('iceConnectionStateChanged');
        this.emit('connectionStateChanged');
    };
    /**
     * Handle an ICE gathering state change event.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleIceGatheringStateChange = function () {
        var iceGatheringState = this._peerConnection.iceGatheringState;
        var log = this._log;
        log.debug("ICE gathering state is \"" + iceGatheringState + "\"");
        // NOTE(mmalavalli): Start the ICE gathering timeout only if the RTCPeerConnection
        // has started gathering candidates for the first time since the initial offer/answer
        // or an offer/answer with ICE restart.
        var _a = this._iceGatheringTimeout, delay = _a.delay, isSet = _a.isSet;
        if (iceGatheringState === 'gathering' && !this._didGenerateLocalCandidates && !isSet) {
            log.debug("Starting ICE gathering timeout: " + delay);
            this._iceGatheringFailed = false;
            this._iceGatheringTimeout.start();
        }
    };
    /**
     * Handle a signaling state change event.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleSignalingStateChange = function () {
        if (this._peerConnection.signalingState === 'stable') {
            this._appliedTrackIdsToAttributes = new Map(this._trackIdsToAttributes);
        }
    };
    /**
     * Handle a track event.
     * @private
     * @param {RTCTrackEvent} event
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleTrackEvent = function (event) {
        var _this = this;
        var sdp = this._peerConnection.remoteDescription
            ? this._peerConnection.remoteDescription.sdp
            : null;
        this._trackMatcher = this._trackMatcher || new TrackMatcher();
        this._trackMatcher.update(sdp);
        var mediaStreamTrack = event.track, mid = event.transceiver.mid;
        var signaledTrackId = this._trackMatcher.match(event) || mediaStreamTrack.id;
        var mediaTrackReceiver = new MediaTrackReceiver(signaledTrackId, mid, mediaStreamTrack);
        // NOTE(mmalavalli): "ended" is not fired on the remote MediaStreamTrack when
        // the remote peer removes a track. So, when this MediaStreamTrack is re-used
        // for a different track due to the remote peer calling RTCRtpSender.replaceTrack(),
        // we delete the previous MediaTrackReceiver that owned this MediaStreamTrack
        // before adding the new MediaTrackReceiver.
        this._mediaTrackReceivers.forEach(function (trackReceiver) {
            if (trackReceiver.track.id === mediaTrackReceiver.track.id) {
                _this._mediaTrackReceivers.delete(trackReceiver);
            }
        });
        this._mediaTrackReceivers.add(mediaTrackReceiver);
        mediaStreamTrack.addEventListener('ended', function () { return _this._mediaTrackReceivers.delete(mediaTrackReceiver); });
        this.emit('trackAdded', mediaTrackReceiver);
    };
    /**
     * Initiate ICE Restart.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._initiateIceRestart = function () {
        if (this._peerConnection.signalingState === 'closed') {
            return;
        }
        var log = this._log;
        log.warn('Attempting to restart ICE');
        this._didGenerateLocalCandidates = false;
        this._isIceRestartBackoffInProgress = false;
        this._shouldRestartIce = true;
        var _a = this._iceReconnectTimeout, delay = _a.delay, isSet = _a.isSet;
        if (!isSet) {
            log.debug("Starting ICE reconnect timeout: " + delay);
            this._iceReconnectTimeout.start();
        }
        this.offer().catch(function (ex) {
            log.error("offer failed in _initiateIceRestart with: " + ex.message);
        });
    };
    /**
     * Schedule an ICE Restart.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._initiateIceRestartBackoff = function () {
        if (this._peerConnection.signalingState === 'closed' || this._isIceRestartBackoffInProgress) {
            return;
        }
        this._log.warn('An ICE restart has been scheduled');
        this._isIceRestartBackoffInProgress = true;
        this._iceRestartBackoff.backoff();
    };
    /**
     * Conditionally re-offer.
     * @private
     * @param {?RTCSessionDescriptionInit} localDescription
     * @returns {Promise<boolean>}
     */
    PeerConnectionV2.prototype._maybeReoffer = function (localDescription) {
        var shouldReoffer = this._shouldOffer;
        if (localDescription && localDescription.sdp) {
            // NOTE(mmalavalli): If the local RTCSessionDescription has fewer audio and/or
            // video send* m= lines than the corresponding RTCRtpSenders with non-null
            // MediaStreamTracks, it means that the newly added RTCRtpSenders require
            // renegotiation.
            var senders_1 = this._peerConnection.getSenders().filter(function (sender) { return sender.track; });
            shouldReoffer = ['audio', 'video'].reduce(function (shouldOffer, kind) {
                var mediaSections = getMediaSections(localDescription.sdp, kind, '(sendrecv|sendonly)');
                var sendersOfKind = senders_1.filter(isSenderOfKind.bind(null, kind));
                return shouldOffer || (mediaSections.length < sendersOfKind.length);
            }, shouldReoffer);
            // NOTE(mroberts): We also need to re-offer if we have a DataTrack to share
            // but no m= application section.
            var hasDataTrack = this._dataChannels.size > 0;
            var hasApplicationMediaSection = getMediaSections(localDescription.sdp, 'application').length > 0;
            var needsApplicationMediaSection = hasDataTrack && !hasApplicationMediaSection;
            shouldReoffer = shouldReoffer || needsApplicationMediaSection;
        }
        var promise = shouldReoffer ? this._offer() : Promise.resolve();
        return promise.then(function () { return shouldReoffer; });
    };
    /**
     * Create an offer and set it on the {@link PeerConnectionV2}.
     * @private
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._offer = function () {
        var _this = this;
        var offerOptions = Object.assign({}, this._offerOptions);
        this._needsAnswer = true;
        if (this._shouldRestartIce) {
            this._shouldRestartIce = false;
            this._isRestartingIce = true;
            offerOptions.iceRestart = true;
        }
        return Promise.all(this._replaceTrackPromises.values()).then(function () {
            return _this._peerConnection.createOffer(offerOptions);
        }).catch(function (error) {
            var errorToThrow = new MediaClientLocalDescFailedError();
            _this._publishMediaWarning({
                message: 'Failed to create offer',
                code: errorToThrow.code,
                error: error
            });
            throw errorToThrow;
        }).then(function (offer) {
            if (isFirefox) {
                // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling
                // RTX in Firefox 79+. For more details about the bug, please go here:
                // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157
                offer = new _this._RTCSessionDescription({
                    sdp: disableRtx(offer.sdp),
                    type: offer.type
                });
            }
            else {
                offer = workaroundIssue8329(offer);
            }
            // NOTE(mpatwardhan): upcoming chrome versions are going to remove ssrc attributes
            // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110
            // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ
            // Looks like we are not referencing those attributes, but this changes goes ahead and removes them to see if it works.
            // this also helps reduce bytes on wires
            var sdp = removeSSRCAttributes(offer.sdp, ['mslabel', 'label']);
            sdp = _this._peerConnection.remoteDescription
                ? filterLocalCodecs(sdp, _this._peerConnection.remoteDescription.sdp)
                : sdp;
            var updatedSdp = _this._setCodecPreferences(sdp, _this._preferredAudioCodecs, _this._preferredVideoCodecs);
            _this._shouldOffer = false;
            if (!_this._negotiationRole) {
                _this._negotiationRole = 'offerer';
            }
            if (_this._shouldApplySimulcast) {
                _this._localDescriptionWithoutSimulcast = {
                    type: 'offer',
                    sdp: updatedSdp
                };
                updatedSdp = _this._setSimulcast(updatedSdp, _this._trackIdsToAttributes);
            }
            return _this._setLocalDescription({
                type: 'offer',
                sdp: updatedSdp
            });
        });
    };
    /**
     * Get the MediaTrackSender ID of the given MediaStreamTrack ID.
     * Since a MediaTrackSender's underlying MediaStreamTrack can be
     * replaced, the corresponding IDs can mismatch.
     * @private
     * @param {Track.ID} id
     * @returns {Track.ID}
     */
    PeerConnectionV2.prototype._getMediaTrackSenderId = function (trackId) {
        var mediaTrackSender = Array.from(this._rtpSenders.keys()).find(function (_a) {
            var id = _a.track.id;
            return id === trackId;
        });
        return mediaTrackSender ? mediaTrackSender.id : trackId;
    };
    /**
     * Add or rewrite local MediaStreamTrack IDs in the given RTCSessionDescription.
     * @private
     * @param {RTCSessionDescription} description
     * @return {RTCSessionDescription}
     */
    PeerConnectionV2.prototype._addOrRewriteLocalTrackIds = function (description) {
        var _this = this;
        var transceivers = this._peerConnection.getTransceivers();
        var activeTransceivers = transceivers.filter(function (_a) {
            var sender = _a.sender, stopped = _a.stopped;
            return !stopped && sender && sender.track;
        });
        // NOTE(mmalavalli): There is no guarantee that MediaStreamTrack IDs will be present in
        // SDPs, and even if they are, there is no guarantee that they will be the same as the
        // actual MediaStreamTrack IDs. So, we add or re-write the actual MediaStreamTrack IDs
        // to the assigned m= sections here.
        var assignedTransceivers = activeTransceivers.filter(function (_a) {
            var mid = _a.mid;
            return mid;
        });
        var midsToTrackIds = new Map(assignedTransceivers.map(function (_a) {
            var mid = _a.mid, sender = _a.sender;
            return [mid, _this._getMediaTrackSenderId(sender.track.id)];
        }));
        var sdp1 = addOrRewriteTrackIds(description.sdp, midsToTrackIds);
        // NOTE(mmalavalli): Chrome and Safari do not apply the offer until they get an answer.
        // So, we add or re-write the actual MediaStreamTrack IDs to the unassigned m= sections here.
        var unassignedTransceivers = activeTransceivers.filter(function (_a) {
            var mid = _a.mid;
            return !mid;
        });
        var newTrackIdsByKind = new Map(['audio', 'video'].map(function (kind) { return [
            kind,
            unassignedTransceivers.filter(function (_a) {
                var sender = _a.sender;
                return sender.track.kind === kind;
            }).map(function (_a) {
                var sender = _a.sender;
                return _this._getMediaTrackSenderId(sender.track.id);
            })
        ]; }));
        var sdp2 = addOrRewriteNewTrackIds(sdp1, midsToTrackIds, newTrackIdsByKind);
        return new this._RTCSessionDescription({
            sdp: sdp2,
            type: description.type
        });
    };
    /**
     * Rollback and apply the given offer.
     * @private
     * @param {RTCSessionDescriptionInit} offer
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._rollbackAndApplyOffer = function (offer) {
        var _this = this;
        return this._setLocalDescription({ type: 'rollback' }).then(function () { return _this._setLocalDescription(offer); });
    };
    /**
     * Set a local description on the {@link PeerConnectionV2}.
     * @private
     * @param {RTCSessionDescription|RTCSessionDescriptionInit} description
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._setLocalDescription = function (description) {
        var _this = this;
        if (description.type !== 'rollback' && this._shouldApplyDtx) {
            description = new this._RTCSessionDescription({
                sdp: enableDtxForOpus(description.sdp),
                type: description.type
            });
        }
        return this._peerConnection.setLocalDescription(description).catch(function (error) {
            _this._log.warn("Calling setLocalDescription with an RTCSessionDescription of type \"" + description.type + "\" failed with the error \"" + error.message + "\".", error);
            var errorToThrow = new MediaClientLocalDescFailedError();
            var publishWarning = {
                message: "Calling setLocalDescription with an RTCSessionDescription of type \"" + description.type + "\" failed",
                code: errorToThrow.code,
                error: error
            };
            if (description.sdp) {
                _this._log.warn("The SDP was " + description.sdp);
                publishWarning.sdp = description.sdp;
            }
            _this._publishMediaWarning(publishWarning);
            throw errorToThrow;
        }).then(function () {
            if (description.type !== 'rollback') {
                _this._localDescription = _this._addOrRewriteLocalTrackIds(description);
                // NOTE(mmalavalli): In order for this feature to be backward compatible with older
                // SDK versions which to not support opus DTX, we append "usedtx=1" to the local SDP
                // only while applying it. We will not send it over the wire to prevent inadvertent
                // enabling of opus DTX in older SDKs. Newer SDKs will append "usedtx=1" by themselves
                // if the developer has requested opus DTX to be enabled. (JSDK-3063)
                if (_this._shouldApplyDtx) {
                    _this._localDescription = new _this._RTCSessionDescription({
                        sdp: enableDtxForOpus(_this._localDescription.sdp, []),
                        type: _this._localDescription.type
                    });
                }
                _this._localCandidates = [];
                if (description.type === 'offer') {
                    _this._descriptionRevision++;
                }
                else if (description.type === 'answer') {
                    _this._lastStableDescriptionRevision = _this._descriptionRevision;
                    negotiationCompleted(_this);
                }
                _this._localUfrag = getUfrag(description);
                _this.emit('description', _this.getState());
            }
        });
    };
    /**
     * Set a remote RTCSessionDescription on the {@link PeerConnectionV2}.
     * @private
     * @param {RTCSessionDescriptionInit} description
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._setRemoteDescription = function (description) {
        var _this = this;
        if (description.sdp) {
            description.sdp = this._setCodecPreferences(description.sdp, this._preferredAudioCodecs, this._preferredVideoCodecs);
            if (this._shouldApplyDtx) {
                description.sdp = enableDtxForOpus(description.sdp);
            }
            else {
                // NOTE(mmalavalli): Remove "usedtx=1" from opus's fmtp line if present
                // since DTX is disabled.
                description.sdp = enableDtxForOpus(description.sdp, []);
            }
            if (isFirefox) {
                // NOTE(mroberts): Do this to reduce our MediaStream count in Firefox. By
                // mapping MediaStream IDs in the SDP to "-", we ensure the "track" event
                // doesn't include any new MediaStreams in Firefox. Its `streams` member
                // will always be the empty Array.
                description.sdp = filterOutMediaStreamIds(description.sdp);
            }
            if (!this._peerConnection.remoteDescription) {
                this._isIceLite = /a=ice-lite/.test(description.sdp);
            }
        }
        description = new this._RTCSessionDescription(description);
        // eslint-disable-next-line consistent-return
        return Promise.resolve().then(function () {
            // NOTE(syerrapragada): VMS does not support H264 simulcast. So,
            // unset simulcast for sections in local offer where corresponding
            // sections in answer doesn't have vp8 as preferred codec and reapply offer.
            if (description.type === 'answer' && _this._localDescriptionWithoutSimulcast) {
                // NOTE(mpatwardhan):if we were using adaptive simulcast, and if its not supported by server
                // revert simulcast even for vp8.
                var adaptiveSimulcastEntry = _this._preferredVideoCodecs.find(function (cs) { return 'adaptiveSimulcast' in cs; });
                var revertForAll = !!adaptiveSimulcastEntry && adaptiveSimulcastEntry.adaptiveSimulcast === false;
                var sdpWithoutSimulcastForNonVP8MediaSections = _this._revertSimulcast(_this._localDescription.sdp, _this._localDescriptionWithoutSimulcast.sdp, description.sdp, revertForAll);
                _this._localDescriptionWithoutSimulcast = null;
                if (sdpWithoutSimulcastForNonVP8MediaSections !== _this._localDescription.sdp) {
                    return _this._rollbackAndApplyOffer({
                        type: _this._localDescription.type,
                        sdp: sdpWithoutSimulcastForNonVP8MediaSections
                    });
                }
            }
        }).then(function () { return _this._peerConnection.setRemoteDescription(description); }).then(function () {
            if (description.type === 'answer') {
                if (_this._isRestartingIce) {
                    _this._log.debug('An ICE restart was in-progress and is now completed');
                    _this._isRestartingIce = false;
                }
                negotiationCompleted(_this);
            }
        }, function (error) {
            _this._log.warn("Calling setRemoteDescription with an RTCSessionDescription of type \"" + description.type + "\" failed with the error \"" + error.message + "\".", error);
            if (description.sdp) {
                _this._log.warn("The SDP was " + description.sdp);
            }
            throw error;
        });
    };
    /**
     * Update the {@link PeerConnectionV2}'s description.
     * @private
     * @param {RTCSessionDescriptionInit} description
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._updateDescription = function (description) {
        var _this = this;
        switch (description.type) {
            case 'answer':
            case 'pranswer':
                if (description.revision !== this._descriptionRevision
                    || this._peerConnection.signalingState !== 'have-local-offer') {
                    return Promise.resolve();
                }
                this._descriptionRevision = description.revision;
                break;
            case 'close':
                return this._close();
            case 'create-offer':
                if (description.revision <= this._lastStableDescriptionRevision) {
                    return Promise.resolve();
                }
                else if (this._needsAnswer) {
                    this._queuedDescription = description;
                    return Promise.resolve();
                }
                this._descriptionRevision = description.revision;
                return this._offer();
            case 'offer':
                if (description.revision <= this._lastStableDescriptionRevision
                    || this._peerConnection.signalingState === 'closed') {
                    return Promise.resolve();
                }
                if (this._peerConnection.signalingState === 'have-local-offer') {
                    // NOTE(mpatwardhan): For a peer connection
                    // 1) createOffer always generate SDP with `setup:actpass`
                    // 2) when remote description is set `setup:active`  - the answer generated selects the dtls role of setup:passive
                    // 3) when remote description is set `setup:passive` - the answer generated selects the dtls role of setup:active
                    // 4) when remote description is set `setup:actpass` - the answer generated uses the previously negotiated role (if not negotiated previously setup:active is used)
                    // This test shows the  behavior: https://github.com/twilio/twilio-webrtc.js/blob/master/test/integration/spec/rtcpeerconnection.js#L936
                    // with glare handling (if dtls role was not negotiated before ) the generated answer will set setup:active.
                    // we do not want that. lets wait for "initial negotiation" before attempting glare handling.
                    if (this._needsAnswer && this._lastStableDescriptionRevision === 0) {
                        this._queuedDescription = description;
                        return Promise.resolve();
                    }
                    this._descriptionRevision = description.revision;
                    return this._handleGlare(description);
                }
                this._descriptionRevision = description.revision;
                return this._answer(description).then(function () { });
            default:
            // Do nothing.
        }
        // Handle answer or pranswer.
        var revision = description.revision;
        return Promise.resolve().then(function () {
            return _this._setRemoteDescription(description);
        }).catch(function (error) {
            var errorToThrow = new MediaClientRemoteDescFailedError();
            _this._publishMediaWarning({
                message: "Calling setRemoteDescription with an RTCSessionDescription of type \"" + description.type + "\" failed",
                code: errorToThrow.code,
                error: error,
                sdp: description.sdp
            });
            throw errorToThrow;
        }).then(function () {
            _this._lastStableDescriptionRevision = revision;
            _this._needsAnswer = false;
            return _this._checkIceBox(description);
        }).then(function () {
            return _this._queuedDescription
                && _this._updateDescription(_this._queuedDescription);
        }).then(function () {
            _this._queuedDescription = null;
            return _this._maybeReoffer(_this._peerConnection.localDescription).then(function () { });
        });
    };
    /**
     * Update the {@link PeerConnectionV2}'s ICE candidates.
     * @private
     * @param {object} iceState
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._updateIce = function (iceState) {
        var candidates = this._remoteCandidates.update(iceState);
        return this._addIceCandidates(candidates);
    };
    /**
     * Add a {@link DataTrackSender} to the {@link PeerConnectionV2}.
     * @param {DataTrackSender} dataTrackSender
     * @returns {void}
     */
    PeerConnectionV2.prototype.addDataTrackSender = function (dataTrackSender) {
        if (this._dataChannels.has(dataTrackSender)) {
            return;
        }
        try {
            var dataChannelDict = {
                ordered: dataTrackSender.ordered
            };
            if (dataTrackSender.maxPacketLifeTime !== null) {
                dataChannelDict.maxPacketLifeTime = dataTrackSender.maxPacketLifeTime;
            }
            if (dataTrackSender.maxRetransmits !== null) {
                dataChannelDict.maxRetransmits = dataTrackSender.maxRetransmits;
            }
            var dataChannel = this._peerConnection.createDataChannel(dataTrackSender.id, dataChannelDict);
            dataTrackSender.addDataChannel(dataChannel);
            this._dataChannels.set(dataTrackSender, dataChannel);
        }
        catch (error) {
            this._log.warn("Error creating an RTCDataChannel for DataTrack \"" + dataTrackSender.id + "\": " + error.message);
        }
    };
    PeerConnectionV2.prototype._handleQueuedPublisherHints = function () {
        var _this = this;
        if (this._peerConnection.signalingState === 'stable') {
            this._mediaTrackSenderToPublisherHints.forEach(function (_a, mediaTrackSender) {
                var deferred = _a.deferred, encodings = _a.encodings;
                _this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);
                _this._setPublisherHint(mediaTrackSender, encodings)
                    .then(function (result) { return deferred.resolve(result); })
                    .catch(function (error) { return deferred.reject(error); });
            });
        }
    };
    /**
     * updates encodings for simulcast layers of given sender.
     * @param {RTCRtpSender} sender
     * @param {Array<{enabled: boolean, layer_index: number}>|null} encodings
     * @returns {Promise<string>} string indicating result of the operation. can be one of
     *  "OK", "INVALID_HINT", "COULD_NOT_APPLY_HINT", "UNKNOWN_TRACK"
     */
    PeerConnectionV2.prototype._setPublisherHint = function (mediaTrackSender, encodings) {
        var _this = this;
        if (isFirefox) {
            return Promise.resolve('COULD_NOT_APPLY_HINT');
        }
        if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {
            // skip any stale hint associated with the mediaTrackSender.
            var queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);
            queuedHint.deferred.resolve('REQUEST_SKIPPED');
            this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);
        }
        var sender = this._rtpSenders.get(mediaTrackSender);
        if (!sender) {
            this._log.warn('Could not apply publisher hint because RTCRtpSender was not found');
            return Promise.resolve('UNKNOWN_TRACK');
        }
        if (this._peerConnection.signalingState === 'closed') {
            this._log.warn('Could not apply publisher hint because signalingState was "closed"');
            return Promise.resolve('COULD_NOT_APPLY_HINT');
        }
        if (this._peerConnection.signalingState !== 'stable') {
            // enqueue this hint to be applied when pc becomes stable.
            this._log.debug('Queuing up publisher hint because signalingState:', this._peerConnection.signalingState);
            var deferred = defer();
            this._mediaTrackSenderToPublisherHints.set(mediaTrackSender, { deferred: deferred, encodings: encodings });
            return deferred.promise;
        }
        var parameters = sender.getParameters();
        if (encodings !== null) {
            encodings.forEach(function (_a) {
                var enabled = _a.enabled, layerIndex = _a.layer_index;
                if (parameters.encodings.length > layerIndex) {
                    _this._log.debug("layer:" + layerIndex + ", active:" + parameters.encodings[layerIndex].active + " => " + enabled);
                    parameters.encodings[layerIndex].active = enabled;
                }
                else {
                    _this._log.warn("invalid layer:" + layerIndex + ", active:" + enabled);
                }
            });
        }
        // Note(mpatwardhan): after publisher hints are applied, overwrite with default encodings
        // to disable any encoding that shouldn't have been enabled by publisher_hints.
        // When encodings===null (that is we are asked to reset encodings for replaceTrack)
        // along with disabling encodings, clear active flag for encodings that should not be disabled
        this._maybeUpdateEncodings(sender.track, parameters.encodings, encodings === null /* trackReplaced */);
        return sender.setParameters(parameters).then(function () { return 'OK'; }).catch(function (error) {
            _this._log.error('Failed to apply publisher hints:', error);
            return 'COULD_NOT_APPLY_HINT';
        });
    };
    /**
     * Add the {@link MediaTrackSender} to the {@link PeerConnectionV2}.
     * @param {MediaTrackSender} mediaTrackSender
     * @returns {void}
     */
    PeerConnectionV2.prototype.addMediaTrackSender = function (mediaTrackSender) {
        var _this = this;
        if (this._peerConnection.signalingState === 'closed' || this._rtpSenders.has(mediaTrackSender)) {
            return;
        }
        var transceiver = this._addOrUpdateTransceiver(mediaTrackSender.track);
        var sender = transceiver.sender;
        mediaTrackSender.addSender(sender, function (encodings) { return _this._setPublisherHint(mediaTrackSender, encodings); });
        this._rtpNewSenders.add(sender);
        this._rtpSenders.set(mediaTrackSender, sender);
    };
    /**
     * Close the {@link PeerConnectionV2}.
     * @returns {void}
     */
    PeerConnectionV2.prototype.close = function () {
        if (this._close()) {
            this._descriptionRevision++;
            this._localDescription = { type: 'close' };
            this.emit('description', this.getState());
        }
    };
    /**
     * Get the {@link DataTrackReceiver}s and the {@link MediaTrackReceiver}s on the
     * {@link PeerConnectionV2}.
     * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers
     */
    PeerConnectionV2.prototype.getTrackReceivers = function () {
        return Array.from(this._dataTrackReceivers).concat(Array.from(this._mediaTrackReceivers));
    };
    /**
     * Get the {@link PeerConnectionV2}'s state (specifically, its description).
     * @returns {?object}
     */
    PeerConnectionV2.prototype.getState = function () {
        if (!this._localDescription) {
            return null;
        }
        // NOTE(mpatwardhan): Return most recent localDescription. If the most recent local description is an
        // answer, and this method is called for sending a "sync" message while the next remote offer is being processed,
        // we need to send the most recent stable description revision instead of the current description revision,
        // which is supposed to be for the next local answer.
        var localDescriptionRevision = this._localDescription.type === 'answer' ? this._lastStableDescriptionRevision : this._descriptionRevision;
        var localDescription = {
            type: this._localDescription.type,
            revision: localDescriptionRevision
        };
        if (this._localDescription.sdp) {
            localDescription.sdp = this._localDescription.sdp;
        }
        return {
            description: localDescription,
            id: this.id
        };
    };
    /**
     * Create an offer and set it on the {@link PeerConnectionV2}.
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype.offer = function () {
        var _this = this;
        if (this._needsAnswer || this._isRestartingIce) {
            this._shouldOffer = true;
            return Promise.resolve();
        }
        return this.bracket('offering', function (key) {
            _this.transition('updating', key);
            var promise = _this._needsAnswer || _this._isRestartingIce ? Promise.resolve() : _this._offer();
            return promise.then(function () {
                _this.tryTransition('open', key);
            }, function (error) {
                _this.tryTransition('open', key);
                throw error;
            });
        });
    };
    /**
     * Remove a {@link DataTrackSender} from the {@link PeerConnectionV2}.
     * @param {DataTrackSender} dataTrackSender
     * @returns {void}
     */
    PeerConnectionV2.prototype.removeDataTrackSender = function (dataTrackSender) {
        var dataChannel = this._dataChannels.get(dataTrackSender);
        if (dataChannel) {
            dataTrackSender.removeDataChannel(dataChannel);
            this._dataChannels.delete(dataTrackSender);
            dataChannel.close();
        }
    };
    /**
     * Remove the {@link MediaTrackSender} from the {@link PeerConnectionV2}.
     * @param {MediaTrackSender} mediaTrackSender
     * @returns {void}
     */
    PeerConnectionV2.prototype.removeMediaTrackSender = function (mediaTrackSender) {
        var sender = this._rtpSenders.get(mediaTrackSender);
        if (!sender) {
            return;
        }
        if (this._peerConnection.signalingState !== 'closed') {
            this._peerConnection.removeTrack(sender);
        }
        mediaTrackSender.removeSender(sender);
        // clean up any pending publisher hints associated with this mediaTrackSender.
        if (this._mediaTrackSenderToPublisherHints.has(mediaTrackSender)) {
            var queuedHint = this._mediaTrackSenderToPublisherHints.get(mediaTrackSender);
            queuedHint.deferred.resolve('UNKNOWN_TRACK');
            this._mediaTrackSenderToPublisherHints.delete(mediaTrackSender);
        }
        this._rtpNewSenders.delete(sender);
        this._rtpSenders.delete(mediaTrackSender);
    };
    /**
     * Set the RTCConfiguration on the underlying RTCPeerConnection.
     * @param {RTCConfiguration} configuration
     * @returns {void}
     */
    PeerConnectionV2.prototype.setConfiguration = function (configuration) {
        if (typeof this._peerConnection.setConfiguration === 'function') {
            this._peerConnection.setConfiguration(getConfiguration(configuration));
        }
    };
    /**
     * Set the ICE reconnect timeout period.
     * @param {number} period - Period in milliseconds.
     * @returns {this}
     */
    PeerConnectionV2.prototype.setIceReconnectTimeout = function (period) {
        this._iceReconnectTimeout.setDelay(period);
        this._log.debug('Updated ICE reconnection timeout period:', this._iceReconnectTimeout.delay);
        return this;
    };
    /**
     * Update the {@link PeerConnectionV2}.
     * @param {object} peerConnectionState
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype.update = function (peerConnectionState) {
        var _this = this;
        return this.bracket('updating', function (key) {
            if (_this.state === 'closed') {
                return Promise.resolve();
            }
            _this.transition('updating', key);
            var updates = [];
            if (peerConnectionState.ice) {
                updates.push(_this._updateIce(peerConnectionState.ice));
            }
            if (peerConnectionState.description) {
                updates.push(_this._updateDescription(peerConnectionState.description));
            }
            return Promise.all(updates).then(function () {
                _this.tryTransition('open', key);
            }, function (error) {
                _this.tryTransition('open', key);
                throw error;
            });
        });
    };
    /**
     * Get the {@link PeerConnectionV2}'s media statistics.
     * @returns {Promise<StandardizedStatsResponse>}
     */
    PeerConnectionV2.prototype.getStats = function () {
        var _this = this;
        return getStatistics(this._peerConnection).then(function (response) { return rewriteTrackIds(_this, response); });
    };
    return PeerConnectionV2;
}(StateMachine));
function rewriteLocalTrackId(pcv2, stats) {
    var trackId = pcv2._getMediaTrackSenderId(stats.trackId);
    return Object.assign(stats, { trackId: trackId });
}
function rewriteTrackId(pcv2, stats) {
    var receiver = __spreadArray([], __read(pcv2._mediaTrackReceivers)).find(function (receiver) { return receiver.track.id === stats.trackId; });
    var trackId = receiver ? receiver.id : null;
    return Object.assign(stats, { trackId: trackId });
}
function rewriteTrackIds(pcv2, response) {
    return Object.assign(response, {
        remoteAudioTrackStats: response.remoteAudioTrackStats.map(function (stats) { return rewriteTrackId(pcv2, stats); }),
        remoteVideoTrackStats: response.remoteVideoTrackStats.map(function (stats) { return rewriteTrackId(pcv2, stats); }),
        localAudioTrackStats: response.localAudioTrackStats.map(function (stats) { return rewriteLocalTrackId(pcv2, stats); }),
        localVideoTrackStats: response.localVideoTrackStats.map(function (stats) { return rewriteLocalTrackId(pcv2, stats); }),
    });
}
/**
 * @event PeerConnectionV2#candidates
 * @param {object} candidates
 */
/**
 * @event PeerConnectionV2#connectionStateChanged
 */
/**
 * @event PeerConnectionV2#description
 * @param {object} description
 */
/**
 * @event PeerConnectionV2#iceConnectionStateChanged
 */
/**
 * @event PeerConnectionV2#trackAdded
 * @param {DataTrackReceiver|MediaTrackReceiver} trackReceiver
 */
function getUfrag(description) {
    if (description.sdp) {
        var match = description.sdp.match(/^a=ice-ufrag:([a-zA-Z0-9+/]+)/m);
        if (match) {
            return match[1];
        }
    }
    return null;
}
function getConfiguration(configuration) {
    return Object.assign({
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
    }, configuration);
}
/**
 * Whether the MediaStreamTrack of the given RTCRTPSender is a non-ended
 * MediaStreamTrack of a given kind.
 * @private
 * @param {string} kind
 * @param {RTCRtpSender} sender
 * @return {boolean}
 */
function isSenderOfKind(kind, sender) {
    var track = sender.track;
    return track && track.kind === kind && track.readyState !== 'ended';
}
/**
 * Preferred codecs.
 * @typedef {object} PreferredCodecs
 * @property {Array<AudioCodec>} audio
 * @property {Array<VideoCodec>} video
 */
function filterOutMediaStreamIds(sdp) {
    return sdp.replace(/a=msid:[^ ]+ /g, 'a=msid:- ');
}
/**
 * Whether an RTCRtpTransceiver can be recycled.
 * @param {RTCRtpTransceiver} transceiver
 * @returns {boolean}
 */
function shouldRecycleTransceiver(transceiver, pcv2) {
    return !transceiver.stopped
        && !pcv2._replaceTrackPromises.has(transceiver)
        && ['inactive', 'recvonly'].includes(transceiver.direction);
}
/**
 * Take a recycled RTCRtpTransceiver if available.
 * @param {PeerConnectionV2} pcv2
 * @param {Track.Kind} kind
 * @returns {?RTCRtpTransceiver}
 */
function takeRecycledTransceiver(pcv2, kind) {
    var preferredCodecs = {
        audio: pcv2._preferredAudioCodecs.map(function (_a) {
            var codec = _a.codec;
            return codec.toLowerCase();
        }),
        video: pcv2._preferredVideoCodecs.map(function (_a) {
            var codec = _a.codec;
            return codec.toLowerCase();
        })
    }[kind];
    var recycledTransceivers = pcv2._recycledTransceivers[kind];
    var localCodec = preferredCodecs.find(function (codec) { return pcv2._localCodecs.has(codec); });
    if (!localCodec) {
        return recycledTransceivers.shift();
    }
    var transceiver = recycledTransceivers.find(function (transceiver) {
        var remoteCodecMap = pcv2._remoteCodecMaps.get(transceiver.mid);
        return remoteCodecMap && remoteCodecMap.has(localCodec);
    });
    if (transceiver) {
        recycledTransceivers.splice(recycledTransceivers.indexOf(transceiver), 1);
    }
    return transceiver;
}
/**
 * Update the set of locally supported {@link Codec}s.
 * @param pcv2
 * @returns {void}
 */
function updateLocalCodecs(pcv2) {
    var description = pcv2._peerConnection.localDescription;
    if (!description || !description.sdp) {
        return;
    }
    getMediaSections(description.sdp).forEach(function (section) {
        var codecMap = createCodecMapForMediaSection(section);
        codecMap.forEach(function (pts, codec) { return pcv2._localCodecs.add(codec); });
    });
}
/**
 * Update the {@link Codec} maps for all m= sections in the remote {@link RTCSessionDescription}s.
 * @param {PeerConnectionV2} pcv2
 * @returns {void}
 */
function updateRemoteCodecMaps(pcv2) {
    var description = pcv2._peerConnection.remoteDescription;
    if (!description || !description.sdp) {
        return;
    }
    getMediaSections(description.sdp).forEach(function (section) {
        var matched = section.match(/^a=mid:(.+)$/m);
        if (!matched || !matched[1]) {
            return;
        }
        var mid = matched[1];
        var codecMap = createCodecMapForMediaSection(section);
        pcv2._remoteCodecMaps.set(mid, codecMap);
    });
}
/**
 * Update the list of recycled RTCRtpTransceivers.
 * @param {PeerConnectionV2} pcv2
 */
function updateRecycledTransceivers(pcv2) {
    pcv2._recycledTransceivers.audio = [];
    pcv2._recycledTransceivers.video = [];
    pcv2._peerConnection.getTransceivers().forEach(function (transceiver) {
        if (shouldRecycleTransceiver(transceiver, pcv2)) {
            var track = transceiver.receiver.track;
            pcv2._recycledTransceivers[track.kind].push(transceiver);
        }
    });
}
/**
 * Perform certain updates after an SDP negotiation is completed.
 * @param {PeerConnectionV2} pcv2
 * @returns {void}
 */
function negotiationCompleted(pcv2) {
    updateRecycledTransceivers(pcv2);
    updateLocalCodecs(pcv2);
    updateRemoteCodecMaps(pcv2);
    updateEncodingParameters(pcv2).then(function () {
        // if there any any publisher hints queued, apply them now.
        pcv2._handleQueuedPublisherHints();
    });
}
/**
 * Update the RTCRtpEncodingParameters of all active RTCRtpSenders.
 * @param {PeerConnectionV2} pcv2
 * @returns {void}
 */
function updateEncodingParameters(pcv2) {
    var _a = pcv2._encodingParameters, maxAudioBitrate = _a.maxAudioBitrate, maxVideoBitrate = _a.maxVideoBitrate;
    var maxBitrates = new Map([
        ['audio', maxAudioBitrate],
        ['video', maxVideoBitrate]
    ]);
    var promises = [];
    pcv2._peerConnection.getSenders().filter(function (sender) { return sender.track; }).forEach(function (sender) {
        var maxBitrate = maxBitrates.get(sender.track.kind);
        var params = sender.getParameters();
        if (maxBitrate === null || maxBitrate === 0) {
            removeMaxBitrate(params);
        }
        else if (pcv2._isChromeScreenShareTrack(sender.track)) {
            // NOTE(mpatwardhan): Sometimes (JSDK-2557) chrome does not send any bytes on screen track if MaxBitRate is set on it via setParameters,
            // To workaround this issue we will not apply maxBitrate if the track appears to be a screen share track created by chrome
            pcv2._log.warn("Not setting maxBitrate for " + sender.track.kind + " Track " + sender.track.id + " because it appears to be screen share track: " + sender.track.label);
        }
        else {
            setMaxBitrate(params, maxBitrate);
        }
        if (!isFirefox && pcv2._enableDscp && params.encodings.length > 0) {
            // NOTE(mmalavalli): "networkPriority" is a per-sender property and not
            // a per-encoding-layer property. So, we set the value only on the first
            // encoding layer. Any attempt to set the value on subsequent encoding
            // layers (in the case of simulcast) will result in the Promise returned
            // by RTCRtpSender.setParameters() being rejected.
            params.encodings[0].networkPriority = 'high';
        }
        // when a sender is reused, delete any active encodings set by server.
        var trackReplaced = pcv2._rtpNewSenders.has(sender);
        pcv2._maybeUpdateEncodings(sender.track, params.encodings, trackReplaced);
        pcv2._rtpNewSenders.delete(sender);
        var promise = sender.setParameters(params).catch(function (error) {
            pcv2._log.warn("Error while setting encodings parameters for " + sender.track.kind + " Track " + sender.track.id + ": " + (error.message || error.name));
        });
        promises.push(promise);
    });
    return Promise.all(promises);
}
/**
 * Remove maxBitrate from the RTCRtpSendParameters' encodings.
 * @param {RTCRtpSendParameters} params
 * @returns {void}
 */
function removeMaxBitrate(params) {
    if (Array.isArray(params.encodings)) {
        params.encodings.forEach(function (encoding) { return delete encoding.maxBitrate; });
    }
}
/**
 * Set the given maxBitrate in the RTCRtpSendParameters' encodings.
 * @param {RTCRtpSendParameters} params
 * @param {number} maxBitrate
 * @returns {void}
 */
function setMaxBitrate(params, maxBitrate) {
    if (isFirefox) {
        params.encodings = [{ maxBitrate: maxBitrate }];
    }
    else {
        params.encodings.forEach(function (encoding) {
            encoding.maxBitrate = maxBitrate;
        });
    }
}
module.exports = PeerConnectionV2;
//# sourceMappingURL=peerconnection.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/peerconnectionmanager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/peerconnectionmanager.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var guessBrowser = __webpack_require__(/*! ../../webrtc/util */ "./node_modules/twilio-video/es5/webrtc/util/index.js").guessBrowser;
var PeerConnectionV2 = __webpack_require__(/*! ./peerconnection */ "./node_modules/twilio-video/es5/signaling/v2/peerconnection.js");
var MediaTrackSender = __webpack_require__(/*! ../../media/track/sender */ "./node_modules/twilio-video/es5/media/track/sender.js");
var QueueingEventEmitter = __webpack_require__(/*! ../../queueingeventemitter */ "./node_modules/twilio-video/es5/queueingeventemitter.js");
var util = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js");
var MediaConnectionError = __webpack_require__(/*! ../../util/twilio-video-errors */ "./node_modules/twilio-video/es5/util/twilio-video-errors.js").MediaConnectionError;
var isFirefox = guessBrowser() === 'firefox';
/**
 * {@link PeerConnectionManager} manages multiple {@link PeerConnectionV2}s.
 * @extends QueueingEventEmitter
 * @emits PeerConnectionManager#candidates
 * @emits PeerConnectionManager#connectionStateChanged
 * @emits PeerConnectionManager#description
 * @emits PeerConnectionManager#iceConnectionStateChanged
 * @emits PeerConnectionManager#trackAdded
 */
var PeerConnectionManager = /** @class */ (function (_super) {
    __extends(PeerConnectionManager, _super);
    /**
     * Construct {@link PeerConnectionManager}.
     * @param {EncodingParametersImpl} encodingParameters
     * @param {PreferredCodecs} preferredCodecs
     * @param {object} options
     */
    function PeerConnectionManager(encodingParameters, preferredCodecs, options) {
        var _this = _super.call(this) || this;
        options = Object.assign({
            audioContextFactory: isFirefox
                ? __webpack_require__(/*! ../../webaudio/audiocontext */ "./node_modules/twilio-video/es5/webaudio/audiocontext.js")
                : null,
            PeerConnectionV2: PeerConnectionV2
        }, options);
        var audioContext = options.audioContextFactory
            ? options.audioContextFactory.getOrCreate(_this)
            : null;
        // NOTE(mroberts): If we're using an AudioContext, we don't need to specify
        // `offerToReceiveAudio` in RTCOfferOptions.
        var offerOptions = audioContext
            ? { offerToReceiveVideo: true }
            : { offerToReceiveAudio: true, offerToReceiveVideo: true };
        Object.defineProperties(_this, {
            _audioContextFactory: {
                value: options.audioContextFactory
            },
            _closedPeerConnectionIds: {
                value: new Set()
            },
            _configuration: {
                writable: true,
                value: null
            },
            _configurationDeferred: {
                writable: true,
                value: util.defer()
            },
            _connectionState: {
                value: 'new',
                writable: true
            },
            _dummyAudioTrackSender: {
                value: audioContext
                    ? new MediaTrackSender(createDummyAudioMediaStreamTrack(audioContext))
                    : null
            },
            _encodingParameters: {
                value: encodingParameters
            },
            _iceConnectionState: {
                writable: true,
                value: 'new'
            },
            _dataTrackSenders: {
                writable: true,
                value: new Set()
            },
            _lastConnectionState: {
                value: 'new',
                writable: true
            },
            _lastIceConnectionState: {
                writable: true,
                value: 'new'
            },
            _mediaTrackSenders: {
                writable: true,
                value: new Set()
            },
            _offerOptions: {
                value: offerOptions
            },
            _peerConnections: {
                value: new Map()
            },
            _preferredCodecs: {
                value: preferredCodecs
            },
            _sessionTimeout: {
                value: null,
                writable: true
            },
            _PeerConnectionV2: {
                value: options.PeerConnectionV2
            }
        });
        return _this;
    }
    PeerConnectionManager.prototype.setEffectiveAdaptiveSimulcast = function (effectiveAdaptiveSimulcast) {
        this._peerConnections.forEach(function (pc) { return pc.setEffectiveAdaptiveSimulcast(effectiveAdaptiveSimulcast); });
        this._preferredCodecs.video.forEach(function (cs) {
            if ('adaptiveSimulcast' in cs) {
                cs.adaptiveSimulcast = effectiveAdaptiveSimulcast;
            }
        });
    };
    Object.defineProperty(PeerConnectionManager.prototype, "connectionState", {
        /**
         * A summarized RTCPeerConnectionState across all the
         * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.
         * @property {RTCPeerConnectionState}
         */
        get: function () {
            return this._connectionState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PeerConnectionManager.prototype, "iceConnectionState", {
        /**
         * A summarized RTCIceConnectionState across all the
         * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.
         * @property {RTCIceConnectionState}
         */
        get: function () {
            return this._iceConnectionState;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Close the {@link PeerConnectionV2}s which are no longer relevant.
     * @param {Array<object>} peerConnectionStates
     * @returns {this}
     */
    PeerConnectionManager.prototype._closeAbsentPeerConnections = function (peerConnectionStates) {
        var peerConnectionIds = new Set(peerConnectionStates.map(function (peerConnectionState) { return peerConnectionState.id; }));
        this._peerConnections.forEach(function (peerConnection) {
            if (!peerConnectionIds.has(peerConnection.id)) {
                peerConnection._close();
            }
        });
        return this;
    };
    /**
     * Get the {@link PeerConnectionManager}'s configuration.
     * @private
     * @returns {Promise<object>}
     */
    PeerConnectionManager.prototype._getConfiguration = function () {
        return this._configurationDeferred.promise;
    };
    /**
     * Get or create a {@link PeerConnectionV2}.
     * @private
     * @param {string} id
     * @param {object} [configuration]
     * @returns {PeerConnectionV2}
     */
    PeerConnectionManager.prototype._getOrCreate = function (id, configuration) {
        var _this = this;
        var self = this;
        var peerConnection = this._peerConnections.get(id);
        if (!peerConnection) {
            var PeerConnectionV2_1 = this._PeerConnectionV2;
            var options = Object.assign({
                dummyAudioMediaStreamTrack: this._dummyAudioTrackSender
                    ? this._dummyAudioTrackSender.track
                    : null,
                offerOptions: this._offerOptions
            }, this._sessionTimeout ? {
                sessionTimeout: this._sessionTimeout
            } : {}, configuration);
            try {
                peerConnection = new PeerConnectionV2_1(id, this._encodingParameters, this._preferredCodecs, options);
            }
            catch (e) {
                throw new MediaConnectionError();
            }
            this._peerConnections.set(peerConnection.id, peerConnection);
            peerConnection.on('candidates', this.queue.bind(this, 'candidates'));
            peerConnection.on('description', this.queue.bind(this, 'description'));
            peerConnection.on('trackAdded', this.queue.bind(this, 'trackAdded'));
            peerConnection.on('stateChanged', function stateChanged(state) {
                if (state === 'closed') {
                    peerConnection.removeListener('stateChanged', stateChanged);
                    self._dataTrackSenders.forEach(function (sender) { return peerConnection.removeDataTrackSender(sender); });
                    self._mediaTrackSenders.forEach(function (sender) { return peerConnection.removeMediaTrackSender(sender); });
                    self._peerConnections.delete(peerConnection.id);
                    self._closedPeerConnectionIds.add(peerConnection.id);
                    updateConnectionState(self);
                    updateIceConnectionState(self);
                }
            });
            peerConnection.on('connectionStateChanged', function () { return updateConnectionState(_this); });
            peerConnection.on('iceConnectionStateChanged', function () { return updateIceConnectionState(_this); });
            this._dataTrackSenders.forEach(peerConnection.addDataTrackSender, peerConnection);
            this._mediaTrackSenders.forEach(peerConnection.addMediaTrackSender, peerConnection);
            updateIceConnectionState(this);
        }
        return peerConnection;
    };
    /**
     * Close all the {@link PeerConnectionV2}s in this {@link PeerConnectionManager}.
     * @returns {this}
     */
    PeerConnectionManager.prototype.close = function () {
        this._peerConnections.forEach(function (peerConnection) {
            peerConnection.close();
        });
        if (this._dummyAudioTrackSender) {
            this._dummyAudioTrackSender.stop();
        }
        if (this._audioContextFactory) {
            this._audioContextFactory.release(this);
        }
        updateIceConnectionState(this);
        return this;
    };
    /**
     * Create a new {@link PeerConnectionV2} on this {@link PeerConnectionManager}.
     * Then, create a new offer with the newly-created {@link PeerConnectionV2}.
     * @return {Promise<this>}
     */
    PeerConnectionManager.prototype.createAndOffer = function () {
        var _this = this;
        return this._getConfiguration().then(function (configuration) {
            var id;
            do {
                id = util.makeUUID();
            } while (_this._peerConnections.has(id));
            return _this._getOrCreate(id, configuration);
        }).then(function (peerConnection) {
            return peerConnection.offer();
        }).then(function () {
            return _this;
        });
    };
    /**
     * Get the {@link DataTrackReceiver}s and {@link MediaTrackReceiver}s of all
     * the {@link PeerConnectionV2}s.
     * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers
     */
    PeerConnectionManager.prototype.getTrackReceivers = function () {
        return util.flatMap(this._peerConnections, function (peerConnection) { return peerConnection.getTrackReceivers(); });
    };
    /**
     * Get the states of all {@link PeerConnectionV2}s.
     * @returns {Array<object>}
     */
    PeerConnectionManager.prototype.getStates = function () {
        var peerConnectionStates = [];
        this._peerConnections.forEach(function (peerConnection) {
            var peerConnectionState = peerConnection.getState();
            if (peerConnectionState) {
                peerConnectionStates.push(peerConnectionState);
            }
        });
        return peerConnectionStates;
    };
    /**
     * Set the {@link PeerConnectionManager}'s configuration.
     * @param {object} configuration
     * @returns {this}
     */
    PeerConnectionManager.prototype.setConfiguration = function (configuration) {
        if (this._configuration) {
            this._configurationDeferred = util.defer();
            this._peerConnections.forEach(function (peerConnection) {
                peerConnection.setConfiguration(configuration);
            });
        }
        this._configuration = configuration;
        this._configurationDeferred.resolve(configuration);
        return this;
    };
    /**
     * Set the ICE reconnect timeout period for all {@link PeerConnectionV2}s.
     * @param {number} period - Period in milliseconds.
     * @returns {this}
     */
    PeerConnectionManager.prototype.setIceReconnectTimeout = function (period) {
        if (this._sessionTimeout === null) {
            this._peerConnections.forEach(function (peerConnection) {
                peerConnection.setIceReconnectTimeout(period);
            });
            this._sessionTimeout = period;
        }
        return this;
    };
    /**
     * Set the {@link DataTrackSender}s and {@link MediaTrackSender}s on the
     * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.
     * @param {Array<DataTrackSender|MediaTrackSender>} trackSenders
     * @returns {this}
     */
    PeerConnectionManager.prototype.setTrackSenders = function (trackSenders) {
        var dataTrackSenders = new Set(trackSenders.filter(function (trackSender) { return trackSender.kind === 'data'; }));
        var mediaTrackSenders = new Set(trackSenders
            .filter(function (trackSender) { return trackSender && (trackSender.kind === 'audio' || trackSender.kind === 'video'); }));
        var changes = getTrackSenderChanges(this, dataTrackSenders, mediaTrackSenders);
        this._dataTrackSenders = dataTrackSenders;
        this._mediaTrackSenders = mediaTrackSenders;
        applyTrackSenderChanges(this, changes);
        return this;
    };
    /**
     * Update the {@link PeerConnectionManager}.
     * @param {Array<object>} peerConnectionStates
     * @param {boolean} [synced=false]
     * @returns {Promise<this>}
     */
    PeerConnectionManager.prototype.update = function (peerConnectionStates, synced) {
        var _this = this;
        if (synced === void 0) { synced = false; }
        if (synced) {
            this._closeAbsentPeerConnections(peerConnectionStates);
        }
        return this._getConfiguration().then(function (configuration) {
            return Promise.all(peerConnectionStates.map(function (peerConnectionState) {
                if (_this._closedPeerConnectionIds.has(peerConnectionState.id)) {
                    return null;
                }
                var peerConnection = _this._getOrCreate(peerConnectionState.id, configuration);
                return peerConnection.update(peerConnectionState);
            }));
        }).then(function () {
            return _this;
        });
    };
    /**
     * Get the {@link PeerConnectionManager}'s media statistics.
     * @returns {Promise.<Map<PeerConnectionV2#id, StandardizedStatsResponse>>}
     */
    PeerConnectionManager.prototype.getStats = function () {
        var peerConnections = Array.from(this._peerConnections.values());
        return Promise.all(peerConnections.map(function (peerConnection) { return peerConnection.getStats().then(function (response) { return [
            peerConnection.id,
            response
        ]; }); })).then(function (responses) { return new Map(responses); });
    };
    return PeerConnectionManager;
}(QueueingEventEmitter));
/**
 * Create a dummy audio MediaStreamTrack with the given AudioContext.
 * @private
 * @param {AudioContext} audioContext
 * @return {MediaStreamTrack}
 */
function createDummyAudioMediaStreamTrack(audioContext) {
    var mediaStreamDestination = audioContext.createMediaStreamDestination();
    return mediaStreamDestination.stream.getAudioTracks()[0];
}
/**
 * @event {PeerConnectionManager#candidates}
 * @param {object} candidates
 */
/**
 * @event {PeerConnectionManager#connectionStateChanged}
 */
/**
 * @event {PeerConnectionManager#description}
 * @param {object} description
 */
/**
 * @event {PeerConnectionManager#iceConnectionStateChanged}
 */
/**
 * @event {PeerConnectionManager#trackAdded}
 * @param {MediaStreamTrack|DataTrackReceiver} mediaStreamTrackOrDataTrackReceiver
 */
/**
 * Apply {@link TrackSenderChanges}.
 * @param {PeerConnectionManager} peerConnectionManager
 * @param {TrackSenderChanges} changes
 * @returns {void}
 */
function applyTrackSenderChanges(peerConnectionManager, changes) {
    if (changes.data.add.size
        || changes.data.remove.size
        || changes.media.add.size
        || changes.media.remove.size) {
        peerConnectionManager._peerConnections.forEach(function (peerConnection) {
            changes.data.remove.forEach(peerConnection.removeDataTrackSender, peerConnection);
            changes.media.remove.forEach(peerConnection.removeMediaTrackSender, peerConnection);
            changes.data.add.forEach(peerConnection.addDataTrackSender, peerConnection);
            changes.media.add.forEach(peerConnection.addMediaTrackSender, peerConnection);
            if (changes.media.add.size
                || changes.media.remove.size
                || (changes.data.add.size && !peerConnection.isApplicationSectionNegotiated)) {
                peerConnection.offer();
            }
        });
    }
}
/**
 * @interface DataTrackSenderChanges
 * @property {Set<DataTrackSender>} add
 * @property {Set<DataTrackSender>} remove
 */
/**
 * Get the {@Link DataTrackSender} changes.
 * @param {PeerConnectionManager} peerConnectionManager
 * @param {Array<DataTrackSender>} dataTrackSenders
 * @returns {DataTrackSenderChanges} changes
 */
function getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders) {
    var dataTrackSendersToAdd = util.difference(dataTrackSenders, peerConnectionManager._dataTrackSenders);
    var dataTrackSendersToRemove = util.difference(peerConnectionManager._dataTrackSenders, dataTrackSenders);
    return {
        add: dataTrackSendersToAdd,
        remove: dataTrackSendersToRemove
    };
}
/**
 * @interface TrackSenderChanges
 * @property {DataTrackSenderChanges} data
 * @property {MediaTrackSenderChanges} media
 */
/**
 * Get {@link DataTrackSender} and {@link MediaTrackSender} changes.
 * @param {PeerConnectionManager} peerConnectionManager
 * @param {Array<DataTrackSender>} dataTrackSenders
 * @param {Array<MediaTrackSender>} mediaTrackSenders
 * @returns {TrackSenderChanges} changes
 */
function getTrackSenderChanges(peerConnectionManager, dataTrackSenders, mediaTrackSenders) {
    return {
        data: getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders),
        media: getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders)
    };
}
/**
 * @interface MediaTrackSenderChanges
 * @property {Set<MediaTrackSender>} add
 * @property {Set<MediaTrackSender>} remove
 */
/**
 * Get the {@link MediaTrackSender} changes.
 * @param {PeerConnectionManager} peerConnectionManager
 * @param {Array<MediaTrackSender>} mediaTrackSenders
 * @returns {MediaTrackSenderChanges} changes
 */
function getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders) {
    var mediaTrackSendersToAdd = util.difference(mediaTrackSenders, peerConnectionManager._mediaTrackSenders);
    var mediaTrackSendersToRemove = util.difference(peerConnectionManager._mediaTrackSenders, mediaTrackSenders);
    return {
        add: mediaTrackSendersToAdd,
        remove: mediaTrackSendersToRemove
    };
}
/**
 * This object maps RTCIceConnectionState and RTCPeerConnectionState values to a "rank".
 */
var toRank = {
    new: 0,
    checking: 1,
    connecting: 2,
    connected: 3,
    completed: 4,
    disconnected: -1,
    failed: -2,
    closed: -3
};
/**
 * This object maps "rank" back to RTCIceConnectionState or RTCPeerConnectionState values.
 */
var fromRank;
/**
 * `Object.keys` is not supported in older browsers, so we can't just
 * synchronously call it in this module; we need to defer invoking it until we
 * know we're in a modern environment (i.e., anything that supports WebRTC).
 * @returns {object} fromRank
 */
function createFromRank() {
    return Object.keys(toRank).reduce(function (fromRank, state) {
        var _a;
        return Object.assign(fromRank, (_a = {}, _a[toRank[state]] = state, _a));
    }, {});
}
/**
 * Summarize RTCIceConnectionStates or RTCPeerConnectionStates.
 * @param {Array<RTCIceConnectionState>|Array<RTCPeerConnectionState>} states
 * @returns {RTCIceConnectionState|RTCPeerConnectionState} summary
 */
function summarizeIceOrPeerConnectionStates(states) {
    if (!states.length) {
        return 'new';
    }
    fromRank = fromRank || createFromRank();
    return states.reduce(function (state1, state2) {
        return fromRank[Math.max(toRank[state1], toRank[state2])];
    });
}
/**
 * Update the {@link PeerConnectionManager}'s `iceConnectionState`, and emit an
 * "iceConnectionStateChanged" event, if necessary.
 * @param {PeerConnectionManager} pcm
 * @returns {void}
 */
function updateIceConnectionState(pcm) {
    pcm._lastIceConnectionState = pcm.iceConnectionState;
    pcm._iceConnectionState = summarizeIceOrPeerConnectionStates(__spreadArray([], __read(pcm._peerConnections.values())).map(function (pcv2) { return pcv2.iceConnectionState; }));
    if (pcm.iceConnectionState !== pcm._lastIceConnectionState) {
        pcm.emit('iceConnectionStateChanged');
    }
}
/**
 * Update the {@link PeerConnectionManager}'s `connectionState`, and emit a
 * "connectionStateChanged" event, if necessary.
 * @param {PeerConnectionManager} pcm
 * @returns {void}
 */
function updateConnectionState(pcm) {
    pcm._lastConnectionState = pcm.connectionState;
    pcm._connectionState = summarizeIceOrPeerConnectionStates(__spreadArray([], __read(pcm._peerConnections.values())).map(function (pcv2) { return pcv2.connectionState; }));
    if (pcm.connectionState !== pcm._lastConnectionState) {
        pcm.emit('connectionStateChanged');
    }
}
module.exports = PeerConnectionManager;
//# sourceMappingURL=peerconnectionmanager.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/publisherhintsignaling.js":
/*!******************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/publisherhintsignaling.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint callback-return:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaSignaling = __webpack_require__(/*! ./mediasignaling */ "./node_modules/twilio-video/es5/signaling/v2/mediasignaling.js");
var messageId = 1;
var PublisherHintsSignaling = /** @class */ (function (_super) {
    __extends(PublisherHintsSignaling, _super);
    /**
     * Construct a {@link RenderHintsSignaling}.
     */
    function PublisherHintsSignaling(getReceiver, options) {
        var _this = _super.call(this, getReceiver, 'publisher_hints', options) || this;
        _this.on('ready', function (transport) {
            _this._log.debug('publisher_hints transport ready:', transport);
            transport.on('message', function (message) {
                _this._log.debug('Incoming: ', message);
                switch (message.type) {
                    case 'publisher_hints':
                        if (message.publisher && message.publisher.hints && message.publisher.id) {
                            _this._processPublisherHints(message.publisher.hints, message.publisher.id);
                        }
                        break;
                    default:
                        _this._log.warn('Unknown message type: ', message.type);
                        break;
                }
            });
        });
        return _this;
    }
    PublisherHintsSignaling.prototype.sendTrackReplaced = function (_a) {
        var trackSid = _a.trackSid;
        if (!this._transport) {
            return;
        }
        var payLoad = {
            type: 'client_reset',
            track: trackSid,
            id: messageId++
        };
        this._log.debug('Outgoing: ', payLoad);
        this._transport.publish(payLoad);
    };
    PublisherHintsSignaling.prototype.sendHintResponse = function (_a) {
        var id = _a.id, hints = _a.hints;
        if (!this._transport) {
            return;
        }
        var payLoad = {
            type: 'publisher_hints',
            id: id,
            hints: hints
        };
        this._log.debug('Outgoing: ', payLoad);
        this._transport.publish(payLoad);
    };
    /**
     * @private
     */
    PublisherHintsSignaling.prototype._processPublisherHints = function (hints, id) {
        try {
            this.emit('updated', hints, id);
        }
        catch (ex) {
            this._log.error('error processing hints:', ex);
        }
    };
    return PublisherHintsSignaling;
}(MediaSignaling));
module.exports = PublisherHintsSignaling;
//# sourceMappingURL=publisherhintsignaling.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/recording.js":
/*!*****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/recording.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RecordingSignaling = __webpack_require__(/*! ../recording */ "./node_modules/twilio-video/es5/signaling/recording.js");
/**
 * @extends RecordingSignaling
 */
var RecordingV2 = /** @class */ (function (_super) {
    __extends(RecordingV2, _super);
    /**
     * Construct a {@link RecordingV2}.
     */
    function RecordingV2() {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _revision: {
                value: 1,
                writable: true
            }
        });
        return _this;
    }
    /**
     * Compare the {@link RecordingV2} to a {@link RecordingV2#Representation}
     * of itself and perform any updates necessary.
     * @param {RecordingV2#Representation} recording
     * @returns {this}
     * @fires RecordingSignaling#updated
     */
    RecordingV2.prototype.update = function (recording) {
        if (recording.revision < this._revision) {
            return this;
        }
        this._revision = recording.revision;
        return this.enable(recording.is_recording);
    };
    return RecordingV2;
}(RecordingSignaling));
/**
 * The Room Signaling Protocol (RSP) representation of a {@link RecordingV2}
 * @typedef {object} RecordingV2#Representation
 * @property {boolean} enabled
 * @property {number} revision
 */
module.exports = RecordingV2;
//# sourceMappingURL=recording.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/remoteparticipant.js":
/*!*************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/remoteparticipant.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteParticipantSignaling = __webpack_require__(/*! ../remoteparticipant */ "./node_modules/twilio-video/es5/signaling/remoteparticipant.js");
var RemoteTrackPublicationV2 = __webpack_require__(/*! ./remotetrackpublication */ "./node_modules/twilio-video/es5/signaling/v2/remotetrackpublication.js");
/**
 * @extends RemoteParticipantSignaling
 * @property {?number} revision
 */
var RemoteParticipantV2 = /** @class */ (function (_super) {
    __extends(RemoteParticipantV2, _super);
    /**
     * Construct a {@link RemoteParticipantV2}.
     * @param {object} participantState
     * @param {function(Track.SID): boolean} getInitialTrackSwitchOffState
     * @param {function(Track.SID, Track.Priority): boolean} setPriority
     * @param {function(Track.SID, ClientRenderHint): Promise<void>} setRenderHint
     * @param {function(Track.SID): void} clearTrackHint
     * @param {object} [options]
     */
    function RemoteParticipantV2(participantState, getInitialTrackSwitchOffState, setPriority, setRenderHint, clearTrackHint, options) {
        var _this = _super.call(this, participantState.sid, participantState.identity) || this;
        options = Object.assign({
            RemoteTrackPublicationSignaling: RemoteTrackPublicationV2,
            getPendingTrackReceiver: function () { return null; }
        }, options);
        Object.defineProperties(_this, {
            _revision: {
                writable: true,
                value: null
            },
            _RemoteTrackPublicationSignaling: {
                value: options.RemoteTrackPublicationSignaling
            },
            _getInitialTrackSwitchOffState: {
                value: getInitialTrackSwitchOffState
            },
            _getPendingTrackReceiver: {
                value: options.getPendingTrackReceiver
            },
            updateSubscriberTrackPriority: {
                value: function (trackSid, priority) { return setPriority(trackSid, priority); }
            },
            updateTrackRenderHint: {
                value: function (trackSid, renderHint) { return setRenderHint(trackSid, renderHint); }
            },
            clearTrackHint: {
                value: function (trackSid) { return clearTrackHint(trackSid); }
            },
            revision: {
                enumerable: true,
                get: function () {
                    return this._revision;
                }
            }
        });
        _this.update(participantState);
        return _this;
    }
    /**
     * @private
     */
    RemoteParticipantV2.prototype._getOrCreateTrack = function (trackState) {
        var RemoteTrackPublicationV2 = this._RemoteTrackPublicationSignaling;
        var track = this.tracks.get(trackState.sid);
        if (!track) {
            var isSwitchedOff = this._getInitialTrackSwitchOffState(trackState.sid);
            track = new RemoteTrackPublicationV2(trackState, isSwitchedOff);
            this.addTrack(track);
        }
        return track;
    };
    /**
     * Update the {@link RemoteParticipantV2} with the new state.
     * @param {object} participantState
     * @returns {this}
     */
    RemoteParticipantV2.prototype.update = function (participantState) {
        var _this = this;
        if (this.revision !== null && participantState.revision <= this.revision) {
            return this;
        }
        this._revision = participantState.revision;
        var tracksToKeep = new Set();
        participantState.tracks.forEach(function (trackState) {
            var track = _this._getOrCreateTrack(trackState);
            track.update(trackState);
            tracksToKeep.add(track);
        });
        this.tracks.forEach(function (track) {
            if (!tracksToKeep.has(track)) {
                _this.removeTrack(track);
            }
        });
        switch (participantState.state) {
            case 'disconnected':
                this.disconnect();
                break;
            case 'reconnecting':
                this.reconnecting();
                break;
            case 'connected':
                this.connect(this.sid, this.identity);
                break;
        }
        return this;
    };
    return RemoteParticipantV2;
}(RemoteParticipantSignaling));
module.exports = RemoteParticipantV2;
//# sourceMappingURL=remoteparticipant.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/remotetrackpublication.js":
/*!******************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/remotetrackpublication.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteTrackPublicationSignaling = __webpack_require__(/*! ../remotetrackpublication */ "./node_modules/twilio-video/es5/signaling/remotetrackpublication.js");
/**
 * @extends RemoteTrackPublicationSignaling
 */
var RemoteTrackPublicationV2 = /** @class */ (function (_super) {
    __extends(RemoteTrackPublicationV2, _super);
    /**
     * Construct a {@link RemoteTrackPublicationV2}.
     * @param {RemoteTrackPublicationV2#Representation} track
     * @param {boolean} isSwitchedOff
     *
     */
    function RemoteTrackPublicationV2(track, isSwitchedOff) {
        return _super.call(this, track.sid, track.name, track.kind, track.enabled, track.priority, isSwitchedOff, 2) || this;
    }
    Object.defineProperty(RemoteTrackPublicationV2.prototype, "isSubscribed", {
        /**
         * Whether the {@link RemoteTrackPublicationV2} is subscribed to.
         * @property {boolean}
         */
        get: function () {
            return !!this.trackTransceiver;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Compare the {@link RemoteTrackPublicationV2} to a
     * {@link RemoteTrackPublicationV2#Representation} of itself and perform any
     * updates necessary.
     * @param {RemoteTrackPublicationV2#Representation} track
     * @returns {this}
     * @fires TrackSignaling#updated
     */
    RemoteTrackPublicationV2.prototype.update = function (track) {
        this.enable(track.enabled);
        this.setPriority(track.priority);
        return this;
    };
    return RemoteTrackPublicationV2;
}(RemoteTrackPublicationSignaling));
/**
 * The Room Signaling Protocol (RSP) representation of a {@link RemoteTrackPublicationV2}.
 * @typedef {LocalTrackPublicationV2#Representation} RemoteTrackPublicationV2#Representation
 * @property {boolean} subscribed
 */
module.exports = RemoteTrackPublicationV2;
//# sourceMappingURL=remotetrackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/renderhintssignaling.js":
/*!****************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/renderhintssignaling.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint callback-return:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaSignaling = __webpack_require__(/*! ./mediasignaling */ "./node_modules/twilio-video/es5/signaling/v2/mediasignaling.js");
var Timeout = __webpack_require__(/*! ../../util/timeout */ "./node_modules/twilio-video/es5/util/timeout.js");
var isDeepEqual = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js").isDeepEqual;
var RENDER_HINT_RESPONSE_TIME_MS = 2000; // time to wait for server response (before resending all hints.)
var messageId = 1;
var RenderHintsSignaling = /** @class */ (function (_super) {
    __extends(RenderHintsSignaling, _super);
    /**
     * Construct a {@link RenderHintsSignaling}.
     */
    function RenderHintsSignaling(getReceiver, options) {
        var _this = _super.call(this, getReceiver, 'render_hints', options) || this;
        Object.defineProperties(_this, {
            _trackSidsToRenderHints: {
                value: new Map()
            },
            _responseTimer: {
                value: new Timeout(function () {
                    _this._sendAllHints();
                    // once timer fires, for next round double the delay.
                    _this._responseTimer.setDelay(_this._responseTimer.delay * 2);
                }, RENDER_HINT_RESPONSE_TIME_MS, false),
            }
        });
        _this.on('ready', function (transport) {
            transport.on('message', function (message) {
                _this._log.debug('Incoming: ', message);
                switch (message.type) {
                    case 'render_hints':
                        _this._processHintResults((message && message.subscriber && message.subscriber.hints) || []);
                        break;
                    default:
                        _this._log.warn('Unknown message type: ', message.type);
                        break;
                }
            });
            // NOTE(mpatwardhan): When transport is set (either 1st time of after vms failover)
            // resend all track states.
            _this._sendAllHints();
        });
        return _this;
    }
    RenderHintsSignaling.prototype._sendAllHints = function () {
        var _this = this;
        // to force sending all hints simply mark all tracks as dirty.
        Array.from(this._trackSidsToRenderHints.keys()).forEach(function (trackSid) {
            var trackState = _this._trackSidsToRenderHints.get(trackSid);
            if (trackState.renderDimensions) {
                trackState.isDimensionDirty = true;
            }
            if ('enabled' in trackState) {
                trackState.isEnabledDirty = true;
            }
        });
        this._sendHints();
    };
    RenderHintsSignaling.prototype._processHintResults = function (hintResults) {
        var _this = this;
        this._responseTimer.clear();
        this._responseTimer.setDelay(RENDER_HINT_RESPONSE_TIME_MS);
        hintResults.forEach(function (hintResult) {
            if (hintResult.result !== 'OK') {
                _this._log.debug('Server error processing hint:', hintResult);
            }
        });
        this._sendHints();
    };
    RenderHintsSignaling.prototype._sendHints = function () {
        var _this = this;
        if (!this._transport || this._responseTimer.isSet) {
            return;
        }
        var hints = [];
        Array.from(this._trackSidsToRenderHints.keys()).forEach(function (trackSid) {
            var trackState = _this._trackSidsToRenderHints.get(trackSid);
            if (trackState.isEnabledDirty || trackState.isDimensionDirty) {
                var mspHint = {
                    'track': trackSid,
                };
                if (trackState.isEnabledDirty) {
                    mspHint.enabled = trackState.enabled;
                    trackState.isEnabledDirty = false;
                }
                if (trackState.isDimensionDirty) {
                    // eslint-disable-next-line camelcase
                    mspHint.render_dimensions = trackState.renderDimensions;
                    trackState.isDimensionDirty = false;
                }
                hints.push(mspHint);
            }
        });
        if (hints.length > 0) {
            var payLoad = {
                type: 'render_hints',
                subscriber: {
                    id: messageId++,
                    hints: hints
                }
            };
            this._log.debug('Outgoing: ', payLoad);
            this._transport.publish(payLoad);
            this._responseTimer.start();
        }
    };
    /**
     * @param {Track.SID} trackSid
     * @param {ClientRenderHint} renderHint
     */
    RenderHintsSignaling.prototype.setTrackHint = function (trackSid, renderHint) {
        var trackState = this._trackSidsToRenderHints.get(trackSid) || { isEnabledDirty: false, isDimensionDirty: false };
        if ('enabled' in renderHint && trackState.enabled !== renderHint.enabled) {
            trackState.enabled = !!renderHint.enabled;
            trackState.isEnabledDirty = true;
        }
        if (renderHint.renderDimensions && !isDeepEqual(renderHint.renderDimensions, trackState.renderDimensions)) {
            // eslint-disable-next-line camelcase
            trackState.renderDimensions = renderHint.renderDimensions;
            trackState.isDimensionDirty = true;
        }
        this._trackSidsToRenderHints.set(trackSid, trackState);
        this._sendHints();
    };
    /**
     * must be called when track is unsubscribed.
     * @param {Track.SID} trackSid
     */
    RenderHintsSignaling.prototype.clearTrackHint = function (trackSid) {
        this._trackSidsToRenderHints.delete(trackSid);
    };
    return RenderHintsSignaling;
}(MediaSignaling));
module.exports = RenderHintsSignaling;
//# sourceMappingURL=renderhintssignaling.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/room.js":
/*!************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/room.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var DominantSpeakerSignaling = __webpack_require__(/*! ./dominantspeakersignaling */ "./node_modules/twilio-video/es5/signaling/v2/dominantspeakersignaling.js");
var NetworkQualityMonitor = __webpack_require__(/*! ./networkqualitymonitor */ "./node_modules/twilio-video/es5/signaling/v2/networkqualitymonitor.js");
var NetworkQualitySignaling = __webpack_require__(/*! ./networkqualitysignaling */ "./node_modules/twilio-video/es5/signaling/v2/networkqualitysignaling.js");
var RecordingV2 = __webpack_require__(/*! ./recording */ "./node_modules/twilio-video/es5/signaling/v2/recording.js");
var RoomSignaling = __webpack_require__(/*! ../room */ "./node_modules/twilio-video/es5/signaling/room.js");
var RemoteParticipantV2 = __webpack_require__(/*! ./remoteparticipant */ "./node_modules/twilio-video/es5/signaling/v2/remoteparticipant.js");
var StatsReport = __webpack_require__(/*! ../../stats/statsreport */ "./node_modules/twilio-video/es5/stats/statsreport.js");
var TrackPrioritySignaling = __webpack_require__(/*! ./trackprioritysignaling */ "./node_modules/twilio-video/es5/signaling/v2/trackprioritysignaling.js");
var TrackSwitchOffSignaling = __webpack_require__(/*! ./trackswitchoffsignaling */ "./node_modules/twilio-video/es5/signaling/v2/trackswitchoffsignaling.js");
var RenderHintsSignaling = __webpack_require__(/*! ./renderhintssignaling */ "./node_modules/twilio-video/es5/signaling/v2/renderhintssignaling.js");
var PublisherHintsSignaling = __webpack_require__(/*! ./publisherhintsignaling.js */ "./node_modules/twilio-video/es5/signaling/v2/publisherhintsignaling.js");
var _a = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js"), DEFAULT_SESSION_TIMEOUT_SEC = _a.constants.DEFAULT_SESSION_TIMEOUT_SEC, createBandwidthProfilePayload = _a.createBandwidthProfilePayload, defer = _a.defer, difference = _a.difference, filterObject = _a.filterObject, flatMap = _a.flatMap, oncePerTick = _a.oncePerTick;
var MovingAverageDelta = __webpack_require__(/*! ../../util/movingaveragedelta */ "./node_modules/twilio-video/es5/util/movingaveragedelta.js");
var createTwilioError = __webpack_require__(/*! ../../util/twilio-video-errors */ "./node_modules/twilio-video/es5/util/twilio-video-errors.js").createTwilioError;
var STATS_PUBLISH_INTERVAL_MS = 10000;
/**
 * @extends RoomSignaling
 */
var RoomV2 = /** @class */ (function (_super) {
    __extends(RoomV2, _super);
    function RoomV2(localParticipant, initialState, transport, peerConnectionManager, options) {
        var _this = this;
        initialState.options = Object.assign({
            session_timeout: DEFAULT_SESSION_TIMEOUT_SEC
        }, initialState.options);
        options = Object.assign({
            DominantSpeakerSignaling: DominantSpeakerSignaling,
            NetworkQualityMonitor: NetworkQualityMonitor,
            NetworkQualitySignaling: NetworkQualitySignaling,
            RecordingSignaling: RecordingV2,
            RemoteParticipantSignaling: RemoteParticipantV2,
            TrackPrioritySignaling: TrackPrioritySignaling,
            TrackSwitchOffSignaling: TrackSwitchOffSignaling,
            bandwidthProfile: null,
            otherMediaSignalings: [],
            sessionTimeout: initialState.options.session_timeout * 1000,
            statsPublishIntervalMs: STATS_PUBLISH_INTERVAL_MS
        }, options);
        localParticipant.setBandwidthProfile(options.bandwidthProfile);
        peerConnectionManager.setIceReconnectTimeout(options.sessionTimeout);
        _this = _super.call(this, localParticipant, initialState.sid, initialState.name, options) || this;
        var getTrackReceiver = function (id) { return _this._getTrackReceiver(id); };
        var log = _this._log;
        Object.defineProperties(_this, {
            _disconnectedParticipantRevisions: {
                value: new Map()
            },
            _NetworkQualityMonitor: {
                value: options.NetworkQualityMonitor
            },
            _lastBandwidthProfileRevision: {
                value: localParticipant.bandwidthProfileRevision,
                writable: true
            },
            _networkQualityMonitor: {
                value: null,
                writable: true
            },
            _networkQualityConfiguration: {
                value: localParticipant.networkQualityConfiguration
            },
            _peerConnectionManager: {
                value: peerConnectionManager
            },
            _published: {
                value: new Map()
            },
            _publishedRevision: {
                value: 0,
                writable: true
            },
            _RemoteParticipantSignaling: {
                value: options.RemoteParticipantSignaling
            },
            _subscribed: {
                value: new Map()
            },
            _subscribedRevision: {
                value: 0,
                writable: true
            },
            _subscriptionFailures: {
                value: new Map()
            },
            _dominantSpeakerSignaling: {
                value: new options.DominantSpeakerSignaling(getTrackReceiver, { log: log })
            },
            _networkQualitySignaling: {
                value: new options.NetworkQualitySignaling(getTrackReceiver, localParticipant.networkQualityConfiguration, { log: log })
            },
            _renderHintsSignaling: {
                value: new RenderHintsSignaling(getTrackReceiver, { log: log }),
            },
            _publisherHintsSignaling: {
                value: new PublisherHintsSignaling(getTrackReceiver, { log: log }),
            },
            _trackPrioritySignaling: {
                value: new options.TrackPrioritySignaling(getTrackReceiver, { log: log }),
            },
            _trackSwitchOffSignaling: {
                value: new options.TrackSwitchOffSignaling(getTrackReceiver, { log: log }),
            },
            _pendingSwitchOffStates: {
                value: new Map()
            },
            _transport: {
                value: transport
            },
            _trackReceiverDeferreds: {
                value: new Map()
            },
            mediaRegion: {
                enumerable: true,
                value: initialState.options.media_region || null
            }
        });
        _this._init(localParticipant, peerConnectionManager, transport, options, initialState);
        return _this;
    }
    Object.defineProperty(RoomV2.prototype, "connectionState", {
        /**
         * The PeerConnection state.
         * @property {RTCPeerConnectionState}
         */
        get: function () {
            return this._peerConnectionManager.connectionState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RoomV2.prototype, "signalingConnectionState", {
        /**
         * The Signaling Connection State.
         * @property {string} - "connected", "reconnecting", "disconnected"
         */
        get: function () {
            return this._transport.state === 'syncing'
                ? 'reconnecting'
                : this._transport.state;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RoomV2.prototype, "iceConnectionState", {
        /**
         * The Ice Connection State.
         * @property {RTCIceConnectionState}
         */
        get: function () {
            return this._peerConnectionManager.iceConnectionState;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @private
     */
    RoomV2.prototype._deleteTrackReceiverDeferred = function (id) {
        return this._trackReceiverDeferreds.delete(id);
    };
    /**
     * @private
     */
    RoomV2.prototype._getOrCreateTrackReceiverDeferred = function (id, idOrMid) {
        if (idOrMid === void 0) { idOrMid = 'id'; }
        var deferred = this._trackReceiverDeferreds.get(id) || defer();
        var trackReceivers = this._peerConnectionManager.getTrackReceivers();
        // NOTE(mmalavalli): In Firefox, there can be instances where a MediaStreamTrack
        // for the given Track ID already exists, for example, when a Track is removed
        // and added back. If that is the case, then we should resolve 'deferred'.
        var trackReceiver = trackReceivers.find(function (trackReceiver) { return trackReceiver[idOrMid] === id && trackReceiver.readyState !== 'ended'; });
        if (trackReceiver) {
            deferred.resolve(trackReceiver);
        }
        else {
            // NOTE(mmalavalli): Only add the 'deferred' to the map if it's not
            // resolved. This will prevent old copies of the MediaStreamTrack from
            // being used when the remote peer removes and re-adds a MediaStreamTrack.
            this._trackReceiverDeferreds.set(id, deferred);
        }
        return deferred;
    };
    /**
     * @private
     */
    RoomV2.prototype._addTrackReceiver = function (trackReceiver) {
        var deferred = this._getOrCreateTrackReceiverDeferred(trackReceiver.id);
        deferred.resolve(trackReceiver);
        return this;
    };
    /**
     * @private
     */
    RoomV2.prototype._createRemoteParticipant = function (participantState) {
        var _this = this;
        var RemoteParticipantV2 = this._RemoteParticipantSignaling;
        return new RemoteParticipantV2(participantState, function (trackSid) { return _this._getInitialTrackSwitchOffState(trackSid); }, function (trackSid, priority) { return _this._trackPrioritySignaling.sendTrackPriorityUpdate(trackSid, 'subscribe', priority); }, function (trackSid, hint) { return _this._renderHintsSignaling.setTrackHint(trackSid, hint); }, function (trackSid) { return _this._renderHintsSignaling.clearTrackHint(trackSid); });
    };
    /**
     * @private
     */
    RoomV2.prototype._disconnect = function (error) {
        var didDisconnect = _super.prototype._disconnect.call(this, error);
        if (didDisconnect) {
            this._teardownNetworkQualityMonitor();
            this._transport.disconnect();
            this._peerConnectionManager.close();
        }
        this.localParticipant.tracks.forEach(function (track) {
            track.publishFailed(error || new Error('LocalParticipant disconnected'));
        });
        return didDisconnect;
    };
    /**
     * @private
     */
    RoomV2.prototype._getTrackReceiver = function (id, idOrMid) {
        var _this = this;
        if (idOrMid === void 0) { idOrMid = 'id'; }
        return this._getOrCreateTrackReceiverDeferred(id, idOrMid).promise.then(function (trackReceiver) {
            _this._deleteTrackReceiverDeferred(id);
            return trackReceiver;
        });
    };
    /**
     * @private
     */
    RoomV2.prototype._getInitialTrackSwitchOffState = function (trackSid) {
        var initiallySwitchedOff = this._pendingSwitchOffStates.get(trackSid) || false;
        this._pendingSwitchOffStates.delete(trackSid);
        if (initiallySwitchedOff) {
            this._log.warn("[" + trackSid + "] was initially switched off! ");
        }
        return initiallySwitchedOff;
    };
    /**
     * @private
     */
    RoomV2.prototype._getTrackSidsToTrackSignalings = function () {
        var trackSidsToTrackSignalings = flatMap(this.participants, function (participant) { return Array.from(participant.tracks); });
        return new Map(trackSidsToTrackSignalings);
    };
    /**
     * @private
     */
    RoomV2.prototype._getOrCreateRemoteParticipant = function (participantState) {
        var participant = this.participants.get(participantState.sid);
        var self = this;
        if (!participant) {
            participant = this._createRemoteParticipant(participantState);
            participant.on('stateChanged', function stateChanged(state) {
                if (state === 'disconnected') {
                    participant.removeListener('stateChanged', stateChanged);
                    self.participants.delete(participant.sid);
                    self._disconnectedParticipantRevisions.set(participant.sid, participant.revision);
                }
            });
            this.connectParticipant(participant);
        }
        return participant;
    };
    /**
     * @private
     */
    RoomV2.prototype._getState = function () {
        return {
            participant: this.localParticipant.getState()
        };
    };
    /**
     * @private
     */
    RoomV2.prototype._init = function (localParticipant, peerConnectionManager, transport, options, initialState) {
        this._initTrackSwitchOffSignaling();
        this._initDominantSpeakerSignaling();
        this._initNetworkQualityMonitorSignaling();
        this._initPublisherHintSignaling();
        handleLocalParticipantEvents(this, localParticipant);
        handlePeerConnectionEvents(this, peerConnectionManager);
        handleTransportEvents(this, transport);
        periodicallyPublishStats(this, transport, options.statsPublishIntervalMs);
        this._update(initialState);
        // NOTE(mpatwardhan) after initial state we can find out if we are connected to a P2P or group room by checking if there is a mediaRegion.
        // if we are not connected to group room, turn off adaptive simulcast.
        this._peerConnectionManager.setEffectiveAdaptiveSimulcast(!!this.mediaRegion);
    };
    /**
     * @private
     */
    RoomV2.prototype._maybeAddBandwidthProfile = function (update) {
        var _a = this.localParticipant, bandwidthProfile = _a.bandwidthProfile, bandwidthProfileRevision = _a.bandwidthProfileRevision;
        if (bandwidthProfile && this._lastBandwidthProfileRevision < bandwidthProfileRevision) {
            this._lastBandwidthProfileRevision = bandwidthProfileRevision;
            return Object.assign({
                bandwidth_profile: createBandwidthProfilePayload(bandwidthProfile)
            }, update);
        }
        return update;
    };
    /**
     * @private
     */
    RoomV2.prototype._publishNewLocalParticipantState = function () {
        this._transport.publish(this._maybeAddBandwidthProfile(this._getState()));
    };
    /**
     * @private
     */
    RoomV2.prototype._publishPeerConnectionState = function (peerConnectionState) {
        /* eslint camelcase:0 */
        this._transport.publish(Object.assign({
            peer_connections: [peerConnectionState]
        }, this._getState()));
    };
    /**
     * @private
     */
    RoomV2.prototype._update = function (roomState) {
        var type = roomState.type;
        this._updateSubscribed(roomState);
        this._updateParticipants(roomState, type);
        this._handleSubscriptions();
        this._updatePeerConnections(roomState, type);
        this._updateRecording(roomState);
        this._updatePublished(roomState);
        this._connectLocalParticipant(roomState);
        this._setupMediaSignalings(roomState);
        return this;
    };
    /**
     * @private
     */
    RoomV2.prototype._connectLocalParticipant = function (_a) {
        var participant = _a.participant;
        if (!participant) {
            return;
        }
        var sid = participant.sid, identity = participant.identity;
        this.localParticipant.connect(sid, identity);
    };
    /**
     * @private
     */
    RoomV2.prototype._handleSubscriptions = function () {
        var _this = this;
        var trackSidsToTrackSignalings = this._getTrackSidsToTrackSignalings();
        this._subscriptionFailures.forEach(function (error, trackSid) {
            var trackSignaling = trackSidsToTrackSignalings.get(trackSid);
            if (trackSignaling) {
                _this._subscriptionFailures.delete(trackSid);
                trackSignaling.subscribeFailed(createTwilioError(error.code, error.message));
            }
        });
        trackSidsToTrackSignalings.forEach(function (trackSignaling) {
            var trackId = _this._subscribed.get(trackSignaling.sid);
            if (!trackId || (trackSignaling.isSubscribed && trackSignaling.trackTransceiver.id !== trackId)) {
                trackSignaling.setTrackTransceiver(null);
            }
            if (trackId) {
                _this._getTrackReceiver(trackId).then(function (trackReceiver) { return trackSignaling.setTrackTransceiver(trackReceiver); });
            }
        });
    };
    /**
     * @private
     */
    RoomV2.prototype._setupMediaSignalings = function (_a) {
        var mediaSignalings = _a.media_signaling;
        var otherMediaSignalings = this._trackSubscriptionsSignaling
            ? [this._trackSubscriptionsSignaling]
            : [];
        [
            this._dominantSpeakerSignaling,
            this._networkQualitySignaling,
            this._trackPrioritySignaling,
            this._trackSwitchOffSignaling,
            this._renderHintsSignaling,
            this._publisherHintsSignaling,
        ].concat(otherMediaSignalings).forEach(function (mediaSignaling) {
            var channel = mediaSignaling.channel;
            if (!mediaSignaling.isSetup
                && mediaSignalings
                && mediaSignalings[channel]
                && mediaSignalings[channel].transport
                && mediaSignalings[channel].transport.type === 'data-channel') {
                mediaSignaling.setup(mediaSignalings[channel].transport.label);
            }
        });
    };
    /**
     * @private
     */
    RoomV2.prototype._updateParticipants = function (_a, roomStateType) {
        var _this = this;
        var _b = _a.participants, participants = _b === void 0 ? [] : _b;
        var participantsToKeep = new Set();
        participants.forEach(function (participantState) {
            if (participantState.sid === _this.localParticipant.sid) {
                return;
            }
            // NOTE(mmalavalli): If the incoming revision for a disconnected Participant is less than or
            // equal to the revision when it was disconnected, then the state is old and can be ignored.
            // Otherwise, the Participant was most likely disconnected in a Large Group Room when it
            // stopped publishing media, and hence needs to be re-added.
            var disconnectedParticipantRevision = _this._disconnectedParticipantRevisions.get(participantState.sid);
            if (disconnectedParticipantRevision && participantState.revision <= disconnectedParticipantRevision) {
                return;
            }
            if (disconnectedParticipantRevision) {
                _this._disconnectedParticipantRevisions.delete(participantState.sid);
            }
            var participant = _this._getOrCreateRemoteParticipant(participantState);
            participant.update(participantState);
            participantsToKeep.add(participant);
        });
        if (roomStateType === 'synced') {
            this.participants.forEach(function (participant) {
                if (!participantsToKeep.has(participant)) {
                    participant.disconnect();
                }
            });
        }
    };
    /**
     * @private
     */
    RoomV2.prototype._updatePeerConnections = function (_a, roomStateType) {
        var peerConnections = _a.peer_connections;
        if (peerConnections) {
            this._peerConnectionManager.update(peerConnections, roomStateType === 'synced');
        }
    };
    /**
     * @private
     */
    RoomV2.prototype._updateRecording = function (_a) {
        var recording = _a.recording;
        if (recording) {
            this.recording.update(recording);
        }
    };
    /**
     * @private
     */
    RoomV2.prototype._updatePublished = function (_a) {
        var _this = this;
        var published = _a.published;
        if (!published || published.revision <= this._publishedRevision) {
            return;
        }
        this._publishedRevision = published.revision;
        published.tracks.forEach(function (track) {
            if (track.sid) {
                _this._published.set(track.id, track.sid);
            }
        });
        this.localParticipant.update(published);
    };
    /**
     * @private
     */
    RoomV2.prototype._updateSubscribed = function (_a) {
        var _this = this;
        var subscribed = _a.subscribed;
        if (!subscribed || subscribed.revision <= this._subscribedRevision) {
            return;
        }
        this._subscribedRevision = subscribed.revision;
        subscribed.tracks.forEach(function (trackState) {
            if (trackState.id) {
                _this._subscriptionFailures.delete(trackState.sid);
                _this._subscribed.set(trackState.sid, trackState.id);
            }
            else if (trackState.error && !_this._subscriptionFailures.has(trackState.sid)) {
                _this._subscriptionFailures.set(trackState.sid, trackState.error);
            }
        });
        var subscribedTrackSids = new Set(subscribed.tracks
            .filter(function (trackState) { return !!trackState.id; })
            .map(function (trackState) { return trackState.sid; }));
        this._subscribed.forEach(function (trackId, trackSid) {
            if (!subscribedTrackSids.has(trackSid)) {
                _this._subscribed.delete(trackSid);
            }
        });
    };
    RoomV2.prototype._initPublisherHintSignaling = function () {
        var _this = this;
        this._publisherHintsSignaling.on('updated', function (hints, id) {
            Promise.all(hints.map(function (hint) {
                return _this.localParticipant.setPublisherHint(hint.track, hint.encodings).then(function (result) {
                    return { track: hint.track, result: result };
                });
            })).then(function (hintResponses) {
                _this._publisherHintsSignaling.sendHintResponse({ id: id, hints: hintResponses });
            });
        });
        var handleReplaced = function (track) {
            if (track.kind === 'video') {
                track.trackTransceiver.on('replaced', function () {
                    _this._publisherHintsSignaling.sendTrackReplaced({ trackSid: track.sid });
                });
            }
        };
        // hook up for any existing and new tracks getting replaced.
        Array.from(this.localParticipant.tracks.values()).forEach(function (track) { return handleReplaced(track); });
        this.localParticipant.on('trackAdded', function (track) { return handleReplaced(track); });
    };
    RoomV2.prototype._initTrackSwitchOffSignaling = function () {
        var _this = this;
        this._trackSwitchOffSignaling.on('updated', function (tracksOff, tracksOn) {
            try {
                _this._log.debug('received trackSwitch: ', { tracksOn: tracksOn, tracksOff: tracksOff });
                var trackUpdates_1 = new Map();
                tracksOn.forEach(function (trackSid) { return trackUpdates_1.set(trackSid, true); });
                tracksOff.forEach(function (trackSid) {
                    if (trackUpdates_1.get(trackSid)) {
                        // NOTE(mpatwardhan): This means that VIDEO-3762 has been reproduced.
                        _this._log.warn(trackSid + " is DUPLICATED in both tracksOff and tracksOn list");
                    }
                    trackUpdates_1.set(trackSid, false);
                });
                _this.participants.forEach(function (participant) {
                    participant.tracks.forEach(function (track) {
                        var isOn = trackUpdates_1.get(track.sid);
                        if (typeof isOn !== 'undefined') {
                            track.setSwitchedOff(!isOn);
                            trackUpdates_1.delete(track.sid);
                        }
                    });
                });
                // NOTE(mpatwardhan): Cache any notification about the tracks that we do not yet know about.
                trackUpdates_1.forEach(function (isOn, trackSid) { return _this._pendingSwitchOffStates.set(trackSid, !isOn); });
            }
            catch (ex) {
                _this._log.error('error processing track switch off:', ex);
            }
        });
    };
    RoomV2.prototype._initDominantSpeakerSignaling = function () {
        var _this = this;
        this._dominantSpeakerSignaling.on('updated', function () { return _this.setDominantSpeaker(_this._dominantSpeakerSignaling.loudestParticipantSid); });
    };
    RoomV2.prototype._initNetworkQualityMonitorSignaling = function () {
        var _this = this;
        this._networkQualitySignaling.on('ready', function () {
            var networkQualityMonitor = new _this._NetworkQualityMonitor(_this._peerConnectionManager, _this._networkQualitySignaling);
            _this._networkQualityMonitor = networkQualityMonitor;
            networkQualityMonitor.on('updated', function () {
                if (_this.iceConnectionState === 'failed') {
                    return;
                }
                _this.localParticipant.setNetworkQualityLevel(networkQualityMonitor.level, networkQualityMonitor.levels);
                _this.participants.forEach(function (participant) {
                    var levels = networkQualityMonitor.remoteLevels.get(participant.sid);
                    if (levels) {
                        participant.setNetworkQualityLevel(levels.level, levels);
                    }
                });
            });
            networkQualityMonitor.start();
        });
        this._networkQualitySignaling.on('teardown', function () { return _this._teardownNetworkQualityMonitor(); });
    };
    RoomV2.prototype._teardownNetworkQualityMonitor = function () {
        if (this._networkQualityMonitor) {
            this._networkQualityMonitor.stop();
            this._networkQualityMonitor = null;
        }
    };
    /**
     * Get the {@link RoomV2}'s media statistics.
     * @returns {Promise.<Map<PeerConnectionV2#id, StandardizedStatsResponse>>}
     */
    RoomV2.prototype.getStats = function () {
        var _this = this;
        return this._peerConnectionManager.getStats().then(function (responses) {
            return new Map(Array.from(responses).map(function (_a) {
                var _b = __read(_a, 2), id = _b[0], response = _b[1];
                return [id, Object.assign({}, response, {
                        localAudioTrackStats: filterAndAddLocalTrackSids(_this, response.localAudioTrackStats),
                        localVideoTrackStats: filterAndAddLocalTrackSids(_this, response.localVideoTrackStats),
                        remoteAudioTrackStats: filterAndAddRemoteTrackSids(_this, response.remoteAudioTrackStats),
                        remoteVideoTrackStats: filterAndAddRemoteTrackSids(_this, response.remoteVideoTrackStats)
                    })];
            }));
        });
    };
    return RoomV2;
}(RoomSignaling));
/**
 * Filter out {@link TrackStats} that aren't in the collection while also
 * stamping their Track SIDs.
 * @param {Map<ID, SID>} idToSid
 * @param {Array<TrackStats>} trackStats
 * @returns {Array<TrackStats>}
 */
function filterAndAddTrackSids(idToSid, trackStats) {
    return trackStats.reduce(function (trackStats, trackStat) {
        var trackSid = idToSid.get(trackStat.trackId);
        return trackSid
            ? [Object.assign({}, trackStat, { trackSid: trackSid })].concat(trackStats)
            : trackStats;
    }, []);
}
/**
 * Filter out {@link LocalTrackStats} that aren't currently published while also
 * stamping their Track SIDs.
 * @param {RoomV2} roomV2
 * @param {Array<LocalTrackStats>} localTrackStats
 * @returns {Array<LocalTrackStats>}
 */
function filterAndAddLocalTrackSids(roomV2, localTrackStats) {
    return filterAndAddTrackSids(roomV2._published, localTrackStats);
}
/**
 * Filter out {@link RemoteTrackStats} that aren't currently subscribed while
 * also stamping their Track SIDs.
 * @param {RoomV2} roomV2
 * @param {Array<RemoteTrackStats>} remoteTrackStats
 * @returns {Array<RemoteTrackStats>}
 */
function filterAndAddRemoteTrackSids(roomV2, remoteTrackStats) {
    var idToSid = new Map(Array.from(roomV2._subscribed.entries()).map(function (_a) {
        var _b = __read(_a, 2), sid = _b[0], id = _b[1];
        return [id, sid];
    }));
    return filterAndAddTrackSids(idToSid, remoteTrackStats);
}
/**
 * @typedef {object} RoomV2#Representation
 * @property {string} name
 * @property {LocalParticipantV2#Representation} participant
 * @property {?Array<RemoteParticipantV2#Representation>} participants
 * @property {?Array<PeerConnectionV2#Representation>} peer_connections
 * @property {?RecordingV2#Representation} recording
 * @property {string} sid
 */
function handleLocalParticipantEvents(roomV2, localParticipant) {
    var localParticipantUpdated = oncePerTick(function () {
        roomV2._publishNewLocalParticipantState();
    });
    var renegotiate = oncePerTick(function () {
        var trackSenders = flatMap(localParticipant.tracks, function (trackV2) { return trackV2.trackTransceiver; });
        roomV2._peerConnectionManager.setTrackSenders(trackSenders);
    });
    localParticipant.on('trackAdded', renegotiate);
    localParticipant.on('trackRemoved', renegotiate);
    localParticipant.on('updated', localParticipantUpdated);
    roomV2.on('stateChanged', function stateChanged(state) {
        if (state === 'disconnected') {
            localParticipant.removeListener('trackAdded', renegotiate);
            localParticipant.removeListener('trackRemoved', renegotiate);
            localParticipant.removeListener('updated', localParticipantUpdated);
            roomV2.removeListener('stateChanged', stateChanged);
            localParticipant.disconnect();
        }
    });
    roomV2.on('signalingConnectionStateChanged', function () {
        var localParticipant = roomV2.localParticipant, signalingConnectionState = roomV2.signalingConnectionState;
        var identity = localParticipant.identity, sid = localParticipant.sid;
        switch (signalingConnectionState) {
            case 'connected':
                localParticipant.connect(sid, identity);
                break;
            case 'reconnecting':
                localParticipant.reconnecting();
                break;
        }
    });
}
function handlePeerConnectionEvents(roomV2, peerConnectionManager) {
    peerConnectionManager.on('description', function onDescription(description) {
        roomV2._publishPeerConnectionState(description);
    });
    peerConnectionManager.dequeue('description');
    peerConnectionManager.on('candidates', function onCandidates(candidates) {
        roomV2._publishPeerConnectionState(candidates);
    });
    peerConnectionManager.dequeue('candidates');
    peerConnectionManager.on('trackAdded', roomV2._addTrackReceiver.bind(roomV2));
    peerConnectionManager.dequeue('trackAdded');
    peerConnectionManager.getTrackReceivers().forEach(roomV2._addTrackReceiver, roomV2);
    peerConnectionManager.on('connectionStateChanged', function () {
        roomV2.emit('connectionStateChanged');
    });
    peerConnectionManager.on('iceConnectionStateChanged', function () {
        roomV2.emit('iceConnectionStateChanged');
        if (roomV2.iceConnectionState === 'failed') {
            if (roomV2.localParticipant.networkQualityLevel !== null) {
                roomV2.localParticipant.setNetworkQualityLevel(0);
            }
            roomV2.participants.forEach(function (participant) {
                if (participant.networkQualityLevel !== null) {
                    participant.setNetworkQualityLevel(0);
                }
            });
        }
    });
}
function handleTransportEvents(roomV2, transport) {
    transport.on('message', roomV2._update.bind(roomV2));
    transport.on('stateChanged', function stateChanged(state, error) {
        if (state === 'disconnected') {
            if (roomV2.state !== 'disconnected') {
                roomV2._disconnect(error);
            }
            transport.removeListener('stateChanged', stateChanged);
        }
        roomV2.emit('signalingConnectionStateChanged');
    });
}
/**
 * Periodically publish {@link StatsReport}s.
 * @private
 * @param {RoomV2} roomV2
 * @param {Transport} transport
 * @param {Number} intervalMs
 */
function periodicallyPublishStats(roomV2, transport, intervalMs) {
    var movingAverageDeltas = new Map();
    var oddPublishCount = false;
    var interval = setInterval(function () {
        roomV2.getStats().then(function (stats) {
            oddPublishCount = !oddPublishCount;
            stats.forEach(function (response, id) {
                // NOTE(mmalavalli): A StatsReport is used to publish a "stats-report"
                // event instead of using StandardizedStatsResponse directly because
                // StatsReport will add zeros to properties that do not exist.
                var report = new StatsReport(id, response, true /* prepareForInsights */);
                // NOTE(mmalavalli): Since A/V sync metrics are not part of the StatsReport class,
                // we add them to the insights payload here.
                transport.publishEvent('quality', 'stats-report', 'info', {
                    audioTrackStats: report.remoteAudioTrackStats.map(function (trackStat, i) {
                        return addAVSyncMetricsToRemoteTrackStats(trackStat, response.remoteAudioTrackStats[i], movingAverageDeltas);
                    }),
                    localAudioTrackStats: report.localAudioTrackStats.map(function (trackStat, i) {
                        return addAVSyncMetricsToLocalTrackStats(trackStat, response.localAudioTrackStats[i], movingAverageDeltas);
                    }),
                    localVideoTrackStats: report.localVideoTrackStats.map(function (trackStat, i) {
                        return addAVSyncMetricsToLocalTrackStats(trackStat, response.localVideoTrackStats[i], movingAverageDeltas);
                    }),
                    peerConnectionId: report.peerConnectionId,
                    videoTrackStats: report.remoteVideoTrackStats.map(function (trackStat, i) {
                        return addAVSyncMetricsToRemoteTrackStats(trackStat, response.remoteVideoTrackStats[i], movingAverageDeltas);
                    }),
                });
                // NOTE(mmalavalli): Clean up entries for Tracks that are no longer published or subscribed to.
                var keys = flatMap([
                    'localAudioTrackStats',
                    'localVideoTrackStats',
                    'remoteAudioTrackStats',
                    'remoteVideoTrackStats'
                ], function (prop) { return report[prop].map(function (_a) {
                    var ssrc = _a.ssrc, trackSid = _a.trackSid;
                    return trackSid + "+" + ssrc;
                }); });
                var movingAverageDeltaKeysToBeRemoved = difference(Array.from(movingAverageDeltas.keys()), keys);
                movingAverageDeltaKeysToBeRemoved.forEach(function (key) { return movingAverageDeltas.delete(key); });
                if (oddPublishCount) {
                    // NOTE(mmalavalli): null properties of the "active-ice-candidate-pair"
                    // payload are assigned default values until the Insights gateway
                    // accepts null values.
                    var activeIceCandidatePair = replaceNullsWithDefaults(response.activeIceCandidatePair, report.peerConnectionId);
                    transport.publishEvent('quality', 'active-ice-candidate-pair', 'info', activeIceCandidatePair);
                }
            });
        }, function () {
            // Do nothing.
        });
    }, intervalMs);
    roomV2.on('stateChanged', function onStateChanged(state) {
        if (state === 'disconnected') {
            clearInterval(interval);
            roomV2.removeListener('stateChanged', onStateChanged);
        }
    });
}
/**
 * NOTE(mmalavalli): Since A/V sync metrics are not part of the public StatsReport class, we add them
 * only for reporting purposes.
 * @private
 */
function addAVSyncMetricsToLocalTrackStats(trackStats, trackResponse, movingAverageDeltas) {
    var framesEncoded = trackResponse.framesEncoded, packetsSent = trackResponse.packetsSent, totalEncodeTime = trackResponse.totalEncodeTime, totalPacketSendDelay = trackResponse.totalPacketSendDelay;
    var augmentedTrackStats = Object.assign({}, trackStats);
    var key = trackStats.trackSid + "+" + trackStats.ssrc;
    var trackMovingAverageDeltas = movingAverageDeltas.get(key) || new Map();
    if (typeof totalEncodeTime === 'number' && typeof framesEncoded === 'number') {
        var trackAvgEncodeDelayMovingAverageDelta = trackMovingAverageDeltas.get('avgEncodeDelay')
            || new MovingAverageDelta();
        trackAvgEncodeDelayMovingAverageDelta.putSample(totalEncodeTime * 1000, framesEncoded);
        augmentedTrackStats.avgEncodeDelay = Math.round(trackAvgEncodeDelayMovingAverageDelta.get());
        trackMovingAverageDeltas.set('avgEncodeDelay', trackAvgEncodeDelayMovingAverageDelta);
    }
    if (typeof totalPacketSendDelay === 'number' && typeof packetsSent === 'number') {
        var trackAvgPacketSendDelayMovingAverageDelta = trackMovingAverageDeltas.get('avgPacketSendDelay')
            || new MovingAverageDelta();
        trackAvgPacketSendDelayMovingAverageDelta.putSample(totalPacketSendDelay * 1000, packetsSent);
        augmentedTrackStats.avgPacketSendDelay = Math.round(trackAvgPacketSendDelayMovingAverageDelta.get());
        trackMovingAverageDeltas.set('avgPacketSendDelay', trackAvgPacketSendDelayMovingAverageDelta);
    }
    movingAverageDeltas.set(key, trackMovingAverageDeltas);
    return augmentedTrackStats;
}
/**
 * NOTE(mmalavalli): Since A/V sync metrics are not part of the public StatsReport class, we add them
 * only for reporting purposes.
 * @private
 */
function addAVSyncMetricsToRemoteTrackStats(trackStats, trackResponse, movingAverageDeltas) {
    var estimatedPlayoutTimestamp = trackResponse.estimatedPlayoutTimestamp, framesDecoded = trackResponse.framesDecoded, jitterBufferDelay = trackResponse.jitterBufferDelay, jitterBufferEmittedCount = trackResponse.jitterBufferEmittedCount, totalDecodeTime = trackResponse.totalDecodeTime;
    var augmentedTrackStats = Object.assign({}, trackStats);
    var key = trackStats.trackSid + "+" + trackStats.ssrc;
    var trackMovingAverageDeltas = movingAverageDeltas.get(key) || new Map();
    if (typeof estimatedPlayoutTimestamp === 'number') {
        augmentedTrackStats.estimatedPlayoutTimestamp = estimatedPlayoutTimestamp;
    }
    if (typeof framesDecoded === 'number' && typeof totalDecodeTime === 'number') {
        var trackAvgDecodeDelayMovingAverageDelta = trackMovingAverageDeltas.get('avgDecodeDelay')
            || new MovingAverageDelta();
        trackAvgDecodeDelayMovingAverageDelta.putSample(totalDecodeTime * 1000, framesDecoded);
        augmentedTrackStats.avgDecodeDelay = Math.round(trackAvgDecodeDelayMovingAverageDelta.get());
        trackMovingAverageDeltas.set('avgDecodeDelay', trackAvgDecodeDelayMovingAverageDelta);
    }
    if (typeof jitterBufferDelay === 'number' && typeof jitterBufferEmittedCount === 'number') {
        var trackAvgJitterBufferDelayMovingAverageDelta = trackMovingAverageDeltas.get('avgJitterBufferDelay')
            || new MovingAverageDelta();
        trackAvgJitterBufferDelayMovingAverageDelta.putSample(jitterBufferDelay * 1000, jitterBufferEmittedCount);
        augmentedTrackStats.avgJitterBufferDelay = Math.round(trackAvgJitterBufferDelayMovingAverageDelta.get());
        trackMovingAverageDeltas.set('avgJitterBufferDelay', trackAvgJitterBufferDelayMovingAverageDelta);
    }
    movingAverageDeltas.set(key, trackMovingAverageDeltas);
    return augmentedTrackStats;
}
function replaceNullsWithDefaults(activeIceCandidatePair, peerConnectionId) {
    activeIceCandidatePair = Object.assign({
        availableIncomingBitrate: 0,
        availableOutgoingBitrate: 0,
        bytesReceived: 0,
        bytesSent: 0,
        consentRequestsSent: 0,
        currentRoundTripTime: 0,
        lastPacketReceivedTimestamp: 0,
        lastPacketSentTimestamp: 0,
        nominated: false,
        peerConnectionId: peerConnectionId,
        priority: 0,
        readable: false,
        requestsReceived: 0,
        requestsSent: 0,
        responsesReceived: 0,
        responsesSent: 0,
        retransmissionsReceived: 0,
        retransmissionsSent: 0,
        state: 'failed',
        totalRoundTripTime: 0,
        transportId: '',
        writable: false
    }, filterObject(activeIceCandidatePair || {}, null));
    activeIceCandidatePair.localCandidate = Object.assign({
        candidateType: 'host',
        deleted: false,
        ip: '',
        port: 0,
        priority: 0,
        protocol: 'udp',
        url: ''
    }, filterObject(activeIceCandidatePair.localCandidate || {}, null));
    activeIceCandidatePair.remoteCandidate = Object.assign({
        candidateType: 'host',
        ip: '',
        port: 0,
        priority: 0,
        protocol: 'udp',
        url: ''
    }, filterObject(activeIceCandidatePair.remoteCandidate || {}, null));
    return activeIceCandidatePair;
}
module.exports = RoomV2;
//# sourceMappingURL=room.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/trackprioritysignaling.js":
/*!******************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/trackprioritysignaling.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaSignaling = __webpack_require__(/*! ./mediasignaling */ "./node_modules/twilio-video/es5/signaling/v2/mediasignaling.js");
var TrackPrioritySignaling = /** @class */ (function (_super) {
    __extends(TrackPrioritySignaling, _super);
    /**
     * Construct a {@link TrackPrioritySignaling}.
     * @param {Promise<DataTrackReceiver>} getReceiver
     */
    function TrackPrioritySignaling(getReceiver, options) {
        var _this = _super.call(this, getReceiver, 'track_priority', options) || this;
        Object.defineProperties(_this, {
            _enqueuedPriorityUpdates: {
                value: new Map()
            },
        });
        _this.on('ready', function (transport) {
            Array.from(_this._enqueuedPriorityUpdates.keys()).forEach(function (trackSid) {
                transport.publish({
                    type: 'track_priority',
                    track: trackSid,
                    subscribe: _this._enqueuedPriorityUpdates.get(trackSid)
                });
                // NOTE(mpatwardhan)- we do not clear _enqueuedPriorityUpdates intentionally,
                // this cache will is used to re-send the priorities in case of VMS-FailOver.
            });
        });
        return _this;
    }
    /**
     * @param {Track.SID} trackSid
     * @param {'publish'|'subscribe'} publishOrSubscribe
     * @param {Track.Priority} priority
     */
    TrackPrioritySignaling.prototype.sendTrackPriorityUpdate = function (trackSid, publishOrSubscribe, priority) {
        if (publishOrSubscribe !== 'subscribe') {
            throw new Error('only subscribe priorities are supported, found: ' + publishOrSubscribe);
        }
        this._enqueuedPriorityUpdates.set(trackSid, priority);
        if (this._transport) {
            this._transport.publish({
                type: 'track_priority',
                track: trackSid,
                subscribe: priority
            });
        }
    };
    return TrackPrioritySignaling;
}(MediaSignaling));
module.exports = TrackPrioritySignaling;
//# sourceMappingURL=trackprioritysignaling.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/trackswitchoffsignaling.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/trackswitchoffsignaling.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaSignaling = __webpack_require__(/*! ./mediasignaling */ "./node_modules/twilio-video/es5/signaling/v2/mediasignaling.js");
/**
 * @emits TrackSwitchOffSignalinging#updated
 */
var TrackSwitchOffSignaling = /** @class */ (function (_super) {
    __extends(TrackSwitchOffSignaling, _super);
    /**
     * Construct a {@link TrackSwitchOffSignaling}.
     * @param {Promise<DataTrackReceiver>} getReceiver
     */
    function TrackSwitchOffSignaling(getReceiver, options) {
        var _this = _super.call(this, getReceiver, 'track_switch_off', options) || this;
        _this.on('ready', function (transport) {
            transport.on('message', function (message) {
                switch (message.type) {
                    case 'track_switch_off':
                        _this._setTrackSwitchOffUpdates(message.off || [], message.on || []);
                        break;
                    default:
                        break;
                }
            });
        });
        return _this;
    }
    /**
     * @private
     * @param {[Track.SID]} tracksSwitchedOff
     * @param {[Track.SID]} tracksSwitchedOn
     * @returns {void}
     */
    TrackSwitchOffSignaling.prototype._setTrackSwitchOffUpdates = function (tracksSwitchedOff, tracksSwitchedOn) {
        this.emit('updated', tracksSwitchedOff, tracksSwitchedOn);
    };
    return TrackSwitchOffSignaling;
}(MediaSignaling));
/**
 * @event TrackSwitchOffSignaling#updated
 */
module.exports = TrackSwitchOffSignaling;
//# sourceMappingURL=trackswitchoffsignaling.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v2/twilioconnectiontransport.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v2/twilioconnectiontransport.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var StateMachine = __webpack_require__(/*! ../../statemachine */ "./node_modules/twilio-video/es5/statemachine.js");
var TwilioConnection = __webpack_require__(/*! ../../twilioconnection */ "./node_modules/twilio-video/es5/twilioconnection.js");
var DefaultBackoff = __webpack_require__(/*! backoff */ "./node_modules/backoff/index.js");
var reconnectBackoffConfig = __webpack_require__(/*! ../../util/constants */ "./node_modules/twilio-video/es5/util/constants.js").reconnectBackoffConfig;
var Timeout = __webpack_require__(/*! ../../util/timeout */ "./node_modules/twilio-video/es5/util/timeout.js");
var _a = __webpack_require__(/*! ../../util/constants */ "./node_modules/twilio-video/es5/util/constants.js"), SDK_NAME = _a.SDK_NAME, SDK_VERSION = _a.SDK_VERSION, SDP_FORMAT = _a.SDP_FORMAT;
var _b = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js"), createBandwidthProfilePayload = _b.createBandwidthProfilePayload, createMediaSignalingPayload = _b.createMediaSignalingPayload, createSubscribePayload = _b.createSubscribePayload, getUserAgent = _b.getUserAgent, isNonArrayObject = _b.isNonArrayObject;
var _c = __webpack_require__(/*! ../../util/twilio-video-errors */ "./node_modules/twilio-video/es5/util/twilio-video-errors.js"), createTwilioError = _c.createTwilioError, RoomCompletedError = _c.RoomCompletedError, SignalingConnectionError = _c.SignalingConnectionError, SignalingServerBusyError = _c.SignalingServerBusyError;
// eslint-disable-next-line no-warning-comments
// TODO(mmalavalli): Remove ICE version and use RSP_VERSION before Large Rooms GA.
var ICE_VERSION = 1;
var RSP_VERSION = 3;
/*
TwilioConnectionTransport States
----------------

                      +-----------+
                      |           |
                      |  syncing  |---------+
                      |           |         |
                      +-----------+         |
                         ^     |            |
                         |     |            |
                         |     v            v
    +------------+    +-----------+    +--------------+
    |            |    |           |    |              |
    | connecting |--->| connected |--->| disconnected |
    |            |    |           |    |              |
    +------------+    +-----------+    +--------------+
             |                              ^
             |                              |
             |                              |
             +------------------------------+

*/
var states = {
    connecting: [
        'connected',
        'disconnected'
    ],
    connected: [
        'disconnected',
        'syncing'
    ],
    syncing: [
        'connected',
        'disconnected'
    ],
    disconnected: []
};
/**
 * A {@link TwilioConnectionTransport} supports sending and receiving Room Signaling Protocol
 * (RSP) messages. It also supports RSP requests, such as Sync and Disconnect.
 * @extends StateMachine
 * @emits TwilioConnectionTransport#connected
 * @emits TwilioConnectionTransport#message
 */
var TwilioConnectionTransport = /** @class */ (function (_super) {
    __extends(TwilioConnectionTransport, _super);
    /**
     * Construct a {@link TwilioConnectionTransport}.
     * @param {?string} name
     * @param {string} accessToken
     * @param {ParticipantSignaling} localParticipant
     * @param {PeerConnectionManager} peerConnectionManager
     * @param {string} wsServer
     * @param {object} [options]
     */
    function TwilioConnectionTransport(name, accessToken, localParticipant, peerConnectionManager, wsServer, options) {
        var _this = this;
        options = Object.assign({
            Backoff: DefaultBackoff,
            TwilioConnection: TwilioConnection,
            iceServers: null,
            trackPriority: true,
            trackSwitchOff: true,
            renderHints: true,
            userAgent: getUserAgent()
        }, options);
        _this = _super.call(this, 'connecting', states) || this;
        Object.defineProperties(_this, {
            _accessToken: {
                value: accessToken
            },
            _automaticSubscription: {
                value: options.automaticSubscription
            },
            _bandwidthProfile: {
                value: options.bandwidthProfile
            },
            _dominantSpeaker: {
                value: options.dominantSpeaker
            },
            _adaptiveSimulcast: {
                value: options.adaptiveSimulcast
            },
            _eventObserver: {
                value: options.eventObserver,
                writable: false
            },
            _renderHints: {
                value: options.renderHints
            },
            _iceServersStatus: {
                value: Array.isArray(options.iceServers)
                    ? 'overrode'
                    : 'acquire'
            },
            _localParticipant: {
                value: localParticipant
            },
            _name: {
                value: name,
            },
            _networkQuality: {
                value: isNonArrayObject(options.networkQuality) || options.networkQuality
            },
            _options: {
                value: options
            },
            _peerConnectionManager: {
                value: peerConnectionManager
            },
            _sessionTimer: {
                value: null,
                writable: true
            },
            _sessionTimeoutMS: {
                value: 0,
                writable: true
            },
            _reconnectBackoff: {
                value: options.Backoff.exponential(reconnectBackoffConfig)
            },
            _session: {
                value: null,
                writable: true
            },
            _trackPriority: {
                value: options.trackPriority
            },
            _trackSwitchOff: {
                value: options.trackSwitchOff
            },
            _twilioConnection: {
                value: null,
                writable: true
            },
            _updatesReceived: {
                value: []
            },
            _updatesToSend: {
                value: []
            },
            _userAgent: {
                value: options.userAgent
            },
            _wsServer: {
                value: wsServer
            }
        });
        setupTransport(_this);
        return _this;
    }
    /**
     * Create a Connect, Sync or Disconnect RSP message.
     * @private
     * @returns {?object}
     */
    TwilioConnectionTransport.prototype._createConnectOrSyncOrDisconnectMessage = function () {
        if (this.state === 'connected') {
            return null;
        }
        if (this.state === 'disconnected') {
            return {
                session: this._session,
                type: 'disconnect',
                version: RSP_VERSION
            };
        }
        var type = {
            connecting: 'connect',
            syncing: 'sync'
        }[this.state];
        var message = {
            name: this._name,
            participant: this._localParticipant.getState(),
            peer_connections: this._peerConnectionManager.getStates(),
            type: type,
            version: RSP_VERSION
        };
        if (message.type === 'connect') {
            message.ice_servers = this._iceServersStatus;
            message.publisher = {
                name: SDK_NAME,
                sdk_version: SDK_VERSION,
                user_agent: this._userAgent
            };
            if (this._bandwidthProfile) {
                message.bandwidth_profile = createBandwidthProfilePayload(this._bandwidthProfile);
            }
            message.media_signaling = createMediaSignalingPayload(this._dominantSpeaker, this._networkQuality, this._trackPriority, this._trackSwitchOff, this._adaptiveSimulcast, this._renderHints);
            message.subscribe = createSubscribePayload(this._automaticSubscription);
            message.format = SDP_FORMAT;
            message.token = this._accessToken;
        }
        else if (message.type === 'sync') {
            message.session = this._session;
            message.token = this._accessToken;
        }
        else if (message.type === 'update') {
            message.session = this._session;
        }
        return message;
    };
    /**
     * Create an "ice" message.
     * @private
     */
    TwilioConnectionTransport.prototype._createIceMessage = function () {
        return {
            edge: 'roaming',
            token: this._accessToken,
            type: 'ice',
            version: ICE_VERSION
        };
    };
    /**
     * Send a Connect, Sync or Disconnect RSP message.
     * @private
     */
    TwilioConnectionTransport.prototype._sendConnectOrSyncOrDisconnectMessage = function () {
        var message = this._createConnectOrSyncOrDisconnectMessage();
        if (message) {
            this._twilioConnection.sendMessage(message);
        }
    };
    /**
     * Disconnect the {@link TwilioConnectionTransport}. Returns true if calling the method resulted
     * in disconnection.
     * @param {TwilioError} [error]
     * @returns {boolean}
     */
    TwilioConnectionTransport.prototype.disconnect = function (error) {
        if (this.state !== 'disconnected') {
            this.preempt('disconnected', null, [error]);
            this._sendConnectOrSyncOrDisconnectMessage();
            this._twilioConnection.close();
            return true;
        }
        return false;
    };
    /**
     * Publish an RSP Update. Returns true if calling the method resulted in
     * publishing (or eventually publishing) the update.
     * @param {object} update
     * @returns {boolean}
     */
    TwilioConnectionTransport.prototype.publish = function (update) {
        switch (this.state) {
            case 'connected':
                this._twilioConnection.sendMessage(Object.assign({
                    session: this._session,
                    type: 'update',
                    version: RSP_VERSION
                }, update));
                return true;
            case 'connecting':
            case 'syncing':
                this._updatesToSend.push(update);
                return true;
            case 'disconnected':
            default:
                return false;
        }
    };
    /**
     * Publish (or queue) an event to the Insights gateway.
     * @param {string} group - Event group name
     * @param {string} name - Event name
     * @param {string} level - Event level
     * @param {object} payload - Event payload
     * @returns {void}
     */
    TwilioConnectionTransport.prototype.publishEvent = function (group, name, level, payload) {
        this._eventObserver.emit('event', { group: group, name: name, level: level, payload: payload });
    };
    /**
     * Sync the {@link TwilioConnectionTransport}. Returns true if calling the method resulted in
     * syncing.
     * @returns {boolean}
     */
    TwilioConnectionTransport.prototype.sync = function () {
        if (this.state === 'connected') {
            this.preempt('syncing');
            this._sendConnectOrSyncOrDisconnectMessage();
            return true;
        }
        return false;
    };
    /**
     * @private
     * @returns {void}
     */
    TwilioConnectionTransport.prototype._setSession = function (session, sessionTimeout) {
        this._session = session;
        this._sessionTimeoutMS = sessionTimeout * 1000;
    };
    /**
     * Determines if we should attempt reconnect.
     * returns a Promise to wait on before attempting to
     * reconnect. returns null if its not okay to reconnect.
     * @private
     * @returns {Promise<void>}
     */
    TwilioConnectionTransport.prototype._getReconnectTimer = function () {
        var _this = this;
        if (this._sessionTimeoutMS === 0) {
            // this means either we have never connected.
            // or we timed out while trying to reconnect
            // In either case we do not want to reconnect.
            return null;
        }
        // start session timer
        if (!this._sessionTimer) {
            this._sessionTimer = new Timeout(function () {
                // ensure that _clearReconnectTimer wasn't
                // called while we were waiting.
                if (_this._sessionTimer) {
                    // do not allow any more reconnect attempts.
                    _this._sessionTimeoutMS = 0;
                }
            }, this._sessionTimeoutMS);
        }
        // return promise that waits with exponential backoff.
        return new Promise(function (resolve) {
            _this._reconnectBackoff.once('ready', resolve);
            _this._reconnectBackoff.backoff();
        });
    };
    /**
     * clears the session reconnect timer.
     *
     * @private
     * @returns {void}
     */
    TwilioConnectionTransport.prototype._clearReconnectTimer = function () {
        this._reconnectBackoff.reset();
        if (this._sessionTimer) {
            this._sessionTimer.clear();
            this._sessionTimer = null;
        }
    };
    return TwilioConnectionTransport;
}(StateMachine));
/**
 * @event TwilioConnectionTransport#connected
 * @param {object} initialState
 */
/**
 * @event TwilioConnectionTransport#message
 * @param {object} peerConnections
 */
function reducePeerConnections(peerConnections) {
    return Array.from(peerConnections.reduce(function (peerConnectionsById, update) {
        var reduced = peerConnectionsById.get(update.id) || update;
        // First, reduce the top-level `description` property.
        if (!reduced.description && update.description) {
            reduced.description = update.description;
        }
        else if (reduced.description && update.description) {
            if (update.description.revision > reduced.description.revision) {
                reduced.description = update.description;
            }
        }
        // Then, reduce the top-level `ice` property.
        if (!reduced.ice && update.ice) {
            reduced.ice = update.ice;
        }
        else if (reduced.ice && update.ice) {
            if (update.ice.revision > reduced.ice.revision) {
                reduced.ice = update.ice;
            }
        }
        // Finally, update the map.
        peerConnectionsById.set(reduced.id, reduced);
        return peerConnectionsById;
    }, new Map()).values());
}
function reduceUpdates(updates) {
    return updates.reduce(function (reduced, update) {
        // First, reduce the top-level `participant` property.
        if (!reduced.participant && update.participant) {
            reduced.participant = update.participant;
        }
        else if (reduced.participant && update.participant) {
            if (update.participant.revision > reduced.participant.revision) {
                reduced.participant = update.participant;
            }
        }
        // Then, reduce the top-level `peer_connections` property.
        /* eslint camelcase:0 */
        if (!reduced.peer_connections && update.peer_connections) {
            reduced.peer_connections = reducePeerConnections(update.peer_connections);
        }
        else if (reduced.peer_connections && update.peer_connections) {
            reduced.peer_connections = reducePeerConnections(reduced.peer_connections.concat(update.peer_connections));
        }
        return reduced;
    }, {});
}
function setupTransport(transport) {
    function createOrResetTwilioConnection() {
        if (transport.state === 'disconnected') {
            return;
        }
        if (transport._twilioConnection) {
            transport._twilioConnection.removeListener('message', handleMessage);
        }
        var _iceServersStatus = transport._iceServersStatus, _options = transport._options, _wsServer = transport._wsServer, state = transport.state;
        var TwilioConnection = _options.TwilioConnection;
        var twilioConnection = new TwilioConnection(_wsServer, Object.assign({
            helloBody: state === 'connecting' && _iceServersStatus === 'acquire'
                ? transport._createIceMessage()
                : transport._createConnectOrSyncOrDisconnectMessage()
        }, _options));
        twilioConnection.once('close', function (reason) {
            if (reason === TwilioConnection.CloseReason.LOCAL) {
                disconnect();
            }
            else {
                disconnect(new Error(reason));
            }
        });
        twilioConnection.on('message', handleMessage);
        transport._twilioConnection = twilioConnection;
    }
    function disconnect(error) {
        if (transport.state === 'disconnected') {
            return;
        }
        if (!error) {
            transport.disconnect();
            return;
        }
        var reconnectTimer = transport._getReconnectTimer();
        if (!reconnectTimer) {
            var twilioError = error.message === TwilioConnection.CloseReason.BUSY
                ? new SignalingServerBusyError()
                : new SignalingConnectionError();
            transport.disconnect(twilioError);
            return;
        }
        if (transport.state === 'connected') {
            transport.preempt('syncing');
        }
        reconnectTimer.then(createOrResetTwilioConnection);
    }
    function handleMessage(message) {
        if (transport.state === 'disconnected') {
            return;
        }
        if (message.type === 'error') {
            transport.disconnect(createTwilioError(message.code, message.message));
            return;
        }
        switch (transport.state) {
            case 'connected':
                switch (message.type) {
                    case 'connected':
                    case 'synced':
                    case 'update':
                        transport.emit('message', message);
                        return;
                    case 'disconnected':
                        transport.disconnect(message.status === 'completed'
                            ? new RoomCompletedError()
                            : null);
                        return;
                    default:
                        // Do nothing.
                        return;
                }
            case 'connecting':
                switch (message.type) {
                    case 'iced':
                        transport._options.onIced(message.ice_servers).then(function () {
                            transport._sendConnectOrSyncOrDisconnectMessage();
                        });
                        return;
                    case 'connected':
                        transport._setSession(message.session, message.options.session_timeout);
                        transport.emit('connected', message);
                        transport.preempt('connected');
                        return;
                    case 'synced':
                    case 'update':
                        transport._updatesReceived.push(message);
                        return;
                    case 'disconnected':
                        transport.disconnect(message.status === 'completed'
                            ? new RoomCompletedError()
                            : null);
                        return;
                    default:
                        // Do nothing.
                        return;
                }
            case 'syncing':
                switch (message.type) {
                    case 'connected':
                    case 'update':
                        transport._updatesReceived.push(message);
                        return;
                    case 'synced':
                        transport._clearReconnectTimer();
                        transport.emit('message', message);
                        transport.preempt('connected');
                        return;
                    case 'disconnected':
                        transport.disconnect(message.status === 'completed'
                            ? new RoomCompletedError()
                            : null);
                        return;
                    default:
                        // Do nothing.
                        return;
                }
            default:
                // Impossible
                return;
        }
    }
    transport.on('stateChanged', function stateChanged(state) {
        switch (state) {
            case 'connected': {
                var updates = transport._updatesToSend.splice(0);
                if (updates.length) {
                    transport.publish(reduceUpdates(updates));
                }
                transport._updatesReceived.splice(0).forEach(function (update) { return transport.emit('message', update); });
                return;
            }
            case 'disconnected':
                transport._twilioConnection.removeListener('message', handleMessage);
                transport.removeListener('stateChanged', stateChanged);
                return;
            case 'syncing':
                // Do nothing.
                return;
            default:
                // Impossible
                return;
        }
    });
    var _options = transport._options, _iceServersStatus = transport._iceServersStatus;
    var iceServers = _options.iceServers, onIced = _options.onIced;
    if (_iceServersStatus === 'overrode') {
        onIced(iceServers).then(createOrResetTwilioConnection);
    }
    else {
        createOrResetTwilioConnection();
    }
}
module.exports = TwilioConnectionTransport;
//# sourceMappingURL=twilioconnectiontransport.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v3/remoteparticipant.js":
/*!*************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v3/remoteparticipant.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteParticipantV2 = __webpack_require__(/*! ../v2/remoteparticipant */ "./node_modules/twilio-video/es5/signaling/v2/remoteparticipant.js");
var RemoteTrackPublicationV3 = __webpack_require__(/*! ./remotetrackpublication */ "./node_modules/twilio-video/es5/signaling/v3/remotetrackpublication.js");
/**
 * @extends RemoteParticipantV2
 */
var RemoteParticipantV3 = /** @class */ (function (_super) {
    __extends(RemoteParticipantV3, _super);
    /**
     * Construct a {@link RemoteParticipantV2}.
     * @param {object} participantState
     * @param {function(Track.SID): Promise<MediaTrackReceiver>} getPendingTrackReceiver
     * @param {function(Track.SID): boolean} getInitialTrackSwitchOffState
     * @param {function(Track.SID, Track.Priority): boolean} setPriority
     * @param {function(Track.SID, ClientRenderHint): Promise<void>} setRenderHint
     * @param {function(Track.SID): void} clearTrackHint
     * @param {object} [options]
     */
    function RemoteParticipantV3(participantState, getPendingTrackReceiver, getInitialTrackSwitchOffState, setPriority, setRenderHint, clearTrackHint, options) {
        var _this = this;
        options = Object.assign({
            RemoteTrackPublicationSignaling: RemoteTrackPublicationV3,
            getPendingTrackReceiver: getPendingTrackReceiver
        }, options);
        _this = _super.call(this, participantState, getInitialTrackSwitchOffState, setPriority, setRenderHint, clearTrackHint, options) || this;
        return _this;
    }
    /**
     * @private
     */
    RemoteParticipantV3.prototype._getOrCreateTrack = function (trackState) {
        var _a = this, RemoteTrackPublicationV3 = _a._RemoteTrackPublicationSignaling, getPendingTrackReceiver = _a._getPendingTrackReceiver;
        var track = this.tracks.get(trackState.sid);
        if (!track) {
            var _b = this.kind === 'data'
                ? { state: 'ON', switchOffReason: null }
                : this._getInitialTrackSwitchOffState(trackState.sid), state = _b.state, switchOffReason = _b.switchOffReason;
            track = new RemoteTrackPublicationV3(trackState, state === 'OFF', switchOffReason);
            this.addTrack(track);
            getPendingTrackReceiver(track.sid).then(function (trackReceiver) {
                // NOTE(mmalavalli): DataTracks are subscribed to only if corresponding DataTrackReceivers
                // are available, whereas MediaTracks can be subscribed to irrespective of whether corresponding
                // MediaTrackReceivers are available. MediaTracks without MediaTrackReceivers are considered
                // switched off.
                track.setTrackTransceiver(trackReceiver, track.kind !== 'data' || !!trackReceiver);
            });
        }
        return track;
    };
    return RemoteParticipantV3;
}(RemoteParticipantV2));
module.exports = RemoteParticipantV3;
//# sourceMappingURL=remoteparticipant.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v3/remotetrackpublication.js":
/*!******************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v3/remotetrackpublication.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteTrackPublicationSignaling = __webpack_require__(/*! ../remotetrackpublication */ "./node_modules/twilio-video/es5/signaling/remotetrackpublication.js");
/**
 * @extends RemoteTrackPublicationSignaling
 */
var RemoteTrackPublicationV3 = /** @class */ (function (_super) {
    __extends(RemoteTrackPublicationV3, _super);
    /**
     * Construct a {@link RemoteTrackPublicationV3}.
     * @param {RemoteTrackPublicationV3#Representation} track
     * @param {boolean} isSwitchedOff
     * @param {?string} switchOffReason
     */
    function RemoteTrackPublicationV3(track, isSwitchedOff, switchOffReason) {
        if (switchOffReason === void 0) { switchOffReason = null; }
        var _this = this;
        switchOffReason = isSwitchedOff ? switchOffReason : null;
        var enabled = isEnabled(isSwitchedOff, switchOffReason);
        var kind = track.kind, name = track.name, priority = track.priority, sid = track.sid;
        _this = _super.call(this, sid, name, kind, enabled, priority, isSwitchedOff, 3) || this;
        Object.defineProperties(_this, {
            _isSubscribed: {
                value: false,
                writable: true
            },
            _switchOffReason: {
                value: switchOffReason,
                writable: true
            }
        });
        return _this;
    }
    Object.defineProperty(RemoteTrackPublicationV3.prototype, "isSubscribed", {
        /**
         * Whether the {@link RemoteTrackPublicationV3} is subscribed to.
         * @property {boolean}
         */
        get: function () {
            return this._isSubscribed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RemoteTrackPublicationV3.prototype, "switchOffReason", {
        /**
         * The reason for the {@link RemoteTrackPublicationV3} being switched off.
         * @returns {?string}
         */
        get: function () {
            return this._switchOffReason;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Updates track switch on/off state.
     * @param {boolean} isSwitchedOff
     * @param {?string} switchOffReason
     * @returns {this}
     */
    RemoteTrackPublicationV3.prototype.setSwitchedOff = function (isSwitchedOff, switchOffReason) {
        switchOffReason = isSwitchedOff ? switchOffReason : null;
        var shouldEmitUpdated = isSwitchedOff !== this.isSwitchedOff
            || switchOffReason !== this.switchOffReason;
        this._isSwitchedOff = isSwitchedOff;
        this._switchOffReason = switchOffReason;
        if (shouldEmitUpdated) {
            this.emit('updated');
        }
        return this.enable(isEnabled(isSwitchedOff, switchOffReason));
    };
    /**
     * Set the {@link MediaTrackReceiver} on the {@link RemoteTrackPublicationV3}.
     * @override
     * @param {MediaTrackReceiver} trackReceiver
     * @param {boolean} isSubscribed
     * @returns {this}
     */
    RemoteTrackPublicationV3.prototype.setTrackTransceiver = function (trackReceiver, isSubscribed) {
        isSubscribed = !!trackReceiver || isSubscribed;
        var shouldEmitUpdated = trackReceiver !== this.trackTransceiver || isSubscribed !== this.isSubscribed;
        this._trackTransceiver = trackReceiver;
        this._isSubscribed = isSubscribed;
        if (shouldEmitUpdated) {
            this.emit('updated');
        }
        return this;
    };
    /**
     * Compare the {@link RemoteTrackPublicationV3} to a
     * {@link RemoteTrackPublicationV3#Representation} of itself and perform any
     * updates necessary.
     * @param {RemoteTrackPublicationV3#Representation} track
     * @returns {this}
     * @fires TrackSignaling#updated
     */
    RemoteTrackPublicationV3.prototype.update = function (track) {
        this.setPriority(track.priority);
        return this;
    };
    return RemoteTrackPublicationV3;
}(RemoteTrackPublicationSignaling));
/**
 * @private
 * @param {boolean} isSwitchedOff
 * @param {?string} switchOffReason
 * @returns {boolean}
 */
function isEnabled(isSwitchedOff, switchOffReason) {
    return !(isSwitchedOff && switchOffReason === 'DISABLED_BY_PUBLISHER');
}
/**
 * The Room Signaling Protocol (RSP) representation of a {@link RemoteTrackPublicationV3}.
 * @typedef {object} RemoteTrackPublicationV3#Representation
 * @property {Track.Kind} kind
 * @property {string} name
 * @priority {Track.Priority} priority
 * @property {Track.SID} sid
 */
module.exports = RemoteTrackPublicationV3;
//# sourceMappingURL=remotetrackpublication.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v3/room.js":
/*!************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v3/room.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var createTwilioError = __webpack_require__(/*! ../../util/twilio-video-errors */ "./node_modules/twilio-video/es5/util/twilio-video-errors.js").createTwilioError;
var RoomV2 = __webpack_require__(/*! ../v2/room */ "./node_modules/twilio-video/es5/signaling/v2/room.js");
var RemoteParticipantV3 = __webpack_require__(/*! ../v3/remoteparticipant */ "./node_modules/twilio-video/es5/signaling/v3/remoteparticipant.js");
var TrackSubscriptionsSignaling = __webpack_require__(/*! ./tracksubscriptionssignaling */ "./node_modules/twilio-video/es5/signaling/v3/tracksubscriptionssignaling.js");
/**
 * @extends RoomV2
 */
var RoomV3 = /** @class */ (function (_super) {
    __extends(RoomV3, _super);
    function RoomV3(localParticipant, initialState, transport, peerConnectionManager, options) {
        var _this = this;
        options = Object.assign({
            RemoteParticipantSignaling: RemoteParticipantV3,
            TrackSubscriptionsSignaling: TrackSubscriptionsSignaling
        }, options);
        _this = _super.call(this, localParticipant, initialState, transport, peerConnectionManager, options) || this;
        return _this;
    }
    /**
     * @private
     * @override
     */
    RoomV3.prototype._addTrackReceiver = function (trackReceiver) {
        var idType = trackReceiver.kind === 'data' ? 'id' : 'mid';
        var deferred = this._getOrCreateTrackReceiverDeferred(trackReceiver[idType], idType);
        deferred.resolve(trackReceiver);
        return this;
    };
    /**
     * @private
     * @override
     */
    RoomV3.prototype._createRemoteParticipant = function (participantState) {
        var _this = this;
        var RemoteParticipantV3 = this._RemoteParticipantSignaling;
        return new RemoteParticipantV3(participantState, function (trackSid) { return _this._getPendingTrackReceiver(trackSid); }, function (trackSid) { return _this._getInitialTrackSwitchOffState(trackSid); }, function (trackSid, priority) { return _this._trackPrioritySignaling.sendTrackPriorityUpdate(trackSid, 'subscribe', priority); }, function (trackSid, hint) { return _this._renderHintsSignaling.setTrackHint(trackSid, hint); }, function (trackSid) { return _this._renderHintsSignaling.clearTrackHint(trackSid); });
    };
    /**
     * @private
     * @override
     */
    RoomV3.prototype._getInitialTrackSwitchOffState = function (trackSid) {
        var switchOffState = this._pendingSwitchOffStates.get(trackSid)
            || { state: 'OFF', switchOffReason: 'DISABLED_BY_SUBSCRIBER' };
        this._pendingSwitchOffStates.delete(trackSid);
        if (switchOffState.state === 'OFF') {
            this._log.warn("[" + trackSid + "] was initially switched off! ");
        }
        return switchOffState;
    };
    /**
     * @private
     */
    RoomV3.prototype._getPendingTrackReceiver = function (trackSid) {
        var dataChannelLabel = this._pendingDataChannelLabels.get(trackSid);
        var mid = this._pendingTrackMids.get(trackSid);
        var promise = Promise.resolve(null);
        if (dataChannelLabel) {
            this._pendingDataChannelLabels.delete(trackSid);
            promise = this._getTrackReceiver(dataChannelLabel);
        }
        else if (mid) {
            this._pendingTrackMids.delete(trackSid);
            promise = this._getTrackReceiver(mid, 'mid');
        }
        return promise;
    };
    /**
     * @private
     * @override
     */
    RoomV3.prototype._handleSubscriptions = function () {
        /* Do nothing since RSP v3 messages will not contain the "subscribed" property. */
    };
    /**
     * @private
     * @override
     */
    RoomV3.prototype._init = function (localParticipant, peerConnectionManager, transport, options, initialState) {
        var _this = this;
        var getTrackReceiver = function (id) { return _this._getTrackReceiver(id); };
        var log = this._log;
        Object.defineProperties(this, {
            _pendingDataChannelLabels: {
                value: new Map()
            },
            _pendingTrackMids: {
                value: new Map()
            },
            _trackSubscriptionsSignaling: {
                value: new options.TrackSubscriptionsSignaling(getTrackReceiver, { log: log })
            }
        });
        this._initTrackSubscriptionsSignaling();
        _super.prototype._init.call(this, localParticipant, peerConnectionManager, transport, options, initialState);
    };
    /**
     * @private
     */
    RoomV3.prototype._initTrackSubscriptionsSignaling = function () {
        var _this = this;
        this._trackSubscriptionsSignaling.on('updated', function (media, data, errors) {
            var trackSidsToTrackSignalings = _this._getTrackSidsToTrackSignalings();
            var dataTrackSidsToTrackStates = new Map(Object.entries(data));
            var mediaTrackSidsToTrackStates = new Map(Object.entries(media));
            var trackSidsToErrors = new Map(Object.entries(errors));
            mediaTrackSidsToTrackStates.forEach(function (_a, sid) {
                var mid = _a.mid, _b = _a.off_reason, switchOffReason = _b === void 0 ? null : _b, state = _a.state;
                var trackSignaling = trackSidsToTrackSignalings.get(sid);
                var trackState = { state: state, switchOffReason: switchOffReason };
                if (!trackSignaling) {
                    _this._pendingSwitchOffStates.set(sid, trackState);
                    _this._pendingTrackMids.set(sid, mid);
                    return;
                }
                var isSwitchedOff = state === 'OFF';
                if (isSwitchedOff || (trackSignaling.trackTransceiver && trackSignaling.trackTransceiver.mid !== mid)) {
                    // NOTE(mmalavalli): If a RemoteTrackPublicationV3's MID changes, then we need to unsubscribe
                    // from the RemoteTrack before subscribing to it again with the MediaTrackReceiver associated with the new
                    // MID. If a RemoteTrackPublicationV3's RemoteTrack is switched off, then we should still be subscribed
                    // to it, even though it no longer has an MID associated with it.
                    trackSignaling.setTrackTransceiver(null, isSwitchedOff);
                }
                if (!isSwitchedOff) {
                    _this._getTrackReceiver(mid, 'mid').then(function (trackReceiver) {
                        trackSignaling.setTrackTransceiver(trackReceiver, true);
                        // NOTE(mpatwardhan): when track is switched on, send the switchOn message
                        // only after track receiver is set so that application can access (new) mediaStreamTrack
                        trackSignaling.setSwitchedOff(isSwitchedOff, switchOffReason);
                    });
                }
                else {
                    trackSignaling.setSwitchedOff(isSwitchedOff, switchOffReason);
                }
            });
            dataTrackSidsToTrackStates.forEach(function (_a, sid) {
                var label = _a.label;
                var trackSignaling = trackSidsToTrackSignalings.get(sid);
                if (!trackSignaling) {
                    _this._pendingDataChannelLabels.set(sid, label);
                    return;
                }
                _this._getTrackReceiver(label).then(function (trackReceiver) { return trackSignaling.setTrackTransceiver(trackReceiver, true); });
            });
            trackSidsToErrors.forEach(function (_a, sid) {
                var code = _a.code, message = _a.message;
                var trackSignaling = trackSidsToTrackSignalings.get(sid);
                if (trackSignaling) {
                    trackSignaling.subscribeFailed(createTwilioError(code, message));
                }
            });
            trackSidsToTrackSignalings.forEach(function (trackSignaling) {
                var sid = trackSignaling.sid;
                if (!mediaTrackSidsToTrackStates.has(sid) && !dataTrackSidsToTrackStates.has(sid)) {
                    _this._pendingSwitchOffStates.delete(sid);
                    _this._pendingTrackMids.delete(sid);
                    trackSignaling.setTrackTransceiver(null, false);
                }
            });
        });
    };
    /**
     * @private
     * @override
     */
    RoomV3.prototype._updateSubscribed = function (roomState) {
        /* Do nothing since RSP v3 messages will not contain the "subscribed" property. */
    };
    return RoomV3;
}(RoomV2));
module.exports = RoomV3;
//# sourceMappingURL=room.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/signaling/v3/tracksubscriptionssignaling.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/signaling/v3/tracksubscriptionssignaling.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaSignaling = __webpack_require__(/*! ../v2/mediasignaling */ "./node_modules/twilio-video/es5/signaling/v2/mediasignaling.js");
var TrackSubscriptionsSignaling = /** @class */ (function (_super) {
    __extends(TrackSubscriptionsSignaling, _super);
    /**
     * Construct a {@link TrackSubscriptionsSignaling}.
     */
    function TrackSubscriptionsSignaling(getReceiver, options) {
        var _this = _super.call(this, getReceiver, 'track_subscriptions', options) || this;
        Object.defineProperties(_this, {
            _currentRevision: {
                value: null,
                writable: true
            }
        });
        var log = _this._log;
        _this.on('ready', function (transport) {
            log.debug(_this.channel + " transport ready");
            transport.on('message', function (message) {
                switch (message.type) {
                    case _this.channel:
                        _this._handleIncomingMessage(message);
                        break;
                    default:
                        log.warn("Unknown " + _this.channel + " MSP message type:", message.type);
                        break;
                }
            });
            // NOTE(mpatwardhan): we receive ready message every time
            // MSP channel is established. That means at startup and at every VMS-failover.
            if (_this._currentRevision !== null) {
                log.warn('resetting current version after VMS failover', _this._currentRevision);
                _this._currentRevision = null;
            }
        });
        return _this;
    }
    /**
     * @private
     */
    TrackSubscriptionsSignaling.prototype._handleIncomingMessage = function (message) {
        var _a = this, log = _a._log, currentRevision = _a._currentRevision;
        var _b = message.data, data = _b === void 0 ? {} : _b, _c = message.errors, errors = _c === void 0 ? {} : _c, _d = message.media, media = _d === void 0 ? {} : _d, revision = message.revision;
        // TODO(mmalavalli): Remove this once SFU sends revision as integer instead of string.
        var revisionNumber = Number(revision);
        if (currentRevision !== null && currentRevision >= revisionNumber) {
            log.warn("Ignoring incoming " + this.channel + " message as " + currentRevision + " (current revision) >= " + revision + " (incoming revision)");
            log.debug("Ignored incoming " + this.channel + " message:", message);
            return;
        }
        log.debug("Incoming " + this.channel + " MSP message:", message);
        this._currentRevision = revisionNumber;
        this.emit('updated', media, data, errors);
    };
    return TrackSubscriptionsSignaling;
}(MediaSignaling));
module.exports = TrackSubscriptionsSignaling;
//# sourceMappingURL=tracksubscriptionssignaling.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/statemachine.js":
/*!*******************************************************!*\
  !*** ./node_modules/twilio-video/es5/statemachine.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var util = __webpack_require__(/*! ./util */ "./node_modules/twilio-video/es5/util/index.js");
/**
 * {@link StateMachine} represents a state machine. The state machine supports a
 * reentrant locking mechanism to allow asynchronous state transitions to ensure
 * they have not been preempted. Calls to {@link StateMachine#takeLock} are
 * guaranteed to be resolved in FIFO order.
 * @extends EventEmitter
 * @property {boolean} isLocked - whether or not the {@link StateMachine} is
 *   locked performing asynchronous state transition
 * @property {string} state - the current state
 * @emits {@link StateMachine#stateChanged}
 */
var StateMachine = /** @class */ (function (_super) {
    __extends(StateMachine, _super);
    /**
     * Construct a {@link StateMachine}.
     * @param {string} initialState - the intiial state
     * @param {object} states
     */
    function StateMachine(initialState, states) {
        var _this = _super.call(this) || this;
        var lock = null;
        var state = initialState;
        states = transformStates(states);
        Object.defineProperties(_this, {
            _lock: {
                get: function () {
                    return lock;
                },
                set: function (_lock) {
                    lock = _lock;
                }
            },
            _reachableStates: {
                value: reachable(states)
            },
            _state: {
                get: function () {
                    return state;
                },
                set: function (_state) {
                    state = _state;
                }
            },
            _states: {
                value: states
            },
            _whenDeferreds: {
                value: new Set()
            },
            isLocked: {
                enumerable: true,
                get: function () {
                    return lock !== null;
                }
            },
            state: {
                enumerable: true,
                get: function () {
                    return state;
                }
            }
        });
        _this.on('stateChanged', function (state) {
            _this._whenDeferreds.forEach(function (deferred) {
                deferred.when(state, deferred.resolve, deferred.reject);
            });
        });
        return _this;
    }
    /**
     * Returns a promise whose executor function is called on each state change.
     * @param {function(state: string, resolve: function, reject: function): void} when
     * @returns {Promise.<*>}
     * @private
     */
    StateMachine.prototype._whenPromise = function (when) {
        var _this = this;
        if (typeof when !== 'function') {
            return Promise.reject(new Error('when() executor must be a function'));
        }
        var deferred = util.defer();
        deferred.when = when;
        this._whenDeferreds.add(deferred);
        return deferred.promise.then(function (payload) {
            _this._whenDeferreds.delete(deferred);
            return payload;
        }, function (error) {
            _this._whenDeferreds.delete(deferred);
            throw error;
        });
    };
    /**
     * This method takes a lock and passes the {@link StateMachine#Key} to your
     * transition function. You may perform zero or more state transitions in your
     * transition function, but you should check for preemption in each tick. You
     * may also reenter the lock. Once the Promise returned by your transition
     * function resolves or rejects, this method releases the lock it acquired for
     * you.
     * @param {string} name - a name for the lock
     * @param {function(StateMachine#Key): Promise} transitionFunction
     * @returns {Promise}
     */
    // NOTE(mroberts): This method is named after a Haskell function:
    // https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket
    StateMachine.prototype.bracket = function (name, transitionFunction) {
        var key;
        var self = this;
        function releaseLock(error) {
            if (self.hasLock(key)) {
                self.releaseLockCompletely(key);
            }
            if (error) {
                throw error;
            }
        }
        return this.takeLock(name).then(function gotKey(_key) {
            key = _key;
            return transitionFunction(key);
        }).then(function success(result) {
            releaseLock();
            return result;
        }, releaseLock);
    };
    /**
     * Check whether or not a {@link StateMachine#Key} matches the lock.
     * @param {StateMachine#Key} key
     * @returns {boolean}
     */
    StateMachine.prototype.hasLock = function (key) {
        return this._lock === key;
    };
    /**
     * Preempt any pending state transitions and immediately transition to the new
     * state. If a lock name is specified, take the lock and return the
     * {@link StateMachine#Key}.
     * @param {string} newState
     * @param {?string} [name=null] - a name for the lock
     * @param {Array<*>} [payload=[]]
     * @returns {?StateMachine#Key}
     */
    StateMachine.prototype.preempt = function (newState, name, payload) {
        // 1. Check that the new state is valid.
        if (!isValidTransition(this._states, this.state, newState)) {
            throw new Error("Cannot transition from \"" + this.state + "\" to \"" + newState + "\"");
        }
        // 2. Release the old lock, if any.
        var oldLock;
        if (this.isLocked) {
            oldLock = this._lock;
            this._lock = null;
        }
        // 3. Take the lock, if requested.
        var key = null;
        if (name) {
            key = this.takeLockSync(name);
        }
        // 4. If a lock wasn't requested, take a "preemption" lock in order to
        // maintain FIFO order of those taking locks.
        var preemptionKey = key ? null : this.takeLockSync('preemption');
        // 5. Transition.
        this.transition(newState, key || preemptionKey, payload);
        // 6. Preempt anyone blocked on the old lock.
        if (oldLock) {
            oldLock.resolve();
        }
        // 7. Release the "preemption" lock, if we took it.
        if (preemptionKey) {
            this.releaseLock(preemptionKey);
        }
        return key;
    };
    /**
     * Release a lock. This method succeeds only if the {@link StateMachine} is
     * still locked and has not been preempted.
     * @param {StateMachine#Key} key
     * @throws Error
     */
    StateMachine.prototype.releaseLock = function (key) {
        if (!this.isLocked) {
            throw new Error("Could not release the lock for " + key.name + " because the StateMachine is not locked");
        }
        else if (!this.hasLock(key)) {
            throw new Error("Could not release the lock for " + key.name + " because " + this._lock.name + " has the lock");
        }
        if (key.depth === 0) {
            this._lock = null;
            key.resolve();
        }
        else {
            key.depth--;
        }
    };
    /**
     * Release a lock completely, even if it has been reentered. This method
     * succeeds only if the {@link StateMachine} is still locked and has not been
     * preempted.
     * @param {StateMachine#Key} key
     * @throws Error
     */
    StateMachine.prototype.releaseLockCompletely = function (key) {
        if (!this.isLocked) {
            throw new Error("Could not release the lock for " + key.name + " because the StateMachine is not locked");
        }
        else if (!this.hasLock(key)) {
            throw new Error("Could not release the lock for " + key.name + " because " + this._lock.name + " has the lock");
        }
        key.depth = 0;
        this._lock = null;
        key.resolve();
    };
    /**
     * Take a lock, returning a Promise for the {@link StateMachine#Key}. You should
     * take a lock anytime you intend to perform asynchronous transitions. Calls to
     * this method are guaranteed to be resolved in FIFO order. You may reenter
     * a lock by passing its {@link StateMachine#Key}.
     * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an
     * existing {@link StateMachine#Key}
     * @returns {Promise<object>}
     */
    StateMachine.prototype.takeLock = function (nameOrKey) {
        var _this = this;
        // Reentrant lock
        if (typeof nameOrKey === 'object') {
            var key_1 = nameOrKey;
            return new Promise(function (resolve) {
                resolve(_this.takeLockSync(key_1));
            });
        }
        // New lock
        var name = nameOrKey;
        if (this.isLocked) {
            var takeLock = this.takeLock.bind(this, name);
            return this._lock.promise.then(takeLock);
        }
        return Promise.resolve(this.takeLockSync(name));
    };
    /**
     * Take a lock, returning the {@Link StateMachine#Key}. This method throws if
     * the {@link StateMachine} is locked or the wrong {@link StateMachine#Key} is
     * provided. You may reenter a lock by passing its {@link StateMachine#Key}.
     * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an
     * existing {@link StateMachine#Key}
     * @returns {object}
     * @throws Error
     */
    StateMachine.prototype.takeLockSync = function (nameOrKey) {
        var key = typeof nameOrKey === 'string' ? null : nameOrKey;
        var name = key ? key.name : nameOrKey;
        if (key && !this.hasLock(key) || !key && this.isLocked) {
            throw new Error("Could not take the lock for " + name + " because the lock for " + this._lock.name + " was not released");
        }
        // Reentrant lock
        if (key) {
            key.depth++;
            return key;
        }
        // New lock
        var lock = makeLock(name);
        this._lock = lock;
        return lock;
    };
    /**
     * Transition to a new state. If the {@link StateMachine} is locked, you must
     * provide the {@link StateMachine#Key}. An invalid state or the wrong
     * {@link StateMachine#Key} will throw an error.
     * @param {string} newState
     * @param {?StateMachine#Key} [key=null]
     * @param {Array<*>} [payload=[]]
     * @throws {Error}
     */
    StateMachine.prototype.transition = function (newState, key, payload) {
        payload = payload || [];
        // 1. If we're locked, required the key.
        if (this.isLocked) {
            if (!key) {
                throw new Error('You must provide the key in order to ' +
                    'transition');
            }
            else if (!this.hasLock(key)) {
                throw new Error("Could not transition using the key for " + key.name + " because " + this._lock.name + " has the lock");
            }
        }
        else if (key) {
            throw new Error("Key provided for " + key.name + ", but the StateMachine was not locked (possibly due to preemption)");
        }
        // 2. Check that the new state is valid.
        if (!isValidTransition(this._states, this.state, newState)) {
            throw new Error("Cannot transition from \"" + this.state + "\" to \"" + newState + "\"");
        }
        // 3. Update the state and emit an event.
        this._state = newState;
        this.emit.apply(this, __spreadArray([], __read(['stateChanged', newState].concat(payload))));
    };
    /**
     * Attempt to transition to a new state. Unlike {@link StateMachine#transition},
     * this method does not throw.
     * @param {string} newState
     * @param {?StateMachine#Key} [key=null]
     * @param {Array<*>} [payload=[]]
     * @returns {boolean}
     */
    StateMachine.prototype.tryTransition = function (newState, key, payload) {
        try {
            this.transition(newState, key, payload);
        }
        catch (error) {
            return false;
        }
        return true;
    };
    /**
     * Return a Promise that resolves when the {@link StateMachine} transitions to
     * the specified state. If the {@link StateMachine} transitions such that the
     * requested state becomes unreachable, the Promise rejects.
     * @param {string} state
     * @returns {Promise<this>}
     */
    StateMachine.prototype.when = function (state) {
        var _this = this;
        if (this.state === state) {
            return Promise.resolve(this);
        }
        else if (!isValidTransition(this._reachableStates, this.state, state)) {
            return Promise.reject(createUnreachableError(this.state, state));
        }
        return this._whenPromise(function (newState, resolve, reject) {
            if (newState === state) {
                resolve(_this);
            }
            else if (!isValidTransition(_this._reachableStates, newState, state)) {
                reject(createUnreachableError(newState, state));
            }
        });
    };
    return StateMachine;
}(EventEmitter));
/**
 * @event StateMachine#stateChanged
 * @param {string} newState
 */
/**
 * Check if a transition is valid.
 * @private
 * @param {Map<*, Set<*>>} graph
 * @param {*} from
 * @param {*} to
 * @returns {boolean}
 */
function isValidTransition(graph, from, to) {
    return graph.get(from).has(to);
}
/**
 * @typedef {object} StateMachine#Key
 */
function makeLock(name) {
    var lock = util.defer();
    lock.name = name;
    lock.depth = 0;
    return lock;
}
/**
 * Compute the transitive closure of a graph (i.e. what nodes are reachable from
 * where).
 * @private
 * @param {Map<*, Set<*>>} graph
 * @returns {Map<*, Set<*>>}
 */
function reachable(graph) {
    return Array.from(graph.keys()).reduce(function (newGraph, from) { return newGraph.set(from, reachableFrom(graph, from)); }, new Map());
}
/**
 * Compute the Set of node reachable from a particular node in the graph.
 * @private
 * @param {Map<*, Set<*>>} graph
 * @param {*} from
 * @param {Set<*>} [to]
 * @returns {Set<*>}
 */
function reachableFrom(graph, from, to) {
    to = to || new Set();
    graph.get(from).forEach(function (node) {
        if (!to.has(node)) {
            to.add(node);
            reachableFrom(graph, node, to).forEach(to.add, to);
        }
    });
    return to;
}
function transformStates(states) {
    var newStates = new Map();
    for (var key in states) {
        newStates.set(key, new Set(states[key]));
    }
    return newStates;
}
/**
 * Create an "unreachable state" Error.
 * @param {string} here
 * @param {string} there
 * @returns {Error}
 */
function createUnreachableError(here, there) {
    return new Error("\"" + there + "\" cannot be reached from \"" + here + "\"");
}
module.exports = StateMachine;
//# sourceMappingURL=statemachine.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/average.js":
/*!********************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/average.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint no-undefined:0 */

/**
 * @param {Array<number|undefined>} xs
 * @returns {number|undefined}
 */
function average(xs) {
    xs = xs.filter(function (x) { return typeof x === 'number'; });
    return xs.length < 1 ? undefined : xs.reduce(function (y, x) { return x + y; }) / xs.length;
}
module.exports = average;
//# sourceMappingURL=average.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/icereport.js":
/*!**********************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/icereport.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @property {number} [availableSend] - bps (undefined in Firefox)
 * @property {number} recv - bps
 * @property {number} [rtt] - s (undefined in Firefox)
 * @property {number} send - bps
 */
var IceReport = /** @class */ (function () {
    /**
     * Construct an {@link IceReport}.
     * @param {number} send - bps
     * @param {number} recv - bps
     * @param {number} [rtt] - s
     * @param {number} [availableSend] - bps
     */
    function IceReport(send, recv, availableSend, rtt) {
        Object.defineProperties(this, {
            availableSend: {
                enumerable: true,
                value: availableSend
            },
            recv: {
                enumerable: true,
                value: recv
            },
            rtt: {
                enumerable: true,
                value: rtt
            },
            send: {
                enumerable: true,
                value: send
            }
        });
    }
    /**
     * @param {RTCStats} olderStats
     * @param {RTCStats} newerStats
     * @returns {IceReport}
     */
    IceReport.of = function (olderStats, newerStats) {
        var secondsElapsed = (newerStats.timestamp - olderStats.timestamp) / 1000;
        var deltaBytesSent = newerStats.bytesSent - olderStats.bytesSent;
        var deltaBytesReceived = newerStats.bytesReceived - olderStats.bytesReceived;
        var send = secondsElapsed > 0
            ? (deltaBytesSent / secondsElapsed) * 8
            : 0;
        var recv = secondsElapsed > 0
            ? (deltaBytesReceived / secondsElapsed) * 8
            : 0;
        var availableSend = newerStats.availableOutgoingBitrate, rtt = newerStats.currentRoundTripTime;
        return new IceReport(send, recv, availableSend, rtt);
    };
    return IceReport;
}());
module.exports = IceReport;
//# sourceMappingURL=icereport.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/icereportfactory.js":
/*!*****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/icereportfactory.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IceReport = __webpack_require__(/*! ./icereport */ "./node_modules/twilio-video/es5/stats/icereport.js");
/**
 * @property {IceReport} lastReport
 * @property {?RTCStats} lastStats
 */
var IceReportFactory = /** @class */ (function () {
    /**
     * Construct an {@link IceReportFactory}.
     */
    function IceReportFactory() {
        Object.defineProperties(this, {
            lastReport: {
                enumerable: true,
                value: new IceReport(0, 0),
                writable: true
            },
            lastStats: {
                enumerable: true,
                value: null,
                writable: true
            }
        });
    }
    /**
     * Create an {@link IceReport}.
     * @param {RTCStats} newerStats;
     * @returns {IceReport}
     */
    IceReportFactory.prototype.next = function (newerStats) {
        var olderStats = this.lastStats;
        this.lastStats = newerStats;
        if (olderStats) {
            var report = olderStats.id === newerStats.id
                ? IceReport.of(olderStats, newerStats)
                : new IceReport(0, 0);
            this.lastReport = report;
        }
        return this.lastReport;
    };
    return IceReportFactory;
}());
module.exports = IceReportFactory;
//# sourceMappingURL=icereportfactory.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/localaudiotrackstats.js":
/*!*********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/localaudiotrackstats.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalTrackStats = __webpack_require__(/*! ./localtrackstats */ "./node_modules/twilio-video/es5/stats/localtrackstats.js");
/**
 * Statistics for a {@link LocalAudioTrack}.
 * @extends LocalTrackStats
 * @property {?AudioLevel} audioLevel - Input {@link AudioLevel}
 * @property {?number} jitter - Audio jitter in milliseconds
 */
var LocalAudioTrackStats = /** @class */ (function (_super) {
    __extends(LocalAudioTrackStats, _super);
    /**
     * @param {string} trackId - {@link LocalAudioTrack} ID
     * @param {StandardizedTrackStatsReport} statsReport
     * @param {boolean} prepareForInsights
     */
    function LocalAudioTrackStats(trackId, statsReport, prepareForInsights) {
        var _this = _super.call(this, trackId, statsReport, prepareForInsights) || this;
        Object.defineProperties(_this, {
            audioLevel: {
                value: typeof statsReport.audioInputLevel === 'number'
                    ? statsReport.audioInputLevel
                    : null,
                enumerable: true
            },
            jitter: {
                value: typeof statsReport.jitter === 'number'
                    ? statsReport.jitter
                    : null,
                enumerable: true
            }
        });
        return _this;
    }
    return LocalAudioTrackStats;
}(LocalTrackStats));
/**
 * The maximum absolute amplitude of a set of audio samples in the
 * range of 0 to 32767 inclusive.
 * @typedef {number} AudioLevel
 */
module.exports = LocalAudioTrackStats;
//# sourceMappingURL=localaudiotrackstats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/localtrackstats.js":
/*!****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/localtrackstats.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackStats = __webpack_require__(/*! ./trackstats */ "./node_modules/twilio-video/es5/stats/trackstats.js");
/**
 * Statistics for a {@link LocalTrack}.
 * @extends TrackStats
 * @property {?number} bytesSent - Number of bytes sent
 * @property {?number} packetsSent - Number of packets sent
 * @property {?number} roundTripTime - Round trip time in milliseconds
 */
var LocalTrackStats = /** @class */ (function (_super) {
    __extends(LocalTrackStats, _super);
    /**
     * @param {string} trackId - {@link LocalTrack} ID
     * @param {StandardizedTrackStatsReport} statsReport
     * @param {boolean} prepareForInsights
     */
    function LocalTrackStats(trackId, statsReport, prepareForInsights) {
        var _this = _super.call(this, trackId, statsReport) || this;
        Object.defineProperties(_this, {
            bytesSent: {
                value: typeof statsReport.bytesSent === 'number'
                    ? statsReport.bytesSent
                    : prepareForInsights ? 0 : null,
                enumerable: true
            },
            packetsSent: {
                value: typeof statsReport.packetsSent === 'number'
                    ? statsReport.packetsSent
                    : prepareForInsights ? 0 : null,
                enumerable: true
            },
            roundTripTime: {
                value: typeof statsReport.roundTripTime === 'number'
                    ? statsReport.roundTripTime
                    : prepareForInsights ? 0 : null,
                enumerable: true
            }
        });
        return _this;
    }
    return LocalTrackStats;
}(TrackStats));
module.exports = LocalTrackStats;
//# sourceMappingURL=localtrackstats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/localvideotrackstats.js":
/*!*********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/localvideotrackstats.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalTrackStats = __webpack_require__(/*! ./localtrackstats */ "./node_modules/twilio-video/es5/stats/localtrackstats.js");
/**
 * Statistics for a {@link LocalVideoTrack}.
 * @extends LocalTrackStats
 * @property {?VideoTrack#Dimensions} captureDimensions - Video capture resolution
 * @property {?VideoTrack#Dimensions} dimensions - Video encoding resolution
 * @property {?number} captureFrameRate - Video capture frame rate
 * @property {?number} frameRate - Video encoding frame rate
 */
var LocalVideoTrackStats = /** @class */ (function (_super) {
    __extends(LocalVideoTrackStats, _super);
    /**
     * @param {string} trackId - {@link LocalVideoTrack} ID
     * @param {StandardizedTrackStatsReport} statsReport
     * @param {boolean} prepareForInsights
     */
    function LocalVideoTrackStats(trackId, statsReport, prepareForInsights) {
        var _this = _super.call(this, trackId, statsReport, prepareForInsights) || this;
        var captureDimensions = null;
        if (typeof statsReport.frameWidthInput === 'number' &&
            typeof statsReport.frameHeightInput === 'number') {
            captureDimensions = {};
            Object.defineProperties(captureDimensions, {
                width: {
                    value: statsReport.frameWidthInput,
                    enumerable: true
                },
                height: {
                    value: statsReport.frameHeightInput,
                    enumerable: true
                }
            });
        }
        var dimensions = null;
        if (typeof statsReport.frameWidthSent === 'number' &&
            typeof statsReport.frameHeightSent === 'number') {
            dimensions = {};
            Object.defineProperties(dimensions, {
                width: {
                    value: statsReport.frameWidthSent,
                    enumerable: true
                },
                height: {
                    value: statsReport.frameHeightSent,
                    enumerable: true
                }
            });
        }
        Object.defineProperties(_this, {
            captureDimensions: {
                value: captureDimensions,
                enumerable: true
            },
            dimensions: {
                value: dimensions,
                enumerable: true
            },
            captureFrameRate: {
                value: typeof statsReport.frameRateInput === 'number'
                    ? statsReport.frameRateInput
                    : null,
                enumerable: true
            },
            frameRate: {
                value: typeof statsReport.frameRateSent === 'number'
                    ? statsReport.frameRateSent
                    : null,
                enumerable: true
            }
        });
        return _this;
    }
    return LocalVideoTrackStats;
}(LocalTrackStats));
module.exports = LocalVideoTrackStats;
//# sourceMappingURL=localvideotrackstats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/networkqualityaudiostats.js":
/*!*************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/networkqualityaudiostats.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NetworkQualityMediaStats = __webpack_require__(/*! ./networkqualitymediastats */ "./node_modules/twilio-video/es5/stats/networkqualitymediastats.js");
/**
 * {@link NetworkQualityMediaStats} for a {@link Participant}'s audio.
 */
var NetworkQualityAudioStats = /** @class */ (function (_super) {
    __extends(NetworkQualityAudioStats, _super);
    /**
     * Construct a {@link NetworkQualityAudioStats}.
     * @param {MediaLevels} mediaLevels
     */
    function NetworkQualityAudioStats(mediaLevels) {
        return _super.call(this, mediaLevels) || this;
    }
    return NetworkQualityAudioStats;
}(NetworkQualityMediaStats));
module.exports = NetworkQualityAudioStats;
//# sourceMappingURL=networkqualityaudiostats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/networkqualitybandwidthstats.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/networkqualitybandwidthstats.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Bandwidth network quality statistics.
 * @property {?number} actual - the actual bandwidth used, in bits per second
 * @property {?number} available - an estimate of available useable bandwidth, in bits per second
 * @property {?NetworkQualityLevel} level - {@link NetworkQualityLevel} for bandwidth
 */
var NetworkQualityBandwidthStats = /** @class */ (function () {
    /**
     * Construct a {@link NetworkQualityBandwidthStats}.
     * @param {BandwidthStats} bandwidthStats
     */
    function NetworkQualityBandwidthStats(_a) {
        var _b = _a.actual, actual = _b === void 0 ? null : _b, _c = _a.available, available = _c === void 0 ? null : _c, _d = _a.level, level = _d === void 0 ? null : _d;
        Object.defineProperties(this, {
            actual: {
                value: actual,
                enumerable: true
            },
            available: {
                value: available,
                enumerable: true
            },
            level: {
                value: level,
                enumerable: true
            }
        });
    }
    return NetworkQualityBandwidthStats;
}());
module.exports = NetworkQualityBandwidthStats;
//# sourceMappingURL=networkqualitybandwidthstats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/networkqualityfractionloststats.js":
/*!********************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/networkqualityfractionloststats.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Fraction lost network quality statistics.
 * @property {?number} fractionLost - packets lost
 * @property {?NetworkQualityLevel} level - {@link NetworkQualityLevel} for fraction lost
 */
var NetworkQualityFractionLostStats = /** @class */ (function () {
    /**
     * Construct a {@link NetworkQualityFractionLostStats}.
     * @param {FractionLostStats} fractionLostStats
     */
    function NetworkQualityFractionLostStats(_a) {
        var _b = _a.fractionLost, fractionLost = _b === void 0 ? null : _b, _c = _a.level, level = _c === void 0 ? null : _c;
        Object.defineProperties(this, {
            fractionLost: {
                value: fractionLost,
                enumerable: true
            },
            level: {
                value: level,
                enumerable: true
            }
        });
    }
    return NetworkQualityFractionLostStats;
}());
module.exports = NetworkQualityFractionLostStats;
//# sourceMappingURL=networkqualityfractionloststats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/networkqualitylatencystats.js":
/*!***************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/networkqualitylatencystats.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Latency network quality statistics.
 * @property {?number} jitter - media jitter in seconds
 * @property {?number} rtt - round trip time in seconds
 * @property {?NetworkQualityLevel} level - {@link NetworkQualityLevel} for latency
 */
var NetworkQualityLatencyStats = /** @class */ (function () {
    /**
     * Construct a {@link NetworkQualityLatencyStats}.
     * @param {LatencyStats} latencyStats
     */
    function NetworkQualityLatencyStats(_a) {
        var _b = _a.jitter, jitter = _b === void 0 ? null : _b, _c = _a.rtt, rtt = _c === void 0 ? null : _c, _d = _a.level, level = _d === void 0 ? null : _d;
        Object.defineProperties(this, {
            jitter: {
                value: jitter,
                enumerable: true
            },
            rtt: {
                value: rtt,
                enumerable: true
            },
            level: {
                value: level,
                enumerable: true
            }
        });
    }
    return NetworkQualityLatencyStats;
}());
module.exports = NetworkQualityLatencyStats;
//# sourceMappingURL=networkqualitylatencystats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/networkqualitymediastats.js":
/*!*************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/networkqualitymediastats.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NetworkQualitySendStats = __webpack_require__(/*! ./networkqualitysendstats */ "./node_modules/twilio-video/es5/stats/networkqualitysendstats.js");
var NetworkQualityRecvStats = __webpack_require__(/*! ./networkqualityrecvstats */ "./node_modules/twilio-video/es5/stats/networkqualityrecvstats.js");
/**
 * Network quality statistics shared between a {@link Participant}'s audio or video.
 * @property {NetworkQualityLevel} send - {@link NetworkQualityLevel} of the
 *  {@link Participant}'s published audio or video
 * @property {number} recv - {@link NetworkQualityLevel} of the
 *  {@link Participant}'s subscribed audio or video
 * @property {?NetworkQualitySendOrRecvStats} sendStats - {@link NetworkQualitySendOrRecvStats}
 *   based on which {@link NetworkQualityMediaStats}<code style="padding:0 0">#send</code>
 *   is calculated
 * @property {?NetworkQualitySendOrRecvStats} recvStats - {@link NetworkQualitySendOrRecvStats}
 *   based on which {@link NetworkQualityMediaStats}<code style="padding:0 0">#recv</code>
 *   is calculated
 */
var NetworkQualityMediaStats = /** @class */ (function () {
    /**
     * Construct a {@link NetworkQualityMediaStats}.
     * @param {MediaLevels} mediaLevels
     */
    function NetworkQualityMediaStats(_a) {
        var send = _a.send, recv = _a.recv, _b = _a.sendStats, sendStats = _b === void 0 ? null : _b, _c = _a.recvStats, recvStats = _c === void 0 ? null : _c;
        Object.defineProperties(this, {
            send: {
                value: send,
                enumerable: true
            },
            recv: {
                value: recv,
                enumerable: true
            },
            sendStats: {
                value: sendStats ? new NetworkQualitySendStats(sendStats) : null,
                enumerable: true
            },
            recvStats: {
                value: recvStats ? new NetworkQualityRecvStats(recvStats) : null,
                enumerable: true
            }
        });
    }
    return NetworkQualityMediaStats;
}());
module.exports = NetworkQualityMediaStats;
//# sourceMappingURL=networkqualitymediastats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/networkqualityrecvstats.js":
/*!************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/networkqualityrecvstats.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NetworkQualitySendOrRecvStats = __webpack_require__(/*! ./networkqualitysendorrecvstats */ "./node_modules/twilio-video/es5/stats/networkqualitysendorrecvstats.js");
/**
 * {@link NetworkQualitySendOrRecvStats} based on which a {@link Participant}'s
 * {@link NetworkQualityMediaStats}<code style="padding:0 0">#recv</code> is calculated.
 */
var NetworkQualityRecvStats = /** @class */ (function (_super) {
    __extends(NetworkQualityRecvStats, _super);
    /**
     * Construct a {@link NetworkQualityRecvStats}.
     * @param {SendOrRecvStats} sendOrRecvStats
     */
    function NetworkQualityRecvStats(sendOrRecvStats) {
        return _super.call(this, sendOrRecvStats) || this;
    }
    return NetworkQualityRecvStats;
}(NetworkQualitySendOrRecvStats));
module.exports = NetworkQualityRecvStats;
//# sourceMappingURL=networkqualityrecvstats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/networkqualitysendorrecvstats.js":
/*!******************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/networkqualitysendorrecvstats.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NetworkQualityBandwidthStats = __webpack_require__(/*! ./networkqualitybandwidthstats */ "./node_modules/twilio-video/es5/stats/networkqualitybandwidthstats.js");
var NetworkQualityFractionLostStats = __webpack_require__(/*! ./networkqualityfractionloststats */ "./node_modules/twilio-video/es5/stats/networkqualityfractionloststats.js");
var NetworkQualityLatencyStats = __webpack_require__(/*! ./networkqualitylatencystats */ "./node_modules/twilio-video/es5/stats/networkqualitylatencystats.js");
/**
 * Network quality statistics shared between {@link NetworkQualitySendStats} and
 * {@link NetworkQualityRecvStats} based on which a {@link Participant}'s
 * {@link NetworkQualityMediaStats}<code style="padding:0 0">#send</code> or
 * {@link NetworkQualityMediaStats}<code style="padding:0 0">#recv</code> is calculated.
 * @property {?NetworkQualityBandwidthStats} bandwidth - bandwidth statistics
 * @property {?NetworkQualityLatencyStats} latency - latency statistics
 * @property {?NetworkQualityFractionLostStats} fractionLost - fraction lost statistics
 */
var NetworkQualitySendOrRecvStats = /** @class */ (function () {
    /**
     * Construct a {@link NetworkQualitySendOrRecvStats}.
     * @param {SendOrRecvStats} sendOrRecvStats
     */
    function NetworkQualitySendOrRecvStats(_a) {
        var _b = _a.bandwidth, bandwidth = _b === void 0 ? null : _b, _c = _a.fractionLost, fractionLost = _c === void 0 ? null : _c, _d = _a.latency, latency = _d === void 0 ? null : _d;
        Object.defineProperties(this, {
            bandwidth: {
                value: bandwidth ? new NetworkQualityBandwidthStats(bandwidth) : null,
                enumerable: true
            },
            fractionLost: {
                value: fractionLost ? new NetworkQualityFractionLostStats(fractionLost) : null,
                enumerable: true
            },
            latency: {
                value: latency ? new NetworkQualityLatencyStats(latency) : null,
                enumerable: true
            }
        });
    }
    return NetworkQualitySendOrRecvStats;
}());
module.exports = NetworkQualitySendOrRecvStats;
//# sourceMappingURL=networkqualitysendorrecvstats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/networkqualitysendstats.js":
/*!************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/networkqualitysendstats.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NetworkQualitySendOrRecvStats = __webpack_require__(/*! ./networkqualitysendorrecvstats */ "./node_modules/twilio-video/es5/stats/networkqualitysendorrecvstats.js");
/**
 * {@link NetworkQualitySendOrRecvStats} based on which a {@link Participant}'s
 * {@link NetworkQualityMediaStats}<code style="padding:0 0">#send</code> is calculated.
 */
var NetworkQualitySendStats = /** @class */ (function (_super) {
    __extends(NetworkQualitySendStats, _super);
    /**
     * Construct a {@link NetworkQualitySendStats}.
     * @param {SendOrRecvStats} sendOrRecvStats
     */
    function NetworkQualitySendStats(sendOrRecvStats) {
        return _super.call(this, sendOrRecvStats) || this;
    }
    return NetworkQualitySendStats;
}(NetworkQualitySendOrRecvStats));
module.exports = NetworkQualitySendStats;
//# sourceMappingURL=networkqualitysendstats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/networkqualitystats.js":
/*!********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/networkqualitystats.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NetworkQualityAudioStats = __webpack_require__(/*! ./networkqualityaudiostats */ "./node_modules/twilio-video/es5/stats/networkqualityaudiostats.js");
var NetworkQualityVideoStats = __webpack_require__(/*! ./networkqualityvideostats */ "./node_modules/twilio-video/es5/stats/networkqualityvideostats.js");
/**
 * Network quality statistics for a {@link Participant}.
 * @property {NetworkQualityLevel} level - {@link NetworkQualityLevel} of the {@link Participant}
 * @property {?NetworkQualityAudioStats} audio - {@link NetworkQualityMediaStats}
 *   for audio; <code>null</code> if {@link NetworkQualityVerbosity} is {@link NetworkQualityVerbosity}<code style="padding:0 0">#minimal</code>
 *   or below
 * @property {?NetworkQualityVideoStats} video - {@link NetworkQualityMediaStats}
 *   for video; <code>null</code> if {@link NetworkQualityVerbosity} is {@link NetworkQualityVerbosity}<code style="padding:0 0">#minimal</code>
 *   or below
 */
var NetworkQualityStats = /** @class */ (function () {
    /**
     * Construct a {@link NetworkQualityStats}.
     * @param {NetworkQualityLevels} networkQualityLevels
     */
    function NetworkQualityStats(_a) {
        var level = _a.level, audio = _a.audio, video = _a.video;
        Object.defineProperties(this, {
            level: {
                value: level,
                enumerable: true
            },
            audio: {
                value: audio ? new NetworkQualityAudioStats(audio) : null,
                enumerable: true
            },
            video: {
                value: video ? new NetworkQualityVideoStats(video) : null,
                enumerable: true
            }
        });
    }
    return NetworkQualityStats;
}());
module.exports = NetworkQualityStats;
//# sourceMappingURL=networkqualitystats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/networkqualityvideostats.js":
/*!*************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/networkqualityvideostats.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NetworkQualityMediaStats = __webpack_require__(/*! ./networkqualitymediastats */ "./node_modules/twilio-video/es5/stats/networkqualitymediastats.js");
/**
 * {@link NetworkQualityMediaStats} for a {@link Participant}'s video.
 */
var NetworkQualityVideoStats = /** @class */ (function (_super) {
    __extends(NetworkQualityVideoStats, _super);
    /**
     * Construct a {@link NetworkQualityVideoStats}.
     * @param {MediaLevels} mediaLevels
     */
    function NetworkQualityVideoStats(mediaLevels) {
        return _super.call(this, mediaLevels) || this;
    }
    return NetworkQualityVideoStats;
}(NetworkQualityMediaStats));
module.exports = NetworkQualityVideoStats;
//# sourceMappingURL=networkqualityvideostats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/peerconnectionreport.js":
/*!*********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/peerconnectionreport.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ReceiverReport = __webpack_require__(/*! ./receiverreport */ "./node_modules/twilio-video/es5/stats/receiverreport.js");
var SenderReport = __webpack_require__(/*! ./senderreport */ "./node_modules/twilio-video/es5/stats/senderreport.js");
/**
 * @interface SenderAndReceiverReports
 * @property {Array<SenderReport>} send
 * @property {Array<ReceiverReport>} recv
 */
/**
 * @interface SenderAndReceiverSummary
 * @property {SenderSummary} send
 * @property {ReceiverSummary} recv
 */
/**
 * @interface PeerConnectionSummary
 * @property {IceReport} ice
 * @property {SenderSummary} send
 * @property {ReceiverSummary} recv
 * @property {SenderAndReceiverSummary} audio
 * @property {SenderAndReceiverSummary} video
 */
/**
 * @property {IceReport} ice
 * @roperty {SenderAndReceiverReports} audio
 * @roperty {SenderAndReceiverReports} video
 */
var PeerConnectionReport = /** @class */ (function () {
    /**
     * Construct a {@link PeerConnectionReport}.
     * @param {IceReport} ice
     * @param {SenderAndReceiverReports} audio
     * @param {SenderAndReceiverReports} video
     */
    function PeerConnectionReport(ice, audio, video) {
        Object.defineProperties(this, {
            ice: {
                enumerable: true,
                value: ice
            },
            audio: {
                enumerable: true,
                value: audio
            },
            video: {
                enumerable: true,
                value: video
            }
        });
    }
    /**
     * Summarize the {@link PeerConnectionReport} by summarizing its
     * {@link SenderReport}s and {@link ReceiverReport}s.
     * @returns {PeerConnectionSummary}
     */
    PeerConnectionReport.prototype.summarize = function () {
        var senderReports = this.audio.send.concat(this.video.send);
        var send = SenderReport.summarize(senderReports);
        var receiverReports = this.audio.recv.concat(this.video.recv);
        var recv = ReceiverReport.summarize(receiverReports);
        return {
            ice: this.ice,
            send: send,
            recv: recv,
            audio: {
                send: SenderReport.summarize(this.audio.send),
                recv: ReceiverReport.summarize(this.audio.recv)
            },
            video: {
                send: SenderReport.summarize(this.video.send),
                recv: ReceiverReport.summarize(this.video.recv)
            }
        };
    };
    return PeerConnectionReport;
}());
module.exports = PeerConnectionReport;
//# sourceMappingURL=peerconnectionreport.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/peerconnectionreportfactory.js":
/*!****************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/peerconnectionreportfactory.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var guessBrowser = __webpack_require__(/*! ../webrtc/util */ "./node_modules/twilio-video/es5/webrtc/util/index.js").guessBrowser;
var IceReportFactory = __webpack_require__(/*! ./icereportfactory */ "./node_modules/twilio-video/es5/stats/icereportfactory.js");
var PeerConnectionReport = __webpack_require__(/*! ./peerconnectionreport */ "./node_modules/twilio-video/es5/stats/peerconnectionreport.js");
var ReceiverReportFactory = __webpack_require__(/*! ./receiverreportfactory */ "./node_modules/twilio-video/es5/stats/receiverreportfactory.js");
var SenderReportFactory = __webpack_require__(/*! ./senderreportfactory */ "./node_modules/twilio-video/es5/stats/senderreportfactory.js");
/**
 * @typedef {string} TrackId
 */
/**
 * @typedef {string} StatsId
 */
/**
 * @interface SenderReportFactoriesByMediaType
 * @property {Map<StatsId, SenderReportFactory>} audio
 * @property {Map<StatsId, SenderReportFactory>} video
 */
/**
 * @interface ReceiverReportFactoriesByMediaType
 * @property {Map<StatsId, ReceiverReportFactory>} audio
 * @property {Map<StatsId, ReceiverReportFactory>} video
 */
/**
 * @interface SenderAndReceiverReportFactories
 * @property {Map<StatsId, SenderReportFactories>} send
 * @property {Map<StatsId, ReceiverReportFactories>} recv
 */
/**
 * @interface {StatsIdsByMediaType}
 * @property {Set<StatsId>} audio
 * @property {Set<StatsId>} video
 */
/**
 * @property {RTCPeerConnection} pc
 * @property {IceReportFactory} iceReportFactory
 * @property {SenderAndReceiverReportFactories} audio
 * @property {SenderAndReceiverReportFactories} video
 * @property {?PeerConnectionReport} lastReport
 */
var PeerConnectionReportFactory = /** @class */ (function () {
    /**
     * Construct a {@link PeerConnectionReportFactory}.
     * @param {RTCPeerConnection} pc
     */
    function PeerConnectionReportFactory(pc) {
        Object.defineProperties(this, {
            pc: {
                enumerable: true,
                value: pc
            },
            ice: {
                enumerable: true,
                value: new IceReportFactory()
            },
            audio: {
                enumerable: true,
                value: {
                    send: new Map(),
                    recv: new Map()
                }
            },
            video: {
                enumerable: true,
                value: {
                    send: new Map(),
                    recv: new Map()
                }
            },
            lastReport: {
                enumerable: true,
                value: null,
                writable: true
            }
        });
    }
    /**
     * Create a {@link PeerConnectionReport}.
     * @returns {Promise<PeerConnectionReport>}
     */
    PeerConnectionReportFactory.prototype.next = function () {
        var _this = this;
        var updatePromise = guessBrowser() === 'firefox'
            ? updateFirefox(this)
            : updateChrome(this);
        return updatePromise.then(function () {
            var audioSenderReportFactories = __spreadArray([], __read(_this.audio.send.values()));
            var videoSenderReportFactories = __spreadArray([], __read(_this.video.send.values()));
            var audioReceiverReportFactories = __spreadArray([], __read(_this.audio.recv.values()));
            var videoReceiverReportFactories = __spreadArray([], __read(_this.video.recv.values()));
            var report = new PeerConnectionReport(_this.ice.lastReport, {
                send: audioSenderReportFactories.map(function (factory) { return factory.lastReport; }).filter(function (report) { return report; }),
                recv: audioReceiverReportFactories.map(function (factory) { return factory.lastReport; }).filter(function (report) { return report; })
            }, {
                send: videoSenderReportFactories.map(function (factory) { return factory.lastReport; }).filter(function (report) { return report; }),
                recv: videoReceiverReportFactories.map(function (factory) { return factory.lastReport; }).filter(function (report) { return report; })
            });
            _this.lastReport = report;
            return report;
        });
    };
    return PeerConnectionReportFactory;
}());
/**
 * Construct a Map from MediaStreamTrack Ids to RTCStatsReports.
 * @param {Array<RTCRtpSender>|Array<RTCRtpReceiver>} sendersOrReceivers - each
 *   RTCRtpSender should have a non-null track
 * @returns {Promise<Map<TrackId, RTCStats>>}
 */
function getSenderOrReceiverReports(sendersOrReceivers) {
    return Promise.all(sendersOrReceivers.map(function (senderOrReceiver) {
        var trackId = senderOrReceiver.track.id;
        return senderOrReceiver.getStats().then(function (report) {
            var e_1, _a;
            try {
                // NOTE(mroberts): We have to rewrite Ids due to this bug:
                //
                //   https://bugzilla.mozilla.org/show_bug.cgi?id=1463430
                //
                for (var _b = __values(report.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var stats = _c.value;
                    if (stats.type === 'inbound-rtp') {
                        stats.id = trackId + "-" + stats.id;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return [trackId, report];
        });
    })).then(function (pairs) { return new Map(pairs); });
}
/**
 * @param {SenderReportFactory.constructor} SenderReportFactory
 * @param {SenderReportFactoriesByMediaType} sendersByMediaType
 * @param {RTCStatsReport} report
 * @param {RTCStats} stats
 * @param {TrackId} [trackId]
 * @returns {?SenderReportFactory}
 */ /**
* @param {ReceiverReportFactory.constructor} ReceiverReportFactory
* @param {ReceiverReportFactoriesByMediaType} receiversByMediaType
* @param {RTCStatsReport} report
* @param {RTCStats} stats
* @param {TrackId} [trackId]
* @returns {?ReceiverReportFactory}
*/
function getOrCreateSenderOrReceiverReportFactory(SenderOrReceiverReportFactory, sendersOrReceiversByMediaType, report, stats, trackId) {
    var sendersOrReceivers = sendersOrReceiversByMediaType[stats.mediaType];
    if (!trackId) {
        var trackStats = report.get(stats.trackId);
        if (trackStats) {
            trackId = trackStats.trackIdentifier;
        }
    }
    if (sendersOrReceivers && trackId) {
        if (sendersOrReceivers.has(stats.id)) {
            return sendersOrReceivers.get(stats.id);
        }
        var senderOrReceiverFactory = new SenderOrReceiverReportFactory(trackId, stats);
        sendersOrReceivers.set(stats.id, senderOrReceiverFactory);
    }
    return null;
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @returns {SenderReportFactoriesByMediaType}
 */
function getSenderReportFactoriesByMediaType(factory) {
    return { audio: factory.audio.send, video: factory.video.send };
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @returns {ReceiverReportFactoriesByMediaType}
 */
function getReceiverReportFactoriesByMediaType(factory) {
    return { audio: factory.audio.recv, video: factory.video.recv };
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @param {RTCStatsReport} report
 * @param {RTCStats} stats
 * @param {TrackId} [trackId]
 * @returns {?SenderReportFactory}
 */
function getOrCreateSenderReportFactory(factory, report, stats, trackId) {
    return getOrCreateSenderOrReceiverReportFactory(SenderReportFactory, getSenderReportFactoriesByMediaType(factory), report, stats, trackId);
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @param {RTCStatsReport} report
 * @param {RTCStats} stats
 * @param {TrackId} [trackId]
 * @returns {?ReceiverReportFactory}
 */
function getOrCreateReceiverReportFactory(factory, report, stats, trackId) {
    return getOrCreateSenderOrReceiverReportFactory(ReceiverReportFactory, getReceiverReportFactoriesByMediaType(factory), report, stats, trackId);
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @retuns {StatsIdsByMediaType}
 */
function getSenderReportFactoryIdsByMediaType(factory) {
    return {
        audio: new Set(factory.audio.send.keys()),
        video: new Set(factory.video.send.keys())
    };
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @retuns {StatsIdsByMediaType}
 */
function getReceiverReportFactoryIdsByMediaType(factory) {
    return {
        audio: new Set(factory.audio.recv.keys()),
        video: new Set(factory.video.recv.keys())
    };
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @param {RTCStatsReport} report
 * @param {StatsIdsByMediaType} senderReportFactoryIdsToDeleteByMediaType
 * @param {TrackId} [trackId]
 * @returns {void}
 */
function updateSenderReports(factory, report, senderReportFactoryIdsToDeleteByMediaType, trackId) {
    var e_2, _a;
    try {
        for (var _b = __values(report.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var stats = _c.value;
            if (stats.type === 'outbound-rtp' && !stats.isRemote) {
                if (guessBrowser() !== 'firefox' && !stats.trackId) {
                    continue;
                }
                var senderReportFactoryIdsToDelete = senderReportFactoryIdsToDeleteByMediaType[stats.mediaType];
                if (senderReportFactoryIdsToDelete) {
                    senderReportFactoryIdsToDelete.delete(stats.id);
                }
                var senderReportFactory = getOrCreateSenderReportFactory(factory, report, stats, trackId);
                if (senderReportFactory) {
                    var remoteInboundStats = report.get(stats.remoteId);
                    senderReportFactory.next(trackId || senderReportFactory.trackId, stats, remoteInboundStats);
                }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @param {RTCStatsReport} report
 * @param {StatsIdsByMediaType} receiverReportFactoryIdsToDeleteByMediaType
 * @param {TrackId} [trackId]
 * @returns {void}
 */
function updateReceiverReports(factory, report, receiverReportFactoryIdsToDeleteByMediaType, trackId) {
    var e_3, _a;
    try {
        for (var _b = __values(report.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var stats = _c.value;
            if (stats.type === 'inbound-rtp' && !stats.isRemote) {
                var receiverReportFactoryIdsToDelete = receiverReportFactoryIdsToDeleteByMediaType[stats.mediaType];
                if (receiverReportFactoryIdsToDelete) {
                    receiverReportFactoryIdsToDelete.delete(stats.id);
                }
                var receiverReportFactory = getOrCreateReceiverReportFactory(factory, report, stats, trackId);
                if (receiverReportFactory) {
                    receiverReportFactory.next(trackId || receiverReportFactory.trackId, stats);
                }
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_3) throw e_3.error; }
    }
}
/**
 * @param {SenderReportFactoriesByMediaType|ReceiverReportFactoriesByMediaType} senderOrReceiverReportFactoriesByMediaType
 * @param {StatsIdsByMediaType} senderOrReceiverReportFactoryIdsByMediaType
 * @returns {void}
 */
function deleteSenderOrReceiverReportFactories(senderOrReceiverReportFactoriesByMediaType, senderOrReceiverReportFactoryIdsByMediaType) {
    var _loop_1 = function (mediaType) {
        var senderOrReceiverReportFactories = senderOrReceiverReportFactoriesByMediaType[mediaType];
        var senderOrReceiverReportFactoryIds = senderOrReceiverReportFactoryIdsByMediaType[mediaType];
        senderOrReceiverReportFactoryIds.forEach(function (senderOrReceiverReportFactoryId) { return senderOrReceiverReportFactories.delete(senderOrReceiverReportFactoryId); });
    };
    for (var mediaType in senderOrReceiverReportFactoryIdsByMediaType) {
        _loop_1(mediaType);
    }
}
/**
 * @param {IceReportFactory} ice
 * @param {RTCStatsReport} report
 * @returns {void}
 */
function updateIceReport(ice, report) {
    var e_4, _a, e_5, _b;
    var selectedCandidatePair;
    try {
        for (var _c = __values(report.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var stats = _d.value;
            if (stats.type === 'transport') {
                selectedCandidatePair = report.get(stats.selectedCandidatePairId);
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_4) throw e_4.error; }
    }
    if (selectedCandidatePair) {
        ice.next(selectedCandidatePair);
        return;
    }
    try {
        for (var _e = __values(report.values()), _f = _e.next(); !_f.done; _f = _e.next()) {
            var stats = _f.value;
            if (stats.type === 'candidate-pair'
                && stats.nominated
                && ('selected' in stats ? stats.selected : true)) {
                ice.next(stats);
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_5) throw e_5.error; }
    }
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @returns {Promise<PeerConnectionReport>}
 */
function updateFirefox(factory) {
    var senders = factory.pc.getTransceivers()
        .filter(function (transceiver) { return transceiver.currentDirection && transceiver.currentDirection.match(/send/) && transceiver.sender.track; })
        .map(function (transceiver) { return transceiver.sender; });
    var receivers = factory.pc.getTransceivers()
        .filter(function (transceiver) { return transceiver.currentDirection && transceiver.currentDirection.match(/recv/); })
        .map(function (transceiver) { return transceiver.receiver; });
    return Promise.all([
        getSenderOrReceiverReports(senders),
        getSenderOrReceiverReports(receivers),
        factory.pc.getStats()
    ]).then(function (_a) {
        var _b = __read(_a, 3), senderReports = _b[0], receiverReports = _b[1], pcReport = _b[2];
        var senderReportFactoriesByMediaType = getSenderReportFactoriesByMediaType(factory);
        var senderReportFactoryIdsToDeleteByMediaType = getSenderReportFactoryIdsByMediaType(factory);
        senderReports.forEach(function (report, trackId) { return updateSenderReports(factory, report, senderReportFactoryIdsToDeleteByMediaType, trackId); });
        deleteSenderOrReceiverReportFactories(senderReportFactoriesByMediaType, senderReportFactoryIdsToDeleteByMediaType);
        var receiverReportFactoriesByMediaType = getReceiverReportFactoriesByMediaType(factory);
        var receiverReportFactoryIdsToDeleteByMediaType = getReceiverReportFactoryIdsByMediaType(factory);
        receiverReports.forEach(function (report, trackId) { return updateReceiverReports(factory, report, receiverReportFactoryIdsToDeleteByMediaType, trackId); });
        deleteSenderOrReceiverReportFactories(receiverReportFactoriesByMediaType, receiverReportFactoryIdsToDeleteByMediaType);
        updateIceReport(factory.ice, pcReport);
    });
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @returns {Promise<PeerConnectionReport>}
 */
function updateChrome(factory) {
    return factory.pc.getStats().then(function (report) {
        var senderReportFactoriesByMediaType = getSenderReportFactoriesByMediaType(factory);
        var senderReportFactoryIdsToDeleteByMediaType = getSenderReportFactoryIdsByMediaType(factory);
        updateSenderReports(factory, report, senderReportFactoryIdsToDeleteByMediaType);
        deleteSenderOrReceiverReportFactories(senderReportFactoriesByMediaType, senderReportFactoryIdsToDeleteByMediaType);
        var receiverReportFactoriesByMediaType = getReceiverReportFactoriesByMediaType(factory);
        var receiverReportFactoryIdsToDeleteByMediaType = getReceiverReportFactoryIdsByMediaType(factory);
        updateReceiverReports(factory, report, receiverReportFactoryIdsToDeleteByMediaType);
        deleteSenderOrReceiverReportFactories(receiverReportFactoriesByMediaType, receiverReportFactoryIdsToDeleteByMediaType);
        updateIceReport(factory.ice, report);
    });
}
module.exports = PeerConnectionReportFactory;
//# sourceMappingURL=peerconnectionreportfactory.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/receiverreport.js":
/*!***************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/receiverreport.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var average = __webpack_require__(/*! ./average */ "./node_modules/twilio-video/es5/stats/average.js");
var SenderOrReceiverReport = __webpack_require__(/*! ./senderorreceiverreport */ "./node_modules/twilio-video/es5/stats/senderorreceiverreport.js");
var sum = __webpack_require__(/*! ./sum */ "./node_modules/twilio-video/es5/stats/sum.js");
/**
 * @interface ReceiverSummary
 * @property {number} bitrate
 * @property {number} fractionLost - 0–1
 * @property {number} [jitter] - s (undefined for video tracks in Chrome)
 */
/**
 * @extends SenderOrReceiverReport
 * @property {number} deltaPacketsLost
 * @property {number} deltaPacketsReceived
 * @property {number} [fractionLost] - 0–1 (undefined in Firefox)
 * @property {number} [jitter] - s (undefined for video tracks in Chrome)
 * @property {number} phonyPacketsLost - 0–1
 */
var ReceiverReport = /** @class */ (function (_super) {
    __extends(ReceiverReport, _super);
    /**
     * @param {StatsId} id
     * @param {TrackId} trackId
     * @param {number} bitrate - bps
     * @param {number} deltaPacketsLost
     * @param {number} deltaPacketsReceived
     * @param {number} [fractionLost] - 0–1 (undefined in Firefox)
     * @param {number} [jitter] - s (undefined for video tracks in Chrome)
     */
    function ReceiverReport(id, trackId, bitrate, deltaPacketsLost, deltaPacketsReceived, fractionLost, jitter) {
        var _this = _super.call(this, id, trackId, bitrate) || this;
        var phonyFractionLost = deltaPacketsReceived > 0
            ? deltaPacketsLost / deltaPacketsReceived
            : 0;
        Object.defineProperties(_this, {
            deltaPacketsLost: {
                enumerable: true,
                value: deltaPacketsLost
            },
            deltaPacketsReceived: {
                enumerable: true,
                value: deltaPacketsReceived
            },
            fractionLost: {
                enumerable: true,
                value: fractionLost
            },
            jitter: {
                enumerable: true,
                value: jitter
            },
            phonyFractionLost: {
                enumerable: true,
                value: phonyFractionLost
            }
        });
        return _this;
    }
    /**
     * Create a {@link ReceiverReport}.
     * @param {string} trackId
     * @param {RTCStats} olderStats
     * @param {RTCStats} newerStats
     * @returns {ReceiverReport}
     */
    ReceiverReport.of = function (trackId, olderStats, newerStats) {
        if (olderStats.id !== newerStats.id) {
            throw new Error('RTCStats IDs must match');
        }
        var secondsElapsed = (newerStats.timestamp - olderStats.timestamp) / 1000;
        var deltaBytesReceived = newerStats.bytesReceived - olderStats.bytesReceived;
        var bitrate = secondsElapsed > 0
            ? (deltaBytesReceived / secondsElapsed) * 8
            : 0;
        var deltaPacketsLost = Math.max(newerStats.packetsLost - olderStats.packetsLost, 0);
        var deltaPacketsReceived = newerStats.packetsReceived - olderStats.packetsReceived;
        var fractionLost = newerStats.fractionLost, jitter = newerStats.jitter;
        return new ReceiverReport(olderStats.id, trackId, bitrate, deltaPacketsLost, deltaPacketsReceived, fractionLost, jitter);
    };
    /**
     * Summarize {@link ReceiverReport}s by summing and averaging their values.
     * @param {Array<ReceiverReport>} reports
     * @returns {ReceiverSummary}
     */
    ReceiverReport.summarize = function (reports) {
        var summaries = reports.map(function (report) { return report.summarize(); });
        var bitrate = sum(summaries.map(function (summary) { return summary.bitrate; }));
        var fractionLost = average(summaries.map(function (summary) { return summary.fractionLost; }));
        var jitter = average(summaries.map(function (summary) { return summary.jitter; }));
        return {
            bitrate: bitrate,
            fractionLost: fractionLost,
            jitter: jitter
        };
    };
    /**
     * Summarize the {@link ReceiveReport}.
     * @returns {ReceiverSummary}
     */
    ReceiverReport.prototype.summarize = function () {
        return {
            bitrate: this.bitrate,
            fractionLost: typeof this.fractionLost === 'number' ? this.fractionLost : this.phonyFractionLost,
            jitter: this.jitter
        };
    };
    return ReceiverReport;
}(SenderOrReceiverReport));
module.exports = ReceiverReport;
//# sourceMappingURL=receiverreport.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/receiverreportfactory.js":
/*!**********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/receiverreportfactory.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ReceiverReport = __webpack_require__(/*! ./receiverreport */ "./node_modules/twilio-video/es5/stats/receiverreport.js");
var SenderOrReceiverReportFactory = __webpack_require__(/*! ./senderorreceiverreportfactory */ "./node_modules/twilio-video/es5/stats/senderorreceiverreportfactory.js");
/**
 * @extends SenderOrReceiverReportFactory
 * @param {?ReceiverReport} lastReport
 */
var ReceiverReportFactory = /** @class */ (function (_super) {
    __extends(ReceiverReportFactory, _super);
    /**
     * Construct a {@link ReceiverReportFactory}.
     * @param {TrackId} trackId
     * @param {RTCStats} initialStats
     */
    function ReceiverReportFactory(trackId, initialStats) {
        var _this = _super.call(this, initialStats.id, trackId, initialStats) || this;
        Object.defineProperties(_this, {
            lastReport: {
                enumerable: true,
                value: null,
                writable: true
            }
        });
        return _this;
    }
    /**
     * Create a {@link ReceiverReport}.
     * @param {TrackId} trackId
     * @param {RTCStats} newerStats
     * @returns {ReceiverReport}
     */
    ReceiverReportFactory.prototype.next = function (trackId, newerStats) {
        var olderStats = this.lastStats;
        this.lastStats = newerStats;
        this.trackId = trackId;
        var report = ReceiverReport.of(trackId, olderStats, newerStats);
        this.lastReport = report;
        return report;
    };
    return ReceiverReportFactory;
}(SenderOrReceiverReportFactory));
module.exports = ReceiverReportFactory;
//# sourceMappingURL=receiverreportfactory.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/remoteaudiotrackstats.js":
/*!**********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/remoteaudiotrackstats.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteTrackStats = __webpack_require__(/*! ./remotetrackstats */ "./node_modules/twilio-video/es5/stats/remotetrackstats.js");
/**
 * Statistics for an {@link AudioTrack}.
 * @extends RemoteTrackStats
 * @property {?AudioLevel} audioLevel - Output {@link AudioLevel}
 * @property {?number} jitter - Audio jitter in milliseconds
 */
var RemoteAudioTrackStats = /** @class */ (function (_super) {
    __extends(RemoteAudioTrackStats, _super);
    /**
     * @param {string} trackId - {@link AudioTrack} ID
     * @param {StandardizedTrackStatsReport} statsReport
     */
    function RemoteAudioTrackStats(trackId, statsReport) {
        var _this = _super.call(this, trackId, statsReport) || this;
        Object.defineProperties(_this, {
            audioLevel: {
                value: typeof statsReport.audioOutputLevel === 'number'
                    ? statsReport.audioOutputLevel
                    : null,
                enumerable: true
            },
            jitter: {
                value: typeof statsReport.jitter === 'number'
                    ? statsReport.jitter
                    : null,
                enumerable: true
            }
        });
        return _this;
    }
    return RemoteAudioTrackStats;
}(RemoteTrackStats));
module.exports = RemoteAudioTrackStats;
//# sourceMappingURL=remoteaudiotrackstats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/remotetrackstats.js":
/*!*****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/remotetrackstats.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackStats = __webpack_require__(/*! ./trackstats */ "./node_modules/twilio-video/es5/stats/trackstats.js");
/**
 * Statistics for a remote {@link Track}.
 * @extends TrackStats
 * @property {?number} bytesReceived - Number of bytes received
 * @property {?number} packetsReceived - Number of packets received
 */
var RemoteTrackStats = /** @class */ (function (_super) {
    __extends(RemoteTrackStats, _super);
    /*
     * @param {string} trackId - {@link Track} ID
     * @param {StandardizedTrackStatsReport} statsReport
     */
    function RemoteTrackStats(trackId, statsReport) {
        var _this = _super.call(this, trackId, statsReport) || this;
        Object.defineProperties(_this, {
            bytesReceived: {
                value: typeof statsReport.bytesReceived === 'number'
                    ? statsReport.bytesReceived
                    : null,
                enumerable: true
            },
            packetsReceived: {
                value: typeof statsReport.packetsReceived === 'number'
                    ? statsReport.packetsReceived
                    : null,
                enumerable: true
            }
        });
        return _this;
    }
    return RemoteTrackStats;
}(TrackStats));
module.exports = RemoteTrackStats;
//# sourceMappingURL=remotetrackstats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/remotevideotrackstats.js":
/*!**********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/remotevideotrackstats.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteTrackStats = __webpack_require__(/*! ./remotetrackstats */ "./node_modules/twilio-video/es5/stats/remotetrackstats.js");
/**
 * Statistics for a {@link VideoTrack}.
 * @extends RemoteTrackStats
 * @property {?VideoTrack#Dimensions} dimensions - Received video resolution
 * @property {?number} frameRate - Received video frame rate
 */
var RemoteVideoTrackStats = /** @class */ (function (_super) {
    __extends(RemoteVideoTrackStats, _super);
    /**
     * @param {string} trackId - {@link VideoTrack} ID
     * @param {StandardizedTrackStatsReport} statsReport
     */
    function RemoteVideoTrackStats(trackId, statsReport) {
        var _this = _super.call(this, trackId, statsReport) || this;
        var dimensions = null;
        if (typeof statsReport.frameWidthReceived === 'number' &&
            typeof statsReport.frameHeightReceived === 'number') {
            dimensions = {};
            Object.defineProperties(dimensions, {
                width: {
                    value: statsReport.frameWidthReceived,
                    enumerable: true
                },
                height: {
                    value: statsReport.frameHeightReceived,
                    enumerable: true
                }
            });
        }
        Object.defineProperties(_this, {
            dimensions: {
                value: dimensions,
                enumerable: true
            },
            frameRate: {
                value: typeof statsReport.frameRateReceived === 'number'
                    ? statsReport.frameRateReceived
                    : null,
                enumerable: true
            }
        });
        return _this;
    }
    return RemoteVideoTrackStats;
}(RemoteTrackStats));
module.exports = RemoteVideoTrackStats;
//# sourceMappingURL=remotevideotrackstats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/senderorreceiverreport.js":
/*!***********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/senderorreceiverreport.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @property {StatsId} id
 * @property {TrackId} trackId
 * @property {number} bitrate - bps
 */
var SenderOrReceiverReport = /** @class */ (function () {
    /**
     * Construct a {@link SenderOrReceiverReport}.
     * @param {StatsId} id
     * @param {TrackId} trackId
     * @param {number} bitrate - bps
     */
    function SenderOrReceiverReport(id, trackId, bitrate) {
        Object.defineProperties(this, {
            id: {
                enumerable: true,
                value: id
            },
            trackId: {
                enumerable: true,
                value: trackId
            },
            bitrate: {
                enumerable: true,
                value: bitrate
            }
        });
    }
    return SenderOrReceiverReport;
}());
module.exports = SenderOrReceiverReport;
//# sourceMappingURL=senderorreceiverreport.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/senderorreceiverreportfactory.js":
/*!******************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/senderorreceiverreportfactory.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @property {StatsId} id
 * @property {TrackId} trackId
 * @property {RTCStats} lastStats
 */
var SenderOrReceiverReportFactory = /** @class */ (function () {
    /**
     * @param {StatsId} id
     * @param {TrackId} trackId
     * @param {RTCStats} initialStats
     */
    function SenderOrReceiverReportFactory(id, trackId, initialStats) {
        Object.defineProperties(this, {
            id: {
                enumerable: true,
                value: id,
                writable: true
            },
            trackId: {
                enumerable: true,
                value: trackId,
                writable: true
            },
            lastStats: {
                enumerable: true,
                value: initialStats,
                writable: true
            }
        });
    }
    return SenderOrReceiverReportFactory;
}());
module.exports = SenderOrReceiverReportFactory;
//# sourceMappingURL=senderorreceiverreportfactory.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/senderreport.js":
/*!*************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/senderreport.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint no-undefined:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var average = __webpack_require__(/*! ./average */ "./node_modules/twilio-video/es5/stats/average.js");
var SenderOrReceiverReport = __webpack_require__(/*! ./senderorreceiverreport */ "./node_modules/twilio-video/es5/stats/senderorreceiverreport.js");
var sum = __webpack_require__(/*! ./sum */ "./node_modules/twilio-video/es5/stats/sum.js");
/**
 * @interface SenderSummary
 * @property {number} bitrate
 * @property {number} [rtt] - s (undefined in Chrome)
 */
/**
 * @extends SenderOrReceiverReport
 * @property {number} [rtt] - s (undefined in Chrome)
 */
var SenderReport = /** @class */ (function (_super) {
    __extends(SenderReport, _super);
    /**
     * Construct a {@link SenderReport}.
     * @param {StatsId} id
     * @param {TrackId} trackId
     * @param {number} bitrate - bps
     * @param {number} [rtt] - s
     */
    function SenderReport(id, trackId, bitrate, rtt) {
        var _this = _super.call(this, id, trackId, bitrate) || this;
        Object.defineProperties(_this, {
            rtt: {
                enumerable: true,
                value: rtt
            }
        });
        return _this;
    }
    /**
     * Create a {@link SenderReport}.
     * @param {string} trackId
     * @param {RTCStats} olderStats
     * @param {RTCStats} newerStats
     * @param {RTCRemoteInboundRtpStreamStats} [newerRemoteStats]
     * @returns {SenderReport}
     */
    SenderReport.of = function (trackId, olderStats, newerStats, newerRemoteStats) {
        if (olderStats.id !== newerStats.id) {
            throw new Error('RTCStats IDs must match');
        }
        var secondsElapsed = (newerStats.timestamp - olderStats.timestamp) / 1000;
        var deltaBytesSent = newerStats.bytesSent - olderStats.bytesSent;
        var bitrate = secondsElapsed > 0
            ? (deltaBytesSent / secondsElapsed) * 8
            : 0;
        var rtt = newerRemoteStats && typeof newerRemoteStats.roundTripTime === 'number'
            ? newerRemoteStats.roundTripTime / 1000
            : undefined;
        return new SenderReport(olderStats.id, trackId, bitrate, rtt);
    };
    /**
     * Summarize {@link SenderReport}s by summing and averaging their values.
     * @param {Array<SenderReport>} reports
     * @returns {SenderSummary}
     */
    SenderReport.summarize = function (reports) {
        var bitrate = sum(reports.map(function (report) { return report.bitrate; }));
        var rtt = average(reports.map(function (report) { return report.rtt; }));
        return {
            bitrate: bitrate,
            rtt: rtt
        };
    };
    return SenderReport;
}(SenderOrReceiverReport));
module.exports = SenderReport;
//# sourceMappingURL=senderreport.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/senderreportfactory.js":
/*!********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/senderreportfactory.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var SenderOrReceiverReportFactory = __webpack_require__(/*! ./senderorreceiverreportfactory */ "./node_modules/twilio-video/es5/stats/senderorreceiverreportfactory.js");
var SenderReport = __webpack_require__(/*! ./senderreport */ "./node_modules/twilio-video/es5/stats/senderreport.js");
/**
 * @extends {SenderOrReceiverReportFactory}
 * @property {?SenderReport} lastReport
 */
var SenderReportFactory = /** @class */ (function (_super) {
    __extends(SenderReportFactory, _super);
    /**
     * Construct a {@link SenderReportFactory}.
     * @param {TrackId} trackId
     * @param {RTCStats} initialStats
     */
    function SenderReportFactory(trackId, initialStats) {
        var _this = _super.call(this, initialStats.id, trackId, initialStats) || this;
        Object.defineProperties(_this, {
            lastReport: {
                enumerable: true,
                value: null,
                writable: true
            }
        });
        return _this;
    }
    /**
     * @param {TrackId} trackId
     * @param {RTCStats} newerStats
     * @param {RTCRemoteInboundRtpStreamStats} [newerRemoteStats]
     * @returns {SenderReport}
     */
    SenderReportFactory.prototype.next = function (trackId, newerStats, newerRemoteStats) {
        var olderStats = this.lastStats;
        this.lastStats = newerStats;
        this.trackId = trackId;
        var report = SenderReport.of(trackId, olderStats, newerStats, newerRemoteStats);
        this.lastReport = report;
        return report;
    };
    return SenderReportFactory;
}(SenderOrReceiverReportFactory));
module.exports = SenderReportFactory;
//# sourceMappingURL=senderreportfactory.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/statsreport.js":
/*!************************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/statsreport.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LocalAudioTrackStats = __webpack_require__(/*! ./localaudiotrackstats */ "./node_modules/twilio-video/es5/stats/localaudiotrackstats.js");
var LocalVideoTrackStats = __webpack_require__(/*! ./localvideotrackstats */ "./node_modules/twilio-video/es5/stats/localvideotrackstats.js");
var RemoteAudioTrackStats = __webpack_require__(/*! ./remoteaudiotrackstats */ "./node_modules/twilio-video/es5/stats/remoteaudiotrackstats.js");
var RemoteVideoTrackStats = __webpack_require__(/*! ./remotevideotrackstats */ "./node_modules/twilio-video/es5/stats/remotevideotrackstats.js");
/**
 * Statistics report for an RTCPeerConnection.
 * @property {string} peerConnectionId - ID of the RTCPeerConnection
 * @property {Array<LocalAudioTrackStats>} localAudioTrackStats - List of {@link LocalAudioTrackStats}
 * @property {Array<LocalVideoTrackStats>} localVideoTrackStats - List of {@link LocalVideoTrackStats}
 * @property {Array<RemoteAudioTrackStats>} remoteAudioTrackStats - List of {@link RemoteAudioTrackStats}
 * @property {Array<RemoteVideoTrackStats>} remoteVideoTrackStats - List of {@link RemoteVideoTrackStats}
 */
var StatsReport = /** @class */ (function () {
    /**
     * @param {string} peerConnectionId - RTCPeerConnection ID
     * @param {StandardizedStatsResponse} statsResponse
     * @param {boolean} prepareForInsights - if report is being prepared to send to insights.
     */
    function StatsReport(peerConnectionId, statsResponse, prepareForInsights) {
        if (typeof peerConnectionId !== 'string') {
            throw new Error('RTCPeerConnection id must be a string');
        }
        Object.defineProperties(this, {
            peerConnectionId: {
                value: peerConnectionId,
                enumerable: true
            },
            localAudioTrackStats: {
                value: statsResponse.localAudioTrackStats.map(function (report) { return new LocalAudioTrackStats(report.trackId, report, prepareForInsights); }),
                enumerable: true
            },
            localVideoTrackStats: {
                value: statsResponse.localVideoTrackStats.map(function (report) { return new LocalVideoTrackStats(report.trackId, report, prepareForInsights); }),
                enumerable: true
            },
            remoteAudioTrackStats: {
                value: statsResponse.remoteAudioTrackStats.map(function (report) { return new RemoteAudioTrackStats(report.trackId, report); }),
                enumerable: true
            },
            remoteVideoTrackStats: {
                value: statsResponse.remoteVideoTrackStats.map(function (report) { return new RemoteVideoTrackStats(report.trackId, report); }),
                enumerable: true
            }
        });
    }
    return StatsReport;
}());
module.exports = StatsReport;
//# sourceMappingURL=statsreport.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/sum.js":
/*!****************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/sum.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @param {Array<number|undefined>} xs
 * @returns {number}
 */
function sum(xs) {
    return xs.reduce(function (y, x) { return typeof x === 'number' ? x + y : y; }, 0);
}
module.exports = sum;
//# sourceMappingURL=sum.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/stats/trackstats.js":
/*!***********************************************************!*\
  !*** ./node_modules/twilio-video/es5/stats/trackstats.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Statistics for a {@link Track}.
 * @property {Track.ID} trackId - The {@link Track} ID
 * @property {Track.SID} trackSid - The {@link Track}'s SID when published in
 *  in a {@link Room}
 * @property {number} timestamp - A Unix timestamp in milliseconds indicating
 *   when the {@link TrackStats} were gathered
 * @property {string} ssrc - The {@link Track}'s SSRC when transmitted over the
 *   RTCPeerConnection
 * @property {?number} packetsLost - The number of packets lost
 * @property {?string} codec - The name of the codec used to encode the
 *   {@link Track}'s media
 */
var TrackStats = /** @class */ (function () {
    /**
     * @param {string} trackId - {@link Track} ID
     * @param {StandardizedTrackStatsReport} statsReport
     */
    function TrackStats(trackId, statsReport) {
        if (typeof trackId !== 'string') {
            throw new Error('Track id must be a string');
        }
        Object.defineProperties(this, {
            trackId: {
                value: trackId,
                enumerable: true
            },
            trackSid: {
                value: statsReport.trackSid,
                enumerable: true
            },
            timestamp: {
                value: statsReport.timestamp,
                enumerable: true
            },
            ssrc: {
                value: statsReport.ssrc,
                enumerable: true
            },
            packetsLost: {
                value: typeof statsReport.packetsLost === 'number'
                    ? statsReport.packetsLost
                    : null,
                enumerable: true
            },
            codec: {
                value: typeof statsReport.codecName === 'string'
                    ? statsReport.codecName
                    : null,
                enumerable: true
            }
        });
    }
    return TrackStats;
}());
module.exports = TrackStats;
//# sourceMappingURL=trackstats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/transceiver.js":
/*!******************************************************!*\
  !*** ./node_modules/twilio-video/es5/transceiver.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
/**
 * A {@link TrackTransceiver} represents either one or more local RTCRtpSenders
 * or RTCDataChannels, or a single RTCRtpReceiver or remote RTCDataChannel.
 * @extends EventEmitter
 * @property {Track.ID} id
 * @property {Track.kind} kind
 */
var TrackTransceiver = /** @class */ (function (_super) {
    __extends(TrackTransceiver, _super);
    /**
     * Construct a {@link TrackTransceiver}.
     * @param {Track.ID} id
     * @param {Track.kind} kind
     */
    function TrackTransceiver(id, kind) {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            id: {
                enumerable: true,
                value: id
            },
            kind: {
                enumerable: true,
                value: kind
            }
        });
        return _this;
    }
    /**
     * Stop the {@link TrackTransceiver}.
     * #emits TrackTransceiver#stopped
     * @returns {void}
     */
    TrackTransceiver.prototype.stop = function () {
        this.emit('stopped');
    };
    return TrackTransceiver;
}(EventEmitter));
/**
 * The {@link TrackTransceiver} was stopped.
 * @event TrackTransceiver#stopped
 */
module.exports = TrackTransceiver;
//# sourceMappingURL=transceiver.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/twilioconnection.js":
/*!***********************************************************!*\
  !*** ./node_modules/twilio-video/es5/twilioconnection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var StateMachine = __webpack_require__(/*! ./statemachine */ "./node_modules/twilio-video/es5/statemachine.js");
var _a = __webpack_require__(/*! ./util */ "./node_modules/twilio-video/es5/util/index.js"), buildLogLevels = _a.buildLogLevels, makeUUID = _a.makeUUID;
var Log = __webpack_require__(/*! ./util/log */ "./node_modules/twilio-video/es5/util/log.js");
var NetworkMonitor = __webpack_require__(/*! ./util/networkmonitor */ "./node_modules/twilio-video/es5/util/networkmonitor.js");
var Timeout = __webpack_require__(/*! ./util/timeout */ "./node_modules/twilio-video/es5/util/timeout.js");
var nInstances = 0;
/*
  TwilioConnection states
  -----------------------

       ------------------------------------------
       |                                        |
       |                                        v
  +---------+       +--------------+       +----------+
  |  early  | ----> |  connecting  | ----> |  closed  |
  +---------+       +--------------+       +----------+
    ^                     | ^ |                 ^ ^
    | --------------------- | |                 | |
    | | --------------------- |                 | |
    | | | --------------------|------------------ |
    | v | |                   v                   |
  +----------+           +--------+               |
  | waiting  | --------> |  open  | ---------------
  +----------+           +--------+
 */
var states = {
    closed: [],
    connecting: ['closed', 'open', 'waiting'],
    early: ['closed', 'connecting'],
    open: ['closed'],
    waiting: ['closed', 'connecting', 'early', 'open']
};
var events = {
    closed: 'close',
    open: 'open',
    waiting: 'waiting'
};
var TCMP_VERSION = 2;
var DEFAULT_MAX_CONSECUTIVE_MISSED_HEARTBEATS = 3;
var DEFAULT_MAX_CONSECUTIVE_FAILED_HELLOS = 3;
var DEFAULT_MAX_REQUESTED_HEARTBEAT_TIMEOUT = 5000;
var DEFAULT_OPEN_TIMEOUT = 15000;
var DEFAULT_WELCOME_TIMEOUT = 5000;
var OUTGOING_HEARTBEAT_OFFSET = 200;
var WS_CLOSE_NORMAL = 1000;
var WS_CLOSE_WELCOME_TIMEOUT = 3000;
var WS_CLOSE_HEARTBEATS_MISSED = 3001;
var WS_CLOSE_HELLO_FAILED = 3002;
var WS_CLOSE_SEND_FAILED = 3003;
var WS_CLOSE_NETWORK_CHANGED = 3004;
var WS_CLOSE_BUSY_WAIT = 3005;
var WS_CLOSE_SERVER_BUSY = 3006;
var WS_CLOSE_OPEN_TIMEOUT = 3007;
var toplevel = global.window || global;
var WebSocket = toplevel.WebSocket ? toplevel.WebSocket : __webpack_require__(/*! ws */ "./node_modules/twilio-video/src/ws.js");
var CloseReason = {
    BUSY: 'busy',
    FAILED: 'failed',
    LOCAL: 'local',
    REMOTE: 'remote',
    TIMEOUT: 'timeout'
};
var wsCloseCodesToCloseReasons = new Map([
    [WS_CLOSE_WELCOME_TIMEOUT, CloseReason.TIMEOUT],
    [WS_CLOSE_HEARTBEATS_MISSED, CloseReason.TIMEOUT],
    [WS_CLOSE_HELLO_FAILED, CloseReason.FAILED],
    [WS_CLOSE_SEND_FAILED, CloseReason.FAILED],
    [WS_CLOSE_NETWORK_CHANGED, CloseReason.TIMEOUT],
    [WS_CLOSE_SERVER_BUSY, CloseReason.BUSY],
    [WS_CLOSE_OPEN_TIMEOUT, CloseReason.TIMEOUT]
]);
/**
 * A {@link TwilioConnection} represents a WebSocket connection
 * to a Twilio Connections Messaging Protocol (TCMP) server.
 * @fires TwilioConnection#close
 * @fires TwilioConnection#error
 * @fires TwilioConnection#message
 * @fires TwilioConnection#open
 * @fires TwilioConnection#waiting
 */
var TwilioConnection = /** @class */ (function (_super) {
    __extends(TwilioConnection, _super);
    /**
     * Construct a {@link TwilioConnection}.
     * @param {string} serverUrl - TCMP server url
     * @param {TwilioConnectionOptions} options - {@link TwilioConnection} options
     */
    function TwilioConnection(serverUrl, options) {
        var _this = _super.call(this, 'early', states) || this;
        options = Object.assign({
            helloBody: null,
            maxConsecutiveFailedHellos: DEFAULT_MAX_CONSECUTIVE_FAILED_HELLOS,
            maxConsecutiveMissedHeartbeats: DEFAULT_MAX_CONSECUTIVE_MISSED_HEARTBEATS,
            requestedHeartbeatTimeout: DEFAULT_MAX_REQUESTED_HEARTBEAT_TIMEOUT,
            openTimeout: DEFAULT_OPEN_TIMEOUT,
            welcomeTimeout: DEFAULT_WELCOME_TIMEOUT,
            Log: Log,
            WebSocket: WebSocket
        }, options);
        var logLevels = buildLogLevels(options.logLevel);
        var log = new options.Log('default', _this, logLevels, options.loggerName);
        var networkMonitor = options.networkMonitor ? new NetworkMonitor(function () {
            var type = networkMonitor.type;
            var reason = "Network changed" + (type ? " to " + type : '');
            log.debug(reason);
            _this._close({ code: WS_CLOSE_NETWORK_CHANGED, reason: reason });
        }) : null;
        Object.defineProperties(_this, {
            _busyWaitTimeout: {
                value: null,
                writable: true
            },
            _consecutiveHeartbeatsMissed: {
                value: 0,
                writable: true
            },
            _cookie: {
                value: null,
                writable: true
            },
            _eventObserver: {
                value: options.eventObserver
            },
            _heartbeatTimeout: {
                value: null,
                writable: true
            },
            _hellosLeft: {
                value: options.maxConsecutiveFailedHellos,
                writable: true
            },
            _instanceId: {
                value: ++nInstances
            },
            _log: {
                value: log
            },
            _messageQueue: {
                value: []
            },
            _networkMonitor: {
                value: networkMonitor
            },
            _options: {
                value: options
            },
            _openTimeout: {
                value: null,
                writable: true
            },
            _sendHeartbeatTimeout: {
                value: null,
                writable: true
            },
            _serverUrl: {
                value: serverUrl
            },
            _welcomeTimeout: {
                value: null,
                writable: true
            },
            _ws: {
                value: null,
                writable: true
            }
        });
        var eventsToLevels = {
            connecting: 'info',
            early: 'info',
            open: 'info',
            waiting: 'warning',
            closed: 'info'
        };
        _this.on('stateChanged', function (state) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (state in events) {
                _this.emit.apply(_this, __spreadArray([events[state]], __read(args)));
            }
            var event = { name: state, group: 'signaling', level: eventsToLevels[_this.state] };
            if (state === 'closed') {
                var _a = __read(args, 1), reason = _a[0];
                event.payload = { reason: reason };
                event.level = reason === CloseReason.LOCAL ? 'info' : 'error';
            }
            _this._eventObserver.emit('event', event);
        });
        _this._eventObserver.emit('event', { name: _this.state, group: 'signaling', level: eventsToLevels[_this.state] });
        _this._connect();
        return _this;
    }
    TwilioConnection.prototype.toString = function () {
        return "[TwilioConnection #" + this._instanceId + ": " + this._ws.url + "]";
    };
    /**
     * Close the {@link TwilioConnection}.
     * @param {{code: number, reason: string}} event
     * @private
     */
    TwilioConnection.prototype._close = function (_a) {
        var code = _a.code, reason = _a.reason;
        if (this.state === 'closed') {
            return;
        }
        if (this._openTimeout) {
            this._openTimeout.clear();
        }
        if (this._welcomeTimeout) {
            this._welcomeTimeout.clear();
        }
        if (this._heartbeatTimeout) {
            this._heartbeatTimeout.clear();
        }
        if (this._sendHeartbeatTimeout) {
            this._sendHeartbeatTimeout.clear();
        }
        if (this._networkMonitor) {
            this._networkMonitor.stop();
        }
        if (this._busyWaitTimeout && code !== WS_CLOSE_BUSY_WAIT) {
            this._busyWaitTimeout.clear();
        }
        this._messageQueue.splice(0);
        var log = this._log;
        if (code === WS_CLOSE_NORMAL) {
            log.debug('Closed');
            this.transition('closed', null, [CloseReason.LOCAL]);
        }
        else {
            log.warn("Closed: " + code + " - " + reason);
            if (code !== WS_CLOSE_BUSY_WAIT) {
                this.transition('closed', null, [
                    wsCloseCodesToCloseReasons.get(code) || CloseReason.REMOTE
                ]);
            }
        }
        var readyState = this._ws.readyState;
        var WebSocket = this._options.WebSocket;
        if (readyState !== WebSocket.CLOSING && readyState !== WebSocket.CLOSED) {
            this._ws.close(code, reason);
        }
    };
    /**
     * Connect to the TCMP server.
     * @private
     */
    TwilioConnection.prototype._connect = function () {
        var _this = this;
        var log = this._log;
        if (this.state === 'waiting') {
            this.transition('early');
        }
        else if (this.state !== 'early') {
            log.warn("Unexpected state \"" + this.state + "\" for connecting to the"
                + ' TCMP server.');
            return;
        }
        this._ws = new this._options.WebSocket(this._serverUrl);
        var ws = this._ws;
        log.debug('Created a new WebSocket:', ws);
        ws.addEventListener('close', function (event) { return _this._close(event); });
        var openTimeout = this._options.openTimeout;
        // Add a timeout for getting the onopen event on the WebSocket (15 sec). After that, attempt to reconnect only if this is not the first attempt.
        this._openTimeout = new Timeout(function () {
            var reason = "Failed to open in " + openTimeout + " ms";
            _this._close({ code: WS_CLOSE_OPEN_TIMEOUT, reason: reason });
        }, openTimeout);
        ws.addEventListener('open', function () {
            log.debug('WebSocket opened:', ws);
            _this._openTimeout.clear();
            _this._startHandshake();
            if (_this._networkMonitor) {
                _this._networkMonitor.start();
            }
        });
        ws.addEventListener('message', function (message) {
            log.debug("Incoming: " + message.data);
            try {
                message = JSON.parse(message.data);
            }
            catch (error) {
                _this.emit('error', error);
                return;
            }
            switch (message.type) {
                case 'bad':
                    _this._handleBad(message);
                    break;
                case 'busy':
                    _this._handleBusy(message);
                    break;
                case 'bye':
                    // Do nothing.
                    break;
                case 'msg':
                    _this._handleMessage(message);
                // NOTE(mpatwardhan): Each incoming message should be treated as an incoming
                // heartbeat intentionally falling through to 'heartbeat' case.
                // eslint-disable-next-line no-fallthrough
                case 'heartbeat':
                    _this._handleHeartbeat();
                    break;
                case 'welcome':
                    _this._handleWelcome(message);
                    break;
                default:
                    _this._log.debug("Unknown message type: " + message.type);
                    _this.emit('error', new Error("Unknown message type: " + message.type));
                    break;
            }
        });
    };
    /**
     * Handle an incoming "bad" message.
     * @param {{reason: string}} message
     * @private
     */
    TwilioConnection.prototype._handleBad = function (_a) {
        var reason = _a.reason;
        var log = this._log;
        if (!['connecting', 'open'].includes(this.state)) {
            log.warn("Unexpected state \"" + this.state + "\" for handling a \"bad\" message"
                + ' from the TCMP server.');
            return;
        }
        if (this.state === 'connecting') {
            log.warn("Closing: " + WS_CLOSE_HELLO_FAILED + " - " + reason);
            this._close({ code: WS_CLOSE_HELLO_FAILED, reason: reason });
            return;
        }
        log.debug("Error: " + reason);
        this.emit('error', new Error(reason));
    };
    /**
     * Handle an incoming "busy" message.
     * @param {{cookie: ?string, keepAlive: boolean, retryAfter: number}} message
     * @private
     */
    TwilioConnection.prototype._handleBusy = function (_a) {
        var _this = this;
        var cookie = _a.cookie, keepAlive = _a.keepAlive, retryAfter = _a.retryAfter;
        var log = this._log;
        if (!['connecting', 'waiting'].includes(this.state)) {
            log.warn("Unexpected state \"" + this.state + "\" for handling a \"busy\" message"
                + ' from the TCMP server.');
            return;
        }
        if (this._busyWaitTimeout) {
            this._busyWaitTimeout.clear();
        }
        if (this._welcomeTimeout) {
            this._welcomeTimeout.clear();
        }
        var reason = retryAfter < 0
            ? 'Received terminal "busy" message'
            : "Received \"busy\" message, retrying after " + retryAfter + " ms";
        if (retryAfter < 0) {
            log.warn("Closing: " + WS_CLOSE_SERVER_BUSY + " - " + reason);
            this._close({ code: WS_CLOSE_SERVER_BUSY, reason: reason });
            return;
        }
        var maxConsecutiveFailedHellos = this._options.maxConsecutiveFailedHellos;
        this._hellosLeft = maxConsecutiveFailedHellos;
        this._cookie = cookie || null;
        if (keepAlive) {
            log.warn(reason);
            this._busyWaitTimeout = new Timeout(function () { return _this._startHandshake(); }, retryAfter);
        }
        else {
            log.warn("Closing: " + WS_CLOSE_BUSY_WAIT + " - " + reason);
            this._close({ code: WS_CLOSE_BUSY_WAIT, reason: reason });
            this._busyWaitTimeout = new Timeout(function () { return _this._connect(); }, retryAfter);
        }
        this.transition('waiting', null, [keepAlive, retryAfter]);
    };
    /**
     * Handle an incoming "heartbeat" message.
     * @private
     */
    TwilioConnection.prototype._handleHeartbeat = function () {
        if (this.state !== 'open') {
            this._log.warn("Unexpected state \"" + this.state + "\" for handling a \"heartbeat\""
                + ' message from the TCMP server.');
            return;
        }
        this._heartbeatTimeout.reset();
    };
    /**
     * Handle a missed "heartbeat" message.
     * @private
     */
    TwilioConnection.prototype._handleHeartbeatTimeout = function () {
        if (this.state !== 'open') {
            return;
        }
        var log = this._log;
        var maxConsecutiveMissedHeartbeats = this._options.maxConsecutiveMissedHeartbeats;
        log.debug("Consecutive heartbeats missed: " + maxConsecutiveMissedHeartbeats);
        var reason = "Missed " + maxConsecutiveMissedHeartbeats + " \"heartbeat\" messages";
        log.warn("Closing: " + WS_CLOSE_HEARTBEATS_MISSED + " - " + reason);
        this._close({ code: WS_CLOSE_HEARTBEATS_MISSED, reason: reason });
    };
    /**
     * Handle an incoming "msg" message.
     * @param {{body: object}} message
     * @private
     */
    TwilioConnection.prototype._handleMessage = function (_a) {
        var body = _a.body;
        if (this.state !== 'open') {
            this._log.warn("Unexpected state \"" + this.state + "\" for handling a \"msg\" message"
                + ' from the TCMP server.');
            return;
        }
        this.emit('message', body);
    };
    /**
     * Handle an incoming "welcome" message.
     * @param {{ negotiatedTimeout: number }} message
     * @private
     */
    TwilioConnection.prototype._handleWelcome = function (_a) {
        var _this = this;
        var negotiatedTimeout = _a.negotiatedTimeout;
        var log = this._log;
        if (!['connecting', 'waiting'].includes(this.state)) {
            log.warn("Unexpected state \"" + this.state + "\" for handling a \"welcome\""
                + ' message from the TCMP server.');
            return;
        }
        if (this.state === 'waiting') {
            log.debug('Received "welcome" message, no need to retry connection.');
            this._busyWaitTimeout.clear();
        }
        var maxConsecutiveMissedHeartbeats = this._options.maxConsecutiveMissedHeartbeats;
        var heartbeatTimeout = negotiatedTimeout * maxConsecutiveMissedHeartbeats;
        var outgoingHeartbeatTimeout = negotiatedTimeout - OUTGOING_HEARTBEAT_OFFSET;
        this._welcomeTimeout.clear();
        this._heartbeatTimeout = new Timeout(function () { return _this._handleHeartbeatTimeout(); }, heartbeatTimeout);
        this._messageQueue.splice(0).forEach(function (message) { return _this._send(message); });
        this._sendHeartbeatTimeout = new Timeout(function () { return _this._sendHeartbeat(); }, outgoingHeartbeatTimeout);
        this.transition('open');
    };
    /**
     * Handle a missed "welcome" message.
     * @private
     */
    TwilioConnection.prototype._handleWelcomeTimeout = function () {
        if (this.state !== 'connecting') {
            return;
        }
        var log = this._log;
        if (this._hellosLeft <= 0) {
            var reason = 'All handshake attempts failed';
            log.warn("Closing: " + WS_CLOSE_WELCOME_TIMEOUT + " - " + reason);
            this._close({ code: WS_CLOSE_WELCOME_TIMEOUT, reason: reason });
            return;
        }
        var maxConsecutiveFailedHellos = this._options.maxConsecutiveFailedHellos;
        log.warn("Handshake attempt " + (maxConsecutiveFailedHellos - this._hellosLeft) + " failed");
        this._startHandshake();
    };
    /**
     * Send a message to the TCMP server.
     * @param {*} message
     * @private
     */
    TwilioConnection.prototype._send = function (message) {
        var readyState = this._ws.readyState;
        var WebSocket = this._options.WebSocket;
        if (readyState === WebSocket.OPEN) {
            var data = JSON.stringify(message);
            this._log.debug("Outgoing: " + data);
            try {
                this._ws.send(data);
                if (this._sendHeartbeatTimeout) {
                    // Each outgoing message is to be treated as an outgoing heartbeat.
                    this._sendHeartbeatTimeout.reset();
                }
            }
            catch (error) {
                var reason = 'Failed to send message';
                this._log.warn("Closing: " + WS_CLOSE_SEND_FAILED + " - " + reason);
                this._close({ code: WS_CLOSE_SEND_FAILED, reason: reason });
            }
        }
    };
    /**
     * Send a "heartbeat" message.
     * @private
     */
    TwilioConnection.prototype._sendHeartbeat = function () {
        if (this.state === 'closed') {
            return;
        }
        this._send({ type: 'heartbeat' });
    };
    /**
     * Send a "hello" message.
     * @private
     */
    TwilioConnection.prototype._sendHello = function () {
        var _a = this._options, helloBody = _a.helloBody, timeout = _a.requestedHeartbeatTimeout;
        var hello = {
            id: makeUUID(),
            timeout: timeout,
            type: 'hello',
            version: TCMP_VERSION
        };
        if (this._cookie) {
            hello.cookie = this._cookie;
        }
        if (helloBody) {
            hello.body = helloBody;
        }
        this._send(hello);
    };
    /**
     * Send or enqueue a message.
     * @param {*} message
     * @private
     */
    TwilioConnection.prototype._sendOrEnqueue = function (message) {
        var _this = this;
        if (this.state === 'closed') {
            return;
        }
        var sendOrEnqueue = this.state === 'open'
            ? function (message) { return _this._send(message); }
            : function (message) { return _this._messageQueue.push(message); };
        sendOrEnqueue(message);
    };
    /**
     * Start the TCMP handshake.
     * @private
     */
    TwilioConnection.prototype._startHandshake = function () {
        var _this = this;
        if (['early', 'waiting'].includes(this.state)) {
            this.transition('connecting');
        }
        if (this.state !== 'connecting') {
            return;
        }
        this._hellosLeft--;
        this._sendHello();
        var welcomeTimeout = this._options.welcomeTimeout;
        this._welcomeTimeout = new Timeout(function () { return _this._handleWelcomeTimeout(); }, welcomeTimeout);
    };
    /**
     * Close the {@link TwilioConnection}.
     * @returns {void}
     */
    TwilioConnection.prototype.close = function () {
        if (this.state === 'closed') {
            return;
        }
        this._sendOrEnqueue({ type: 'bye' });
        this._close({ code: WS_CLOSE_NORMAL, reason: 'Normal' });
    };
    /**
     * Send a "msg" message.
     * @param {*} body
     * @returns {void}
     */
    TwilioConnection.prototype.sendMessage = function (body) {
        this._sendOrEnqueue({ body: body, type: 'msg' });
    };
    return TwilioConnection;
}(StateMachine));
/**
 * A unique string depicting the reason for the {@link TwilioConnection} being closed.
 * @enum {string}
 */
TwilioConnection.CloseReason = CloseReason;
/**
 * A {@link TwilioConnection} was closed.
 * @event TwilioConnection#close
 * @param {CloseReason} reason - The reason for the {@link TwilioConnection} being closed
 */
/**
 * A {@link TwilioConnection} received an error from the TCMP server.
 * @event TwilioConnection#error
 * @param {Error} error - The TCMP server error
 */
/**
 * A {@link TwilioConnection} received a message from the TCMP server.
 * @event TwilioConnection#message
 * @param {*} body - Message body
 */
/**
 * A {@link TwilioConnection} completed a hello/welcome handshake with the TCMP server.
 * @event TwilioConnection#open
 */
/**
 * A {@link TwilioConnection} received a "busy" message from the TCMP server.
 * @event TwilioConnection#waiting
 * @param {boolean} keepAlive - true if the WebSocket connection is retained
 * @param {number} retryAfter - delay in milliseconds after which a retry is attempted
 */
/**
 * {@link TwilioConnection} options
 * @typedef {object} TwilioConnectionOptions
 * @property {EventObserver} [eventObserver] - Optional event observer
 * @property {*} [helloBody=null] - Optional body for "hello" message
 * @property {LogLevel} [logLevel=warn] - Log level of the {@link TwilioConnection}
 * @property {number} [maxConsecutiveFailedHellos=3] - Max. number of consecutive failed "hello"s
 * @property {number} [maxConsecutiveMissedHeartbeats=3] - Max. number of (effective) consecutive "heartbeat" messages that can be missed
 * @property {number} [requestedHeartbeatTimeout=5000] - "heartbeat" timeout (ms) requested by the {@link TwilioConnection}
 * @property {number} [welcomeTimeout=5000] - Time (ms) to wait for the "welcome" message after sending the "hello" message
 */
module.exports = TwilioConnection;
//# sourceMappingURL=twilioconnection.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/asyncvar.js":
/*!********************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/asyncvar.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var defer = __webpack_require__(/*! ./ */ "./node_modules/twilio-video/es5/util/index.js").defer;
/**
 * An {@link AsyncVar} is an "asynchronous variable" which may or may not
 * contain a value of some type T. You can put a value into the {@link AsyncVar}
 * with {@link AsyncVar#put}. Callers can take a value out of the
 * {@link AsyncVar} by queueing up with {@link AsyncVar#take}. N calls to
 * {@link AsyncVar#take} require N calls to {@link AsyncVar#put} to resolve, and
 * they resolve in order.
 */
var AsyncVar = /** @class */ (function () {
    /**
     * Construct an {@link AsyncVar}.
     */
    function AsyncVar() {
        Object.defineProperties(this, {
            _deferreds: {
                value: []
            },
            _hasValue: {
                value: false,
                writable: true
            },
            _value: {
                value: null,
                writable: true
            }
        });
    }
    /**
     * Put a value into the {@link AsyncVar}.
     * @param {T} value
     * @returns {this}
     */
    AsyncVar.prototype.put = function (value) {
        this._hasValue = true;
        this._value = value;
        var deferred = this._deferreds.shift();
        if (deferred) {
            deferred.resolve(value);
        }
        return this;
    };
    /**
     * Take the value out of the {@link AsyncVar}.
     * @returns {Promise<T>}
     */
    AsyncVar.prototype.take = function () {
        var _this = this;
        if (this._hasValue && !this._deferreds.length) {
            this._hasValue = false;
            return Promise.resolve(this._value);
        }
        var deferred = defer();
        this._deferreds.push(deferred);
        return deferred.promise.then(function (value) {
            _this._hasValue = false;
            return value;
        });
    };
    return AsyncVar;
}());
module.exports = AsyncVar;
//# sourceMappingURL=asyncvar.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/browserdetection.js":
/*!****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/browserdetection.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals chrome, navigator */

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/**
 * Check whether the current browser is an Android device.
 * @returns {boolean}
 */
function isAndroid() {
    return /Android/.test(navigator.userAgent);
}
/**
 * Check whether the current browser is an iOS device.
 * @returns {boolean}
 */
function isIOS() {
    return /iPad|iPhone|iPod/.test(navigator.userAgent);
}
/**
 * Check whether the current browser is a mobile browser
 * @returns {boolean}
 */
function isMobile() {
    return /Mobi/.test(navigator.userAgent);
}
/**
 * Check whether the current browser is non-Chromium Edge.
 * @param {string} browser
 * @returns {boolean}
 */
function isNonChromiumEdge(browser) {
    return browser === 'chrome' && /Edge/.test(navigator.userAgent) && (typeof chrome === 'undefined' || typeof chrome.runtime === 'undefined');
}
/**
 * Get the name of the rebranded Chromium browser, if any. Re-branded Chrome's user
 * agent has the following format:
 * <source>/<version> (<os>) <engine>/<version> (<engine_name>) Chrome/<version> [Mobile] Safari/<version>
 * @param browser
 * @returns {?string} Name of the rebranded Chrome browser, or null if the browser
 *   is either not Chrome or vanilla Chrome.
 */
function rebrandedChromeBrowser(browser) {
    // If the browser is not Chrome based, then it is not a rebranded Chrome browser.
    if (browser !== 'chrome') {
        return null;
    }
    // Latest desktop Brave browser has a "brave" property in navigator.
    if ('brave' in navigator) {
        return 'brave';
    }
    // Remove the "(.+)" entries from the user agent thereby retaining only the
    // <name>[/<version>] entries.
    var parenthesizedSubstrings = getParenthesizedSubstrings(navigator.userAgent);
    var nameAndVersions = parenthesizedSubstrings.reduce(function (userAgent, substring) { return userAgent.replace(substring, ''); }, navigator.userAgent);
    // Extract the potential browser <name>s by ignoring the first two names, which
    // point to <source> and <engine>.
    var matches = nameAndVersions.match(/[^\s]+/g) || [];
    var _a = __read(matches.map(function (nameAndVersion) {
        return nameAndVersion.split('/')[0].toLowerCase();
    })), browserNames = _a.slice(2);
    // Extract the <name> that is not expected to be present in the vanilla Chrome
    // browser, which indicates the rebranded name (ex: "edg[e]", "electron"). If null,
    // then this is a vanilla Chrome browser.
    return browserNames.find(function (name) {
        return !['chrome', 'mobile', 'safari'].includes(name);
    }) || null;
}
/**
 * Get the name of the mobile webkit based browser, if any.
 * @param browser
 * @returns {?string} Name of the mobile webkit based browser, or null if the browser
 *   is either not webkit based or mobile safari.
 */
function mobileWebKitBrowser(browser) {
    if (browser !== 'safari') {
        return null;
    }
    if ('brave' in navigator) {
        return 'brave';
    }
    return ['edge', 'edg'].find(function (name) {
        return navigator.userAgent.toLowerCase().includes(name);
    }) || null;
}
/**
 * Get the top level parenthesized substrings within a given string. Unmatched
 * parentheses are ignored.
 * Ex: "abc) (def) gh(ij) (kl (mn)o) (pqr" => ["(def)", "(ij)", "(kl (mn)o)"]
 * @param {string} string
 * @returns {string[]}
 */
function getParenthesizedSubstrings(string) {
    var openParenthesisPositions = [];
    var substrings = [];
    for (var i = 0; i < string.length; i++) {
        if (string[i] === '(') {
            openParenthesisPositions.push(i);
        }
        else if (string[i] === ')' && openParenthesisPositions.length > 0) {
            var openParenthesisPosition = openParenthesisPositions.pop();
            if (openParenthesisPositions.length === 0) {
                substrings.push(string.substring(openParenthesisPosition, i + 1));
            }
        }
    }
    return substrings;
}
module.exports = {
    isAndroid: isAndroid,
    isIOS: isIOS,
    isMobile: isMobile,
    isNonChromiumEdge: isNonChromiumEdge,
    mobileWebKitBrowser: mobileWebKitBrowser,
    rebrandedChromeBrowser: rebrandedChromeBrowser
};
//# sourceMappingURL=browserdetection.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/cancelablepromise.js":
/*!*****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/cancelablepromise.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
/**
 * A Promise that can be canceled with {@link CancelablePromise#cancel}.
 * @extends Promise
*/
var CancelablePromise = /** @class */ (function () {
    /**
     * Construct a new {@link CancelablePromise}.
     * @param {CancelablePromise.OnCreate} onCreate
     * @param {CancelablePromise.OnCancel} onCancel
    */ /**
     * A function to be called on {@link CancelablePromise} creation
     * @typedef {function} CancelablePromise.OnCreate
     * @param {function(*)} resolve
     * @param {function(*)} reject
     * @param {function(): boolean} isCanceled
    */ /**
     * A function to be called when {@link CancelablePromise#cancel} is called
     * @typedef {function} CancelablePromise.OnCancel
     */
    function CancelablePromise(onCreate, onCancel) {
        var _this = this;
        /* istanbul ignore next */
        Object.defineProperties(this, {
            _isCancelable: {
                writable: true,
                value: true
            },
            _isCanceled: {
                writable: true,
                value: false
            },
            _onCancel: {
                value: onCancel
            }
        });
        Object.defineProperty(this, '_promise', {
            value: new Promise(function (resolve, reject) {
                onCreate(function (value) {
                    _this._isCancelable = false;
                    resolve(value);
                }, function (reason) {
                    _this._isCancelable = false;
                    reject(reason);
                }, function () { return _this._isCanceled; });
            })
        });
    }
    /**
     * Create a synchronously-rejected {@link CancelablePromise}.
     * @param {*} reason
     * @returns {Promise<*>}
     */
    CancelablePromise.reject = function (reason) {
        return new CancelablePromise(function rejected(resolve, reject) {
            reject(reason);
        }, function onCancel() {
            // Do nothing.
        });
    };
    /**
     * Create a synchronously-resolved {@link CancelablePromise}.
     * @param {*|Promise<*>|Thenable<*>} result
     * @returns {CancelablePromise<*>}
     */
    CancelablePromise.resolve = function (result) {
        return new CancelablePromise(function resolved(resolve) {
            resolve(result);
        }, function onCancel() {
            // Do nothing.
        });
    };
    /**
     * Attempt to cancel the {@link CancelablePromise}.
     * @returns {this}
     */
    CancelablePromise.prototype.cancel = function () {
        if (this._isCancelable) {
            this._isCanceled = true;
            this._onCancel();
        }
        return this;
    };
    /**
     * @param {function} onRejected
     * @returns {CancelablePromise}
     */
    CancelablePromise.prototype.catch = function () {
        var args = [].slice.call(arguments);
        var promise = this._promise;
        return new CancelablePromise(function onCreate(resolve, reject) {
            promise.catch.apply(promise, __spreadArray([], __read(args))).then(resolve, reject);
        }, this._onCancel);
    };
    /**
     * @param {?function} onResolved
     * @param {function} [onRejected]
     * @returns {CancelablePromise}
     */
    CancelablePromise.prototype.then = function () {
        var args = [].slice.call(arguments);
        var promise = this._promise;
        return new CancelablePromise(function onCreate(resolve, reject) {
            promise.then.apply(promise, __spreadArray([], __read(args))).then(resolve, reject);
        }, this._onCancel);
    };
    /**
   * @param {?function} onFinally
   * @returns {CancelablePromise}
   */
    CancelablePromise.prototype.finally = function () {
        var args = [].slice.call(arguments);
        var promise = this._promise;
        return new CancelablePromise(function onCreate(resolve, reject) {
            promise.finally.apply(promise, __spreadArray([], __read(args))).then(resolve, reject);
        }, this._onCancel);
    };
    return CancelablePromise;
}());
module.exports = CancelablePromise;
//# sourceMappingURL=cancelablepromise.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/constants.js":
/*!*********************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/constants.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var packageInfo = __webpack_require__(/*! ../../package.json */ "./node_modules/twilio-video/package.json");
module.exports.SDK_NAME = packageInfo.name + ".js";
module.exports.SDK_VERSION = packageInfo.version;
module.exports.SDP_FORMAT = 'unified';
module.exports.DEFAULT_ENVIRONMENT = 'prod';
module.exports.DEFAULT_REALM = 'us1';
module.exports.DEFAULT_REGION = 'gll';
module.exports.DEFAULT_LOG_LEVEL = 'warn';
module.exports.DEFAULT_LOGGER_NAME = 'twilio-video';
module.exports.WS_SERVER = function (environment, region) {
    region = region === 'gll' ? 'global' : encodeURIComponent(region);
    return environment === 'prod'
        ? "wss://" + region + ".vss.twilio.com/signaling"
        : "wss://" + region + ".vss." + environment + ".twilio.com/signaling";
};
module.exports.PUBLISH_MAX_ATTEMPTS = 5;
module.exports.PUBLISH_BACKOFF_JITTER = 10;
module.exports.PUBLISH_BACKOFF_MS = 20;
/**
 * Returns the appropriate indefinite article ("a" | "an").
 * @param {string} word - The word which determines whether "a" | "an" is returned
 * @returns {string} "a" if word's first letter is a vowel, "an" otherwise
 */
function article(word) {
    // NOTE(mmalavalli): This will not be accurate for words like "hour",
    // which have consonants as their first character, but are pronounced like
    // vowels. We can address this issue if the need arises.
    return ['a', 'e', 'i', 'o', 'u'].includes(word.toLowerCase()[0]) ? 'an' : 'a';
}
module.exports.typeErrors = {
    ILLEGAL_INVOKE: function (name, context) {
        return new TypeError("Illegal call to " + name + ": " + context);
    },
    INVALID_TYPE: function (name, type) {
        return new TypeError(name + " must be " + article(type) + " " + type);
    },
    INVALID_VALUE: function (name, values) {
        return new RangeError(name + " must be one of " + values.join(', '));
    },
    REQUIRED_ARGUMENT: function (name) {
        return new TypeError(name + " must be specified");
    }
};
module.exports.DEFAULT_FRAME_RATE = 24;
module.exports.DEFAULT_VIDEO_PROCESSOR_STATS_INTERVAL_MS = 10000;
module.exports.DEFAULT_ICE_GATHERING_TIMEOUT_MS = 15000;
module.exports.DEFAULT_SESSION_TIMEOUT_SEC = 30;
module.exports.DEFAULT_NQ_LEVEL_LOCAL = 1;
module.exports.DEFAULT_NQ_LEVEL_REMOTE = 0;
module.exports.MAX_NQ_LEVEL = 3;
module.exports.ICE_ACTIVITY_CHECK_PERIOD_MS = 1000;
module.exports.ICE_INACTIVITY_THRESHOLD_MS = 3000;
module.exports.iceRestartBackoffConfig = {
    factor: 1.1,
    initialDelay: 1,
    maxDelay: module.exports.DEFAULT_SESSION_TIMEOUT_SEC * 1000,
    randomisationFactor: 0.5
};
module.exports.reconnectBackoffConfig = {
    factor: 1.5,
    initialDelay: 80,
    randomisationFactor: 0.5
};
module.exports.subscriptionMode = {
    MODE_COLLABORATION: 'collaboration',
    MODE_GRID: 'grid',
    MODE_PRESENTATION: 'presentation'
};
module.exports.trackSwitchOffMode = {
    MODE_DISABLED: 'disabled',
    MODE_DETECTED: 'detected',
    MODE_PREDICTED: 'predicted'
};
module.exports.trackSwitchOffReason = {
    DISABLED_BY_PUBLISHER: 'disabled-by-publisher',
    DISABLED_BY_SUBSCRIBER: 'disabled-by-subscriber',
    MAX_BANDWIDTH_REACHED: 'max-bandwidth-reached',
    MAX_TRACKS_SWITCHED_ON: 'max-tracks-switched-on',
    NETWORK_CONGESTION: 'network-congestion'
};
module.exports.trackPriority = {
    PRIORITY_HIGH: 'high',
    PRIORITY_LOW: 'low',
    PRIORITY_STANDARD: 'standard'
};
module.exports.clientTrackSwitchOffControl = {
    MODE_AUTO: 'auto',
    MODE_MANUAL: 'manual'
};
module.exports.videoContentPreferencesMode = {
    MODE_AUTO: 'auto',
    MODE_MANUAL: 'manual'
};
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/detectsilentaudio.js":
/*!*****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/detectsilentaudio.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var detectSilence = __webpack_require__(/*! ../webaudio/detectsilence */ "./node_modules/twilio-video/es5/webaudio/detectsilence.js");
var N_ATTEMPTS = 3;
var ATTEMPT_DURATION_MS = 250;
/**
 * Detect whether the audio stream rendered by the given HTMLVideoElement is silent.
 * @param {HTMLAudioElement} el
 * @returns {Promise<boolean>} true if silent, false if not.
 */
function detectSilentAudio(el) {
    // NOTE(mmalavalli): We have to delay require-ing AudioContextFactory, because
    // it exports a default instance whose constructor calls Object.assign.
    var AudioContextFactory = __webpack_require__(/*! ../webaudio/audiocontext */ "./node_modules/twilio-video/es5/webaudio/audiocontext.js");
    var holder = {};
    var audioContext = AudioContextFactory.getOrCreate(holder);
    var attemptsLeft = N_ATTEMPTS;
    function doCheckSilence() {
        attemptsLeft--;
        return detectSilence(audioContext, el.srcObject, ATTEMPT_DURATION_MS).then(function (isSilent) {
            if (!isSilent) {
                return false;
            }
            if (attemptsLeft > 0) {
                return doCheckSilence();
            }
            return true;
        }).catch(function () {
            // NOTE(mmalavalli): If an error is thrown while detect silence, the audio
            // stream is assumed to be silent.
            return true;
        });
    }
    // Resolve the returned Promise with true if 3 consecutive attempts
    // to detect silent audio are successful.
    return doCheckSilence().finally(function () {
        AudioContextFactory.release(holder);
    });
}
module.exports = detectSilentAudio;
//# sourceMappingURL=detectsilentaudio.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/detectsilentvideo.js":
/*!*****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/detectsilentvideo.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Cached copy of the <canvas> used to check silent video frames.
var canvas = null;
var N_SAMPLES = 3;
var SAMPLE_HEIGHT = 50;
var SAMPLE_INTERVAL_MS = 250;
var SAMPLE_WIDTH = 50;
/**
 * Check whether the current video frame is silent by selecting a 50x50
 * sample and calculating the max value of the pixel data. If it is 0, then
 * the frame is considered to be silent.
 * @private
 * @param {HTMLVideoElement} el
 * @returns {boolean} true if silent, false if not
 */
function checkSilence(el) {
    try {
        var context = canvas.getContext('2d');
        context.drawImage(el, 0, 0, SAMPLE_WIDTH, SAMPLE_HEIGHT);
        var frame = context.getImageData(0, 0, SAMPLE_WIDTH, SAMPLE_HEIGHT);
        var frameDataWithoutAlpha = frame.data.filter(function (item, i) { return (i + 1) % 4; });
        var max = Math.max.apply(Math, frameDataWithoutAlpha);
        return max === 0;
    }
    catch (ex) {
        // eslint-disable-next-line no-console
        console.log('Error checking silence: ', ex);
        return false;
    }
}
/**
 * Detect whether the video stream rendered by the given HTMLVideoElement is silent.
 * @param {HTMLVideoElement} el
 * @returns {Promise<boolean>} true if silent, false if not.
 */
function detectSilentVideo(el) {
    // Create the canvas when detectSilentVideo() is called for the
    // first time.
    canvas = canvas || document.createElement('canvas');
    // Resolve the returned Promise with true if 3 consecutive sample
    // frames from the video being played by the HTMLVideoElement are
    // silent.
    return new Promise(function (resolve) {
        var samplesLeft = N_SAMPLES;
        setTimeout(function doCheckSilence() {
            samplesLeft--;
            if (!checkSilence(el)) {
                return resolve(false);
            }
            if (samplesLeft > 0) {
                return setTimeout(doCheckSilence, SAMPLE_INTERVAL_MS);
            }
            return resolve(true);
        }, SAMPLE_INTERVAL_MS);
    });
}
module.exports = detectSilentVideo;
//# sourceMappingURL=detectsilentvideo.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/documentvisibilitymonitor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/documentvisibilitymonitor.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * The {@link DocumentVisibilityMonitor} monitors the visibility state of the DOM
 * and executes the attached listeners in phase order when the DOM is visible.
 */
var DocumentVisibilityMonitor = /** @class */ (function () {
    /**
     * Constructor.
     * @param {number} [nPhases=1] - the number of phases
     */
    function DocumentVisibilityMonitor(nPhases) {
        var _this = this;
        if (nPhases === void 0) { nPhases = 1; }
        Object.defineProperties(this, {
            _listeners: {
                value: []
            },
            _onVisibilityChange: {
                value: function () {
                    _this._emitVisible(document.visibilityState === 'visible');
                }
            }
        });
        for (var i = 0; i < nPhases; i++) {
            this._listeners.push([]);
        }
    }
    /**
     * clears the state.
     */
    DocumentVisibilityMonitor.prototype.clear = function () {
        var nPhases = this._listeners.length;
        for (var i = 0; i < nPhases; i++) {
            this._listeners[i] = [];
        }
    };
    DocumentVisibilityMonitor.prototype._listenerCount = function () {
        return this._listeners.reduce(function (count, phaseListeners) { return count + phaseListeners.length; }, 0);
    };
    /**
     * Call all the listeners. Makes sure that all listeners for a given phase
     * are executed before calling the listeners of the next phase.
     * @private
     */
    DocumentVisibilityMonitor.prototype._emitVisible = function (isVisible) {
        var _this = this;
        var promise = Promise.resolve();
        var _loop_1 = function (phase) {
            promise = promise.then(function () { return _this._emitVisiblePhase(phase, isVisible); });
        };
        for (var phase = 1; phase <= this._listeners.length; phase++) {
            _loop_1(phase);
        }
        return promise;
    };
    /**
     * Call all the listeners for a given phase.
     * @private
     */
    DocumentVisibilityMonitor.prototype._emitVisiblePhase = function (phase, isVisible) {
        var phaseListeners = this._listeners[phase - 1];
        return Promise.all(phaseListeners.map(function (listener) {
            var ret = listener(isVisible);
            return ret instanceof Promise ? ret : Promise.resolve(ret);
        }));
    };
    /**
     * Start listening to the DOM visibility state change.
     * @private
     */
    DocumentVisibilityMonitor.prototype._start = function () {
        document.addEventListener('visibilitychange', this._onVisibilityChange);
    };
    /**
     * Stop listening to the DOM visibility state change.
     * @private
     */
    DocumentVisibilityMonitor.prototype._stop = function () {
        document.removeEventListener('visibilitychange', this._onVisibilityChange);
    };
    /**
     * Listen for the DOM visibility changes at the given phase.
     * @param {number} phase
     * @param {function} listener
     * @returns {this}
     */
    DocumentVisibilityMonitor.prototype.onVisibilityChange = function (phase, listener) {
        if (typeof phase !== 'number' || phase <= 0 || phase > this._listeners.length) {
            throw new Error('invalid phase: ', phase);
        }
        var phaseListeners = this._listeners[phase - 1];
        phaseListeners.push(listener);
        if (this._listenerCount() === 1) {
            this._start();
        }
        return this;
    };
    /**
     * Stop listening for the DOM visibility change at the given phase.
     * @param {number} phase
     * @param {function} listener
     * @returns {this}
     */
    DocumentVisibilityMonitor.prototype.offVisibilityChange = function (phase, listener) {
        if (typeof phase !== 'number' || phase <= 0 || phase > this._listeners.length) {
            throw new Error('invalid phase: ', phase);
        }
        var phaseListeners = this._listeners[phase - 1];
        var index = phaseListeners.indexOf(listener);
        if (index !== -1) {
            phaseListeners.splice(index, 1);
            if (this._listenerCount() === 0) {
                this._stop();
            }
        }
        return this;
    };
    return DocumentVisibilityMonitor;
}());
module.exports = new DocumentVisibilityMonitor(2);
//# sourceMappingURL=documentvisibilitymonitor.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/eventobserver.js":
/*!*************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/eventobserver.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable no-console */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var VALID_GROUPS = [
    'signaling',
    'room',
    'media',
    'quality',
    'video-processor',
    'preflight'
];
var VALID_LEVELS = [
    'debug',
    'error',
    'info',
    'warning'
];
/**
 * EventObserver listens to SDK events and re-emits them on the
 * @link EventListener} with some additional information.
 * @extends EventEmitter
 * @emits EventObserver#event
 */
var EventObserver = /** @class */ (function (_super) {
    __extends(EventObserver, _super);
    /**
     * Constructor.
     * @param {InsightsPublisher} publisher
     * @param {number} connectTimestamp
     * @param {Log} log
     * @param {EventListener} [eventListener]
     */
    function EventObserver(publisher, connectTimestamp, log, eventListener) {
        if (eventListener === void 0) { eventListener = null; }
        var _this = _super.call(this) || this;
        _this.on('event', function (_a) {
            var name = _a.name, group = _a.group, level = _a.level, payload = _a.payload;
            if (typeof name !== 'string') {
                log.error('Unexpected name: ', name);
                throw new Error('Unexpected name: ', name);
            }
            if (!VALID_GROUPS.includes(group)) {
                log.error('Unexpected group: ', group);
                throw new Error('Unexpected group: ', group);
            }
            if (!VALID_LEVELS.includes(level)) {
                log.error('Unexpected level: ', level);
                throw new Error('Unexpected level: ', level);
            }
            var timestamp = Date.now();
            var elapsedTime = timestamp - connectTimestamp;
            var publisherPayload = Object.assign({ elapsedTime: elapsedTime, level: level }, payload ? payload : {});
            publisher.publish(group, name, publisherPayload);
            var event = Object.assign({
                elapsedTime: elapsedTime,
                group: group,
                level: level,
                name: name,
                timestamp: timestamp
            }, payload ? { payload: payload } : {});
            var logLevel = {
                debug: 'debug',
                error: 'error',
                info: 'info',
                warning: 'warn',
            }[level];
            log[logLevel]('event', event);
            if (eventListener && group === 'signaling') {
                eventListener.emit('event', event);
            }
        });
        return _this;
    }
    return EventObserver;
}(EventEmitter));
/**
 * An SDK event.
 * @event EventObserver#event
 * @param {{name: string, payload: *}} event
 */
module.exports = EventObserver;
//# sourceMappingURL=eventobserver.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/filter.js":
/*!******************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/filter.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Filter = /** @class */ (function () {
    function Filter(options) {
        options = Object.assign({
            getKey: function defaultGetKey(a) { return a; },
            getValue: function defaultGetValue(a) { return a; },
            isLessThanOrEqualTo: function defaultIsLessThanOrEqualTo(a, b) { return a <= b; }
        }, options);
        Object.defineProperties(this, {
            _getKey: {
                value: options.getKey
            },
            _getValue: {
                value: options.getValue
            },
            _isLessThanOrEqualTo: {
                value: options.isLessThanOrEqualTo
            },
            _map: {
                value: new Map()
            }
        });
    }
    Filter.prototype.toMap = function () {
        return new Map(this._map);
    };
    Filter.prototype.updateAndFilter = function (entries) {
        return entries.filter(this.update, this);
    };
    Filter.prototype.update = function (entry) {
        var key = this._getKey(entry);
        var value = this._getValue(entry);
        if (this._map.has(key) &&
            this._isLessThanOrEqualTo(value, this._map.get(key))) {
            return false;
        }
        this._map.set(key, value);
        return true;
    };
    return Filter;
}());
module.exports = Filter;
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var constants = __webpack_require__(/*! ./constants */ "./node_modules/twilio-video/es5/util/constants.js");
var E = constants.typeErrors, trackPriority = constants.trackPriority;
var util = __webpack_require__(/*! ../webrtc/util */ "./node_modules/twilio-video/es5/webrtc/util/index.js");
var sessionSID = __webpack_require__(/*! ./sid */ "./node_modules/twilio-video/es5/util/sid.js").sessionSID;
/**
 * Return the given {@link LocalTrack} or a new {@link LocalTrack} for the
 * given MediaStreamTrack.
 * @param {LocalTrack|MediaStreamTrack} track
 * @param {object} options
 * @returns {LocalTrack}
 * @throws {TypeError}
 */
function asLocalTrack(track, options) {
    if (track instanceof options.LocalAudioTrack
        || track instanceof options.LocalVideoTrack
        || track instanceof options.LocalDataTrack) {
        return track;
    }
    if (track instanceof options.MediaStreamTrack) {
        return track.kind === 'audio'
            ? new options.LocalAudioTrack(track, options)
            : new options.LocalVideoTrack(track, options);
    }
    /* eslint new-cap:0 */
    throw E.INVALID_TYPE('track', 'LocalAudioTrack, LocalVideoTrack, LocalDataTrack, or MediaStreamTrack');
}
/**
 * Create a new {@link LocalTrackPublication} for the given {@link LocalTrack}.
 * @param {LocalTrack} track
 * @param {LocalTrackPublicationSignaling} signaling
 * @param {function(track: LocalTrackPublication): void} unpublish
 * @param {object} options
 */
function asLocalTrackPublication(track, signaling, unpublish, options) {
    var LocalTrackPublication = {
        audio: options.LocalAudioTrackPublication,
        video: options.LocalVideoTrackPublication,
        data: options.LocalDataTrackPublication
    }[track.kind];
    return new LocalTrackPublication(signaling, track, unpublish, options);
}
/**
 * Capitalize a word.
 * @param {string} word
 * @returns {string} capitalized
 */
function capitalize(word) {
    return word[0].toUpperCase() + word.slice(1);
}
/**
 * Log deprecation warnings for the given events of an EventEmitter.
 * @param {string} name
 * @param {EventEmitter} emitter
 * @param {Map<string, string>} events
 * @param {Log} log
 */
function deprecateEvents(name, emitter, events, log) {
    var warningsShown = new Set();
    emitter.on('newListener', function newListener(event) {
        if (events.has(event) && !warningsShown.has(event)) {
            log.deprecated(name + "#" + event + " has been deprecated and scheduled for removal." + (events.get(event)
                ? " Use " + name + "#" + events.get(event) + " instead."
                : ''));
            warningsShown.add(event);
        }
        if (warningsShown.size >= events.size) {
            emitter.removeListener('newListener', newListener);
        }
    });
}
/**
 * Finds the items in list1 that are not in list2.
 * @param {Array<*>|Map<*>|Set<*>} list1
 * @param {Array<*>|Map<*>|Set<*>} list2
 * @returns {Set}
 */
function difference(list1, list2) {
    list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());
    list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());
    var difference = new Set();
    list1.forEach(function (item) {
        if (!list2.has(item)) {
            difference.add(item);
        }
    });
    return difference;
}
/**
 * Filter out the keys in an object with a given value.
 * @param {object} object - Object to be filtered
 * @param {*} [filterValue] - Value to be filtered out; If not specified, then
 *   filters out all keys which have an explicit value of "undefined"
 * @returns {object} - Filtered object
 */
function filterObject(object, filterValue) {
    return Object.keys(object).reduce(function (filtered, key) {
        if (object[key] !== filterValue) {
            filtered[key] = object[key];
        }
        return filtered;
    }, {});
}
/**
 * Map a list to an array of arrays, and return the flattened result.
 * @param {Array<*>|Set<*>|Map<*>} list
 * @param {function(*): Array<*>} [mapFn]
 * @returns Array<*>
 */
function flatMap(list, mapFn) {
    var listArray = list instanceof Map || list instanceof Set
        ? Array.from(list.values())
        : list;
    mapFn = mapFn || function mapFn(item) {
        return item;
    };
    return listArray.reduce(function (flattened, item) {
        var mapped = mapFn(item);
        return flattened.concat(mapped);
    }, []);
}
/**
 * Get the user agent string, or return "Unknown".
 * @returns {string}
 */
function getUserAgent() {
    return typeof navigator !== 'undefined' && navigator.userAgent
        ? navigator.userAgent
        : 'Unknown';
}
/**
 * Get the platform component of the user agent string.
 * Example:
 *   Input - Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36
 *   Output - macintosh
 * @returns {string}
 */
function getPlatform() {
    var userAgent = getUserAgent();
    var _a = __read(userAgent.match(/\(([^)]+)\)/) || [], 2), _b = _a[1], match = _b === void 0 ? 'unknown' : _b;
    var _c = __read(match.split(';').map(function (entry) { return entry.trim(); }), 1), platform = _c[0];
    return platform.toLowerCase();
}
/**
 * Create a unique identifier.
 * @returns {string}
 */
function makeUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
/**
 * Ensure that the given function is called once per tick.
 * @param {function} fn - Function to be executed
 * @returns {function} - Schedules the given function to be called on the next tick
 */
function oncePerTick(fn) {
    var timeout = null;
    function nextTick() {
        timeout = null;
        fn();
    }
    return function scheduleNextTick() {
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(nextTick);
    };
}
function promiseFromEvents(operation, eventEmitter, successEvent, failureEvent) {
    return new Promise(function (resolve, reject) {
        function onSuccess() {
            var args = [].slice.call(arguments);
            if (failureEvent) {
                eventEmitter.removeListener(failureEvent, onFailure);
            }
            resolve.apply(void 0, __spreadArray([], __read(args)));
        }
        function onFailure() {
            var args = [].slice.call(arguments);
            eventEmitter.removeListener(successEvent, onSuccess);
            reject.apply(void 0, __spreadArray([], __read(args)));
        }
        eventEmitter.once(successEvent, onSuccess);
        if (failureEvent) {
            eventEmitter.once(failureEvent, onFailure);
        }
        operation();
    });
}
/**
 * Traverse down multiple nodes on an object and return null if
 * any link in the path is unavailable.
 * @param {Object} obj - Object to traverse
 * @param {String} path - Path to traverse. Period-separated.
 * @returns {Any|null}
 */
function getOrNull(obj, path) {
    return path.split('.').reduce(function (output, step) {
        if (!output) {
            return null;
        }
        return output[step];
    }, obj);
}
/**
 * @typedef {object} Deferred
 * @property {Promise} promise
 * @property {function} reject
 * @property {function} resolve
 */
/**
 * Create a {@link Deferred}.
 * @returns {Deferred}
 */
function defer() {
    var deferred = {};
    deferred.promise = new Promise(function (resolve, reject) {
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
    return deferred;
}
/**
 * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking
 * the method on the `wrapper` prototype will invoke the corresponding method
 * on an instance accessed by `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @param {string} methodName
 * @returns {undefined}
 */
function delegateMethod(source, wrapper, target, methodName) {
    if (methodName in wrapper) {
        // Skip any methods already set.
        return;
    }
    else if (methodName.match(/^on[a-z]+$/)) {
        // Skip EventHandlers (these are handled in the constructor).
        return;
    }
    var type;
    try {
        type = typeof source[methodName];
    }
    catch (error) {
        // NOTE(mroberts): Attempting to check the type of non-function members
        // on the prototype throws an error for some types.
    }
    if (type !== 'function') {
        // Skip non-function members.
        return;
    }
    /* eslint no-loop-func:0 */
    wrapper[methodName] = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = this[target])[methodName].apply(_a, __spreadArray([], __read(args)));
    };
}
/**
 * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking
 * the methods on the `wrapper` prototype will invoke the corresponding method
 * on an instance accessed by `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @returns {undefined}
 */
function delegateMethods(source, wrapper, target) {
    for (var methodName in source) {
        delegateMethod(source, wrapper, target, methodName);
    }
}
/**
 * Determine whether two values are deeply equal.
 * @param {*} val1
 * @param {*} val2
 * @returns {boolean}
 */
function isDeepEqual(val1, val2) {
    if (val1 === val2) {
        return true;
    }
    if (typeof val1 !== typeof val2) {
        return false;
    }
    if (val1 === null) {
        return val2 === null;
    }
    if (val2 === null) {
        return false;
    }
    if (Array.isArray(val1)) {
        return Array.isArray(val2)
            && val1.length === val2.length
            && val1.every(function (val, i) { return isDeepEqual(val, val2[i]); });
    }
    if (typeof val1 === 'object') {
        var val1Keys = Object.keys(val1).sort();
        var val2Keys = Object.keys(val2).sort();
        return !Array.isArray(val2)
            && isDeepEqual(val1Keys, val2Keys)
            && val1Keys.every(function (key) { return isDeepEqual(val1[key], val2[key]); });
    }
    return false;
}
/**
 * Whether the given argument is a non-array object.
 * @param {*} object
 * @return {boolean}
 */
function isNonArrayObject(object) {
    return typeof object === 'object' && !Array.isArray(object);
}
/**
 * For each property name on the `source` prototype, add getters and/or setters
 * to `wrapper` that proxy to `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @returns {undefined}
 */
function proxyProperties(source, wrapper, target) {
    Object.getOwnPropertyNames(source).forEach(function (propertyName) {
        proxyProperty(source, wrapper, target, propertyName);
    });
}
/**
 * For the property name on the `source` prototype, add a getter and/or setter
 * to `wrapper` that proxies to `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @param {string} propertyName
 * @returns {undefined}
 */
function proxyProperty(source, wrapper, target, propertyName) {
    if (propertyName in wrapper) {
        // Skip any properties already set.
        return;
    }
    else if (propertyName.match(/^on[a-z]+$/)) {
        Object.defineProperty(wrapper, propertyName, {
            value: null,
            writable: true
        });
        target.addEventListener(propertyName.slice(2), function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            wrapper.dispatchEvent.apply(wrapper, __spreadArray([], __read(args)));
        });
        return;
    }
    Object.defineProperty(wrapper, propertyName, {
        enumerable: true,
        get: function () {
            return target[propertyName];
        }
    });
}
/**
 * This is a function for turning a Promise into the kind referenced in the
 * Legacy Interface Extensions section of the WebRTC spec.
 * @param {Promise<*>} promise
 * @param {function<*>} onSuccess
 * @param {function<Error>} onFailure
 * @returns {Promise<undefined>}
 */
function legacyPromise(promise, onSuccess, onFailure) {
    if (onSuccess) {
        return promise.then(function (result) {
            onSuccess(result);
        }, function (error) {
            onFailure(error);
        });
    }
    return promise;
}
/**
 * Build the {@link LogLevels} object.
 * @param {String|LogLevel} logLevel - Log level name or object
 * @returns {LogLevels}
 */
function buildLogLevels(logLevel) {
    if (typeof logLevel === 'string') {
        return {
            default: logLevel,
            media: logLevel,
            signaling: logLevel,
            webrtc: logLevel
        };
    }
    return logLevel;
}
/**
 * Get the {@link Track}'s derived class name
 * @param {Track} track
 * @param {?boolean} [local=undefined]
 * @returns {string}
 */
function trackClass(track, local) {
    local = local ? 'Local' : '';
    return local + (track.kind || '').replace(/\w{1}/, function (m) { return m.toUpperCase(); }) + "Track";
}
/**
 * Get the {@link TrackPublication}'s derived class name
 * @param {TrackPublication} publication
 * @param {?boolean} [local=undefined]
 * @returns {string}
 */
function trackPublicationClass(publication, local) {
    local = local ? 'Local' : '';
    return local + (publication.kind || '').replace(/\w{1}/, function (m) { return m.toUpperCase(); }) + "TrackPublication";
}
/**
 * Sets all underscore-prefixed properties on `object` non-enumerable.
 * @param {Object} object
 * @returns {void}
 */
function hidePrivateProperties(object) {
    Object.getOwnPropertyNames(object).forEach(function (name) {
        if (name.startsWith('_')) {
            hideProperty(object, name);
        }
    });
}
/**
 * Creates a new subclass which, in the constructor, sets all underscore-prefixed
 * properties and the given public properties non-enumerable. This is useful for
 * patching up classes like EventEmitter which may set properties like `_events`
 * and `domain`.
 * @param {Function} klass
 * @param {Array<string>} props
 * @returns {Function} subclass
 */
function hidePrivateAndCertainPublicPropertiesInClass(klass, props) {
    // NOTE(mroberts): We do this to avoid giving the class a name.
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args))) || this;
            hidePrivateProperties(_this);
            hidePublicProperties(_this, props);
            return _this;
        }
        return class_1;
    }(klass));
}
/**
 * Hide a property of an object.
 * @param {object} object
 * @param {string} name
 */
function hideProperty(object, name) {
    var descriptor = Object.getOwnPropertyDescriptor(object, name);
    descriptor.enumerable = false;
    Object.defineProperty(object, name, descriptor);
}
/**
 * Hide the given public properties of an object.
 * @param {object} object
 * @param {Array<string>} [props=[]]
 */
function hidePublicProperties(object, props) {
    if (props === void 0) { props = []; }
    props.forEach(function (name) {
        // eslint-disable-next-line no-prototype-builtins
        if (object.hasOwnProperty(name)) {
            hideProperty(object, name);
        }
    });
}
/**
 * Convert an Array of values to an Array of JSON values by calling
 * `valueToJSON` on each value.
 * @param {Array<*>} array
 * @returns {Array<*>}
 */
function arrayToJSON(array) {
    return array.map(valueToJSON);
}
/**
 * Convert a Set of values to an Array of JSON values by calling `valueToJSON`
 * on each value.
 * @param {Set<*>} set
 * @returns {Array<*>}
 */
function setToJSON(set) {
    return arrayToJSON(__spreadArray([], __read(set)));
}
/**
 * Convert a Map from strings to values to an object of JSON values by calling
 * `valueToJSON` on each value.
 * @param {Map<string, *>} map
 * @returns {object}
 */
function mapToJSON(map) {
    return __spreadArray([], __read(map.entries())).reduce(function (json, _a) {
        var _b;
        var _c = __read(_a, 2), key = _c[0], value = _c[1];
        return Object.assign((_b = {}, _b[key] = valueToJSON(value), _b), json);
    }, {});
}
/**
 * Convert an object to a JSON value by calling `valueToJSON` on its enumerable
 * keys.
 * @param {object} object
 * @returns {object}
 */
function objectToJSON(object) {
    return Object.entries(object).reduce(function (json, _a) {
        var _b;
        var _c = __read(_a, 2), key = _c[0], value = _c[1];
        return Object.assign((_b = {}, _b[key] = valueToJSON(value), _b), json);
    }, {});
}
/**
 * Convert a value into a JSON value.
 * @param {*} value
 * @returns {*}
 */
function valueToJSON(value) {
    if (Array.isArray(value)) {
        return arrayToJSON(value);
    }
    else if (value instanceof Set) {
        return setToJSON(value);
    }
    else if (value instanceof Map) {
        return mapToJSON(value);
    }
    else if (value && typeof value === 'object') {
        return objectToJSON(value);
    }
    return value;
}
function createRoomConnectEventPayload(connectOptions) {
    function boolToString(val) {
        return val ? 'true' : 'false';
    }
    var payload = {
        sessionSID: sessionSID,
        // arrays props converted to lengths.
        iceServers: (connectOptions.iceServers || []).length,
        audioTracks: (connectOptions.tracks || []).filter(function (track) { return track.kind === 'audio'; }).length,
        videoTracks: (connectOptions.tracks || []).filter(function (track) { return track.kind === 'video'; }).length,
        dataTracks: (connectOptions.tracks || []).filter(function (track) { return track.kind === 'data'; }).length,
    };
    // boolean properties.
    [['audio'], ['automaticSubscription'], ['enableDscp'], ['eventListener'], ['preflight'], ['video'], ['dominantSpeaker', 'enableDominantSpeaker']].forEach(function (_a) {
        var _b = __read(_a, 2), prop = _b[0], eventProp = _b[1];
        eventProp = eventProp || prop;
        payload[eventProp] = boolToString(!!connectOptions[prop]);
    });
    // numbers properties.
    [['maxVideoBitrate'], ['maxAudioBitrate']].forEach(function (_a) {
        var _b = __read(_a, 2), prop = _b[0], eventProp = _b[1];
        eventProp = eventProp || prop;
        if (typeof connectOptions[prop] === 'number') {
            payload[eventProp] = connectOptions[prop];
        }
        else if (!isNaN(Number(connectOptions[prop]))) {
            payload[eventProp] = Number(connectOptions[prop]);
        }
    });
    // string properties.
    [['iceTransportPolicy'], ['region'], ['name', 'roomName']].forEach(function (_a) {
        var _b = __read(_a, 2), prop = _b[0], eventProp = _b[1];
        eventProp = eventProp || prop;
        if (typeof connectOptions[prop] === 'string') {
            payload[eventProp] = connectOptions[prop];
        }
        else if (typeof connectOptions[prop] === 'number' && prop === 'name') {
            payload[eventProp] = connectOptions[prop].toString();
        }
    });
    // array props stringified.
    ['preferredAudioCodecs', 'preferredVideoCodecs'].forEach(function (prop) {
        if (prop in connectOptions) {
            payload[prop] = JSON.stringify(connectOptions[prop]);
        }
    });
    if ('networkQuality' in connectOptions) {
        payload.networkQualityConfiguration = {};
        if (isNonArrayObject(connectOptions.networkQuality)) {
            ['local', 'remote'].forEach(function (prop) {
                if (typeof connectOptions.networkQuality[prop] === 'number') {
                    payload.networkQualityConfiguration[prop] = connectOptions.networkQuality[prop];
                }
            });
        }
        else {
            payload.networkQualityConfiguration.remote = 0;
            payload.networkQualityConfiguration.local = connectOptions.networkQuality ? 1 : 0;
        }
    }
    if (connectOptions.bandwidthProfile && connectOptions.bandwidthProfile.video) {
        var videoBPOptions_1 = connectOptions.bandwidthProfile.video || {};
        payload.bandwidthProfileOptions = {};
        ['mode', ['maxSwitchedOnTracks', 'maxVideoTracks'], 'trackSwitchOffMode', 'dominantSpeakerPriority', 'maxSubscriptionBitrate', 'renderDimensions', 'contentPreferencesMode', 'clientTrackSwitchOffControl'].forEach(function (prop) {
            var destProp = Array.isArray(prop) ? prop[1] : prop;
            var srcProp = Array.isArray(prop) ? prop[0] : prop;
            var srcPropValue = videoBPOptions_1[srcProp];
            if (typeof srcPropValue === 'number' || typeof srcPropValue === 'string') {
                payload.bandwidthProfileOptions[destProp] = srcPropValue;
            }
            else if (typeof srcPropValue === 'boolean') {
                payload.bandwidthProfileOptions[destProp] = boolToString(srcPropValue);
            }
            else if (typeof videoBPOptions_1[destProp] === 'object') {
                payload.bandwidthProfileOptions[destProp] = JSON.stringify(srcPropValue);
            }
        });
        var audioBPOptions_1 = connectOptions.bandwidthProfile.audio || {};
        [['maxSwitchedOnTracks', 'maxAudioTracks']].forEach(function (prop) {
            var destProp = Array.isArray(prop) ? prop[1] : prop;
            var srcProp = Array.isArray(prop) ? prop[0] : prop;
            var srcPropValue = audioBPOptions_1[srcProp];
            if (typeof srcPropValue === 'number' || typeof srcPropValue === 'string') {
                payload.bandwidthProfileOptions[destProp] = srcPropValue;
            }
            else if (typeof srcPropValue === 'boolean') {
                payload.bandwidthProfileOptions[destProp] = boolToString(srcPropValue);
            }
            else if (typeof videoBPOptions_1[destProp] === 'object') {
                payload.bandwidthProfileOptions[destProp] = JSON.stringify(srcPropValue);
            }
        });
    }
    return {
        group: 'room',
        name: 'connect',
        level: 'info',
        payload: payload
    };
}
/**
 * Create the bandwidth profile payload included in an RSP connect message.
 * @param {BandwidthProfile} bandwidthProfile
 * @returns {object}
 */
function createBandwidthProfilePayload(bandwidthProfile) {
    return createRSPPayload(bandwidthProfile, [
        { prop: 'video', type: 'object', transform: createBandwidthProfileVideoPayload },
        { prop: 'audio', type: 'object', transform: createBandwidthProfileAudioPayload }
    ]);
}
/**
 * Create the bandwidth profile audio payload included in an RSP connect message.
 * @param {AudioBandwidthProfile} bandwidthProfileAudio
 * @returns {object}
 */
function createBandwidthProfileAudioPayload(bandwidthProfileAudio) {
    return createRSPPayload(bandwidthProfileAudio, [
        { prop: 'maxSwitchedOnTracks', type: 'number', payloadProp: 'max_tracks' }
    ]);
}
/**
 * Create the bandwidth profile video payload included in an RSP connect message.
 * @param {VideoBandwidthProfile} bandwidthProfileVideo
 * @returns {object}
 */
function createBandwidthProfileVideoPayload(bandwidthProfileVideo) {
    return createRSPPayload(bandwidthProfileVideo, [
        { prop: 'dominantSpeakerPriority', type: 'string', payloadProp: 'active_speaker_priority' },
        { prop: 'maxSubscriptionBitrate', type: 'number', payloadProp: 'max_subscription_bandwidth' },
        { prop: 'maxSwitchedOnTracks', type: 'number', payloadProp: 'max_tracks' },
        { prop: 'mode', type: 'string' },
        { prop: 'renderDimensions', type: 'object', payloadProp: 'render_dimensions', transform: createRenderDimensionsPayload },
        { prop: 'trackSwitchOffMode', type: 'string', payloadProp: 'track_switch_off' }
    ]);
}
/**
 * Create the Media Signaling payload included in an RSP connect message.
 * @param {boolean} dominantSpeaker - whether to enable the Dominant Speaker
 *   protocol or not
 * @param {boolean} networkQuality - whether to enable the Network Quality
 *   protocol or not
 * @param {boolean} trackPriority - whether to enable the Track Priority
 *   protocol or not
 * @param {boolean} trackSwitchOff - whether to enable the Track Switch-Off
 *   protocol or not.
 * @param {boolean} renderHints - whether to enable the renderHints
 *   protocol or not.
 * @returns {object}
 */
function createMediaSignalingPayload(dominantSpeaker, networkQuality, trackPriority, trackSwitchOff, adaptiveSimulcast, renderHints) {
    var transports = { transports: [{ type: 'data-channel' }] };
    return Object.assign(dominantSpeaker
        // eslint-disable-next-line
        ? { active_speaker: transports }
        : {}, networkQuality
        // eslint-disable-next-line
        ? { network_quality: transports }
        : {}, renderHints
        // eslint-disable-next-line
        ? { render_hints: transports }
        : {}, adaptiveSimulcast
        // eslint-disable-next-line
        ? { publisher_hints: transports }
        : {}, trackPriority
        // eslint-disable-next-line
        ? { track_priority: transports }
        : {}, trackSwitchOff
        // eslint-disable-next-line
        ? { track_switch_off: transports }
        : {}, 
    // eslint-disable-next-line
    { track_subscriptions: transports });
}
/**
 * Create {@link VideoTrack.Dimensions} RSP payload.
 * @param {VideoTrack.Dimensions} [dimensions]
 * @returns {object}
 */
function createDimensionsPayload(dimensions) {
    return createRSPPayload(dimensions, [
        { prop: 'height', type: 'number' },
        { prop: 'width', type: 'number' }
    ]);
}
/**
 * Create {@link VideoRenderDimensions} RSP payload.
 * @param renderDimensions
 * @returns {object}
 */
function createRenderDimensionsPayload(renderDimensions) {
    var PRIORITY_HIGH = trackPriority.PRIORITY_HIGH, PRIORITY_LOW = trackPriority.PRIORITY_LOW, PRIORITY_STANDARD = trackPriority.PRIORITY_STANDARD;
    return createRSPPayload(renderDimensions, [
        { prop: PRIORITY_HIGH, type: 'object', transform: createDimensionsPayload },
        { prop: PRIORITY_LOW, type: 'object', transform: createDimensionsPayload },
        { prop: PRIORITY_STANDARD, type: 'object', transform: createDimensionsPayload }
    ]);
}
/**
 * Create an RSP payload for the given object.
 * @param {object} object - object for which RSP payload is to be generated
 * @param {Array<object>} propConversions - conversion rules for object properties;
 *   they specify how object properties should be converted to their corresponding
 *   RSP payload properties
 * @returns {object}
 */
function createRSPPayload(object, propConversions) {
    return propConversions.reduce(function (payload, _a) {
        var _b;
        var prop = _a.prop, type = _a.type, _c = _a.payloadProp, payloadProp = _c === void 0 ? prop : _c, _d = _a.transform, transform = _d === void 0 ? function (x) { return x; } : _d;
        return typeof object[prop] === type
            ? Object.assign((_b = {}, _b[payloadProp] = transform(object[prop]), _b), payload)
            : payload;
    }, {});
}
/**
 * Create the subscribe payload included in an RSP connect/update message.
 * @param {boolean} automaticSubscription - whether to subscribe to all RemoteTracks
 * @returns {object}
 */
function createSubscribePayload(automaticSubscription) {
    return {
        rules: [{
                type: automaticSubscription ? 'include' : 'exclude',
                all: true
            }],
        revision: 1
    };
}
/**
 * Add random jitter to a given value in the range [-jitter, jitter].
 * @private
 * @param {number} value
 * @param {number} jitter
 * @returns {number} value + random(-jitter, +jitter)
 */
function withJitter(value, jitter) {
    var rand = Math.random();
    return value - jitter + Math.floor(2 * jitter * rand + 0.5);
}
/**
 * Checks if the a number is in the range [min, max].
 * @private
 * @param {num} num
 * @param {number} min
 * @param {number} max
 * @return {boolean}
 */
function inRange(num, min, max) {
    return min <= num && num <= max;
}
/**
 * returns true if given MediaStreamTrack is a screen share track
 * @private
 * @param {MediaStreamTrack} track
 * @returns {boolean}
 */
function isChromeScreenShareTrack(track) {
    // NOTE(mpatwardhan): Chrome creates screen share tracks with label like: "screen:69734272*"
    // we will check for label that starts with "screen:D" where D being a digit.
    return util.guessBrowser() === 'chrome' && track.kind === 'video' && 'displaySurface' in track.getSettings();
}
/**
 * returns true if given MediaStreamTrack is a user media track
 * @private
 * @param {MediaStreamTrack} track
 * @returns {boolean}
 */
function isUserMediaTrack(track) {
    // NOTE(mpatwardhan): tracks obtained from getUserMedia have a deviceId in its settings.
    return typeof track.getSettings().deviceId === 'string';
}
/**
 * Returns a promise that resolve after timeoutMS have passed.
 * @param {number} timeoutMS - time to wait in milliseconds.
 * @returns {Promise<void>}
 */
function waitForSometime(timeoutMS) {
    if (timeoutMS === void 0) { timeoutMS = 10; }
    return new Promise(function (resolve) { return setTimeout(resolve, timeoutMS); });
}
/**
 * Returns a promise that resolve after event is received
 * @returns {Promise<void>}
 */
function waitForEvent(eventTarget, event) {
    return new Promise(function (resolve) {
        eventTarget.addEventListener(event, function onevent(e) {
            eventTarget.removeEventListener(event, onevent);
            resolve(e);
        });
    });
}
/**
 * Re-emit {@link TrackPublication} events.
 * @private
 * @param {Participant} participant
 * @param {TrackPublication} publication
 */
function reemitTrackPublicationEvents(participant, publication) {
    var publicationEventReemitters = new Map();
    if (participant.state === 'disconnected') {
        return;
    }
    participant._getTrackPublicationEvents().forEach(function (_a) {
        var _b = __read(_a, 2), publicationEvent = _b[0], participantEvent = _b[1];
        publicationEventReemitters.set(publicationEvent, function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (publicationEvent === 'trackSwitchedOff') {
                var _a = __read(args, 2), track = _a[0], switchOffReason = _a[1];
                participant.emit(participantEvent, track, publication, switchOffReason);
            }
            else {
                participant.emit.apply(participant, __spreadArray(__spreadArray([participantEvent], __read(args)), [publication]));
            }
        });
        publication.on(publicationEvent, publicationEventReemitters.get(publicationEvent));
    });
    participant._trackPublicationEventReemitters.set(publication.trackSid, publicationEventReemitters);
}
exports.constants = constants;
exports.createBandwidthProfilePayload = createBandwidthProfilePayload;
exports.createMediaSignalingPayload = createMediaSignalingPayload;
exports.createRoomConnectEventPayload = createRoomConnectEventPayload;
exports.createSubscribePayload = createSubscribePayload;
exports.asLocalTrack = asLocalTrack;
exports.asLocalTrackPublication = asLocalTrackPublication;
exports.capitalize = capitalize;
exports.deprecateEvents = deprecateEvents;
exports.difference = difference;
exports.filterObject = filterObject;
exports.flatMap = flatMap;
exports.getPlatform = getPlatform;
exports.getUserAgent = getUserAgent;
exports.hidePrivateProperties = hidePrivateProperties;
exports.hidePrivateAndCertainPublicPropertiesInClass = hidePrivateAndCertainPublicPropertiesInClass;
exports.isDeepEqual = isDeepEqual;
exports.isNonArrayObject = isNonArrayObject;
exports.inRange = inRange;
exports.makeUUID = makeUUID;
exports.oncePerTick = oncePerTick;
exports.promiseFromEvents = promiseFromEvents;
exports.getOrNull = getOrNull;
exports.defer = defer;
exports.delegateMethods = delegateMethods;
exports.proxyProperties = proxyProperties;
exports.legacyPromise = legacyPromise;
exports.buildLogLevels = buildLogLevels;
exports.trackClass = trackClass;
exports.trackPublicationClass = trackPublicationClass;
exports.valueToJSON = valueToJSON;
exports.withJitter = withJitter;
exports.isChromeScreenShareTrack = isChromeScreenShareTrack;
exports.isUserMediaTrack = isUserMediaTrack;
exports.waitForSometime = waitForSometime;
exports.waitForEvent = waitForEvent;
exports.reemitTrackPublicationEvents = reemitTrackPublicationEvents;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/insightspublisher/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/insightspublisher/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var getUserAgent = __webpack_require__(/*! .. */ "./node_modules/twilio-video/es5/util/index.js").getUserAgent;
var MAX_RECONNECT_ATTEMPTS = 5;
var RECONNECT_INTERVAL_MS = 50;
var WS_CLOSE_NORMAL = 1000;
var toplevel = global.window || global;
var WebSocket = toplevel.WebSocket ? toplevel.WebSocket : __webpack_require__(/*! ws */ "./node_modules/twilio-video/src/ws.js");
var util = __webpack_require__(/*! ../../util */ "./node_modules/twilio-video/es5/util/index.js");
/**
 * Publish events to the Insights gateway.
 * @extends EventEmitter
 * @emits InsightsPublisher#connected
 * @emits InsightsPublisher#disconnected
 * @emits InsightsPublisher#reconnecting
 */
var InsightsPublisher = /** @class */ (function (_super) {
    __extends(InsightsPublisher, _super);
    /**
     * @param {string} token - Insights gateway token
     * @param {string} sdkName - Name of the SDK using the {@link InsightsPublisher}
     * @param {string} sdkVersion - Version of the SDK using the {@link InsightsPublisher}
     * @param {string} environment - One of 'dev', 'stage' or 'prod'
     * @param {string} realm - Region identifier
     * @param {InsightsPublisherOptions} options - Override default behavior
     */
    function InsightsPublisher(token, sdkName, sdkVersion, environment, realm, options) {
        var _this = _super.call(this) || this;
        options = Object.assign({
            gateway: createGateway(environment, realm) + "/v1/VideoEvents",
            maxReconnectAttempts: MAX_RECONNECT_ATTEMPTS,
            reconnectIntervalMs: RECONNECT_INTERVAL_MS,
            userAgent: getUserAgent(),
            WebSocket: WebSocket
        }, options);
        Object.defineProperties(_this, {
            _connectTimestamp: {
                value: 0,
                writable: true
            },
            _eventQueue: {
                value: []
            },
            _readyToConnect: {
                value: util.defer()
            },
            _reconnectAttemptsLeft: {
                value: options.maxReconnectAttempts,
                writable: true
            },
            _ws: {
                value: null,
                writable: true
            },
            _WebSocket: {
                value: options.WebSocket
            }
        });
        _this._readyToConnect.promise.then(function (_a) {
            var roomSid = _a.roomSid, participantSid = _a.participantSid;
            var self = _this;
            _this.on('disconnected', function maybeReconnect(error) {
                self._session = null;
                if (error && self._reconnectAttemptsLeft > 0) {
                    self.emit('reconnecting');
                    reconnect(self, token, sdkName, sdkVersion, roomSid, participantSid, options);
                    return;
                }
                self.removeListener('disconnected', maybeReconnect);
            });
            connect(_this, token, sdkName, sdkVersion, roomSid, participantSid, options);
        }).catch(function () {
            // ignore failures to connect
        });
        return _this;
    }
    /**
     * Start connecting to the Insights gateway.
     * @param {string} roomSid
     * @param {string} participantSid
     * @returns {void}
     */
    InsightsPublisher.prototype.connect = function (roomSid, participantSid) {
        this._readyToConnect.resolve({ roomSid: roomSid, participantSid: participantSid });
    };
    /**
     * Publish an event to the Insights gateway.
     * @private
     * @param {*} event
     */
    InsightsPublisher.prototype._publish = function (event) {
        event.session = this._session;
        this._ws.send(JSON.stringify(event));
    };
    /**
     * Disconnect from the Insights gateway.
     * @returns {boolean} true if called when connecting/open, false if not
     */
    InsightsPublisher.prototype.disconnect = function () {
        if (this._ws === null
            || this._ws.readyState === this._WebSocket.CLOSING
            || this._ws.readyState === this._WebSocket.CLOSED) {
            return false;
        }
        try {
            this._ws.close();
        }
        catch (error) {
            // Do nothing.
        }
        this.emit('disconnected');
        return true;
    };
    /**
     * Publish (or queue, if not connected) an event to the Insights gateway.
     * @param {string} groupName - Event group name
     * @param {string} eventName - Event name
     * @param {object} payload - Event payload
     * @returns {boolean} true if queued or published, false if disconnect() called
     */
    InsightsPublisher.prototype.publish = function (groupName, eventName, payload) {
        if (this._ws !== null
            && (this._ws.readyState === this._WebSocket.CLOSING
                || this._ws.readyState === this._WebSocket.CLOSED)) {
            return false;
        }
        var publishOrEnqueue = typeof this._session === 'string'
            ? this._publish.bind(this)
            : this._eventQueue.push.bind(this._eventQueue);
        publishOrEnqueue({
            group: groupName,
            name: eventName,
            payload: payload,
            timestamp: Date.now(),
            type: 'event',
            version: 1
        });
        return true;
    };
    return InsightsPublisher;
}(EventEmitter));
/**
 * Start connecting to the Insights gateway.
 * @private
 * @param {InsightsPublisher} publisher
 * @param {string} name
 * @param {string} token
 * @param {string} sdkName
 * @param {string} sdkVersion
 * @param {string} roomSid
 * @param {string} participantSid
 * @param {InsightsPublisherOptions} options
 */
function connect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options) {
    publisher._connectTimestamp = Date.now();
    publisher._reconnectAttemptsLeft--;
    publisher._ws = new options.WebSocket(options.gateway);
    var ws = publisher._ws;
    ws.addEventListener('close', function (event) {
        if (event.code === WS_CLOSE_NORMAL) {
            publisher.emit('disconnected');
            return;
        }
        publisher.emit('disconnected', new Error("WebSocket Error " + event.code + ": " + event.reason));
    });
    ws.addEventListener('message', function (message) {
        handleConnectResponse(publisher, JSON.parse(message.data), options);
    });
    ws.addEventListener('open', function () {
        var connectRequest = {
            type: 'connect',
            token: token,
            version: 1
        };
        connectRequest.publisher = {
            name: sdkName,
            sdkVersion: sdkVersion,
            userAgent: options.userAgent,
            participantSid: participantSid,
            roomSid: roomSid,
        };
        ws.send(JSON.stringify(connectRequest));
    });
}
/**
 * Create the Insights Websocket gateway URL.
 * @param {string} environment
 * @param {string} realm
 * @returns {string}
 */
function createGateway(environment, realm) {
    return environment === 'prod' ? "wss://sdkgw." + realm + ".twilio.com"
        : "wss://sdkgw." + environment + "-" + realm + ".twilio.com";
}
/**
 * Handle connect response from the Insights gateway.
 * @param {InsightsPublisher} publisher
 * @param {*} response
 * @param {InsightsPublisherOptions} options
 */
function handleConnectResponse(publisher, response, options) {
    switch (response.type) {
        case 'connected':
            publisher._session = response.session;
            publisher._reconnectAttemptsLeft = options.maxReconnectAttempts;
            publisher._eventQueue.splice(0).forEach(publisher._publish, publisher);
            publisher.emit('connected');
            break;
        case 'error':
            publisher._ws.close();
            publisher.emit('disconnected', new Error(response.message));
            break;
    }
}
/**
 * Start re-connecting to the Insights gateway with an appropriate delay based
 * on InsightsPublisherOptions#reconnectIntervalMs.
 * @private
 * @param {InsightsPublisher} publisher
 * @param {string} token
 * @param {string} sdkName
 * @param {string} sdkVersion
 * @param {string} roomSid
 * @param {string} participantSid
 * @param {InsightsPublisherOptions} options
 */
function reconnect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options) {
    var connectInterval = Date.now() - publisher._connectTimestamp;
    var timeToWait = options.reconnectIntervalMs - connectInterval;
    if (timeToWait > 0) {
        setTimeout(function () {
            connect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options);
        }, timeToWait);
        return;
    }
    connect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options);
}
/**
 * The {@link InsightsPublisher} is connected to the gateway.
 * @event InsightsPublisher#connected
 */
/**
 * The {@link InsightsPublisher} is disconnected from the gateway.
 * @event InsightsPublisher#disconnected
 * @param {Error} [error] - Optional error if disconnected unintentionally
 */
/**
 * The {@link InsightsPublisher} is re-connecting to the gateway.
 * @event InsightsPublisher#reconnecting
 */
/**
 * {@link InsightsPublisher} options.
 * @typedef {object} InsightsPublisherOptions
 * @property {string} [gateway=sdkgw.{environment}-{realm}.twilio.com] - Insights WebSocket gateway url
 * @property {number} [maxReconnectAttempts=5] - Max re-connect attempts
 * @property {number} [reconnectIntervalMs=50] - Re-connect interval in ms
 */
module.exports = InsightsPublisher;
//# sourceMappingURL=index.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/insightspublisher/null.js":
/*!**********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/insightspublisher/null.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// eslint-disable-next-line no-warning-comments
// TODO(mroberts): This should be described as implementing some
// InsightsPublisher interface.

/**
 * Null Insights publisher.
 */
var InsightsPublisher = /** @class */ (function () {
    function InsightsPublisher() {
        Object.defineProperties(this, {
            _connected: {
                writable: true,
                value: true
            }
        });
    }
    /**
     * Connect
     * @returns {void}
     */
    InsightsPublisher.prototype.connect = function () {
    };
    /**
     * Disconnect.
     * @returns {boolean}
     */
    InsightsPublisher.prototype.disconnect = function () {
        if (this._connected) {
            this._connected = false;
            return true;
        }
        return false;
    };
    /**
     * Publish.
     * @returns {boolean}
     */
    InsightsPublisher.prototype.publish = function () {
        return this._connected;
    };
    return InsightsPublisher;
}());
module.exports = InsightsPublisher;
//# sourceMappingURL=null.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/localmediarestartdeferreds.js":
/*!**************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/localmediarestartdeferreds.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var defer = __webpack_require__(/*! ./ */ "./node_modules/twilio-video/es5/util/index.js").defer;
/**
 * This is a pair of Deferreds that are set whenever local media is muted and
 * resolved whenever local media is unmuted/ended and restarted if necessary.
 */
var LocalMediaRestartDeferreds = /** @class */ (function () {
    /**
     * Constructor.
     */
    function LocalMediaRestartDeferreds() {
        Object.defineProperties(this, {
            _audio: {
                value: defer(),
                writable: true
            },
            _video: {
                value: defer(),
                writable: true
            }
        });
        // Initially, resolve both the Deferreds.
        this._audio.resolve();
        this._video.resolve();
    }
    /**
     * Resolve the Deferred for audio or video.
     * @param {'audio'|'video'} kind
     */
    LocalMediaRestartDeferreds.prototype.resolveDeferred = function (kind) {
        if (kind === 'audio') {
            this._audio.resolve();
        }
        else {
            this._video.resolve();
        }
    };
    /**
     * Start the Deferred for audio or video.
     * @param {'audio' | 'video'} kind
     */
    LocalMediaRestartDeferreds.prototype.startDeferred = function (kind) {
        if (kind === 'audio') {
            this._audio = defer();
        }
        else {
            this._video = defer();
        }
    };
    /**
     * Wait until the Deferred for audio or video is resolved.
     * @param {'audio'|'video'} kind
     * @returns {Promise<void>}
     */
    LocalMediaRestartDeferreds.prototype.whenResolved = function (kind) {
        return kind === 'audio' ? this._audio.promise : this._video.promise;
    };
    return LocalMediaRestartDeferreds;
}());
module.exports = new LocalMediaRestartDeferreds();
//# sourceMappingURL=localmediarestartdeferreds.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/log.js":
/*!***************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/log.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint new-cap:0 */

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var defaultGetLogger = __webpack_require__(/*! ../vendor/loglevel */ "./node_modules/twilio-video/es5/vendor/loglevel.js").getLogger;
var constants = __webpack_require__(/*! ./constants */ "./node_modules/twilio-video/es5/util/constants.js");
var DEFAULT_LOG_LEVEL = constants.DEFAULT_LOG_LEVEL, DEFAULT_LOGGER_NAME = constants.DEFAULT_LOGGER_NAME;
var E = __webpack_require__(/*! ./constants */ "./node_modules/twilio-video/es5/util/constants.js").typeErrors;
var deprecationWarningsByComponentConstructor;
function getDeprecationWarnings(componentConstructor) {
    deprecationWarningsByComponentConstructor = deprecationWarningsByComponentConstructor || new Map();
    if (deprecationWarningsByComponentConstructor.has(componentConstructor)) {
        return deprecationWarningsByComponentConstructor.get(componentConstructor);
    }
    var deprecationWarnings = new Set();
    deprecationWarningsByComponentConstructor.set(componentConstructor, deprecationWarnings);
    return deprecationWarnings;
}
/**
 * Selectively outputs messages to console based on specified minimum module
 * specific log levels.
 *
 * NOTE: The values in the logLevels object passed to the constructor is changed
 *       by subsequent calls to {@link Log#setLevels}.
 */
var Log = /** @class */ (function () {
    /**
     * Construct a new {@link Log} object.
     * @param {String} moduleName - Name of the logging module (webrtc/media/signaling)
     * @param {object} component - Component owning this instance of {@link Log}
     * @param {LogLevels} logLevels - Logging levels. See {@link LogLevels}
     * @param {String} loggerName - Name of the logger instance. Used when calling getLogger from loglevel module
     * @param {Function} [getLogger] - optional method used internally.
     */
    function Log(moduleName, component, logLevels, loggerName, getLogger) {
        if (typeof moduleName !== 'string') {
            throw E.INVALID_TYPE('moduleName', 'string');
        }
        if (!component) {
            throw E.REQUIRED_ARGUMENT('component');
        }
        if (typeof logLevels !== 'object') {
            logLevels = {};
        }
        getLogger = getLogger || defaultGetLogger;
        validateLogLevels(logLevels);
        /* istanbul ignore next */
        Object.defineProperties(this, {
            _component: {
                value: component
            },
            _logLevels: {
                value: logLevels
            },
            _warnings: {
                value: new Set()
            },
            _loggerName: {
                get: function get() {
                    var name = loggerName && typeof loggerName === 'string' ? loggerName : DEFAULT_LOGGER_NAME;
                    if (!this._logLevelsEqual) {
                        name = name + "-" + moduleName;
                    }
                    return name;
                }
            },
            _logger: {
                get: function get() {
                    var logger = getLogger(this._loggerName);
                    var level = this._logLevels[moduleName] || DEFAULT_LOG_LEVEL;
                    // There is no 'off' in the logger module. It uses 'silent' instead
                    level = level === 'off' ? 'silent' : level;
                    logger.setDefaultLevel(level);
                    return logger;
                }
            },
            _logLevelsEqual: {
                get: function get() {
                    // True if all levels are the same
                    return (new Set(Object.values(this._logLevels)).size) === 1;
                }
            },
            logLevel: {
                get: function get() {
                    return Log.getLevelByName(logLevels[moduleName] || DEFAULT_LOG_LEVEL);
                }
            },
            name: { get: component.toString.bind(component) }
        });
    }
    /**
     * Get the log level (number) by its name (string)
     * @param {String} name - Name of the log level
     * @returns {Number} Requested log level
     * @throws {TwilioError} INVALID_LOG_LEVEL (32056)
     * @public
     */
    Log.getLevelByName = function (name) {
        if (!isNaN(name)) {
            return parseInt(name, 10);
        }
        name = name.toUpperCase();
        validateLogLevel(name);
        return Log[name];
    };
    /**
     * Create a child {@link Log} instance with this._logLevels
     * @param moduleName - Name of the logging module
     * @param component - Component owning this instance of {@link Log}
     * @returns {Log} this
     */
    Log.prototype.createLog = function (moduleName, component) {
        var name = this._loggerName;
        // Grab the original logger name
        if (!this._logLevelsEqual) {
            name = name.substring(0, name.lastIndexOf('-'));
        }
        return new Log(moduleName, component, this._logLevels, name);
    };
    /**
     * Set new log levels.
     * This changes the levels for all its ancestors,
     * siblings, and children and descendants instances of {@link Log}.
     * @param {LogLevels} levels - New log levels
     * @throws {TwilioError} INVALID_ARGUMENT
     * @returns {Log} this
     */
    Log.prototype.setLevels = function (levels) {
        validateLogLevels(levels);
        Object.assign(this._logLevels, levels);
        return this;
    };
    /**
     * Log a message using the logger method appropriate for the specified logLevel
     * @param {Number} logLevel - Log level of the message being logged
     * @param {Array} messages - Message(s) to log
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.log = function (logLevel, messages) {
        var name = Log._levels[logLevel];
        // eslint-disable-next-line no-use-before-define
        if (!name) {
            throw E.INVALID_VALUE('logLevel', LOG_LEVEL_VALUES);
        }
        name = name.toLowerCase();
        var prefix = [new Date().toISOString(), name, this.name];
        (this._logger[name] || function noop() { }).apply(void 0, __spreadArray([], __read(prefix.concat(messages))));
        return this;
    };
    /**
     * Log a debug message
     * @param {...String} messages - Message(s) to pass to the logger
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.debug = function () {
        return this.log(Log.DEBUG, [].slice.call(arguments));
    };
    /**
     * Log a deprecation warning. Deprecation warnings are logged as warnings and
     * they are only ever logged once.
     * @param {String} deprecationWarning - The deprecation warning
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.deprecated = function (deprecationWarning) {
        var deprecationWarnings = getDeprecationWarnings(this._component.constructor);
        if (deprecationWarnings.has(deprecationWarning)) {
            return this;
        }
        deprecationWarnings.add(deprecationWarning);
        return this.warn(deprecationWarning);
    };
    /**
     * Log an info message
     * @param {...String} messages - Message(s) to pass to the logger
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.info = function () {
        return this.log(Log.INFO, [].slice.call(arguments));
    };
    /**
     * Log a warn message
     * @param {...String} messages - Message(s) to pass to the logger
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.warn = function () {
        return this.log(Log.WARN, [].slice.call(arguments));
    };
    /**
     * Log a warning once.
     * @param {String} warning
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.warnOnce = function (warning) {
        if (this._warnings.has(warning)) {
            return this;
        }
        this._warnings.add(warning);
        return this.warn(warning);
    };
    /**
     * Log an error message
     * @param {...String} messages - Message(s) to pass to the logger
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.error = function () {
        return this.log(Log.ERROR, [].slice.call(arguments));
    };
    /**
     * Log an error message and throw an exception
     * @param {TwilioError} error - Error to throw
     * @param {String} customMessage - Custom message for the error
     * @public
     */
    Log.prototype.throw = function (error, customMessage) {
        if (error.clone) {
            error = error.clone(customMessage);
        }
        this.log(Log.ERROR, error);
        throw error;
    };
    return Log;
}());
// Singleton Constants
/* eslint key-spacing:0 */
/* istanbul ignore next */
Object.defineProperties(Log, {
    DEBUG: { value: 0 },
    INFO: { value: 1 },
    WARN: { value: 2 },
    ERROR: { value: 3 },
    OFF: { value: 4 },
    _levels: {
        value: [
            'DEBUG',
            'INFO',
            'WARN',
            'ERROR',
            'OFF',
        ]
    }
});
var LOG_LEVELS_SET = {};
var LOG_LEVEL_VALUES = [];
var LOG_LEVEL_NAMES = Log._levels.map(function (level, i) {
    LOG_LEVELS_SET[level] = true;
    LOG_LEVEL_VALUES.push(i);
    return level;
});
function validateLogLevel(level) {
    if (!(level in LOG_LEVELS_SET)) {
        throw E.INVALID_VALUE('level', LOG_LEVEL_NAMES);
    }
}
function validateLogLevels(levels) {
    Object.keys(levels).forEach(function (moduleName) {
        validateLogLevel(levels[moduleName].toUpperCase());
    });
}
module.exports = Log;
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/movingaveragedelta.js":
/*!******************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/movingaveragedelta.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Calculates the moving average delta for the given pair ofsamples. A sample (S)
 * consists of a numerator (Sn) and a denominator (Sd).The moving average delta is
 * calculated as follows:
 *
 * MovingAvgDelta = (Sn[1] - Sn[0]) / (Sd[1] - Sd[0])
 */
var MovingAverageDelta = /** @class */ (function () {
    /**
     * Constructor.
     */
    function MovingAverageDelta() {
        Object.defineProperties(this, {
            _samples: {
                value: [
                    { denominator: 0, numerator: 0 },
                    { denominator: 0, numerator: 0 }
                ],
            }
        });
    }
    /**
     * Get the moving average delta.
     * @returns {number}
     */
    MovingAverageDelta.prototype.get = function () {
        var samples = this._samples;
        var denominatorDelta = (samples[1].denominator - samples[0].denominator) || Infinity;
        var numeratorDelta = samples[1].numerator - samples[0].numerator;
        return numeratorDelta / denominatorDelta;
    };
    /**
     * Put a sample and get rid of the older sample to maintain sample size of 2.
     * @param numerator
     * @param denominator
     */
    MovingAverageDelta.prototype.putSample = function (numerator, denominator) {
        var samples = this._samples;
        samples.shift();
        samples.push({ denominator: denominator, numerator: numerator });
    };
    return MovingAverageDelta;
}());
module.exports = MovingAverageDelta;
//# sourceMappingURL=movingaveragedelta.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/networkmonitor.js":
/*!**************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/networkmonitor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Monitor the network connection status to detect interruptions and handoffs.
 */
var NetworkMonitor = /** @class */ (function () {
    /**
     * Construct a {@link NetworkMonitor}.
     * @param {function} onNetworkChanged
     * @param {*} [options]
     */
    function NetworkMonitor(onNetworkChanged, options) {
        var _this = this;
        options = Object.assign({
            navigator: navigator,
            window: window,
        }, options);
        var nav = options.navigator;
        var connection = nav.connection || { type: null };
        var type = connection.type;
        var _a = connection.type ? {
            _events: {
                value: ['change', 'typechange']
            },
            _listener: {
                value: function () {
                    var networkChanged = type !== _this.type && _this.isOnline;
                    type = _this.type;
                    if (networkChanged) {
                        onNetworkChanged();
                    }
                }
            },
            _target: {
                value: connection
            }
        } : {
            _events: {
                value: ['online']
            },
            _listener: {
                value: onNetworkChanged
            },
            _target: {
                value: options.window
            }
        }, _events = _a._events, _listener = _a._listener, _target = _a._target;
        Object.defineProperties(this, {
            isOnline: {
                enumerable: true,
                get: function () {
                    return typeof nav.onLine === 'boolean'
                        ? nav.onLine
                        : true;
                }
            },
            type: {
                enumerable: true,
                get: function () {
                    return connection.type || null;
                }
            },
            _listener: _listener,
            _events: _events,
            _target: _target
        });
    }
    /**
     * Start the {@link NetworkMonitor}.
     */
    NetworkMonitor.prototype.start = function () {
        var _this = this;
        this._events.forEach(function (event) {
            _this._target.addEventListener(event, _this._listener);
        });
    };
    /**
     * Stop the {@link NetworkMonitor}.
     */
    NetworkMonitor.prototype.stop = function () {
        var _this = this;
        this._events.forEach(function (event) {
            _this._target.removeEventListener(event, _this._listener);
        });
    };
    return NetworkMonitor;
}());
module.exports = NetworkMonitor;
//# sourceMappingURL=networkmonitor.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/nullobserver.js":
/*!************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/nullobserver.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable no-console */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NullObserver = /** @class */ (function () {
    function NullObserver(callback) {
        Object.defineProperties(this, {
            _callback: {
                value: callback
            }
        });
    }
    NullObserver.prototype.observe = function () {
    };
    NullObserver.prototype.unobserve = function () {
    };
    NullObserver.prototype.makeVisible = function (videoEl) {
        var visibleEntry = this._makeFakeEntry(videoEl, true);
        this._callback([visibleEntry]);
    };
    NullObserver.prototype.makeInvisible = function (videoEl) {
        var invisibleEntry = this._makeFakeEntry(videoEl, false);
        this._callback([invisibleEntry]);
    };
    NullObserver.prototype._makeFakeEntry = function (videoElement, isIntersecting) {
        return { target: videoElement, isIntersecting: isIntersecting };
    };
    return NullObserver;
}());
var NullIntersectionObserver = /** @class */ (function (_super) {
    __extends(NullIntersectionObserver, _super);
    function NullIntersectionObserver() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NullIntersectionObserver;
}(NullObserver));
var NullResizeObserver = /** @class */ (function (_super) {
    __extends(NullResizeObserver, _super);
    function NullResizeObserver() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NullResizeObserver.prototype.resize = function (videoEl) {
        var entry = this._makeFakeEntry(videoEl, true);
        this._callback([entry]);
    };
    return NullResizeObserver;
}(NullObserver));
module.exports = { NullIntersectionObserver: NullIntersectionObserver, NullResizeObserver: NullResizeObserver, NullObserver: NullObserver };
//# sourceMappingURL=nullobserver.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/sdp/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/sdp/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var _a = __webpack_require__(/*! ../ */ "./node_modules/twilio-video/es5/util/index.js"), difference = _a.difference, flatMap = _a.flatMap;
var setSimulcastInMediaSection = __webpack_require__(/*! ./simulcast */ "./node_modules/twilio-video/es5/util/sdp/simulcast.js");
var ptToFixedBitrateAudioCodecName = {
    0: 'PCMU',
    8: 'PCMA'
};
/**
 * A payload type
 * @typedef {number} PT
 */
/**
 * An {@link AudioCodec} or {@link VideoCodec}
 * @typedef {AudioCodec|VideoCodec} Codec
 */
/**
 * Create a Codec Map for the given m= section.
 * @param {string} section - The given m= section
 * @returns {Map<Codec, Array<PT>>}
 */
function createCodecMapForMediaSection(section) {
    return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {
        var pt = pair[0];
        var codecName = pair[1];
        var pts = codecMap.get(codecName) || [];
        return codecMap.set(codecName, pts.concat(pt));
    }, new Map());
}
/**
 * Create a Map of MIDs to m= sections for the given SDP.
 * @param {string} sdp
 * @returns {Map<string, string>}
 */
function createMidToMediaSectionMap(sdp) {
    return getMediaSections(sdp).reduce(function (midsToMediaSections, mediaSection) {
        var mid = getMidForMediaSection(mediaSection);
        return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;
    }, new Map());
}
/**
 * Create a Map from PTs to codec names for the given m= section.
 * @param {string} mediaSection - The given m= section.
 * @returns {Map<PT, Codec>} ptToCodecName
 */
function createPtToCodecName(mediaSection) {
    return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {
        var rtpmapPattern = new RegExp("a=rtpmap:" + pt + " ([^/]+)");
        var matches = mediaSection.match(rtpmapPattern);
        var codecName = matches
            ? matches[1].toLowerCase()
            : ptToFixedBitrateAudioCodecName[pt]
                ? ptToFixedBitrateAudioCodecName[pt].toLowerCase()
                : '';
        return ptToCodecName.set(pt, codecName);
    }, new Map());
}
/**
 * Get the associated fmtp attributes for the given Payload Type in an m= section.
 * @param {PT} pt
 * @param {string} mediaSection
 * @returns {?object}
 */
function getFmtpAttributesForPt(pt, mediaSection) {
    // In "a=fmtp:<pt> <name>=<value>[;<name>=<value>]*", the regex matches the codec
    // profile parameters expressed as name/value pairs separated by ";".
    var fmtpRegex = new RegExp("^a=fmtp:" + pt + " (.+)$", 'm');
    var matches = mediaSection.match(fmtpRegex);
    return matches && matches[1].split(';').reduce(function (attrs, nvPair) {
        var _a = __read(nvPair.split('='), 2), name = _a[0], value = _a[1];
        attrs[name] = isNaN(value) ? value : parseInt(value, 10);
        return attrs;
    }, {});
}
/**
 * Get the MID for the given m= section.
 * @param {string} mediaSection
 * @return {?string}
 */
function getMidForMediaSection(mediaSection) {
    // In "a=mid:<mid>", the regex matches <mid>.
    var midMatches = mediaSection.match(/^a=mid:(.+)$/m);
    return midMatches && midMatches[1];
}
/**
 * Get the m= sections of a particular kind and direction from an sdp.
 * @param {string} sdp - SDP string
 * @param {string} [kind] - Pattern for matching kind
 * @param {string} [direction] - Pattern for matching direction
 * @returns {Array<string>} mediaSections
 */
function getMediaSections(sdp, kind, direction) {
    return sdp.replace(/\r\n\r\n$/, '\r\n').split('\r\nm=').slice(1).map(function (mediaSection) { return "m=" + mediaSection; }).filter(function (mediaSection) {
        var kindPattern = new RegExp("m=" + (kind || '.*'), 'gm');
        var directionPattern = new RegExp("a=" + (direction || '.*'), 'gm');
        return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);
    });
}
/**
 * Get the Codec Payload Types present in the first line of the given m= section
 * @param {string} section - The m= section
 * @returns {Array<PT>} Payload Types
 */
function getPayloadTypesInMediaSection(section) {
    var mLine = section.split('\r\n')[0];
    // In "m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>",
    // the regex matches <port> and the Payload Types.
    var matches = mLine.match(/([0-9]+)/g);
    // This should not happen, but in case there are no Payload Types in
    // the m= line, return an empty array.
    if (!matches) {
        return [];
    }
    // Since only the Payload Types are needed, we discard the <port>.
    return matches.slice(1).map(function (match) { return parseInt(match, 10); });
}
/**
 * Create the reordered Codec Payload Types based on the preferred Codec Names.
 * @param {Map<Codec, Array<PT>>} codecMap - Codec Map
 * @param {Array<AudioCodecSettings|VideoCodecSettings>} preferredCodecs - Preferred Codecs
 * @returns {Array<PT>} Reordered Payload Types
 */
function getReorderedPayloadTypes(codecMap, preferredCodecs) {
    preferredCodecs = preferredCodecs.map(function (_a) {
        var codec = _a.codec;
        return codec.toLowerCase();
    });
    var preferredPayloadTypes = flatMap(preferredCodecs, function (codecName) { return codecMap.get(codecName) || []; });
    var remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);
    var remainingPayloadTypes = flatMap(remainingCodecs, function (codecName) { return codecMap.get(codecName); });
    return preferredPayloadTypes.concat(remainingPayloadTypes);
}
/**
 * Set the given Codec Payload Types in the first line of the given m= section.
 * @param {Array<PT>} payloadTypes - Payload Types
 * @param {string} section - Given m= section
 * @returns {string} - Updated m= section
 */
function setPayloadTypesInMediaSection(payloadTypes, section) {
    var lines = section.split('\r\n');
    var mLine = lines[0];
    var otherLines = lines.slice(1);
    mLine = mLine.replace(/([0-9]+\s?)+$/, payloadTypes.join(' '));
    return [mLine].concat(otherLines).join('\r\n');
}
/**
 * Return a new SDP string with the re-ordered codec preferences.
 * @param {string} sdp
 * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order
 *   of audio codecs is preserved
 * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the
 *   existing order of video codecs is preserved
 * @returns {string} Updated SDP string
 */
function setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {
    var mediaSections = getMediaSections(sdp);
    var session = sdp.split('\r\nm=')[0];
    return [session].concat(mediaSections.map(function (section) {
        // Codec preferences should not be applied to m=application sections.
        if (!/^m=(audio|video)/.test(section)) {
            return section;
        }
        var kind = section.match(/^m=(audio|video)/)[1];
        var codecMap = createCodecMapForMediaSection(section);
        var preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs;
        var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);
        var newSection = setPayloadTypesInMediaSection(payloadTypes, section);
        var pcmaPayloadTypes = codecMap.get('pcma') || [];
        var pcmuPayloadTypes = codecMap.get('pcmu') || [];
        var fixedBitratePayloadTypes = kind === 'audio'
            ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes))
            : new Set();
        return fixedBitratePayloadTypes.has(payloadTypes[0])
            ? newSection.replace(/\r\nb=(AS|TIAS):([0-9]+)/g, '')
            : newSection;
    })).join('\r\n');
}
/**
 * Return a new SDP string with simulcast settings.
 * @param {string} sdp
 * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes
 * @returns {string} Updated SDP string
 */
function setSimulcast(sdp, trackIdsToAttributes) {
    var mediaSections = getMediaSections(sdp);
    var session = sdp.split('\r\nm=')[0];
    return [session].concat(mediaSections.map(function (section) {
        section = section.replace(/\r\n$/, '');
        if (!/^m=video/.test(section)) {
            return section;
        }
        var codecMap = createCodecMapForMediaSection(section);
        var payloadTypes = getPayloadTypesInMediaSection(section);
        var vp8PayloadTypes = new Set(codecMap.get('vp8') || []);
        var hasVP8PayloadType = payloadTypes.some(function (payloadType) { return vp8PayloadTypes.has(payloadType); });
        return hasVP8PayloadType
            ? setSimulcastInMediaSection(section, trackIdsToAttributes)
            : section;
    })).concat('').join('\r\n');
}
/**
 * Get the matching Payload Types in an m= section for a particular peer codec.
 * @param {Codec} peerCodec
 * @param {PT} peerPt
 * @param {Map<Codec, PT>} codecsToPts
 * @param {string} section
 * @param {string} peerSection
 * @returns {Array<PT>}
 */
function getMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) {
    // If there is at most one local Payload Type that matches the remote codec, retain it.
    var matchingPts = codecsToPts.get(peerCodec) || [];
    if (matchingPts.length <= 1) {
        return matchingPts;
    }
    // If there are no fmtp attributes for the codec in the peer m= section, then we
    // cannot get a match in the  m= section. In that case, retain all matching Payload
    // Types.
    var peerFmtpAttrs = getFmtpAttributesForPt(peerPt, peerSection);
    if (!peerFmtpAttrs) {
        return matchingPts;
    }
    // Among the matched local Payload Types, find the one that matches the remote
    // fmtp attributes.
    var matchingPt = matchingPts.find(function (pt) {
        var fmtpAttrs = getFmtpAttributesForPt(pt, section);
        return fmtpAttrs && Object.keys(peerFmtpAttrs).every(function (attr) {
            return peerFmtpAttrs[attr] === fmtpAttrs[attr];
        });
    });
    // If none of the matched Payload Types also have matching fmtp attributes,
    // then retain all of them, otherwise retain only the Payload Type that
    // matches the peer fmtp attributes.
    return typeof matchingPt === 'number' ? [matchingPt] : matchingPts;
}
/**
 * Filter codecs in an m= section based on its peer m= section from the other peer.
 * @param {string} section
 * @param {Map<string, string>} peerMidsToMediaSections
 * @param {Array<string>} codecsToRemove
 * @returns {string}
 */
function filterCodecsInMediaSection(section, peerMidsToMediaSections, codecsToRemove) {
    // Do nothing if the m= section represents neither audio nor video.
    if (!/^m=(audio|video)/.test(section)) {
        return section;
    }
    // Do nothing if the m= section does not have an equivalent remote m= section.
    var mid = getMidForMediaSection(section);
    var peerSection = mid && peerMidsToMediaSections.get(mid);
    if (!peerSection) {
        return section;
    }
    // Construct a Map of the peer Payload Types to their codec names.
    var peerPtToCodecs = createPtToCodecName(peerSection);
    // Construct a Map of the codec names to their Payload Types.
    var codecsToPts = createCodecMapForMediaSection(section);
    // Maintain a list of non-rtx Payload Types to retain.
    var pts = flatMap(Array.from(peerPtToCodecs), function (_a) {
        var _b = __read(_a, 2), peerPt = _b[0], peerCodec = _b[1];
        return peerCodec !== 'rtx' && !codecsToRemove.includes(peerCodec)
            ? getMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection)
            : [];
    });
    // For each Payload Type that will be retained, retain their corresponding rtx
    // Payload Type if present.
    var rtxPts = codecsToPts.get('rtx') || [];
    // In "a=fmtp:<rtxPt> apt=<apt>", extract the codec PT <apt> associated with rtxPt.
    pts = pts.concat(rtxPts.filter(function (rtxPt) {
        var fmtpAttrs = getFmtpAttributesForPt(rtxPt, section);
        return fmtpAttrs && pts.includes(fmtpAttrs.apt);
    }));
    // Filter out the below mentioned attribute lines in the m= section that do not
    // belong to one of the Payload Types that are to be retained.
    // 1. "a=rtpmap:<pt> <codec>"
    // 2. "a=rtcp-fb:<pt> <attr>[ <attr>]*"
    // 3. "a=fmtp:<pt> <name>=<value>[;<name>=<value>]*"
    var lines = section.split('\r\n').filter(function (line) {
        var ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);
        var pt = ptMatches && ptMatches[2];
        return !ptMatches || (pt && pts.includes(parseInt(pt, 10)));
    });
    // Filter the list of Payload Types in the first line of the m= section.
    var orderedPts = getPayloadTypesInMediaSection(section).filter(function (pt) { return pts.includes(pt); });
    return setPayloadTypesInMediaSection(orderedPts, lines.join('\r\n'));
}
/**
 * Filter local codecs based on the remote SDP.
 * @param {string} localSdp
 * @param {string} remoteSdp
 * @returns {string} - Updated local SDP
 */
function filterLocalCodecs(localSdp, remoteSdp) {
    var localMediaSections = getMediaSections(localSdp);
    var localSession = localSdp.split('\r\nm=')[0];
    var remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);
    return [localSession].concat(localMediaSections.map(function (localSection) {
        return filterCodecsInMediaSection(localSection, remoteMidsToMediaSections, []);
    })).join('\r\n');
}
/**
 * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.
 * @param localSdp - simulcast enabled local sdp
 * @param localSdpWithoutSimulcast - local sdp before simulcast was set
 * @param remoteSdp - remote sdp
 * @param revertForAll - when true simulcast will be reverted for all codecs. when false it will be reverted
 *  only for non-vp8 codecs.
 * @return {string} Updated SDP string
 */
function revertSimulcast(localSdp, localSdpWithoutSimulcast, remoteSdp, revertForAll) {
    if (revertForAll === void 0) { revertForAll = false; }
    var remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);
    var localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);
    var mediaSections = getMediaSections(localSdp);
    var session = localSdp.split('\r\nm=')[0];
    return [session].concat(mediaSections.map(function (section) {
        section = section.replace(/\r\n$/, '');
        if (!/^m=video/.test(section)) {
            return section;
        }
        var midMatches = section.match(/^a=mid:(.+)$/m);
        var mid = midMatches && midMatches[1];
        if (!mid) {
            return section;
        }
        var remoteSection = remoteMidToMediaSections.get(mid);
        var remotePtToCodecs = createPtToCodecName(remoteSection);
        var remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);
        var isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';
        var shouldRevertSimulcast = revertForAll || !isVP8ThePreferredCodec;
        return shouldRevertSimulcast ? localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\r\n$/, '') : section;
    })).concat('').join('\r\n');
}
/**
 * Add or rewrite MSIDs for new m= sections in the given SDP with their corresponding
 * local MediaStreamTrack IDs. These can be different when previously removed MediaStreamTracks
 * are added back (or Track IDs may not be present in the SDPs at all once browsers implement
 * the latest WebRTC spec).
 * @param {string} sdp
 * @param {Map<string, Track.ID>} activeMidsToTrackIds
 * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind
 * @returns {string}
 */
function addOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {
    // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually
    // present after the m= sections for the existing MediaStreamTracks, in order
    // of addition.
    var newMidsToTrackIds = Array.from(trackIdsByKind).reduce(function (midsToTrackIds, _a) {
        var _b = __read(_a, 2), kind = _b[0], trackIds = _b[1];
        var mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');
        var newMids = mediaSections.map(getMidForMediaSection).filter(function (mid) { return !activeMidsToTrackIds.has(mid); });
        newMids.forEach(function (mid, i) { return midsToTrackIds.set(mid, trackIds[i]); });
        return midsToTrackIds;
    }, new Map());
    return addOrRewriteTrackIds(sdp, newMidsToTrackIds);
}
/**
 * Add or rewrite MSIDs in the given SDP with their corresponding local MediaStreamTrack IDs.
 * These IDs need not be the same (or Track IDs may not be present in the SDPs at all once
 * browsers implement the latest WebRTC spec).
 * @param {string} sdp
 * @param {Map<string, Track.ID>} midsToTrackIds
 * @returns {string}
 */
function addOrRewriteTrackIds(sdp, midsToTrackIds) {
    var mediaSections = getMediaSections(sdp);
    var session = sdp.split('\r\nm=')[0];
    return [session].concat(mediaSections.map(function (mediaSection) {
        // Do nothing if the m= section represents neither audio nor video.
        if (!/^m=(audio|video)/.test(mediaSection)) {
            return mediaSection;
        }
        // This shouldn't happen, but in case there is no MID for the m= section, do nothing.
        var mid = getMidForMediaSection(mediaSection);
        if (!mid) {
            return mediaSection;
        }
        // In case there is no Track ID for the given MID in the map, do nothing.
        var trackId = midsToTrackIds.get(mid);
        if (!trackId) {
            return mediaSection;
        }
        // This shouldn't happen, but in case there is no a=msid: line, do nothing.
        var attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];
        if (!attributes) {
            return mediaSection;
        }
        // If the a=msid: line contains the "appdata" field, then replace it with the Track ID,
        // otherwise append the Track ID.
        var _a = __read(attributes.split(' '), 2), msid = _a[0], trackIdToRewrite = _a[1];
        var msidRegex = new RegExp("msid:" + msid + (trackIdToRewrite ? " " + trackIdToRewrite : '') + "$", 'gm');
        return mediaSection.replace(msidRegex, "msid:" + msid + " " + trackId);
    })).join('\r\n');
}
/**
 * Removes specified ssrc attributes from given sdp.
 * @param {string} sdp
 * @param {Array<string>} ssrcAttributesToRemove
 * @returns {string}
 */
function removeSSRCAttributes(sdp, ssrcAttributesToRemove) {
    return sdp.split('\r\n').filter(function (line) {
        return !ssrcAttributesToRemove.find(function (srcAttribute) { return new RegExp('a=ssrc:.*' + srcAttribute + ':', 'g').test(line); });
    }).join('\r\n');
}
/**
 * Disable RTX in a given sdp.
 * @param {string} sdp
 * @returns {string} sdp without RTX
 */
function disableRtx(sdp) {
    var mediaSections = getMediaSections(sdp);
    var session = sdp.split('\r\nm=')[0];
    return [session].concat(mediaSections.map(function (mediaSection) {
        // Do nothing if the m= section does not represent a video track.
        if (!/^m=video/.test(mediaSection)) {
            return mediaSection;
        }
        // Create a map of codecs to payload types.
        var codecsToPts = createCodecMapForMediaSection(mediaSection);
        // Get the RTX payload types.
        var rtxPts = codecsToPts.get('rtx');
        // Do nothing if there are no RTX payload types.
        if (!rtxPts) {
            return mediaSection;
        }
        // Remove the RTX payload types.
        var pts = new Set(getPayloadTypesInMediaSection(mediaSection));
        rtxPts.forEach(function (rtxPt) { return pts.delete(rtxPt); });
        // Get the RTX SSRC.
        var rtxSSRCMatches = mediaSection.match(/a=ssrc-group:FID [0-9]+ ([0-9]+)/);
        var rtxSSRC = rtxSSRCMatches && rtxSSRCMatches[1];
        // Remove the following lines associated with the RTX payload types:
        // 1. "a=fmtp:<rtxPt> apt=<pt>"
        // 2. "a=rtpmap:<rtxPt> rtx/..."
        // 3. "a=ssrc:<rtxSSRC> cname:..."
        // 4. "a=ssrc-group:FID <SSRC> <rtxSSRC>"
        var filterRegexes = [
            /^a=fmtp:.+ apt=.+$/,
            /^a=rtpmap:.+ rtx\/.+$/,
            /^a=ssrc-group:.+$/
        ].concat(rtxSSRC
            ? [new RegExp("^a=ssrc:" + rtxSSRC + " .+$")]
            : []);
        mediaSection = mediaSection.split('\r\n')
            .filter(function (line) { return filterRegexes.every(function (regex) { return !regex.test(line); }); })
            .join('\r\n');
        // Reconstruct the m= section without the RTX payload types.
        return setPayloadTypesInMediaSection(Array.from(pts), mediaSection);
    })).join('\r\n');
}
/**
 * Generate an a=fmtp: line from the given payload type and attributes.
 * @param {PT} pt
 * @param {*} fmtpAttrs
 * @returns {string}
 */
function generateFmtpLineFromPtAndAttributes(pt, fmtpAttrs) {
    var serializedFmtpAttrs = Object.entries(fmtpAttrs).map(function (_a) {
        var _b = __read(_a, 2), name = _b[0], value = _b[1];
        return name + "=" + value;
    }).join(';');
    return "a=fmtp:" + pt + " " + serializedFmtpAttrs;
}
/**
 * Enable DTX for opus in the m= sections for the given MIDs.`
 * @param {string} sdp
 * @param {Array<string>} [mids] - If not specified, enables opus DTX for all
 *   audio m= lines.
 * @returns {string}
 */
function enableDtxForOpus(sdp, mids) {
    var mediaSections = getMediaSections(sdp);
    var session = sdp.split('\r\nm=')[0];
    mids = mids || mediaSections
        .filter(function (section) { return /^m=audio/.test(section); })
        .map(getMidForMediaSection);
    return [session].concat(mediaSections.map(function (section) {
        // Do nothing if the m= section is not audio.
        if (!/^m=audio/.test(section)) {
            return section;
        }
        // Build a map codecs to payload types.
        var codecsToPts = createCodecMapForMediaSection(section);
        // Do nothing if a payload type for opus does not exist.
        var opusPt = codecsToPts.get('opus');
        if (!opusPt) {
            return section;
        }
        // If no fmtp attributes are found for opus, do nothing.
        var opusFmtpAttrs = getFmtpAttributesForPt(opusPt, section);
        if (!opusFmtpAttrs) {
            return section;
        }
        // Add usedtx=1 to the a=fmtp: line for opus.
        var origOpusFmtpLine = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);
        var origOpusFmtpRegex = new RegExp(origOpusFmtpLine);
        // If the m= section's MID is in the list of MIDs, then enable dtx. Otherwise disable it.
        var mid = getMidForMediaSection(section);
        if (mids.includes(mid)) {
            opusFmtpAttrs.usedtx = 1;
        }
        else {
            delete opusFmtpAttrs.usedtx;
        }
        var opusFmtpLineWithDtx = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);
        return section.replace(origOpusFmtpRegex, opusFmtpLineWithDtx);
    })).join('\r\n');
}
exports.addOrRewriteNewTrackIds = addOrRewriteNewTrackIds;
exports.addOrRewriteTrackIds = addOrRewriteTrackIds;
exports.createCodecMapForMediaSection = createCodecMapForMediaSection;
exports.createPtToCodecName = createPtToCodecName;
exports.disableRtx = disableRtx;
exports.enableDtxForOpus = enableDtxForOpus;
exports.filterLocalCodecs = filterLocalCodecs;
exports.getMediaSections = getMediaSections;
exports.removeSSRCAttributes = removeSSRCAttributes;
exports.revertSimulcast = revertSimulcast;
exports.setCodecPreferences = setCodecPreferences;
exports.setSimulcast = setSimulcast;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/sdp/issue8329.js":
/*!*************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/sdp/issue8329.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var RTCSessionDescription = __webpack_require__(/*! ../../webrtc */ "./node_modules/twilio-video/es5/webrtc/index.js").RTCSessionDescription;
var _a = __webpack_require__(/*! ./ */ "./node_modules/twilio-video/es5/util/sdp/index.js"), createPtToCodecName = _a.createPtToCodecName, getMediaSections = _a.getMediaSections;
/**
 * An RTX payload type
 * @typedef {PT} RtxPT
 */
/**
 * A non-RTX payload type
 * @typedef {PT} NonRtxPT
 */
/**
 * A Set with at least one element
 * @typedef {Set} NonEmptySet
 */
/**
 * Apply the workaround for Issue 8329 to an RTCSessionDescriptionInit.
 * @param {RTCSessionDescriptionInit} description
 * @returns {RTCSessionDescription} newDescription
 */
function workaround(description) {
    var descriptionInit = { type: description.type };
    if (description.type !== 'rollback') {
        descriptionInit.sdp = sdpWorkaround(description.sdp);
    }
    return new RTCSessionDescription(descriptionInit);
}
/**
 * @param {string} sdp
 * @returns {string} newSdp
 */
function sdpWorkaround(sdp) {
    var mediaSections = getMediaSections(sdp);
    var session = sdp.split('\r\nm=')[0];
    return [session]
        .concat(mediaSections.map(mediaSectionWorkaround))
        .join('\r\n');
}
/**
 * @param {string} mediaSection
 * @returns {string} newMediaSection
 */
function mediaSectionWorkaround(mediaSection) {
    var ptToCodecName = createPtToCodecName(mediaSection);
    mediaSection = deleteDuplicateRtxPts(mediaSection, ptToCodecName);
    var codecNameToPts = createCodecNameToPts(ptToCodecName);
    var rtxPts = codecNameToPts.get('rtx') || new Set();
    var invalidRtxPts = new Set();
    var rtxPtToAssociatedPt = createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts);
    var associatedPtToRtxPt = createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts);
    var unassociatedRtxPts = Array.from(invalidRtxPts);
    // NOTE(mroberts): We normalize to lowercase.
    var knownCodecNames = ['h264', 'vp8', 'vp9'];
    var unassociatedPts = knownCodecNames.reduce(function (unassociatedPts, codecName) {
        var pts = codecNameToPts.get(codecName) || new Set();
        return Array.from(pts).reduce(function (unassociatedPts, pt) { return associatedPtToRtxPt.has(pt)
            ? unassociatedPts
            : unassociatedPts.add(pt); }, unassociatedPts);
    }, new Set());
    unassociatedPts.forEach(function (pt) {
        if (unassociatedRtxPts.length) {
            var rtxPt = unassociatedRtxPts.shift();
            mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);
            mediaSection = addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt);
        }
    });
    unassociatedRtxPts.forEach(function (rtxPt) {
        mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);
        mediaSection = deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt);
    });
    return mediaSection;
}
/**
 * @param {string} mediaSection
 * @param {Map<PT, Codec>} ptToCodecName
 * @returns {string} newMediaSection
 */
function deleteDuplicateRtxPts(mediaSection, ptToCodecName) {
    // NOTE(syerrapragada): In some cases Chrome produces an offer/answer
    // with duplicate "rtx" payload mapping in media section. When applied,
    // Chrome rejects the SDP. We workaround this by deleting duplicate
    // "rtx" mappings found in SDP.
    return Array.from(ptToCodecName.keys()).reduce(function (section, pt) {
        var rtpmapRegex = new RegExp("^a=rtpmap:" + pt + " rtx.+$", 'gm');
        return (section.match(rtpmapRegex) || []).slice(ptToCodecName.get(pt) === 'rtx' ? 1 : 0).reduce(function (section, rtpmap) {
            var rtpmapRegex = new RegExp("\r\n" + rtpmap);
            var fmtpmapRegex = new RegExp("\r\na=fmtp:" + pt + " apt=[0-9]+");
            return section.replace(rtpmapRegex, '').replace(fmtpmapRegex, '');
        }, section);
    }, mediaSection);
}
/**
 * @param {Map<PT, Codec>} ptToCodecName
 * @returns {Map<string, NonEmptySet<PT>>} codecNameToPts
 */
function createCodecNameToPts(ptToCodecName) {
    var codecNameToPts = new Map();
    ptToCodecName.forEach(function (codecName, pt) {
        var pts = codecNameToPts.get(codecName) || new Set();
        return codecNameToPts.set(codecName, pts.add(pt));
    });
    return codecNameToPts;
}
/**
 * @param {string} mediaSection
 * @param {Map<PT, Codec>} ptToCodecName
 * @param {Set<RtxPT>} rtxPts
 * @param {Set<RtxPT>} invalidRtxPts
 * @returns {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt
 */
function createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts) {
    return Array.from(rtxPts).reduce(function (rtxPtToAssociatedPt, rtxPt) {
        var fmtpPattern = new RegExp("a=fmtp:" + rtxPt + " apt=(\\d+)");
        var matches = mediaSection.match(fmtpPattern);
        if (!matches) {
            invalidRtxPts.add(rtxPt);
            return rtxPtToAssociatedPt;
        }
        var pt = Number.parseInt(matches[1]);
        if (!ptToCodecName.has(pt)) {
            // This is Issue 8329.
            invalidRtxPts.add(rtxPt);
            return rtxPtToAssociatedPt;
        }
        var codecName = ptToCodecName.get(pt);
        if (codecName === 'rtx') {
            // Strange
            invalidRtxPts.add(rtxPt);
            return rtxPtToAssociatedPt;
        }
        return rtxPtToAssociatedPt.set(rtxPt, pt);
    }, new Map());
}
/**
 * @param {string} mediaSection
 * @param {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt
 * @param {Set<RtxPT>} invalidRtxPts
 * @returns {Map<NonRtxPT, RtxPT>} associatedPtToRtxPt
 */
function createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts) {
    // First, we construct a Map<NonRtxPT, NonEmptySet<RtxPT>>.
    var associatedPtToRtxPts = Array.from(rtxPtToAssociatedPt).reduce(function (associatedPtToRtxPts, pair) {
        var rtxPt = pair[0];
        var pt = pair[1];
        var rtxPts = associatedPtToRtxPts.get(pt) || new Set();
        return associatedPtToRtxPts.set(pt, rtxPts.add(rtxPt));
    }, new Map());
    // Then, we filter down to a Map<NonRtxPT, RtxPt>. Any RtxPTs that map to the
    // same NonRtxPT are removed and added to invalidRtxPts.
    return Array.from(associatedPtToRtxPts).reduce(function (associatedPtToRtxPt, pair) {
        var pt = pair[0];
        var rtxPts = Array.from(pair[1]);
        if (rtxPts.length > 1) {
            rtxPts.forEach(function (rtxPt) {
                invalidRtxPts.add(rtxPt);
            });
            return associatedPtToRtxPt;
        }
        return associatedPtToRtxPt.set(pt, rtxPts[0]);
    }, new Map());
}
/**
 * @param {string} mediaSection
 * @param {RtxPT} rtxPt
 * @returns {string} newMediaSection
 */
function deleteFmtpAttributesForRtxPt(mediaSection, rtxPt) {
    var pattern = new RegExp("a=fmtp:" + rtxPt + ".*\r\n", 'gm');
    return mediaSection.replace(pattern, '');
}
/**
 * @param {string} mediaSection
 * @param {RtxPT} rtxPt
 * @returns {string} newMediaSection
 */
function deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt) {
    var pattern = new RegExp("a=rtpmap:" + rtxPt + ".*\r\n", 'gm');
    return mediaSection.replace(pattern, '');
}
/**
 * @param {string} mediaSection
 * @param {RtxPT} rtxPt
 * @param {NonRtxPT} pt
 * @returns {string} newMediaSection
 */
function addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt) {
    return mediaSection.endsWith('\r\n')
        ? mediaSection + "a=fmtp:" + rtxPt + " apt=" + pt + "\r\n"
        : mediaSection + "\r\na=fmtp:" + rtxPt + " apt=" + pt;
}
module.exports = workaround;
//# sourceMappingURL=issue8329.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/sdp/simulcast.js":
/*!*************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/sdp/simulcast.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var _a = __webpack_require__(/*! ../ */ "./node_modules/twilio-video/es5/util/index.js"), difference = _a.difference, flatMap = _a.flatMap;
/**
 * Create a random {@link SSRC}.
 * @returns {SSRC}
 */
function createSSRC() {
    var ssrcMax = 0xffffffff;
    return String(Math.floor(Math.random() * ssrcMax));
}
/**
 * @property {string} cName
 * @property {boolean} isSimulcastEnabled
 * @property {Map<RtxSSRC, PrimarySSRC>} rtxPairs
 * @property {Set<PrimarySSRC>} primarySSRCs
 * @property {string} streamId
 * @property {Track.ID} trackId
 */
var TrackAttributes = /** @class */ (function () {
    /**
     * Construct a {@link MediaStreamTrack} attribute store.
     * @param {Track.ID} trackId - The MediaStreamTrack ID
     * @param {MediaStreamID} streamId - The MediaStream ID
     * @param {string} cName - The MediaStream cname
     */
    function TrackAttributes(trackId, streamId, cName) {
        Object.defineProperties(this, {
            cName: {
                enumerable: true,
                value: cName
            },
            isSimulcastEnabled: {
                enumerable: true,
                value: false,
                writable: true
            },
            primarySSRCs: {
                enumerable: true,
                value: new Set()
            },
            rtxPairs: {
                enumerable: true,
                value: new Map()
            },
            streamId: {
                enumerable: true,
                value: streamId
            },
            trackId: {
                enumerable: true,
                value: trackId
            }
        });
    }
    /**
     * Add {@link SimSSRC}s to the {@link TrackAttributes}.
     * @returns {void}
     */
    TrackAttributes.prototype.addSimulcastSSRCs = function () {
        if (this.isSimulcastEnabled) {
            return;
        }
        var simulcastSSRCs = [createSSRC(), createSSRC()];
        simulcastSSRCs.forEach(function (ssrc) {
            this.primarySSRCs.add(ssrc);
        }, this);
        if (this.rtxPairs.size) {
            simulcastSSRCs.forEach(function (ssrc) {
                this.rtxPairs.set(createSSRC(), ssrc);
            }, this);
        }
    };
    /**
     * Add the given {@link PrimarySSRC} or {@link RtxSSRC} to the {@link TrackAttributes}
     * and update the "isSimulcastEnabled" flag if it is also a {@link SimSSRC}.
     * @param {SSRC} ssrc - The {@link SSRC} to be added
     * @param {?PrimarySSRC} primarySSRC - The {@link PrimarySSRC}; if the given
     *   {@link SSRC} itself is the {@link PrimarySSRC}, then this is set to null
     * @param {boolean} isSimSSRC - true if the given {@link SSRC} is a
     *   {@link SimSSRC}; false otherwise
     * @returns {void}
     */
    TrackAttributes.prototype.addSSRC = function (ssrc, primarySSRC, isSimSSRC) {
        if (primarySSRC) {
            this.rtxPairs.set(ssrc, primarySSRC);
        }
        else {
            this.primarySSRCs.add(ssrc);
        }
        this.isSimulcastEnabled = this.isSimulcastEnabled || isSimSSRC;
    };
    /**
     * Construct the SDP lines for the {@link TrackAttributes}.
     * @param {boolean} [excludeRtx=false]
     * @returns {Array<string>} Array of SDP lines
     */
    TrackAttributes.prototype.toSdpLines = function (excludeRtx) {
        var _this = this;
        var rtxPairs = excludeRtx
            ? []
            : Array.from(this.rtxPairs.entries()).map(function (rtxPair) { return rtxPair.reverse(); });
        var simSSRCs = Array.from(this.primarySSRCs.values());
        var ssrcs = rtxPairs.length ? flatMap(rtxPairs) : simSSRCs;
        var attrLines = flatMap(ssrcs, function (ssrc) { return [
            "a=ssrc:" + ssrc + " cname:" + _this.cName,
            "a=ssrc:" + ssrc + " msid:" + _this.streamId + " " + _this.trackId
        ]; });
        var rtxPairLines = rtxPairs.map(function (rtxPair) { return "a=ssrc-group:FID " + rtxPair.join(' '); });
        var simGroupLines = [
            "a=ssrc-group:SIM " + simSSRCs.join(' ')
        ];
        return rtxPairLines.concat(attrLines).concat(simGroupLines);
    };
    return TrackAttributes;
}());
/**
 * Get the matches for a given RegEx pattern.
 * @param {string} section - SDP media section
 * @param {string} pattern - RegEx pattern
 * @returns {Array<Array<string>>} - Array of pattern matches
 */
function getMatches(section, pattern) {
    var matches = section.match(new RegExp(pattern, 'gm')) || [];
    return matches.map(function (match) {
        var matches = match.match(new RegExp(pattern)) || [];
        return matches.slice(1);
    });
}
/**
 * Get the {@link SimSSRC}s that belong to a simulcast group.
 * @param {string} section - SDP media section
 * @returns {Set<SimSSRC>} Set of simulcast {@link SSRC}s
 */
function getSimulcastSSRCs(section) {
    var simGroupPattern = '^a=ssrc-group:SIM ([0-9]+) ([0-9]+) ([0-9]+)$';
    return new Set(flatMap(getMatches(section, simGroupPattern)));
}
/**
 * Get the value of the given attribute for an SSRC.
 * @param {string} section - SDP media section
 * @param {SSRC} ssrc - {@link SSRC} whose attribute's value is to be determinded
 * @param {string} attribute - {@link SSRC} attribute name
 * @param {string} - {@link SSRC} attribute value
 */
function getSSRCAttribute(section, ssrc, attribute) {
    var pattern = "a=ssrc:" + ssrc + " " + attribute + ":(.+)";
    return section.match(new RegExp(pattern))[1];
}
/**
 * Create a Map of {@link PrimarySSRC}s and their {@link RtxSSRC}s.
 * @param {string} section - SDP media section
 * @returns {Map<RtxSSRC, PrimarySSRC>} - Map of {@link RtxSSRC}s and their
 *   corresponding {@link PrimarySSRC}s
 */
function getSSRCRtxPairs(section) {
    var rtxPairPattern = '^a=ssrc-group:FID ([0-9]+) ([0-9]+)$';
    return new Map(getMatches(section, rtxPairPattern).map(function (pair) { return pair.reverse(); }));
}
/**
 * Create SSRC attribute tuples.
 * @param {string} section
 * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}
 */
function createSSRCAttributeTuples(section) {
    var _a = __read(flatMap(getMatches(section, '^a=msid:(.+) (.+)$')), 2), streamId = _a[0], trackId = _a[1];
    var ssrcs = flatMap(getMatches(section, '^a=ssrc:(.+) cname:.+$'));
    return ssrcs.map(function (ssrc) { return [ssrc, streamId, trackId]; });
}
/**
 * Create a Map of MediaStreamTrack IDs and their {@link TrackAttributes}.
 * @param {string} section - SDP media section
 * @returns {Map<Track.ID, TrackAttributes>}
 */
function createTrackIdsToAttributes(section) {
    var simSSRCs = getSimulcastSSRCs(section);
    var rtxPairs = getSSRCRtxPairs(section);
    var ssrcAttrTuples = createSSRCAttributeTuples(section);
    return ssrcAttrTuples.reduce(function (trackIdsToSSRCs, tuple) {
        var ssrc = tuple[0];
        var streamId = tuple[1];
        var trackId = tuple[2];
        var trackAttributes = trackIdsToSSRCs.get(trackId) || new TrackAttributes(trackId, streamId, getSSRCAttribute(section, ssrc, 'cname'));
        var primarySSRC = rtxPairs.get(ssrc) || null;
        trackAttributes.addSSRC(ssrc, primarySSRC, simSSRCs.has(ssrc));
        return trackIdsToSSRCs.set(trackId, trackAttributes);
    }, new Map());
}
/**
 * Apply simulcast settings to the given SDP media section.
 * @param {string} section - SDP media section
 * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes - Existing
 *   map which will be updated for new MediaStreamTrack IDs
 * @returns {string} - The transformed SDP media section
 */
function setSimulcastInMediaSection(section, trackIdsToAttributes) {
    var newTrackIdsToAttributes = createTrackIdsToAttributes(section);
    var newTrackIds = Array.from(newTrackIdsToAttributes.keys());
    var trackIds = Array.from(trackIdsToAttributes.keys());
    var trackIdsToAdd = difference(newTrackIds, trackIds);
    var trackIdsToIgnore = difference(trackIds, newTrackIds);
    // Update "trackIdsToAttributes" with TrackAttributes for new
    // MediaStreamTrack IDs.
    var trackAttributesToAdd = flatMap(trackIdsToAdd, function (trackId) { return newTrackIdsToAttributes.get(trackId); });
    trackAttributesToAdd.forEach(function (trackAttributes) {
        trackAttributes.addSimulcastSSRCs();
        trackIdsToAttributes.set(trackAttributes.trackId, trackAttributes);
    });
    // Get the SDP lines of the relevant MediaStreamTrack IDs from
    // "trackIdsToAttributes".
    trackIds = Array.from(trackIdsToAttributes.keys());
    var relevantTrackIds = difference(trackIds, trackIdsToIgnore);
    var relevantTrackAttributes = flatMap(relevantTrackIds, function (trackId) { return trackIdsToAttributes.get(trackId); });
    var excludeRtx = !section.match(/a=rtpmap:[0-9]+ rtx/);
    var relevantSdpLines = flatMap(relevantTrackAttributes, function (trackAttributes) { return trackAttributes.toSdpLines(excludeRtx); });
    // Add the simulcast SSRC SDP lines to the media section. The Set ensures
    // that the duplicates of the SSRC SDP lines that are in both "section" and
    // "relevantSdpLines" are removed.
    var sectionLines = flatMap(new Set(section.split('\r\n').concat(relevantSdpLines)));
    var xGoogleFlagConference = 'a=x-google-flag:conference';
    if (!section.match(xGoogleFlagConference)) {
        sectionLines.push(xGoogleFlagConference);
    }
    return sectionLines.join('\r\n');
}
/**
 * String representing a MediaStream ID.
 * @typedef {string} MediaStreamID
 */
/**
 * String representing the SSRC of a MediaStreamTrack.
 * @typedef {string} SSRC
 */
/**
 * Primary SSRC.
 * @typedef {SSRC} PrimarySSRC
 */
/**
 * Retransmission SSRC.
 * @typedef {SSRC} RtxSSRC
 */
/**
 * Simulcast SSRC.
 * @typedef {SSRC} SimSSRC
 */
module.exports = setSimulcastInMediaSection;
//# sourceMappingURL=simulcast.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/sdp/trackmatcher.js":
/*!****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/sdp/trackmatcher.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getMediaSections = __webpack_require__(/*! ./ */ "./node_modules/twilio-video/es5/util/sdp/index.js").getMediaSections;
/**
 * An {@link TrackMatcher} matches an RTCTrackEvent with a MediaStreamTrack
 * ID based on the MID of the underlying RTCRtpTransceiver.
 */
var TrackMatcher = /** @class */ (function () {
    /**
     * Construct an {@link TrackMatcher}.
     */
    function TrackMatcher() {
        Object.defineProperties(this, {
            _midsToTrackIds: {
                value: new Map(),
                writable: true
            }
        });
    }
    /**
     * Match a given MediaStreamTrack with its ID.
     * @param {RTCTrackEvent} event
     * @returns {?Track.ID}
     */
    TrackMatcher.prototype.match = function (event) {
        return this._midsToTrackIds.get(event.transceiver.mid) || null;
    };
    /**
     * Update the {@link TrackMatcher} with a new SDP.
     * @param {string} sdp
     */
    TrackMatcher.prototype.update = function (sdp) {
        var sections = getMediaSections(sdp, '(audio|video)');
        this._midsToTrackIds = sections.reduce(function (midsToTrackIds, section) {
            var midMatches = section.match(/^a=mid:(.+)$/m) || [];
            var trackIdMatches = section.match(/^a=msid:.+ (.+)$/m) || [];
            var mid = midMatches[1];
            var trackId = trackIdMatches[1];
            return mid && trackId ? midsToTrackIds.set(mid, trackId) : midsToTrackIds;
        }, this._midsToTrackIds);
    };
    return TrackMatcher;
}());
module.exports = TrackMatcher;
//# sourceMappingURL=trackmatcher.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/sid.js":
/*!***************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/sid.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var SID_CHARS = '1234567890abcdef';
var SID_CHAR_LENGTH = 32;
// copied from: https://code.hq.twilio.com/flex/monkey/blob/0fdce2b6c52d6be0b17a5cdb92f0c54f119b8ea8/src/client/lib/sid.ts#L39
/**
 * Generates a random sid using given prefix.
 * @param {string} prefix
 * @returns string
 */
function createSID(prefix) {
    var result = '';
    for (var i = 0; i < SID_CHAR_LENGTH; i++) {
        result += SID_CHARS.charAt(Math.floor(Math.random() * SID_CHARS.length));
    }
    return "" + prefix + result;
}
exports.sessionSID = createSID('SS');
exports.createSID = createSID;
//# sourceMappingURL=sid.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/support.js":
/*!*******************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/support.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a = __webpack_require__(/*! ../webrtc/util */ "./node_modules/twilio-video/es5/webrtc/util/index.js"), guessBrowser = _a.guessBrowser, isWebRTCSupported = _a.support;
var _b = __webpack_require__(/*! ./browserdetection */ "./node_modules/twilio-video/es5/util/browserdetection.js"), isAndroid = _b.isAndroid, isMobile = _b.isMobile, isNonChromiumEdge = _b.isNonChromiumEdge, rebrandedChromeBrowser = _b.rebrandedChromeBrowser, mobileWebKitBrowser = _b.mobileWebKitBrowser;
var SUPPORTED_CHROME_BASED_BROWSERS = [
    'crios',
    'edg',
    'edge',
    'electron',
    'headlesschrome'
];
var SUPPORTED_ANDROID_BROWSERS = [
    'chrome',
    'firefox'
];
var SUPPORTED_IOS_BROWSERS = [
    'chrome',
    'safari'
];
// Currently none. Add 'brave', 'edg', and 'edge' here once we start supporting them
var SUPPORTED_MOBILE_WEBKIT_BASED_BROWSERS = [];
/**
 * Check if the current browser is officially supported by twilio-video.js.
 * @returns {boolean}
 */
function isSupported() {
    var browser = guessBrowser();
    // NOTE (csantos): Return right away if there is no browser detected
    // to prevent unnecessary checks which could lead to errors
    if (!browser) {
        return false;
    }
    var rebrandedChrome = rebrandedChromeBrowser(browser);
    var mobileWebKit = mobileWebKitBrowser(browser);
    var supportedMobileBrowsers = isAndroid() ?
        SUPPORTED_ANDROID_BROWSERS : SUPPORTED_IOS_BROWSERS;
    return !!browser
        && isWebRTCSupported()
        && (!rebrandedChrome || SUPPORTED_CHROME_BASED_BROWSERS.includes(rebrandedChrome))
        && !isNonChromiumEdge(browser)
        && (!mobileWebKit || SUPPORTED_MOBILE_WEBKIT_BASED_BROWSERS.includes(mobileWebKit))
        && (!isMobile() || supportedMobileBrowsers.includes(browser));
}
module.exports = isSupported;
//# sourceMappingURL=support.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/timeout.js":
/*!*******************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/timeout.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A {@link Timeout} represents a resettable and clearable timeout.
 */
var Timeout = /** @class */ (function () {
    /**
     * Construct a {@link Timeout}.
     * @param {function} fn - Function to call
     * @param {number} delay - Delay in milliseconds
     * @param {boolean} [autoStart=true] - If true, then start the {@link Timeout}.
     */
    function Timeout(fn, delay, autoStart) {
        if (autoStart === void 0) { autoStart = true; }
        Object.defineProperties(this, {
            _delay: {
                value: delay,
                writable: true
            },
            _fn: {
                value: fn
            },
            _timeout: {
                value: null,
                writable: true
            }
        });
        if (autoStart) {
            this.start();
        }
    }
    Object.defineProperty(Timeout.prototype, "delay", {
        /**
         * The {@link Timeout} delay in milliseconds.
         * @property {number}
         */
        get: function () {
            return this._delay;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timeout.prototype, "isSet", {
        /**
         * Whether the {@link Timeout} is set.
         * @property {boolean}
         */
        get: function () {
            return !!this._timeout;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Update the {@link Timeout} delay.
     * @param {number} delay
     * @returns {void}
     */
    Timeout.prototype.setDelay = function (delay) {
        this._delay = delay;
    };
    /**
     * Start the {@link Timeout}, if not already started.
     * @returns {void}
     */
    Timeout.prototype.start = function () {
        var _this = this;
        if (!this.isSet) {
            this._timeout = setTimeout(function () {
                var fn = _this._fn;
                _this.clear();
                fn();
            }, this._delay);
        }
    };
    /**
     * Clear the {@link Timeout}.
     * @returns {void}
     */
    Timeout.prototype.clear = function () {
        clearTimeout(this._timeout);
        this._timeout = null;
    };
    /**
     * Reset the {@link Timeout}.
     * @returns {void}
     */
    Timeout.prototype.reset = function () {
        this.clear();
        this.start();
    };
    return Timeout;
}());
module.exports = Timeout;
//# sourceMappingURL=timeout.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/twilio-video-errors.js":
/*!*******************************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/twilio-video-errors.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// NOTE: Do not edit this file. This code is auto-generated. Contact the
// Twilio SDK Team for more information.

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TwilioError = __webpack_require__(/*! ./twilioerror */ "./node_modules/twilio-video/es5/util/twilioerror.js");
var TwilioErrorByCode = {};
/**
 * Create a {@link TwilioError} for a given code and message.
 * @private
 * @param {number} [code] - Error code
 * @param {string} [message] - Error message
 * @returns {TwilioError}
 */
exports.createTwilioError = function createTwilioError(code, message) {
    code = typeof code === 'number' ? code : 0;
    message = typeof message === 'string' && message ? message : 'Unknown error';
    return TwilioErrorByCode[code] ? new TwilioErrorByCode[code]() : new TwilioError(code, message);
};
/**
 * @class AccessTokenInvalidError
 * @classdesc Raised whenever the AccessToken used for connecting to a Room is invalid.
 * @extends TwilioError
 * @property {number} code - 20101
 * @property {string} message - 'Invalid Access Token'
 */
var AccessTokenInvalidError = /** @class */ (function (_super) {
    __extends(AccessTokenInvalidError, _super);
    function AccessTokenInvalidError() {
        var _this = _super.call(this, 20101, 'Invalid Access Token') || this;
        Object.setPrototypeOf(_this, AccessTokenInvalidError.prototype);
        return _this;
    }
    return AccessTokenInvalidError;
}(TwilioError));
exports.AccessTokenInvalidError = AccessTokenInvalidError;
Object.defineProperty(TwilioErrorByCode, 20101, { value: AccessTokenInvalidError });
/**
 * @class AccessTokenHeaderInvalidError
 * @classdesc Raised whenever the AccessToken used for connecting to a Room has an invalid header.
 * @extends TwilioError
 * @property {number} code - 20102
 * @property {string} message - 'Invalid Access Token header'
 */
var AccessTokenHeaderInvalidError = /** @class */ (function (_super) {
    __extends(AccessTokenHeaderInvalidError, _super);
    function AccessTokenHeaderInvalidError() {
        var _this = _super.call(this, 20102, 'Invalid Access Token header') || this;
        Object.setPrototypeOf(_this, AccessTokenHeaderInvalidError.prototype);
        return _this;
    }
    return AccessTokenHeaderInvalidError;
}(TwilioError));
exports.AccessTokenHeaderInvalidError = AccessTokenHeaderInvalidError;
Object.defineProperty(TwilioErrorByCode, 20102, { value: AccessTokenHeaderInvalidError });
/**
 * @class AccessTokenIssuerInvalidError
 * @classdesc Raised whenever the AccessToken used for connecting to a Room contains an invalid issuer or subject.
 * @extends TwilioError
 * @property {number} code - 20103
 * @property {string} message - 'Invalid Access Token issuer/subject'
 */
var AccessTokenIssuerInvalidError = /** @class */ (function (_super) {
    __extends(AccessTokenIssuerInvalidError, _super);
    function AccessTokenIssuerInvalidError() {
        var _this = _super.call(this, 20103, 'Invalid Access Token issuer/subject') || this;
        Object.setPrototypeOf(_this, AccessTokenIssuerInvalidError.prototype);
        return _this;
    }
    return AccessTokenIssuerInvalidError;
}(TwilioError));
exports.AccessTokenIssuerInvalidError = AccessTokenIssuerInvalidError;
Object.defineProperty(TwilioErrorByCode, 20103, { value: AccessTokenIssuerInvalidError });
/**
 * @class AccessTokenExpiredError
 * @classdesc Raised whenever the AccessToken used for connecting, or reconnecting to a Room has expired.
 * @extends TwilioError
 * @property {number} code - 20104
 * @property {string} message - 'Access Token expired or expiration date invalid'
 */
var AccessTokenExpiredError = /** @class */ (function (_super) {
    __extends(AccessTokenExpiredError, _super);
    function AccessTokenExpiredError() {
        var _this = _super.call(this, 20104, 'Access Token expired or expiration date invalid') || this;
        Object.setPrototypeOf(_this, AccessTokenExpiredError.prototype);
        return _this;
    }
    return AccessTokenExpiredError;
}(TwilioError));
exports.AccessTokenExpiredError = AccessTokenExpiredError;
Object.defineProperty(TwilioErrorByCode, 20104, { value: AccessTokenExpiredError });
/**
 * @class AccessTokenNotYetValidError
 * @classdesc Raised whenever the AccessToken used for connecting to a Room is not yet valid.
 * @extends TwilioError
 * @property {number} code - 20105
 * @property {string} message - 'Access Token not yet valid'
 */
var AccessTokenNotYetValidError = /** @class */ (function (_super) {
    __extends(AccessTokenNotYetValidError, _super);
    function AccessTokenNotYetValidError() {
        var _this = _super.call(this, 20105, 'Access Token not yet valid') || this;
        Object.setPrototypeOf(_this, AccessTokenNotYetValidError.prototype);
        return _this;
    }
    return AccessTokenNotYetValidError;
}(TwilioError));
exports.AccessTokenNotYetValidError = AccessTokenNotYetValidError;
Object.defineProperty(TwilioErrorByCode, 20105, { value: AccessTokenNotYetValidError });
/**
 * @class AccessTokenGrantsInvalidError
 * @classdesc Raised whenever the AccessToken used for connecting to a Room has invalid grants.
 * @extends TwilioError
 * @property {number} code - 20106
 * @property {string} message - 'Invalid Access Token grants'
 */
var AccessTokenGrantsInvalidError = /** @class */ (function (_super) {
    __extends(AccessTokenGrantsInvalidError, _super);
    function AccessTokenGrantsInvalidError() {
        var _this = _super.call(this, 20106, 'Invalid Access Token grants') || this;
        Object.setPrototypeOf(_this, AccessTokenGrantsInvalidError.prototype);
        return _this;
    }
    return AccessTokenGrantsInvalidError;
}(TwilioError));
exports.AccessTokenGrantsInvalidError = AccessTokenGrantsInvalidError;
Object.defineProperty(TwilioErrorByCode, 20106, { value: AccessTokenGrantsInvalidError });
/**
 * @class AccessTokenSignatureInvalidError
 * @classdesc Raised whenever the AccessToken used for connecting to a Room has an invalid signature.
 * @extends TwilioError
 * @property {number} code - 20107
 * @property {string} message - 'Invalid Access Token signature'
 */
var AccessTokenSignatureInvalidError = /** @class */ (function (_super) {
    __extends(AccessTokenSignatureInvalidError, _super);
    function AccessTokenSignatureInvalidError() {
        var _this = _super.call(this, 20107, 'Invalid Access Token signature') || this;
        Object.setPrototypeOf(_this, AccessTokenSignatureInvalidError.prototype);
        return _this;
    }
    return AccessTokenSignatureInvalidError;
}(TwilioError));
exports.AccessTokenSignatureInvalidError = AccessTokenSignatureInvalidError;
Object.defineProperty(TwilioErrorByCode, 20107, { value: AccessTokenSignatureInvalidError });
/**
 * @class SignalingConnectionError
 * @classdesc Raised whenever a signaling connection error occurs that is not covered by a more specific error code.
 * @extends TwilioError
 * @property {number} code - 53000
 * @property {string} message - 'Signaling connection error'
 */
var SignalingConnectionError = /** @class */ (function (_super) {
    __extends(SignalingConnectionError, _super);
    function SignalingConnectionError() {
        var _this = _super.call(this, 53000, 'Signaling connection error') || this;
        Object.setPrototypeOf(_this, SignalingConnectionError.prototype);
        return _this;
    }
    return SignalingConnectionError;
}(TwilioError));
exports.SignalingConnectionError = SignalingConnectionError;
Object.defineProperty(TwilioErrorByCode, 53000, { value: SignalingConnectionError });
/**
 * @class SignalingConnectionDisconnectedError
 * @classdesc Raised whenever the signaling connection is unexpectedly disconnected.
 * @extends TwilioError
 * @property {number} code - 53001
 * @property {string} message - 'Signaling connection disconnected'
 */
var SignalingConnectionDisconnectedError = /** @class */ (function (_super) {
    __extends(SignalingConnectionDisconnectedError, _super);
    function SignalingConnectionDisconnectedError() {
        var _this = _super.call(this, 53001, 'Signaling connection disconnected') || this;
        Object.setPrototypeOf(_this, SignalingConnectionDisconnectedError.prototype);
        return _this;
    }
    return SignalingConnectionDisconnectedError;
}(TwilioError));
exports.SignalingConnectionDisconnectedError = SignalingConnectionDisconnectedError;
Object.defineProperty(TwilioErrorByCode, 53001, { value: SignalingConnectionDisconnectedError });
/**
 * @class SignalingConnectionTimeoutError
 * @classdesc Raised when connection liveliness checks fail, or when the signaling session expires.
 * @extends TwilioError
 * @property {number} code - 53002
 * @property {string} message - 'Signaling connection timed out'
 */
var SignalingConnectionTimeoutError = /** @class */ (function (_super) {
    __extends(SignalingConnectionTimeoutError, _super);
    function SignalingConnectionTimeoutError() {
        var _this = _super.call(this, 53002, 'Signaling connection timed out') || this;
        Object.setPrototypeOf(_this, SignalingConnectionTimeoutError.prototype);
        return _this;
    }
    return SignalingConnectionTimeoutError;
}(TwilioError));
exports.SignalingConnectionTimeoutError = SignalingConnectionTimeoutError;
Object.defineProperty(TwilioErrorByCode, 53002, { value: SignalingConnectionTimeoutError });
/**
 * @class SignalingIncomingMessageInvalidError
 * @classdesc Raised whenever the Client receives a message from the Server that the Client cannot handle.
 * @extends TwilioError
 * @property {number} code - 53003
 * @property {string} message - 'Client received an invalid signaling message'
 */
var SignalingIncomingMessageInvalidError = /** @class */ (function (_super) {
    __extends(SignalingIncomingMessageInvalidError, _super);
    function SignalingIncomingMessageInvalidError() {
        var _this = _super.call(this, 53003, 'Client received an invalid signaling message') || this;
        Object.setPrototypeOf(_this, SignalingIncomingMessageInvalidError.prototype);
        return _this;
    }
    return SignalingIncomingMessageInvalidError;
}(TwilioError));
exports.SignalingIncomingMessageInvalidError = SignalingIncomingMessageInvalidError;
Object.defineProperty(TwilioErrorByCode, 53003, { value: SignalingIncomingMessageInvalidError });
/**
 * @class SignalingOutgoingMessageInvalidError
 * @classdesc Raised whenever the Client sends a message to the Server that the Server cannot handle.
 * @extends TwilioError
 * @property {number} code - 53004
 * @property {string} message - 'Client sent an invalid signaling message'
 */
var SignalingOutgoingMessageInvalidError = /** @class */ (function (_super) {
    __extends(SignalingOutgoingMessageInvalidError, _super);
    function SignalingOutgoingMessageInvalidError() {
        var _this = _super.call(this, 53004, 'Client sent an invalid signaling message') || this;
        Object.setPrototypeOf(_this, SignalingOutgoingMessageInvalidError.prototype);
        return _this;
    }
    return SignalingOutgoingMessageInvalidError;
}(TwilioError));
exports.SignalingOutgoingMessageInvalidError = SignalingOutgoingMessageInvalidError;
Object.defineProperty(TwilioErrorByCode, 53004, { value: SignalingOutgoingMessageInvalidError });
/**
 * @class SignalingServerBusyError
 * @classdesc Raised when the server is too busy to accept new clients.
 * @extends TwilioError
 * @property {number} code - 53006
 * @property {string} message - 'Video server is busy'
 */
var SignalingServerBusyError = /** @class */ (function (_super) {
    __extends(SignalingServerBusyError, _super);
    function SignalingServerBusyError() {
        var _this = _super.call(this, 53006, 'Video server is busy') || this;
        Object.setPrototypeOf(_this, SignalingServerBusyError.prototype);
        return _this;
    }
    return SignalingServerBusyError;
}(TwilioError));
exports.SignalingServerBusyError = SignalingServerBusyError;
Object.defineProperty(TwilioErrorByCode, 53006, { value: SignalingServerBusyError });
/**
 * @class RoomNameInvalidError
 * @classdesc Raised whenever a Room name is invalid, and the scenario is not covered by a more specific error code.
 * @extends TwilioError
 * @property {number} code - 53100
 * @property {string} message - 'Room name is invalid'
 */
var RoomNameInvalidError = /** @class */ (function (_super) {
    __extends(RoomNameInvalidError, _super);
    function RoomNameInvalidError() {
        var _this = _super.call(this, 53100, 'Room name is invalid') || this;
        Object.setPrototypeOf(_this, RoomNameInvalidError.prototype);
        return _this;
    }
    return RoomNameInvalidError;
}(TwilioError));
exports.RoomNameInvalidError = RoomNameInvalidError;
Object.defineProperty(TwilioErrorByCode, 53100, { value: RoomNameInvalidError });
/**
 * @class RoomNameTooLongError
 * @classdesc Raised whenever a Room name is too long.
 * @extends TwilioError
 * @property {number} code - 53101
 * @property {string} message - 'Room name is too long'
 */
var RoomNameTooLongError = /** @class */ (function (_super) {
    __extends(RoomNameTooLongError, _super);
    function RoomNameTooLongError() {
        var _this = _super.call(this, 53101, 'Room name is too long') || this;
        Object.setPrototypeOf(_this, RoomNameTooLongError.prototype);
        return _this;
    }
    return RoomNameTooLongError;
}(TwilioError));
exports.RoomNameTooLongError = RoomNameTooLongError;
Object.defineProperty(TwilioErrorByCode, 53101, { value: RoomNameTooLongError });
/**
 * @class RoomNameCharsInvalidError
 * @classdesc Raised whenever a Room name contains invalid characters.
 * @extends TwilioError
 * @property {number} code - 53102
 * @property {string} message - 'Room name contains invalid characters'
 */
var RoomNameCharsInvalidError = /** @class */ (function (_super) {
    __extends(RoomNameCharsInvalidError, _super);
    function RoomNameCharsInvalidError() {
        var _this = _super.call(this, 53102, 'Room name contains invalid characters') || this;
        Object.setPrototypeOf(_this, RoomNameCharsInvalidError.prototype);
        return _this;
    }
    return RoomNameCharsInvalidError;
}(TwilioError));
exports.RoomNameCharsInvalidError = RoomNameCharsInvalidError;
Object.defineProperty(TwilioErrorByCode, 53102, { value: RoomNameCharsInvalidError });
/**
 * @class RoomCreateFailedError
 * @classdesc Raised whenever the Server is unable to create a Room.
 * @extends TwilioError
 * @property {number} code - 53103
 * @property {string} message - 'Unable to create Room'
 */
var RoomCreateFailedError = /** @class */ (function (_super) {
    __extends(RoomCreateFailedError, _super);
    function RoomCreateFailedError() {
        var _this = _super.call(this, 53103, 'Unable to create Room') || this;
        Object.setPrototypeOf(_this, RoomCreateFailedError.prototype);
        return _this;
    }
    return RoomCreateFailedError;
}(TwilioError));
exports.RoomCreateFailedError = RoomCreateFailedError;
Object.defineProperty(TwilioErrorByCode, 53103, { value: RoomCreateFailedError });
/**
 * @class RoomConnectFailedError
 * @classdesc Raised whenever a Client is unable to connect to a Room, and the scenario is not covered by a more specific error code.
 * @extends TwilioError
 * @property {number} code - 53104
 * @property {string} message - 'Unable to connect to Room'
 */
var RoomConnectFailedError = /** @class */ (function (_super) {
    __extends(RoomConnectFailedError, _super);
    function RoomConnectFailedError() {
        var _this = _super.call(this, 53104, 'Unable to connect to Room') || this;
        Object.setPrototypeOf(_this, RoomConnectFailedError.prototype);
        return _this;
    }
    return RoomConnectFailedError;
}(TwilioError));
exports.RoomConnectFailedError = RoomConnectFailedError;
Object.defineProperty(TwilioErrorByCode, 53104, { value: RoomConnectFailedError });
/**
 * @class RoomMaxParticipantsExceededError
 * @classdesc Raised whenever a Client is unable to connect to a Room because the Room contains too many Participants.
 * @extends TwilioError
 * @property {number} code - 53105
 * @property {string} message - 'Room contains too many Participants'
 */
var RoomMaxParticipantsExceededError = /** @class */ (function (_super) {
    __extends(RoomMaxParticipantsExceededError, _super);
    function RoomMaxParticipantsExceededError() {
        var _this = _super.call(this, 53105, 'Room contains too many Participants') || this;
        Object.setPrototypeOf(_this, RoomMaxParticipantsExceededError.prototype);
        return _this;
    }
    return RoomMaxParticipantsExceededError;
}(TwilioError));
exports.RoomMaxParticipantsExceededError = RoomMaxParticipantsExceededError;
Object.defineProperty(TwilioErrorByCode, 53105, { value: RoomMaxParticipantsExceededError });
/**
 * @class RoomNotFoundError
 * @classdesc Raised whenever attempting operation on a non-existent Room.
 * @extends TwilioError
 * @property {number} code - 53106
 * @property {string} message - 'Room not found'
 */
var RoomNotFoundError = /** @class */ (function (_super) {
    __extends(RoomNotFoundError, _super);
    function RoomNotFoundError() {
        var _this = _super.call(this, 53106, 'Room not found') || this;
        Object.setPrototypeOf(_this, RoomNotFoundError.prototype);
        return _this;
    }
    return RoomNotFoundError;
}(TwilioError));
exports.RoomNotFoundError = RoomNotFoundError;
Object.defineProperty(TwilioErrorByCode, 53106, { value: RoomNotFoundError });
/**
 * @class RoomMaxParticipantsOutOfRangeError
 * @classdesc Raised in the REST API when MaxParticipants is set out of range.
 * @extends TwilioError
 * @property {number} code - 53107
 * @property {string} message - 'MaxParticipants is out of range'
 */
var RoomMaxParticipantsOutOfRangeError = /** @class */ (function (_super) {
    __extends(RoomMaxParticipantsOutOfRangeError, _super);
    function RoomMaxParticipantsOutOfRangeError() {
        var _this = _super.call(this, 53107, 'MaxParticipants is out of range') || this;
        Object.setPrototypeOf(_this, RoomMaxParticipantsOutOfRangeError.prototype);
        return _this;
    }
    return RoomMaxParticipantsOutOfRangeError;
}(TwilioError));
exports.RoomMaxParticipantsOutOfRangeError = RoomMaxParticipantsOutOfRangeError;
Object.defineProperty(TwilioErrorByCode, 53107, { value: RoomMaxParticipantsOutOfRangeError });
/**
 * @class RoomTypeInvalidError
 * @classdesc Raised in the REST API when the user attempts to create a Room with an invalid RoomType
 * @extends TwilioError
 * @property {number} code - 53108
 * @property {string} message - 'RoomType is not valid'
 */
var RoomTypeInvalidError = /** @class */ (function (_super) {
    __extends(RoomTypeInvalidError, _super);
    function RoomTypeInvalidError() {
        var _this = _super.call(this, 53108, 'RoomType is not valid') || this;
        Object.setPrototypeOf(_this, RoomTypeInvalidError.prototype);
        return _this;
    }
    return RoomTypeInvalidError;
}(TwilioError));
exports.RoomTypeInvalidError = RoomTypeInvalidError;
Object.defineProperty(TwilioErrorByCode, 53108, { value: RoomTypeInvalidError });
/**
 * @class RoomTimeoutOutOfRangeError
 * @classdesc Raised in the REST API when Timeout is set out of range.
 * @extends TwilioError
 * @property {number} code - 53109
 * @property {string} message - 'Timeout is out of range'
 */
var RoomTimeoutOutOfRangeError = /** @class */ (function (_super) {
    __extends(RoomTimeoutOutOfRangeError, _super);
    function RoomTimeoutOutOfRangeError() {
        var _this = _super.call(this, 53109, 'Timeout is out of range') || this;
        Object.setPrototypeOf(_this, RoomTimeoutOutOfRangeError.prototype);
        return _this;
    }
    return RoomTimeoutOutOfRangeError;
}(TwilioError));
exports.RoomTimeoutOutOfRangeError = RoomTimeoutOutOfRangeError;
Object.defineProperty(TwilioErrorByCode, 53109, { value: RoomTimeoutOutOfRangeError });
/**
 * @class RoomStatusCallbackMethodInvalidError
 * @classdesc Raised in the REST API when StatusCallbackMethod is set to an invalid value.
 * @extends TwilioError
 * @property {number} code - 53110
 * @property {string} message - 'StatusCallbackMethod is invalid'
 */
var RoomStatusCallbackMethodInvalidError = /** @class */ (function (_super) {
    __extends(RoomStatusCallbackMethodInvalidError, _super);
    function RoomStatusCallbackMethodInvalidError() {
        var _this = _super.call(this, 53110, 'StatusCallbackMethod is invalid') || this;
        Object.setPrototypeOf(_this, RoomStatusCallbackMethodInvalidError.prototype);
        return _this;
    }
    return RoomStatusCallbackMethodInvalidError;
}(TwilioError));
exports.RoomStatusCallbackMethodInvalidError = RoomStatusCallbackMethodInvalidError;
Object.defineProperty(TwilioErrorByCode, 53110, { value: RoomStatusCallbackMethodInvalidError });
/**
 * @class RoomStatusCallbackInvalidError
 * @classdesc Raised in the REST API when StatusCallback is not a valid URL or the url is too long.
 * @extends TwilioError
 * @property {number} code - 53111
 * @property {string} message - 'StatusCallback is invalid'
 */
var RoomStatusCallbackInvalidError = /** @class */ (function (_super) {
    __extends(RoomStatusCallbackInvalidError, _super);
    function RoomStatusCallbackInvalidError() {
        var _this = _super.call(this, 53111, 'StatusCallback is invalid') || this;
        Object.setPrototypeOf(_this, RoomStatusCallbackInvalidError.prototype);
        return _this;
    }
    return RoomStatusCallbackInvalidError;
}(TwilioError));
exports.RoomStatusCallbackInvalidError = RoomStatusCallbackInvalidError;
Object.defineProperty(TwilioErrorByCode, 53111, { value: RoomStatusCallbackInvalidError });
/**
 * @class RoomStatusInvalidError
 * @classdesc Raised in the REST API when Status is not valid or the Room is not in-progress.
 * @extends TwilioError
 * @property {number} code - 53112
 * @property {string} message - 'Status is invalid'
 */
var RoomStatusInvalidError = /** @class */ (function (_super) {
    __extends(RoomStatusInvalidError, _super);
    function RoomStatusInvalidError() {
        var _this = _super.call(this, 53112, 'Status is invalid') || this;
        Object.setPrototypeOf(_this, RoomStatusInvalidError.prototype);
        return _this;
    }
    return RoomStatusInvalidError;
}(TwilioError));
exports.RoomStatusInvalidError = RoomStatusInvalidError;
Object.defineProperty(TwilioErrorByCode, 53112, { value: RoomStatusInvalidError });
/**
 * @class RoomRoomExistsError
 * @classdesc Raised in the REST API when the Room creation fails because a Room exists with the same name.
 * @extends TwilioError
 * @property {number} code - 53113
 * @property {string} message - 'Room exists'
 */
var RoomRoomExistsError = /** @class */ (function (_super) {
    __extends(RoomRoomExistsError, _super);
    function RoomRoomExistsError() {
        var _this = _super.call(this, 53113, 'Room exists') || this;
        Object.setPrototypeOf(_this, RoomRoomExistsError.prototype);
        return _this;
    }
    return RoomRoomExistsError;
}(TwilioError));
exports.RoomRoomExistsError = RoomRoomExistsError;
Object.defineProperty(TwilioErrorByCode, 53113, { value: RoomRoomExistsError });
/**
 * @class RoomInvalidParametersError
 * @classdesc Raised in the REST API when one or more Room creation parameter is incompatible with the Room type.
 * @extends TwilioError
 * @property {number} code - 53114
 * @property {string} message - 'Room creation parameter(s) incompatible with the Room type'
 */
var RoomInvalidParametersError = /** @class */ (function (_super) {
    __extends(RoomInvalidParametersError, _super);
    function RoomInvalidParametersError() {
        var _this = _super.call(this, 53114, 'Room creation parameter(s) incompatible with the Room type') || this;
        Object.setPrototypeOf(_this, RoomInvalidParametersError.prototype);
        return _this;
    }
    return RoomInvalidParametersError;
}(TwilioError));
exports.RoomInvalidParametersError = RoomInvalidParametersError;
Object.defineProperty(TwilioErrorByCode, 53114, { value: RoomInvalidParametersError });
/**
 * @class RoomMediaRegionInvalidError
 * @classdesc Raised in the REST API when MediaRegion is set to an invalid value.
 * @extends TwilioError
 * @property {number} code - 53115
 * @property {string} message - 'MediaRegion is invalid'
 */
var RoomMediaRegionInvalidError = /** @class */ (function (_super) {
    __extends(RoomMediaRegionInvalidError, _super);
    function RoomMediaRegionInvalidError() {
        var _this = _super.call(this, 53115, 'MediaRegion is invalid') || this;
        Object.setPrototypeOf(_this, RoomMediaRegionInvalidError.prototype);
        return _this;
    }
    return RoomMediaRegionInvalidError;
}(TwilioError));
exports.RoomMediaRegionInvalidError = RoomMediaRegionInvalidError;
Object.defineProperty(TwilioErrorByCode, 53115, { value: RoomMediaRegionInvalidError });
/**
 * @class RoomMediaRegionUnavailableError
 * @classdesc Raised in the REST API when MediaRegion is set to a valid value but no media servers are available.
 * @extends TwilioError
 * @property {number} code - 53116
 * @property {string} message - 'There are no media servers available in the MediaRegion'
 */
var RoomMediaRegionUnavailableError = /** @class */ (function (_super) {
    __extends(RoomMediaRegionUnavailableError, _super);
    function RoomMediaRegionUnavailableError() {
        var _this = _super.call(this, 53116, 'There are no media servers available in the MediaRegion') || this;
        Object.setPrototypeOf(_this, RoomMediaRegionUnavailableError.prototype);
        return _this;
    }
    return RoomMediaRegionUnavailableError;
}(TwilioError));
exports.RoomMediaRegionUnavailableError = RoomMediaRegionUnavailableError;
Object.defineProperty(TwilioErrorByCode, 53116, { value: RoomMediaRegionUnavailableError });
/**
 * @class RoomSubscriptionOperationNotSupportedError
 * @classdesc Raised whenever the subscription operation requested is not supported for the Room type.
 * @extends TwilioError
 * @property {number} code - 53117
 * @property {string} message - 'The subscription operation requested is not supported for the Room type'
 */
var RoomSubscriptionOperationNotSupportedError = /** @class */ (function (_super) {
    __extends(RoomSubscriptionOperationNotSupportedError, _super);
    function RoomSubscriptionOperationNotSupportedError() {
        var _this = _super.call(this, 53117, 'The subscription operation requested is not supported for the Room type') || this;
        Object.setPrototypeOf(_this, RoomSubscriptionOperationNotSupportedError.prototype);
        return _this;
    }
    return RoomSubscriptionOperationNotSupportedError;
}(TwilioError));
exports.RoomSubscriptionOperationNotSupportedError = RoomSubscriptionOperationNotSupportedError;
Object.defineProperty(TwilioErrorByCode, 53117, { value: RoomSubscriptionOperationNotSupportedError });
/**
 * @class RoomCompletedError
 * @classdesc Raised whenever a Room is completed via the REST API.
 * @extends TwilioError
 * @property {number} code - 53118
 * @property {string} message - 'Room completed'
 */
var RoomCompletedError = /** @class */ (function (_super) {
    __extends(RoomCompletedError, _super);
    function RoomCompletedError() {
        var _this = _super.call(this, 53118, 'Room completed') || this;
        Object.setPrototypeOf(_this, RoomCompletedError.prototype);
        return _this;
    }
    return RoomCompletedError;
}(TwilioError));
exports.RoomCompletedError = RoomCompletedError;
Object.defineProperty(TwilioErrorByCode, 53118, { value: RoomCompletedError });
/**
 * @class RoomAudioOnlyFlagNotSupportedError
 * @classdesc Raised whenever a participant tries to set the AudioOnly flag for a Room type other than Group Rooms.
 * @extends TwilioError
 * @property {number} code - 53124
 * @property {string} message - 'The AudioOnly flag is not supported for the Room type'
 */
var RoomAudioOnlyFlagNotSupportedError = /** @class */ (function (_super) {
    __extends(RoomAudioOnlyFlagNotSupportedError, _super);
    function RoomAudioOnlyFlagNotSupportedError() {
        var _this = _super.call(this, 53124, 'The AudioOnly flag is not supported for the Room type') || this;
        Object.setPrototypeOf(_this, RoomAudioOnlyFlagNotSupportedError.prototype);
        return _this;
    }
    return RoomAudioOnlyFlagNotSupportedError;
}(TwilioError));
exports.RoomAudioOnlyFlagNotSupportedError = RoomAudioOnlyFlagNotSupportedError;
Object.defineProperty(TwilioErrorByCode, 53124, { value: RoomAudioOnlyFlagNotSupportedError });
/**
 * @class RoomTrackKindNotSupportedError
 * @classdesc Raised whenever a participant tries to publish a track or connects with a track that is not supported by the group room.
 * @extends TwilioError
 * @property {number} code - 53125
 * @property {string} message - 'The track kind is not supported by the Room'
 */
var RoomTrackKindNotSupportedError = /** @class */ (function (_super) {
    __extends(RoomTrackKindNotSupportedError, _super);
    function RoomTrackKindNotSupportedError() {
        var _this = _super.call(this, 53125, 'The track kind is not supported by the Room') || this;
        Object.setPrototypeOf(_this, RoomTrackKindNotSupportedError.prototype);
        return _this;
    }
    return RoomTrackKindNotSupportedError;
}(TwilioError));
exports.RoomTrackKindNotSupportedError = RoomTrackKindNotSupportedError;
Object.defineProperty(TwilioErrorByCode, 53125, { value: RoomTrackKindNotSupportedError });
/**
 * @class ParticipantIdentityInvalidError
 * @classdesc Raised whenever a Participant identity is invalid, and the scenario is not covered by a more specific error code.
 * @extends TwilioError
 * @property {number} code - 53200
 * @property {string} message - 'Participant identity is invalid'
 */
var ParticipantIdentityInvalidError = /** @class */ (function (_super) {
    __extends(ParticipantIdentityInvalidError, _super);
    function ParticipantIdentityInvalidError() {
        var _this = _super.call(this, 53200, 'Participant identity is invalid') || this;
        Object.setPrototypeOf(_this, ParticipantIdentityInvalidError.prototype);
        return _this;
    }
    return ParticipantIdentityInvalidError;
}(TwilioError));
exports.ParticipantIdentityInvalidError = ParticipantIdentityInvalidError;
Object.defineProperty(TwilioErrorByCode, 53200, { value: ParticipantIdentityInvalidError });
/**
 * @class ParticipantIdentityTooLongError
 * @classdesc Raised whenever a Participant identity is too long.
 * @extends TwilioError
 * @property {number} code - 53201
 * @property {string} message - 'Participant identity is too long'
 */
var ParticipantIdentityTooLongError = /** @class */ (function (_super) {
    __extends(ParticipantIdentityTooLongError, _super);
    function ParticipantIdentityTooLongError() {
        var _this = _super.call(this, 53201, 'Participant identity is too long') || this;
        Object.setPrototypeOf(_this, ParticipantIdentityTooLongError.prototype);
        return _this;
    }
    return ParticipantIdentityTooLongError;
}(TwilioError));
exports.ParticipantIdentityTooLongError = ParticipantIdentityTooLongError;
Object.defineProperty(TwilioErrorByCode, 53201, { value: ParticipantIdentityTooLongError });
/**
 * @class ParticipantIdentityCharsInvalidError
 * @classdesc Raised whenever a Participant identity contains invalid characters.
 * @extends TwilioError
 * @property {number} code - 53202
 * @property {string} message - 'Participant identity contains invalid characters'
 */
var ParticipantIdentityCharsInvalidError = /** @class */ (function (_super) {
    __extends(ParticipantIdentityCharsInvalidError, _super);
    function ParticipantIdentityCharsInvalidError() {
        var _this = _super.call(this, 53202, 'Participant identity contains invalid characters') || this;
        Object.setPrototypeOf(_this, ParticipantIdentityCharsInvalidError.prototype);
        return _this;
    }
    return ParticipantIdentityCharsInvalidError;
}(TwilioError));
exports.ParticipantIdentityCharsInvalidError = ParticipantIdentityCharsInvalidError;
Object.defineProperty(TwilioErrorByCode, 53202, { value: ParticipantIdentityCharsInvalidError });
/**
 * @class ParticipantMaxTracksExceededError
 * @classdesc Raised whenever a Participant tries to publish a Track and the maximum number of published tracks allowed in the Room at the same time has been reached
 * @extends TwilioError
 * @property {number} code - 53203
 * @property {string} message - 'The maximum number of published tracks allowed in the Room at the same time has been reached'
 */
var ParticipantMaxTracksExceededError = /** @class */ (function (_super) {
    __extends(ParticipantMaxTracksExceededError, _super);
    function ParticipantMaxTracksExceededError() {
        var _this = _super.call(this, 53203, 'The maximum number of published tracks allowed in the Room at the same time has been reached') || this;
        Object.setPrototypeOf(_this, ParticipantMaxTracksExceededError.prototype);
        return _this;
    }
    return ParticipantMaxTracksExceededError;
}(TwilioError));
exports.ParticipantMaxTracksExceededError = ParticipantMaxTracksExceededError;
Object.defineProperty(TwilioErrorByCode, 53203, { value: ParticipantMaxTracksExceededError });
/**
 * @class ParticipantNotFoundError
 * @classdesc Raised whenever attempting an operation on a non-existent Participant.
 * @extends TwilioError
 * @property {number} code - 53204
 * @property {string} message - 'Participant not found'
 */
var ParticipantNotFoundError = /** @class */ (function (_super) {
    __extends(ParticipantNotFoundError, _super);
    function ParticipantNotFoundError() {
        var _this = _super.call(this, 53204, 'Participant not found') || this;
        Object.setPrototypeOf(_this, ParticipantNotFoundError.prototype);
        return _this;
    }
    return ParticipantNotFoundError;
}(TwilioError));
exports.ParticipantNotFoundError = ParticipantNotFoundError;
Object.defineProperty(TwilioErrorByCode, 53204, { value: ParticipantNotFoundError });
/**
 * @class ParticipantDuplicateIdentityError
 * @classdesc Raised by the server to the existing Participant when a new Participant joins a Room with the same identity as the existing Participant.
 * @extends TwilioError
 * @property {number} code - 53205
 * @property {string} message - 'Participant disconnected because of duplicate identity'
 */
var ParticipantDuplicateIdentityError = /** @class */ (function (_super) {
    __extends(ParticipantDuplicateIdentityError, _super);
    function ParticipantDuplicateIdentityError() {
        var _this = _super.call(this, 53205, 'Participant disconnected because of duplicate identity') || this;
        Object.setPrototypeOf(_this, ParticipantDuplicateIdentityError.prototype);
        return _this;
    }
    return ParticipantDuplicateIdentityError;
}(TwilioError));
exports.ParticipantDuplicateIdentityError = ParticipantDuplicateIdentityError;
Object.defineProperty(TwilioErrorByCode, 53205, { value: ParticipantDuplicateIdentityError });
/**
 * @class TrackInvalidError
 * @classdesc Raised whenever a Track is invalid, and the scenario is not covered by a more specific error code.
 * @extends TwilioError
 * @property {number} code - 53300
 * @property {string} message - 'Track is invalid'
 */
var TrackInvalidError = /** @class */ (function (_super) {
    __extends(TrackInvalidError, _super);
    function TrackInvalidError() {
        var _this = _super.call(this, 53300, 'Track is invalid') || this;
        Object.setPrototypeOf(_this, TrackInvalidError.prototype);
        return _this;
    }
    return TrackInvalidError;
}(TwilioError));
exports.TrackInvalidError = TrackInvalidError;
Object.defineProperty(TwilioErrorByCode, 53300, { value: TrackInvalidError });
/**
 * @class TrackNameInvalidError
 * @classdesc Raised whenever a Track name is invalid, and the scenario is not covered by a more specific error code.
 * @extends TwilioError
 * @property {number} code - 53301
 * @property {string} message - 'Track name is invalid'
 */
var TrackNameInvalidError = /** @class */ (function (_super) {
    __extends(TrackNameInvalidError, _super);
    function TrackNameInvalidError() {
        var _this = _super.call(this, 53301, 'Track name is invalid') || this;
        Object.setPrototypeOf(_this, TrackNameInvalidError.prototype);
        return _this;
    }
    return TrackNameInvalidError;
}(TwilioError));
exports.TrackNameInvalidError = TrackNameInvalidError;
Object.defineProperty(TwilioErrorByCode, 53301, { value: TrackNameInvalidError });
/**
 * @class TrackNameTooLongError
 * @classdesc Raised whenever a Track name is too long.
 * @extends TwilioError
 * @property {number} code - 53302
 * @property {string} message - 'Track name is too long'
 */
var TrackNameTooLongError = /** @class */ (function (_super) {
    __extends(TrackNameTooLongError, _super);
    function TrackNameTooLongError() {
        var _this = _super.call(this, 53302, 'Track name is too long') || this;
        Object.setPrototypeOf(_this, TrackNameTooLongError.prototype);
        return _this;
    }
    return TrackNameTooLongError;
}(TwilioError));
exports.TrackNameTooLongError = TrackNameTooLongError;
Object.defineProperty(TwilioErrorByCode, 53302, { value: TrackNameTooLongError });
/**
 * @class TrackNameCharsInvalidError
 * @classdesc Raised whenever a Track name contains invalid characters.
 * @extends TwilioError
 * @property {number} code - 53303
 * @property {string} message - 'Track name contains invalid characters'
 */
var TrackNameCharsInvalidError = /** @class */ (function (_super) {
    __extends(TrackNameCharsInvalidError, _super);
    function TrackNameCharsInvalidError() {
        var _this = _super.call(this, 53303, 'Track name contains invalid characters') || this;
        Object.setPrototypeOf(_this, TrackNameCharsInvalidError.prototype);
        return _this;
    }
    return TrackNameCharsInvalidError;
}(TwilioError));
exports.TrackNameCharsInvalidError = TrackNameCharsInvalidError;
Object.defineProperty(TwilioErrorByCode, 53303, { value: TrackNameCharsInvalidError });
/**
 * @class TrackNameIsDuplicatedError
 * @classdesc Raised whenever a Participant is currently publishing a Track with the same name.
 * @extends TwilioError
 * @property {number} code - 53304
 * @property {string} message - 'Track name is duplicated'
 */
var TrackNameIsDuplicatedError = /** @class */ (function (_super) {
    __extends(TrackNameIsDuplicatedError, _super);
    function TrackNameIsDuplicatedError() {
        var _this = _super.call(this, 53304, 'Track name is duplicated') || this;
        Object.setPrototypeOf(_this, TrackNameIsDuplicatedError.prototype);
        return _this;
    }
    return TrackNameIsDuplicatedError;
}(TwilioError));
exports.TrackNameIsDuplicatedError = TrackNameIsDuplicatedError;
Object.defineProperty(TwilioErrorByCode, 53304, { value: TrackNameIsDuplicatedError });
/**
 * @class TrackServerTrackCapacityReachedError
 * @classdesc The server does not have enough resources available to create a new Track.
 * @extends TwilioError
 * @property {number} code - 53305
 * @property {string} message - 'The server has reached capacity and cannot fulfill this request'
 */
var TrackServerTrackCapacityReachedError = /** @class */ (function (_super) {
    __extends(TrackServerTrackCapacityReachedError, _super);
    function TrackServerTrackCapacityReachedError() {
        var _this = _super.call(this, 53305, 'The server has reached capacity and cannot fulfill this request') || this;
        Object.setPrototypeOf(_this, TrackServerTrackCapacityReachedError.prototype);
        return _this;
    }
    return TrackServerTrackCapacityReachedError;
}(TwilioError));
exports.TrackServerTrackCapacityReachedError = TrackServerTrackCapacityReachedError;
Object.defineProperty(TwilioErrorByCode, 53305, { value: TrackServerTrackCapacityReachedError });
/**
 * @class MediaClientLocalDescFailedError
 * @classdesc Raised whenever a Client is unable to create or apply a local media description.
 * @extends TwilioError
 * @property {number} code - 53400
 * @property {string} message - 'Client is unable to create or apply a local media description'
 */
var MediaClientLocalDescFailedError = /** @class */ (function (_super) {
    __extends(MediaClientLocalDescFailedError, _super);
    function MediaClientLocalDescFailedError() {
        var _this = _super.call(this, 53400, 'Client is unable to create or apply a local media description') || this;
        Object.setPrototypeOf(_this, MediaClientLocalDescFailedError.prototype);
        return _this;
    }
    return MediaClientLocalDescFailedError;
}(TwilioError));
exports.MediaClientLocalDescFailedError = MediaClientLocalDescFailedError;
Object.defineProperty(TwilioErrorByCode, 53400, { value: MediaClientLocalDescFailedError });
/**
 * @class MediaServerLocalDescFailedError
 * @classdesc Raised whenever the Server is unable to create or apply a local media description.
 * @extends TwilioError
 * @property {number} code - 53401
 * @property {string} message - 'Server is unable to create or apply a local media description'
 */
var MediaServerLocalDescFailedError = /** @class */ (function (_super) {
    __extends(MediaServerLocalDescFailedError, _super);
    function MediaServerLocalDescFailedError() {
        var _this = _super.call(this, 53401, 'Server is unable to create or apply a local media description') || this;
        Object.setPrototypeOf(_this, MediaServerLocalDescFailedError.prototype);
        return _this;
    }
    return MediaServerLocalDescFailedError;
}(TwilioError));
exports.MediaServerLocalDescFailedError = MediaServerLocalDescFailedError;
Object.defineProperty(TwilioErrorByCode, 53401, { value: MediaServerLocalDescFailedError });
/**
 * @class MediaClientRemoteDescFailedError
 * @classdesc Raised whenever the Client receives a remote media description but is unable to apply it.
 * @extends TwilioError
 * @property {number} code - 53402
 * @property {string} message - 'Client is unable to apply a remote media description'
 */
var MediaClientRemoteDescFailedError = /** @class */ (function (_super) {
    __extends(MediaClientRemoteDescFailedError, _super);
    function MediaClientRemoteDescFailedError() {
        var _this = _super.call(this, 53402, 'Client is unable to apply a remote media description') || this;
        Object.setPrototypeOf(_this, MediaClientRemoteDescFailedError.prototype);
        return _this;
    }
    return MediaClientRemoteDescFailedError;
}(TwilioError));
exports.MediaClientRemoteDescFailedError = MediaClientRemoteDescFailedError;
Object.defineProperty(TwilioErrorByCode, 53402, { value: MediaClientRemoteDescFailedError });
/**
 * @class MediaServerRemoteDescFailedError
 * @classdesc Raised whenever the Server receives a remote media description but is unable to apply it.
 * @extends TwilioError
 * @property {number} code - 53403
 * @property {string} message - 'Server is unable to apply a remote media description'
 */
var MediaServerRemoteDescFailedError = /** @class */ (function (_super) {
    __extends(MediaServerRemoteDescFailedError, _super);
    function MediaServerRemoteDescFailedError() {
        var _this = _super.call(this, 53403, 'Server is unable to apply a remote media description') || this;
        Object.setPrototypeOf(_this, MediaServerRemoteDescFailedError.prototype);
        return _this;
    }
    return MediaServerRemoteDescFailedError;
}(TwilioError));
exports.MediaServerRemoteDescFailedError = MediaServerRemoteDescFailedError;
Object.defineProperty(TwilioErrorByCode, 53403, { value: MediaServerRemoteDescFailedError });
/**
 * @class MediaNoSupportedCodecError
 * @classdesc Raised whenever the intersection of codecs supported by the Client and the Server (or, in peer-to-peer, the Client and another Participant) is empty.
 * @extends TwilioError
 * @property {number} code - 53404
 * @property {string} message - 'No supported codec'
 */
var MediaNoSupportedCodecError = /** @class */ (function (_super) {
    __extends(MediaNoSupportedCodecError, _super);
    function MediaNoSupportedCodecError() {
        var _this = _super.call(this, 53404, 'No supported codec') || this;
        Object.setPrototypeOf(_this, MediaNoSupportedCodecError.prototype);
        return _this;
    }
    return MediaNoSupportedCodecError;
}(TwilioError));
exports.MediaNoSupportedCodecError = MediaNoSupportedCodecError;
Object.defineProperty(TwilioErrorByCode, 53404, { value: MediaNoSupportedCodecError });
/**
 * @class MediaConnectionError
 * @classdesc Raised by the Client or Server whenever a media connection fails or raised by the Client whenever it detects that media has stopped flowing.
 * @extends TwilioError
 * @property {number} code - 53405
 * @property {string} message - 'Media connection failed or Media activity ceased'
 */
var MediaConnectionError = /** @class */ (function (_super) {
    __extends(MediaConnectionError, _super);
    function MediaConnectionError() {
        var _this = _super.call(this, 53405, 'Media connection failed or Media activity ceased') || this;
        Object.setPrototypeOf(_this, MediaConnectionError.prototype);
        return _this;
    }
    return MediaConnectionError;
}(TwilioError));
exports.MediaConnectionError = MediaConnectionError;
Object.defineProperty(TwilioErrorByCode, 53405, { value: MediaConnectionError });
/**
 * @class MediaDTLSTransportFailedError
 * @classdesc There was a problem while negotiating with the remote DTLS peer. Therefore the Participant will not be able to publish or subscribe to Tracks.
 * @extends TwilioError
 * @property {number} code - 53407
 * @property {string} message - 'Media connection failed due to DTLS handshake failure'
 */
var MediaDTLSTransportFailedError = /** @class */ (function (_super) {
    __extends(MediaDTLSTransportFailedError, _super);
    function MediaDTLSTransportFailedError() {
        var _this = _super.call(this, 53407, 'Media connection failed due to DTLS handshake failure') || this;
        Object.setPrototypeOf(_this, MediaDTLSTransportFailedError.prototype);
        return _this;
    }
    return MediaDTLSTransportFailedError;
}(TwilioError));
exports.MediaDTLSTransportFailedError = MediaDTLSTransportFailedError;
Object.defineProperty(TwilioErrorByCode, 53407, { value: MediaDTLSTransportFailedError });
/**
 * @class ConfigurationAcquireFailedError
 * @classdesc Raised whenever the Client is unable to acquire configuration information from the Server.
 * @extends TwilioError
 * @property {number} code - 53500
 * @property {string} message - 'Unable to acquire configuration'
 */
var ConfigurationAcquireFailedError = /** @class */ (function (_super) {
    __extends(ConfigurationAcquireFailedError, _super);
    function ConfigurationAcquireFailedError() {
        var _this = _super.call(this, 53500, 'Unable to acquire configuration') || this;
        Object.setPrototypeOf(_this, ConfigurationAcquireFailedError.prototype);
        return _this;
    }
    return ConfigurationAcquireFailedError;
}(TwilioError));
exports.ConfigurationAcquireFailedError = ConfigurationAcquireFailedError;
Object.defineProperty(TwilioErrorByCode, 53500, { value: ConfigurationAcquireFailedError });
/**
 * @class ConfigurationAcquireTurnFailedError
 * @classdesc Raised whenever the Server is unable to return TURN credentials to the Client
 * @extends TwilioError
 * @property {number} code - 53501
 * @property {string} message - 'Unable to acquire TURN credentials'
 */
var ConfigurationAcquireTurnFailedError = /** @class */ (function (_super) {
    __extends(ConfigurationAcquireTurnFailedError, _super);
    function ConfigurationAcquireTurnFailedError() {
        var _this = _super.call(this, 53501, 'Unable to acquire TURN credentials') || this;
        Object.setPrototypeOf(_this, ConfigurationAcquireTurnFailedError.prototype);
        return _this;
    }
    return ConfigurationAcquireTurnFailedError;
}(TwilioError));
exports.ConfigurationAcquireTurnFailedError = ConfigurationAcquireTurnFailedError;
Object.defineProperty(TwilioErrorByCode, 53501, { value: ConfigurationAcquireTurnFailedError });
//# sourceMappingURL=twilio-video-errors.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/twilioerror.js":
/*!***********************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/twilioerror.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
/**
 * @extends Error
 * @property {number} code - Error code
 */
var TwilioError = /** @class */ (function (_super) {
    __extends(TwilioError, _super);
    /**
     * Creates a new {@link TwilioError}
     * @param {number} code - Error code
     * @param {string} [message] - Error message
     * @param {string} [fileName] - Name of the script file where error was generated
     * @param {number} [lineNumber] - Line number of the script file where error was generated
     */
    function TwilioError(code) {
        var _this = this;
        var args = [].slice.call(arguments, 1);
        _this = _super.apply(this, __spreadArray([], __read(args))) || this;
        Object.setPrototypeOf(_this, TwilioError.prototype);
        var error = Error.apply(_this, args);
        error.name = 'TwilioError';
        Object.defineProperty(_this, 'code', {
            value: code,
            enumerable: true
        });
        Object.getOwnPropertyNames(error).forEach(function (prop) {
            Object.defineProperty(this, prop, {
                value: error[prop],
                enumerable: true
            });
        }, _this);
        return _this;
    }
    /**
     * Returns human readable string describing the error.
     * @returns {string}
     */
    TwilioError.prototype.toString = function () {
        var message = this.message ? ": " + this.message : '';
        return this.name + " " + this.code + message;
    };
    return TwilioError;
}(Error));
module.exports = TwilioError;
//# sourceMappingURL=twilioerror.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/util/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/twilio-video/es5/util/validate.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isNonArrayObject = __webpack_require__(/*! ./ */ "./node_modules/twilio-video/es5/util/index.js").isNonArrayObject;
var _a = __webpack_require__(/*! ./constants */ "./node_modules/twilio-video/es5/util/constants.js"), E = _a.typeErrors, clientTrackSwitchOffControl = _a.clientTrackSwitchOffControl, videoContentPreferencesMode = _a.videoContentPreferencesMode, subscriptionMode = _a.subscriptionMode, trackPriority = _a.trackPriority, trackSwitchOffMode = _a.trackSwitchOffMode;
/**
 * Validate the {@link BandwidthProfile} object.
 * @param {BandwidthProfile} bandwidthProfile
 * @returns {?Error} - null if valid, Error if not.
 */
function validateBandwidthProfile(bandwidthProfile) {
    var error = validateObject(bandwidthProfile, 'options.bandwidthProfile');
    if (!bandwidthProfile || error) {
        return error;
    }
    error = validateObject(bandwidthProfile.video, 'options.bandwidthProfile.video', [
        { prop: 'contentPreferencesMode', values: Object.values(videoContentPreferencesMode) },
        { prop: 'dominantSpeakerPriority', values: Object.values(trackPriority) },
        { prop: 'maxSubscriptionBitrate', type: 'number' },
        { prop: 'maxTracks', type: 'number' },
        { prop: 'maxSwitchedOnTracks', type: 'number' },
        { prop: 'mode', values: Object.values(subscriptionMode) },
        { prop: 'clientTrackSwitchOffControl', values: Object.values(clientTrackSwitchOffControl) },
        { prop: 'trackSwitchOffMode', values: Object.values(trackSwitchOffMode) }
    ]);
    if (error) {
        return error;
    }
    error = validateObject(bandwidthProfile.audio, 'options.bandwidthProfile.audio', [
        { prop: 'maxSwitchedOnTracks', type: 'number' }
    ]);
    if (bandwidthProfile.video) {
        // maxTracks is replaced by clientTrackSwitchOffControl.
        // throw an error if both are specified.
        if ('maxTracks' in bandwidthProfile.video && 'clientTrackSwitchOffControl' in bandwidthProfile.video) {
            return new TypeError('options.bandwidthProfile.video.maxTracks is deprecated. Use options.bandwidthProfile.video.clientTrackSwitchOffControl instead.');
        }
        // renderDimensions is replaced by contentPreferencesMode.
        // throw an error if both are specified.
        if ('renderDimensions' in bandwidthProfile.video && 'contentPreferencesMode' in bandwidthProfile.video) {
            return new TypeError('options.bandwidthProfile.video.renderDimensions is deprecated. Use options.bandwidthProfile.video.contentPreferencesMode instead.');
        }
        // maxSwitchedOnTracks and maxTracks are mutually exclusive.
        if ('maxSwitchedOnTracks' in bandwidthProfile.video && 'maxTracks' in bandwidthProfile.video) {
            return new TypeError('options.bandwidthProfile.video.maxTracks is deprecated. Use options.bandwidthProfile.video.clientTrackSwitchOffControl instead.');
        }
        return validateRenderDimensions(bandwidthProfile.video.renderDimensions);
    }
    return null;
}
/**
 * Throw if the given track is not a {@link LocalAudioTrack}, a
 * {@link LocalVideoTrack} or a MediaStreamTrack.
 * @param {*} track
 * @param {object} options
 */
function validateLocalTrack(track, options) {
    if (!(track instanceof options.LocalAudioTrack
        || track instanceof options.LocalDataTrack
        || track instanceof options.LocalVideoTrack
        || track instanceof options.MediaStreamTrack)) {
        /* eslint new-cap:0 */
        throw E.INVALID_TYPE('track', 'LocalAudioTrack, LocalVideoTrack, LocalDataTrack, or MediaStreamTrack');
    }
}
/**
 * Validate an object. An object is valid if it is undefined or a non-null, non-array
 * object whose properties satisfy the specified data-type or value-range requirements.
 * @param {object} object - the object to be validated
 * @param {string} name - the object name to be used to build the error message, if invalid
 * @param {Array<object>} [propChecks] - optional data-type or value-range requirements
 *   for the object's properties
 * @returns {?Error} - null if object is valid, Error if not
 */
function validateObject(object, name, propChecks) {
    if (propChecks === void 0) { propChecks = []; }
    // NOTE(mmalavalli): We determine that an undefined object is valid because this
    // means the parent object does not contain this object as a property, which is
    // a valid scenario.
    if (typeof object === 'undefined') {
        return null;
    }
    // NOTE(mmalavalli): We determine that if the object is null, or an Array, or
    // any other non-object type, then it is invalid.
    if (object === null || !isNonArrayObject(object)) {
        return E.INVALID_TYPE(name, 'object');
    }
    // NOTE(mmalavalli): We determine that the object is invalid if at least one of
    // its properties does not satisfy its data-type or value-range requirement.
    return propChecks.reduce(function (error, _a) {
        var prop = _a.prop, type = _a.type, values = _a.values;
        if (error || !(prop in object)) {
            return error;
        }
        var value = object[prop];
        if (type && typeof value !== type) {
            return E.INVALID_TYPE(name + "." + prop, type);
        }
        if (type === 'number' && isNaN(value)) {
            return E.INVALID_TYPE(name + "." + prop, type);
        }
        if (Array.isArray(values) && !values.includes(value)) {
            return E.INVALID_VALUE(name + "." + prop, values);
        }
        return error;
    }, null);
}
/**
 * Validates the renderDimensions field to be "auto" or {@link VideoRenderDimensions} object.
 * @param {string|VideoRenderDimensions} renderDimensions
 * @returns {?Error} - null if valid, Error if not.
 */
function validateRenderDimensions(renderDimensions) {
    var name = 'options.bandwidthProfile.video.renderDimensions';
    var error = validateObject(renderDimensions, name);
    return renderDimensions ? error || Object.values(trackPriority).reduce(function (error, prop) {
        return error || validateObject(renderDimensions[prop], name + "." + prop, [
            { prop: 'height', type: 'number' },
            { prop: 'width', type: 'number' }
        ]);
    }, null) : error;
}
exports.validateBandwidthProfile = validateBandwidthProfile;
exports.validateLocalTrack = validateLocalTrack;
exports.validateObject = validateObject;
//# sourceMappingURL=validate.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/vendor/loglevel.js":
/*!**********************************************************!*\
  !*** ./node_modules/twilio-video/es5/vendor/loglevel.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2013 Tim Perry
 * Licensed under the MIT license.
 *
 * Copied from https://github.com/pimterry/loglevel (1.7.0)
 * and modified to remove browser and AMD module support, while keeping CommonJS.
 * It was causing a conflict when this is bundled using CommonJS, and then loaded via RequireJS.
 * The proper way to fix this module is to have a build that outputs CommonJS and AMD separately
 * which needs to be submitted to the original module's repo.
 */
/* istanbul ignore file */
/* eslint-disable */
// Slightly dubious tricks to cut down minimized file size
var noop = function () { };
var undefinedType = "undefined";
var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (/Trident\/|MSIE /.test(window.navigator.userAgent));
var logMethods = [
    "trace",
    "debug",
    "info",
    "warn",
    "error"
];
// Cross-browser bind equivalent that works at least back to IE6
function bindMethod(obj, methodName) {
    var method = obj[methodName];
    if (typeof method.bind === 'function') {
        return method.bind(obj);
    }
    else {
        try {
            return Function.prototype.bind.call(method, obj);
        }
        catch (e) {
            // Missing bind shim or IE8 + Modernizr, fallback to wrapping
            return function () {
                return Function.prototype.apply.apply(method, [obj, arguments]);
            };
        }
    }
}
// Trace() doesn't print the message in IE, so for that case we need to wrap it
function traceForIE() {
    if (console.log) {
        if (console.log.apply) {
            console.log.apply(console, arguments);
        }
        else {
            // In old IE, native console methods themselves don't have apply().
            Function.prototype.apply.apply(console.log, [console, arguments]);
        }
    }
    if (console.trace)
        console.trace();
}
// Build the best logging method possible for this env
// Wherever possible we want to bind, not wrap, to preserve stack traces
function realMethod(methodName) {
    if (methodName === 'debug') {
        methodName = 'log';
    }
    if (typeof console === undefinedType) {
        return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
    }
    else if (methodName === 'trace' && isIE) {
        return traceForIE;
    }
    else if (console[methodName] !== undefined) {
        return bindMethod(console, methodName);
    }
    else if (console.log !== undefined) {
        return bindMethod(console, 'log');
    }
    else {
        return noop;
    }
}
// These private functions always need `this` to be set properly
function replaceLoggingMethods(level, loggerName) {
    /*jshint validthis:true */
    for (var i = 0; i < logMethods.length; i++) {
        var methodName = logMethods[i];
        this[methodName] = (i < level) ?
            noop :
            this.methodFactory(methodName, level, loggerName);
    }
    // Define log.log as an alias for log.debug
    this.log = this.debug;
}
// In old IE versions, the console isn't present until you first open it.
// We build realMethod() replacements here that regenerate logging methods
function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
    return function () {
        if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this, level, loggerName);
            this[methodName].apply(this, arguments);
        }
    };
}
// By default, we use closely bound real methods wherever possible, and
// otherwise we wait for a console to appear, and then try again.
function defaultMethodFactory(methodName, level, loggerName) {
    /*jshint validthis:true */
    return realMethod(methodName) ||
        enableLoggingWhenConsoleArrives.apply(this, arguments);
}
function Logger(name, defaultLevel, factory) {
    var self = this;
    var currentLevel;
    var storageKey = "loglevel";
    if (typeof name === "string") {
        storageKey += ":" + name;
    }
    else if (typeof name === "symbol") {
        storageKey = undefined;
    }
    function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || 'silent').toUpperCase();
        if (typeof window === undefinedType || !storageKey)
            return;
        // Use localStorage if available
        try {
            window.localStorage[storageKey] = levelName;
            return;
        }
        catch (ignore) { }
        // Use session cookie as fallback
        try {
            window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
        }
        catch (ignore) { }
    }
    function getPersistedLevel() {
        var storedLevel;
        if (typeof window === undefinedType || !storageKey)
            return;
        try {
            storedLevel = window.localStorage[storageKey];
        }
        catch (ignore) { }
        // Fallback to cookies if local storage gives us nothing
        if (typeof storedLevel === undefinedType) {
            try {
                var cookie = window.document.cookie;
                var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");
                if (location !== -1) {
                    storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                }
            }
            catch (ignore) { }
        }
        // If the stored level is not valid, treat it as if nothing was stored.
        if (self.levels[storedLevel] === undefined) {
            storedLevel = undefined;
        }
        return storedLevel;
    }
    /*
     *
     * Public logger API - see https://github.com/pimterry/loglevel for details
     *
     */
    self.name = name;
    self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
        "ERROR": 4, "SILENT": 5 };
    self.methodFactory = factory || defaultMethodFactory;
    self.getLevel = function () {
        return currentLevel;
    };
    self.setLevel = function (level, persist) {
        if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
            level = self.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
            currentLevel = level;
            if (persist !== false) { // defaults to true
                persistLevelIfPossible(level);
            }
            replaceLoggingMethods.call(self, level, name);
            if (typeof console === undefinedType && level < self.levels.SILENT) {
                return "No console available for logging";
            }
        }
        else {
            throw "log.setLevel() called with invalid level: " + level;
        }
    };
    self.setDefaultLevel = function (level) {
        if (!getPersistedLevel()) {
            self.setLevel(level, false);
        }
    };
    self.enableAll = function (persist) {
        self.setLevel(self.levels.TRACE, persist);
    };
    self.disableAll = function (persist) {
        self.setLevel(self.levels.SILENT, persist);
    };
    // Initialize with the right level
    var initialLevel = getPersistedLevel();
    if (initialLevel == null) {
        initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
    }
    self.setLevel(initialLevel, false);
}
/*
 *
 * Top-level API
 *
 */
var defaultLogger = new Logger();
var _loggersByName = {};
defaultLogger.getLogger = function getLogger(name) {
    if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
        throw new TypeError("You must supply a name when creating a logger.");
    }
    var logger = _loggersByName[name];
    if (!logger) {
        logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);
    }
    return logger;
};
// Grab the current global log variable in case of overwrite
var _log = (typeof window !== undefinedType) ? window.log : undefined;
defaultLogger.noConflict = function () {
    if (typeof window !== undefinedType &&
        window.log === defaultLogger) {
        window.log = _log;
    }
    return defaultLogger;
};
defaultLogger.getLoggers = function getLoggers() {
    return _loggersByName;
};
// ES6 default export, for compatibility
defaultLogger['default'] = defaultLogger;
module.exports = defaultLogger;
//# sourceMappingURL=loglevel.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webaudio/audiocontext.js":
/*!****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webaudio/audiocontext.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals webkitAudioContext, AudioContext */

var NativeAudioContext = typeof AudioContext !== 'undefined'
    ? AudioContext
    : typeof webkitAudioContext !== 'undefined'
        ? webkitAudioContext
        : null;
/**
 * @interface AudioContextFactoryOptions
 * @property {AudioContext} [AudioContext] - The AudioContext constructor
 */
/**
 * {@link AudioContextFactory} ensures we construct at most one AudioContext
 * at a time, and that it is eventually closed when we no longer need it.
 * @property {AudioContextFactory} AudioContextFactory - The
 *   {@link AudioContextFactory} constructor
 */
var AudioContextFactory = /** @class */ (function () {
    /**
     * @param {AudioContextFactoryOptions} [options]
     */
    function AudioContextFactory(options) {
        options = Object.assign({
            AudioContext: NativeAudioContext
        }, options);
        Object.defineProperties(this, {
            _AudioContext: {
                value: options.AudioContext
            },
            _audioContext: {
                value: null,
                writable: true
            },
            _holders: {
                value: new Set()
            },
            AudioContextFactory: {
                enumerable: true,
                value: AudioContextFactory
            }
        });
    }
    /**
     * Each call to {@link AudioContextFactory#getOrCreate} should be paired with a
     * call to {@link AudioContextFactory#release}. Calling this increments an
     * internal reference count.
     * @param {*} holder - The object to hold a reference to the AudioContext
     * @returns {?AudioContext}
     */
    AudioContextFactory.prototype.getOrCreate = function (holder) {
        if (!this._holders.has(holder)) {
            this._holders.add(holder);
            if (this._AudioContext && !this._audioContext) {
                try {
                    this._audioContext = new this._AudioContext();
                }
                catch (error) {
                    // Do nothing;
                }
            }
        }
        return this._audioContext;
    };
    /**
     * Decrement the internal reference count. If it reaches zero, close and destroy
     * the AudioContext.
     * @param {*} holder - The object that held a reference to the AudioContext
     * @returns {void}
     */
    AudioContextFactory.prototype.release = function (holder) {
        if (this._holders.has(holder)) {
            this._holders.delete(holder);
            if (!this._holders.size && this._audioContext) {
                this._audioContext.close();
                this._audioContext = null;
            }
        }
    };
    return AudioContextFactory;
}());
module.exports = new AudioContextFactory();
//# sourceMappingURL=audiocontext.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webaudio/detectsilence.js":
/*!*****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webaudio/detectsilence.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Return a Promise that resolves after `timeout` milliseconds.
 * @param {?number} [timeout=0]
 * @returns {Promise<void>}
 */
function delay(timeout) {
    timeout = typeof timeout === 'number' ? timeout : 0;
    return new Promise(function (resolve) { return setTimeout(resolve, timeout); });
}
/**
 * Attempt to detect silence. The Promise returned by this function returns
 * false as soon as audio is detected or true after `timeout` milliseconds.
 * @param {AudioContext} audioContext
 * @param {MediaStream} stream
 * @param {?number} [timeout=250]
 * @returns {Promise<boolean>}
 */
function detectSilence(audioContext, stream, timeout) {
    timeout = typeof timeout === 'number' ? timeout : 250;
    var source = audioContext.createMediaStreamSource(stream);
    var analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    source.connect(analyser);
    var samples = new Uint8Array(analyser.fftSize);
    var timeoutDidFire = false;
    setTimeout(function () { timeoutDidFire = true; }, timeout);
    /**
     * We can't use async/await yet, so I need to factor this out.
     * @returns {Promise<boolean>}
     */
    function doDetectSilence() {
        if (timeoutDidFire) {
            return Promise.resolve(true);
        }
        analyser.getByteTimeDomainData(samples);
        // NOTE(mpatwardhan): An audio MediaStreamTrack can be silent either due to all samples
        // being equal to 128 or all samples being equal to 0.
        return samples.some(function (sample) { return sample !== 128 && sample !== 0; })
            ? Promise.resolve(false)
            : delay().then(doDetectSilence);
    }
    return doDetectSilence().then(function (isSilent) {
        source.disconnect();
        return isSilent;
    }, function (error) {
        source.disconnect();
        throw error;
    });
}
module.exports = detectSilence;
//# sourceMappingURL=detectsilence.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webaudio/workaround180748.js":
/*!********************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webaudio/workaround180748.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var detectSilence = __webpack_require__(/*! ./detectsilence */ "./node_modules/twilio-video/es5/webaudio/detectsilence.js");
/**
 * This function attempts to workaround WebKit Bug 180748. It does so by
 *
 *   1. Calling `getUserMedia`, and
 *   2. Checking to see if the resulting MediaStream is silent.
 *   3. If so, repeat Step 1; otherwise, return the MediaStream.
 *
 * The function only repeats up to `n` times, and it only waits `timeout`
 * milliseconds when detecting silence. Assuming `getUserMedia` is
 * instantaneous, in the best case, this function returns a Promise that
 * resolves immediately; in the worst case, this function returns a Promise that
 * resolves in `n` * `timeout` milliseconds.
 *
 * @param {Log} log
 * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia
 * @param {MediaStreamConstraints} constraints
 * @param {number} [n=3]
 * @param {number} [timeout=250]
 * @returns Promise<MediaStream>
 */
function workaround(log, getUserMedia, constraints, n, timeout) {
    n = typeof n === 'number' ? n : 3;
    var retry = 0;
    // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because
    // it exports a default instance whose constructor calls Object.assign.
    var AudioContextFactory = __webpack_require__(/*! ./audiocontext */ "./node_modules/twilio-video/es5/webaudio/audiocontext.js");
    var holder = {};
    var audioContext = AudioContextFactory.getOrCreate(holder);
    /**
     * We can't use async/await yet, so I need to factor this out.
     * @returns {Promise<MediaStream>}
     */
    function doWorkaround() {
        return getUserMedia(constraints).then(function (stream) {
            var isSilentPromise = constraints.audio
                ? detectSilence(audioContext, stream, timeout).catch(function (err) {
                    log.warn('Encountered an error while detecting silence', err);
                    return true;
                })
                : Promise.resolve(false);
            return isSilentPromise.then(function (isSilent) {
                if (!isSilent) {
                    log.info('Got a non-silent audio MediaStreamTrack; returning it.');
                    return stream;
                }
                else if (n <= 0) {
                    log.warn('Got a silent audio MediaStreamTrack. Normally we would try \
to get a new one, but we\'ve run out of retries; returning it anyway.');
                    return stream;
                }
                log.warn("Got a silent audio MediaStreamTrack. Stopping all MediaStreamTracks and calling getUserMedia again. This is retry #" + ++retry + ".");
                stream.getTracks().forEach(function (track) { return track.stop(); });
                n--;
                return doWorkaround();
            });
        });
    }
    return doWorkaround().then(function (stream) {
        AudioContextFactory.release(holder);
        return stream;
    }, function (error) {
        AudioContextFactory.release(holder);
        throw error;
    });
}
module.exports = workaround;
//# sourceMappingURL=workaround180748.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/getstats.js":
/*!**********************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/getstats.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var flatMap = __webpack_require__(/*! ./util */ "./node_modules/twilio-video/es5/webrtc/util/index.js").flatMap;
var guessBrowser = __webpack_require__(/*! ./util */ "./node_modules/twilio-video/es5/webrtc/util/index.js").guessBrowser;
var guessBrowserVersion = __webpack_require__(/*! ./util */ "./node_modules/twilio-video/es5/webrtc/util/index.js").guessBrowserVersion;
var getSdpFormat = __webpack_require__(/*! ./util/sdp */ "./node_modules/twilio-video/es5/webrtc/util/sdp.js").getSdpFormat;
var guess = guessBrowser();
var guessVersion = guessBrowserVersion();
var isChrome = guess === 'chrome';
var isFirefox = guess === 'firefox';
var isSafari = guess === 'safari';
var chromeMajorVersion = isChrome ? guessVersion.major : null;
var CHROME_LEGACY_MAX_AUDIO_LEVEL = 32767;
/**
 * Get the standardized {@link RTCPeerConnection} statistics.
 * @param {RTCPeerConnection} peerConnection
 * @param {object} [options] - Used for testing
 * @returns {Promise.<StandardizedStatsResponse>}
 */
function getStats(peerConnection, options) {
    if (!(peerConnection && typeof peerConnection.getStats === 'function')) {
        return Promise.reject(new Error('Given PeerConnection does not support getStats'));
    }
    return _getStats(peerConnection, options);
}
/**
 * getStats() implementation.
 * @param {RTCPeerConnection} peerConnection
 * @param {object} [options] - Used for testing
 * @returns {Promise.<StandardizedStatsResponse>}
 */
function _getStats(peerConnection, options) {
    var localAudioTracks = getTracks(peerConnection, 'audio', 'local');
    var localVideoTracks = getTracks(peerConnection, 'video', 'local');
    var remoteAudioTracks = getTracks(peerConnection, 'audio');
    var remoteVideoTracks = getTracks(peerConnection, 'video');
    var statsResponse = {
        activeIceCandidatePair: null,
        localAudioTrackStats: [],
        localVideoTrackStats: [],
        remoteAudioTrackStats: [],
        remoteVideoTrackStats: []
    };
    var trackStatsPromises = flatMap([
        [localAudioTracks, 'localAudioTrackStats', false],
        [localVideoTracks, 'localVideoTrackStats', false],
        [remoteAudioTracks, 'remoteAudioTrackStats', true],
        [remoteVideoTracks, 'remoteVideoTrackStats', true]
    ], function (triple) {
        var tracks = triple[0];
        var statsArrayName = triple[1];
        var isRemote = triple[2];
        return tracks.map(function (track) {
            return getTrackStats(peerConnection, track, Object.assign({
                isRemote: isRemote
            }, options)).then(function (trackStatsArray) {
                trackStatsArray.forEach(function (trackStats) {
                    trackStats.trackId = track.id;
                    statsResponse[statsArrayName].push(trackStats);
                });
            });
        });
    });
    return Promise.all(trackStatsPromises).then(function () {
        return getActiveIceCandidatePairStats(peerConnection, options);
    }).then(function (activeIceCandidatePairStatsReport) {
        statsResponse.activeIceCandidatePair = activeIceCandidatePairStatsReport;
        return statsResponse;
    });
}
/**
 * Generate the {@link StandardizedActiveIceCandidatePairStatsReport} for the
 * {@link RTCPeerConnection}.
 * @param {RTCPeerConnection} peerConnection
 * @param {object} [options]
 * @returns {Promise<StandardizedActiveIceCandidatePairStatsReport>}
 */
function getActiveIceCandidatePairStats(peerConnection, options) {
    options = options || {};
    if (typeof options.testForChrome !== 'undefined' || isChrome
        || typeof options.testForSafari !== 'undefined' || isSafari) {
        return peerConnection.getStats().then(standardizeChromeOrSafariActiveIceCandidatePairStats);
    }
    if (typeof options.testForFirefox !== 'undefined' || isFirefox) {
        return peerConnection.getStats().then(standardizeFirefoxActiveIceCandidatePairStats);
    }
    return Promise.reject(new Error('RTCPeerConnection#getStats() not supported'));
}
/**
 * Standardize the active RTCIceCandidate pair's statistics in Chrome or Safari.
 * @param {RTCStatsReport} stats
 * @returns {?StandardizedActiveIceCandidatePairStatsReport}
 */
function standardizeChromeOrSafariActiveIceCandidatePairStats(stats) {
    var activeCandidatePairStats = Array.from(stats.values()).find(function (stat) {
        return stat.type === 'candidate-pair' && stat.nominated;
    });
    if (!activeCandidatePairStats) {
        return null;
    }
    var activeLocalCandidateStats = stats.get(activeCandidatePairStats.localCandidateId);
    var activeRemoteCandidateStats = stats.get(activeCandidatePairStats.remoteCandidateId);
    var standardizedCandidateStatsKeys = [
        { key: 'candidateType', type: 'string' },
        { key: 'ip', type: 'string' },
        { key: 'port', type: 'number' },
        { key: 'priority', type: 'number' },
        { key: 'protocol', type: 'string' },
        { key: 'url', type: 'string' }
    ];
    var standardizedLocalCandidateStatsKeys = standardizedCandidateStatsKeys.concat([
        { key: 'deleted', type: 'boolean' },
        { key: 'relayProtocol', type: 'string' }
    ]);
    var standatdizedLocalCandidateStatsReport = activeLocalCandidateStats
        ? standardizedLocalCandidateStatsKeys.reduce(function (report, keyInfo) {
            report[keyInfo.key] = typeof activeLocalCandidateStats[keyInfo.key] === keyInfo.type
                ? activeLocalCandidateStats[keyInfo.key]
                : keyInfo.key === 'deleted' ? false : null;
            return report;
        }, {})
        : null;
    var standardizedRemoteCandidateStatsReport = activeRemoteCandidateStats
        ? standardizedCandidateStatsKeys.reduce(function (report, keyInfo) {
            report[keyInfo.key] = typeof activeRemoteCandidateStats[keyInfo.key] === keyInfo.type
                ? activeRemoteCandidateStats[keyInfo.key]
                : null;
            return report;
        }, {})
        : null;
    return [
        { key: 'availableIncomingBitrate', type: 'number' },
        { key: 'availableOutgoingBitrate', type: 'number' },
        { key: 'bytesReceived', type: 'number' },
        { key: 'bytesSent', type: 'number' },
        { key: 'consentRequestsSent', type: 'number' },
        { key: 'currentRoundTripTime', type: 'number' },
        { key: 'lastPacketReceivedTimestamp', type: 'number' },
        { key: 'lastPacketSentTimestamp', type: 'number' },
        { key: 'nominated', type: 'boolean' },
        { key: 'priority', type: 'number' },
        { key: 'readable', type: 'boolean' },
        { key: 'requestsReceived', type: 'number' },
        { key: 'requestsSent', type: 'number' },
        { key: 'responsesReceived', type: 'number' },
        { key: 'responsesSent', type: 'number' },
        { key: 'retransmissionsReceived', type: 'number' },
        { key: 'retransmissionsSent', type: 'number' },
        { key: 'state', type: 'string', fixup: function (state) { return state === 'inprogress' ? 'in-progress' : state; } },
        { key: 'totalRoundTripTime', type: 'number' },
        { key: 'transportId', type: 'string' },
        { key: 'writable', type: 'boolean' }
    ].reduce(function (report, keyInfo) {
        report[keyInfo.key] = typeof activeCandidatePairStats[keyInfo.key] === keyInfo.type
            ? (keyInfo.fixup ? keyInfo.fixup(activeCandidatePairStats[keyInfo.key]) : activeCandidatePairStats[keyInfo.key])
            : null;
        return report;
    }, {
        localCandidate: standatdizedLocalCandidateStatsReport,
        remoteCandidate: standardizedRemoteCandidateStatsReport
    });
}
/**
 * Standardize the active RTCIceCandidate pair's statistics in Firefox.
 * @param {RTCStatsReport} stats
 * @returns {?StandardizedActiveIceCandidatePairStatsReport}
 */
function standardizeFirefoxActiveIceCandidatePairStats(stats) {
    var activeCandidatePairStats = Array.from(stats.values()).find(function (stat) {
        return stat.type === 'candidate-pair' && stat.nominated;
    });
    if (!activeCandidatePairStats) {
        return null;
    }
    var activeLocalCandidateStats = stats.get(activeCandidatePairStats.localCandidateId);
    var activeRemoteCandidateStats = stats.get(activeCandidatePairStats.remoteCandidateId);
    var standardizedCandidateStatsKeys = [
        { key: 'candidateType', type: 'string' },
        { key: 'ip', ffKeys: ['address', 'ipAddress'], type: 'string' },
        { key: 'port', ffKeys: ['portNumber'], type: 'number' },
        { key: 'priority', type: 'number' },
        { key: 'protocol', ffKeys: ['transport'], type: 'string' },
        { key: 'url', type: 'string' }
    ];
    var standardizedLocalCandidateStatsKeys = standardizedCandidateStatsKeys.concat([
        { key: 'deleted', type: 'boolean' },
        { key: 'relayProtocol', type: 'string' }
    ]);
    var candidateTypes = {
        host: 'host',
        peerreflexive: 'prflx',
        relayed: 'relay',
        serverreflexive: 'srflx'
    };
    var standatdizedLocalCandidateStatsReport = activeLocalCandidateStats
        ? standardizedLocalCandidateStatsKeys.reduce(function (report, keyInfo) {
            var key = keyInfo.ffKeys && keyInfo.ffKeys.find(function (key) {
                return key in activeLocalCandidateStats;
            }) || keyInfo.key;
            report[keyInfo.key] = typeof activeLocalCandidateStats[key] === keyInfo.type
                ? key === 'candidateType'
                    ? candidateTypes[activeLocalCandidateStats[key]] || activeLocalCandidateStats[key]
                    : activeLocalCandidateStats[key]
                : key === 'deleted' ? false : null;
            return report;
        }, {})
        : null;
    var standardizedRemoteCandidateStatsReport = activeRemoteCandidateStats
        ? standardizedCandidateStatsKeys.reduce(function (report, keyInfo) {
            var key = keyInfo.ffKeys && keyInfo.ffKeys.find(function (key) {
                return key in activeRemoteCandidateStats;
            }) || keyInfo.key;
            report[keyInfo.key] = typeof activeRemoteCandidateStats[key] === keyInfo.type
                ? key === 'candidateType'
                    ? candidateTypes[activeRemoteCandidateStats[key]] || activeRemoteCandidateStats[key]
                    : activeRemoteCandidateStats[key]
                : null;
            return report;
        }, {})
        : null;
    return [
        { key: 'availableIncomingBitrate', type: 'number' },
        { key: 'availableOutgoingBitrate', type: 'number' },
        { key: 'bytesReceived', type: 'number' },
        { key: 'bytesSent', type: 'number' },
        { key: 'consentRequestsSent', type: 'number' },
        { key: 'currentRoundTripTime', type: 'number' },
        { key: 'lastPacketReceivedTimestamp', type: 'number' },
        { key: 'lastPacketSentTimestamp', type: 'number' },
        { key: 'nominated', type: 'boolean' },
        { key: 'priority', type: 'number' },
        { key: 'readable', type: 'boolean' },
        { key: 'requestsReceived', type: 'number' },
        { key: 'requestsSent', type: 'number' },
        { key: 'responsesReceived', type: 'number' },
        { key: 'responsesSent', type: 'number' },
        { key: 'retransmissionsReceived', type: 'number' },
        { key: 'retransmissionsSent', type: 'number' },
        { key: 'state', type: 'string' },
        { key: 'totalRoundTripTime', type: 'number' },
        { key: 'transportId', type: 'string' },
        { key: 'writable', type: 'boolean' }
    ].reduce(function (report, keyInfo) {
        report[keyInfo.key] = typeof activeCandidatePairStats[keyInfo.key] === keyInfo.type
            ? activeCandidatePairStats[keyInfo.key]
            : null;
        return report;
    }, {
        localCandidate: standatdizedLocalCandidateStatsReport,
        remoteCandidate: standardizedRemoteCandidateStatsReport
    });
}
/**
 * Get local/remote audio/video MediaStreamTracks.
 * @param {RTCPeerConnection} peerConnection - The RTCPeerConnection
 * @param {string} kind - 'audio' or 'video'
 * @param {string} [localOrRemote] - 'local' or 'remote'
 * @returns {Array<MediaStreamTrack>}
 */
function getTracks(peerConnection, kind, localOrRemote) {
    var getSendersOrReceivers = localOrRemote === 'local' ? 'getSenders' : 'getReceivers';
    if (peerConnection[getSendersOrReceivers]) {
        return peerConnection[getSendersOrReceivers]().map(function (senderOrReceiver) {
            return senderOrReceiver.track;
        }).filter(function (track) {
            return track && track.kind === kind;
        });
    }
    var getStreams = localOrRemote === 'local' ? 'getLocalStreams' : 'getRemoteStreams';
    return flatMap(peerConnection[getStreams](), function (stream) {
        var getTracks = kind === 'audio' ? 'getAudioTracks' : 'getVideoTracks';
        return stream[getTracks]();
    });
}
/**
 * Get the standardized statistics for a particular MediaStreamTrack.
 * @param {RTCPeerConnection} peerConnection
 * @param {MediaStreamTrack} track
 * @param {object} [options] - Used for testing
 * @returns {Promise.<Array<StandardizedTrackStatsReport>>}
 */
function getTrackStats(peerConnection, track, options) {
    options = options || {};
    if (typeof options.testForChrome !== 'undefined' || isChrome) {
        return chromeOrSafariGetTrackStats(peerConnection, track);
    }
    if (typeof options.testForFirefox !== 'undefined' || isFirefox) {
        return firefoxGetTrackStats(peerConnection, track, options.isRemote);
    }
    if (typeof options.testForSafari !== 'undefined' || isSafari) {
        if (typeof options.testForSafari !== 'undefined' || getSdpFormat() === 'unified') {
            return chromeOrSafariGetTrackStats(peerConnection, track);
        }
        // NOTE(syerrapragada): getStats() is not supported on
        // Safari versions where plan-b is the SDP format
        // due to this bug: https://bugs.webkit.org/show_bug.cgi?id=192601
        return Promise.reject(new Error([
            'getStats() is not supported on this version of Safari',
            'due to this bug: https://bugs.webkit.org/show_bug.cgi?id=192601'
        ].join(' ')));
    }
    return Promise.reject(new Error('RTCPeerConnection#getStats() not supported'));
}
/**
 * Get the standardized statistics for a particular MediaStreamTrack in Chrome or Safari.
 * @param {RTCPeerConnection} peerConnection
 * @param {MediaStreamTrack} track
 * @returns {Promise.<Array<StandardizedTrackStatsReport>>}
 */
function chromeOrSafariGetTrackStats(peerConnection, track) {
    return new Promise(function (resolve, reject) {
        if (chromeMajorVersion && chromeMajorVersion < 67) {
            peerConnection.getStats(function (response) {
                resolve([standardizeChromeLegacyStats(response, track)]);
            }, null, reject);
            return;
        }
        peerConnection.getStats(track).then(function (response) {
            resolve(standardizeChromeOrSafariStats(response));
        }, reject);
    });
}
/**
 * Get the standardized statistics for a particular MediaStreamTrack in Firefox.
 * @param {RTCPeerConnection} peerConnection
 * @param {MediaStreamTrack} track
 * @param {boolean} isRemote
 * @returns {Promise.<Array<StandardizedTrackStatsReport>>}
 */
function firefoxGetTrackStats(peerConnection, track, isRemote) {
    return new Promise(function (resolve, reject) {
        peerConnection.getStats(track).then(function (response) {
            resolve([standardizeFirefoxStats(response, isRemote)]);
        }, reject);
    });
}
/**
 * Standardize the MediaStreamTrack's legacy statistics in Chrome.
 * @param {RTCStatsResponse} response
 * @param {MediaStreamTrack} track
 * @returns {StandardizedTrackStatsReport}
 */
function standardizeChromeLegacyStats(response, track) {
    var ssrcReport = response.result().find(function (report) {
        return report.type === 'ssrc' && report.stat('googTrackId') === track.id;
    });
    var standardizedStats = {};
    if (ssrcReport) {
        standardizedStats.timestamp = Math.round(Number(ssrcReport.timestamp));
        standardizedStats = ssrcReport.names().reduce(function (stats, name) {
            switch (name) {
                case 'googCodecName':
                    stats.codecName = ssrcReport.stat(name);
                    break;
                case 'googRtt':
                    stats.roundTripTime = Number(ssrcReport.stat(name));
                    break;
                case 'googJitterReceived':
                    stats.jitter = Number(ssrcReport.stat(name));
                    break;
                case 'googFrameWidthInput':
                    stats.frameWidthInput = Number(ssrcReport.stat(name));
                    break;
                case 'googFrameHeightInput':
                    stats.frameHeightInput = Number(ssrcReport.stat(name));
                    break;
                case 'googFrameWidthSent':
                    stats.frameWidthSent = Number(ssrcReport.stat(name));
                    break;
                case 'googFrameHeightSent':
                    stats.frameHeightSent = Number(ssrcReport.stat(name));
                    break;
                case 'googFrameWidthReceived':
                    stats.frameWidthReceived = Number(ssrcReport.stat(name));
                    break;
                case 'googFrameHeightReceived':
                    stats.frameHeightReceived = Number(ssrcReport.stat(name));
                    break;
                case 'googFrameRateInput':
                    stats.frameRateInput = Number(ssrcReport.stat(name));
                    break;
                case 'googFrameRateSent':
                    stats.frameRateSent = Number(ssrcReport.stat(name));
                    break;
                case 'googFrameRateReceived':
                    stats.frameRateReceived = Number(ssrcReport.stat(name));
                    break;
                case 'ssrc':
                    stats[name] = ssrcReport.stat(name);
                    break;
                case 'bytesReceived':
                case 'bytesSent':
                case 'packetsLost':
                case 'packetsReceived':
                case 'packetsSent':
                case 'audioInputLevel':
                case 'audioOutputLevel':
                    stats[name] = Number(ssrcReport.stat(name));
                    break;
            }
            return stats;
        }, standardizedStats);
    }
    return standardizedStats;
}
/**
 * Standardize the MediaStreamTrack's statistics in Chrome or Safari.
 * @param {RTCStatsResponse} response
 * @returns {Array<StandardizedTrackStatsReport>}
 */
function standardizeChromeOrSafariStats(response) {
    var inbound = null;
    // NOTE(mpatwardhan): We should expect more than one "outbound-rtp" stats for a
    // VP8 simulcast MediaStreamTrack.
    var outbound = [];
    var remoteInbound = null;
    var remoteOutbound = null;
    var track = null;
    var codec = null;
    var localMedia = null;
    response.forEach(function (stat) {
        switch (stat.type) {
            case 'inbound-rtp':
                inbound = stat;
                break;
            case 'outbound-rtp':
                outbound.push(stat);
                break;
            case 'media-source':
                localMedia = stat;
                break;
            case 'track':
                track = stat;
                break;
            case 'codec':
                codec = stat;
                break;
            case 'remote-inbound-rtp':
                remoteInbound = stat;
                break;
            case 'remote-outbound-rtp':
                remoteOutbound = stat;
                break;
        }
    });
    var isRemote = track && track.remoteSource;
    var mainSources = isRemote ? [inbound] : outbound;
    var stats = [];
    var remoteSource = isRemote ? remoteOutbound : remoteInbound; // remote rtp stats
    mainSources.forEach(function (source) {
        var standardizedStats = {};
        var statSources = [
            source,
            localMedia,
            track,
            codec,
            remoteSource && remoteSource.ssrc === source.ssrc ? remoteSource : null, // remote rtp stats
        ];
        function getStatValue(name) {
            var sourceFound = statSources.find(function (statSource) {
                return statSource && typeof statSource[name] !== 'undefined';
            }) || null;
            return sourceFound ? sourceFound[name] : null;
        }
        var ssrc = getStatValue('ssrc');
        if (typeof ssrc === 'number') {
            standardizedStats.ssrc = String(ssrc);
        }
        var timestamp = getStatValue('timestamp');
        standardizedStats.timestamp = Math.round(timestamp);
        var mimeType = getStatValue('mimeType');
        if (typeof mimeType === 'string') {
            mimeType = mimeType.split('/');
            standardizedStats.codecName = mimeType[mimeType.length - 1];
        }
        var roundTripTime = getStatValue('roundTripTime');
        if (typeof roundTripTime === 'number') {
            standardizedStats.roundTripTime = Math.round(roundTripTime * 1000);
        }
        var jitter = getStatValue('jitter');
        if (typeof jitter === 'number') {
            standardizedStats.jitter = Math.round(jitter * 1000);
        }
        var frameWidth = getStatValue('frameWidth');
        if (typeof frameWidth === 'number') {
            if (isRemote) {
                standardizedStats.frameWidthReceived = frameWidth;
            }
            else {
                standardizedStats.frameWidthSent = frameWidth;
                standardizedStats.frameWidthInput = track.frameWidth;
            }
        }
        var frameHeight = getStatValue('frameHeight');
        if (typeof frameHeight === 'number') {
            if (isRemote) {
                standardizedStats.frameHeightReceived = frameHeight;
            }
            else {
                standardizedStats.frameHeightSent = frameHeight;
                standardizedStats.frameHeightInput = track.frameHeight;
            }
        }
        var framesPerSecond = getStatValue('framesPerSecond');
        if (typeof framesPerSecond === 'number') {
            standardizedStats[isRemote ? 'frameRateReceived' : 'frameRateSent'] = framesPerSecond;
        }
        var bytesReceived = getStatValue('bytesReceived');
        if (typeof bytesReceived === 'number') {
            standardizedStats.bytesReceived = bytesReceived;
        }
        var bytesSent = getStatValue('bytesSent');
        if (typeof bytesSent === 'number') {
            standardizedStats.bytesSent = bytesSent;
        }
        var packetsLost = getStatValue('packetsLost');
        if (typeof packetsLost === 'number') {
            standardizedStats.packetsLost = packetsLost;
        }
        var packetsReceived = getStatValue('packetsReceived');
        if (typeof packetsReceived === 'number') {
            standardizedStats.packetsReceived = packetsReceived;
        }
        var packetsSent = getStatValue('packetsSent');
        if (typeof packetsSent === 'number') {
            standardizedStats.packetsSent = packetsSent;
        }
        var audioLevel = getStatValue('audioLevel');
        if (typeof audioLevel === 'number') {
            audioLevel = Math.round(audioLevel * CHROME_LEGACY_MAX_AUDIO_LEVEL);
            if (isRemote) {
                standardizedStats.audioOutputLevel = audioLevel;
            }
            else {
                standardizedStats.audioInputLevel = audioLevel;
            }
        }
        var totalPacketSendDalay = getStatValue('totalPacketSendDelay');
        if (typeof totalPacketSendDalay === 'number') {
            standardizedStats.totalPacketSendDelay = totalPacketSendDalay;
        }
        var totalEncodeTime = getStatValue('totalEncodeTime');
        if (typeof totalEncodeTime === 'number') {
            standardizedStats.totalEncodeTime = totalEncodeTime;
        }
        var framesEncoded = getStatValue('framesEncoded');
        if (typeof framesEncoded === 'number') {
            standardizedStats.framesEncoded = framesEncoded;
        }
        var estimatedPlayoutTimestamp = getStatValue('estimatedPlayoutTimestamp');
        if (typeof estimatedPlayoutTimestamp === 'number') {
            standardizedStats.estimatedPlayoutTimestamp = estimatedPlayoutTimestamp;
        }
        var totalDecodeTime = getStatValue('totalDecodeTime');
        if (typeof totalDecodeTime === 'number') {
            standardizedStats.totalDecodeTime = totalDecodeTime;
        }
        var framesDecoded = getStatValue('framesDecoded');
        if (typeof framesDecoded === 'number') {
            standardizedStats.framesDecoded = framesDecoded;
        }
        var jitterBufferDelay = getStatValue('jitterBufferDelay');
        if (typeof jitterBufferDelay === 'number') {
            standardizedStats.jitterBufferDelay = jitterBufferDelay;
        }
        var jitterBufferEmittedCount = getStatValue('jitterBufferEmittedCount');
        if (typeof jitterBufferEmittedCount === 'number') {
            standardizedStats.jitterBufferEmittedCount = jitterBufferEmittedCount;
        }
        stats.push(standardizedStats);
    });
    return stats;
}
/**
 * Standardize the MediaStreamTrack's statistics in Firefox.
 * @param {RTCStatsReport} response
 * @param {boolean} isRemote
 * @returns {StandardizedTrackStatsReport}
 */
function standardizeFirefoxStats(response, isRemote) {
    // NOTE(mroberts): If getStats is called on a closed RTCPeerConnection,
    // Firefox returns undefined instead of an RTCStatsReport. We workaround this
    // here. See the following bug for more details:
    //
    //   https://bugzilla.mozilla.org/show_bug.cgi?id=1377225
    //
    response = response || new Map();
    var inbound = null;
    var outbound = null;
    // NOTE(mmalavalli): Starting from Firefox 63, RTC{Inbound, Outbound}RTPStreamStats.isRemote
    // will be deprecated, followed by its removal in Firefox 66. Also, trying to
    // access members of the remote RTC{Inbound, Outbound}RTPStreamStats without
    // using RTCStatsReport.get(remoteId) will trigger console warnings. So, we
    // no longer depend on "isRemote", and we call RTCStatsReport.get(remoteId)
    // to access the remote RTC{Inbound, Outbound}RTPStreamStats.
    //
    // Source: https://blog.mozilla.org/webrtc/getstats-isremote-65/
    //
    response.forEach(function (stat) {
        if (stat.isRemote) {
            return;
        }
        switch (stat.type) {
            case 'inbound-rtp':
                inbound = stat;
                outbound = response.get(stat.remoteId);
                break;
            case 'outbound-rtp':
                outbound = stat;
                inbound = response.get(stat.remoteId);
                break;
        }
    });
    var first = isRemote ? inbound : outbound;
    var second = isRemote ? outbound : inbound;
    function getStatValue(name) {
        if (first && typeof first[name] !== 'undefined') {
            return first[name];
        }
        if (second && typeof second[name] !== 'undefined') {
            return second[name];
        }
        return null;
    }
    var standardizedStats = {};
    var timestamp = getStatValue('timestamp');
    standardizedStats.timestamp = Math.round(timestamp);
    var ssrc = getStatValue('ssrc');
    if (typeof ssrc === 'number') {
        standardizedStats.ssrc = String(ssrc);
    }
    var bytesSent = getStatValue('bytesSent');
    if (typeof bytesSent === 'number') {
        standardizedStats.bytesSent = bytesSent;
    }
    var packetsLost = getStatValue('packetsLost');
    if (typeof packetsLost === 'number') {
        standardizedStats.packetsLost = packetsLost;
    }
    var packetsSent = getStatValue('packetsSent');
    if (typeof packetsSent === 'number') {
        standardizedStats.packetsSent = packetsSent;
    }
    var roundTripTime = getStatValue('roundTripTime');
    if (typeof roundTripTime === 'number') {
        // roundTripTime is double - measured in seconds.
        // https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteinboundrtpstreamstats-roundtriptime
        // cover it to milliseconds (and make it integer)
        standardizedStats.roundTripTime = Math.round(roundTripTime * 1000);
    }
    var jitter = getStatValue('jitter');
    if (typeof jitter === 'number') {
        standardizedStats.jitter = Math.round(jitter * 1000);
    }
    var frameRateSent = getStatValue('framerateMean');
    if (typeof frameRateSent === 'number') {
        standardizedStats.frameRateSent = Math.round(frameRateSent);
    }
    var bytesReceived = getStatValue('bytesReceived');
    if (typeof bytesReceived === 'number') {
        standardizedStats.bytesReceived = bytesReceived;
    }
    var packetsReceived = getStatValue('packetsReceived');
    if (typeof packetsReceived === 'number') {
        standardizedStats.packetsReceived = packetsReceived;
    }
    var frameRateReceived = getStatValue('framerateMean');
    if (typeof frameRateReceived === 'number') {
        standardizedStats.frameRateReceived = Math.round(frameRateReceived);
    }
    var totalPacketSendDalay = getStatValue('totalPacketSendDelay');
    if (typeof totalPacketSendDalay === 'number') {
        standardizedStats.totalPacketSendDelay = totalPacketSendDalay;
    }
    var totalEncodeTime = getStatValue('totalEncodeTime');
    if (typeof totalEncodeTime === 'number') {
        standardizedStats.totalEncodeTime = totalEncodeTime;
    }
    var framesEncoded = getStatValue('framesEncoded');
    if (typeof framesEncoded === 'number') {
        standardizedStats.framesEncoded = framesEncoded;
    }
    var estimatedPlayoutTimestamp = getStatValue('estimatedPlayoutTimestamp');
    if (typeof estimatedPlayoutTimestamp === 'number') {
        standardizedStats.estimatedPlayoutTimestamp = estimatedPlayoutTimestamp;
    }
    var totalDecodeTime = getStatValue('totalDecodeTime');
    if (typeof totalDecodeTime === 'number') {
        standardizedStats.totalDecodeTime = totalDecodeTime;
    }
    var framesDecoded = getStatValue('framesDecoded');
    if (typeof framesDecoded === 'number') {
        standardizedStats.framesDecoded = framesDecoded;
    }
    var jitterBufferDelay = getStatValue('jitterBufferDelay');
    if (typeof jitterBufferDelay === 'number') {
        standardizedStats.jitterBufferDelay = jitterBufferDelay;
    }
    var jitterBufferEmittedCount = getStatValue('jitterBufferEmittedCount');
    if (typeof jitterBufferEmittedCount === 'number') {
        standardizedStats.jitterBufferEmittedCount = jitterBufferEmittedCount;
    }
    return standardizedStats;
}
/**
 * Standardized RTCIceCandidate statistics.
 * @typedef {object} StandardizedIceCandidateStatsReport
 * @property {'host'|'prflx'|'relay'|'srflx'} candidateType
 * @property {string} ip
 * @property {number} port
 * @property {number} priority
 * @property {'tcp'|'udp'} protocol
 * @property {string} url
 */
/**
 * Standardized local RTCIceCandidate statistics.
 * @typedef {StandardizedIceCandidateStatsReport} StandardizedLocalIceCandidateStatsReport
 * @property {boolean} [deleted=false]
 * @property {'tcp'|'tls'|'udp'} relayProtocol
 */
/**
 * Standardized active RTCIceCandidate pair statistics.
 * @typedef {object} StandardizedActiveIceCandidatePairStatsReport
 * @property {number} availableIncomingBitrate
 * @property {number} availableOutgoingBitrate
 * @property {number} bytesReceived
 * @property {number} bytesSent
 * @property {number} consentRequestsSent
 * @property {number} currentRoundTripTime
 * @property {number} lastPacketReceivedTimestamp
 * @property {number} lastPacketSentTimestamp
 * @property {StandardizedLocalIceCandidateStatsReport} localCandidate
 * @property {boolean} nominated
 * @property {number} priority
 * @property {boolean} readable
 * @property {StandardizedIceCandidateStatsReport} remoteCandidate
 * @property {number} requestsReceived
 * @property {number} requestsSent
 * @property {number} responsesReceived
 * @property {number} responsesSent
 * @property {number} retransmissionsReceived
 * @property {number} retransmissionsSent
 * @property {'frozen'|'waiting'|'in-progress'|'failed'|'succeeded'} state
 * @property {number} totalRoundTripTime
 * @property {string} transportId
 * @property {boolean} writable
 */
/**
 * Standardized {@link RTCPeerConnection} statistics.
 * @typedef {Object} StandardizedStatsResponse
 * @property {StandardizedActiveIceCandidatePairStatsReport} activeIceCandidatePair - Stats for active ICE candidate pair
 * @property Array<StandardizedTrackStatsReport> localAudioTrackStats - Stats for local audio MediaStreamTracks
 * @property Array<StandardizedTrackStatsReport> localVideoTrackStats - Stats for local video MediaStreamTracks
 * @property Array<StandardizedTrackStatsReport> remoteAudioTrackStats - Stats for remote audio MediaStreamTracks
 * @property Array<StandardizedTrackStatsReport> remoteVideoTrackStats - Stats for remote video MediaStreamTracks
 */
/**
 * Standardized MediaStreamTrack statistics.
 * @typedef {Object} StandardizedTrackStatsReport
 * @property {string} trackId - MediaStreamTrack ID
 * @property {string} ssrc - SSRC of the MediaStreamTrack
 * @property {number} timestamp - The Unix timestamp in milliseconds
 * @property {string} [codecName] - Name of the codec used to encode the MediaStreamTrack's media
 * @property {number} [roundTripTime] - Round trip time in milliseconds
 * @property {number} [jitter] - Jitter in milliseconds
 * @property {number} [frameWidthInput] - Width in pixels of the local video MediaStreamTrack's captured frame
 * @property {number} [frameHeightInput] - Height in pixels of the local video MediaStreamTrack's captured frame
 * @property {number} [frameWidthSent] - Width in pixels of the local video MediaStreamTrack's encoded frame
 * @property {number} [frameHeightSent] - Height in pixels of the local video MediaStreamTrack's encoded frame
 * @property {number} [frameWidthReceived] - Width in pixels of the remote video MediaStreamTrack's received frame
 * @property {number} [frameHeightReceived] - Height in pixels of the remote video MediaStreamTrack's received frame
 * @property {number} [frameRateInput] - Captured frames per second of the local video MediaStreamTrack
 * @property {number} [frameRateSent] - Frames per second of the local video MediaStreamTrack's encoded video
 * @property {number} [frameRateReceived] - Frames per second of the remote video MediaStreamTrack's received video
 * @property {number} [bytesReceived] - Number of bytes of the remote MediaStreamTrack's media received
 * @property {number} [bytesSent] - Number of bytes of the local MediaStreamTrack's media sent
 * @property {number} [packetsLost] - Number of packets of the MediaStreamTrack's media lost
 * @property {number} [packetsReceived] - Number of packets of the remote MediaStreamTrack's media received
 * @property {number} [packetsSent] - Number of packets of the local MediaStreamTrack's media sent
 * @property {number} [totalPacketSendDelay] - The total number of seconds that the local MediaStreamTrack's packets
 *  have spent buffered locally before being sent over the network
 * @property {number} [totalEncodeTime] - The total number of seconds spent on encoding the local MediaStreamTrack's frames
 * @property {number} [framesEncoded] - The total number of frames of the local MediaStreamTrack that have been encoded sor far
 * @property {number} [estimatedPlayoutTimestamp] - The estimated playout time of the remote MediaStreamTrack
 * @property {number} [totalDecodeTime] - The total number of seconds spent on decoding the remote MediaStreamTrack's frames
 * @property {number} [framesDecoded] - The total number of frames of the remote MediaStreamTrack that have been decoded sor far
 * @property {number} [jitterBufferDelay] - The sum of the time, in seconds, each audio sample or a video frame of the remote
 *   MediaStreamTrack takes from the time the first packet is received by the jitter buffer to the time it exits the jitter buffer
 * @property {number} [jitterBufferEmittedCount] - The total number of audio samples or video frames that have come out of the jitter buffer
 * @property {AudioLevel} [audioInputLevel] - The {@link AudioLevel} of the local audio MediaStreamTrack
 * @property {AudioLevel} [audioOutputLevel] - The {@link AudioLevel} of the remote video MediaStreamTrack
 */
module.exports = getStats;
//# sourceMappingURL=getstats.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/getusermedia.js":
/*!**************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/getusermedia.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals navigator */

/**
 * This function is very similar to <code>navigator.mediaDevices.getUserMedia</code>
 * except that if no MediaStreamConstraints are provided, then bot audio and video
 * are requested.
 * @function getUserMedia
 * @param {MediaStreamConstraints} [constraints={audio:true,video:true}] - the
 *   MediaStreamConstraints object specifying what kind of MediaStream to
 *   request from the browser (by default both audio and video)
 * @returns Promise<MediaStream>
 */
function getUserMedia(constraints) {
    if (typeof navigator === 'object'
        && typeof navigator.mediaDevices === 'object'
        && typeof navigator.mediaDevices.getUserMedia === 'function') {
        constraints = constraints || { audio: true, video: true };
        return navigator.mediaDevices.getUserMedia(constraints);
    }
    return Promise.reject(new Error('getUserMedia is not supported'));
}
module.exports = getUserMedia;
//# sourceMappingURL=getusermedia.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var WebRTC = {};
Object.defineProperties(WebRTC, {
    getStats: {
        enumerable: true,
        value: __webpack_require__(/*! ./getstats */ "./node_modules/twilio-video/es5/webrtc/getstats.js")
    },
    getUserMedia: {
        enumerable: true,
        value: __webpack_require__(/*! ./getusermedia */ "./node_modules/twilio-video/es5/webrtc/getusermedia.js")
    },
    MediaStream: {
        enumerable: true,
        value: __webpack_require__(/*! ./mediastream */ "./node_modules/twilio-video/es5/webrtc/mediastream.js")
    },
    MediaStreamTrack: {
        enumerable: true,
        value: __webpack_require__(/*! ./mediastreamtrack */ "./node_modules/twilio-video/es5/webrtc/mediastreamtrack.js")
    },
    RTCIceCandidate: {
        enumerable: true,
        value: __webpack_require__(/*! ./rtcicecandidate */ "./node_modules/twilio-video/es5/webrtc/rtcicecandidate.js")
    },
    RTCPeerConnection: {
        enumerable: true,
        value: __webpack_require__(/*! ./rtcpeerconnection */ "./node_modules/twilio-video/es5/webrtc/rtcpeerconnection/index.js")
    },
    RTCSessionDescription: {
        enumerable: true,
        value: __webpack_require__(/*! ./rtcsessiondescription */ "./node_modules/twilio-video/es5/webrtc/rtcsessiondescription/index.js")
    }
});
module.exports = WebRTC;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/mediastream.js":
/*!*************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/mediastream.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals MediaStream */

if (typeof MediaStream === 'function') {
    module.exports = MediaStream;
}
else {
    module.exports = function MediaStream() {
        throw new Error('MediaStream is not supported');
    };
}
//# sourceMappingURL=mediastream.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/mediastreamtrack.js":
/*!******************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/mediastreamtrack.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global MediaStreamTrack */

if (typeof MediaStreamTrack === 'function') {
    module.exports = MediaStreamTrack;
}
else {
    module.exports = function MediaStreamTrack() {
        throw new Error('MediaStreamTrack is not supported');
    };
}
//# sourceMappingURL=mediastreamtrack.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/rtcicecandidate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/rtcicecandidate.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global RTCIceCandidate */

if (typeof RTCIceCandidate === 'function') {
    module.exports = RTCIceCandidate;
}
else {
    module.exports = function RTCIceCandidate() {
        throw new Error('RTCIceCandidate is not supported');
    };
}
//# sourceMappingURL=rtcicecandidate.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/rtcpeerconnection/chrome.js":
/*!**************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/rtcpeerconnection/chrome.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCDataChannel, RTCPeerConnection, RTCSessionDescription */

var ChromeRTCSessionDescription = __webpack_require__(/*! ../rtcsessiondescription/chrome */ "./node_modules/twilio-video/es5/webrtc/rtcsessiondescription/chrome.js");
var EventTarget = __webpack_require__(/*! ../util/eventtarget */ "./node_modules/twilio-video/es5/webrtc/util/eventtarget.js");
var inherits = __webpack_require__(/*! util */ "./node_modules/util/util.js").inherits;
var Latch = __webpack_require__(/*! ../util/latch */ "./node_modules/twilio-video/es5/webrtc/util/latch.js");
var MediaStream = __webpack_require__(/*! ../mediastream */ "./node_modules/twilio-video/es5/webrtc/mediastream.js");
var RTCRtpSenderShim = __webpack_require__(/*! ../rtcrtpsender */ "./node_modules/twilio-video/es5/webrtc/rtcrtpsender.js");
var sdpUtils = __webpack_require__(/*! ../util/sdp */ "./node_modules/twilio-video/es5/webrtc/util/sdp.js");
var util = __webpack_require__(/*! ../util */ "./node_modules/twilio-video/es5/webrtc/util/index.js");
var isIOSChrome = __webpack_require__(/*! ../util */ "./node_modules/twilio-video/es5/webrtc/util/index.js").isIOSChrome;
var isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified';
// NOTE(mroberts): This class wraps Chrome's RTCPeerConnection implementation.
// It provides some functionality not currently present in Chrome, namely the
// abilities to
//
//   1. Rollback, per the workaround suggested here:
//      https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3
//
//   2. Listen for track events, per the adapter.js workaround.
//
//   3. Set iceTransportPolicy.
//
function ChromeRTCPeerConnection(configuration, constraints) {
    if (!(this instanceof ChromeRTCPeerConnection)) {
        return new ChromeRTCPeerConnection(configuration, constraints);
    }
    EventTarget.call(this);
    configuration = configuration || {};
    var newConfiguration = Object.assign(configuration.iceTransportPolicy
        ? { iceTransports: configuration.iceTransportPolicy }
        : {}, configuration);
    util.interceptEvent(this, 'datachannel');
    util.interceptEvent(this, 'signalingstatechange');
    var sdpFormat = sdpUtils.getSdpFormat(newConfiguration.sdpSemantics);
    var peerConnection = new RTCPeerConnection(newConfiguration, constraints);
    Object.defineProperties(this, {
        _appliedTracksToSSRCs: {
            value: new Map(),
            writable: true
        },
        _localStream: {
            value: new MediaStream()
        },
        _peerConnection: {
            value: peerConnection
        },
        _pendingLocalOffer: {
            value: null,
            writable: true
        },
        _pendingRemoteOffer: {
            value: null,
            writable: true
        },
        _rolledBackTracksToSSRCs: {
            value: new Map(),
            writable: true
        },
        _sdpFormat: {
            value: sdpFormat
        },
        _senders: {
            value: new Map()
        },
        _signalingStateLatch: {
            value: new Latch()
        },
        _tracksToSSRCs: {
            value: new Map(),
            writable: true
        },
        localDescription: {
            enumerable: true,
            get: function () {
                return this._pendingLocalOffer ? this._pendingLocalOffer : peerConnection.localDescription;
            }
        },
        remoteDescription: {
            enumerable: true,
            get: function () {
                return this._pendingRemoteOffer ? this._pendingRemoteOffer : peerConnection.remoteDescription;
            }
        },
        signalingState: {
            enumerable: true,
            get: function () {
                if (this._pendingLocalOffer) {
                    return 'have-local-offer';
                }
                else if (this._pendingRemoteOffer) {
                    return 'have-remote-offer';
                }
                return peerConnection.signalingState;
            }
        }
    });
    var self = this;
    peerConnection.addEventListener('datachannel', function ondatachannel(event) {
        shimDataChannel(event.channel);
        self.dispatchEvent(event);
    });
    peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {
        if (peerConnection.signalingState === 'stable') {
            self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);
        }
        if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {
            self.dispatchEvent.apply(self, arguments);
        }
    });
    peerConnection.ontrack = function ontrack() {
        // NOTE(mroberts): adapter.js's "track" event shim only kicks off if we set
        // the ontrack property of the RTCPeerConnection.
    };
    if (typeof RTCPeerConnection.prototype.addTrack !== 'function') {
        peerConnection.addStream(this._localStream);
    }
    util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);
}
inherits(ChromeRTCPeerConnection, EventTarget);
if (typeof RTCPeerConnection.prototype.addTrack !== 'function') {
    // NOTE(mmalavalli): This shim supports our limited case of adding
    // all MediaStreamTracks to one MediaStream. It has been implemented this
    // keeping in mind that this is to be maintained only until "addTrack" is
    // supported natively in Chrome.
    ChromeRTCPeerConnection.prototype.addTrack = function addTrack() {
        var args = [].slice.call(arguments);
        var track = args[0];
        if (this._peerConnection.signalingState === 'closed') {
            throw new Error('Cannot add MediaStreamTrack [' + track.id + ', '
                + track.kind + ']: RTCPeerConnection is closed');
        }
        var sender = this._senders.get(track);
        if (sender && sender.track) {
            throw new Error('Cannot add MediaStreamTrack [' + track.id + ', '
                + track.kind + ']: RTCPeerConnection already has it');
        }
        this._peerConnection.removeStream(this._localStream);
        this._localStream.addTrack(track);
        this._peerConnection.addStream(this._localStream);
        sender = new RTCRtpSenderShim(track);
        this._senders.set(track, sender);
        return sender;
    };
    // NOTE(mmalavalli): This shim supports our limited case of removing
    // MediaStreamTracks from one MediaStream. It has been implemented this
    // keeping in mind that this is to be maintained only until "removeTrack" is
    // supported natively in Chrome.
    ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
        if (this._peerConnection.signalingState === 'closed') {
            throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');
        }
        var track = sender.track;
        if (!track) {
            return;
        }
        sender = this._senders.get(track);
        if (sender && sender.track) {
            sender.track = null;
            this._peerConnection.removeStream(this._localStream);
            this._localStream.removeTrack(track);
            this._peerConnection.addStream(this._localStream);
        }
    };
    ChromeRTCPeerConnection.prototype.getSenders = function getSenders() {
        return Array.from(this._senders.values());
    };
}
else {
    ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
        if (this._peerConnection.signalingState === 'closed') {
            throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');
        }
        try {
            this._peerConnection.removeTrack(sender);
        }
        catch (e) {
            // NOTE(mhuynh): Do nothing. In Chrome, will throw if a 'sender was not
            // created by this peer connection'. This behavior does not seem to be
            // spec compliant, so a temporary shim is introduced. A bug has been filed,
            // and is tracked here:
            // https://bugs.chromium.org/p/chromium/issues/detail?id=860853
        }
    };
}
ChromeRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {
    var args = [].slice.call(arguments);
    var promise;
    var self = this;
    if (this.signalingState === 'have-remote-offer') {
        // NOTE(mroberts): Because the ChromeRTCPeerConnection simulates the
        // "have-remote-offer" signalingStates, we only want to invoke the true
        // addIceCandidates method when the remote description has been applied.
        promise = this._signalingStateLatch.when('low').then(function signalingStatesResolved() {
            return self._peerConnection.addIceCandidate(candidate);
        });
    }
    else {
        promise = this._peerConnection.addIceCandidate(candidate);
    }
    return args.length > 1
        ? util.legacyPromise(promise, args[1], args[2])
        : promise;
};
// NOTE(mroberts): The WebRTC spec does not specify that close should throw an
// Error; however, in Chrome it does. We workaround this by checking the
// signalingState manually.
ChromeRTCPeerConnection.prototype.close = function close() {
    if (this.signalingState !== 'closed') {
        this._pendingLocalOffer = null;
        this._pendingRemoteOffer = null;
        this._peerConnection.close();
    }
};
// NOTE(mroberts): Because we workaround Chrome's lack of rollback support by
// "faking" setRemoteDescription, we cannot create an answer until we actually
// apply the remote description. This means, once you call createAnswer, you
// can no longer rollback. This is acceptable for our use case because we will
// apply the newly-created answer almost immediately; however, this may be
// unacceptable for other use cases.
ChromeRTCPeerConnection.prototype.createAnswer = function createAnswer() {
    var args = [].slice.call(arguments);
    var promise;
    var self = this;
    if (this._pendingRemoteOffer) {
        promise = this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {
            // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection
            // and the underlying RTCPeerConnection implementation have converged. We
            // can unblock any pending calls to addIceCandidate now.
            self._signalingStateLatch.lower();
            return self._peerConnection.createAnswer();
        }).then(function createAnswerSucceeded(answer) {
            self._pendingRemoteOffer = null;
            // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no
            // longer need to retain the rolled back tracks to SSRCs Map.
            self._rolledBackTracksToSSRCs.clear();
            return new ChromeRTCSessionDescription({
                type: 'answer',
                sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)
            });
        }, function setRemoteDescriptionOrCreateAnswerFailed(error) {
            self._pendingRemoteOffer = null;
            throw error;
        });
    }
    else {
        promise = this._peerConnection.createAnswer().then(function (answer) {
            // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no
            // longer need to retain the rolled back tracks to SSRCs Map.
            self._rolledBackTracksToSSRCs.clear();
            return new ChromeRTCSessionDescription({
                type: 'answer',
                sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)
            });
        });
    }
    return args.length > 1
        ? util.legacyPromise(promise, args[0], args[1])
        : promise;
};
ChromeRTCPeerConnection.prototype.createOffer = function createOffer() {
    var args = [].slice.call(arguments);
    var options = (args.length > 1 ? args[2] : args[0]) || {};
    var self = this;
    if (isIOSChrome()) {
        // NOTE (joma): From SafariRTCPeerConnection in order to support iOS Chrome.
        if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {
            delete options.offerToReceiveAudio;
            try {
                this._audioTransceiver = isUnifiedPlan
                    ? this.addTransceiver('audio', { direction: 'recvonly' })
                    : this.addTransceiver('audio');
            }
            catch (e) {
                return Promise.reject(e);
            }
        }
        if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {
            delete options.offerToReceiveVideo;
            try {
                this._videoTransceiver = isUnifiedPlan
                    ? this.addTransceiver('video', { direction: 'recvonly' })
                    : this.addTransceiver('video');
            }
            catch (e) {
                return Promise.reject(e);
            }
        }
    }
    var promise = this._peerConnection.createOffer(options).then(function (offer) {
        // NOTE(mmalavalli): If createOffer() is called immediately after rolling back, then we no
        // longer need to retain the rolled back tracks to SSRCs Map.
        self._rolledBackTracksToSSRCs.clear();
        return new ChromeRTCSessionDescription({
            type: offer.type,
            sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, offer.sdp)
        });
    });
    return args.length > 1
        ? util.legacyPromise(promise, args[0], args[1])
        : promise;
};
ChromeRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {
    dataChannelDict = shimDataChannelInit(dataChannelDict);
    var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);
    shimDataChannel(dataChannel);
    return dataChannel;
};
ChromeRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    var args = [].slice.call(arguments);
    var description = args[0];
    // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,
    // then we need to restore the rolled back tracks to SSRCs Map.
    if (this._rolledBackTracksToSSRCs.size > 0) {
        this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);
        this._rolledBackTracksToSSRCs.clear();
    }
    var promise = setDescription(this, true, description);
    return args.length > 1
        ? util.legacyPromise(promise, args[1], args[2])
        : promise;
};
ChromeRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
    var args = [].slice.call(arguments);
    var description = args[0];
    // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,
    // then we no longer need to retain the rolled back tracks to SSRCs Map.
    this._rolledBackTracksToSSRCs.clear();
    var promise = setDescription(this, false, description);
    return args.length > 1
        ? util.legacyPromise(promise, args[1], args[2])
        : promise;
};
util.delegateMethods(RTCPeerConnection.prototype, ChromeRTCPeerConnection.prototype, '_peerConnection');
// NOTE(mroberts): We workaround Chrome's lack of rollback support, per the
// workaround suggested here: https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3
// Namely, we "fake" setting the local or remote description and instead buffer
// it. If we receive or create an answer, then we will actually apply the
// description. Until we receive or create an answer, we will be able to
// "rollback" by simply discarding the buffer description.
function setDescription(peerConnection, local, description) {
    function setPendingLocalOffer(offer) {
        if (local) {
            peerConnection._pendingLocalOffer = offer;
        }
        else {
            peerConnection._pendingRemoteOffer = offer;
        }
    }
    function clearPendingLocalOffer() {
        if (local) {
            peerConnection._pendingLocalOffer = null;
        }
        else {
            peerConnection._pendingRemoteOffer = null;
        }
    }
    var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;
    var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;
    var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';
    var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';
    var promise;
    if (!local && pendingRemoteOffer && description.type === 'answer') {
        promise = setRemoteAnswer(peerConnection, description);
    }
    else if (description.type === 'offer') {
        if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {
            // NOTE(mroberts): Error message copied from Firefox.
            return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') +
                ' offer in state ' + peerConnection.signalingState));
        }
        // We need to save this local offer in case of a rollback. We also need to
        // check to see if the signalingState between the ChromeRTCPeerConnection
        // and the underlying RTCPeerConnection implementation are about to diverge.
        // If so, we need to ensure subsequent calls to addIceCandidate will block.
        if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {
            peerConnection._signalingStateLatch.raise();
        }
        var previousSignalingState = peerConnection.signalingState;
        setPendingLocalOffer(unwrap(description));
        promise = Promise.resolve();
        // Only dispatch a signalingstatechange event if we transitioned.
        if (peerConnection.signalingState !== previousSignalingState) {
            promise.then(function dispatchSignalingStateChangeEvent() {
                peerConnection.dispatchEvent(new Event('signalingstatechange'));
            });
        }
    }
    else if (description.type === 'rollback') {
        if (peerConnection.signalingState !== intermediateState) {
            // NOTE(mroberts): Error message copied from Firefox.
            promise = Promise.reject(new Error('Cannot rollback ' +
                (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));
        }
        else {
            // Reset the pending offer.
            clearPendingLocalOffer();
            // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case
            // setLocalDescription() is called immediately after a rollback (without calling
            // createOffer() or createAnswer()), in which case this roll back is not due to a
            // glare scenario and this Map should be restored.
            peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);
            peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);
            promise = Promise.resolve();
            promise.then(function dispatchSignalingStateChangeEvent() {
                peerConnection.dispatchEvent(new Event('signalingstatechange'));
            });
        }
    }
    return promise || peerConnection._peerConnection[setLocalDescription](unwrap(description));
}
function setRemoteAnswer(peerConnection, answer) {
    // Apply the pending local offer.
    var pendingLocalOffer = peerConnection._pendingLocalOffer;
    return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {
        peerConnection._pendingLocalOffer = null;
        return peerConnection.setRemoteDescription(answer);
    }).then(function setRemoteAnswerSucceeded() {
        // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection
        // and the underlying RTCPeerConnection implementation have converged. We
        // can unblock any pending calls to addIceCandidate now.
        peerConnection._signalingStateLatch.lower();
    });
}
/**
 * Whether a ChromeRTCPeerConnection has any RTCRtpReceivers(s) for the given
 * MediaStreamTrack kind.
 * @param {ChromeRTCPeerConnection} peerConnection
 * @param {'audio' | 'video'} kind
 * @returns {boolean}
 */
function hasReceiversForTracksOfKind(peerConnection, kind) {
    return !!peerConnection.getTransceivers().find(function (transceiver) {
        return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;
    });
}
function unwrap(description) {
    if (description instanceof ChromeRTCSessionDescription) {
        if (description._description) {
            return description._description;
        }
    }
    return new RTCSessionDescription(description);
}
/**
 * Check whether or not we need to apply our maxPacketLifeTime shim. We are
 * pretty conservative: we'll only apply it if the legacy maxRetransmitTime
 * property is available _and_ the standard maxPacketLifeTime property is _not_
 * available (the thinking being that Chrome will land the standards-compliant
 * property).
 * @returns {boolean}
 */
function needsMaxPacketLifeTimeShim() {
    return 'maxRetransmitTime' in RTCDataChannel.prototype
        && !('maxPacketLifeTime' in RTCDataChannel.prototype);
}
/**
 * Shim an RTCDataChannelInit dictionary (if necessary). This function returns
 * a copy of the original RTCDataChannelInit.
 * @param {RTCDataChannelInit} dataChannelDict
 * @returns {RTCDataChannelInit}
 */
function shimDataChannelInit(dataChannelDict) {
    dataChannelDict = Object.assign({}, dataChannelDict);
    if (needsMaxPacketLifeTimeShim() && 'maxPacketLifeTime' in dataChannelDict) {
        dataChannelDict.maxRetransmitTime = dataChannelDict.maxPacketLifeTime;
    }
    return dataChannelDict;
}
/**
 * Shim an RTCDataChannel (if necessary). This function mutates the
 * RTCDataChannel.
 * @param {RTCDataChannel} dataChannel
 * @returns {RTCDataChannel}
 */
function shimDataChannel(dataChannel) {
    Object.defineProperty(dataChannel, 'maxRetransmits', {
        value: dataChannel.maxRetransmits === 65535
            ? null
            : dataChannel.maxRetransmits
    });
    if (needsMaxPacketLifeTimeShim()) {
        // NOTE(mroberts): We can rename `maxRetransmitTime` to `maxPacketLifeTime`.
        //
        //   https://bugs.chromium.org/p/chromium/issues/detail?id=696681
        //
        Object.defineProperty(dataChannel, 'maxPacketLifeTime', {
            value: dataChannel.maxRetransmitTime === 65535
                ? null
                : dataChannel.maxRetransmitTime
        });
    }
    return dataChannel;
}
/**
 * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both
 * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method
 * ensures that SSRCs never change once announced.
 * @param {'planb'|'unified'} sdpFormat
 * @param {Map<string, Set<string>>} tracksToSSRCs
 * @param {string} sdp - an SDP whose format is determined by `sdpSemantics`
 * @returns {string} updatedSdp - updated SDP
 */
function updateTrackIdsToSSRCs(sdpFormat, tracksToSSRCs, sdp) {
    return sdpFormat === 'unified'
        ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs(tracksToSSRCs, sdp)
        : sdpUtils.updatePlanBTrackIdsToSSRCs(tracksToSSRCs, sdp);
}
module.exports = ChromeRTCPeerConnection;
//# sourceMappingURL=chrome.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/rtcpeerconnection/firefox.js":
/*!***************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/rtcpeerconnection/firefox.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCPeerConnection */

var EventTarget = __webpack_require__(/*! ../util/eventtarget */ "./node_modules/twilio-video/es5/webrtc/util/eventtarget.js");
var FirefoxRTCSessionDescription = __webpack_require__(/*! ../rtcsessiondescription/firefox */ "./node_modules/twilio-video/es5/webrtc/rtcsessiondescription/firefox.js");
var inherits = __webpack_require__(/*! util */ "./node_modules/util/util.js").inherits;
var updateTracksToSSRCs = __webpack_require__(/*! ../util/sdp */ "./node_modules/twilio-video/es5/webrtc/util/sdp.js").updateUnifiedPlanTrackIdsToSSRCs;
var util = __webpack_require__(/*! ../util */ "./node_modules/twilio-video/es5/webrtc/util/index.js");
// NOTE(mroberts): This is a short-lived workaround. Checking the user agent
// string might not fix every affected Firefox instance, but it should be good
// enough for this bug.
var needsWorkaroundForBug1480277 = typeof navigator === 'object'
    && navigator.userAgent
    && (navigator.userAgent.match(/Firefox\/61/) || navigator.userAgent.match(/Firefox\/62/));
// NOTE(mroberts): This class wraps Firefox's RTCPeerConnection implementation.
// It provides some functionality not currently present in Firefox, namely the
// abilities to
//
//   1. Call setLocalDescription and setRemoteDescription with new offers in
//      signalingStates "have-local-offer" and "have-remote-offer",
//      respectively.
//
//   2. The ability to call createOffer in signalingState "have-local-offer".
//
// Both of these are implemented using rollbacks to workaround the following
// bug:
//
//   https://bugzilla.mozilla.org/show_bug.cgi?id=1072388
//
// We also provide a workaround for a bug where Firefox may change the
// previously-negotiated DTLS role in an answer, which breaks Chrome:
//
//     https://bugzilla.mozilla.org/show_bug.cgi?id=1240897
//
function FirefoxRTCPeerConnection(configuration) {
    if (!(this instanceof FirefoxRTCPeerConnection)) {
        return new FirefoxRTCPeerConnection(configuration);
    }
    EventTarget.call(this);
    util.interceptEvent(this, 'signalingstatechange');
    /* eslint new-cap:0 */
    var peerConnection = new RTCPeerConnection(configuration);
    Object.defineProperties(this, {
        _initiallyNegotiatedDtlsRole: {
            value: null,
            writable: true
        },
        _isClosed: {
            value: false,
            writable: true
        },
        _peerConnection: {
            value: peerConnection
        },
        _rollingBack: {
            value: false,
            writable: true
        },
        _tracksToSSRCs: {
            value: new Map()
        },
        iceGatheringState: {
            enumerable: true,
            get: function () {
                return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;
            }
        },
        localDescription: {
            enumerable: true,
            get: function () {
                return overwriteWithInitiallyNegotiatedDtlsRole(this._peerConnection.localDescription, this._initiallyNegotiatedDtlsRole);
            }
        },
        signalingState: {
            enumerable: true,
            get: function () {
                return this._isClosed ? 'closed' : this._peerConnection.signalingState;
            }
        }
    });
    var self = this;
    var previousSignalingState;
    peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {
        if (!self._rollingBack && self.signalingState !== previousSignalingState) {
            previousSignalingState = self.signalingState;
            // NOTE(mmalavalli): In Firefox, 'signalingstatechange' event is
            // triggered synchronously in the same tick after
            // RTCPeerConnection#close() is called. So we mimic Chrome's behavior
            // by triggering 'signalingstatechange' on the next tick.
            var dispatchEventToSelf = self.dispatchEvent.apply.bind(self.dispatchEvent, self, arguments);
            if (self._isClosed) {
                setTimeout(dispatchEventToSelf);
            }
            else {
                dispatchEventToSelf();
            }
        }
    });
    util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);
}
inherits(FirefoxRTCPeerConnection, EventTarget);
// NOTE(mmalavalli): Firefox throws a TypeError when the PeerConnection's
// prototype's "peerIdentity" property is accessed. In order to overcome
// this, we ignore this property while delegating methods.
// Reference: https://bugzilla.mozilla.org/show_bug.cgi?id=1363815
Object.defineProperty(FirefoxRTCPeerConnection.prototype, 'peerIdentity', {
    enumerable: true,
    value: Promise.resolve({
        idp: '',
        name: ''
    })
});
if (needsWorkaroundForBug1480277) {
    FirefoxRTCPeerConnection.prototype.addTrack = function addTrack() {
        var track = arguments[0];
        var sender = this._peerConnection.addTrack.apply(this._peerConnection, arguments);
        sender.replaceTrack(track);
        return sender;
    };
}
FirefoxRTCPeerConnection.prototype.createAnswer = function createAnswer() {
    var args = [].slice.call(arguments);
    var promise;
    var self = this;
    promise = this._peerConnection.createAnswer().then(function createAnswerSucceeded(answer) {
        saveInitiallyNegotiatedDtlsRole(self, answer);
        return overwriteWithInitiallyNegotiatedDtlsRole(answer, self._initiallyNegotiatedDtlsRole);
    });
    return typeof args[0] === 'function'
        ? util.legacyPromise(promise, args[0], args[1])
        : promise;
};
// NOTE(mroberts): The WebRTC spec allows you to call createOffer from any
// signalingState other than "closed"; however, Firefox has not yet implemented
// this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388). We workaround
// this by rolling back if we are in state "have-local-offer" or
// "have-remote-offer". This is acceptable for our use case because we will
// apply the newly-created offer almost immediately; however, this may be
// unacceptable for other use cases.
FirefoxRTCPeerConnection.prototype.createOffer = function createOffer() {
    var args = [].slice.call(arguments);
    var options = (args.length > 1 ? args[2] : args[0]) || {};
    var promise;
    var self = this;
    if (this.signalingState === 'have-local-offer' ||
        this.signalingState === 'have-remote-offer') {
        var local = this.signalingState === 'have-local-offer';
        promise = rollback(this, local, function rollbackSucceeded() {
            return self.createOffer(options);
        });
    }
    else {
        promise = self._peerConnection.createOffer(options);
    }
    promise = promise.then(function (offer) {
        return new FirefoxRTCSessionDescription({
            type: offer.type,
            sdp: updateTracksToSSRCs(self._tracksToSSRCs, offer.sdp)
        });
    });
    return args.length > 1
        ? util.legacyPromise(promise, args[0], args[1])
        : promise;
};
// NOTE(mroberts): While Firefox will reject the Promise returned by
// setLocalDescription when called from signalingState "have-local-offer" with
// an answer, it still updates the .localDescription property. We workaround
// this by explicitly handling this case.
FirefoxRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    var args = [].slice.call(arguments);
    var description = args[0];
    var promise;
    if (description && description.type === 'answer' && this.signalingState === 'have-local-offer') {
        promise = Promise.reject(new Error('Cannot set local answer in state have-local-offer'));
    }
    if (promise) {
        return args.length > 1
            ? util.legacyPromise(promise, args[1], args[2])
            : promise;
    }
    return this._peerConnection.setLocalDescription.apply(this._peerConnection, args);
};
// NOTE(mroberts): The WebRTC spec allows you to call setRemoteDescription with
// an offer multiple times in signalingState "have-remote-offer"; however,
// Firefox has not yet implemented this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388).
// We workaround this by rolling back if we are in state "have-remote-offer".
// This is acceptable for our use case; however, this may be unacceptable for
// other use cases.
//
// While Firefox will reject the Promise returned by setRemoteDescription when
// called from signalingState "have-remote-offer" with an answer, it sill
// updates the .remoteDescription property. We workaround this by explicitly
// handling this case.
FirefoxRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
    var args = [].slice.call(arguments);
    var description = args[0];
    var promise;
    var self = this;
    if (description && this.signalingState === 'have-remote-offer') {
        if (description.type === 'answer') {
            promise = Promise.reject(new Error('Cannot set remote answer in state have-remote-offer'));
        }
        else if (description.type === 'offer') {
            promise = rollback(this, false, function rollbackSucceeded() {
                return self._peerConnection.setRemoteDescription(description);
            });
        }
    }
    if (!promise) {
        promise = this._peerConnection.setRemoteDescription(description);
    }
    promise = promise.then(function setRemoteDescriptionSucceeded() {
        saveInitiallyNegotiatedDtlsRole(self, description, true);
    });
    return args.length > 1
        ? util.legacyPromise(promise, args[1], args[2])
        : promise;
};
// NOTE(mroberts): The WebRTC spec specifies that the PeerConnection's internal
// isClosed slot should immediately be set to true; however, in Firefox it
// occurs in the next tick. We workaround this by tracking isClosed manually.
FirefoxRTCPeerConnection.prototype.close = function close() {
    if (this.signalingState !== 'closed') {
        this._isClosed = true;
        this._peerConnection.close();
    }
};
util.delegateMethods(RTCPeerConnection.prototype, FirefoxRTCPeerConnection.prototype, '_peerConnection');
function rollback(peerConnection, local, onceRolledBack) {
    var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';
    peerConnection._rollingBack = true;
    return peerConnection._peerConnection[setLocalDescription](new FirefoxRTCSessionDescription({
        type: 'rollback'
    })).then(onceRolledBack).then(function onceRolledBackSucceeded(result) {
        peerConnection._rollingBack = false;
        return result;
    }, function rollbackOrOnceRolledBackFailed(error) {
        peerConnection._rollingBack = false;
        throw error;
    });
}
/**
 * Extract the initially negotiated DTLS role out of an RTCSessionDescription's
 * sdp property and save it on the FirefoxRTCPeerConnection if and only if
 *
 *   1. A DTLS role was not already saved on the FirefoxRTCPeerConnection, and
 *   2. The description is an answer.
 *
 * @private
 * @param {FirefoxRTCPeerConnection} peerConnection
 * @param {RTCSessionDescription} description
 * @param {boolean} [remote=false] - if true, save the inverse of the DTLS role,
 *   e.g. "active" instead of "passive" and vice versa
 * @returns {undefined}
 */
function saveInitiallyNegotiatedDtlsRole(peerConnection, description, remote) {
    // NOTE(mroberts): JSEP specifies that offers always offer "actpass" as the
    // DTLS role. We need to inspect answers to figure out the negotiated DTLS
    // role.
    if (peerConnection._initiallyNegotiatedDtlsRole || description.type === 'offer') {
        return;
    }
    var match = description.sdp.match(/a=setup:([a-z]+)/);
    if (!match) {
        return;
    }
    var dtlsRole = match[1];
    peerConnection._initiallyNegotiatedDtlsRole = remote ? {
        active: 'passive',
        passive: 'active'
    }[dtlsRole] : dtlsRole;
}
/**
 * Overwrite the DTLS role in the sdp property of an RTCSessionDescription if
 * and only if
 *
 *   1. The description is an answer, and
 *   2. A DTLS role is provided.
 *
 * @private
 * @param {RTCSessionDescription} [description]
 * @param {string} [dtlsRole] - one of "active" or "passive"
 * @returns {?RTCSessionDescription} description
 */
function overwriteWithInitiallyNegotiatedDtlsRole(description, dtlsRole) {
    if (description && description.type === 'answer' && dtlsRole) {
        return new FirefoxRTCSessionDescription({
            type: description.type,
            sdp: description.sdp.replace(/a=setup:[a-z]+/g, 'a=setup:' + dtlsRole)
        });
    }
    return description;
}
module.exports = FirefoxRTCPeerConnection;
//# sourceMappingURL=firefox.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/rtcpeerconnection/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/rtcpeerconnection/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (typeof RTCPeerConnection === 'function') {
    var guessBrowser = __webpack_require__(/*! ../util */ "./node_modules/twilio-video/es5/webrtc/util/index.js").guessBrowser;
    switch (guessBrowser()) {
        case 'chrome':
            module.exports = __webpack_require__(/*! ./chrome */ "./node_modules/twilio-video/es5/webrtc/rtcpeerconnection/chrome.js");
            break;
        case 'firefox':
            module.exports = __webpack_require__(/*! ./firefox */ "./node_modules/twilio-video/es5/webrtc/rtcpeerconnection/firefox.js");
            break;
        case 'safari':
            module.exports = __webpack_require__(/*! ./safari */ "./node_modules/twilio-video/es5/webrtc/rtcpeerconnection/safari.js");
            break;
        default:
            module.exports = RTCPeerConnection;
            break;
    }
}
else {
    module.exports = function RTCPeerConnection() {
        throw new Error('RTCPeerConnection is not supported');
    };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/rtcpeerconnection/safari.js":
/*!**************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/rtcpeerconnection/safari.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCPeerConnection, RTCSessionDescription */

var EventTarget = __webpack_require__(/*! ../util/eventtarget */ "./node_modules/twilio-video/es5/webrtc/util/eventtarget.js");
var inherits = __webpack_require__(/*! util */ "./node_modules/util/util.js").inherits;
var Latch = __webpack_require__(/*! ../util/latch */ "./node_modules/twilio-video/es5/webrtc/util/latch.js");
var sdpUtils = __webpack_require__(/*! ../util/sdp */ "./node_modules/twilio-video/es5/webrtc/util/sdp.js");
var util = __webpack_require__(/*! ../util */ "./node_modules/twilio-video/es5/webrtc/util/index.js");
var isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified';
var updateTrackIdsToSSRCs = isUnifiedPlan
    ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs
    : sdpUtils.updatePlanBTrackIdsToSSRCs;
function SafariRTCPeerConnection(configuration) {
    if (!(this instanceof SafariRTCPeerConnection)) {
        return new SafariRTCPeerConnection(configuration);
    }
    EventTarget.call(this);
    util.interceptEvent(this, 'datachannel');
    util.interceptEvent(this, 'iceconnectionstatechange');
    util.interceptEvent(this, 'signalingstatechange');
    util.interceptEvent(this, 'track');
    var peerConnection = new RTCPeerConnection(configuration);
    Object.defineProperties(this, {
        _appliedTracksToSSRCs: {
            value: new Map(),
            writable: true
        },
        _audioTransceiver: {
            value: null,
            writable: true
        },
        _isClosed: {
            value: false,
            writable: true
        },
        _peerConnection: {
            value: peerConnection
        },
        _pendingLocalOffer: {
            value: null,
            writable: true
        },
        _pendingRemoteOffer: {
            value: null,
            writable: true
        },
        _rolledBackTracksToSSRCs: {
            value: new Map(),
            writable: true
        },
        _signalingStateLatch: {
            value: new Latch()
        },
        _tracksToSSRCs: {
            value: new Map(),
            writable: true
        },
        _videoTransceiver: {
            value: null,
            writable: true
        },
        localDescription: {
            enumerable: true,
            get: function () {
                return this._pendingLocalOffer || this._peerConnection.localDescription;
            }
        },
        iceConnectionState: {
            enumerable: true,
            get: function () {
                return this._isClosed ? 'closed' : this._peerConnection.iceConnectionState;
            }
        },
        iceGatheringState: {
            enumerable: true,
            get: function () {
                return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;
            }
        },
        remoteDescription: {
            enumerable: true,
            get: function () {
                return this._pendingRemoteOffer || this._peerConnection.remoteDescription;
            }
        },
        signalingState: {
            enumerable: true,
            get: function () {
                if (this._isClosed) {
                    return 'closed';
                }
                else if (this._pendingLocalOffer) {
                    return 'have-local-offer';
                }
                else if (this._pendingRemoteOffer) {
                    return 'have-remote-offer';
                }
                return this._peerConnection.signalingState;
            }
        }
    });
    var self = this;
    peerConnection.addEventListener('datachannel', function ondatachannel(event) {
        shimDataChannel(event.channel);
        self.dispatchEvent(event);
    });
    peerConnection.addEventListener('iceconnectionstatechange', function oniceconnectionstatechange() {
        if (self._isClosed) {
            return;
        }
        self.dispatchEvent.apply(self, arguments);
    });
    peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {
        if (self._isClosed) {
            return;
        }
        if (peerConnection.signalingState === 'stable') {
            self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);
        }
        if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {
            self.dispatchEvent.apply(self, arguments);
        }
    });
    // NOTE(syerrapragada): This ensures that SafariRTCPeerConnection's "remoteDescription", when accessed
    // in an RTCTrackEvent listener, will point to the underlying RTCPeerConnection's
    // "remoteDescription". Before this fix, this was still pointing to "_pendingRemoteOffer"
    // even though a new remote RTCSessionDescription had already been applied.
    peerConnection.addEventListener('track', function ontrack(event) {
        self._pendingRemoteOffer = null;
        self.dispatchEvent(event);
    });
    util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);
}
inherits(SafariRTCPeerConnection, EventTarget);
SafariRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {
    var self = this;
    if (this.signalingState === 'have-remote-offer') {
        return this._signalingStateLatch.when('low').then(function signalingStatesResolved() {
            return self._peerConnection.addIceCandidate(candidate);
        });
    }
    return this._peerConnection.addIceCandidate(candidate);
};
SafariRTCPeerConnection.prototype.createOffer = function createOffer(options) {
    options = Object.assign({}, options);
    var self = this;
    // NOTE(mroberts): In general, this is not the way to do this; however, it's
    // good enough for our application.
    if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {
        delete options.offerToReceiveAudio;
        try {
            this._audioTransceiver = isUnifiedPlan
                ? this.addTransceiver('audio', { direction: 'recvonly' })
                : this.addTransceiver('audio');
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {
        delete options.offerToReceiveVideo;
        try {
            this._videoTransceiver = isUnifiedPlan
                ? this.addTransceiver('video', { direction: 'recvonly' })
                : this.addTransceiver('video');
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    return this._peerConnection.createOffer(options).then(function (offer) {
        // NOTE(mmalavalli): If createOffer() is called immediately after rolling back,
        // then we no longer need to retain the rolled back tracks to SSRCs Map.
        self._rolledBackTracksToSSRCs.clear();
        return new RTCSessionDescription({
            type: offer.type,
            sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, offer.sdp)
        });
    });
};
SafariRTCPeerConnection.prototype.createAnswer = function createAnswer(options) {
    var self = this;
    if (this._pendingRemoteOffer) {
        return this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {
            self._signalingStateLatch.lower();
            return self._peerConnection.createAnswer();
        }).then(function createAnswerSucceeded(answer) {
            self._pendingRemoteOffer = null;
            // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no
            // longer need to retain the rolled back tracks to SSRCs Map.
            self._rolledBackTracksToSSRCs.clear();
            return isUnifiedPlan ? new RTCSessionDescription({
                type: answer.type,
                sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)
            }) : answer;
        }, function setRemoteDescriptionOrCreateAnswerFailed(error) {
            self._pendingRemoteOffer = null;
            throw error;
        });
    }
    return this._peerConnection.createAnswer(options).then(function createAnswerSucceeded(answer) {
        // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no
        // longer need to retain the rolled back tracks to SSRCs Map.
        self._rolledBackTracksToSSRCs.clear();
        return isUnifiedPlan ? new RTCSessionDescription({
            type: answer.type,
            sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)
        }) : answer;
    });
};
SafariRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {
    var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);
    shimDataChannel(dataChannel);
    return dataChannel;
};
SafariRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    sender.replaceTrack(null);
    this._peerConnection.removeTrack(sender);
};
SafariRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription(description) {
    // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,
    // then we need to restore the rolled back tracks to SSRCs Map.
    if (this._rolledBackTracksToSSRCs.size > 0) {
        this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);
        this._rolledBackTracksToSSRCs.clear();
    }
    return setDescription(this, true, description);
};
SafariRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(description) {
    // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,
    // then we no longer need to retain the rolled back tracks to SSRCs Map.
    this._rolledBackTracksToSSRCs.clear();
    return setDescription(this, false, description);
};
SafariRTCPeerConnection.prototype.close = function close() {
    if (this._isClosed) {
        return;
    }
    this._isClosed = true;
    this._peerConnection.close();
    var self = this;
    setTimeout(function () {
        self.dispatchEvent(new Event('iceconnectionstatechange'));
        self.dispatchEvent(new Event('signalingstatechange'));
    });
};
util.delegateMethods(RTCPeerConnection.prototype, SafariRTCPeerConnection.prototype, '_peerConnection');
function setDescription(peerConnection, local, description) {
    function setPendingLocalOffer(offer) {
        if (local) {
            peerConnection._pendingLocalOffer = offer;
        }
        else {
            peerConnection._pendingRemoteOffer = offer;
        }
    }
    function clearPendingLocalOffer() {
        if (local) {
            peerConnection._pendingLocalOffer = null;
        }
        else {
            peerConnection._pendingRemoteOffer = null;
        }
    }
    var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;
    var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;
    var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';
    var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';
    if (!local && pendingRemoteOffer && description.type === 'answer') {
        return setRemoteAnswer(peerConnection, description);
    }
    else if (description.type === 'offer') {
        if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {
            return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') +
                ' offer in state ' + peerConnection.signalingState));
        }
        if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {
            peerConnection._signalingStateLatch.raise();
        }
        var previousSignalingState = peerConnection.signalingState;
        setPendingLocalOffer(description);
        // Only dispatch a signalingstatechange event if we transitioned.
        if (peerConnection.signalingState !== previousSignalingState) {
            return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {
                peerConnection.dispatchEvent(new Event('signalingstatechange'));
            });
        }
        return Promise.resolve();
    }
    else if (description.type === 'rollback') {
        if (peerConnection.signalingState !== intermediateState) {
            return Promise.reject(new Error('Cannot rollback ' +
                (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));
        }
        clearPendingLocalOffer();
        // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case
        // setLocalDescription() is called immediately aftera rollback (without calling
        // createOffer() or createAnswer()), in which case this roll back is not due to
        // a glare scenario and this Map should be restored.
        peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);
        peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);
        return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {
            peerConnection.dispatchEvent(new Event('signalingstatechange'));
        });
    }
    return peerConnection._peerConnection[setLocalDescription](description);
}
function setRemoteAnswer(peerConnection, answer) {
    var pendingLocalOffer = peerConnection._pendingLocalOffer;
    return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {
        peerConnection._pendingLocalOffer = null;
        return peerConnection.setRemoteDescription(answer);
    }).then(function setRemoteAnswerSucceeded() {
        peerConnection._signalingStateLatch.lower();
    });
}
/**
 * Whether a SafariRTCPeerConnection has any RTCRtpReceivers(s) for the given
 * MediaStreamTrack kind.
 * @param {SafariRTCPeerConnection} peerConnection
 * @param {'audio' | 'video'} kind
 * @returns {boolean}
 */
function hasReceiversForTracksOfKind(peerConnection, kind) {
    return !!peerConnection.getTransceivers().find(function (transceiver) {
        return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;
    });
}
/**
 * Shim an RTCDataChannel. This function mutates the RTCDataChannel.
 * @param {RTCDataChannel} dataChannel
 * @returns {RTCDataChannel}
 */
function shimDataChannel(dataChannel) {
    return Object.defineProperties(dataChannel, {
        maxPacketLifeTime: {
            value: dataChannel.maxPacketLifeTime === 65535
                ? null
                : dataChannel.maxPacketLifeTime
        },
        maxRetransmits: {
            value: dataChannel.maxRetransmits === 65535
                ? null
                : dataChannel.maxRetransmits
        }
    });
}
module.exports = SafariRTCPeerConnection;
//# sourceMappingURL=safari.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/rtcrtpsender.js":
/*!**************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/rtcrtpsender.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * RTCRtpSender shim.
 * @param {MediaStreamTrack} track
 * @property {MediaStreamTrack} track
 */
function RTCRtpSenderShim(track) {
    Object.defineProperties(this, {
        track: {
            enumerable: true,
            value: track,
            writable: true
        }
    });
}
// NOTE(mmalavalli): Because of the way we will be using this shim, there
// are a couple of use cases that will not be covered:
//
// /* Case 1 */
// const sender = pc.addTrack(track);
// assert.equal(sender.track, track);
// pc.removeTrack(sender);
// assert.equal(sender.track, null); /* Error */
//
// /* Case 2 */
// const sender = pc.addTrack(track);
// const senders1 = new Set(pc.getSenders());
// assert(senders1.has(sender));
// pc.removeTrack(track);
// const senders2 = new Set(pc.getSenders());
// assert(senders2.has(sender)); /* Error */
//
// For now, since we only use senders for passing them to RTCPeerConnection#removeTrack(),
// we will omit handling these use cases for now, and revisit them when we start
// using the RTCRtpSender APIs.
module.exports = RTCRtpSenderShim;
//# sourceMappingURL=rtcrtpsender.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/rtcsessiondescription/chrome.js":
/*!******************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/rtcsessiondescription/chrome.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCSessionDescription */

// This class wraps Chrome's RTCSessionDescription implementation. It provides
// one piece of functionality not currently present in Chrome, namely
//
//   1. Rollback support
//      https://bugs.chromium.org/p/webrtc/issues/detail?id=4676
//
function ChromeRTCSessionDescription(descriptionInitDict) {
    if (!(this instanceof ChromeRTCSessionDescription)) {
        return new ChromeRTCSessionDescription(descriptionInitDict);
    }
    // If this constructor is called with an object with a .type property set to
    // "rollback", we should not call Chrome's RTCSessionDescription constructor,
    // because this would throw an RTCSdpType error.
    var description = descriptionInitDict && descriptionInitDict.type === 'rollback'
        ? null
        : new RTCSessionDescription(descriptionInitDict);
    Object.defineProperties(this, {
        _description: {
            get: function () {
                return description;
            }
        },
        sdp: {
            enumerable: true,
            value: description ? description.sdp : descriptionInitDict.sdp
        },
        type: {
            enumerable: true,
            value: description ? description.type : descriptionInitDict.type
        }
    });
}
module.exports = ChromeRTCSessionDescription;
//# sourceMappingURL=chrome.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/rtcsessiondescription/firefox.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/rtcsessiondescription/firefox.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCSessionDescription */

module.exports = RTCSessionDescription;
//# sourceMappingURL=firefox.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/rtcsessiondescription/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/rtcsessiondescription/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCSessionDescription */

if (typeof RTCSessionDescription === 'function') {
    var guessBrowser = __webpack_require__(/*! ../util */ "./node_modules/twilio-video/es5/webrtc/util/index.js").guessBrowser;
    switch (guessBrowser()) {
        case 'chrome':
            module.exports = __webpack_require__(/*! ./chrome */ "./node_modules/twilio-video/es5/webrtc/rtcsessiondescription/chrome.js");
            break;
        case 'firefox':
            module.exports = __webpack_require__(/*! ./firefox */ "./node_modules/twilio-video/es5/webrtc/rtcsessiondescription/firefox.js");
            break;
        default:
            module.exports = RTCSessionDescription;
            break;
    }
}
else {
    module.exports = function RTCSessionDescription() {
        throw new Error('RTCSessionDescription is not supported');
    };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/util/eventtarget.js":
/*!******************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/util/eventtarget.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
/**
 * Event target.
 * @class
 */
function EventTarget() {
    Object.defineProperties(this, {
        _eventEmitter: {
            value: new EventEmitter()
        }
    });
}
/**
 * Dispatch an Event to the {@link EventTarget}.
 * @param {Event} event
 */
EventTarget.prototype.dispatchEvent = function dispatchEvent(event) {
    return this._eventEmitter.emit(event.type, event);
};
/**
 * Add an Event listener to the {@link EventTarget}.
 */
EventTarget.prototype.addEventListener = function addEventListener() {
    return this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
};
/**
 * Remove an Event listener to the {@link EventTarget}.
 */
EventTarget.prototype.removeEventListener = function removeEventListener() {
    return this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
};
module.exports = EventTarget;
//# sourceMappingURL=eventtarget.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/util/index.js":
/*!************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/util/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Create a {@link Deferred}.
 * @returns {Deferred}
 */
function defer() {
    var deferred = {};
    deferred.promise = new Promise(function (resolve, reject) {
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
    return deferred;
}
/**
 * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking
 * the method on the `wrapper` prototype will invoke the corresponding method
 * on an instance accessed by `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @param {string} methodName
 * @returns {undefined}
 */
function delegateMethod(source, wrapper, target, methodName) {
    if (methodName in wrapper) {
        // Skip any methods already set.
        return;
    }
    else if (methodName.match(/^on[a-z]+$/)) {
        // Skip EventHandlers (these are handled in the constructor).
        return;
    }
    var isProperty = false;
    try {
        var propDesc = Object.getOwnPropertyDescriptor(source, methodName);
        isProperty = propDesc && !!propDesc.get;
    }
    catch (error) {
        // its okay to eat failure here.
    }
    // NOTE(mpatwardhan):skip properties. we are only interested in overriding
    // functions. we do not even want to evaluate  `typeof source[methodName]` for properties
    // because getter would get invoked, and they might have side effects.
    // For example RTCPeerConnection.peerIdentity is a property that returns a promise.
    // calling typeof RTCPeerConnection.peerIdentity, would leak a promise, and in case it rejects
    // we see errors.
    if (isProperty) {
        return;
    }
    var type;
    try {
        type = typeof source[methodName];
    }
    catch (error) {
        // NOTE(mroberts): Attempting to check the type of non-function members
        // on the prototype throws an error for some types.
    }
    if (type !== 'function') {
        // Skip non-function members.
        return;
    }
    /* eslint no-loop-func:0 */
    wrapper[methodName] = function () {
        return this[target][methodName].apply(this[target], arguments);
    };
}
/**
 * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking
 * the methods on the `wrapper` prototype will invoke the corresponding method
 * on an instance accessed by `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @returns {undefined}
 */
function delegateMethods(source, wrapper, target) {
    for (var methodName in source) {
        delegateMethod(source, wrapper, target, methodName);
    }
}
/**
 * Finds the items in list1 that are not in list2.
 * @param {Array<*>|Map<*>|Set<*>} list1
 * @param {Array<*>|Map<*>|Set<*>} list2
 * @returns {Set}
 */
function difference(list1, list2) {
    list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());
    list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());
    var difference = new Set();
    list1.forEach(function (item) {
        if (!list2.has(item)) {
            difference.add(item);
        }
    });
    return difference;
}
/**
 * Map a list to an array of arrays, and return the flattened result.
 * @param {Array<*>|Set<*>|Map<*>} list
 * @param {function(*): Array<*>} mapFn
 * @returns Array<*>
 */
function flatMap(list, mapFn) {
    var listArray = list instanceof Map || list instanceof Set
        ? Array.from(list.values())
        : list;
    return listArray.reduce(function (flattened, item) {
        var mapped = mapFn(item);
        return flattened.concat(mapped);
    }, []);
}
/**
 * Get the browser's user agent, if available.
 * @returns {?string}
 */
function getUserAgent() {
    return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string'
        ? navigator.userAgent
        : null;
}
/**
 * Guess the browser.
 * @param {string} [userAgent=navigator.userAgent]
 * @returns {?string} browser - "chrome", "firefox", "safari", or null
 */
function guessBrowser(userAgent) {
    if (typeof userAgent === 'undefined') {
        userAgent = getUserAgent();
    }
    if (/Chrome|CriOS/.test(userAgent)) {
        return 'chrome';
    }
    if (/Firefox|FxiOS/.test(userAgent)) {
        return 'firefox';
    }
    if (/Safari|iPhone|iPad|iPod/.test(userAgent)) {
        return 'safari';
    }
    return null;
}
/**
 * Guess the browser version.
 * @param {string} [userAgent=navigator.userAgent]
 * @returns {?{major: number, minor: number}}
 */
function guessBrowserVersion(userAgent) {
    if (typeof userAgent === 'undefined') {
        userAgent = getUserAgent();
    }
    var prefix = {
        chrome: 'Chrome|CriOS',
        firefox: 'Firefox|FxiOS',
        safari: 'Version'
    }[guessBrowser(userAgent)];
    if (!prefix) {
        return null;
    }
    var regex = new RegExp('(' + prefix + ')/([^\\s]+)');
    var match = (userAgent.match(regex) || [])[2];
    if (!match) {
        return null;
    }
    var versions = match.split('.').map(Number);
    return {
        major: isNaN(versions[0]) ? null : versions[0],
        minor: isNaN(versions[1]) ? null : versions[1]
    };
}
/**
 * Check whether the current browser is iOS Chrome.
 * @param {string} [userAgent=navigator.userAgent]
 * @returns {boolean}
 */
function isIOSChrome(userAgent) {
    if (typeof userAgent === 'undefined') {
        userAgent = getUserAgent();
    }
    return (/Mobi/.test(userAgent) && guessBrowser() === 'chrome' && /iPad|iPhone|iPod/.test(userAgent));
}
/**
 * Intercept an event that might otherwise be proxied on an EventTarget.
 * @param {EventTarget} target
 * @param {string} type
 * @returns {void}
 */
function interceptEvent(target, type) {
    var currentListener = null;
    Object.defineProperty(target, 'on' + type, {
        get: function () {
            return currentListener;
        },
        set: function (newListener) {
            if (currentListener) {
                this.removeEventListener(type, currentListener);
            }
            if (typeof newListener === 'function') {
                currentListener = newListener;
                this.addEventListener(type, currentListener);
            }
            else {
                currentListener = null;
            }
        }
    });
}
/**
 * This is a function for turning a Promise into the kind referenced in the
 * Legacy Interface Extensions section of the WebRTC spec.
 * @param {Promise<*>} promise
 * @param {function<*>} onSuccess
 * @param {function<Error>} onFailure
 * @returns {Promise<undefined>}
 */
function legacyPromise(promise, onSuccess, onFailure) {
    if (onSuccess) {
        return promise.then(function (result) {
            onSuccess(result);
        }, function (error) {
            onFailure(error);
        });
    }
    return promise;
}
/**
 * Make a unique ID.
 * @return {string}
 */
function makeUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
/**
 * For each property name on the `source` prototype, add getters and/or setters
 * to `wrapper` that proxy to `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @returns {undefined}
 */
function proxyProperties(source, wrapper, target) {
    Object.getOwnPropertyNames(source).forEach(function (propertyName) {
        proxyProperty(source, wrapper, target, propertyName);
    });
}
/**
 * For the property name on the `source` prototype, add a getter and/or setter
 * to `wrapper` that proxies to `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @param {string} propertyName
 * @returns {undefined}
 */
function proxyProperty(source, wrapper, target, propertyName) {
    if (propertyName in wrapper) {
        // Skip any properties already set.
        return;
    }
    else if (propertyName.match(/^on[a-z]+$/)) {
        Object.defineProperty(wrapper, propertyName, {
            value: null,
            writable: true
        });
        target.addEventListener(propertyName.slice(2), function () {
            wrapper.dispatchEvent.apply(wrapper, arguments);
        });
        return;
    }
    Object.defineProperty(wrapper, propertyName, {
        enumerable: true,
        get: function () {
            return target[propertyName];
        }
    });
}
/**
 * Check whether native WebRTC APIs are supported.
 * @returns {boolean}
 */
function support() {
    return typeof navigator === 'object'
        && typeof navigator.mediaDevices === 'object'
        && typeof navigator.mediaDevices.getUserMedia === 'function'
        && typeof RTCPeerConnection === 'function';
}
/**
 * @typedef {object} Deferred
 * @property {Promise} promise
 * @property {function} reject
 * @property {function} resolve
 */
exports.defer = defer;
exports.delegateMethods = delegateMethods;
exports.difference = difference;
exports.flatMap = flatMap;
exports.guessBrowser = guessBrowser;
exports.guessBrowserVersion = guessBrowserVersion;
exports.isIOSChrome = isIOSChrome;
exports.interceptEvent = interceptEvent;
exports.legacyPromise = legacyPromise;
exports.makeUUID = makeUUID;
exports.proxyProperties = proxyProperties;
exports.support = support;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/util/latch.js":
/*!************************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/util/latch.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var defer = __webpack_require__(/*! ./ */ "./node_modules/twilio-video/es5/webrtc/util/index.js").defer;
var states = {
    high: new Set(['low']),
    low: new Set(['high'])
};
/**
 * Construct a {@link Latch}.
 * @class
 * @classdesc A {@link Latch} has two states ("high" and "low") and methods for
 * transitioning between them ({@link Latch#raise} and {@link Latch#lower}).
 * @param {string} [initialState="low"] - either "high" or "low"
 */
function Latch(initialState) {
    if (!(this instanceof Latch)) {
        return new Latch(initialState);
    }
    var state = initialState || 'low';
    Object.defineProperties(this, {
        _state: {
            set: function (_state) {
                if (state !== _state) {
                    state = _state;
                    var whenDeferreds = this._whenDeferreds.get(state);
                    whenDeferreds.forEach(function (deferred) {
                        deferred.resolve(this);
                    }, this);
                    whenDeferreds.clear();
                }
            },
            get: function () {
                return state;
            }
        },
        _whenDeferreds: {
            value: new Map([
                ['high', new Set()],
                ['low', new Set()]
            ])
        },
        state: {
            enumerable: true,
            get: function () {
                return this._state;
            }
        }
    });
}
/**
 * Transition to "low".
 * @returns {this}
 * @throws {Error}
 */
Latch.prototype.lower = function lower() {
    return this.transition('low');
};
/**
 * Transition to "high".
 * @returns {this}
 * @throws {Error}
 */
Latch.prototype.raise = function raise() {
    return this.transition('high');
};
/**
 * Transition to a new state.
 * @param {string} newState
 * @returns {this}
 * @throws {Error}
 */
Latch.prototype.transition = function transition(newState) {
    if (!states[this.state].has(newState)) {
        throw createUnreachableStateError(this.state, newState);
    }
    this._state = newState;
    return this;
};
/**
 * Return a Promise that resolves when the {@link Latch} transitions to
 * the specified state.
 * @param {string} state
 * @returns {Promise<this>}
 */
Latch.prototype.when = function when(state) {
    if (this.state === state) {
        return Promise.resolve(this);
    }
    if (!states[this.state].has(state)) {
        return Promise.reject(createUnreachableStateError(this.state, state));
    }
    var deferred = defer();
    this._whenDeferreds.get(state).add(deferred);
    return deferred.promise;
};
/**
 * Create an unreachable state Error.
 * @param {string} from - state to be transitioned from
 * @param {string} to - state to be transitioned to
 * @return {Error}
 */
function createUnreachableStateError(from, to) {
    return new Error('Cannot transition from "' + from + '" to "' + to + '"');
}
module.exports = Latch;
//# sourceMappingURL=latch.js.map

/***/ }),

/***/ "./node_modules/twilio-video/es5/webrtc/util/sdp.js":
/*!**********************************************************!*\
  !*** ./node_modules/twilio-video/es5/webrtc/util/sdp.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCPeerConnection, RTCRtpTransceiver */

var flatMap = __webpack_require__(/*! ./ */ "./node_modules/twilio-video/es5/webrtc/util/index.js").flatMap;
var guessBrowser = __webpack_require__(/*! ./ */ "./node_modules/twilio-video/es5/webrtc/util/index.js").guessBrowser;
// NOTE(mmalavalli): We cache Chrome's sdpSemantics support in order to prevent
// instantiation of more than one RTCPeerConnection.
var isSdpSemanticsSupported = null;
/**
 * Check if Chrome supports specifying sdpSemantics for an RTCPeerConnection.
 * @return {boolean}
 */
function checkIfSdpSemanticsIsSupported() {
    if (typeof isSdpSemanticsSupported === 'boolean') {
        return isSdpSemanticsSupported;
    }
    if (typeof RTCPeerConnection === 'undefined') {
        isSdpSemanticsSupported = false;
        return isSdpSemanticsSupported;
    }
    try {
        // eslint-disable-next-line no-new
        new RTCPeerConnection({ sdpSemantics: 'foo' });
        isSdpSemanticsSupported = false;
    }
    catch (e) {
        isSdpSemanticsSupported = true;
    }
    return isSdpSemanticsSupported;
}
// NOTE(mmalavalli): We cache Chrome's SDP format in order to prevent
// instantiation of more than one RTCPeerConnection.
var chromeSdpFormat = null;
/**
 * Get Chrome's default SDP format.
 * @returns {'planb'|'unified'}
 */
function getChromeDefaultSdpFormat() {
    if (!chromeSdpFormat) {
        if (typeof RTCPeerConnection !== 'undefined'
            && 'addTransceiver' in RTCPeerConnection.prototype) {
            try {
                new RTCPeerConnection().addTransceiver('audio');
                chromeSdpFormat = 'unified';
            }
            catch (e) {
                chromeSdpFormat = 'planb';
            }
        }
        else {
            chromeSdpFormat = 'planb';
        }
    }
    return chromeSdpFormat;
}
/**
 * Get Chrome's SDP format.
 * @param {'plan-b'|'unified-plan'} [sdpSemantics]
 * @returns {'planb'|'unified'}
 */
function getChromeSdpFormat(sdpSemantics) {
    if (!sdpSemantics || !checkIfSdpSemanticsIsSupported()) {
        return getChromeDefaultSdpFormat();
    }
    return {
        'plan-b': 'planb',
        'unified-plan': 'unified'
    }[sdpSemantics];
}
/**
 * Get Safari's default SDP format.
 * @returns {'planb'|'unified'}
 */
function getSafariSdpFormat() {
    return typeof RTCRtpTransceiver !== 'undefined'
        && 'currentDirection' in RTCRtpTransceiver.prototype
        ? 'unified'
        : 'planb';
}
/**
 * Get the browser's default SDP format.
 * @param {'plan-b'|'unified-plan'} [sdpSemantics]
 * @returns {'planb'|'unified'}
 */
function getSdpFormat(sdpSemantics) {
    return {
        chrome: getChromeSdpFormat(sdpSemantics),
        firefox: 'unified',
        safari: getSafariSdpFormat()
    }[guessBrowser()] || null;
}
/**
 * Match a pattern across lines, returning the first capture group for any
 * matches.
 * @param {string} pattern
 * @param {string} lines
 * @returns {Set<string>} matches
 */
function getMatches(pattern, lines) {
    var matches = lines.match(new RegExp(pattern, 'gm')) || [];
    return matches.reduce(function (results, line) {
        var match = line.match(new RegExp(pattern));
        return match ? results.add(match[1]) : results;
    }, new Set());
}
/**
 * Get a Set of MediaStreamTrack IDs from an SDP.
 * @param {string} pattern
 * @param {string} sdp
 * @returns {Set<string>}
 */
function getTrackIds(pattern, sdp) {
    return getMatches(pattern, sdp);
}
/**
 * Get a Set of MediaStreamTrack IDs from a Plan B SDP.
 * @param {string} sdp - Plan B SDP
 * @returns {Set<string>} trackIds
 */
function getPlanBTrackIds(sdp) {
    return getTrackIds('^a=ssrc:[0-9]+ +msid:.+ +(.+) *$', sdp);
}
/**
 * Get a Set of MediaStreamTrack IDs from a Unified Plan SDP.
 * @param {string} sdp - Unified Plan SDP
 * @returns {Set<string>} trackIds
 */
function getUnifiedPlanTrackIds(sdp) {
    return getTrackIds('^a=msid:.+ +(.+) *$', sdp);
}
/**
 * Get a Set of SSRCs for a MediaStreamTrack from a Plan B SDP.
 * @param {string} sdp - Plan B SDP
 * @param {string} trackId - MediaStreamTrack ID
 * @returns {Set<string>}
 */
function getPlanBSSRCs(sdp, trackId) {
    var pattern = '^a=ssrc:([0-9]+) +msid:[^ ]+ +' + trackId + ' *$';
    return getMatches(pattern, sdp);
}
/**
 * Get the m= sections of a particular kind and direction from an sdp.
 * @param {string} sdp -  sdp string
 * @param {string} [kind] - Pattern for matching kind
 * @param {string} [direction] - Pattern for matching direction
 * @returns {Array<string>} mediaSections
 */
function getMediaSections(sdp, kind, direction) {
    kind = kind || '.*';
    direction = direction || '.*';
    return sdp.split('\r\nm=').slice(1).map(function (mediaSection) {
        return 'm=' + mediaSection;
    }).filter(function (mediaSection) {
        var kindPattern = new RegExp('m=' + kind, 'gm');
        var directionPattern = new RegExp('a=' + direction, 'gm');
        return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);
    });
}
/**
 * Get the Set of SSRCs announced in a MediaSection.
 * @param {string} mediaSection
 * @returns {Array<string>} ssrcs
 */
function getMediaSectionSSRCs(mediaSection) {
    return Array.from(getMatches('^a=ssrc:([0-9]+) +.*$', mediaSection));
}
/**
 * Get a Set of SSRCs for a MediaStreamTrack from a Unified Plan SDP.
 * @param {string} sdp - Unified Plan SDP
 * @param {string} trackId - MediaStreamTrack ID
 * @returns {Set<string>}
 */
function getUnifiedPlanSSRCs(sdp, trackId) {
    var mediaSections = getMediaSections(sdp);
    var msidAttrRegExp = new RegExp('^a=msid:[^ ]+ +' + trackId + ' *$', 'gm');
    var matchingMediaSections = mediaSections.filter(function (mediaSection) {
        return mediaSection.match(msidAttrRegExp);
    });
    return new Set(flatMap(matchingMediaSections, getMediaSectionSSRCs));
}
/**
 * Get a Map from MediaStreamTrack IDs to SSRCs from an SDP.
 * @param {function(string): Set<string>} getTrackIds
 * @param {function(string, string): Set<string>} getSSRCs
 * @param {string} sdp - SDP
 * @returns {Map<string, Set<string>>} trackIdsToSSRCs
 */
function getTrackIdsToSSRCs(getTrackIds, getSSRCs, sdp) {
    return new Map(Array.from(getTrackIds(sdp)).map(function (trackId) {
        return [trackId, getSSRCs(sdp, trackId)];
    }));
}
/**
 * Get a Map from MediaStreamTrack IDs to SSRCs from a Plan B SDP.
 * @param {string} sdp - Plan B SDP
 * @returns {Map<string, Set<string>>} trackIdsToSSRCs
 */
function getPlanBTrackIdsToSSRCs(sdp) {
    return getTrackIdsToSSRCs(getPlanBTrackIds, getPlanBSSRCs, sdp);
}
/**
 * Get a Map from MediaStreamTrack IDs to SSRCs from a Plan B SDP.
 * @param {string} sdp - Plan B SDP
 * @returns {Map<string, Set<string>>} trackIdsToSSRCs
 */
function getUnifiedPlanTrackIdsToSSRCs(sdp) {
    return getTrackIdsToSSRCs(getUnifiedPlanTrackIds, getUnifiedPlanSSRCs, sdp);
}
/**
 * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both
 * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method
 * ensures that SSRCs never change once announced.
 * @param {function(string): Map<string, Set<string>>} getTrackIdsToSSRCs
 * @param {Map<string, Set<string>>} trackIdsToSSRCs
 * @param {string} sdp - SDP
 * @returns {strinng} updatedSdp - updated SDP
 */
function updateTrackIdsToSSRCs(getTrackIdsToSSRCs, trackIdsToSSRCs, sdp) {
    var newTrackIdsToSSRCs = getTrackIdsToSSRCs(sdp);
    var newSSRCsToOldSSRCs = new Map();
    // NOTE(mroberts): First, update a=ssrc attributes.
    newTrackIdsToSSRCs.forEach(function (ssrcs, trackId) {
        if (!trackIdsToSSRCs.has(trackId)) {
            trackIdsToSSRCs.set(trackId, ssrcs);
            return;
        }
        var oldSSRCs = Array.from(trackIdsToSSRCs.get(trackId));
        var newSSRCs = Array.from(ssrcs);
        oldSSRCs.forEach(function (oldSSRC, i) {
            var newSSRC = newSSRCs[i];
            newSSRCsToOldSSRCs.set(newSSRC, oldSSRC);
            var pattern = '^a=ssrc:' + newSSRC + ' (.*)$';
            var replacement = 'a=ssrc:' + oldSSRC + ' $1';
            sdp = sdp.replace(new RegExp(pattern, 'gm'), replacement);
        });
    });
    // NOTE(mroberts): Then, update a=ssrc-group attributes.
    var pattern = '^(a=ssrc-group:[^ ]+ +)(.*)$';
    var matches = sdp.match(new RegExp(pattern, 'gm')) || [];
    matches.forEach(function (line) {
        var match = line.match(new RegExp(pattern));
        if (!match) {
            return;
        }
        var prefix = match[1];
        var newSSRCs = match[2];
        var oldSSRCs = newSSRCs.split(' ').map(function (newSSRC) {
            var oldSSRC = newSSRCsToOldSSRCs.get(newSSRC);
            return oldSSRC ? oldSSRC : newSSRC;
        }).join(' ');
        sdp = sdp.replace(match[0], prefix + oldSSRCs);
    });
    return sdp;
}
/**
 * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both
 * the Map from MediaStreamTrack IDs to SSRCs and the Plan B SDP itself. This
 * method ensures that SSRCs never change once announced.
 * @param {Map<string, Set<string>>} trackIdsToSSRCs
 * @param {string} sdp - Plan B SDP
 * @returns {string} updatedSdp - updated Plan B SDP
 */
function updatePlanBTrackIdsToSSRCs(trackIdsToSSRCs, sdp) {
    return updateTrackIdsToSSRCs(getPlanBTrackIdsToSSRCs, trackIdsToSSRCs, sdp);
}
/**
 * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both
 * the Map from MediaStreamTrack IDs to SSRCs and the Plan B SDP itself. This
 * method ensures that SSRCs never change once announced.
 * @param {Map<string, Set<string>>} trackIdsToSSRCs
 * @param {string} sdp - Plan B SDP
 * @returns {string} updatedSdp - updated Plan B SDP
 */
function updateUnifiedPlanTrackIdsToSSRCs(trackIdsToSSRCs, sdp) {
    return updateTrackIdsToSSRCs(getUnifiedPlanTrackIdsToSSRCs, trackIdsToSSRCs, sdp);
}
exports.getSdpFormat = getSdpFormat;
exports.getMediaSections = getMediaSections;
exports.getPlanBTrackIds = getPlanBTrackIds;
exports.getUnifiedPlanTrackIds = getUnifiedPlanTrackIds;
exports.getPlanBSSRCs = getPlanBSSRCs;
exports.getUnifiedPlanSSRCs = getUnifiedPlanSSRCs;
exports.updatePlanBTrackIdsToSSRCs = updatePlanBTrackIdsToSSRCs;
exports.updateUnifiedPlanTrackIdsToSSRCs = updateUnifiedPlanTrackIdsToSSRCs;
//# sourceMappingURL=sdp.js.map

/***/ }),

/***/ "./node_modules/twilio-video/package.json":
/*!************************************************!*\
  !*** ./node_modules/twilio-video/package.json ***!
  \************************************************/
/*! exports provided: name, title, description, version, homepage, author, contributors, keywords, repository, devDependencies, engines, license, main, types, scripts, dependencies, browser, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"twilio-video\",\"title\":\"Twilio Video\",\"description\":\"Twilio Video JavaScript Library\",\"version\":\"3.0.0-rc5\",\"homepage\":\"https://twilio.com\",\"author\":\"Mark Andrus Roberts <mroberts@twilio.com>\",\"contributors\":[\"Ryan Rowland <rrowland@twilio.com>\",\"Manjesh Malavalli <mmalavalli@twilio.com>\",\"Makarand Patwardhan <mpatwardhan@twilio.com>\"],\"keywords\":[\"twilio\",\"webrtc\",\"library\",\"javascript\",\"video\",\"rooms\"],\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/twilio/twilio-video.js.git\"},\"devDependencies\":{\"@babel/core\":\"^7.14.2\",\"@babel/preset-env\":\"^7.14.2\",\"@babel/preset-typescript\":\"^7.13.0\",\"@types/express\":\"^4.11.0\",\"@types/node\":\"^8.5.1\",\"@types/selenium-webdriver\":\"^3.0.8\",\"@types/ws\":\"^3.2.1\",\"@typescript-eslint/eslint-plugin\":\"^4.13.0\",\"@typescript-eslint/parser\":\"^4.0.0\",\"babel-cli\":\"^6.26.0\",\"babel-preset-es2015\":\"^6.24.1\",\"browserify\":\"^17.0.0\",\"cheerio\":\"^0.22.0\",\"cors\":\"^2.8.5\",\"electron\":\"^9.1.0\",\"envify\":\"^4.0.0\",\"eslint\":\"^6.2.1\",\"eslint-config-standard\":\"^14.0.0\",\"eslint-plugin-import\":\"^2.18.2\",\"eslint-plugin-node\":\"^9.1.0\",\"eslint-plugin-promise\":\"^4.2.1\",\"eslint-plugin-standard\":\"^4.0.1\",\"express\":\"^4.16.2\",\"glob\":\"^7.1.7\",\"ink-docstrap\":\"^1.3.2\",\"inquirer\":\"^7.0.0\",\"is-docker\":\"^2.0.0\",\"jsdoc\":\"^3.5.5\",\"jsdoc-babel\":\"^0.5.0\",\"json-loader\":\"^0.5.7\",\"karma\":\"^5.0.2\",\"karma-browserify\":\"^8.0.0\",\"karma-chrome-launcher\":\"^2.0.0\",\"karma-edgium-launcher\":\"^4.0.0-0\",\"karma-electron\":\"^6.1.0\",\"karma-firefox-launcher\":\"^1.3.0\",\"karma-htmlfile-reporter\":\"^0.3.8\",\"karma-junit-reporter\":\"^1.2.0\",\"karma-mocha\":\"^1.3.0\",\"karma-safari-launcher\":\"^1.0.0\",\"karma-spec-reporter\":\"0.0.32\",\"karma-typescript\":\"^5.5.1\",\"karma-typescript-es6-transform\":\"^5.5.1\",\"mocha\":\"^3.2.0\",\"mock-require\":\"^3.0.3\",\"ncp\":\"^2.0.0\",\"node-http-server\":\"^8.1.2\",\"npm-run-all\":\"^4.0.2\",\"nyc\":\"^15.1.0\",\"requirejs\":\"^2.3.3\",\"rimraf\":\"^2.6.1\",\"simple-git\":\"^1.126.0\",\"sinon\":\"^4.0.1\",\"ts-node\":\"4.0.1\",\"tslint\":\"5.8.0\",\"twilio\":\"^3.49.0\",\"twilio-release-tool\":\"^1.0.2\",\"typescript\":\"4.2.2\",\"uglify-js\":\"^2.8.22\",\"vinyl-fs\":\"^2.4.4\",\"vinyl-source-stream\":\"^1.1.0\",\"watchify\":\"^3.11.1\",\"webrtc-adapter\":\"^7.7.1\"},\"engines\":{\"node\":\">=0.12\"},\"license\":\"BSD-3-Clause\",\"main\":\"./es5/index.js\",\"types\":\"./tsdef/index.d.ts\",\"scripts\":{\"lint:js\":\"eslint ./lib ./test/*.js ./docker/**/*.js ./test/framework/*.js ./test/lib/*.js ./test/integration/** ./test/unit/** \",\"lint:ts\":\"eslint ./tsdef/*.ts ./lib/**/*.ts\",\"lint\":\"npm-run-all lint:js lint:ts\",\"printVersion\":\"node --version && npm --version\",\"test:unit\":\"npm-run-all printVersion build:es5 && nyc --report-dir=./coverage --include=lib/**/* --reporter=html --reporter=lcov --reporter=text mocha -r ts-node/register ./test/unit/*\",\"test:serversiderender\":\"mocha ./test/serversiderender/index.js\",\"test:integration:adapter\":\"node ./scripts/karma.js karma/integration.adapter.conf.js\",\"test:integration\":\"npm run build:es5 && node ./scripts/karma.js karma/integration.conf.js\",\"test:umd:install\":\"npm install puppeteer@5.5.0\",\"test:umd\":\"mocha ./test/umd/index.js\",\"test:crossbrowser:build:clean\":\"rimraf ./test/crossbrowser/lib ./test/crossbrowser/src/browser/index.js\",\"test:crossbrowser:build:lint\":\"cd ./test/crossbrowser && tslint --project tsconfig.json\",\"test:crossbrowser:build:tsc\":\"cd ./test/crossbrowser && tsc\",\"test:crossbrowser:build:browser\":\"cd ./test/crossbrowser && browserify lib/crossbrowser/src/browser/index.js > src/browser/index.js\",\"test:crossbrowser:build\":\"npm-run-all test:crossbrowser:build:*\",\"test:crossbrowser:test\":\"cd ./test/crossbrowser && mocha --compilers ts:ts-node/register test/integration/spec/**/*.ts\",\"test:crossbrowser\":\"npm-run-all test:crossbrowser:*\",\"test:sdkdriver:build:clean\":\"rimraf ./test/lib/sdkdriver/lib ./test/lib/sdkdriver/test/integration/browser/index.js\",\"test:sdkdriver:build:lint\":\"cd ./test/lib/sdkdriver && tslint --project tsconfig.json\",\"test:sdkdriver:build:tsc\":\"cd ./test/lib/sdkdriver && tsc --rootDir src\",\"test:sdkdriver:build\":\"npm-run-all test:sdkdriver:build:*\",\"test:sdkdriver:test:unit\":\"cd ./test/lib/sdkdriver && mocha --compilers ts:ts-node/register test/unit/spec/**/*.ts\",\"test:sdkdriver:test:integration:browser\":\"cd ./test/lib/sdkdriver/test/integration && browserify browser/browser.js > browser/index.js\",\"test:sdkdriver:test:integration:run\":\"cd ./test/lib/sdkdriver && mocha --compilers ts:ts-node/register test/integration/spec/**/*.ts\",\"test:sdkdriver:test:integration\":\"npm-run-all test:sdkdriver:test:integration:*\",\"test:sdkdriver:test\":\"npm-run-all test:sdkdriver:test:*\",\"test:sdkdriver\":\"npm-run-all test:sdkdriver:*\",\"test:framework:angular:install\":\"cd ./test/framework/twilio-video-angular && rimraf ./node_modules package-lock.json && npm install\",\"test:framework:angular:run\":\"mocha ./test/framework/twilio-video-angular.js\",\"test:framework:angular\":\"npm-run-all test:framework:angular:*\",\"test:framework:no-framework:run\":\"mocha ./test/framework/twilio-video-no-framework.js\",\"test:framework:no-framework\":\"npm-run-all test:framework:no-framework:*\",\"test:framework:react:install\":\"cd ./test/framework/twilio-video-react && rimraf ./node_modules package-lock.json && npm install\",\"test:framework:react:test\":\"node ./scripts/framework.js twilio-video-react\",\"test:framework:react:build\":\"cd ./test/framework/twilio-video-react && npm run build\",\"test:framework:react:run\":\"mocha ./test/framework/twilio-video-react.js\",\"test:framework:react\":\"npm-run-all test:framework:react:*\",\"test:framework:install\":\"npm install chromedriver && npm install selenium-webdriver && npm install geckodriver && npm install puppeteer\",\"test:framework\":\"npm-run-all test:framework:install test:framework:no-framework test:framework:react\",\"test\":\"npm-run-all test:unit test:integration\",\"build:es5\":\"rimraf ./es5 && tsc tsdef/twilio-video-tests.ts --noEmit --lib es2018,dom && tsc \",\"build:js\":\"node ./scripts/build.js ./src/twilio-video.js ./LICENSE.md ./dist/twilio-video.js\",\"build:min.js\":\"uglifyjs ./dist/twilio-video.js -o ./dist/twilio-video.min.js --comments \\\"/^! twilio-video.js/\\\" -b beautify=false,ascii_only=true\",\"build\":\"npm-run-all clean lint docs test:unit test:integration build:es5 build:js build:min.js test:umd\",\"build:quick\":\"npm-run-all clean lint docs build:es5 build:js build:min.js\",\"docs\":\"node ./scripts/docs.js ./dist/docs\",\"watch\":\"tsc -w\",\"clean\":\"rimraf ./coverage ./es5 ./dist\"},\"dependencies\":{\"backoff\":\"^2.5.0\",\"events\":\"^3.3.0\",\"util\":\"^0.12.4\",\"ws\":\"^7.4.6\",\"xmlhttprequest\":\"^1.8.0\"},\"browser\":{\"ws\":\"./src/ws.js\",\"xmlhttprequest\":\"./src/xmlhttprequest.js\"}}");

/***/ }),

/***/ "./node_modules/twilio-video/src/ws.js":
/*!*********************************************!*\
  !*** ./node_modules/twilio-video/src/ws.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = WebSocket;


/***/ }),

/***/ "./node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/util/node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb, null, ret) },
            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/admin.ts":
/*!**********************!*\
  !*** ./src/admin.ts ***!
  \**********************/
/*! exports provided: demo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "demo", function() { return demo; });
/* harmony import */ var _components_button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/button */ "./src/components/button.ts");
/* harmony import */ var _components_createDiv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/createDiv */ "./src/components/createDiv.ts");
/* harmony import */ var _components_log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/log */ "./src/components/log.ts");
/* harmony import */ var _components_createLabeledInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/createLabeledInput */ "./src/components/createLabeledInput.ts");
/* harmony import */ var _components_createLink__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/createLink */ "./src/components/createLink.ts");
/* harmony import */ var _components_createSelection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/createSelection */ "./src/components/createSelection.ts");
/* harmony import */ var twilio_video__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! twilio-video */ "./node_modules/twilio-video/es5/index.js");
/* harmony import */ var twilio_video__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(twilio_video__WEBPACK_IMPORTED_MODULE_6__);
/* eslint-disable no-undefined */
/* eslint-disable require-atomic-updates */
/* eslint-disable no-console */
/* eslint-disable quotes */

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
console.log('loaded tokens.js');


// eslint-disable-next-line sort-imports





demo(twilio_video__WEBPACK_IMPORTED_MODULE_6___default.a, document.body);
function demo(Video, containerDiv) {
    var _this = this;
    // create html
    var container = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_1__["createDiv"])(containerDiv, 'foo', 'foo');
    Object(_components_log__WEBPACK_IMPORTED_MODULE_2__["createLog"])(containerDiv);
    Object(_components_createLink__WEBPACK_IMPORTED_MODULE_4__["createLink"])({ container: container, linkText: 'hey!', linkUrl: 'https://www.twilio.com' });
    var roomNameInput = Object(_components_createLabeledInput__WEBPACK_IMPORTED_MODULE_3__["createLabeledInput"])({ container: container, labelText: 'roomName', placeHolder: 'roomName', initialValue: "roomName" });
    // const accountSid =  createLabeledInput({ container, labelText: 'accountSid', placeHolder: 'ACxxxx', initialValue: "ACxxx" });
    var apiKeySid = Object(_components_createLabeledInput__WEBPACK_IMPORTED_MODULE_3__["createLabeledInput"])({ container: container, labelText: 'apiKeySid', placeHolder: 'SKxxx', initialValue: "SKxxx" });
    var apiKeySecret = Object(_components_createLabeledInput__WEBPACK_IMPORTED_MODULE_3__["createLabeledInput"])({ container: container, labelText: 'apiKeySecret', placeHolder: 'xxxx', initialValue: "xxxx" });
    var envSelect = Object(_components_createSelection__WEBPACK_IMPORTED_MODULE_5__["createSelection"])({
        container: container,
        // id: 'env',
        options: ['dev', 'stage', 'prod'],
        title: 'env',
        onChange: function () { return Object(_components_log__WEBPACK_IMPORTED_MODULE_2__["log"])('env change:', envSelect.getValue()); }
    });
    var topologySelect = Object(_components_createSelection__WEBPACK_IMPORTED_MODULE_5__["createSelection"])({
        container: container,
        // id: 'topology',
        options: ['group-small', 'peer-to-peer', 'group', 'go'],
        title: 'topology',
        onChange: function () { return Object(_components_log__WEBPACK_IMPORTED_MODULE_2__["log"])('topology change:', topologySelect.getValue()); }
    });
    Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('createRoom', container, function () { return __awaiter(_this, void 0, void 0, function () {
        var HOST_NAME_REST, HOST_URL_REST, searchParams, roomResult, json;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    HOST_NAME_REST = envSelect.getValue() === 'prod' ? 'video.twilio.com' : "video." + envSelect.getValue() + ".twilio.com";
                    HOST_URL_REST = 'https://' + HOST_NAME_REST;
                    searchParams = new URLSearchParams({ Type: topologySelect.getValue(), UniqueName: roomNameInput.value });
                    return [4 /*yield*/, fetch(HOST_URL_REST + "/v1/Rooms", {
                            "headers": {
                                "authorization": 'Basic ' + btoa(apiKeySid.value + ":" + apiKeySecret.value),
                                "content-type": "application/x-www-form-urlencoded",
                                "sec-fetch-dest": "empty",
                                "sec-fetch-mode": "cors",
                                "sec-fetch-site": "cross-site"
                            },
                            "body": searchParams,
                            "method": "POST",
                            "mode": "cors",
                            "credentials": "include"
                        })];
                case 1:
                    roomResult = _a.sent();
                    if (!roomResult.ok) return [3 /*break*/, 3];
                    return [4 /*yield*/, roomResult.json()];
                case 2:
                    json = _a.sent();
                    if (json.status === 'in-progress') {
                        return [2 /*return*/, json];
                    }
                    _a.label = 3;
                case 3:
                    console.log('Failed to create room: ', roomResult);
                    throw new Error("Could not create " + topologySelect.getValue() + " Room: " + roomNameInput.value);
            }
        });
    }); });
}


/***/ }),

/***/ "./src/components/button.ts":
/*!**********************************!*\
  !*** ./src/components/button.ts ***!
  \**********************************/
/*! exports provided: createButton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createButton", function() { return createButton; });
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../jss */ "./src/jss.ts");
;

// Create your style.
var style = {
    button: {
        height: '2em',
        margin: '2px',
    },
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_0__["default"].createStyleSheet(style);
sheet.attach();
function createButton(text, container, onClick) {
    var btn = document.createElement('button');
    btn.classList.add(sheet.classes.button);
    btn.innerHTML = text;
    btn.onclick = onClick;
    container.appendChild(btn);
    return {
        btn: btn,
        show: function (visible) { btn.style.display = visible ? 'inline-block' : 'none'; },
        text: function (newText) { btn.innerHTML = newText; },
        click: function () { return onClick(); },
        enable: function () { btn.disabled = false; },
        disable: function () { btn.disabled = true; }
    };
}


/***/ }),

/***/ "./src/components/createDiv.ts":
/*!*************************************!*\
  !*** ./src/components/createDiv.ts ***!
  \*************************************/
/*! exports provided: createDiv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDiv", function() { return createDiv; });
/* harmony import */ var _createElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createElement */ "./src/components/createElement.ts");

function createDiv(container, divClass, id) {
    divClass = Array.isArray(divClass) ? divClass : [divClass];
    return Object(_createElement__WEBPACK_IMPORTED_MODULE_0__["createElement"])({ container: container, type: 'div', classNames: divClass, id: id });
}


/***/ }),

/***/ "./src/components/createElement.ts":
/*!*****************************************!*\
  !*** ./src/components/createElement.ts ***!
  \*****************************************/
/*! exports provided: createElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return createElement; });
function createElement(_a) {
    var _b;
    var container = _a.container, type = _a.type, id = _a.id, classNames = _a.classNames, style = _a.style, innerHtml = _a.innerHtml;
    var el = document.createElement(type);
    if (id) {
        el.id = id;
    }
    if (classNames) {
        (_b = el.classList).add.apply(_b, classNames);
    }
    if (style) {
        el.setAttribute('style', style);
    }
    if (innerHtml) {
        el.innerHTML = innerHtml;
    }
    container.appendChild(el);
    return el;
}


/***/ }),

/***/ "./src/components/createLabeledInput.ts":
/*!**********************************************!*\
  !*** ./src/components/createLabeledInput.ts ***!
  \**********************************************/
/*! exports provided: createLabeledInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLabeledInput", function() { return createLabeledInput; });
/* harmony import */ var _createElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createElement */ "./src/components/createElement.ts");

function createLabeledInput(_a) {
    var container = _a.container, labelText = _a.labelText, placeHolder = _a.placeHolder, initialValue = _a.initialValue, _b = _a.labelClasses, labelClasses = _b === void 0 ? [] : _b, _c = _a.inputType, inputType = _c === void 0 ? 'input' : _c, _d = _a.inputClasses, inputClasses = _d === void 0 ? [] : _d, _e = _a.labelParent, labelParent = _e === void 0 ? false : _e;
    var identityLabel = null;
    if (typeof labelText === 'string') {
        identityLabel = Object(_createElement__WEBPACK_IMPORTED_MODULE_0__["createElement"])({ container: container, type: 'label', classNames: labelClasses, innerHtml: labelText });
    }
    else {
        identityLabel = labelText;
    }
    var inputElement = Object(_createElement__WEBPACK_IMPORTED_MODULE_0__["createElement"])({ container: labelParent ? identityLabel : container, type: inputType, classNames: inputClasses });
    inputElement.placeholder = placeHolder;
    if (initialValue) {
        inputElement.value = initialValue;
    }
    return inputElement;
}


/***/ }),

/***/ "./src/components/createLink.ts":
/*!**************************************!*\
  !*** ./src/components/createLink.ts ***!
  \**************************************/
/*! exports provided: createLink */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLink", function() { return createLink; });
/* harmony import */ var _createElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createElement */ "./src/components/createElement.ts");

function createLink(_a) {
    var container = _a.container, linkText = _a.linkText, linkUrl = _a.linkUrl, _b = _a.newTab, newTab = _b === void 0 ? false : _b;
    var a = Object(_createElement__WEBPACK_IMPORTED_MODULE_0__["createElement"])({ container: container, type: 'a' });
    a.appendChild(document.createTextNode(linkText));
    a.title = linkText;
    a.href = linkUrl;
    if (newTab) {
        a.target = '_blank';
    }
    return a;
}


/***/ }),

/***/ "./src/components/createSelection.ts":
/*!*******************************************!*\
  !*** ./src/components/createSelection.ts ***!
  \*******************************************/
/*! exports provided: createSelection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSelection", function() { return createSelection; });
function createSelection(_a) {
    var _b, _c;
    var id = _a.id, container = _a.container, _d = _a.options, options = _d === void 0 ? ['dog', 'cat', 'parrot', 'rabbit'] : _d, _e = _a.title, title = _e === void 0 ? 'Pets' : _e, _f = _a.selectClasses, selectClasses = _f === void 0 ? [] : _f, _g = _a.labelClasses, labelClasses = _g === void 0 ? [] : _g, _h = _a.onChange, onChange = _h === void 0 ? function () { } : _h;
    var select = document.createElement('select');
    if (id) {
        select.id = id;
    }
    (_b = select.classList).add.apply(_b, selectClasses);
    for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
        var val = options_1[_i];
        var option = document.createElement('option');
        option.value = val;
        option.text = val;
        select.appendChild(option);
    }
    var label = document.createElement('label');
    label.innerHTML = title;
    label.htmlFor = select.id;
    (_c = label.classList).add.apply(_c, labelClasses);
    select.addEventListener('change', onChange);
    container.appendChild(label).appendChild(select);
    return {
        select: select,
        getValue: function () { return select.value; },
        setValue: function (value) { select.value = value; /* not if the value is not one of the options then a blank value gets selected */ }
    };
}


/***/ }),

/***/ "./src/components/log.ts":
/*!*******************************!*\
  !*** ./src/components/log.ts ***!
  \*******************************/
/*! exports provided: createLog, log */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLog", function() { return createLog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony import */ var _button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./button */ "./src/components/button.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../jss */ "./src/jss.ts");
/* eslint-disable no-console */


// Create your style.
var style = {
    logDiv: {
        height: '15em',
        padding: '1.5em',
        'min-height': '100%',
        'max-height': '100%',
        'margin-top': '3.125em',
        'text-align': 'left',
        'overflow-y': 'scroll',
    },
    logP: {
        color: '#686865',
        width: '90%',
        'font-family': '\'Share Tech Mono\', \'Courier New\', Courier, fixed-width',
        'font-size': '1.25em',
        'line-height': '1.25em',
        'margin-left': '1em',
        'text-indent': '-1.25em',
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_1__["default"].createStyleSheet(style);
sheet.attach();
var logClearBtn;
var realLogDiv;
function createLog(logDiv) {
    if (!logClearBtn) {
        if (!logDiv) {
            logDiv = document.createElement('div');
            logDiv.classList.add(sheet.classes.logDiv);
            document.body.appendChild(logDiv);
        }
        logClearBtn = Object(_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('clear log', logDiv, function () {
            realLogDiv.innerHTML = '';
        });
        realLogDiv = document.createElement('div');
        logDiv.appendChild(realLogDiv);
    }
}
function log() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    createLog();
    var message = args.map(function (arg) { return String(arg); }).join(', ');
    realLogDiv.innerHTML += '<p>' + message + '</p>';
    realLogDiv.scrollTop = realLogDiv.scrollHeight;
    console.log.apply(console, args);
}


/***/ }),

/***/ "./src/jss.ts":
/*!********************!*\
  !*** ./src/jss.ts ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jss */ "./node_modules/jss/dist/jss.esm.js");
/* harmony import */ var jss_preset_default__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss-preset-default */ "./node_modules/jss-preset-default/dist/jss-preset-default.esm.js");
/* eslint-disable no-undefined */
/* eslint-disable require-atomic-updates */
/* eslint-disable no-console */
/* eslint-disable quotes */



jss__WEBPACK_IMPORTED_MODULE_0__["default"].setup(Object(jss_preset_default__WEBPACK_IMPORTED_MODULE_1__["default"])());
/* harmony default export */ __webpack_exports__["default"] = (jss__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWNrb2ZmL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWNrb2ZmL2xpYi9iYWNrb2ZmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWNrb2ZmL2xpYi9mdW5jdGlvbl9jYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWNrb2ZmL2xpYi9zdHJhdGVneS9leHBvbmVudGlhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFja29mZi9saWIvc3RyYXRlZ3kvZmlib25hY2NpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWNrb2ZmL2xpYi9zdHJhdGVneS9zdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLXZlbmRvci9kaXN0L2Nzcy12ZW5kb3IuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oeXBoZW5hdGUtc3R5bGUtbmFtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtaW4tYnJvd3Nlci9kaXN0L21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1jYW1lbC1jYXNlL2Rpc3QvanNzLXBsdWdpbi1jYW1lbC1jYXNlLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1jb21wb3NlL2Rpc3QvanNzLXBsdWdpbi1jb21wb3NlLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1kZWZhdWx0LXVuaXQvZGlzdC9qc3MtcGx1Z2luLWRlZmF1bHQtdW5pdC5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tZXhwYW5kL2Rpc3QvanNzLXBsdWdpbi1leHBhbmQuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLWV4dGVuZC9kaXN0L2pzcy1wbHVnaW4tZXh0ZW5kLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1nbG9iYWwvZGlzdC9qc3MtcGx1Z2luLWdsb2JhbC5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tbmVzdGVkL2Rpc3QvanNzLXBsdWdpbi1uZXN0ZWQuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLXByb3BzLXNvcnQvZGlzdC9qc3MtcGx1Z2luLXByb3BzLXNvcnQuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLXJ1bGUtdmFsdWUtZnVuY3Rpb24vZGlzdC9qc3MtcGx1Z2luLXJ1bGUtdmFsdWUtZnVuY3Rpb24uZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLXJ1bGUtdmFsdWUtb2JzZXJ2YWJsZS9kaXN0L2pzcy1wbHVnaW4tcnVsZS12YWx1ZS1vYnNlcnZhYmxlLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi10ZW1wbGF0ZS9kaXN0L2pzcy1wbHVnaW4tdGVtcGxhdGUuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLXZlbmRvci1wcmVmaXhlci9kaXN0L2pzcy1wbHVnaW4tdmVuZG9yLXByZWZpeGVyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNzLXByZXNldC1kZWZhdWx0L2Rpc3QvanNzLXByZXNldC1kZWZhdWx0LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNzL2Rpc3QvanNzLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJlY29uZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJlY29uZC9saWIvY2hlY2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcmVjb25kL2xpYi9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2VzL3BvbnlmaWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW55LXdhcm5pbmcvZGlzdC90aW55LXdhcm5pbmcuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L2NhbmNlbGFibGVyb29tcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9jb25uZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L2NyZWF0ZWxvY2FsdHJhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvY3JlYXRlbG9jYWx0cmFja3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvZGF0YS9yZWNlaXZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9kYXRhL3NlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9kYXRhL3RyYW5zY2VpdmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L2RhdGEvdHJhbnNwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L2VuY29kaW5ncGFyYW1ldGVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9ldmVudGVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvbG9jYWxwYXJ0aWNpcGFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9tZWRpYS90cmFjay9hdWRpb3RyYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L21lZGlhL3RyYWNrL2VzNS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9tZWRpYS90cmFjay9lczUvbG9jYWxhdWRpb3RyYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L21lZGlhL3RyYWNrL2VzNS9sb2NhbGRhdGF0cmFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9tZWRpYS90cmFjay9lczUvbG9jYWx2aWRlb3RyYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L21lZGlhL3RyYWNrL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L21lZGlhL3RyYWNrL2xvY2FsYXVkaW90cmFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9tZWRpYS90cmFjay9sb2NhbGF1ZGlvdHJhY2twdWJsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9tZWRpYS90cmFjay9sb2NhbGRhdGF0cmFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9tZWRpYS90cmFjay9sb2NhbGRhdGF0cmFja3B1YmxpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L21lZGlhL3RyYWNrL2xvY2FsbWVkaWF0cmFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9tZWRpYS90cmFjay9sb2NhbHRyYWNrcHVibGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvbWVkaWEvdHJhY2svbG9jYWx2aWRlb3RyYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L21lZGlhL3RyYWNrL2xvY2FsdmlkZW90cmFja3B1YmxpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L21lZGlhL3RyYWNrL21lZGlhdHJhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvbWVkaWEvdHJhY2svcmVjZWl2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvbWVkaWEvdHJhY2svcmVtb3RlYXVkaW90cmFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9tZWRpYS90cmFjay9yZW1vdGVhdWRpb3RyYWNrcHVibGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvbWVkaWEvdHJhY2svcmVtb3RlZGF0YXRyYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L21lZGlhL3RyYWNrL3JlbW90ZWRhdGF0cmFja3B1YmxpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L21lZGlhL3RyYWNrL3JlbW90ZW1lZGlhdHJhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvbWVkaWEvdHJhY2svcmVtb3RldHJhY2twdWJsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9tZWRpYS90cmFjay9yZW1vdGV2aWRlb3RyYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L21lZGlhL3RyYWNrL3JlbW90ZXZpZGVvdHJhY2twdWJsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9tZWRpYS90cmFjay9zZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvbWVkaWEvdHJhY2svdHJhY2twdWJsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9tZWRpYS90cmFjay90cmFuc2NlaXZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9tZWRpYS90cmFjay92aWRlb3Byb2Nlc3NvcmV2ZW50b2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvbWVkaWEvdHJhY2svdmlkZW90cmFjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9uZXR3b3JrcXVhbGl0eWNvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvcGFydGljaXBhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvcHJlZmxpZ2h0L2dldENvbWJpbmVkQ29ubmVjdGlvblN0YXRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3ByZWZsaWdodC9nZXR0dXJuY3JlZGVudGlhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvcHJlZmxpZ2h0L21ha2VzdGF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3ByZWZsaWdodC9tb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvcHJlZmxpZ2h0L3ByZWZsaWdodHRlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvcHJlZmxpZ2h0L3N5bnRoZXRpY2F1ZGlvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3ByZWZsaWdodC9zeW50aGV0aWN2aWRlby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9wcmVmbGlnaHQvdGltZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvcXVldWVpbmdldmVudGVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvcmVtb3RlcGFydGljaXBhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvcm9vbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zaWduYWxpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL2xvY2FscGFydGljaXBhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL2xvY2FsdHJhY2twdWJsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zaWduYWxpbmcvcGFydGljaXBhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3JlY29yZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zaWduYWxpbmcvcmVtb3RlcGFydGljaXBhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3JlbW90ZXRyYWNrcHVibGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3Jvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3RyYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3NpZ25hbGluZy92Mi9jYW5jZWxhYmxlcm9vbXNpZ25hbGluZ3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3YyL2RvbWluYW50c3BlYWtlcnNpZ25hbGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zaWduYWxpbmcvdjIvaWNlYm94LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3NpZ25hbGluZy92Mi9pY2Vjb25uZWN0aW9ubW9uaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zaWduYWxpbmcvdjIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3YyL2xvY2FscGFydGljaXBhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3YyL2xvY2FsdHJhY2twdWJsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zaWduYWxpbmcvdjIvbWVkaWFzaWduYWxpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3YyL25ldHdvcmtxdWFsaXR5bW9uaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zaWduYWxpbmcvdjIvbmV0d29ya3F1YWxpdHlzaWduYWxpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3YyL3BlZXJjb25uZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3NpZ25hbGluZy92Mi9wZWVyY29ubmVjdGlvbm1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3YyL3B1Ymxpc2hlcmhpbnRzaWduYWxpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3YyL3JlY29yZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zaWduYWxpbmcvdjIvcmVtb3RlcGFydGljaXBhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3YyL3JlbW90ZXRyYWNrcHVibGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3YyL3JlbmRlcmhpbnRzc2lnbmFsaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3NpZ25hbGluZy92Mi9yb29tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3NpZ25hbGluZy92Mi90cmFja3ByaW9yaXR5c2lnbmFsaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3NpZ25hbGluZy92Mi90cmFja3N3aXRjaG9mZnNpZ25hbGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zaWduYWxpbmcvdjIvdHdpbGlvY29ubmVjdGlvbnRyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zaWduYWxpbmcvdjMvcmVtb3RlcGFydGljaXBhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3YzL3JlbW90ZXRyYWNrcHVibGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3YzL3Jvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc2lnbmFsaW5nL3YzL3RyYWNrc3Vic2NyaXB0aW9uc3NpZ25hbGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zdGF0ZW1hY2hpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvYXZlcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zdGF0cy9pY2VyZXBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvaWNlcmVwb3J0ZmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zdGF0cy9sb2NhbGF1ZGlvdHJhY2tzdGF0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zdGF0cy9sb2NhbHRyYWNrc3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvbG9jYWx2aWRlb3RyYWNrc3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvbmV0d29ya3F1YWxpdHlhdWRpb3N0YXRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3N0YXRzL25ldHdvcmtxdWFsaXR5YmFuZHdpZHRoc3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvbmV0d29ya3F1YWxpdHlmcmFjdGlvbmxvc3RzdGF0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zdGF0cy9uZXR3b3JrcXVhbGl0eWxhdGVuY3lzdGF0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zdGF0cy9uZXR3b3JrcXVhbGl0eW1lZGlhc3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvbmV0d29ya3F1YWxpdHlyZWN2c3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvbmV0d29ya3F1YWxpdHlzZW5kb3JyZWN2c3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvbmV0d29ya3F1YWxpdHlzZW5kc3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvbmV0d29ya3F1YWxpdHlzdGF0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zdGF0cy9uZXR3b3JrcXVhbGl0eXZpZGVvc3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvcGVlcmNvbm5lY3Rpb25yZXBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvcGVlcmNvbm5lY3Rpb25yZXBvcnRmYWN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3N0YXRzL3JlY2VpdmVycmVwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3N0YXRzL3JlY2VpdmVycmVwb3J0ZmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zdGF0cy9yZW1vdGVhdWRpb3RyYWNrc3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvcmVtb3RldHJhY2tzdGF0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zdGF0cy9yZW1vdGV2aWRlb3RyYWNrc3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvc2VuZGVyb3JyZWNlaXZlcnJlcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zdGF0cy9zZW5kZXJvcnJlY2VpdmVycmVwb3J0ZmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zdGF0cy9zZW5kZXJyZXBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvc2VuZGVycmVwb3J0ZmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zdGF0cy9zdGF0c3JlcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS9zdGF0cy9zdW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvc3RhdHMvdHJhY2tzdGF0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS90cmFuc2NlaXZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS90d2lsaW9jb25uZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3V0aWwvYXN5bmN2YXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvdXRpbC9icm93c2VyZGV0ZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3V0aWwvY2FuY2VsYWJsZXByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvdXRpbC9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvdXRpbC9kZXRlY3RzaWxlbnRhdWRpby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS91dGlsL2RldGVjdHNpbGVudHZpZGVvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3V0aWwvZG9jdW1lbnR2aXNpYmlsaXR5bW9uaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS91dGlsL2V2ZW50b2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvdXRpbC9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvdXRpbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS91dGlsL2luc2lnaHRzcHVibGlzaGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3V0aWwvaW5zaWdodHNwdWJsaXNoZXIvbnVsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS91dGlsL2xvY2FsbWVkaWFyZXN0YXJ0ZGVmZXJyZWRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3V0aWwvbG9nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3V0aWwvbW92aW5nYXZlcmFnZWRlbHRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3V0aWwvbmV0d29ya21vbml0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvdXRpbC9udWxsb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvdXRpbC9zZHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvdXRpbC9zZHAvaXNzdWU4MzI5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3V0aWwvc2RwL3NpbXVsY2FzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS91dGlsL3NkcC90cmFja21hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvdXRpbC9zaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvdXRpbC9zdXBwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3V0aWwvdGltZW91dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS91dGlsL3R3aWxpby12aWRlby1lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvdXRpbC90d2lsaW9lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS91dGlsL3ZhbGlkYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3ZlbmRvci9sb2dsZXZlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS93ZWJhdWRpby9hdWRpb2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvd2ViYXVkaW8vZGV0ZWN0c2lsZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS93ZWJhdWRpby93b3JrYXJvdW5kMTgwNzQ4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3dlYnJ0Yy9nZXRzdGF0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS93ZWJydGMvZ2V0dXNlcm1lZGlhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3dlYnJ0Yy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS93ZWJydGMvbWVkaWFzdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvd2VicnRjL21lZGlhc3RyZWFtdHJhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvd2VicnRjL3J0Y2ljZWNhbmRpZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS93ZWJydGMvcnRjcGVlcmNvbm5lY3Rpb24vY2hyb21lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3dlYnJ0Yy9ydGNwZWVyY29ubmVjdGlvbi9maXJlZm94LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3dlYnJ0Yy9ydGNwZWVyY29ubmVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLXZpZGVvL2VzNS93ZWJydGMvcnRjcGVlcmNvbm5lY3Rpb24vc2FmYXJpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3dlYnJ0Yy9ydGNydHBzZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvd2VicnRjL3J0Y3Nlc3Npb25kZXNjcmlwdGlvbi9jaHJvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvd2VicnRjL3J0Y3Nlc3Npb25kZXNjcmlwdGlvbi9maXJlZm94LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vZXM1L3dlYnJ0Yy9ydGNzZXNzaW9uZGVzY3JpcHRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvd2VicnRjL3V0aWwvZXZlbnR0YXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvd2VicnRjL3V0aWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvd2VicnRjL3V0aWwvbGF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWxpby12aWRlby9lczUvd2VicnRjL3V0aWwvc2RwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d2lsaW8tdmlkZW8vc3JjL3dzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FkbWluLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2J1dHRvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9jcmVhdGVEaXYudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvY3JlYXRlRWxlbWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9jcmVhdGVMYWJlbGVkSW5wdXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvY3JlYXRlTGluay50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9jcmVhdGVTZWxlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvbG9nLnRzIiwid2VicGFjazovLy8uL3NyYy9qc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7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QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDLHFDQUFxQzs7QUFFckM7QUFDQSxrRUFBa0U7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHlCQUF5QjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQsYUFBYTtBQUMxRTtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoZkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVlLGlGQUFrQjs7Ozs7Ozs7Ozs7OztBQ2xCakM7QUFBQTtBQUFBLG9HQUFvRyxtQkFBbUIsRUFBRSxtQkFBbUIsOEhBQThIOztBQUVuUTs7QUFFUSx3RUFBUyxFQUFDOzs7Ozs7Ozs7Ozs7O0FDSnpCO0FBQUE7QUFBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxvRUFBUztBQUN6RDtBQUNBOztBQUVBO0FBQ0EsK0ZBQStGO0FBQy9GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsb0VBQVMsT0FBTzs7QUFFekM7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSx3RUFBUyxFQUFDOzs7Ozs7Ozs7Ozs7O0FDL0R6QjtBQUFBO0FBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUNBQW1DLHlCQUF5Qjs7QUFFMUY7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsMENBQTBDLG9CQUFvQjs7O0FBR2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBcUMsR0FBRyw0REFBTyx3RUFBd0UsU0FBTTtBQUNuSTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxLQUFxQyxHQUFHLDREQUFPLHFFQUFxRSxTQUFNO0FBQ2hJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSx5RUFBVSxFQUFDOzs7Ozs7Ozs7Ozs7O0FDeEUxQjtBQUFBO0FBQXVDOztBQUV2QyxTQUFTLG9EQUFnQjtBQUN6QixTQUFTLG9EQUFnQjtBQUN6QixjQUFjLG9EQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsR0FBRztBQUNILDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSwwRUFBVyxFQUFDOzs7Ozs7Ozs7Ozs7O0FDM1AzQjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUIsK0JBQStCO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtB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QTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsMkJBQTJCO0FBQ3BELHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0ZBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGVBQWU7QUFDcEI7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtB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Q0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1REFBdUQ7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpRUFBaUU7QUFDM0c7QUFDQTtBQUNBLDJEQUEyRCx1Q0FBdUMsRUFBRTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELDBCQUEwQixFQUFFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNy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Q0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdEQUF3RCwyQ0FBMkMsRUFBRTtBQUNyRyxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLDBEQUEwRCxFQUFFO0FBQzVJO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FB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O0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsOENBQThDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsa0NBQWtDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsOEJBQThCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsOEJBQThCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsbUNBQW1DO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsK0JBQStCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsZ0NBQWdDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsMENBQTBDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsMkJBQTJCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsNENBQTRDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsOEJBQThCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsb0NBQW9DO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsOENBQThDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsd0NBQXdDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsZ0NBQWdDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsNkJBQTZCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsb0NBQW9DO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQscUNBQXFDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQseUNBQXlDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsb0RBQW9EO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsNEJBQTRCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsNENBQTRDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsd0NBQXdDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQseUNBQXlDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQseUNBQXlDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsOENBQThDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsMkNBQTJDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsa0NBQWtDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsMkNBQTJDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsMkJBQTJCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsK0JBQStCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsK0JBQStCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsb0NBQW9DO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsb0NBQW9DO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsOENBQThDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQseUNBQXlDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQseUNBQXlDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsMENBQTBDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsMENBQTBDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsb0NBQW9DO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpREFBaUQsOEJBQThCO0FBQy9F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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHdCQUF3QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxXQUFXLGtCQUFrQjtBQUM3QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyx5QkFBeUI7QUFDcEMsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDOzs7Ozs7Ozs7Ozs7QUM3ZkE7QUFDYTtBQUNiLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFxQjtBQUMvQyxtQ0FBbUMsbUJBQU8sQ0FBQyxpSEFBa0M7QUFDN0UsZUFBZSxtQkFBTyxDQUFDLHlDQUFNO0FBQzdCLDBCQUEwQixtQkFBTyxDQUFDLHVFQUFhO0FBQy9DLFdBQVcsbUJBQU8sQ0FBQyxxRUFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsV0FBVyxzQkFBc0I7QUFDakMsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsT0FBTztBQUNsQixhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQzs7Ozs7Ozs7Ozs7O0FDclNhO0FBQ2I7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyxxRUFBUztBQUN4QztBQUNBO0FBQ0EsNkJBQTZCLG1CQUFPLENBQUMsb0ZBQVU7QUFDL0M7QUFDQTtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLHNGQUFXO0FBQ2hEO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQU8sQ0FBQyxvRkFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNhO0FBQ2Isa0JBQWtCLG1CQUFPLENBQUMsdUZBQXFCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyx5Q0FBTTtBQUM3QixZQUFZLG1CQUFPLENBQUMsMkVBQWU7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLHVFQUFhO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxxRUFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx3QkFBd0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsd0JBQXdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDOzs7Ozs7Ozs7Ozs7QUMzVmE7QUFDYjtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Qzs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ2E7QUFDYjtBQUNBLG1DOzs7Ozs7Ozs7Ozs7QUNIQTtBQUNhO0FBQ2I7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyxxRUFBUztBQUN4QztBQUNBO0FBQ0EsNkJBQTZCLG1CQUFPLENBQUMsd0ZBQVU7QUFDL0M7QUFDQTtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLDBGQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7Ozs7Ozs7O0FDckJhO0FBQ2IsbUJBQW1CLG1CQUFPLENBQUMsK0NBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7Ozs7Ozs7Ozs7OztBQ2pDYTtBQUNiO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsdUJBQXVCO0FBQ2xDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7Ozs7OztBQ25UYTtBQUNiLFlBQVksbUJBQU8sQ0FBQyxnRUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QixnQ0FBZ0Msa0JBQWtCLE1BQU0sa0JBQWtCO0FBQzFFLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7Ozs7Ozs7O0FDeEdBO0FBQ2E7QUFDYixjQUFjLG1CQUFPLENBQUMsZ0VBQUk7QUFDMUIsbUJBQW1CLG1CQUFPLENBQUMsZ0VBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLHNDQUFzQztBQUNqRCxXQUFXLE9BQU87QUFDbEIsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQsV0FBVyx5QkFBeUI7QUFDcEMsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzUkE7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsMEVBQW9COztBQUUvQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FB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MkI7QUFDZDtBQUNTO0FBQ2tCO0FBRXhDLDJDQUFHLENBQUMsS0FBSyxDQUFDLGtFQUFNLEVBQUUsQ0FBQyxDQUFDO0FBQ0wsMEdBQUcsRUFBQyIsImZpbGUiOiJhZG1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2FkbWluLnRzXCIpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufSIsImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufSIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSIsImltcG9ydCBzZXRQcm90b3R5cGVPZiBmcm9tIFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59IiwiaW1wb3J0IGFycmF5V2l0aG91dEhvbGVzIGZyb20gXCIuL2FycmF5V2l0aG91dEhvbGVzLmpzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5IGZyb20gXCIuL2l0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCI7XG5pbXBvcnQgbm9uSXRlcmFibGVTcHJlYWQgZnJvbSBcIi4vbm9uSXRlcmFibGVTcHJlYWQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufSIsImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59IiwiLy8gICAgICBDb3B5cmlnaHQgKGMpIDIwMTIgTWF0aGlldSBUdXJjb3R0ZVxuLy8gICAgICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnLi9saWIvYmFja29mZicpO1xudmFyIEV4cG9uZW50aWFsQmFja29mZlN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9saWIvc3RyYXRlZ3kvZXhwb25lbnRpYWwnKTtcbnZhciBGaWJvbmFjY2lCYWNrb2ZmU3RyYXRlZ3kgPSByZXF1aXJlKCcuL2xpYi9zdHJhdGVneS9maWJvbmFjY2knKTtcbnZhciBGdW5jdGlvbkNhbGwgPSByZXF1aXJlKCcuL2xpYi9mdW5jdGlvbl9jYWxsLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzLkJhY2tvZmYgPSBCYWNrb2ZmO1xubW9kdWxlLmV4cG9ydHMuRnVuY3Rpb25DYWxsID0gRnVuY3Rpb25DYWxsO1xubW9kdWxlLmV4cG9ydHMuRmlib25hY2NpU3RyYXRlZ3kgPSBGaWJvbmFjY2lCYWNrb2ZmU3RyYXRlZ3k7XG5tb2R1bGUuZXhwb3J0cy5FeHBvbmVudGlhbFN0cmF0ZWd5ID0gRXhwb25lbnRpYWxCYWNrb2ZmU3RyYXRlZ3k7XG5cbi8vIENvbnN0cnVjdHMgYSBGaWJvbmFjY2kgYmFja29mZi5cbm1vZHVsZS5leHBvcnRzLmZpYm9uYWNjaSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEJhY2tvZmYobmV3IEZpYm9uYWNjaUJhY2tvZmZTdHJhdGVneShvcHRpb25zKSk7XG59O1xuXG4vLyBDb25zdHJ1Y3RzIGFuIGV4cG9uZW50aWFsIGJhY2tvZmYuXG5tb2R1bGUuZXhwb3J0cy5leHBvbmVudGlhbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEJhY2tvZmYobmV3IEV4cG9uZW50aWFsQmFja29mZlN0cmF0ZWd5KG9wdGlvbnMpKTtcbn07XG5cbi8vIENvbnN0cnVjdHMgYSBGdW5jdGlvbkNhbGwgZm9yIHRoZSBnaXZlbiBmdW5jdGlvbiBhbmQgYXJndW1lbnRzLlxubW9kdWxlLmV4cG9ydHMuY2FsbCA9IGZ1bmN0aW9uKGZuLCB2YXJncywgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgZm4gPSBhcmdzWzBdO1xuICAgIHZhcmdzID0gYXJncy5zbGljZSgxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgIGNhbGxiYWNrID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25DYWxsKGZuLCB2YXJncywgY2FsbGJhY2spO1xufTtcbiIsIi8vICAgICAgQ29weXJpZ2h0IChjKSAyMDEyIE1hdGhpZXUgVHVyY290dGVcbi8vICAgICAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgcHJlY29uZCA9IHJlcXVpcmUoJ3ByZWNvbmQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vLyBBIGNsYXNzIHRvIGhvbGQgdGhlIHN0YXRlIG9mIGEgYmFja29mZiBvcGVyYXRpb24uIEFjY2VwdHMgYSBiYWNrb2ZmIHN0cmF0ZWd5XG4vLyB0byBnZW5lcmF0ZSB0aGUgYmFja29mZiBkZWxheXMuXG5mdW5jdGlvbiBCYWNrb2ZmKGJhY2tvZmZTdHJhdGVneSkge1xuICAgIGV2ZW50cy5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuYmFja29mZlN0cmF0ZWd5XyA9IGJhY2tvZmZTdHJhdGVneTtcbiAgICB0aGlzLm1heE51bWJlck9mUmV0cnlfID0gLTE7XG4gICAgdGhpcy5iYWNrb2ZmTnVtYmVyXyA9IDA7XG4gICAgdGhpcy5iYWNrb2ZmRGVsYXlfID0gMDtcbiAgICB0aGlzLnRpbWVvdXRJRF8gPSAtMTtcblxuICAgIHRoaXMuaGFuZGxlcnMgPSB7XG4gICAgICAgIGJhY2tvZmY6IHRoaXMub25CYWNrb2ZmXy5iaW5kKHRoaXMpXG4gICAgfTtcbn1cbnV0aWwuaW5oZXJpdHMoQmFja29mZiwgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cbi8vIFNldHMgYSBsaW1pdCwgZ3JlYXRlciB0aGFuIDAsIG9uIHRoZSBtYXhpbXVtIG51bWJlciBvZiBiYWNrb2Zmcy4gQSAnZmFpbCdcbi8vIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCB3aGVuIHRoZSBsaW1pdCBpcyByZWFjaGVkLlxuQmFja29mZi5wcm90b3R5cGUuZmFpbEFmdGVyID0gZnVuY3Rpb24obWF4TnVtYmVyT2ZSZXRyeSkge1xuICAgIHByZWNvbmQuY2hlY2tBcmd1bWVudChtYXhOdW1iZXJPZlJldHJ5ID4gMCxcbiAgICAgICAgJ0V4cGVjdGVkIGEgbWF4aW11bSBudW1iZXIgb2YgcmV0cnkgZ3JlYXRlciB0aGFuIDAgYnV0IGdvdCAlcy4nLFxuICAgICAgICBtYXhOdW1iZXJPZlJldHJ5KTtcblxuICAgIHRoaXMubWF4TnVtYmVyT2ZSZXRyeV8gPSBtYXhOdW1iZXJPZlJldHJ5O1xufTtcblxuLy8gU3RhcnRzIGEgYmFja29mZiBvcGVyYXRpb24uIEFjY2VwdHMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIGxldCB0aGVcbi8vIGxpc3RlbmVycyBrbm93IHdoeSB0aGUgYmFja29mZiBvcGVyYXRpb24gd2FzIHN0YXJ0ZWQuXG5CYWNrb2ZmLnByb3RvdHlwZS5iYWNrb2ZmID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgcHJlY29uZC5jaGVja1N0YXRlKHRoaXMudGltZW91dElEXyA9PT0gLTEsICdCYWNrb2ZmIGluIHByb2dyZXNzLicpO1xuXG4gICAgaWYgKHRoaXMuYmFja29mZk51bWJlcl8gPT09IHRoaXMubWF4TnVtYmVyT2ZSZXRyeV8pIHtcbiAgICAgICAgdGhpcy5lbWl0KCdmYWlsJywgZXJyKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmFja29mZkRlbGF5XyA9IHRoaXMuYmFja29mZlN0cmF0ZWd5Xy5uZXh0KCk7XG4gICAgICAgIHRoaXMudGltZW91dElEXyA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVycy5iYWNrb2ZmLCB0aGlzLmJhY2tvZmZEZWxheV8pO1xuICAgICAgICB0aGlzLmVtaXQoJ2JhY2tvZmYnLCB0aGlzLmJhY2tvZmZOdW1iZXJfLCB0aGlzLmJhY2tvZmZEZWxheV8sIGVycik7XG4gICAgfVxufTtcblxuLy8gSGFuZGxlcyB0aGUgYmFja29mZiB0aW1lb3V0IGNvbXBsZXRpb24uXG5CYWNrb2ZmLnByb3RvdHlwZS5vbkJhY2tvZmZfID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50aW1lb3V0SURfID0gLTE7XG4gICAgdGhpcy5lbWl0KCdyZWFkeScsIHRoaXMuYmFja29mZk51bWJlcl8sIHRoaXMuYmFja29mZkRlbGF5Xyk7XG4gICAgdGhpcy5iYWNrb2ZmTnVtYmVyXysrO1xufTtcblxuLy8gU3RvcHMgYW55IGJhY2tvZmYgb3BlcmF0aW9uIGFuZCByZXNldHMgdGhlIGJhY2tvZmYgZGVsYXkgdG8gaXRzIGluaXRhbCB2YWx1ZS5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5iYWNrb2ZmTnVtYmVyXyA9IDA7XG4gICAgdGhpcy5iYWNrb2ZmU3RyYXRlZ3lfLnJlc2V0KCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElEXyk7XG4gICAgdGhpcy50aW1lb3V0SURfID0gLTE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG4iLCIvLyAgICAgIENvcHlyaWdodCAoYykgMjAxMiBNYXRoaWV1IFR1cmNvdHRlXG4vLyAgICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xudmFyIHByZWNvbmQgPSByZXF1aXJlKCdwcmVjb25kJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIEJhY2tvZmYgPSByZXF1aXJlKCcuL2JhY2tvZmYnKTtcbnZhciBGaWJvbmFjY2lCYWNrb2ZmU3RyYXRlZ3kgPSByZXF1aXJlKCcuL3N0cmF0ZWd5L2ZpYm9uYWNjaScpO1xuXG4vLyBXcmFwcyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiBhIGJhY2tvZmYgbG9vcC5cbmZ1bmN0aW9uIEZ1bmN0aW9uQ2FsbChmbiwgYXJncywgY2FsbGJhY2spIHtcbiAgICBldmVudHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICBwcmVjb25kLmNoZWNrSXNGdW5jdGlvbihmbiwgJ0V4cGVjdGVkIGZuIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgcHJlY29uZC5jaGVja0lzQXJyYXkoYXJncywgJ0V4cGVjdGVkIGFyZ3MgdG8gYmUgYW4gYXJyYXkuJyk7XG4gICAgcHJlY29uZC5jaGVja0lzRnVuY3Rpb24oY2FsbGJhY2ssICdFeHBlY3RlZCBjYWxsYmFjayB0byBiZSBhIGZ1bmN0aW9uLicpO1xuXG4gICAgdGhpcy5mdW5jdGlvbl8gPSBmbjtcbiAgICB0aGlzLmFyZ3VtZW50c18gPSBhcmdzO1xuICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XG4gICAgdGhpcy5sYXN0UmVzdWx0XyA9IFtdO1xuICAgIHRoaXMubnVtUmV0cmllc18gPSAwO1xuXG4gICAgdGhpcy5iYWNrb2ZmXyA9IG51bGw7XG4gICAgdGhpcy5zdHJhdGVneV8gPSBudWxsO1xuICAgIHRoaXMuZmFpbEFmdGVyXyA9IC0xO1xuICAgIHRoaXMucmV0cnlQcmVkaWNhdGVfID0gRnVuY3Rpb25DYWxsLkRFRkFVTFRfUkVUUllfUFJFRElDQVRFXztcblxuICAgIHRoaXMuc3RhdGVfID0gRnVuY3Rpb25DYWxsLlN0YXRlXy5QRU5ESU5HO1xufVxudXRpbC5pbmhlcml0cyhGdW5jdGlvbkNhbGwsIGV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG4vLyBTdGF0ZXMgaW4gd2hpY2ggdGhlIGNhbGwgY2FuIGJlLlxuRnVuY3Rpb25DYWxsLlN0YXRlXyA9IHtcbiAgICAvLyBDYWxsIGlzbid0IHN0YXJ0ZWQgeWV0LlxuICAgIFBFTkRJTkc6IDAsXG4gICAgLy8gQ2FsbCBpcyBpbiBwcm9ncmVzcy5cbiAgICBSVU5OSU5HOiAxLFxuICAgIC8vIENhbGwgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSB3aGljaCBtZWFucyB0aGF0IGVpdGhlciB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICAgIC8vIHJldHVybmVkIHN1Y2Nlc3NmdWxseSBvciB0aGUgbWF4aW1hbCBudW1iZXIgb2YgYmFja29mZnMgd2FzIHJlYWNoZWQuXG4gICAgQ09NUExFVEVEOiAyLFxuICAgIC8vIFRoZSBjYWxsIHdhcyBhYm9ydGVkLlxuICAgIEFCT1JURUQ6IDNcbn07XG5cbi8vIFRoZSBkZWZhdWx0IHJldHJ5IHByZWRpY2F0ZSB3aGljaCBjb25zaWRlcnMgYW55IGVycm9yIGFzIHJldHJpYWJsZS5cbkZ1bmN0aW9uQ2FsbC5ERUZBVUxUX1JFVFJZX1BSRURJQ0FURV8gPSBmdW5jdGlvbihlcnIpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBDaGVja3Mgd2hldGhlciB0aGUgY2FsbCBpcyBwZW5kaW5nLlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZV8gPT0gRnVuY3Rpb25DYWxsLlN0YXRlXy5QRU5ESU5HO1xufTtcblxuLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGNhbGwgaXMgaW4gcHJvZ3Jlc3MuXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLmlzUnVubmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlXyA9PSBGdW5jdGlvbkNhbGwuU3RhdGVfLlJVTk5JTkc7XG59O1xuXG4vLyBDaGVja3Mgd2hldGhlciB0aGUgY2FsbCBpcyBjb21wbGV0ZWQuXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLmlzQ29tcGxldGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVfID09IEZ1bmN0aW9uQ2FsbC5TdGF0ZV8uQ09NUExFVEVEO1xufTtcblxuLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGNhbGwgaXMgYWJvcnRlZC5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuaXNBYm9ydGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVfID09IEZ1bmN0aW9uQ2FsbC5TdGF0ZV8uQUJPUlRFRDtcbn07XG5cbi8vIFNldHMgdGhlIGJhY2tvZmYgc3RyYXRlZ3kgdG8gdXNlLiBDYW4gb25seSBiZSBjYWxsZWQgYmVmb3JlIHRoZSBjYWxsIGlzXG4vLyBzdGFydGVkIG90aGVyd2lzZSBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLnNldFN0cmF0ZWd5ID0gZnVuY3Rpb24oc3RyYXRlZ3kpIHtcbiAgICBwcmVjb25kLmNoZWNrU3RhdGUodGhpcy5pc1BlbmRpbmcoKSwgJ0Z1bmN0aW9uQ2FsbCBpbiBwcm9ncmVzcy4nKTtcbiAgICB0aGlzLnN0cmF0ZWd5XyA9IHN0cmF0ZWd5O1xuICAgIHJldHVybiB0aGlzOyAvLyBSZXR1cm4gdGhpcyBmb3IgY2hhaW5pbmcuXG59O1xuXG4vLyBTZXRzIHRoZSBwcmVkaWNhdGUgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBlcnJvcnNcbi8vIHJldHVybmVkIGZyb20gdGhlIHdyYXBwZWQgZnVuY3Rpb24gc2hvdWxkIGJlIHJldHJpZWQgb3Igbm90LCBlLmcuIGFcbi8vIG5ldHdvcmsgZXJyb3Igd291bGQgYmUgcmV0cmlhYmxlIHdoaWxlIGEgdHlwZSBlcnJvciB3b3VsZCBzdG9wIHRoZVxuLy8gZnVuY3Rpb24gY2FsbC5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUucmV0cnlJZiA9IGZ1bmN0aW9uKHJldHJ5UHJlZGljYXRlKSB7XG4gICAgcHJlY29uZC5jaGVja1N0YXRlKHRoaXMuaXNQZW5kaW5nKCksICdGdW5jdGlvbkNhbGwgaW4gcHJvZ3Jlc3MuJyk7XG4gICAgdGhpcy5yZXRyeVByZWRpY2F0ZV8gPSByZXRyeVByZWRpY2F0ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFJldHVybnMgYWxsIGludGVybWVkaWFyeSByZXN1bHRzIHJldHVybmVkIGJ5IHRoZSB3cmFwcGVkIGZ1bmN0aW9uIHNpbmNlXG4vLyB0aGUgaW5pdGlhbCBjYWxsLlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5nZXRMYXN0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubGFzdFJlc3VsdF8uY29uY2F0KCk7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIHdyYXBwZWQgZnVuY3Rpb24gY2FsbCB3YXMgcmV0cmllZC5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuZ2V0TnVtUmV0cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm51bVJldHJpZXNfO1xufTtcblxuLy8gU2V0cyB0aGUgYmFja29mZiBsaW1pdC5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuZmFpbEFmdGVyID0gZnVuY3Rpb24obWF4TnVtYmVyT2ZSZXRyeSkge1xuICAgIHByZWNvbmQuY2hlY2tTdGF0ZSh0aGlzLmlzUGVuZGluZygpLCAnRnVuY3Rpb25DYWxsIGluIHByb2dyZXNzLicpO1xuICAgIHRoaXMuZmFpbEFmdGVyXyA9IG1heE51bWJlck9mUmV0cnk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIFJldHVybiB0aGlzIGZvciBjaGFpbmluZy5cbn07XG5cbi8vIEFib3J0cyB0aGUgY2FsbC5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc0NvbXBsZXRlZCgpIHx8IHRoaXMuaXNBYm9ydGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1J1bm5pbmcoKSkge1xuICAgICAgICB0aGlzLmJhY2tvZmZfLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZV8gPSBGdW5jdGlvbkNhbGwuU3RhdGVfLkFCT1JURUQ7XG4gICAgdGhpcy5sYXN0UmVzdWx0XyA9IFtuZXcgRXJyb3IoJ0JhY2tvZmYgYWJvcnRlZC4nKV07XG4gICAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICAgIHRoaXMuZG9DYWxsYmFja18oKTtcbn07XG5cbi8vIEluaXRpYXRlcyB0aGUgY2FsbCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvbi4gQWNjZXB0cyBhbiBvcHRpb25hbCBmYWN0b3J5XG4vLyBmdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSB0aGUgYmFja29mZiBpbnN0YW5jZTsgdXNlZCB3aGVuIHRlc3RpbmcuXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oYmFja29mZkZhY3RvcnkpIHtcbiAgICBwcmVjb25kLmNoZWNrU3RhdGUoIXRoaXMuaXNBYm9ydGVkKCksICdGdW5jdGlvbkNhbGwgaXMgYWJvcnRlZC4nKTtcbiAgICBwcmVjb25kLmNoZWNrU3RhdGUodGhpcy5pc1BlbmRpbmcoKSwgJ0Z1bmN0aW9uQ2FsbCBhbHJlYWR5IHN0YXJ0ZWQuJyk7XG5cbiAgICB2YXIgc3RyYXRlZ3kgPSB0aGlzLnN0cmF0ZWd5XyB8fCBuZXcgRmlib25hY2NpQmFja29mZlN0cmF0ZWd5KCk7XG5cbiAgICB0aGlzLmJhY2tvZmZfID0gYmFja29mZkZhY3RvcnkgP1xuICAgICAgICBiYWNrb2ZmRmFjdG9yeShzdHJhdGVneSkgOlxuICAgICAgICBuZXcgQmFja29mZihzdHJhdGVneSk7XG5cbiAgICB0aGlzLmJhY2tvZmZfLm9uKCdyZWFkeScsIHRoaXMuZG9DYWxsXy5iaW5kKHRoaXMsIHRydWUgLyogaXNSZXRyeSAqLykpO1xuICAgIHRoaXMuYmFja29mZl8ub24oJ2ZhaWwnLCB0aGlzLmRvQ2FsbGJhY2tfLmJpbmQodGhpcykpO1xuICAgIHRoaXMuYmFja29mZl8ub24oJ2JhY2tvZmYnLCB0aGlzLmhhbmRsZUJhY2tvZmZfLmJpbmQodGhpcykpO1xuXG4gICAgaWYgKHRoaXMuZmFpbEFmdGVyXyA+IDApIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmXy5mYWlsQWZ0ZXIodGhpcy5mYWlsQWZ0ZXJfKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlXyA9IEZ1bmN0aW9uQ2FsbC5TdGF0ZV8uUlVOTklORztcbiAgICB0aGlzLmRvQ2FsbF8oZmFsc2UgLyogaXNSZXRyeSAqLyk7XG59O1xuXG4vLyBDYWxscyB0aGUgd3JhcHBlZCBmdW5jdGlvbi5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuZG9DYWxsXyA9IGZ1bmN0aW9uKGlzUmV0cnkpIHtcbiAgICBpZiAoaXNSZXRyeSkge1xuICAgICAgICB0aGlzLm51bVJldHJpZXNfKys7XG4gICAgfVxuICAgIHZhciBldmVudEFyZ3MgPSBbJ2NhbGwnXS5jb25jYXQodGhpcy5hcmd1bWVudHNfKTtcbiAgICBldmVudHMuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmFwcGx5KHRoaXMsIGV2ZW50QXJncyk7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5oYW5kbGVGdW5jdGlvbkNhbGxiYWNrXy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZnVuY3Rpb25fLmFwcGx5KG51bGwsIHRoaXMuYXJndW1lbnRzXy5jb25jYXQoY2FsbGJhY2spKTtcbn07XG5cbi8vIENhbGxzIHRoZSB3cmFwcGVkIGZ1bmN0aW9uJ3MgY2FsbGJhY2sgd2l0aCB0aGUgbGFzdCByZXN1bHQgcmV0dXJuZWQgYnkgdGhlXG4vLyB3cmFwcGVkIGZ1bmN0aW9uLlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5kb0NhbGxiYWNrXyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2FsbGJhY2tfLmFwcGx5KG51bGwsIHRoaXMubGFzdFJlc3VsdF8pO1xufTtcblxuLy8gSGFuZGxlcyB3cmFwcGVkIGZ1bmN0aW9uJ3MgY29tcGxldGlvbi4gVGhpcyBtZXRob2QgYWN0cyBhcyBhIHJlcGxhY2VtZW50XG4vLyBmb3IgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZ1bmN0aW9uLlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5oYW5kbGVGdW5jdGlvbkNhbGxiYWNrXyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzQWJvcnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5sYXN0UmVzdWx0XyA9IGFyZ3M7IC8vIFNhdmUgbGFzdCBjYWxsYmFjayBhcmd1bWVudHMuXG4gICAgZXZlbnRzLkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdC5hcHBseSh0aGlzLCBbJ2NhbGxiYWNrJ10uY29uY2F0KGFyZ3MpKTtcblxuICAgIHZhciBlcnIgPSBhcmdzWzBdO1xuICAgIGlmIChlcnIgJiYgdGhpcy5yZXRyeVByZWRpY2F0ZV8oZXJyKSkge1xuICAgICAgICB0aGlzLmJhY2tvZmZfLmJhY2tvZmYoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlXyA9IEZ1bmN0aW9uQ2FsbC5TdGF0ZV8uQ09NUExFVEVEO1xuICAgICAgICB0aGlzLmRvQ2FsbGJhY2tfKCk7XG4gICAgfVxufTtcblxuLy8gSGFuZGxlcyB0aGUgYmFja29mZiBldmVudCBieSByZWVtaXR0aW5nIGl0LlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5oYW5kbGVCYWNrb2ZmXyA9IGZ1bmN0aW9uKG51bWJlciwgZGVsYXksIGVycikge1xuICAgIHRoaXMuZW1pdCgnYmFja29mZicsIG51bWJlciwgZGVsYXksIGVycik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uQ2FsbDtcbiIsIi8vICAgICAgQ29weXJpZ2h0IChjKSAyMDEyIE1hdGhpZXUgVHVyY290dGVcbi8vICAgICAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBwcmVjb25kID0gcmVxdWlyZSgncHJlY29uZCcpO1xuXG52YXIgQmFja29mZlN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9zdHJhdGVneScpO1xuXG4vLyBFeHBvbmVudGlhbCBiYWNrb2ZmIHN0cmF0ZWd5LlxuZnVuY3Rpb24gRXhwb25lbnRpYWxCYWNrb2ZmU3RyYXRlZ3kob3B0aW9ucykge1xuICAgIEJhY2tvZmZTdHJhdGVneS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuYmFja29mZkRlbGF5XyA9IDA7XG4gICAgdGhpcy5uZXh0QmFja29mZkRlbGF5XyA9IHRoaXMuZ2V0SW5pdGlhbERlbGF5KCk7XG4gICAgdGhpcy5mYWN0b3JfID0gRXhwb25lbnRpYWxCYWNrb2ZmU3RyYXRlZ3kuREVGQVVMVF9GQUNUT1I7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZhY3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZWNvbmQuY2hlY2tBcmd1bWVudChvcHRpb25zLmZhY3RvciA+IDEsXG4gICAgICAgICAgICAnRXhwb25lbnRpYWwgZmFjdG9yIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gMSBidXQgZ290ICVzLicsXG4gICAgICAgICAgICBvcHRpb25zLmZhY3Rvcik7XG4gICAgICAgIHRoaXMuZmFjdG9yXyA9IG9wdGlvbnMuZmFjdG9yO1xuICAgIH1cbn1cbnV0aWwuaW5oZXJpdHMoRXhwb25lbnRpYWxCYWNrb2ZmU3RyYXRlZ3ksIEJhY2tvZmZTdHJhdGVneSk7XG5cbi8vIERlZmF1bHQgbXVsdGlwbGljYXRpb24gZmFjdG9yIHVzZWQgdG8gY29tcHV0ZSB0aGUgbmV4dCBiYWNrb2ZmIGRlbGF5IGZyb21cbi8vIHRoZSBjdXJyZW50IG9uZS4gVGhlIHZhbHVlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmcgYSBjdXN0b20gZmFjdG9yIGFzXG4vLyBwYXJ0IG9mIHRoZSBvcHRpb25zLlxuRXhwb25lbnRpYWxCYWNrb2ZmU3RyYXRlZ3kuREVGQVVMVF9GQUNUT1IgPSAyO1xuXG5FeHBvbmVudGlhbEJhY2tvZmZTdHJhdGVneS5wcm90b3R5cGUubmV4dF8gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJhY2tvZmZEZWxheV8gPSBNYXRoLm1pbih0aGlzLm5leHRCYWNrb2ZmRGVsYXlfLCB0aGlzLmdldE1heERlbGF5KCkpO1xuICAgIHRoaXMubmV4dEJhY2tvZmZEZWxheV8gPSB0aGlzLmJhY2tvZmZEZWxheV8gKiB0aGlzLmZhY3Rvcl87XG4gICAgcmV0dXJuIHRoaXMuYmFja29mZkRlbGF5Xztcbn07XG5cbkV4cG9uZW50aWFsQmFja29mZlN0cmF0ZWd5LnByb3RvdHlwZS5yZXNldF8gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJhY2tvZmZEZWxheV8gPSAwO1xuICAgIHRoaXMubmV4dEJhY2tvZmZEZWxheV8gPSB0aGlzLmdldEluaXRpYWxEZWxheSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeHBvbmVudGlhbEJhY2tvZmZTdHJhdGVneTtcbiIsIi8vICAgICAgQ29weXJpZ2h0IChjKSAyMDEyIE1hdGhpZXUgVHVyY290dGVcbi8vICAgICAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIEJhY2tvZmZTdHJhdGVneSA9IHJlcXVpcmUoJy4vc3RyYXRlZ3knKTtcblxuLy8gRmlib25hY2NpIGJhY2tvZmYgc3RyYXRlZ3kuXG5mdW5jdGlvbiBGaWJvbmFjY2lCYWNrb2ZmU3RyYXRlZ3kob3B0aW9ucykge1xuICAgIEJhY2tvZmZTdHJhdGVneS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuYmFja29mZkRlbGF5XyA9IDA7XG4gICAgdGhpcy5uZXh0QmFja29mZkRlbGF5XyA9IHRoaXMuZ2V0SW5pdGlhbERlbGF5KCk7XG59XG51dGlsLmluaGVyaXRzKEZpYm9uYWNjaUJhY2tvZmZTdHJhdGVneSwgQmFja29mZlN0cmF0ZWd5KTtcblxuRmlib25hY2NpQmFja29mZlN0cmF0ZWd5LnByb3RvdHlwZS5uZXh0XyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiYWNrb2ZmRGVsYXkgPSBNYXRoLm1pbih0aGlzLm5leHRCYWNrb2ZmRGVsYXlfLCB0aGlzLmdldE1heERlbGF5KCkpO1xuICAgIHRoaXMubmV4dEJhY2tvZmZEZWxheV8gKz0gdGhpcy5iYWNrb2ZmRGVsYXlfO1xuICAgIHRoaXMuYmFja29mZkRlbGF5XyA9IGJhY2tvZmZEZWxheTtcbiAgICByZXR1cm4gYmFja29mZkRlbGF5O1xufTtcblxuRmlib25hY2NpQmFja29mZlN0cmF0ZWd5LnByb3RvdHlwZS5yZXNldF8gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm5leHRCYWNrb2ZmRGVsYXlfID0gdGhpcy5nZXRJbml0aWFsRGVsYXkoKTtcbiAgICB0aGlzLmJhY2tvZmZEZWxheV8gPSAwO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWJvbmFjY2lCYWNrb2ZmU3RyYXRlZ3k7XG4iLCIvLyAgICAgIENvcHlyaWdodCAoYykgMjAxMiBNYXRoaWV1IFR1cmNvdHRlXG4vLyAgICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGlzRGVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbi8vIEFic3RyYWN0IGNsYXNzIGRlZmluaW5nIHRoZSBza2VsZXRvbiBmb3IgdGhlIGJhY2tvZmYgc3RyYXRlZ2llcy4gQWNjZXB0cyBhblxuLy8gb2JqZWN0IGhvbGRpbmcgdGhlIG9wdGlvbnMgZm9yIHRoZSBiYWNrb2ZmIHN0cmF0ZWd5OlxuLy9cbi8vICAqIGByYW5kb21pc2F0aW9uRmFjdG9yYDogVGhlIHJhbmRvbWlzYXRpb24gZmFjdG9yIHdoaWNoIG11c3QgYmUgYmV0d2VlbiAwXG4vLyAgICAgYW5kIDEgd2hlcmUgMSBlcXVhdGVzIHRvIGEgcmFuZG9taXphdGlvbiBmYWN0b3Igb2YgMTAwJSBhbmQgMCB0byBub1xuLy8gICAgIHJhbmRvbWl6YXRpb24uXG4vLyAgKiBgaW5pdGlhbERlbGF5YDogVGhlIGJhY2tvZmYgaW5pdGlhbCBkZWxheSBpbiBtaWxsaXNlY29uZHMuXG4vLyAgKiBgbWF4RGVsYXlgOiBUaGUgYmFja29mZiBtYXhpbWFsIGRlbGF5IGluIG1pbGxpc2Vjb25kcy5cbmZ1bmN0aW9uIEJhY2tvZmZTdHJhdGVneShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoaXNEZWYob3B0aW9ucy5pbml0aWFsRGVsYXkpICYmIG9wdGlvbnMuaW5pdGlhbERlbGF5IDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbml0aWFsIHRpbWVvdXQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKG9wdGlvbnMubWF4RGVsYXkpICYmIG9wdGlvbnMubWF4RGVsYXkgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIG1heGltYWwgdGltZW91dCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLicpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbERlbGF5XyA9IG9wdGlvbnMuaW5pdGlhbERlbGF5IHx8IDEwMDtcbiAgICB0aGlzLm1heERlbGF5XyA9IG9wdGlvbnMubWF4RGVsYXkgfHwgMTAwMDA7XG5cbiAgICBpZiAodGhpcy5tYXhEZWxheV8gPD0gdGhpcy5pbml0aWFsRGVsYXlfKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIG1heGltYWwgYmFja29mZiBkZWxheSBtdXN0IGJlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dyZWF0ZXIgdGhhbiB0aGUgaW5pdGlhbCBiYWNrb2ZmIGRlbGF5LicpO1xuICAgIH1cblxuICAgIGlmIChpc0RlZihvcHRpb25zLnJhbmRvbWlzYXRpb25GYWN0b3IpICYmXG4gICAgICAgIChvcHRpb25zLnJhbmRvbWlzYXRpb25GYWN0b3IgPCAwIHx8IG9wdGlvbnMucmFuZG9taXNhdGlvbkZhY3RvciA+IDEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJhbmRvbWlzYXRpb24gZmFjdG9yIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLicpO1xuICAgIH1cblxuICAgIHRoaXMucmFuZG9taXNhdGlvbkZhY3Rvcl8gPSBvcHRpb25zLnJhbmRvbWlzYXRpb25GYWN0b3IgfHwgMDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW1hbCBiYWNrb2ZmIGRlbGF5LlxuQmFja29mZlN0cmF0ZWd5LnByb3RvdHlwZS5nZXRNYXhEZWxheSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1heERlbGF5Xztcbn07XG5cbi8vIEdldHMgdGhlIGluaXRpYWwgYmFja29mZiBkZWxheS5cbkJhY2tvZmZTdHJhdGVneS5wcm90b3R5cGUuZ2V0SW5pdGlhbERlbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbERlbGF5Xztcbn07XG5cbi8vIFRlbXBsYXRlIG1ldGhvZCB0aGF0IGNvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBuZXh0IGJhY2tvZmYgZGVsYXkgaW5cbi8vIG1pbGxpc2Vjb25kcy5cbkJhY2tvZmZTdHJhdGVneS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiYWNrb2ZmRGVsYXkgPSB0aGlzLm5leHRfKCk7XG4gICAgdmFyIHJhbmRvbWlzYXRpb25NdWx0aXBsZSA9IDEgKyBNYXRoLnJhbmRvbSgpICogdGhpcy5yYW5kb21pc2F0aW9uRmFjdG9yXztcbiAgICB2YXIgcmFuZG9taXplZERlbGF5ID0gTWF0aC5yb3VuZChiYWNrb2ZmRGVsYXkgKiByYW5kb21pc2F0aW9uTXVsdGlwbGUpO1xuICAgIHJldHVybiByYW5kb21pemVkRGVsYXk7XG59O1xuXG4vLyBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgbmV4dCBiYWNrb2ZmIGRlbGF5LiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5XG4vLyBzdWJjbGFzc2VzLlxuQmFja29mZlN0cmF0ZWd5LnByb3RvdHlwZS5uZXh0XyA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFja29mZlN0cmF0ZWd5Lm5leHRfKCkgdW5pbXBsZW1lbnRlZC4nKTtcbn07XG5cbi8vIFRlbXBsYXRlIG1ldGhvZCB0aGF0IHJlc2V0cyB0aGUgYmFja29mZiBkZWxheSB0byBpdHMgaW5pdGlhbCB2YWx1ZS5cbkJhY2tvZmZTdHJhdGVneS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlc2V0XygpO1xufTtcblxuLy8gUmVzZXRzIHRoZSBiYWNrb2ZmIGRlbGF5IHRvIGl0cyBpbml0aWFsIHZhbHVlLiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5XG4vLyBzdWJjbGFzc2VzLlxuQmFja29mZlN0cmF0ZWd5LnByb3RvdHlwZS5yZXNldF8gPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhY2tvZmZTdHJhdGVneS5yZXNldF8oKSB1bmltcGxlbWVudGVkLicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmU3RyYXRlZ3k7XG4iLCJpbXBvcnQgaXNJbkJyb3dzZXIgZnJvbSAnaXMtaW4tYnJvd3Nlcic7XG5pbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5JztcblxuLy8gRXhwb3J0IGphdmFzY3JpcHQgc3R5bGUgYW5kIGNzcyBzdHlsZSB2ZW5kb3IgcHJlZml4ZXMuXG52YXIganMgPSAnJztcbnZhciBjc3MgPSAnJztcbnZhciB2ZW5kb3IgPSAnJztcbnZhciBicm93c2VyID0gJyc7XG52YXIgaXNUb3VjaCA9IGlzSW5Ccm93c2VyICYmICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsgLy8gV2Ugc2hvdWxkIG5vdCBkbyBhbnl0aGluZyBpZiByZXF1aXJlZCBzZXJ2ZXJzaWRlLlxuXG5pZiAoaXNJbkJyb3dzZXIpIHtcbiAgLy8gT3JkZXIgbWF0dGVycy4gV2UgbmVlZCB0byBjaGVjayBXZWJraXQgdGhlIGxhc3Qgb25lIGJlY2F1c2VcbiAgLy8gb3RoZXIgdmVuZG9ycyB1c2UgdG8gYWRkIFdlYmtpdCBwcmVmaXhlcyB0byBzb21lIHByb3BlcnRpZXNcbiAgdmFyIGpzQ3NzTWFwID0ge1xuICAgIE1vejogJy1tb3otJyxcbiAgICBtczogJy1tcy0nLFxuICAgIE86ICctby0nLFxuICAgIFdlYmtpdDogJy13ZWJraXQtJ1xuICB9O1xuXG4gIHZhciBfZG9jdW1lbnQkY3JlYXRlRWxlbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyksXG4gICAgICBzdHlsZSA9IF9kb2N1bWVudCRjcmVhdGVFbGVtZS5zdHlsZTtcblxuICB2YXIgdGVzdFByb3AgPSAnVHJhbnNmb3JtJztcblxuICBmb3IgKHZhciBrZXkgaW4ganNDc3NNYXApIHtcbiAgICBpZiAoa2V5ICsgdGVzdFByb3AgaW4gc3R5bGUpIHtcbiAgICAgIGpzID0ga2V5O1xuICAgICAgY3NzID0ganNDc3NNYXBba2V5XTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSAvLyBDb3JyZWN0bHkgZGV0ZWN0IHRoZSBFZGdlIGJyb3dzZXIuXG5cblxuICBpZiAoanMgPT09ICdXZWJraXQnICYmICdtc0h5cGhlbnMnIGluIHN0eWxlKSB7XG4gICAganMgPSAnbXMnO1xuICAgIGNzcyA9IGpzQ3NzTWFwLm1zO1xuICAgIGJyb3dzZXIgPSAnZWRnZSc7XG4gIH0gLy8gQ29ycmVjdGx5IGRldGVjdCB0aGUgU2FmYXJpIGJyb3dzZXIuXG5cblxuICBpZiAoanMgPT09ICdXZWJraXQnICYmICctYXBwbGUtdHJhaWxpbmctd29yZCcgaW4gc3R5bGUpIHtcbiAgICB2ZW5kb3IgPSAnYXBwbGUnO1xuICB9XG59XG4vKipcbiAqIFZlbmRvciBwcmVmaXggc3RyaW5nIGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEB0eXBlIHt7anM6IFN0cmluZywgY3NzOiBTdHJpbmcsIHZlbmRvcjogU3RyaW5nLCBicm93c2VyOiBTdHJpbmd9fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbnZhciBwcmVmaXggPSB7XG4gIGpzOiBqcyxcbiAgY3NzOiBjc3MsXG4gIHZlbmRvcjogdmVuZG9yLFxuICBicm93c2VyOiBicm93c2VyLFxuICBpc1RvdWNoOiBpc1RvdWNoXG59O1xuXG4vKipcbiAqIFRlc3QgaWYgYSBrZXlmcmFtZSBhdC1ydWxlIHNob3VsZCBiZSBwcmVmaXhlZCBvciBub3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmVuZG9yIHByZWZpeCBzdHJpbmcgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRlZEtleWZyYW1lcyhrZXkpIHtcbiAgLy8gS2V5ZnJhbWVzIGlzIGFscmVhZHkgcHJlZml4ZWQuIGUuZy4ga2V5ID0gJ0Atd2Via2l0LWtleWZyYW1lcyBhJ1xuICBpZiAoa2V5WzFdID09PSAnLScpIHJldHVybiBrZXk7IC8vIE5vIG5lZWQgdG8gcHJlZml4IElFL0VkZ2UuIE9sZGVyIGJyb3dzZXJzIHdpbGwgaWdub3JlIHVuc3VwcG9ydGVkIHJ1bGVzLlxuICAvLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9a2V5ZnJhbWVzXG5cbiAgaWYgKHByZWZpeC5qcyA9PT0gJ21zJykgcmV0dXJuIGtleTtcbiAgcmV0dXJuIFwiQFwiICsgcHJlZml4LmNzcyArIFwia2V5ZnJhbWVzXCIgKyBrZXkuc3Vic3RyKDEwKTtcbn1cblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWFwcGVhcmFuY2VcblxudmFyIGFwcGVhcmVuY2UgPSB7XG4gIG5vUHJlZmlsbDogWydhcHBlYXJhbmNlJ10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKHByb3AgIT09ICdhcHBlYXJhbmNlJykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwcmVmaXguanMgPT09ICdtcycpIHJldHVybiBcIi13ZWJraXQtXCIgKyBwcm9wO1xuICAgIHJldHVybiBwcmVmaXguY3NzICsgcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWNvbG9yLWFkanVzdFxuXG52YXIgY29sb3JBZGp1c3QgPSB7XG4gIG5vUHJlZmlsbDogWydjb2xvci1hZGp1c3QnXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3ApIHtcbiAgICBpZiAocHJvcCAhPT0gJ2NvbG9yLWFkanVzdCcpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocHJlZml4LmpzID09PSAnV2Via2l0JykgcmV0dXJuIHByZWZpeC5jc3MgKyBcInByaW50LVwiICsgcHJvcDtcbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufTtcblxudmFyIHJlZ0V4cCA9IC9bLVxcc10rKC4pPy9nO1xuLyoqXG4gKiBSZXBsYWNlcyB0aGUgbGV0dGVyIHdpdGggdGhlIGNhcGl0YWwgbGV0dGVyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ30gY1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdG9VcHBlcihtYXRjaCwgYykge1xuICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnO1xufVxuLyoqXG4gKiBDb252ZXJ0IGRhc2ggc2VwYXJhdGVkIHN0cmluZ3MgdG8gY2FtZWwtY2FzZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZ0V4cCwgdG9VcHBlcik7XG59XG5cbi8qKlxuICogQ29udmVydCBkYXNoIHNlcGFyYXRlZCBzdHJpbmdzIHRvIHBhc2NhbCBjYXNlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXNjYWxpemUoc3RyKSB7XG4gIHJldHVybiBjYW1lbGl6ZShcIi1cIiArIHN0cik7XG59XG5cbi8vIGJ1dCB3ZSBjYW4gdXNlIGEgbG9uZ2hhbmQgcHJvcGVydHkgaW5zdGVhZC5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1tYXNrXG5cbnZhciBtYXNrID0ge1xuICBub1ByZWZpbGw6IFsnbWFzayddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUpIHtcbiAgICBpZiAoIS9ebWFzay8udGVzdChwcm9wKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ1dlYmtpdCcpIHtcbiAgICAgIHZhciBsb25naGFuZCA9ICdtYXNrLWltYWdlJztcblxuICAgICAgaWYgKGNhbWVsaXplKGxvbmdoYW5kKSBpbiBzdHlsZSkge1xuICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZWZpeC5qcyArIHBhc2NhbGl6ZShsb25naGFuZCkgaW4gc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9dGV4dC1vcmllbnRhdGlvblxuXG52YXIgdGV4dE9yaWVudGF0aW9uID0ge1xuICBub1ByZWZpbGw6IFsndGV4dC1vcmllbnRhdGlvbiddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCkge1xuICAgIGlmIChwcm9wICE9PSAndGV4dC1vcmllbnRhdGlvbicpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcmVmaXgudmVuZG9yID09PSAnYXBwbGUnICYmICFwcmVmaXguaXNUb3VjaCkge1xuICAgICAgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9dHJhbnNmb3JtXG5cbnZhciB0cmFuc2Zvcm0gPSB7XG4gIG5vUHJlZmlsbDogWyd0cmFuc2Zvcm0nXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKHByb3AgIT09ICd0cmFuc2Zvcm0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy50cmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXguY3NzICsgcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXRyYW5zaXRpb25cblxudmFyIHRyYW5zaXRpb24gPSB7XG4gIG5vUHJlZmlsbDogWyd0cmFuc2l0aW9uJ10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChwcm9wICE9PSAndHJhbnNpdGlvbicpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXguY3NzICsgcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXdyaXRpbmctbW9kZVxuXG52YXIgd3JpdGluZ01vZGUgPSB7XG4gIG5vUHJlZmlsbDogWyd3cml0aW5nLW1vZGUnXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3ApIHtcbiAgICBpZiAocHJvcCAhPT0gJ3dyaXRpbmctbW9kZScpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcmVmaXguanMgPT09ICdXZWJraXQnIHx8IHByZWZpeC5qcyA9PT0gJ21zJyAmJiBwcmVmaXguYnJvd3NlciAhPT0gJ2VkZ2UnKSB7XG4gICAgICByZXR1cm4gcHJlZml4LmNzcyArIHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD11c2VyLXNlbGVjdFxuXG52YXIgdXNlclNlbGVjdCA9IHtcbiAgbm9QcmVmaWxsOiBbJ3VzZXItc2VsZWN0J10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKHByb3AgIT09ICd1c2VyLXNlbGVjdCcpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcmVmaXguanMgPT09ICdNb3onIHx8IHByZWZpeC5qcyA9PT0gJ21zJyB8fCBwcmVmaXgudmVuZG9yID09PSAnYXBwbGUnKSB7XG4gICAgICByZXR1cm4gcHJlZml4LmNzcyArIHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1tdWx0aWNvbHVtblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bvc3Rjc3MvYXV0b3ByZWZpeGVyL2lzc3Vlcy80OTFcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3N0Y3NzL2F1dG9wcmVmaXhlci9pc3N1ZXMvMTc3XG5cbnZhciBicmVha1Byb3BzT2xkID0ge1xuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUpIHtcbiAgICBpZiAoIS9eYnJlYWstLy50ZXN0KHByb3ApKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocHJlZml4LmpzID09PSAnV2Via2l0Jykge1xuICAgICAgdmFyIGpzUHJvcCA9IFwiV2Via2l0Q29sdW1uXCIgKyBwYXNjYWxpemUocHJvcCk7XG4gICAgICByZXR1cm4ganNQcm9wIGluIHN0eWxlID8gcHJlZml4LmNzcyArIFwiY29sdW1uLVwiICsgcHJvcCA6IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwcmVmaXguanMgPT09ICdNb3onKSB7XG4gICAgICB2YXIgX2pzUHJvcCA9IFwicGFnZVwiICsgcGFzY2FsaXplKHByb3ApO1xuXG4gICAgICByZXR1cm4gX2pzUHJvcCBpbiBzdHlsZSA/IFwicGFnZS1cIiArIHByb3AgOiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcG9zdGNzcy9hdXRvcHJlZml4ZXIvaXNzdWVzLzMyNC5cblxudmFyIGlubGluZUxvZ2ljYWxPbGQgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSkge1xuICAgIGlmICghL14oYm9yZGVyfG1hcmdpbnxwYWRkaW5nKS1pbmxpbmUvLnRlc3QocHJvcCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocHJlZml4LmpzID09PSAnTW96JykgcmV0dXJuIHByb3A7XG4gICAgdmFyIG5ld1Byb3AgPSBwcm9wLnJlcGxhY2UoJy1pbmxpbmUnLCAnJyk7XG4gICAgcmV0dXJuIHByZWZpeC5qcyArIHBhc2NhbGl6ZShuZXdQcm9wKSBpbiBzdHlsZSA/IHByZWZpeC5jc3MgKyBuZXdQcm9wIDogZmFsc2U7XG4gIH1cbn07XG5cbi8vIENhbWVsaXphdGlvbiBpcyByZXF1aXJlZCBiZWNhdXNlIHdlIGNhbid0IHRlc3QgdXNpbmcuXG4vLyBDU1Mgc3ludGF4IGZvciBlLmcuIGluIEZGLlxuXG52YXIgdW5wcmVmaXhlZCA9IHtcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlKSB7XG4gICAgcmV0dXJuIGNhbWVsaXplKHByb3ApIGluIHN0eWxlID8gcHJvcCA6IGZhbHNlO1xuICB9XG59O1xuXG52YXIgcHJlZml4ZWQgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSkge1xuICAgIHZhciBwYXNjYWxpemVkID0gcGFzY2FsaXplKHByb3ApOyAvLyBSZXR1cm4gY3VzdG9tIENTUyB2YXJpYWJsZSB3aXRob3V0IHByZWZpeGluZy5cblxuICAgIGlmIChwcm9wWzBdID09PSAnLScpIHJldHVybiBwcm9wOyAvLyBSZXR1cm4gYWxyZWFkeSBwcmVmaXhlZCB2YWx1ZSB3aXRob3V0IHByZWZpeGluZy5cblxuICAgIGlmIChwcm9wWzBdID09PSAnLScgJiYgcHJvcFsxXSA9PT0gJy0nKSByZXR1cm4gcHJvcDtcbiAgICBpZiAocHJlZml4LmpzICsgcGFzY2FsaXplZCBpbiBzdHlsZSkgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wOyAvLyBUcnkgd2Via2l0IGZhbGxiYWNrLlxuXG4gICAgaWYgKHByZWZpeC5qcyAhPT0gJ1dlYmtpdCcgJiYgXCJXZWJraXRcIiArIHBhc2NhbGl6ZWQgaW4gc3R5bGUpIHJldHVybiBcIi13ZWJraXQtXCIgKyBwcm9wO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXNjcm9sbC1zbmFwXG5cbnZhciBzY3JvbGxTbmFwID0ge1xuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCkge1xuICAgIGlmIChwcm9wLnN1YnN0cmluZygwLCAxMSkgIT09ICdzY3JvbGwtc25hcCcpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcmVmaXguanMgPT09ICdtcycpIHtcbiAgICAgIHJldHVybiBcIlwiICsgcHJlZml4LmNzcyArIHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1vdmVyc2Nyb2xsLWJlaGF2aW9yXG5cbnZhciBvdmVyc2Nyb2xsQmVoYXZpb3IgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKHByb3AgIT09ICdvdmVyc2Nyb2xsLWJlaGF2aW9yJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ21zJykge1xuICAgICAgcmV0dXJuIHByZWZpeC5jc3MgKyBcInNjcm9sbC1jaGFpbmluZ1wiO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wO1xuICB9XG59O1xuXG52YXIgcHJvcE1hcCA9IHtcbiAgJ2ZsZXgtZ3Jvdyc6ICdmbGV4LXBvc2l0aXZlJyxcbiAgJ2ZsZXgtc2hyaW5rJzogJ2ZsZXgtbmVnYXRpdmUnLFxuICAnZmxleC1iYXNpcyc6ICdmbGV4LXByZWZlcnJlZC1zaXplJyxcbiAgJ2p1c3RpZnktY29udGVudCc6ICdmbGV4LXBhY2snLFxuICBvcmRlcjogJ2ZsZXgtb3JkZXInLFxuICAnYWxpZ24taXRlbXMnOiAnZmxleC1hbGlnbicsXG4gICdhbGlnbi1jb250ZW50JzogJ2ZsZXgtbGluZS1wYWNrJyAvLyAnYWxpZ24tc2VsZicgaXMgaGFuZGxlZCBieSAnYWxpZ24tc2VsZicgcGx1Z2luLlxuXG59OyAvLyBTdXBwb3J0IG9sZCBmbGV4IHNwZWMgZnJvbSAyMDEyLlxuXG52YXIgZmxleDIwMTIgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSkge1xuICAgIHZhciBuZXdQcm9wID0gcHJvcE1hcFtwcm9wXTtcbiAgICBpZiAoIW5ld1Byb3ApIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcHJlZml4LmpzICsgcGFzY2FsaXplKG5ld1Byb3ApIGluIHN0eWxlID8gcHJlZml4LmNzcyArIG5ld1Byb3AgOiBmYWxzZTtcbiAgfVxufTtcblxudmFyIHByb3BNYXAkMSA9IHtcbiAgZmxleDogJ2JveC1mbGV4JyxcbiAgJ2ZsZXgtZ3Jvdyc6ICdib3gtZmxleCcsXG4gICdmbGV4LWRpcmVjdGlvbic6IFsnYm94LW9yaWVudCcsICdib3gtZGlyZWN0aW9uJ10sXG4gIG9yZGVyOiAnYm94LW9yZGluYWwtZ3JvdXAnLFxuICAnYWxpZ24taXRlbXMnOiAnYm94LWFsaWduJyxcbiAgJ2ZsZXgtZmxvdyc6IFsnYm94LW9yaWVudCcsICdib3gtZGlyZWN0aW9uJ10sXG4gICdqdXN0aWZ5LWNvbnRlbnQnOiAnYm94LXBhY2snXG59O1xudmFyIHByb3BLZXlzID0gT2JqZWN0LmtleXMocHJvcE1hcCQxKTtcblxudmFyIHByZWZpeENzcyA9IGZ1bmN0aW9uIHByZWZpeENzcyhwKSB7XG4gIHJldHVybiBwcmVmaXguY3NzICsgcDtcbn07IC8vIFN1cHBvcnQgb2xkIGZsZXggc3BlYyBmcm9tIDIwMDkuXG5cblxudmFyIGZsZXgyMDA5ID0ge1xuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUsIF9yZWYpIHtcbiAgICB2YXIgbXVsdGlwbGUgPSBfcmVmLm11bHRpcGxlO1xuXG4gICAgaWYgKHByb3BLZXlzLmluZGV4T2YocHJvcCkgPiAtMSkge1xuICAgICAgdmFyIG5ld1Byb3AgPSBwcm9wTWFwJDFbcHJvcF07XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShuZXdQcm9wKSkge1xuICAgICAgICByZXR1cm4gcHJlZml4LmpzICsgcGFzY2FsaXplKG5ld1Byb3ApIGluIHN0eWxlID8gcHJlZml4LmNzcyArIG5ld1Byb3AgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtdWx0aXBsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1Byb3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCEocHJlZml4LmpzICsgcGFzY2FsaXplKG5ld1Byb3BbMF0pIGluIHN0eWxlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3UHJvcC5tYXAocHJlZml4Q3NzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIHBsdWdpbnMgPSBbXG4vLyAgIC4uLnBsdWdpbnMsXG4vLyAgICBicmVha1Byb3BzT2xkLFxuLy8gICAgaW5saW5lTG9naWNhbE9sZCxcbi8vICAgIHVucHJlZml4ZWQsXG4vLyAgICBwcmVmaXhlZCxcbi8vICAgIHNjcm9sbFNuYXAsXG4vLyAgICBmbGV4MjAxMixcbi8vICAgIGZsZXgyMDA5XG4vLyBdXG4vLyBQbHVnaW5zIHdpdGhvdXQgJ25vUHJlZmlsbCcgdmFsdWUsIGdvaW5nIGxhc3QuXG4vLyAnZmxleC0qJyBwbHVnaW5zIHNob3VsZCBiZSBhdCB0aGUgYm90dG9tLlxuLy8gJ2ZsZXgyMDA5JyBnb2luZyBhZnRlciAnZmxleDIwMTInLlxuLy8gJ3ByZWZpeGVkJyBnb2luZyBhZnRlciAndW5wcmVmaXhlZCdcblxudmFyIHBsdWdpbnMgPSBbYXBwZWFyZW5jZSwgY29sb3JBZGp1c3QsIG1hc2ssIHRleHRPcmllbnRhdGlvbiwgdHJhbnNmb3JtLCB0cmFuc2l0aW9uLCB3cml0aW5nTW9kZSwgdXNlclNlbGVjdCwgYnJlYWtQcm9wc09sZCwgaW5saW5lTG9naWNhbE9sZCwgdW5wcmVmaXhlZCwgcHJlZml4ZWQsIHNjcm9sbFNuYXAsIG92ZXJzY3JvbGxCZWhhdmlvciwgZmxleDIwMTIsIGZsZXgyMDA5XTtcbnZhciBwcm9wZXJ0eURldGVjdG9ycyA9IHBsdWdpbnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwLnN1cHBvcnRlZFByb3BlcnR5O1xufSkubWFwKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwLnN1cHBvcnRlZFByb3BlcnR5O1xufSk7XG52YXIgbm9QcmVmaWxsID0gcGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIHAubm9QcmVmaWxsO1xufSkucmVkdWNlKGZ1bmN0aW9uIChhLCBwKSB7XG4gIGEucHVzaC5hcHBseShhLCBfdG9Db25zdW1hYmxlQXJyYXkocC5ub1ByZWZpbGwpKTtcbiAgcmV0dXJuIGE7XG59LCBbXSk7XG5cbnZhciBlbDtcbnZhciBjYWNoZSA9IHt9O1xuXG5pZiAoaXNJbkJyb3dzZXIpIHtcbiAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7IC8vIFdlIHRlc3QgZXZlcnkgcHJvcGVydHkgb24gdmVuZG9yIHByZWZpeCByZXF1aXJlbWVudC5cbiAgLy8gT25jZSB0ZXN0ZWQsIHJlc3VsdCBpcyBjYWNoZWQuIEl0IGdpdmVzIHVzIHVwIHRvIDcwJSBwZXJmIGJvb3N0LlxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9lbGVtZW50LXN0eWxlLW9iamVjdC1hY2Nlc3MtdnMtcGxhaW4tb2JqZWN0XG4gIC8vXG4gIC8vIFByZWZpbGwgY2FjaGUgd2l0aCBrbm93biBjc3MgcHJvcGVydGllcyB0byByZWR1Y2UgYW1vdW50IG9mXG4gIC8vIHByb3BlcnRpZXMgd2UgbmVlZCB0byBmZWF0dXJlIHRlc3QgYXQgcnVudGltZS5cbiAgLy8gaHR0cDovL2Rhdmlkd2Fsc2gubmFtZS92ZW5kb3ItcHJlZml4XG5cbiAgdmFyIGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyk7XG5cbiAgZm9yICh2YXIga2V5JDEgaW4gY29tcHV0ZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgaWYgKCFpc05hTihrZXkkMSkpIGNhY2hlW2NvbXB1dGVkW2tleSQxXV0gPSBjb21wdXRlZFtrZXkkMV07XG4gIH0gLy8gUHJvcGVydGllcyB0aGF0IGNhbm5vdCBiZSBjb3JyZWN0bHkgZGV0ZWN0ZWQgdXNpbmcgdGhlXG4gIC8vIGNhY2hlIHByZWZpbGwgbWV0aG9kLlxuXG5cbiAgbm9QcmVmaWxsLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gZGVsZXRlIGNhY2hlW3hdO1xuICB9KTtcbn1cbi8qKlxuICogVGVzdCBpZiBhIHByb3BlcnR5IGlzIHN1cHBvcnRlZCwgcmV0dXJucyBzdXBwb3J0ZWQgcHJvcGVydHkgd2l0aCB2ZW5kb3JcbiAqIHByZWZpeCBpZiByZXF1aXJlZC4gUmV0dXJucyBgZmFsc2VgIGlmIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgZGFzaCBzZXBhcmF0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIC8vIEZvciBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gIGlmICghZWwpIHJldHVybiBwcm9wOyAvLyBSZW1vdmUgY2FjaGUgZm9yIGJlbmNobWFyayB0ZXN0cyBvciByZXR1cm4gcHJvcGVydHkgZnJvbSB0aGUgY2FjaGUuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnYmVuY2htYXJrJyAmJiBjYWNoZVtwcm9wXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGNhY2hlW3Byb3BdO1xuICB9IC8vIENoZWNrIGlmICd0cmFuc2l0aW9uJyBvciAndHJhbnNmb3JtJyBuYXRpdmVseSBzdXBwb3J0ZWQgaW4gYnJvd3Nlci5cblxuXG4gIGlmIChwcm9wID09PSAndHJhbnNpdGlvbicgfHwgcHJvcCA9PT0gJ3RyYW5zZm9ybScpIHtcbiAgICBvcHRpb25zW3Byb3BdID0gcHJvcCBpbiBlbC5zdHlsZTtcbiAgfSAvLyBGaW5kIGEgcGx1Z2luIGZvciBjdXJyZW50IHByZWZpeCBwcm9wZXJ0eS5cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHlEZXRlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZVtwcm9wXSA9IHByb3BlcnR5RGV0ZWN0b3JzW2ldKHByb3AsIGVsLnN0eWxlLCBvcHRpb25zKTsgLy8gQnJlYWsgbG9vcCwgaWYgdmFsdWUgZm91bmQuXG5cbiAgICBpZiAoY2FjaGVbcHJvcF0pIGJyZWFrO1xuICB9IC8vIFJlc2V0IHN0eWxlcyBmb3IgY3VycmVudCBwcm9wZXJ0eS5cbiAgLy8gRmlyZWZveCBjYW4gZXZlbiB0aHJvdyBhbiBlcnJvciBmb3IgaW52YWxpZCBwcm9wZXJ0aWVzLCBlLmcuLCBcIjBcIi5cblxuXG4gIHRyeSB7XG4gICAgZWwuc3R5bGVbcHJvcF0gPSAnJztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlW3Byb3BdO1xufVxuXG52YXIgY2FjaGUkMSA9IHt9O1xudmFyIHRyYW5zaXRpb25Qcm9wZXJ0aWVzID0ge1xuICB0cmFuc2l0aW9uOiAxLFxuICAndHJhbnNpdGlvbi1wcm9wZXJ0eSc6IDEsXG4gICctd2Via2l0LXRyYW5zaXRpb24nOiAxLFxuICAnLXdlYmtpdC10cmFuc2l0aW9uLXByb3BlcnR5JzogMVxufTtcbnZhciB0cmFuc1Byb3BzUmVnRXhwID0gLyheXFxzKltcXHctXSspfCwgKFxccypbXFx3LV0rKSg/IVteKCldKlxcKSkvZztcbnZhciBlbCQxO1xuLyoqXG4gKiBSZXR1cm5zIHByZWZpeGVkIHZhbHVlIHRyYW5zaXRpb24vdHJhbnNmb3JtIGlmIG5lZWRlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBwMVxuICogQHBhcmFtIHtTdHJpbmd9IHAyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwcmVmaXhUcmFuc2l0aW9uQ2FsbGJhY2sobWF0Y2gsIHAxLCBwMikge1xuICBpZiAocDEgPT09ICd2YXInKSByZXR1cm4gJ3Zhcic7XG4gIGlmIChwMSA9PT0gJ2FsbCcpIHJldHVybiAnYWxsJztcbiAgaWYgKHAyID09PSAnYWxsJykgcmV0dXJuICcsIGFsbCc7XG4gIHZhciBwcmVmaXhlZFZhbHVlID0gcDEgPyBzdXBwb3J0ZWRQcm9wZXJ0eShwMSkgOiBcIiwgXCIgKyBzdXBwb3J0ZWRQcm9wZXJ0eShwMik7XG4gIGlmICghcHJlZml4ZWRWYWx1ZSkgcmV0dXJuIHAxIHx8IHAyO1xuICByZXR1cm4gcHJlZml4ZWRWYWx1ZTtcbn1cblxuaWYgKGlzSW5Ccm93c2VyKSBlbCQxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuLyoqXG4gKiBSZXR1cm5zIHByZWZpeGVkIHZhbHVlIGlmIG5lZWRlZC4gUmV0dXJucyBgZmFsc2VgIGlmIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0ZWRWYWx1ZShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgLy8gRm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgdmFyIHByZWZpeGVkVmFsdWUgPSB2YWx1ZTtcbiAgaWYgKCFlbCQxIHx8IHByb3BlcnR5ID09PSAnY29udGVudCcpIHJldHVybiB2YWx1ZTsgLy8gSXQgaXMgYSBzdHJpbmcgb3IgYSBudW1iZXIgYXMgYSBzdHJpbmcgbGlrZSAnMScuXG4gIC8vIFdlIHdhbnQgb25seSBwcmVmaXhhYmxlIHZhbHVlcyBoZXJlLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG5cbiAgaWYgKHR5cGVvZiBwcmVmaXhlZFZhbHVlICE9PSAnc3RyaW5nJyB8fCAhaXNOYU4ocGFyc2VJbnQocHJlZml4ZWRWYWx1ZSwgMTApKSkge1xuICAgIHJldHVybiBwcmVmaXhlZFZhbHVlO1xuICB9IC8vIENyZWF0ZSBjYWNoZSBrZXkgZm9yIGN1cnJlbnQgdmFsdWUuXG5cblxuICB2YXIgY2FjaGVLZXkgPSBwcm9wZXJ0eSArIHByZWZpeGVkVmFsdWU7IC8vIFJlbW92ZSBjYWNoZSBmb3IgYmVuY2htYXJrIHRlc3RzIG9yIHJldHVybiB2YWx1ZSBmcm9tIGNhY2hlLlxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2JlbmNobWFyaycgJiYgY2FjaGUkMVtjYWNoZUtleV0gIT0gbnVsbCkge1xuICAgIHJldHVybiBjYWNoZSQxW2NhY2hlS2V5XTtcbiAgfSAvLyBJRSBjYW4gZXZlbiB0aHJvdyBhbiBlcnJvciBpbiBzb21lIGNhc2VzLCBmb3IgZS5nLiBzdHlsZS5jb250ZW50ID0gJ2JhcicuXG5cblxuICB0cnkge1xuICAgIC8vIFRlc3QgdmFsdWUgYXMgaXQgaXMuXG4gICAgZWwkMS5zdHlsZVtwcm9wZXJ0eV0gPSBwcmVmaXhlZFZhbHVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBSZXR1cm4gZmFsc2UgaWYgdmFsdWUgbm90IHN1cHBvcnRlZC5cbiAgICBjYWNoZSQxW2NhY2hlS2V5XSA9IGZhbHNlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiAndHJhbnNpdGlvbicgb3IgJ3RyYW5zaXRpb24tcHJvcGVydHknIHByb3BlcnR5LlxuXG5cbiAgaWYgKHRyYW5zaXRpb25Qcm9wZXJ0aWVzW3Byb3BlcnR5XSkge1xuICAgIHByZWZpeGVkVmFsdWUgPSBwcmVmaXhlZFZhbHVlLnJlcGxhY2UodHJhbnNQcm9wc1JlZ0V4cCwgcHJlZml4VHJhbnNpdGlvbkNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmIChlbCQxLnN0eWxlW3Byb3BlcnR5XSA9PT0gJycpIHtcbiAgICAvLyBWYWx1ZSB3aXRoIGEgdmVuZG9yIHByZWZpeC5cbiAgICBwcmVmaXhlZFZhbHVlID0gcHJlZml4LmNzcyArIHByZWZpeGVkVmFsdWU7IC8vIEhhcmRjb2RlIHRlc3QgdG8gY29udmVydCBcImZsZXhcIiB0byBcIi1tcy1mbGV4Ym94XCIgZm9yIElFMTAuXG5cbiAgICBpZiAocHJlZml4ZWRWYWx1ZSA9PT0gJy1tcy1mbGV4JykgZWwkMS5zdHlsZVtwcm9wZXJ0eV0gPSAnLW1zLWZsZXhib3gnOyAvLyBUZXN0IHByZWZpeGVkIHZhbHVlLlxuXG4gICAgZWwkMS5zdHlsZVtwcm9wZXJ0eV0gPSBwcmVmaXhlZFZhbHVlOyAvLyBSZXR1cm4gZmFsc2UgaWYgdmFsdWUgbm90IHN1cHBvcnRlZC5cblxuICAgIGlmIChlbCQxLnN0eWxlW3Byb3BlcnR5XSA9PT0gJycpIHtcbiAgICAgIGNhY2hlJDFbY2FjaGVLZXldID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIFJlc2V0IHN0eWxlcyBmb3IgY3VycmVudCBwcm9wZXJ0eS5cblxuXG4gIGVsJDEuc3R5bGVbcHJvcGVydHldID0gJyc7IC8vIFdyaXRlIGN1cnJlbnQgdmFsdWUgdG8gY2FjaGUuXG5cbiAgY2FjaGUkMVtjYWNoZUtleV0gPSBwcmVmaXhlZFZhbHVlO1xuICByZXR1cm4gY2FjaGUkMVtjYWNoZUtleV07XG59XG5cbmV4cG9ydCB7IHByZWZpeCwgc3VwcG9ydGVkS2V5ZnJhbWVzLCBzdXBwb3J0ZWRQcm9wZXJ0eSwgc3VwcG9ydGVkVmFsdWUgfTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby12YXIsIHByZWZlci10ZW1wbGF0ZSAqL1xudmFyIHVwcGVyY2FzZVBhdHRlcm4gPSAvW0EtWl0vZ1xudmFyIG1zUGF0dGVybiA9IC9ebXMtL1xudmFyIGNhY2hlID0ge31cblxuZnVuY3Rpb24gdG9IeXBoZW5Mb3dlcihtYXRjaCkge1xuICByZXR1cm4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gY2FjaGVbbmFtZV1cbiAgfVxuXG4gIHZhciBoTmFtZSA9IG5hbWUucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCB0b0h5cGhlbkxvd2VyKVxuICByZXR1cm4gKGNhY2hlW25hbWVdID0gbXNQYXR0ZXJuLnRlc3QoaE5hbWUpID8gJy0nICsgaE5hbWUgOiBoTmFtZSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgaHlwaGVuYXRlU3R5bGVOYW1lXG4iLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydCB2YXIgaXNCcm93c2VyID0gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gXCJvYmplY3RcIiAmJiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZG9jdW1lbnQpKSA9PT0gJ29iamVjdCcgJiYgZG9jdW1lbnQubm9kZVR5cGUgPT09IDk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQnJvd3NlcjtcbiIsImltcG9ydCBoeXBoZW5hdGUgZnJvbSAnaHlwaGVuYXRlLXN0eWxlLW5hbWUnO1xuXG4vKipcbiAqIENvbnZlcnQgY2FtZWwgY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gZGFzaCBzZXBhcmF0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gY29udmVydENhc2Uoc3R5bGUpIHtcbiAgdmFyIGNvbnZlcnRlZCA9IHt9O1xuXG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICB2YXIga2V5ID0gcHJvcC5pbmRleE9mKCctLScpID09PSAwID8gcHJvcCA6IGh5cGhlbmF0ZShwcm9wKTtcbiAgICBjb252ZXJ0ZWRba2V5XSA9IHN0eWxlW3Byb3BdO1xuICB9XG5cbiAgaWYgKHN0eWxlLmZhbGxiYWNrcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlLmZhbGxiYWNrcykpIGNvbnZlcnRlZC5mYWxsYmFja3MgPSBzdHlsZS5mYWxsYmFja3MubWFwKGNvbnZlcnRDYXNlKTtlbHNlIGNvbnZlcnRlZC5mYWxsYmFja3MgPSBjb252ZXJ0Q2FzZShzdHlsZS5mYWxsYmFja3MpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cbi8qKlxuICogQWxsb3cgY2FtZWwgY2FzZWQgcHJvcGVydHkgbmFtZXMgYnkgY29udmVydGluZyB0aGVtIGJhY2sgdG8gZGFzaGVyaXplZC5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGNhbWVsQ2FzZSgpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHtcbiAgICAgIC8vIEhhbmRsZSBydWxlcyBsaWtlIEBmb250LWZhY2UsIHdoaWNoIGNhbiBoYXZlIG11bHRpcGxlIHN0eWxlcyBpbiBhbiBhcnJheVxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0eWxlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzdHlsZVtpbmRleF0gPSBjb252ZXJ0Q2FzZShzdHlsZVtpbmRleF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRDYXNlKHN0eWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3AsIHJ1bGUpIHtcbiAgICBpZiAocHJvcC5pbmRleE9mKCctLScpID09PSAwKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGh5cGhlbmF0ZWRQcm9wID0gaHlwaGVuYXRlKHByb3ApOyAvLyBUaGVyZSB3YXMgbm8gY2FtZWwgY2FzZSBpbiBwbGFjZVxuXG4gICAgaWYgKHByb3AgPT09IGh5cGhlbmF0ZWRQcm9wKSByZXR1cm4gdmFsdWU7XG4gICAgcnVsZS5wcm9wKGh5cGhlbmF0ZWRQcm9wLCB2YWx1ZSk7IC8vIENvcmUgd2lsbCBpZ25vcmUgdGhhdCBwcm9wZXJ0eSB2YWx1ZSB3ZSBzZXQgdGhlIHByb3BlciBvbmUgYWJvdmUuXG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlLFxuICAgIG9uQ2hhbmdlVmFsdWU6IG9uQ2hhbmdlVmFsdWVcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FtZWxDYXNlO1xuIiwiaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcblxuLyoqXG4gKiBTZXQgc2VsZWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsIHJ1bGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgY2xhc3Mgc3RyaW5nXG4gKiBAcmV0dXJuIHtCb29sZWFufSBmbGFnLCBpbmRpY2F0aW5nIGZ1bmN0aW9uIHdhcyBzdWNjZXNzZnVsbCBvciBub3RcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDbGFzcyhydWxlLCBjbGFzc05hbWUpIHtcbiAgLy8gU2tpcCBmYWxzeSB2YWx1ZXNcbiAgaWYgKCFjbGFzc05hbWUpIHJldHVybiB0cnVlOyAvLyBTdXBwb3J0IGFycmF5IG9mIGNsYXNzIG5hbWVzIGB7Y29tcG9zZXM6IFsnZm9vJywgJ2JhciddfWBcblxuICBpZiAoQXJyYXkuaXNBcnJheShjbGFzc05hbWUpKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGNsYXNzTmFtZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBpc1NldHRlZCA9IHJlZ2lzdGVyQ2xhc3MocnVsZSwgY2xhc3NOYW1lW2luZGV4XSk7XG4gICAgICBpZiAoIWlzU2V0dGVkKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gU3VwcG9ydCBzcGFjZSBzZXBhcmF0ZWQgY2xhc3MgbmFtZXMgYHtjb21wb3NlczogJ2ZvbyBiYXInfWBcblxuXG4gIGlmIChjbGFzc05hbWUuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJDbGFzcyhydWxlLCBjbGFzc05hbWUuc3BsaXQoJyAnKSk7XG4gIH1cblxuICB2YXIgX3JlZiA9IHJ1bGUub3B0aW9ucyxcbiAgICAgIHBhcmVudCA9IF9yZWYucGFyZW50OyAvLyBJdCBpcyBhIHJlZiB0byBhIGxvY2FsIHJ1bGUuXG5cbiAgaWYgKGNsYXNzTmFtZVswXSA9PT0gJyQnKSB7XG4gICAgdmFyIHJlZlJ1bGUgPSBwYXJlbnQuZ2V0UnVsZShjbGFzc05hbWUuc3Vic3RyKDEpKTtcblxuICAgIGlmICghcmVmUnVsZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBSZWZlcmVuY2VkIHJ1bGUgaXMgbm90IGRlZmluZWQuIFxcblwiICsgcnVsZS50b1N0cmluZygpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocmVmUnVsZSA9PT0gcnVsZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBDeWNsaWMgY29tcG9zaXRpb24gZGV0ZWN0ZWQuIFxcblwiICsgcnVsZS50b1N0cmluZygpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwYXJlbnQuY2xhc3Nlc1tydWxlLmtleV0gKz0gXCIgXCIgKyBwYXJlbnQuY2xhc3Nlc1tyZWZSdWxlLmtleV07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwYXJlbnQuY2xhc3Nlc1tydWxlLmtleV0gKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBDb252ZXJ0IGNvbXBvc2UgcHJvcGVydHkgdG8gYWRkaXRpb25hbCBjbGFzcywgcmVtb3ZlIHByb3BlcnR5IGZyb20gb3JpZ2luYWwgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGpzc0NvbXBvc2UoKSB7XG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgaWYgKCEoJ2NvbXBvc2VzJyBpbiBzdHlsZSkpIHJldHVybiBzdHlsZTtcbiAgICByZWdpc3RlckNsYXNzKHJ1bGUsIHN0eWxlLmNvbXBvc2VzKTsgLy8gUmVtb3ZlIGNvbXBvc2VzIHByb3BlcnR5IHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcC5cblxuICAgIGRlbGV0ZSBzdHlsZS5jb21wb3NlcztcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBqc3NDb21wb3NlO1xuIiwiaW1wb3J0IHsgaGFzQ1NTVE9NU3VwcG9ydCB9IGZyb20gJ2pzcyc7XG5cbnZhciBweCA9IGhhc0NTU1RPTVN1cHBvcnQgJiYgQ1NTID8gQ1NTLnB4IDogJ3B4JztcbnZhciBtcyA9IGhhc0NTU1RPTVN1cHBvcnQgJiYgQ1NTID8gQ1NTLm1zIDogJ21zJztcbnZhciBwZXJjZW50ID0gaGFzQ1NTVE9NU3VwcG9ydCAmJiBDU1MgPyBDU1MucGVyY2VudCA6ICclJztcbi8qKlxuICogR2VuZXJhdGVkIGpzcy1wbHVnaW4tZGVmYXVsdC11bml0IENTUyBwcm9wZXJ0eSB1bml0c1xuICpcbiAqIEB0eXBlIG9iamVjdFxuICovXG5cbnZhciBkZWZhdWx0VW5pdHMgPSB7XG4gIC8vIEFuaW1hdGlvbiBwcm9wZXJ0aWVzXG4gICdhbmltYXRpb24tZGVsYXknOiBtcyxcbiAgJ2FuaW1hdGlvbi1kdXJhdGlvbic6IG1zLFxuICAvLyBCYWNrZ3JvdW5kIHByb3BlcnRpZXNcbiAgJ2JhY2tncm91bmQtcG9zaXRpb24nOiBweCxcbiAgJ2JhY2tncm91bmQtcG9zaXRpb24teCc6IHB4LFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbi15JzogcHgsXG4gICdiYWNrZ3JvdW5kLXNpemUnOiBweCxcbiAgLy8gQm9yZGVyIFByb3BlcnRpZXNcbiAgYm9yZGVyOiBweCxcbiAgJ2JvcmRlci1ib3R0b20nOiBweCxcbiAgJ2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItYm90dG9tLXdpZHRoJzogcHgsXG4gICdib3JkZXItbGVmdCc6IHB4LFxuICAnYm9yZGVyLWxlZnQtd2lkdGgnOiBweCxcbiAgJ2JvcmRlci1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1yaWdodCc6IHB4LFxuICAnYm9yZGVyLXJpZ2h0LXdpZHRoJzogcHgsXG4gICdib3JkZXItdG9wJzogcHgsXG4gICdib3JkZXItdG9wLWxlZnQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItdG9wLXJpZ2h0LXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLXRvcC13aWR0aCc6IHB4LFxuICAnYm9yZGVyLXdpZHRoJzogcHgsXG4gICdib3JkZXItYmxvY2snOiBweCxcbiAgJ2JvcmRlci1ibG9jay1lbmQnOiBweCxcbiAgJ2JvcmRlci1ibG9jay1lbmQtd2lkdGgnOiBweCxcbiAgJ2JvcmRlci1ibG9jay1zdGFydCc6IHB4LFxuICAnYm9yZGVyLWJsb2NrLXN0YXJ0LXdpZHRoJzogcHgsXG4gICdib3JkZXItYmxvY2std2lkdGgnOiBweCxcbiAgJ2JvcmRlci1pbmxpbmUnOiBweCxcbiAgJ2JvcmRlci1pbmxpbmUtZW5kJzogcHgsXG4gICdib3JkZXItaW5saW5lLWVuZC13aWR0aCc6IHB4LFxuICAnYm9yZGVyLWlubGluZS1zdGFydCc6IHB4LFxuICAnYm9yZGVyLWlubGluZS1zdGFydC13aWR0aCc6IHB4LFxuICAnYm9yZGVyLWlubGluZS13aWR0aCc6IHB4LFxuICAnYm9yZGVyLXN0YXJ0LXN0YXJ0LXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLXN0YXJ0LWVuZC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1lbmQtc3RhcnQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItZW5kLWVuZC1yYWRpdXMnOiBweCxcbiAgLy8gTWFyZ2luIHByb3BlcnRpZXNcbiAgbWFyZ2luOiBweCxcbiAgJ21hcmdpbi1ib3R0b20nOiBweCxcbiAgJ21hcmdpbi1sZWZ0JzogcHgsXG4gICdtYXJnaW4tcmlnaHQnOiBweCxcbiAgJ21hcmdpbi10b3AnOiBweCxcbiAgJ21hcmdpbi1ibG9jayc6IHB4LFxuICAnbWFyZ2luLWJsb2NrLWVuZCc6IHB4LFxuICAnbWFyZ2luLWJsb2NrLXN0YXJ0JzogcHgsXG4gICdtYXJnaW4taW5saW5lJzogcHgsXG4gICdtYXJnaW4taW5saW5lLWVuZCc6IHB4LFxuICAnbWFyZ2luLWlubGluZS1zdGFydCc6IHB4LFxuICAvLyBQYWRkaW5nIHByb3BlcnRpZXNcbiAgcGFkZGluZzogcHgsXG4gICdwYWRkaW5nLWJvdHRvbSc6IHB4LFxuICAncGFkZGluZy1sZWZ0JzogcHgsXG4gICdwYWRkaW5nLXJpZ2h0JzogcHgsXG4gICdwYWRkaW5nLXRvcCc6IHB4LFxuICAncGFkZGluZy1ibG9jayc6IHB4LFxuICAncGFkZGluZy1ibG9jay1lbmQnOiBweCxcbiAgJ3BhZGRpbmctYmxvY2stc3RhcnQnOiBweCxcbiAgJ3BhZGRpbmctaW5saW5lJzogcHgsXG4gICdwYWRkaW5nLWlubGluZS1lbmQnOiBweCxcbiAgJ3BhZGRpbmctaW5saW5lLXN0YXJ0JzogcHgsXG4gIC8vIE1hc2sgcHJvcGVydGllc1xuICAnbWFzay1wb3NpdGlvbi14JzogcHgsXG4gICdtYXNrLXBvc2l0aW9uLXknOiBweCxcbiAgJ21hc2stc2l6ZSc6IHB4LFxuICAvLyBXaWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAgaGVpZ2h0OiBweCxcbiAgd2lkdGg6IHB4LFxuICAnbWluLWhlaWdodCc6IHB4LFxuICAnbWF4LWhlaWdodCc6IHB4LFxuICAnbWluLXdpZHRoJzogcHgsXG4gICdtYXgtd2lkdGgnOiBweCxcbiAgLy8gUG9zaXRpb24gcHJvcGVydGllc1xuICBib3R0b206IHB4LFxuICBsZWZ0OiBweCxcbiAgdG9wOiBweCxcbiAgcmlnaHQ6IHB4LFxuICBpbnNldDogcHgsXG4gICdpbnNldC1ibG9jayc6IHB4LFxuICAnaW5zZXQtYmxvY2stZW5kJzogcHgsXG4gICdpbnNldC1ibG9jay1zdGFydCc6IHB4LFxuICAnaW5zZXQtaW5saW5lJzogcHgsXG4gICdpbnNldC1pbmxpbmUtZW5kJzogcHgsXG4gICdpbnNldC1pbmxpbmUtc3RhcnQnOiBweCxcbiAgLy8gU2hhZG93IHByb3BlcnRpZXNcbiAgJ2JveC1zaGFkb3cnOiBweCxcbiAgJ3RleHQtc2hhZG93JzogcHgsXG4gIC8vIENvbHVtbiBwcm9wZXJ0aWVzXG4gICdjb2x1bW4tZ2FwJzogcHgsXG4gICdjb2x1bW4tcnVsZSc6IHB4LFxuICAnY29sdW1uLXJ1bGUtd2lkdGgnOiBweCxcbiAgJ2NvbHVtbi13aWR0aCc6IHB4LFxuICAvLyBGb250IGFuZCB0ZXh0IHByb3BlcnRpZXNcbiAgJ2ZvbnQtc2l6ZSc6IHB4LFxuICAnZm9udC1zaXplLWRlbHRhJzogcHgsXG4gICdsZXR0ZXItc3BhY2luZyc6IHB4LFxuICAndGV4dC1kZWNvcmF0aW9uLXRoaWNrbmVzcyc6IHB4LFxuICAndGV4dC1pbmRlbnQnOiBweCxcbiAgJ3RleHQtc3Ryb2tlJzogcHgsXG4gICd0ZXh0LXN0cm9rZS13aWR0aCc6IHB4LFxuICAnd29yZC1zcGFjaW5nJzogcHgsXG4gIC8vIE1vdGlvbiBwcm9wZXJ0aWVzXG4gIG1vdGlvbjogcHgsXG4gICdtb3Rpb24tb2Zmc2V0JzogcHgsXG4gIC8vIE91dGxpbmUgcHJvcGVydGllc1xuICBvdXRsaW5lOiBweCxcbiAgJ291dGxpbmUtb2Zmc2V0JzogcHgsXG4gICdvdXRsaW5lLXdpZHRoJzogcHgsXG4gIC8vIFBlcnNwZWN0aXZlIHByb3BlcnRpZXNcbiAgcGVyc3BlY3RpdmU6IHB4LFxuICAncGVyc3BlY3RpdmUtb3JpZ2luLXgnOiBwZXJjZW50LFxuICAncGVyc3BlY3RpdmUtb3JpZ2luLXknOiBwZXJjZW50LFxuICAvLyBUcmFuc2Zvcm0gcHJvcGVydGllc1xuICAndHJhbnNmb3JtLW9yaWdpbic6IHBlcmNlbnQsXG4gICd0cmFuc2Zvcm0tb3JpZ2luLXgnOiBwZXJjZW50LFxuICAndHJhbnNmb3JtLW9yaWdpbi15JzogcGVyY2VudCxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4teic6IHBlcmNlbnQsXG4gIC8vIFRyYW5zaXRpb24gcHJvcGVydGllc1xuICAndHJhbnNpdGlvbi1kZWxheSc6IG1zLFxuICAndHJhbnNpdGlvbi1kdXJhdGlvbic6IG1zLFxuICAvLyBBbGlnbm1lbnQgcHJvcGVydGllc1xuICAndmVydGljYWwtYWxpZ24nOiBweCxcbiAgJ2ZsZXgtYmFzaXMnOiBweCxcbiAgLy8gU29tZSByYW5kb20gcHJvcGVydGllc1xuICAnc2hhcGUtbWFyZ2luJzogcHgsXG4gIHNpemU6IHB4LFxuICBnYXA6IHB4LFxuICAvLyBHcmlkIHByb3BlcnRpZXNcbiAgZ3JpZDogcHgsXG4gICdncmlkLWdhcCc6IHB4LFxuICAncm93LWdhcCc6IHB4LFxuICAnZ3JpZC1yb3ctZ2FwJzogcHgsXG4gICdncmlkLWNvbHVtbi1nYXAnOiBweCxcbiAgJ2dyaWQtdGVtcGxhdGUtcm93cyc6IHB4LFxuICAnZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zJzogcHgsXG4gICdncmlkLWF1dG8tcm93cyc6IHB4LFxuICAnZ3JpZC1hdXRvLWNvbHVtbnMnOiBweCxcbiAgLy8gTm90IGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gIC8vIFVzZWQgdG8gYXZvaWQgaXNzdWVzIHdpdGgganNzLXBsdWdpbi1leHBhbmQgaW50ZWdyYXRpb24uXG4gICdib3gtc2hhZG93LXgnOiBweCxcbiAgJ2JveC1zaGFkb3cteSc6IHB4LFxuICAnYm94LXNoYWRvdy1ibHVyJzogcHgsXG4gICdib3gtc2hhZG93LXNwcmVhZCc6IHB4LFxuICAnZm9udC1saW5lLWhlaWdodCc6IHB4LFxuICAndGV4dC1zaGFkb3cteCc6IHB4LFxuICAndGV4dC1zaGFkb3cteSc6IHB4LFxuICAndGV4dC1zaGFkb3ctYmx1cic6IHB4XG59O1xuXG4vKipcbiAqIENsb25lcyB0aGUgb2JqZWN0IGFuZCBhZGRzIGEgY2FtZWwgY2FzZWQgcHJvcGVydHkgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gYWRkQ2FtZWxDYXNlZFZlcnNpb24ob2JqKSB7XG4gIHZhciByZWdFeHAgPSAvKC1bYS16XSkvZztcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0clsxXS50b1VwcGVyQ2FzZSgpO1xuICB9O1xuXG4gIHZhciBuZXdPYmogPSB7fTtcblxuICBmb3IgKHZhciBfa2V5IGluIG9iaikge1xuICAgIG5ld09ialtfa2V5XSA9IG9ialtfa2V5XTtcbiAgICBuZXdPYmpbX2tleS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZSldID0gb2JqW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cblxudmFyIHVuaXRzID0gYWRkQ2FtZWxDYXNlZFZlcnNpb24oZGVmYXVsdFVuaXRzKTtcbi8qKlxuICogUmVjdXJzaXZlIGRlZXAgc3R5bGUgcGFzc2luZyBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGl0ZXJhdGUocHJvcCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB2YWx1ZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZVtpXSA9IGl0ZXJhdGUocHJvcCwgdmFsdWVbaV0sIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3AgPT09ICdmYWxsYmFja3MnKSB7XG4gICAgICBmb3IgKHZhciBpbm5lclByb3AgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFsdWVbaW5uZXJQcm9wXSA9IGl0ZXJhdGUoaW5uZXJQcm9wLCB2YWx1ZVtpbm5lclByb3BdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2lubmVyUHJvcCBpbiB2YWx1ZSkge1xuICAgICAgICB2YWx1ZVtfaW5uZXJQcm9wXSA9IGl0ZXJhdGUocHJvcCArIFwiLVwiICsgX2lubmVyUHJvcCwgdmFsdWVbX2lubmVyUHJvcF0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIHVuaXQgPSBvcHRpb25zW3Byb3BdIHx8IHVuaXRzW3Byb3BdOyAvLyBBZGQgdGhlIHVuaXQgaWYgYXZhaWxhYmxlLCBleGNlcHQgZm9yIHRoZSBzcGVjaWFsIGNhc2Ugb2YgMHB4LlxuXG4gICAgaWYgKHVuaXQgJiYgISh2YWx1ZSA9PT0gMCAmJiB1bml0ID09PSBweCkpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdW5pdCA9PT0gJ2Z1bmN0aW9uJyA/IHVuaXQodmFsdWUpLnRvU3RyaW5nKCkgOiBcIlwiICsgdmFsdWUgKyB1bml0O1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBBZGQgdW5pdCB0byBudW1lcmljIHZhbHVlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZmF1bHRVbml0KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBjYW1lbENhc2VkT3B0aW9ucyA9IGFkZENhbWVsQ2FzZWRWZXJzaW9uKG9wdGlvbnMpO1xuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgc3R5bGVbcHJvcF0gPSBpdGVyYXRlKHByb3AsIHN0eWxlW3Byb3BdLCBjYW1lbENhc2VkT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCkge1xuICAgIHJldHVybiBpdGVyYXRlKHByb3AsIHZhbHVlLCBjYW1lbENhc2VkT3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSxcbiAgICBvbkNoYW5nZVZhbHVlOiBvbkNoYW5nZVZhbHVlXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRVbml0O1xuIiwiLyoqXG4gKiBBIHNjaGVtZSBmb3IgY29udmVydGluZyBwcm9wZXJ0aWVzIGZyb20gYXJyYXkgdG8gcmVndWxhciBzdHlsZS5cbiAqIEFsbCBwcm9wZXJ0aWVzIGxpc3RlZCBiZWxvdyB3aWxsIGJlIHRyYW5zZm9ybWVkIHRvIGEgc3RyaW5nIHNlcGFyYXRlZCBieSBzcGFjZS5cbiAqL1xudmFyIHByb3BBcnJheSA9IHtcbiAgJ2JhY2tncm91bmQtc2l6ZSc6IHRydWUsXG4gICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzogdHJ1ZSxcbiAgYm9yZGVyOiB0cnVlLFxuICAnYm9yZGVyLWJvdHRvbSc6IHRydWUsXG4gICdib3JkZXItbGVmdCc6IHRydWUsXG4gICdib3JkZXItdG9wJzogdHJ1ZSxcbiAgJ2JvcmRlci1yaWdodCc6IHRydWUsXG4gICdib3JkZXItcmFkaXVzJzogdHJ1ZSxcbiAgJ2JvcmRlci1pbWFnZSc6IHRydWUsXG4gICdib3JkZXItd2lkdGgnOiB0cnVlLFxuICAnYm9yZGVyLXN0eWxlJzogdHJ1ZSxcbiAgJ2JvcmRlci1jb2xvcic6IHRydWUsXG4gICdib3gtc2hhZG93JzogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgbWFyZ2luOiB0cnVlLFxuICBwYWRkaW5nOiB0cnVlLFxuICBvdXRsaW5lOiB0cnVlLFxuICAndHJhbnNmb3JtLW9yaWdpbic6IHRydWUsXG4gIHRyYW5zZm9ybTogdHJ1ZSxcbiAgdHJhbnNpdGlvbjogdHJ1ZVxuICAvKipcbiAgICogQSBzY2hlbWUgZm9yIGNvbnZlcnRpbmcgYXJyYXlzIHRvIHJlZ3VsYXIgc3R5bGVzIGluc2lkZSBvZiBvYmplY3RzLlxuICAgKiBGb3IgZS5nLjogXCJ7cG9zaXRpb246IFswLCAwXX1cIiA9PiBcImJhY2tncm91bmQtcG9zaXRpb246IDAgMDtcIi5cbiAgICovXG5cbn07XG52YXIgcHJvcEFycmF5SW5PYmogPSB7XG4gIHBvc2l0aW9uOiB0cnVlLFxuICAvLyBiYWNrZ3JvdW5kLXBvc2l0aW9uXG4gIHNpemU6IHRydWUgLy8gYmFja2dyb3VuZC1zaXplXG5cbiAgLyoqXG4gICAqIEEgc2NoZW1lIGZvciBwYXJzaW5nIGFuZCBidWlsZGluZyBjb3JyZWN0IHN0eWxlcyBmcm9tIHBhc3NlZCBvYmplY3RzLlxuICAgKi9cblxufTtcbnZhciBwcm9wT2JqID0ge1xuICBwYWRkaW5nOiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH0sXG4gIG1hcmdpbjoge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9LFxuICBiYWNrZ3JvdW5kOiB7XG4gICAgYXR0YWNobWVudDogbnVsbCxcbiAgICBjb2xvcjogbnVsbCxcbiAgICBpbWFnZTogbnVsbCxcbiAgICBwb3NpdGlvbjogbnVsbCxcbiAgICByZXBlYXQ6IG51bGxcbiAgfSxcbiAgYm9yZGVyOiB7XG4gICAgd2lkdGg6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgY29sb3I6IG51bGxcbiAgfSxcbiAgJ2JvcmRlci10b3AnOiB7XG4gICAgd2lkdGg6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgY29sb3I6IG51bGxcbiAgfSxcbiAgJ2JvcmRlci1yaWdodCc6IHtcbiAgICB3aWR0aDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBjb2xvcjogbnVsbFxuICB9LFxuICAnYm9yZGVyLWJvdHRvbSc6IHtcbiAgICB3aWR0aDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBjb2xvcjogbnVsbFxuICB9LFxuICAnYm9yZGVyLWxlZnQnOiB7XG4gICAgd2lkdGg6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgY29sb3I6IG51bGxcbiAgfSxcbiAgb3V0bGluZToge1xuICAgIHdpZHRoOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIGNvbG9yOiBudWxsXG4gIH0sXG4gICdsaXN0LXN0eWxlJzoge1xuICAgIHR5cGU6IG51bGwsXG4gICAgcG9zaXRpb246IG51bGwsXG4gICAgaW1hZ2U6IG51bGxcbiAgfSxcbiAgdHJhbnNpdGlvbjoge1xuICAgIHByb3BlcnR5OiBudWxsLFxuICAgIGR1cmF0aW9uOiBudWxsLFxuICAgICd0aW1pbmctZnVuY3Rpb24nOiBudWxsLFxuICAgIHRpbWluZ0Z1bmN0aW9uOiBudWxsLFxuICAgIC8vIE5lZWRlZCBmb3IgYXZvaWRpbmcgY29taWxhdGlvbiBpc3N1ZXMgd2l0aCBqc3MtcGx1Z2luLWNhbWVsLWNhc2VcbiAgICBkZWxheTogbnVsbFxuICB9LFxuICBhbmltYXRpb246IHtcbiAgICBuYW1lOiBudWxsLFxuICAgIGR1cmF0aW9uOiBudWxsLFxuICAgICd0aW1pbmctZnVuY3Rpb24nOiBudWxsLFxuICAgIHRpbWluZ0Z1bmN0aW9uOiBudWxsLFxuICAgIC8vIE5lZWRlZCB0byBhdm9pZCBjb21waWxhdGlvbiBpc3N1ZXMgd2l0aCBqc3MtcGx1Z2luLWNhbWVsLWNhc2VcbiAgICBkZWxheTogbnVsbCxcbiAgICAnaXRlcmF0aW9uLWNvdW50JzogbnVsbCxcbiAgICBpdGVyYXRpb25Db3VudDogbnVsbCxcbiAgICAvLyBOZWVkZWQgdG8gYXZvaWQgY29tcGlsYXRpb24gaXNzdWVzIHdpdGgganNzLXBsdWdpbi1jYW1lbC1jYXNlXG4gICAgZGlyZWN0aW9uOiBudWxsLFxuICAgICdmaWxsLW1vZGUnOiBudWxsLFxuICAgIGZpbGxNb2RlOiBudWxsLFxuICAgIC8vIE5lZWRlZCB0byBhdm9pZCBjb21waWxhdGlvbiBpc3N1ZXMgd2l0aCBqc3MtcGx1Z2luLWNhbWVsLWNhc2VcbiAgICAncGxheS1zdGF0ZSc6IG51bGwsXG4gICAgcGxheVN0YXRlOiBudWxsIC8vIE5lZWRlZCB0byBhdm9pZCBjb21waWxhdGlvbiBpc3N1ZXMgd2l0aCBqc3MtcGx1Z2luLWNhbWVsLWNhc2VcblxuICB9LFxuICAnYm94LXNoYWRvdyc6IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgYmx1cjogMCxcbiAgICBzcHJlYWQ6IDAsXG4gICAgY29sb3I6IG51bGwsXG4gICAgaW5zZXQ6IG51bGxcbiAgfSxcbiAgJ3RleHQtc2hhZG93Jzoge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBibHVyOiBudWxsLFxuICAgIGNvbG9yOiBudWxsXG4gIH1cbiAgLyoqXG4gICAqIEEgc2NoZW1lIGZvciBjb252ZXJ0aW5nIG5vbi1zdGFuZGFydCBwcm9wZXJ0aWVzIGluc2lkZSBvYmplY3QuXG4gICAqIEZvciBlLmcuOiBpbmNsdWRlICdib3JkZXItcmFkaXVzJyBwcm9wZXJ0eSBpbnNpZGUgJ2JvcmRlcicgb2JqZWN0LlxuICAgKi9cblxufTtcbnZhciBjdXN0b21Qcm9wT2JqID0ge1xuICBib3JkZXI6IHtcbiAgICByYWRpdXM6ICdib3JkZXItcmFkaXVzJyxcbiAgICBpbWFnZTogJ2JvcmRlci1pbWFnZScsXG4gICAgd2lkdGg6ICdib3JkZXItd2lkdGgnLFxuICAgIHN0eWxlOiAnYm9yZGVyLXN0eWxlJyxcbiAgICBjb2xvcjogJ2JvcmRlci1jb2xvcidcbiAgfSxcbiAgJ2JvcmRlci1ib3R0b20nOiB7XG4gICAgd2lkdGg6ICdib3JkZXItYm90dG9tLXdpZHRoJyxcbiAgICBzdHlsZTogJ2JvcmRlci1ib3R0b20tc3R5bGUnLFxuICAgIGNvbG9yOiAnYm9yZGVyLWJvdHRvbS1jb2xvcidcbiAgfSxcbiAgJ2JvcmRlci10b3AnOiB7XG4gICAgd2lkdGg6ICdib3JkZXItdG9wLXdpZHRoJyxcbiAgICBzdHlsZTogJ2JvcmRlci10b3Atc3R5bGUnLFxuICAgIGNvbG9yOiAnYm9yZGVyLXRvcC1jb2xvcidcbiAgfSxcbiAgJ2JvcmRlci1sZWZ0Jzoge1xuICAgIHdpZHRoOiAnYm9yZGVyLWxlZnQtd2lkdGgnLFxuICAgIHN0eWxlOiAnYm9yZGVyLWxlZnQtc3R5bGUnLFxuICAgIGNvbG9yOiAnYm9yZGVyLWxlZnQtY29sb3InXG4gIH0sXG4gICdib3JkZXItcmlnaHQnOiB7XG4gICAgd2lkdGg6ICdib3JkZXItcmlnaHQtd2lkdGgnLFxuICAgIHN0eWxlOiAnYm9yZGVyLXJpZ2h0LXN0eWxlJyxcbiAgICBjb2xvcjogJ2JvcmRlci1yaWdodC1jb2xvcidcbiAgfSxcbiAgYmFja2dyb3VuZDoge1xuICAgIHNpemU6ICdiYWNrZ3JvdW5kLXNpemUnLFxuICAgIGltYWdlOiAnYmFja2dyb3VuZC1pbWFnZSdcbiAgfSxcbiAgZm9udDoge1xuICAgIHN0eWxlOiAnZm9udC1zdHlsZScsXG4gICAgdmFyaWFudDogJ2ZvbnQtdmFyaWFudCcsXG4gICAgd2VpZ2h0OiAnZm9udC13ZWlnaHQnLFxuICAgIHN0cmV0Y2g6ICdmb250LXN0cmV0Y2gnLFxuICAgIHNpemU6ICdmb250LXNpemUnLFxuICAgIGZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcbiAgICBsaW5lSGVpZ2h0OiAnbGluZS1oZWlnaHQnLFxuICAgIC8vIE5lZWRlZCB0byBhdm9pZCBjb21waWxhdGlvbiBpc3N1ZXMgd2l0aCBqc3MtcGx1Z2luLWNhbWVsLWNhc2VcbiAgICAnbGluZS1oZWlnaHQnOiAnbGluZS1oZWlnaHQnXG4gIH0sXG4gIGZsZXg6IHtcbiAgICBncm93OiAnZmxleC1ncm93JyxcbiAgICBiYXNpczogJ2ZsZXgtYmFzaXMnLFxuICAgIGRpcmVjdGlvbjogJ2ZsZXgtZGlyZWN0aW9uJyxcbiAgICB3cmFwOiAnZmxleC13cmFwJyxcbiAgICBmbG93OiAnZmxleC1mbG93JyxcbiAgICBzaHJpbms6ICdmbGV4LXNocmluaydcbiAgfSxcbiAgYWxpZ246IHtcbiAgICBzZWxmOiAnYWxpZ24tc2VsZicsXG4gICAgaXRlbXM6ICdhbGlnbi1pdGVtcycsXG4gICAgY29udGVudDogJ2FsaWduLWNvbnRlbnQnXG4gIH0sXG4gIGdyaWQ6IHtcbiAgICAndGVtcGxhdGUtY29sdW1ucyc6ICdncmlkLXRlbXBsYXRlLWNvbHVtbnMnLFxuICAgIHRlbXBsYXRlQ29sdW1uczogJ2dyaWQtdGVtcGxhdGUtY29sdW1ucycsXG4gICAgJ3RlbXBsYXRlLXJvd3MnOiAnZ3JpZC10ZW1wbGF0ZS1yb3dzJyxcbiAgICB0ZW1wbGF0ZVJvd3M6ICdncmlkLXRlbXBsYXRlLXJvd3MnLFxuICAgICd0ZW1wbGF0ZS1hcmVhcyc6ICdncmlkLXRlbXBsYXRlLWFyZWFzJyxcbiAgICB0ZW1wbGF0ZUFyZWFzOiAnZ3JpZC10ZW1wbGF0ZS1hcmVhcycsXG4gICAgdGVtcGxhdGU6ICdncmlkLXRlbXBsYXRlJyxcbiAgICAnYXV0by1jb2x1bW5zJzogJ2dyaWQtYXV0by1jb2x1bW5zJyxcbiAgICBhdXRvQ29sdW1uczogJ2dyaWQtYXV0by1jb2x1bW5zJyxcbiAgICAnYXV0by1yb3dzJzogJ2dyaWQtYXV0by1yb3dzJyxcbiAgICBhdXRvUm93czogJ2dyaWQtYXV0by1yb3dzJyxcbiAgICAnYXV0by1mbG93JzogJ2dyaWQtYXV0by1mbG93JyxcbiAgICBhdXRvRmxvdzogJ2dyaWQtYXV0by1mbG93JyxcbiAgICByb3c6ICdncmlkLXJvdycsXG4gICAgY29sdW1uOiAnZ3JpZC1jb2x1bW4nLFxuICAgICdyb3ctc3RhcnQnOiAnZ3JpZC1yb3ctc3RhcnQnLFxuICAgIHJvd1N0YXJ0OiAnZ3JpZC1yb3ctc3RhcnQnLFxuICAgICdyb3ctZW5kJzogJ2dyaWQtcm93LWVuZCcsXG4gICAgcm93RW5kOiAnZ3JpZC1yb3ctZW5kJyxcbiAgICAnY29sdW1uLXN0YXJ0JzogJ2dyaWQtY29sdW1uLXN0YXJ0JyxcbiAgICBjb2x1bW5TdGFydDogJ2dyaWQtY29sdW1uLXN0YXJ0JyxcbiAgICAnY29sdW1uLWVuZCc6ICdncmlkLWNvbHVtbi1lbmQnLFxuICAgIGNvbHVtbkVuZDogJ2dyaWQtY29sdW1uLWVuZCcsXG4gICAgYXJlYTogJ2dyaWQtYXJlYScsXG4gICAgZ2FwOiAnZ3JpZC1nYXAnLFxuICAgICdyb3ctZ2FwJzogJ2dyaWQtcm93LWdhcCcsXG4gICAgcm93R2FwOiAnZ3JpZC1yb3ctZ2FwJyxcbiAgICAnY29sdW1uLWdhcCc6ICdncmlkLWNvbHVtbi1nYXAnLFxuICAgIGNvbHVtbkdhcDogJ2dyaWQtY29sdW1uLWdhcCdcbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cblxuLyoqXG4gKiBNYXAgdmFsdWVzIGJ5IGdpdmVuIHByb3AuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgdmFsdWVzXG4gKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luYWwgcHJvcGVydHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5hbCBydWxlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG1hcHBlZCB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gbWFwVmFsdWVzQnlQcm9wKHZhbHVlLCBwcm9wLCBydWxlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gb2JqZWN0VG9BcnJheShpdGVtLCBwcm9wLCBydWxlLCBmYWxzZSwgdHJ1ZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IHRvIG5lc3RlZCBhcnJheSwgaWYgbmVlZGVkXG4gKi9cblxuXG5mdW5jdGlvbiBwcm9jZXNzQXJyYXkodmFsdWUsIHByb3AsIHNjaGVtZSwgcnVsZSkge1xuICBpZiAoc2NoZW1lW3Byb3BdID09IG51bGwpIHJldHVybiB2YWx1ZTtcbiAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHJldHVybiBwcm9jZXNzQXJyYXkodmFsdWVbMF0sIHByb3AsIHNjaGVtZSwgcnVsZSk7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZVswXSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwVmFsdWVzQnlQcm9wKHZhbHVlLCBwcm9wLCBydWxlKTtcbiAgfVxuXG4gIHJldHVybiBbdmFsdWVdO1xufVxuLyoqXG4gKiBDb252ZXJ0IG9iamVjdCB0byBhcnJheS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9iamVjdFRvQXJyYXkodmFsdWUsIHByb3AsIHJ1bGUsIGlzRmFsbGJhY2ssIGlzSW5BcnJheSkge1xuICBpZiAoIShwcm9wT2JqW3Byb3BdIHx8IGN1c3RvbVByb3BPYmpbcHJvcF0pKSByZXR1cm4gW107XG4gIHZhciByZXN1bHQgPSBbXTsgLy8gQ2hlY2sgaWYgZXhpc3RzIGFueSBub24tc3RhbmRhcmQgcHJvcGVydHlcblxuICBpZiAoY3VzdG9tUHJvcE9ialtwcm9wXSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHZhbHVlID0gY3VzdG9tUHJvcHNUb1N0eWxlKHZhbHVlLCBydWxlLCBjdXN0b21Qcm9wT2JqW3Byb3BdLCBpc0ZhbGxiYWNrKTtcbiAgfSAvLyBQYXNzIHRocm91Z2h0IGFsbCBzdGFuZGFydCBwcm9wc1xuXG5cbiAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBiYXNlUHJvcCBpbiBwcm9wT2JqW3Byb3BdKSB7XG4gICAgICBpZiAodmFsdWVbYmFzZVByb3BdKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlW2Jhc2VQcm9wXSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwcm9wQXJyYXlJbk9ialtiYXNlUHJvcF0gPT09IG51bGwgPyB2YWx1ZVtiYXNlUHJvcF0gOiB2YWx1ZVtiYXNlUHJvcF0uam9pbignICcpKTtcbiAgICAgICAgfSBlbHNlIHJlc3VsdC5wdXNoKHZhbHVlW2Jhc2VQcm9wXSk7XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIEFkZCBkZWZhdWx0IHZhbHVlIGZyb20gcHJvcHMgY29uZmlnLlxuXG5cbiAgICAgIGlmIChwcm9wT2JqW3Byb3BdW2Jhc2VQcm9wXSAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHByb3BPYmpbcHJvcF1bYmFzZVByb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXJlc3VsdC5sZW5ndGggfHwgaXNJbkFycmF5KSByZXR1cm4gcmVzdWx0O1xuICByZXR1cm4gW3Jlc3VsdF07XG59XG4vKipcbiAqIENvbnZlcnQgY3VzdG9tIHByb3BlcnRpZXMgdmFsdWVzIHRvIHN0eWxlcyBhZGRpbmcgdGhlbSB0byBydWxlIGRpcmVjdGx5XG4gKi9cblxuXG5mdW5jdGlvbiBjdXN0b21Qcm9wc1RvU3R5bGUodmFsdWUsIHJ1bGUsIGN1c3RvbVByb3BzLCBpc0ZhbGxiYWNrKSB7XG4gIGZvciAodmFyIHByb3AgaW4gY3VzdG9tUHJvcHMpIHtcbiAgICB2YXIgcHJvcE5hbWUgPSBjdXN0b21Qcm9wc1twcm9wXTsgLy8gSWYgY3VycmVudCBwcm9wZXJ0eSBkb2Vzbid0IGV4aXN0IGFscmVhZHkgaW4gcnVsZSAtIGFkZCBuZXcgb25lXG5cbiAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BdICE9PSAndW5kZWZpbmVkJyAmJiAoaXNGYWxsYmFjayB8fCAhcnVsZS5wcm9wKHByb3BOYW1lKSkpIHtcbiAgICAgIHZhciBfc3R5bGVEZXRlY3RvcjtcblxuICAgICAgdmFyIGFwcGVuZGVkVmFsdWUgPSBzdHlsZURldGVjdG9yKChfc3R5bGVEZXRlY3RvciA9IHt9LCBfc3R5bGVEZXRlY3Rvcltwcm9wTmFtZV0gPSB2YWx1ZVtwcm9wXSwgX3N0eWxlRGV0ZWN0b3IpLCBydWxlKVtwcm9wTmFtZV07IC8vIEFkZCBzdHlsZSBkaXJlY3RseSBpbiBydWxlXG5cbiAgICAgIGlmIChpc0ZhbGxiYWNrKSBydWxlLnN0eWxlLmZhbGxiYWNrc1twcm9wTmFtZV0gPSBhcHBlbmRlZFZhbHVlO2Vsc2UgcnVsZS5zdHlsZVtwcm9wTmFtZV0gPSBhcHBlbmRlZFZhbHVlO1xuICAgIH0gLy8gRGVsZXRlIGNvbnZlcnRlZCBwcm9wZXJ0eSB0byBhdm9pZCBkb3VibGUgY29udmVydGluZ1xuXG5cbiAgICBkZWxldGUgdmFsdWVbcHJvcF07XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIERldGVjdCBpZiBhIHN0eWxlIG5lZWRzIHRvIGJlIGNvbnZlcnRlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHN0eWxlRGV0ZWN0b3Ioc3R5bGUsIHJ1bGUsIGlzRmFsbGJhY2spIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAvLyBDaGVjayBkb3VibGUgYXJyYXlzIHRvIGF2b2lkIHJlY3Vyc2lvbi5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICAgICAgaWYgKHByb3AgPT09ICdmYWxsYmFja3MnKSB7XG4gICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0eWxlLmZhbGxiYWNrcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHN0eWxlLmZhbGxiYWNrc1tpbmRleF0gPSBzdHlsZURldGVjdG9yKHN0eWxlLmZhbGxiYWNrc1tpbmRleF0sIHJ1bGUsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGVbcHJvcF0gPSBwcm9jZXNzQXJyYXkodmFsdWUsIHByb3AsIHByb3BBcnJheSwgcnVsZSk7IC8vIEF2b2lkIGNyZWF0aW5nIHByb3BlcnRpZXMgd2l0aCBlbXB0eSB2YWx1ZXNcblxuICAgICAgICBpZiAoIXN0eWxlW3Byb3BdLmxlbmd0aCkgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3AgPT09ICdmYWxsYmFja3MnKSB7XG4gICAgICAgIHN0eWxlLmZhbGxiYWNrcyA9IHN0eWxlRGV0ZWN0b3Ioc3R5bGUuZmFsbGJhY2tzLCBydWxlLCB0cnVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlW3Byb3BdID0gb2JqZWN0VG9BcnJheSh2YWx1ZSwgcHJvcCwgcnVsZSwgaXNGYWxsYmFjayk7IC8vIEF2b2lkIGNyZWF0aW5nIHByb3BlcnRpZXMgd2l0aCBlbXB0eSB2YWx1ZXNcblxuICAgICAgaWYgKCFzdHlsZVtwcm9wXS5sZW5ndGgpIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICB9IC8vIE1heWJlIGEgY29tcHV0ZWQgdmFsdWUgcmVzdWx0aW5nIGluIGFuIGVtcHR5IHN0cmluZ1xuICAgIGVsc2UgaWYgKHN0eWxlW3Byb3BdID09PSAnJykgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuLyoqXG4gKiBBZGRzIHBvc3NpYmlsaXR5IHRvIHdyaXRlIGV4cGFuZGVkIHN0eWxlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGpzc0V4cGFuZCgpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICBpZiAoIXN0eWxlIHx8IHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAvLyBQYXNzIHJ1bGVzIG9uZSBieSBvbmUgYW5kIHJlZm9ybWF0IHRoZW1cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdHlsZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3R5bGVbaW5kZXhdID0gc3R5bGVEZXRlY3RvcihzdHlsZVtpbmRleF0sIHJ1bGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlRGV0ZWN0b3Ioc3R5bGUsIHJ1bGUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGVcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQganNzRXhwYW5kO1xuIiwiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcblxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn07XG5cbnZhciB2YWx1ZU5zID0gXCJleHRlbmRDdXJyVmFsdWVcIiArIERhdGUubm93KCk7XG5cbmZ1bmN0aW9uIG1lcmdlRXh0ZW5kKHN0eWxlLCBydWxlLCBzaGVldCwgbmV3U3R5bGUpIHtcbiAgdmFyIGV4dGVuZFR5cGUgPSB0eXBlb2Ygc3R5bGUuZXh0ZW5kOyAvLyBFeHRlbmQgdXNpbmcgYSBydWxlIG5hbWUuXG5cbiAgaWYgKGV4dGVuZFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFzaGVldCkgcmV0dXJuO1xuICAgIHZhciByZWZSdWxlID0gc2hlZXQuZ2V0UnVsZShzdHlsZS5leHRlbmQpO1xuICAgIGlmICghcmVmUnVsZSkgcmV0dXJuO1xuXG4gICAgaWYgKHJlZlJ1bGUgPT09IHJ1bGUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gQSBydWxlIHRyaWVzIHRvIGV4dGVuZCBpdHNlbGYgXFxuXCIgKyBydWxlLnRvU3RyaW5nKCkpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnQgPSByZWZSdWxlLm9wdGlvbnMucGFyZW50O1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgdmFyIG9yaWdpbmFsU3R5bGUgPSBwYXJlbnQucnVsZXMucmF3W3N0eWxlLmV4dGVuZF07XG4gICAgICBleHRlbmQob3JpZ2luYWxTdHlsZSwgcnVsZSwgc2hlZXQsIG5ld1N0eWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gLy8gRXh0ZW5kIHVzaW5nIGFuIGFycmF5LlxuXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUuZXh0ZW5kKSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdHlsZS5leHRlbmQubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgc2luZ2xlRXh0ZW5kID0gc3R5bGUuZXh0ZW5kW2luZGV4XTtcbiAgICAgIHZhciBzaW5nbGVTdHlsZSA9IHR5cGVvZiBzaW5nbGVFeHRlbmQgPT09ICdzdHJpbmcnID8gX2V4dGVuZHMoe30sIHN0eWxlLCB7XG4gICAgICAgIGV4dGVuZDogc2luZ2xlRXh0ZW5kXG4gICAgICB9KSA6IHN0eWxlLmV4dGVuZFtpbmRleF07XG4gICAgICBleHRlbmQoc2luZ2xlU3R5bGUsIHJ1bGUsIHNoZWV0LCBuZXdTdHlsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9IC8vIEV4dGVuZCBpcyBhIHN0eWxlIG9iamVjdC5cblxuXG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGUuZXh0ZW5kKSB7XG4gICAgaWYgKHByb3AgPT09ICdleHRlbmQnKSB7XG4gICAgICBleHRlbmQoc3R5bGUuZXh0ZW5kLmV4dGVuZCwgcnVsZSwgc2hlZXQsIG5ld1N0eWxlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdChzdHlsZS5leHRlbmRbcHJvcF0pKSB7XG4gICAgICBpZiAoIShwcm9wIGluIG5ld1N0eWxlKSkgbmV3U3R5bGVbcHJvcF0gPSB7fTtcbiAgICAgIGV4dGVuZChzdHlsZS5leHRlbmRbcHJvcF0sIHJ1bGUsIHNoZWV0LCBuZXdTdHlsZVtwcm9wXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBuZXdTdHlsZVtwcm9wXSA9IHN0eWxlLmV4dGVuZFtwcm9wXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZVJlc3Qoc3R5bGUsIHJ1bGUsIHNoZWV0LCBuZXdTdHlsZSkge1xuICAvLyBDb3B5IGJhc2Ugc3R5bGUuXG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICBpZiAocHJvcCA9PT0gJ2V4dGVuZCcpIGNvbnRpbnVlO1xuXG4gICAgaWYgKGlzT2JqZWN0KG5ld1N0eWxlW3Byb3BdKSAmJiBpc09iamVjdChzdHlsZVtwcm9wXSkpIHtcbiAgICAgIGV4dGVuZChzdHlsZVtwcm9wXSwgcnVsZSwgc2hlZXQsIG5ld1N0eWxlW3Byb3BdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdChzdHlsZVtwcm9wXSkpIHtcbiAgICAgIG5ld1N0eWxlW3Byb3BdID0gZXh0ZW5kKHN0eWxlW3Byb3BdLCBydWxlLCBzaGVldCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBuZXdTdHlsZVtwcm9wXSA9IHN0eWxlW3Byb3BdO1xuICB9XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGV4dGVuZCBzdHlsZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmQoc3R5bGUsIHJ1bGUsIHNoZWV0LCBuZXdTdHlsZSkge1xuICBpZiAobmV3U3R5bGUgPT09IHZvaWQgMCkge1xuICAgIG5ld1N0eWxlID0ge307XG4gIH1cblxuICBtZXJnZUV4dGVuZChzdHlsZSwgcnVsZSwgc2hlZXQsIG5ld1N0eWxlKTtcbiAgbWVyZ2VSZXN0KHN0eWxlLCBydWxlLCBzaGVldCwgbmV3U3R5bGUpO1xuICByZXR1cm4gbmV3U3R5bGU7XG59XG4vKipcbiAqIEhhbmRsZSBgZXh0ZW5kYCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBqc3NFeHRlbmQoKSB7XG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICAgIGlmICgnZXh0ZW5kJyBpbiBzdHlsZSkgcmV0dXJuIGV4dGVuZChzdHlsZSwgcnVsZSwgc2hlZXQpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3AsIHJ1bGUpIHtcbiAgICBpZiAocHJvcCAhPT0gJ2V4dGVuZCcpIHJldHVybiB2YWx1ZTsgLy8gVmFsdWUgaXMgZW1wdHksIHJlbW92ZSBwcm9wZXJ0aWVzIHNldCBwcmV2aW91c2x5LlxuXG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIGZvciAodmFyIGtleSBpbiBydWxlW3ZhbHVlTnNdKSB7XG4gICAgICAgIHJ1bGUucHJvcChrZXksIG51bGwpO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gRmxvdyBjb21wbGFpbnMgYmVjYXVzZSB0aGVyZSBpcyBubyBpbmRleGVyIHByb3BlcnR5IGluIFN0eWxlUnVsZVxuXG5cbiAgICAgIHJ1bGVbdmFsdWVOc10gPSBudWxsO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW52YWxpZC1pbi1yaHNdIFRoaXMgd2lsbCBiZSBhbiBvYmplY3RcbiAgICAgIGZvciAodmFyIF9rZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIHdpbGwgYmUgYW4gb2JqZWN0XG4gICAgICAgIHJ1bGUucHJvcChfa2V5LCB2YWx1ZVtfa2V5XSk7XG4gICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBGbG93IGNvbXBsYWlucyBiZWNhdXNlIHRoZXJlIGlzIG5vIGluZGV4ZXIgcHJvcGVydHkgaW4gU3R5bGVSdWxlXG5cblxuICAgICAgcnVsZVt2YWx1ZU5zXSA9IHZhbHVlO1xuICAgIH0gLy8gTWFrZSBzdXJlIHdlIGRvbid0IHNldCB0aGUgdmFsdWUgaW4gdGhlIGNvcmUuXG5cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBqc3NFeHRlbmQ7XG4iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgeyBSdWxlTGlzdCB9IGZyb20gJ2pzcyc7XG5cbnZhciBhdCA9ICdAZ2xvYmFsJztcbnZhciBhdFByZWZpeCA9ICdAZ2xvYmFsICc7XG5cbnZhciBHbG9iYWxDb250YWluZXJSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2xvYmFsQ29udGFpbmVyUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdnbG9iYWwnO1xuICAgIHRoaXMuYXQgPSBhdDtcbiAgICB0aGlzLnJ1bGVzID0gdm9pZCAwO1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBzZWxlY3RvciBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKHNlbGVjdG9yLCBzdHlsZXNbc2VsZWN0b3JdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gR2xvYmFsQ29udGFpbmVyUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgcmVnaXN0ZXIgcnVsZSwgcnVuIHBsdWdpbnMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGUgPSBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgaWYgKHJ1bGUpIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuaW5kZXhPZihydWxlKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy50b1N0cmluZygpO1xuICB9O1xuXG4gIHJldHVybiBHbG9iYWxDb250YWluZXJSdWxlO1xufSgpO1xuXG52YXIgR2xvYmFsUHJlZml4ZWRSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2xvYmFsUHJlZml4ZWRSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnZ2xvYmFsJztcbiAgICB0aGlzLmF0ID0gYXQ7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMucnVsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB2YXIgc2VsZWN0b3IgPSBrZXkuc3Vic3RyKGF0UHJlZml4Lmxlbmd0aCk7XG4gICAgdGhpcy5ydWxlID0gb3B0aW9ucy5qc3MuY3JlYXRlUnVsZShzZWxlY3Rvciwgc3R5bGUsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IEdsb2JhbFByZWZpeGVkUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlID8gdGhpcy5ydWxlLnRvU3RyaW5nKG9wdGlvbnMpIDogJyc7XG4gIH07XG5cbiAgcmV0dXJuIEdsb2JhbFByZWZpeGVkUnVsZTtcbn0oKTtcblxudmFyIHNlcGFyYXRvclJlZ0V4cCA9IC9cXHMqLFxccyovZztcblxuZnVuY3Rpb24gYWRkU2NvcGUoc2VsZWN0b3IsIHNjb3BlKSB7XG4gIHZhciBwYXJ0cyA9IHNlbGVjdG9yLnNwbGl0KHNlcGFyYXRvclJlZ0V4cCk7XG4gIHZhciBzY29wZWQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc2NvcGVkICs9IHNjb3BlICsgXCIgXCIgKyBwYXJ0c1tpXS50cmltKCk7XG4gICAgaWYgKHBhcnRzW2kgKyAxXSkgc2NvcGVkICs9ICcsICc7XG4gIH1cblxuICByZXR1cm4gc2NvcGVkO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVOZXN0ZWRHbG9iYWxDb250YWluZXJSdWxlKHJ1bGUsIHNoZWV0KSB7XG4gIHZhciBvcHRpb25zID0gcnVsZS5vcHRpb25zLFxuICAgICAgc3R5bGUgPSBydWxlLnN0eWxlO1xuICB2YXIgcnVsZXMgPSBzdHlsZSA/IHN0eWxlW2F0XSA6IG51bGw7XG4gIGlmICghcnVsZXMpIHJldHVybjtcblxuICBmb3IgKHZhciBuYW1lIGluIHJ1bGVzKSB7XG4gICAgc2hlZXQuYWRkUnVsZShuYW1lLCBydWxlc1tuYW1lXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNlbGVjdG9yOiBhZGRTY29wZShuYW1lLCBydWxlLnNlbGVjdG9yKVxuICAgIH0pKTtcbiAgfVxuXG4gIGRlbGV0ZSBzdHlsZVthdF07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVByZWZpeGVkR2xvYmFsUnVsZShydWxlLCBzaGVldCkge1xuICB2YXIgb3B0aW9ucyA9IHJ1bGUub3B0aW9ucyxcbiAgICAgIHN0eWxlID0gcnVsZS5zdHlsZTtcblxuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgaWYgKHByb3BbMF0gIT09ICdAJyB8fCBwcm9wLnN1YnN0cigwLCBhdC5sZW5ndGgpICE9PSBhdCkgY29udGludWU7XG4gICAgdmFyIHNlbGVjdG9yID0gYWRkU2NvcGUocHJvcC5zdWJzdHIoYXQubGVuZ3RoKSwgcnVsZS5zZWxlY3Rvcik7XG4gICAgc2hlZXQuYWRkUnVsZShzZWxlY3Rvciwgc3R5bGVbcHJvcF0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3JcbiAgICB9KSk7XG4gICAgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICB9XG59XG4vKipcbiAqIENvbnZlcnQgbmVzdGVkIHJ1bGVzIHRvIHNlcGFyYXRlLCByZW1vdmUgdGhlbSBmcm9tIG9yaWdpbmFsIHN0eWxlcy5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBqc3NHbG9iYWwoKSB7XG4gIGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBudWxsO1xuXG4gICAgaWYgKG5hbWUgPT09IGF0KSB7XG4gICAgICByZXR1cm4gbmV3IEdsb2JhbENvbnRhaW5lclJ1bGUobmFtZSwgc3R5bGVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZVswXSA9PT0gJ0AnICYmIG5hbWUuc3Vic3RyKDAsIGF0UHJlZml4Lmxlbmd0aCkgPT09IGF0UHJlZml4KSB7XG4gICAgICByZXR1cm4gbmV3IEdsb2JhbFByZWZpeGVkUnVsZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ2dsb2JhbCcgfHwgcGFyZW50Lm9wdGlvbnMucGFyZW50ICYmIHBhcmVudC5vcHRpb25zLnBhcmVudC50eXBlID09PSAnZ2xvYmFsJykge1xuICAgICAgICBvcHRpb25zLnNjb3BlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNjb3BlZCA9PT0gZmFsc2UpIHtcbiAgICAgIG9wdGlvbnMuc2VsZWN0b3IgPSBuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlLCBzaGVldCkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScgfHwgIXNoZWV0KSByZXR1cm47XG4gICAgaGFuZGxlTmVzdGVkR2xvYmFsQ29udGFpbmVyUnVsZShydWxlLCBzaGVldCk7XG4gICAgaGFuZGxlUHJlZml4ZWRHbG9iYWxSdWxlKHJ1bGUsIHNoZWV0KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25DcmVhdGVSdWxlOiBvbkNyZWF0ZVJ1bGUsXG4gICAgb25Qcm9jZXNzUnVsZTogb25Qcm9jZXNzUnVsZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBqc3NHbG9iYWw7XG4iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuXG52YXIgc2VwYXJhdG9yUmVnRXhwID0gL1xccyosXFxzKi9nO1xudmFyIHBhcmVudFJlZ0V4cCA9IC8mL2c7XG52YXIgcmVmUmVnRXhwID0gL1xcJChbXFx3LV0rKS9nO1xuLyoqXG4gKiBDb252ZXJ0IG5lc3RlZCBydWxlcyB0byBzZXBhcmF0ZSwgcmVtb3ZlIHRoZW0gZnJvbSBvcmlnaW5hbCBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtSdWxlfSBydWxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGpzc05lc3RlZCgpIHtcbiAgLy8gR2V0IGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgJHJlZiByZXBsYWNlbWVudC5cbiAgZnVuY3Rpb24gZ2V0UmVwbGFjZVJlZihjb250YWluZXIsIHNoZWV0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwga2V5KSB7XG4gICAgICB2YXIgcnVsZSA9IGNvbnRhaW5lci5nZXRSdWxlKGtleSkgfHwgc2hlZXQgJiYgc2hlZXQuZ2V0UnVsZShrZXkpO1xuXG4gICAgICBpZiAocnVsZSkge1xuICAgICAgICBydWxlID0gcnVsZTtcbiAgICAgICAgcmV0dXJuIHJ1bGUuc2VsZWN0b3I7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gQ291bGQgbm90IGZpbmQgdGhlIHJlZmVyZW5jZWQgcnVsZSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaW4gXFxcIlwiICsgKGNvbnRhaW5lci5vcHRpb25zLm1ldGEgfHwgY29udGFpbmVyLnRvU3RyaW5nKCkpICsgXCJcXFwiLlwiKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VQYXJlbnRSZWZzKG5lc3RlZFByb3AsIHBhcmVudFByb3ApIHtcbiAgICB2YXIgcGFyZW50U2VsZWN0b3JzID0gcGFyZW50UHJvcC5zcGxpdChzZXBhcmF0b3JSZWdFeHApO1xuICAgIHZhciBuZXN0ZWRTZWxlY3RvcnMgPSBuZXN0ZWRQcm9wLnNwbGl0KHNlcGFyYXRvclJlZ0V4cCk7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRTZWxlY3RvcnNbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmVzdGVkU2VsZWN0b3JzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBuZXN0ZWQgPSBuZXN0ZWRTZWxlY3RvcnNbal07XG4gICAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSAnLCAnOyAvLyBSZXBsYWNlIGFsbCAmIGJ5IHRoZSBwYXJlbnQgb3IgcHJlZml4ICYgd2l0aCB0aGUgcGFyZW50LlxuXG4gICAgICAgIHJlc3VsdCArPSBuZXN0ZWQuaW5kZXhPZignJicpICE9PSAtMSA/IG5lc3RlZC5yZXBsYWNlKHBhcmVudFJlZ0V4cCwgcGFyZW50KSA6IHBhcmVudCArIFwiIFwiICsgbmVzdGVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRPcHRpb25zKHJ1bGUsIGNvbnRhaW5lciwgcHJldk9wdGlvbnMpIHtcbiAgICAvLyBPcHRpb25zIGhhcyBiZWVuIGFscmVhZHkgY3JlYXRlZCwgbm93IHdlIG9ubHkgaW5jcmVhc2UgaW5kZXguXG4gICAgaWYgKHByZXZPcHRpb25zKSByZXR1cm4gX2V4dGVuZHMoe30sIHByZXZPcHRpb25zLCB7XG4gICAgICBpbmRleDogcHJldk9wdGlvbnMuaW5kZXggKyAxIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gICAgfSk7XG4gICAgdmFyIG5lc3RpbmdMZXZlbCA9IHJ1bGUub3B0aW9ucy5uZXN0aW5nTGV2ZWw7XG4gICAgbmVzdGluZ0xldmVsID0gbmVzdGluZ0xldmVsID09PSB1bmRlZmluZWQgPyAxIDogbmVzdGluZ0xldmVsICsgMTtcblxuICAgIHZhciBvcHRpb25zID0gX2V4dGVuZHMoe30sIHJ1bGUub3B0aW9ucywge1xuICAgICAgbmVzdGluZ0xldmVsOiBuZXN0aW5nTGV2ZWwsXG4gICAgICBpbmRleDogY29udGFpbmVyLmluZGV4T2YocnVsZSkgKyAxIC8vIFdlIGRvbid0IG5lZWQgdGhlIHBhcmVudCBuYW1lIHRvIGJlIHNldCBvcHRpb25zIGZvciBjaGxpZC5cblxuICAgIH0pO1xuXG4gICAgZGVsZXRlIG9wdGlvbnMubmFtZTtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcbiAgICB2YXIgc3R5bGVSdWxlID0gcnVsZTtcbiAgICB2YXIgY29udGFpbmVyID0gc3R5bGVSdWxlLm9wdGlvbnMucGFyZW50O1xuICAgIHZhciBvcHRpb25zO1xuICAgIHZhciByZXBsYWNlUmVmO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgdmFyIGlzTmVzdGVkID0gcHJvcC5pbmRleE9mKCcmJykgIT09IC0xO1xuICAgICAgdmFyIGlzTmVzdGVkQ29uZGl0aW9uYWwgPSBwcm9wWzBdID09PSAnQCc7XG4gICAgICBpZiAoIWlzTmVzdGVkICYmICFpc05lc3RlZENvbmRpdGlvbmFsKSBjb250aW51ZTtcbiAgICAgIG9wdGlvbnMgPSBnZXRPcHRpb25zKHN0eWxlUnVsZSwgY29udGFpbmVyLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGlzTmVzdGVkKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHJlcGxhY2VQYXJlbnRSZWZzKHByb3AsIHN0eWxlUnVsZS5zZWxlY3Rvcik7IC8vIExhemlseSBjcmVhdGUgdGhlIHJlZiByZXBsYWNlciBmdW5jdGlvbiBqdXN0IG9uY2UgZm9yXG4gICAgICAgIC8vIGFsbCBuZXN0ZWQgcnVsZXMgd2l0aGluIHRoZSBzaGVldC5cblxuICAgICAgICBpZiAoIXJlcGxhY2VSZWYpIHJlcGxhY2VSZWYgPSBnZXRSZXBsYWNlUmVmKGNvbnRhaW5lciwgc2hlZXQpOyAvLyBSZXBsYWNlIGFsbCAkcmVmcy5cblxuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UocmVmUmVnRXhwLCByZXBsYWNlUmVmKTtcbiAgICAgICAgY29udGFpbmVyLmFkZFJ1bGUoc2VsZWN0b3IsIHN0eWxlW3Byb3BdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvclxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTmVzdGVkQ29uZGl0aW9uYWwpIHtcbiAgICAgICAgLy8gUGxhY2UgY29uZGl0aW9uYWwgcmlnaHQgYWZ0ZXIgdGhlIHBhcmVudCBydWxlIHRvIGVuc3VyZSByaWdodCBvcmRlcmluZy5cbiAgICAgICAgY29udGFpbmVyLmFkZFJ1bGUocHJvcCwge30sIG9wdGlvbnMpIC8vIEZsb3cgZXhwZWN0cyBtb3JlIG9wdGlvbnMgYnV0IHRoZXkgYXJlbid0IHJlcXVpcmVkXG4gICAgICAgIC8vIEFuZCBmbG93IGRvZXNuJ3Qga25vdyB0aGlzIHdpbGwgYWx3YXlzIGJlIGEgU3R5bGVSdWxlIHdoaWNoIGhhcyB0aGUgYWRkUnVsZSBtZXRob2RcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXVxuICAgICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgLmFkZFJ1bGUoc3R5bGVSdWxlLmtleSwgc3R5bGVbcHJvcF0sIHtcbiAgICAgICAgICBzZWxlY3Rvcjogc3R5bGVSdWxlLnNlbGVjdG9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGVcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQganNzTmVzdGVkO1xuIiwiLyoqXG4gKiBTb3J0IHByb3BzIGJ5IGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24ganNzUHJvcHNTb3J0KCkge1xuICB2YXIgc29ydCA9IGZ1bmN0aW9uIHNvcnQocHJvcDAsIHByb3AxKSB7XG4gICAgaWYgKHByb3AwLmxlbmd0aCA9PT0gcHJvcDEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcHJvcDAgPiBwcm9wMSA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDAubGVuZ3RoIC0gcHJvcDEubGVuZ3RoO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzU3R5bGU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG4gICAgICB2YXIgbmV3U3R5bGUgPSB7fTtcbiAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5rZXlzKHN0eWxlKS5zb3J0KHNvcnQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld1N0eWxlW3Byb3BzW2ldXSA9IHN0eWxlW3Byb3BzW2ldXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1N0eWxlO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQganNzUHJvcHNTb3J0O1xuIiwiaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcbmltcG9ydCB7IGNyZWF0ZVJ1bGUgfSBmcm9tICdqc3MnO1xuXG52YXIgbm93ID0gRGF0ZS5ub3coKTtcbnZhciBmblZhbHVlc05zID0gXCJmblZhbHVlc1wiICsgbm93O1xudmFyIGZuUnVsZU5zID0gXCJmblN0eWxlXCIgKyArK25vdztcblxudmFyIGZ1bmN0aW9uUGx1Z2luID0gZnVuY3Rpb24gZnVuY3Rpb25QbHVnaW4oKSB7XG4gIHJldHVybiB7XG4gICAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBkZWNsICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBydWxlID0gY3JlYXRlUnVsZShuYW1lLCB7fSwgb3B0aW9ucyk7XG4gICAgICBydWxlW2ZuUnVsZU5zXSA9IGRlY2w7XG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9LFxuICAgIG9uUHJvY2Vzc1N0eWxlOiBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBleHRyYWN0IGZ1bmN0aW9uIHZhbHVlcyBmcm9tIHRoZSBkZWNsYXJhdGlvbiwgc28gdGhhdCB3ZSBjYW4ga2VlcCBjb3JlIHVuYXdhcmUgb2YgdGhlbS5cbiAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhhdCBvbmx5IG9uY2UuXG4gICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGV4dHJhY3QgZnVuY3Rpb25zIG9uIGVhY2ggc3R5bGUgdXBkYXRlLCBzaW5jZSB0aGlzIGNhbiBoYXBwZW4gb25seSBvbmNlLlxuICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBmdW5jdGlvbiB2YWx1ZXMgaW5zaWRlIG9mIGZ1bmN0aW9uIHJ1bGVzLlxuICAgICAgaWYgKGZuVmFsdWVzTnMgaW4gcnVsZSB8fCBmblJ1bGVOcyBpbiBydWxlKSByZXR1cm4gc3R5bGU7XG4gICAgICB2YXIgZm5WYWx1ZXMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykgY29udGludWU7XG4gICAgICAgIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICAgICAgZm5WYWx1ZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgcnVsZVtmblZhbHVlc05zXSA9IGZuVmFsdWVzO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG4gICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgc3R5bGVSdWxlID0gcnVsZTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgICAgIHZhciBmblJ1bGUgPSBzdHlsZVJ1bGVbZm5SdWxlTnNdOyAvLyBJZiB3ZSBoYXZlIGEgc3R5bGUgZnVuY3Rpb24sIHRoZSBlbnRpcmUgcnVsZSBpcyBkeW5hbWljIGFuZCBzdHlsZSBvYmplY3RcbiAgICAgIC8vIHdpbGwgYmUgcmV0dXJuZWQgZnJvbSB0aGF0IGZ1bmN0aW9uLlxuXG4gICAgICBpZiAoZm5SdWxlKSB7XG4gICAgICAgIC8vIEVtcHR5IG9iamVjdCB3aWxsIHJlbW92ZSBhbGwgY3VycmVudGx5IGRlZmluZWQgcHJvcHNcbiAgICAgICAgLy8gaW4gY2FzZSBmdW5jdGlvbiBydWxlIHJldHVybnMgYSBmYWxzeSB2YWx1ZS5cbiAgICAgICAgc3R5bGVSdWxlLnN0eWxlID0gZm5SdWxlKGRhdGEpIHx8IHt9O1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGVSdWxlLnN0eWxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlUnVsZS5zdHlsZVtwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnW0pTU10gRnVuY3Rpb24gdmFsdWVzIGluc2lkZSBmdW5jdGlvbiBydWxlcyBhcmUgbm90IHN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgIHZhciBmblZhbHVlcyA9IHN0eWxlUnVsZVtmblZhbHVlc05zXTsgLy8gSWYgd2UgaGF2ZSBhIGZuIHZhbHVlcyBtYXAsIGl0IGlzIGEgcnVsZSB3aXRoIGZ1bmN0aW9uIHZhbHVlcy5cblxuICAgICAgaWYgKGZuVmFsdWVzKSB7XG4gICAgICAgIGZvciAodmFyIF9wcm9wIGluIGZuVmFsdWVzKSB7XG4gICAgICAgICAgc3R5bGVSdWxlLnByb3AoX3Byb3AsIGZuVmFsdWVzW19wcm9wXShkYXRhKSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvblBsdWdpbjtcbiIsImltcG9ydCAkJG9ic2VydmFibGUgZnJvbSAnc3ltYm9sLW9ic2VydmFibGUnO1xuaW1wb3J0IHsgY3JlYXRlUnVsZSB9IGZyb20gJ2pzcyc7XG5cbnZhciBpc09ic2VydmFibGUgPSBmdW5jdGlvbiBpc09ic2VydmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlWyQkb2JzZXJ2YWJsZV0gJiYgdmFsdWUgPT09IHZhbHVlWyQkb2JzZXJ2YWJsZV0oKTtcbn07XG5cbnZhciBvYnNlcnZhYmxlUGx1Z2luID0gZnVuY3Rpb24gb2JzZXJ2YWJsZVBsdWdpbih1cGRhdGVPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgICAgaWYgKCFpc09ic2VydmFibGUoZGVjbCkpIHJldHVybiBudWxsOyAvLyBDYXN0IGBkZWNsYCB0byBgT2JzZXJ2YWJsZWAsIHNpbmNlIGl0IHBhc3NlZCB0aGUgdHlwZSBndWFyZC5cblxuICAgICAgdmFyIHN0eWxlJCA9IGRlY2w7XG4gICAgICB2YXIgcnVsZSA9IGNyZWF0ZVJ1bGUobmFtZSwge30sIG9wdGlvbnMpOyAvLyBUT0RPXG4gICAgICAvLyBDYWxsIGBzdHJlYW0uc3Vic2NyaWJlKClgIHJldHVybnMgYSBzdWJzY3JpcHRpb24sIHdoaWNoIHNob3VsZCBiZSBleHBsaWNpdGx5XG4gICAgICAvLyB1bnN1YnNjcmliZWQgZnJvbSB3aGVuIHdlIGtub3cgdGhpcyBzaGVldCBpcyBubyBsb25nZXIgbmVlZGVkLlxuXG4gICAgICBzdHlsZSQuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICAgICAgcnVsZS5wcm9wKHByb3AsIHN0eWxlW3Byb3BdLCB1cGRhdGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9LFxuICAgIG9uUHJvY2Vzc1J1bGU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICAgICAgaWYgKHJ1bGUgJiYgcnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm47XG4gICAgICB2YXIgc3R5bGVSdWxlID0gcnVsZTtcbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUnVsZS5zdHlsZTtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocHJvcCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcbiAgICAgICAgaWYgKCFpc09ic2VydmFibGUodmFsdWUpKSByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgICAgIHZhbHVlLnN1YnNjcmliZSh7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dChuZXh0VmFsdWUpIHtcbiAgICAgICAgICAgIHN0eWxlUnVsZS5wcm9wKHByb3AsIG5leHRWYWx1ZSwgdXBkYXRlT3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgICAgdmFyIF9yZXQgPSBfbG9vcChwcm9wKTtcblxuICAgICAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBvYnNlcnZhYmxlUGx1Z2luO1xuIiwiaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcblxudmFyIHNlbWlXaXRoTmwgPSAvO1xcbi87XG5cbi8qKlxuICogTmFpdmUgQ1NTIHBhcnNlci5cbiAqIC0gU3VwcG9ydHMgb25seSBydWxlIGJvZHkgKG5vIHNlbGVjdG9ycylcbiAqIC0gUmVxdWlyZXMgc2VtaWNvbG9uIGFuZCBuZXcgbGluZSBhZnRlciB0aGUgdmFsdWUgKGV4Y2VwdCBvZiBsYXN0IGxpbmUpXG4gKiAtIE5vIG5lc3RlZCBydWxlcyBzdXBwb3J0XG4gKi9cbnZhciBwYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNzc1RleHQpIHtcbiAgdmFyIHN0eWxlID0ge307XG4gIHZhciBzcGxpdCA9IGNzc1RleHQuc3BsaXQoc2VtaVdpdGhObCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZWNsID0gKHNwbGl0W2ldIHx8ICcnKS50cmltKCk7XG4gICAgaWYgKCFkZWNsKSBjb250aW51ZTtcbiAgICB2YXIgY29sb25JbmRleCA9IGRlY2wuaW5kZXhPZignOicpO1xuXG4gICAgaWYgKGNvbG9uSW5kZXggPT09IC0xKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIE1hbGZvcm1lZCBDU1Mgc3RyaW5nIFxcXCJcIiArIGRlY2wgKyBcIlxcXCJcIikgOiB2b2lkIDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcCA9IGRlY2wuc3Vic3RyKDAsIGNvbG9uSW5kZXgpLnRyaW0oKTtcbiAgICB2YXIgdmFsdWUgPSBkZWNsLnN1YnN0cihjb2xvbkluZGV4ICsgMSkudHJpbSgpO1xuICAgIHN0eWxlW3Byb3BdID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG52YXIgb25Qcm9jZXNzUnVsZSA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICBpZiAodHlwZW9mIHJ1bGUuc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIFdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoYXQgcnVsZSBoYXMgdGhlIHN0eWxlIHByb3BlcnR5XG4gICAgcnVsZS5zdHlsZSA9IHBhcnNlKHJ1bGUuc3R5bGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZVBsdWdpbigpIHtcbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NSdWxlOiBvblByb2Nlc3NSdWxlXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRlbXBsYXRlUGx1Z2luO1xuIiwiaW1wb3J0IHsgc3VwcG9ydGVkS2V5ZnJhbWVzLCBzdXBwb3J0ZWRWYWx1ZSwgc3VwcG9ydGVkUHJvcGVydHkgfSBmcm9tICdjc3MtdmVuZG9yJztcbmltcG9ydCB7IHRvQ3NzVmFsdWUgfSBmcm9tICdqc3MnO1xuXG4vKipcbiAqIEFkZCB2ZW5kb3IgcHJlZml4IHRvIGEgcHJvcGVydHkgbmFtZSB3aGVuIG5lZWRlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGpzc1ZlbmRvclByZWZpeGVyKCkge1xuICBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUpIHtcbiAgICBpZiAocnVsZS50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgdmFyIGF0UnVsZSA9IHJ1bGU7XG4gICAgICBhdFJ1bGUuYXQgPSBzdXBwb3J0ZWRLZXlmcmFtZXMoYXRSdWxlLmF0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVmaXhTdHlsZShzdHlsZSkge1xuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuXG4gICAgICBpZiAocHJvcCA9PT0gJ2ZhbGxiYWNrcycgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgc3R5bGVbcHJvcF0gPSB2YWx1ZS5tYXAocHJlZml4U3R5bGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoYW5nZVByb3AgPSBmYWxzZTtcbiAgICAgIHZhciBzdXBwb3J0ZWRQcm9wID0gc3VwcG9ydGVkUHJvcGVydHkocHJvcCk7XG4gICAgICBpZiAoc3VwcG9ydGVkUHJvcCAmJiBzdXBwb3J0ZWRQcm9wICE9PSBwcm9wKSBjaGFuZ2VQcm9wID0gdHJ1ZTtcbiAgICAgIHZhciBjaGFuZ2VWYWx1ZSA9IGZhbHNlO1xuICAgICAgdmFyIHN1cHBvcnRlZFZhbHVlJDEgPSBzdXBwb3J0ZWRWYWx1ZShzdXBwb3J0ZWRQcm9wLCB0b0Nzc1ZhbHVlKHZhbHVlKSk7XG4gICAgICBpZiAoc3VwcG9ydGVkVmFsdWUkMSAmJiBzdXBwb3J0ZWRWYWx1ZSQxICE9PSB2YWx1ZSkgY2hhbmdlVmFsdWUgPSB0cnVlO1xuXG4gICAgICBpZiAoY2hhbmdlUHJvcCB8fCBjaGFuZ2VWYWx1ZSkge1xuICAgICAgICBpZiAoY2hhbmdlUHJvcCkgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgICAgICBzdHlsZVtzdXBwb3J0ZWRQcm9wIHx8IHByb3BdID0gc3VwcG9ydGVkVmFsdWUkMSB8fCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcbiAgICByZXR1cm4gcHJlZml4U3R5bGUoc3R5bGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCkge1xuICAgIHJldHVybiBzdXBwb3J0ZWRWYWx1ZShwcm9wLCB0b0Nzc1ZhbHVlKHZhbHVlKSkgfHwgdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1J1bGU6IG9uUHJvY2Vzc1J1bGUsXG4gICAgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlLFxuICAgIG9uQ2hhbmdlVmFsdWU6IG9uQ2hhbmdlVmFsdWVcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQganNzVmVuZG9yUHJlZml4ZXI7XG4iLCJpbXBvcnQgZnVuY3Rpb25zIGZyb20gJ2pzcy1wbHVnaW4tcnVsZS12YWx1ZS1mdW5jdGlvbic7XG5pbXBvcnQgb2JzZXJ2YWJsZSBmcm9tICdqc3MtcGx1Z2luLXJ1bGUtdmFsdWUtb2JzZXJ2YWJsZSc7XG5pbXBvcnQgdGVtcGxhdGUgZnJvbSAnanNzLXBsdWdpbi10ZW1wbGF0ZSc7XG5pbXBvcnQgZ2xvYmFsIGZyb20gJ2pzcy1wbHVnaW4tZ2xvYmFsJztcbmltcG9ydCBleHRlbmQgZnJvbSAnanNzLXBsdWdpbi1leHRlbmQnO1xuaW1wb3J0IG5lc3RlZCBmcm9tICdqc3MtcGx1Z2luLW5lc3RlZCc7XG5pbXBvcnQgY29tcG9zZSBmcm9tICdqc3MtcGx1Z2luLWNvbXBvc2UnO1xuaW1wb3J0IGNhbWVsQ2FzZSBmcm9tICdqc3MtcGx1Z2luLWNhbWVsLWNhc2UnO1xuaW1wb3J0IGRlZmF1bHRVbml0IGZyb20gJ2pzcy1wbHVnaW4tZGVmYXVsdC11bml0JztcbmltcG9ydCBleHBhbmQgZnJvbSAnanNzLXBsdWdpbi1leHBhbmQnO1xuaW1wb3J0IHZlbmRvclByZWZpeGVyIGZyb20gJ2pzcy1wbHVnaW4tdmVuZG9yLXByZWZpeGVyJztcbmltcG9ydCBwcm9wc1NvcnQgZnJvbSAnanNzLXBsdWdpbi1wcm9wcy1zb3J0JztcblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBsdWdpbnM6IFtmdW5jdGlvbnMoKSwgb2JzZXJ2YWJsZShvcHRpb25zLm9ic2VydmFibGUpLCB0ZW1wbGF0ZSgpLCBnbG9iYWwoKSwgZXh0ZW5kKCksIG5lc3RlZCgpLCBjb21wb3NlKCksIGNhbWVsQ2FzZSgpLCBkZWZhdWx0VW5pdChvcHRpb25zLmRlZmF1bHRVbml0KSwgZXhwYW5kKCksIHZlbmRvclByZWZpeGVyKCksIHByb3BzU29ydCgpXVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlO1xuIiwiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IGlzSW5Ccm93c2VyIGZyb20gJ2lzLWluLWJyb3dzZXInO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MnO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkJztcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlJztcblxudmFyIHBsYWluT2JqZWN0Q29uc3RydXJjdG9yID0ge30uY29uc3RydWN0b3I7XG5mdW5jdGlvbiBjbG9uZVN0eWxlKHN0eWxlKSB7XG4gIGlmIChzdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBzdHlsZSAhPT0gJ29iamVjdCcpIHJldHVybiBzdHlsZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSByZXR1cm4gc3R5bGUubWFwKGNsb25lU3R5bGUpO1xuICBpZiAoc3R5bGUuY29uc3RydWN0b3IgIT09IHBsYWluT2JqZWN0Q29uc3RydXJjdG9yKSByZXR1cm4gc3R5bGU7XG4gIHZhciBuZXdTdHlsZSA9IHt9O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gc3R5bGUpIHtcbiAgICBuZXdTdHlsZVtuYW1lXSA9IGNsb25lU3R5bGUoc3R5bGVbbmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0eWxlO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJ1bGUgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICBuYW1lID0gJ3VubmFtZWQnO1xuICB9XG5cbiAgdmFyIGpzcyA9IG9wdGlvbnMuanNzO1xuICB2YXIgZGVjbENvcHkgPSBjbG9uZVN0eWxlKGRlY2wpO1xuICB2YXIgcnVsZSA9IGpzcy5wbHVnaW5zLm9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsQ29weSwgb3B0aW9ucyk7XG4gIGlmIChydWxlKSByZXR1cm4gcnVsZTsgLy8gSXQgaXMgYW4gYXQtcnVsZSBhbmQgaXQgaGFzIG5vIGluc3RhbmNlLlxuXG4gIGlmIChuYW1lWzBdID09PSAnQCcpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFVua25vd24gcnVsZSBcIiArIG5hbWUpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBqb2luID0gZnVuY3Rpb24gam9pbih2YWx1ZSwgYnkpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBSZW1vdmUgIWltcG9ydGFudCBmcm9tIHRoZSB2YWx1ZSwgaXQgd2lsbCBiZSByZWFkZGVkIGxhdGVyLlxuICAgIGlmICh2YWx1ZVtpXSA9PT0gJyFpbXBvcnRhbnQnKSBicmVhaztcbiAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gYnk7XG4gICAgcmVzdWx0ICs9IHZhbHVlW2ldO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYXJyYXkgdmFsdWVzIHRvIHN0cmluZy5cbiAqXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddXWAgPiBgbWFyZ2luOiA1cHggMTBweDtgXG4gKiBgYm9yZGVyOiBbJzFweCcsICcycHgnXWAgPiBgYm9yZGVyOiAxcHgsIDJweDtgXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddLCAnIWltcG9ydGFudCddYCA+IGBtYXJnaW46IDVweCAxMHB4ICFpbXBvcnRhbnQ7YFxuICogYGNvbG9yOiBbJ3JlZCcsICFpbXBvcnRhbnRdYCA+IGBjb2xvcjogcmVkICFpbXBvcnRhbnQ7YFxuICovXG52YXIgdG9Dc3NWYWx1ZSA9IGZ1bmN0aW9uIHRvQ3NzVmFsdWUodmFsdWUsIGlnbm9yZUltcG9ydGFudCkge1xuICBpZiAoaWdub3JlSW1wb3J0YW50ID09PSB2b2lkIDApIHtcbiAgICBpZ25vcmVJbXBvcnRhbnQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgdmFyIGNzc1ZhbHVlID0gJyc7IC8vIFN1cHBvcnQgc3BhY2Ugc2VwYXJhdGVkIHZhbHVlcyB2aWEgYFtbJzVweCcsICcxMHB4J11dYC5cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVbaV0gPT09ICchaW1wb3J0YW50JykgYnJlYWs7XG4gICAgICBpZiAoY3NzVmFsdWUpIGNzc1ZhbHVlICs9ICcsICc7XG4gICAgICBjc3NWYWx1ZSArPSBqb2luKHZhbHVlW2ldLCAnICcpO1xuICAgIH1cbiAgfSBlbHNlIGNzc1ZhbHVlID0gam9pbih2YWx1ZSwgJywgJyk7IC8vIEFkZCAhaW1wb3J0YW50LCBiZWNhdXNlIGl0IHdhcyBpZ25vcmVkLlxuXG5cbiAgaWYgKCFpZ25vcmVJbXBvcnRhbnQgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICchaW1wb3J0YW50Jykge1xuICAgIGNzc1ZhbHVlICs9ICcgIWltcG9ydGFudCc7XG4gIH1cblxuICByZXR1cm4gY3NzVmFsdWU7XG59O1xuXG4vKipcbiAqIEluZGVudCBhIHN0cmluZy5cbiAqIGh0dHA6Ly9qc3BlcmYuY29tL2FycmF5LWpvaW4tdnMtZm9yXG4gKi9cbmZ1bmN0aW9uIGluZGVudFN0cihzdHIsIGluZGVudCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGluZGVudDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCArPSAnICAnO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCArIHN0cjtcbn1cbi8qKlxuICogQ29udmVydHMgYSBSdWxlIHRvIENTUyBzdHJpbmcuXG4gKi9cblxuXG5mdW5jdGlvbiB0b0NzcyhzZWxlY3Rvciwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKCFzdHlsZSkgcmV0dXJuIHJlc3VsdDtcbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJGluZGVudCA9IF9vcHRpb25zLmluZGVudCxcbiAgICAgIGluZGVudCA9IF9vcHRpb25zJGluZGVudCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJGluZGVudDtcbiAgdmFyIGZhbGxiYWNrcyA9IHN0eWxlLmZhbGxiYWNrcztcbiAgaWYgKHNlbGVjdG9yKSBpbmRlbnQrKzsgLy8gQXBwbHkgZmFsbGJhY2tzIGZpcnN0LlxuXG4gIGlmIChmYWxsYmFja3MpIHtcbiAgICAvLyBBcnJheSBzeW50YXgge2ZhbGxiYWNrczogW3twcm9wOiB2YWx1ZX1dfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGZhbGxiYWNrcykpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBmYWxsYmFja3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBmYWxsYmFjayA9IGZhbGxiYWNrc1tpbmRleF07XG5cbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBmYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGZhbGxiYWNrW3Byb3BdO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgIHJlc3VsdCArPSBpbmRlbnRTdHIocHJvcCArIFwiOiBcIiArIHRvQ3NzVmFsdWUodmFsdWUpICsgXCI7XCIsIGluZGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9iamVjdCBzeW50YXgge2ZhbGxiYWNrczoge3Byb3A6IHZhbHVlfX1cbiAgICAgIGZvciAodmFyIF9wcm9wIGluIGZhbGxiYWNrcykge1xuICAgICAgICB2YXIgX3ZhbHVlID0gZmFsbGJhY2tzW19wcm9wXTtcblxuICAgICAgICBpZiAoX3ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgcmVzdWx0ICs9IGluZGVudFN0cihfcHJvcCArIFwiOiBcIiArIHRvQ3NzVmFsdWUoX3ZhbHVlKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3Byb3AyIGluIHN0eWxlKSB7XG4gICAgdmFyIF92YWx1ZTIgPSBzdHlsZVtfcHJvcDJdO1xuXG4gICAgaWYgKF92YWx1ZTIgIT0gbnVsbCAmJiBfcHJvcDIgIT09ICdmYWxsYmFja3MnKSB7XG4gICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gJ1xcbic7XG4gICAgICByZXN1bHQgKz0gaW5kZW50U3RyKF9wcm9wMiArIFwiOiBcIiArIHRvQ3NzVmFsdWUoX3ZhbHVlMikgKyBcIjtcIiwgaW5kZW50KTtcbiAgICB9XG4gIH0gLy8gQWxsb3cgZW1wdHkgc3R5bGUgaW4gdGhpcyBjYXNlLCBiZWNhdXNlIHByb3BlcnRpZXMgd2lsbCBiZSBhZGRlZCBkeW5hbWljYWxseS5cblxuXG4gIGlmICghcmVzdWx0ICYmICFvcHRpb25zLmFsbG93RW1wdHkpIHJldHVybiByZXN1bHQ7IC8vIFdoZW4gcnVsZSBpcyBiZWluZyBzdHJpbmdpZmllZCBiZWZvcmUgc2VsZWN0b3Igd2FzIGRlZmluZWQuXG5cbiAgaWYgKCFzZWxlY3RvcikgcmV0dXJuIHJlc3VsdDtcbiAgaW5kZW50LS07XG4gIGlmIChyZXN1bHQpIHJlc3VsdCA9IFwiXFxuXCIgKyByZXN1bHQgKyBcIlxcblwiO1xuICByZXR1cm4gaW5kZW50U3RyKHNlbGVjdG9yICsgXCIge1wiICsgcmVzdWx0LCBpbmRlbnQpICsgaW5kZW50U3RyKCd9JywgaW5kZW50KTtcbn1cblxudmFyIGVzY2FwZVJlZ2V4ID0gLyhbW1xcXS4jKiQ+PCt+PXxeOigpLFwiJ2BcXHNdKS9nO1xudmFyIG5hdGl2ZUVzY2FwZSA9IHR5cGVvZiBDU1MgIT09ICd1bmRlZmluZWQnICYmIENTUy5lc2NhcGU7XG52YXIgZXNjYXBlID0gKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIG5hdGl2ZUVzY2FwZSA/IG5hdGl2ZUVzY2FwZShzdHIpIDogc3RyLnJlcGxhY2UoZXNjYXBlUmVnZXgsICdcXFxcJDEnKTtcbn0pO1xuXG52YXIgQmFzZVN0eWxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VTdHlsZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdzdHlsZSc7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5yZW5kZXJlciA9IHZvaWQgMDtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHZhciBzaGVldCA9IG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIFJlbmRlcmVyID0gb3B0aW9ucy5SZW5kZXJlcjtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICBpZiAoc2hlZXQpIHRoaXMucmVuZGVyZXIgPSBzaGVldC5yZW5kZXJlcjtlbHNlIGlmIChSZW5kZXJlcikgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcigpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IGEgc3R5bGUgcHJvcGVydHkuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEJhc2VTdHlsZVJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5wcm9wID0gZnVuY3Rpb24gcHJvcChuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIC8vIEl0J3MgYSBnZXR0ZXIuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLnN0eWxlW25hbWVdOyAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLlxuXG4gICAgdmFyIGZvcmNlID0gb3B0aW9ucyA/IG9wdGlvbnMuZm9yY2UgOiBmYWxzZTtcbiAgICBpZiAoIWZvcmNlICYmIHRoaXMuc3R5bGVbbmFtZV0gPT09IHZhbHVlKSByZXR1cm4gdGhpcztcbiAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLnByb2Nlc3MgIT09IGZhbHNlKSB7XG4gICAgICBuZXdWYWx1ZSA9IHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vbkNoYW5nZVZhbHVlKHZhbHVlLCBuYW1lLCB0aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgaXNFbXB0eSA9IG5ld1ZhbHVlID09IG51bGwgfHwgbmV3VmFsdWUgPT09IGZhbHNlO1xuICAgIHZhciBpc0RlZmluZWQgPSBuYW1lIGluIHRoaXMuc3R5bGU7IC8vIFZhbHVlIGlzIGVtcHR5IGFuZCB3YXNuJ3QgZGVmaW5lZCBiZWZvcmUuXG5cbiAgICBpZiAoaXNFbXB0eSAmJiAhaXNEZWZpbmVkICYmICFmb3JjZSkgcmV0dXJuIHRoaXM7IC8vIFdlIGFyZSBnb2luZyB0byByZW1vdmUgdGhpcyB2YWx1ZS5cblxuICAgIHZhciByZW1vdmUgPSBpc0VtcHR5ICYmIGlzRGVmaW5lZDtcbiAgICBpZiAocmVtb3ZlKSBkZWxldGUgdGhpcy5zdHlsZVtuYW1lXTtlbHNlIHRoaXMuc3R5bGVbbmFtZV0gPSBuZXdWYWx1ZTsgLy8gUmVuZGVyYWJsZSBpcyBkZWZpbmVkIGlmIFN0eWxlU2hlZXQgb3B0aW9uIGBsaW5rYCBpcyB0cnVlLlxuXG4gICAgaWYgKHRoaXMucmVuZGVyYWJsZSAmJiB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICBpZiAocmVtb3ZlKSB0aGlzLnJlbmRlcmVyLnJlbW92ZVByb3BlcnR5KHRoaXMucmVuZGVyYWJsZSwgbmFtZSk7ZWxzZSB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMucmVuZGVyYWJsZSwgbmFtZSwgbmV3VmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuXG4gICAgaWYgKHNoZWV0ICYmIHNoZWV0LmF0dGFjaGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnW0pTU10gUnVsZSBpcyBub3QgbGlua2VkLiBNaXNzaW5nIHNoZWV0IG9wdGlvbiBcImxpbms6IHRydWVcIi4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQmFzZVN0eWxlUnVsZTtcbn0oKTtcbnZhciBTdHlsZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlU3R5bGVSdWxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN0eWxlUnVsZSwgX0Jhc2VTdHlsZVJ1bGUpO1xuXG4gIGZ1bmN0aW9uIFN0eWxlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZVN0eWxlUnVsZS5jYWxsKHRoaXMsIGtleSwgc3R5bGUsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc2VsZWN0b3JUZXh0ID0gdm9pZCAwO1xuICAgIF90aGlzLmlkID0gdm9pZCAwO1xuICAgIF90aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdmFyIHNlbGVjdG9yID0gb3B0aW9ucy5zZWxlY3RvcixcbiAgICAgICAgc2NvcGVkID0gb3B0aW9ucy5zY29wZWQsXG4gICAgICAgIHNoZWV0ID0gb3B0aW9ucy5zaGVldCxcbiAgICAgICAgZ2VuZXJhdGVJZCA9IG9wdGlvbnMuZ2VuZXJhdGVJZDtcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgX3RoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgfSBlbHNlIGlmIChzY29wZWQgIT09IGZhbHNlKSB7XG4gICAgICBfdGhpcy5pZCA9IGdlbmVyYXRlSWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIHNoZWV0KTtcbiAgICAgIF90aGlzLnNlbGVjdG9yVGV4dCA9IFwiLlwiICsgZXNjYXBlKF90aGlzLmlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBzZWxlY3RvciBzdHJpbmcuXG4gICAqIEF0dGVudGlvbjogdXNlIHRoaXMgd2l0aCBjYXV0aW9uLiBNb3N0IGJyb3dzZXJzIGRpZG4ndCBpbXBsZW1lbnRcbiAgICogc2VsZWN0b3JUZXh0IHNldHRlciwgc28gdGhpcyBtYXkgcmVzdWx0IGluIHJlcmVuZGVyaW5nIG9mIGVudGlyZSBTdHlsZSBTaGVldC5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvMiA9IFN0eWxlUnVsZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEFwcGx5IHJ1bGUgdG8gYW4gZWxlbWVudCBpbmxpbmUuXG4gICAqL1xuICBfcHJvdG8yLmFwcGx5VG8gPSBmdW5jdGlvbiBhcHBseVRvKHJlbmRlcmFibGUpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuXG4gICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICB2YXIganNvbiA9IHRoaXMudG9KU09OKCk7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4ganNvbikge1xuICAgICAgICByZW5kZXJlci5zZXRQcm9wZXJ0eShyZW5kZXJhYmxlLCBwcm9wLCBqc29uW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBydWxlLlxuICAgKiBGYWxsYmFja3MgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAqIFVzZWZ1bCBmb3IgaW5saW5lIHN0eWxlcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICB2YXIganNvbiA9IHt9O1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnN0eWxlW3Byb3BdO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIGpzb25bcHJvcF0gPSB2YWx1ZTtlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkganNvbltwcm9wXSA9IHRvQ3NzVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBqc29uO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcbiAgICB2YXIgb3B0cyA9IGxpbmsgPyBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYWxsb3dFbXB0eTogdHJ1ZVxuICAgIH0pIDogb3B0aW9ucztcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5zZWxlY3RvclRleHQsIHRoaXMuc3R5bGUsIG9wdHMpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTdHlsZVJ1bGUsIFt7XG4gICAga2V5OiBcInNlbGVjdG9yXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3RvciA9PT0gdGhpcy5zZWxlY3RvclRleHQpIHJldHVybjtcbiAgICAgIHRoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgIHJlbmRlcmFibGUgPSB0aGlzLnJlbmRlcmFibGU7XG4gICAgICBpZiAoIXJlbmRlcmFibGUgfHwgIXJlbmRlcmVyKSByZXR1cm47XG4gICAgICB2YXIgaGFzQ2hhbmdlZCA9IHJlbmRlcmVyLnNldFNlbGVjdG9yKHJlbmRlcmFibGUsIHNlbGVjdG9yKTsgLy8gSWYgc2VsZWN0b3Igc2V0dGVyIGlzIG5vdCBpbXBsZW1lbnRlZCwgcmVyZW5kZXIgdGhlIHJ1bGUuXG5cbiAgICAgIGlmICghaGFzQ2hhbmdlZCkge1xuICAgICAgICByZW5kZXJlci5yZXBsYWNlUnVsZShyZW5kZXJhYmxlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNlbGVjdG9yIHN0cmluZy5cbiAgICAgKi9cbiAgICAsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RvclRleHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0eWxlUnVsZTtcbn0oQmFzZVN0eWxlUnVsZSk7XG52YXIgcGx1Z2luU3R5bGVSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChuYW1lWzBdID09PSAnQCcgfHwgb3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5wYXJlbnQudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3R5bGVSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGRlZmF1bHRUb1N0cmluZ09wdGlvbnMgPSB7XG4gIGluZGVudDogMSxcbiAgY2hpbGRyZW46IHRydWVcbn07XG52YXIgYXRSZWdFeHAgPSAvQChbXFx3LV0rKS87XG4vKipcbiAqIENvbmRpdGlvbmFsIHJ1bGUgZm9yIEBtZWRpYSwgQHN1cHBvcnRzXG4gKi9cblxudmFyIENvbmRpdGlvbmFsUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbmRpdGlvbmFsUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdjb25kaXRpb25hbCc7XG4gICAgdGhpcy5hdCA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnF1ZXJ5ID0gdm9pZCAwO1xuICAgIHRoaXMucnVsZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdmFyIGF0TWF0Y2ggPSBrZXkubWF0Y2goYXRSZWdFeHApO1xuICAgIHRoaXMuYXQgPSBhdE1hdGNoID8gYXRNYXRjaFsxXSA6ICd1bmtub3duJzsgLy8gS2V5IG1pZ2h0IGNvbnRhaW4gYSB1bmlxdWUgc3VmZml4IGluIGNhc2UgdGhlIGBuYW1lYCBwYXNzZWQgYnkgdXNlciB3YXMgZHVwbGljYXRlLlxuXG4gICAgdGhpcy5xdWVyeSA9IG9wdGlvbnMubmFtZSB8fCBcIkBcIiArIHRoaXMuYXQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGVzW25hbWVdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gQ29uZGl0aW9uYWxSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0UnVsZSA9IGZ1bmN0aW9uIGdldFJ1bGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YocnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgcmVnaXN0ZXIgcnVsZSwgcnVuIHBsdWdpbnMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGUgPSBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5kZW50ID09IG51bGwpIG9wdGlvbnMuaW5kZW50ID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucy5pbmRlbnQ7XG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT0gbnVsbCkgb3B0aW9ucy5jaGlsZHJlbiA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMuY2hpbGRyZW47XG5cbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5ICsgXCIge31cIjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIHJldHVybiBjaGlsZHJlbiA/IHRoaXMucXVlcnkgKyBcIiB7XFxuXCIgKyBjaGlsZHJlbiArIFwiXFxufVwiIDogJyc7XG4gIH07XG5cbiAgcmV0dXJuIENvbmRpdGlvbmFsUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAgPSAvQG1lZGlhfEBzdXBwb3J0c1xccysvO1xudmFyIHBsdWdpbkNvbmRpdGlvbmFsUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5UmVnRXhwLnRlc3Qoa2V5KSA/IG5ldyBDb25kaXRpb25hbFJ1bGUoa2V5LCBzdHlsZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgfVxufTtcblxudmFyIGRlZmF1bHRUb1N0cmluZ09wdGlvbnMkMSA9IHtcbiAgaW5kZW50OiAxLFxuICBjaGlsZHJlbjogdHJ1ZVxufTtcbnZhciBuYW1lUmVnRXhwID0gL0BrZXlmcmFtZXNcXHMrKFtcXHctXSspLztcbi8qKlxuICogUnVsZSBmb3IgQGtleWZyYW1lc1xuICovXG5cbnZhciBLZXlmcmFtZXNSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gS2V5ZnJhbWVzUnVsZShrZXksIGZyYW1lcywgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdrZXlmcmFtZXMnO1xuICAgIHRoaXMuYXQgPSAnQGtleWZyYW1lcyc7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5ydWxlcyA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB2YXIgbmFtZU1hdGNoID0ga2V5Lm1hdGNoKG5hbWVSZWdFeHApO1xuXG4gICAgaWYgKG5hbWVNYXRjaCAmJiBuYW1lTWF0Y2hbMV0pIHtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWVNYXRjaFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uYW1lID0gJ25vbmFtZSc7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIEJhZCBrZXlmcmFtZXMgbmFtZSBcIiArIGtleSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdGhpcy5rZXkgPSB0aGlzLnR5cGUgKyBcIi1cIiArIHRoaXMubmFtZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzY29wZWQgPSBvcHRpb25zLnNjb3BlZCxcbiAgICAgICAgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBnZW5lcmF0ZUlkID0gb3B0aW9ucy5nZW5lcmF0ZUlkO1xuICAgIHRoaXMuaWQgPSBzY29wZWQgPT09IGZhbHNlID8gdGhpcy5uYW1lIDogZXNjYXBlKGdlbmVyYXRlSWQodGhpcywgc2hlZXQpKTtcbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGZyYW1lcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgZnJhbWVzW25hbWVdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gS2V5ZnJhbWVzUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDE7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5kZW50ID09IG51bGwpIG9wdGlvbnMuaW5kZW50ID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxLmluZGVudDtcbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PSBudWxsKSBvcHRpb25zLmNoaWxkcmVuID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxLmNoaWxkcmVuO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdCArIFwiIFwiICsgdGhpcy5pZCArIFwiIHt9XCI7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgICBpZiAoY2hpbGRyZW4pIGNoaWxkcmVuID0gXCJcXG5cIiArIGNoaWxkcmVuICsgXCJcXG5cIjtcbiAgICByZXR1cm4gdGhpcy5hdCArIFwiIFwiICsgdGhpcy5pZCArIFwiIHtcIiArIGNoaWxkcmVuICsgXCJ9XCI7XG4gIH07XG5cbiAgcmV0dXJuIEtleWZyYW1lc1J1bGU7XG59KCk7XG52YXIga2V5UmVnRXhwJDEgPSAvQGtleWZyYW1lc1xccysvO1xudmFyIHJlZlJlZ0V4cCA9IC9cXCQoW1xcdy1dKykvZztcblxudmFyIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUgPSBmdW5jdGlvbiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwga2V5ZnJhbWVzKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWwucmVwbGFjZShyZWZSZWdFeHAsIGZ1bmN0aW9uIChtYXRjaCwgbmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4ga2V5ZnJhbWVzKSB7XG4gICAgICAgIHJldHVybiBrZXlmcmFtZXNbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gUmVmZXJlbmNlZCBrZXlmcmFtZXMgcnVsZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkLlwiKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuLyoqXG4gKiBSZXBsYWNlIHRoZSByZWZlcmVuY2UgZm9yIGEgYW5pbWF0aW9uIG5hbWUuXG4gKi9cblxuXG52YXIgcmVwbGFjZVJlZiA9IGZ1bmN0aW9uIHJlcGxhY2VSZWYoc3R5bGUsIHByb3AsIGtleWZyYW1lcykge1xuICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcbiAgdmFyIHJlZktleWZyYW1lID0gZmluZFJlZmVyZW5jZWRLZXlmcmFtZSh2YWx1ZSwga2V5ZnJhbWVzKTtcblxuICBpZiAocmVmS2V5ZnJhbWUgIT09IHZhbHVlKSB7XG4gICAgc3R5bGVbcHJvcF0gPSByZWZLZXlmcmFtZTtcbiAgfVxufTtcblxudmFyIHBsdWdpbiA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5UmVnRXhwJDEudGVzdChrZXkpID8gbmV3IEtleWZyYW1lc1J1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgfSxcbiAgLy8gQW5pbWF0aW9uIG5hbWUgcmVmIHJlcGxhY2VyLlxuICBvblByb2Nlc3NTdHlsZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJyB8fCAhc2hlZXQpIHJldHVybiBzdHlsZTtcbiAgICBpZiAoJ2FuaW1hdGlvbi1uYW1lJyBpbiBzdHlsZSkgcmVwbGFjZVJlZihzdHlsZSwgJ2FuaW1hdGlvbi1uYW1lJywgc2hlZXQua2V5ZnJhbWVzKTtcbiAgICBpZiAoJ2FuaW1hdGlvbicgaW4gc3R5bGUpIHJlcGxhY2VSZWYoc3R5bGUsICdhbmltYXRpb24nLCBzaGVldC5rZXlmcmFtZXMpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgb25DaGFuZ2VWYWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWwsIHByb3AsIHJ1bGUpIHtcbiAgICB2YXIgc2hlZXQgPSBydWxlLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBpZiAoIXNoZWV0KSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgcmV0dXJuIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBzaGVldC5rZXlmcmFtZXMpO1xuXG4gICAgICBjYXNlICdhbmltYXRpb24tbmFtZSc6XG4gICAgICAgIHJldHVybiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwgc2hlZXQua2V5ZnJhbWVzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBLZXlmcmFtZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlU3R5bGVSdWxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKEtleWZyYW1lUnVsZSwgX0Jhc2VTdHlsZVJ1bGUpO1xuXG4gIGZ1bmN0aW9uIEtleWZyYW1lUnVsZSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQmFzZVN0eWxlUnVsZS5jYWxsLmFwcGx5KF9CYXNlU3R5bGVSdWxlLCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEtleWZyYW1lUnVsZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcbiAgICB2YXIgb3B0cyA9IGxpbmsgPyBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYWxsb3dFbXB0eTogdHJ1ZVxuICAgIH0pIDogb3B0aW9ucztcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5rZXksIHRoaXMuc3R5bGUsIG9wdHMpO1xuICB9O1xuXG4gIHJldHVybiBLZXlmcmFtZVJ1bGU7XG59KEJhc2VTdHlsZVJ1bGUpO1xudmFyIHBsdWdpbktleWZyYW1lUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgcmV0dXJuIG5ldyBLZXlmcmFtZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbnZhciBGb250RmFjZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb250RmFjZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdmb250LWZhY2UnO1xuICAgIHRoaXMuYXQgPSAnQGZvbnQtZmFjZSc7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gRm9udEZhY2VSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zdHlsZSkpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0ciArPSB0b0Nzcyh0aGlzLmF0LCB0aGlzLnN0eWxlW2luZGV4XSk7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlW2luZGV4ICsgMV0pIHN0ciArPSAnXFxuJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9Dc3ModGhpcy5hdCwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIEZvbnRGYWNlUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAkMiA9IC9AZm9udC1mYWNlLztcbnZhciBwbHVnaW5Gb250RmFjZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5UmVnRXhwJDIudGVzdChrZXkpID8gbmV3IEZvbnRGYWNlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBWaWV3cG9ydFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICd2aWV3cG9ydCc7XG4gICAgdGhpcy5hdCA9ICdAdmlld3BvcnQnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFZpZXdwb3J0UnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0b0Nzcyh0aGlzLmtleSwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFZpZXdwb3J0UnVsZTtcbn0oKTtcbnZhciBwbHVnaW5WaWV3cG9ydFJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5ID09PSAnQHZpZXdwb3J0JyB8fCBrZXkgPT09ICdALW1zLXZpZXdwb3J0JyA/IG5ldyBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgU2ltcGxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNpbXBsZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdzaW1wbGUnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuXG4gIHZhciBfcHJvdG8gPSBTaW1wbGVSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMudmFsdWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0ciArPSB0aGlzLmtleSArIFwiIFwiICsgdGhpcy52YWx1ZVtpbmRleF0gKyBcIjtcIjtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVbaW5kZXggKyAxXSkgc3RyICs9ICdcXG4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmtleSArIFwiIFwiICsgdGhpcy52YWx1ZSArIFwiO1wiO1xuICB9O1xuXG4gIHJldHVybiBTaW1wbGVSdWxlO1xufSgpO1xudmFyIGtleXNNYXAgPSB7XG4gICdAY2hhcnNldCc6IHRydWUsXG4gICdAaW1wb3J0JzogdHJ1ZSxcbiAgJ0BuYW1lc3BhY2UnOiB0cnVlXG59O1xudmFyIHBsdWdpblNpbXBsZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5IGluIGtleXNNYXAgPyBuZXcgU2ltcGxlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBwbHVnaW5zID0gW3BsdWdpblN0eWxlUnVsZSwgcGx1Z2luQ29uZGl0aW9uYWxSdWxlLCBwbHVnaW4sIHBsdWdpbktleWZyYW1lUnVsZSwgcGx1Z2luRm9udEZhY2VSdWxlLCBwbHVnaW5WaWV3cG9ydFJ1bGUsIHBsdWdpblNpbXBsZVJ1bGVdO1xuXG52YXIgZGVmYXVsdFVwZGF0ZU9wdGlvbnMgPSB7XG4gIHByb2Nlc3M6IHRydWVcbn07XG52YXIgZm9yY2VVcGRhdGVPcHRpb25zID0ge1xuICBmb3JjZTogdHJ1ZSxcbiAgcHJvY2VzczogdHJ1ZVxuICAvKipcbiAgICogQ29udGFpbnMgcnVsZXMgb2JqZWN0cyBhbmQgYWxsb3dzIGFkZGluZy9yZW1vdmluZyBldGMuXG4gICAqIElzIHVzZWQgZm9yIGUuZy4gYnkgYFN0eWxlU2hlZXRgIG9yIGBDb25kaXRpb25hbFJ1bGVgLlxuICAgKi9cblxufTtcblxudmFyIFJ1bGVMaXN0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gUnVsZXMgcmVnaXN0cnkgZm9yIGFjY2VzcyBieSAuZ2V0KCkgbWV0aG9kLlxuICAvLyBJdCBjb250YWlucyB0aGUgc2FtZSBydWxlIHJlZ2lzdGVyZWQgYnkgbmFtZSBhbmQgYnkgc2VsZWN0b3IuXG4gIC8vIE9yaWdpbmFsIHN0eWxlcyBvYmplY3QuXG4gIC8vIFVzZWQgdG8gZW5zdXJlIGNvcnJlY3QgcnVsZXMgb3JkZXIuXG4gIGZ1bmN0aW9uIFJ1bGVMaXN0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMucmF3ID0ge307XG4gICAgdGhpcy5pbmRleCA9IFtdO1xuICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleWZyYW1lcyA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY2xhc3NlcyA9IG9wdGlvbnMuY2xhc3NlcztcbiAgICB0aGlzLmtleWZyYW1lcyA9IG9wdGlvbnMua2V5ZnJhbWVzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUuXG4gICAqXG4gICAqIFdpbGwgbm90IHJlbmRlciBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFJ1bGVMaXN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKG5hbWUsIGRlY2wsIHJ1bGVPcHRpb25zKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHBhcmVudCA9IF90aGlzJG9wdGlvbnMucGFyZW50LFxuICAgICAgICBzaGVldCA9IF90aGlzJG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGpzcyA9IF90aGlzJG9wdGlvbnMuanNzLFxuICAgICAgICBSZW5kZXJlciA9IF90aGlzJG9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBfdGhpcyRvcHRpb25zLmdlbmVyYXRlSWQsXG4gICAgICAgIHNjb3BlZCA9IF90aGlzJG9wdGlvbnMuc2NvcGVkO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHNoZWV0OiBzaGVldCxcbiAgICAgIGpzczoganNzLFxuICAgICAgUmVuZGVyZXI6IFJlbmRlcmVyLFxuICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZCxcbiAgICAgIHNjb3BlZDogc2NvcGVkLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGtleWZyYW1lczogdGhpcy5rZXlmcmFtZXMsXG4gICAgICBzZWxlY3RvcjogdW5kZWZpbmVkXG4gICAgfSwgcnVsZU9wdGlvbnMpOyAvLyBXaGVuIHVzZXIgdXNlcyAuY3JlYXRlU3R5bGVTaGVldCgpLCBkdXBsaWNhdGUgbmFtZXMgYXJlIG5vdCBwb3NzaWJsZSwgYnV0XG4gICAgLy8gYHNoZWV0LmFkZFJ1bGUoKWAgb3BlbnMgdGhlIGRvb3IgZm9yIGFueSBkdXBsaWNhdGUgcnVsZSBuYW1lLiBXaGVuIHRoaXMgaGFwcGVuc1xuICAgIC8vIHdlIG5lZWQgdG8gbWFrZSB0aGUga2V5IHVuaXF1ZSB3aXRoaW4gdGhpcyBSdWxlTGlzdCBpbnN0YW5jZSBzY29wZS5cblxuXG4gICAgdmFyIGtleSA9IG5hbWU7XG5cbiAgICBpZiAobmFtZSBpbiB0aGlzLnJhdykge1xuICAgICAga2V5ID0gbmFtZSArIFwiLWRcIiArIHRoaXMuY291bnRlcisrO1xuICAgIH0gLy8gV2UgbmVlZCB0byBzYXZlIHRoZSBvcmlnaW5hbCBkZWNsIGJlZm9yZSBjcmVhdGluZyB0aGUgcnVsZVxuICAgIC8vIGJlY2F1c2UgY2FjaGUgcGx1Z2luIG5lZWRzIHRvIHVzZSBpdCBhcyBhIGtleSB0byByZXR1cm4gYSBjYWNoZWQgcnVsZS5cblxuXG4gICAgdGhpcy5yYXdba2V5XSA9IGRlY2w7XG5cbiAgICBpZiAoa2V5IGluIHRoaXMuY2xhc3Nlcykge1xuICAgICAgLy8gRS5nLiBydWxlcyBpbnNpZGUgb2YgQG1lZGlhIGNvbnRhaW5lclxuICAgICAgb3B0aW9ucy5zZWxlY3RvciA9IFwiLlwiICsgZXNjYXBlKHRoaXMuY2xhc3Nlc1trZXldKTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZSA9IGNyZWF0ZVJ1bGUoa2V5LCBkZWNsLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBudWxsO1xuICAgIHRoaXMucmVnaXN0ZXIocnVsZSk7XG4gICAgdmFyIGluZGV4ID0gb3B0aW9ucy5pbmRleCA9PT0gdW5kZWZpbmVkID8gdGhpcy5pbmRleC5sZW5ndGggOiBvcHRpb25zLmluZGV4O1xuICAgIHRoaXMuaW5kZXguc3BsaWNlKGluZGV4LCAwLCBydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBbbmFtZV07XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShydWxlKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyKHJ1bGUpO1xuICAgIGRlbGV0ZSB0aGlzLnJhd1tydWxlLmtleV07XG4gICAgdGhpcy5pbmRleC5zcGxpY2UodGhpcy5pbmRleC5pbmRleE9mKHJ1bGUpLCAxKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgIHJldHVybiB0aGlzLmluZGV4LmluZGV4T2YocnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJ1biBgb25Qcm9jZXNzUnVsZSgpYCBwbHVnaW5zIG9uIGV2ZXJ5IHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgIHZhciBwbHVnaW5zID0gdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zOyAvLyBXZSBuZWVkIHRvIGNsb25lIGFycmF5IGJlY2F1c2UgaWYgd2UgbW9kaWZ5IHRoZSBpbmRleCBzb21ld2hlcmUgZWxzZSBkdXJpbmcgYSBsb29wXG4gICAgLy8gd2UgZW5kIHVwIHdpdGggdmVyeSBoYXJkLXRvLXRyYWNrLWRvd24gc2lkZSBlZmZlY3RzLlxuXG4gICAgdGhpcy5pbmRleC5zbGljZSgwKS5mb3JFYWNoKHBsdWdpbnMub25Qcm9jZXNzUnVsZSwgcGx1Z2lucyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgcnVsZSBpbiBgLm1hcGAsIGAuY2xhc3Nlc2AgYW5kIGAua2V5ZnJhbWVzYCBtYXBzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKHJ1bGUpIHtcbiAgICB0aGlzLm1hcFtydWxlLmtleV0gPSBydWxlO1xuXG4gICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBTdHlsZVJ1bGUpIHtcbiAgICAgIHRoaXMubWFwW3J1bGUuc2VsZWN0b3JdID0gcnVsZTtcbiAgICAgIGlmIChydWxlLmlkKSB0aGlzLmNsYXNzZXNbcnVsZS5rZXldID0gcnVsZS5pZDtcbiAgICB9IGVsc2UgaWYgKHJ1bGUgaW5zdGFuY2VvZiBLZXlmcmFtZXNSdWxlICYmIHRoaXMua2V5ZnJhbWVzKSB7XG4gICAgICB0aGlzLmtleWZyYW1lc1tydWxlLm5hbWVdID0gcnVsZS5pZDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51bnJlZ2lzdGVyID0gZnVuY3Rpb24gdW5yZWdpc3RlcihydWxlKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW3J1bGUua2V5XTtcblxuICAgIGlmIChydWxlIGluc3RhbmNlb2YgU3R5bGVSdWxlKSB7XG4gICAgICBkZWxldGUgdGhpcy5tYXBbcnVsZS5zZWxlY3Rvcl07XG4gICAgICBkZWxldGUgdGhpcy5jbGFzc2VzW3J1bGUua2V5XTtcbiAgICB9IGVsc2UgaWYgKHJ1bGUgaW5zdGFuY2VvZiBLZXlmcmFtZXNSdWxlKSB7XG4gICAgICBkZWxldGUgdGhpcy5rZXlmcmFtZXNbcnVsZS5uYW1lXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZnVuY3Rpb24gdmFsdWVzIHdpdGggYSBuZXcgZGF0YS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBuYW1lO1xuICAgIHZhciBkYXRhO1xuICAgIHZhciBvcHRpb25zO1xuXG4gICAgaWYgKHR5cGVvZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07IC8vICRGbG93Rml4TWVbaW52YWxpZC10dXBsZS1pbmRleF1cblxuICAgICAgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXTsgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLXR1cGxlLWluZGV4XVxuXG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdOyAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtdHVwbGUtaW5kZXhdXG5cbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07XG4gICAgICBuYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgdGhpcy51cGRhdGVPbmUodGhpcy5tYXBbbmFtZV0sIGRhdGEsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbmRleC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdGhpcy51cGRhdGVPbmUodGhpcy5pbmRleFtpbmRleF0sIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZSBwbHVnaW5zLCB1cGRhdGUgcnVsZSBwcm9wcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlT25lID0gZnVuY3Rpb24gdXBkYXRlT25lKHJ1bGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdFVwZGF0ZU9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJG9wdGlvbnMyID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBwbHVnaW5zID0gX3RoaXMkb3B0aW9uczIuanNzLnBsdWdpbnMsXG4gICAgICAgIHNoZWV0ID0gX3RoaXMkb3B0aW9uczIuc2hlZXQ7IC8vIEl0IGlzIGEgcnVsZXMgY29udGFpbmVyIGxpa2UgZm9yIGUuZy4gQ29uZGl0aW9uYWxSdWxlLlxuXG4gICAgaWYgKHJ1bGUucnVsZXMgaW5zdGFuY2VvZiBSdWxlTGlzdCkge1xuICAgICAgcnVsZS5ydWxlcy51cGRhdGUoZGF0YSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlUnVsZSA9IHJ1bGU7XG4gICAgdmFyIHN0eWxlID0gc3R5bGVSdWxlLnN0eWxlO1xuICAgIHBsdWdpbnMub25VcGRhdGUoZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpOyAvLyBXZSByZWx5IG9uIGEgbmV3IGBzdHlsZWAgcmVmIGluIGNhc2UgaXQgd2FzIG11dGF0ZWQgZHVyaW5nIG9uVXBkYXRlIGhvb2suXG5cbiAgICBpZiAob3B0aW9ucy5wcm9jZXNzICYmIHN0eWxlICYmIHN0eWxlICE9PSBzdHlsZVJ1bGUuc3R5bGUpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gcnVuIHRoZSBwbHVnaW5zIGluIGNhc2UgbmV3IGBzdHlsZWAgcmVsaWVzIG9uIHN5bnRheCBwbHVnaW5zLlxuICAgICAgcGx1Z2lucy5vblByb2Nlc3NTdHlsZShzdHlsZVJ1bGUuc3R5bGUsIHN0eWxlUnVsZSwgc2hlZXQpOyAvLyBVcGRhdGUgYW5kIGFkZCBwcm9wcy5cblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZVJ1bGUuc3R5bGUpIHtcbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9IHN0eWxlUnVsZS5zdHlsZVtwcm9wXTtcbiAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHN0eWxlW3Byb3BdOyAvLyBXZSBuZWVkIHRvIHVzZSBgZm9yY2U6IHRydWVgIGJlY2F1c2UgYHJ1bGUuc3R5bGVgIGhhcyBiZWVuIHVwZGF0ZWQgZHVyaW5nIG9uVXBkYXRlIGhvb2ssIHNvIGBydWxlLnByb3AoKWAgd2lsbCBub3QgdXBkYXRlIHRoZSBDU1NPTSBydWxlLlxuICAgICAgICAvLyBXZSBkbyB0aGlzIGNvbXBhcmlzb24gdG8gYXZvaWQgdW5uZWVkZWQgYHJ1bGUucHJvcCgpYCBjYWxscywgc2luY2Ugd2UgaGF2ZSB0aGUgb2xkIGBzdHlsZWAgb2JqZWN0IGhlcmUuXG5cbiAgICAgICAgaWYgKG5leHRWYWx1ZSAhPT0gcHJldlZhbHVlKSB7XG4gICAgICAgICAgc3R5bGVSdWxlLnByb3AocHJvcCwgbmV4dFZhbHVlLCBmb3JjZVVwZGF0ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlbW92ZSBwcm9wcy5cblxuXG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBzdHlsZSkge1xuICAgICAgICB2YXIgX25leHRWYWx1ZSA9IHN0eWxlUnVsZS5zdHlsZVtfcHJvcF07XG4gICAgICAgIHZhciBfcHJldlZhbHVlID0gc3R5bGVbX3Byb3BdOyAvLyBXZSBuZWVkIHRvIHVzZSBgZm9yY2U6IHRydWVgIGJlY2F1c2UgYHJ1bGUuc3R5bGVgIGhhcyBiZWVuIHVwZGF0ZWQgZHVyaW5nIG9uVXBkYXRlIGhvb2ssIHNvIGBydWxlLnByb3AoKWAgd2lsbCBub3QgdXBkYXRlIHRoZSBDU1NPTSBydWxlLlxuICAgICAgICAvLyBXZSBkbyB0aGlzIGNvbXBhcmlzb24gdG8gYXZvaWQgdW5uZWVkZWQgYHJ1bGUucHJvcCgpYCBjYWxscywgc2luY2Ugd2UgaGF2ZSB0aGUgb2xkIGBzdHlsZWAgb2JqZWN0IGhlcmUuXG5cbiAgICAgICAgaWYgKF9uZXh0VmFsdWUgPT0gbnVsbCAmJiBfbmV4dFZhbHVlICE9PSBfcHJldlZhbHVlKSB7XG4gICAgICAgICAgc3R5bGVSdWxlLnByb3AoX3Byb3AsIG51bGwsIGZvcmNlVXBkYXRlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgcnVsZXMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmluZGV4Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLmluZGV4W2luZGV4XTtcbiAgICAgIHZhciBjc3MgPSBydWxlLnRvU3RyaW5nKG9wdGlvbnMpOyAvLyBObyBuZWVkIHRvIHJlbmRlciBhbiBlbXB0eSBydWxlLlxuXG4gICAgICBpZiAoIWNzcyAmJiAhbGluaykgY29udGludWU7XG4gICAgICBpZiAoc3RyKSBzdHIgKz0gJ1xcbic7XG4gICAgICBzdHIgKz0gY3NzO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgcmV0dXJuIFJ1bGVMaXN0O1xufSgpO1xuXG52YXIgU3R5bGVTaGVldCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0eWxlU2hlZXQoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuZGVwbG95ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRhY2hlZCA9IHZvaWQgMDtcbiAgICB0aGlzLnJ1bGVzID0gdm9pZCAwO1xuICAgIHRoaXMucmVuZGVyZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGFzc2VzID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ZnJhbWVzID0gdm9pZCAwO1xuICAgIHRoaXMucXVldWUgPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVwbG95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsYXNzZXMgPSB7fTtcbiAgICB0aGlzLmtleWZyYW1lcyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBzaGVldDogdGhpcyxcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGNsYXNzZXM6IHRoaXMuY2xhc3NlcyxcbiAgICAgIGtleWZyYW1lczogdGhpcy5rZXlmcmFtZXNcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLlJlbmRlcmVyKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IG9wdGlvbnMuUmVuZGVyZXIodGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcyA9IG5ldyBSdWxlTGlzdCh0aGlzLm9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlc1tuYW1lXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaCByZW5kZXJhYmxlIHRvIHRoZSByZW5kZXIgdHJlZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gU3R5bGVTaGVldC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmF0dGFjaCA9IGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHRoaXMucmVuZGVyZXIuYXR0YWNoKCk7XG4gICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7IC8vIE9yZGVyIGlzIGltcG9ydGFudCwgYmVjYXVzZSB3ZSBjYW4ndCB1c2UgaW5zZXJ0UnVsZSBBUEkgaWYgc3R5bGUgZWxlbWVudCBpcyBub3QgYXR0YWNoZWQuXG5cbiAgICBpZiAoIXRoaXMuZGVwbG95ZWQpIHRoaXMuZGVwbG95KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSByZW5kZXJhYmxlIGZyb20gcmVuZGVyIHRyZWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICBpZiAoIXRoaXMuYXR0YWNoZWQpIHJldHVybiB0aGlzO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmRldGFjaCgpO1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkIGEgcnVsZSB0byB0aGUgY3VycmVudCBzdHlsZXNoZWV0LlxuICAgKiBXaWxsIGluc2VydCBhIHJ1bGUgYWxzbyBhZnRlciB0aGUgc3R5bGVzaGVldCBoYXMgYmVlbiByZW5kZXJlZCBmaXJzdCB0aW1lLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hZGRSdWxlID0gZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTsgLy8gUGx1Z2lucyBjYW4gY3JlYXRlIHJ1bGVzLlxuICAgIC8vIEluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSByaWdodCBvcmRlciwgd2UgbmVlZCB0byBxdWV1ZSBhbGwgYC5hZGRSdWxlYCBjYWxscyxcbiAgICAvLyB3aGljaCBoYXBwZW4gYWZ0ZXIgdGhlIGZpcnN0IGBydWxlcy5hZGQoKWAgY2FsbC5cblxuICAgIGlmICh0aGlzLmF0dGFjaGVkICYmICFxdWV1ZSkgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHZhciBydWxlID0gdGhpcy5ydWxlcy5hZGQobmFtZSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcblxuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICBpZiAoIXRoaXMuZGVwbG95ZWQpIHJldHVybiBydWxlOyAvLyBEb24ndCBpbnNlcnQgcnVsZSBkaXJlY3RseSBpZiB0aGVyZSBpcyBubyBzdHJpbmdpZmllZCB2ZXJzaW9uIHlldC5cbiAgICAgIC8vIEl0IHdpbGwgYmUgaW5zZXJ0ZWQgYWxsIHRvZ2V0aGVyIHdoZW4gLmF0dGFjaCBpcyBjYWxsZWQuXG5cbiAgICAgIGlmIChxdWV1ZSkgcXVldWUucHVzaChydWxlKTtlbHNlIHtcbiAgICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGUpO1xuXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlKSB7XG4gICAgICAgICAgdGhpcy5xdWV1ZS5mb3JFYWNoKHRoaXMuaW5zZXJ0UnVsZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5xdWV1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfSAvLyBXZSBjYW4ndCBhZGQgcnVsZXMgdG8gYSBkZXRhY2hlZCBzdHlsZSBub2RlLlxuICAgIC8vIFdlIHdpbGwgcmVkZXBsb3kgdGhlIHNoZWV0IG9uY2UgdXNlciB3aWxsIGF0dGFjaCBpdC5cblxuXG4gICAgdGhpcy5kZXBsb3llZCA9IGZhbHNlO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgcnVsZSBpbnRvIHRoZSBTdHlsZVNoZWV0XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlci5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCBhZGQgcnVsZXMuXG4gICAqIFdpbGwgcmVuZGVyIGFsc28gYWZ0ZXIgU3R5bGUgU2hlZXQgd2FzIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hZGRSdWxlcyA9IGZ1bmN0aW9uIGFkZFJ1bGVzKHN0eWxlcywgb3B0aW9ucykge1xuICAgIHZhciBhZGRlZCA9IFtdO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5hZGRSdWxlKG5hbWUsIHN0eWxlc1tuYW1lXSwgb3B0aW9ucyk7XG4gICAgICBpZiAocnVsZSkgYWRkZWQucHVzaChydWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUgYnkgbmFtZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0UnVsZSA9IGZ1bmN0aW9uIGdldFJ1bGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgcnVsZSBieSBuYW1lLlxuICAgKiBSZXR1cm5zIGB0cnVlYDogaWYgcnVsZSBoYXMgYmVlbiBkZWxldGVkIGZyb20gdGhlIERPTS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVsZXRlUnVsZSA9IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUobmFtZSkge1xuICAgIHZhciBydWxlID0gdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnID8gbmFtZSA6IHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuXG4gICAgaWYgKCFydWxlIHx8IC8vIFN0eWxlIHNoZWV0IHdhcyBjcmVhdGVkIHdpdGhvdXQgbGluazogdHJ1ZSBhbmQgYXR0YWNoZWQsIGluIHRoaXMgY2FzZSB3ZVxuICAgIC8vIHdvbid0IGJlIGFibGUgdG8gcmVtb3ZlIHRoZSBDU1MgcnVsZSBmcm9tIHRoZSBET00uXG4gICAgdGhpcy5hdHRhY2hlZCAmJiAhcnVsZS5yZW5kZXJhYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5yZW1vdmUocnVsZSk7XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiBydWxlLnJlbmRlcmFibGUgJiYgdGhpcy5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZGVsZXRlUnVsZShydWxlLnJlbmRlcmFibGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuaW5kZXhPZihydWxlKTtcbiAgfVxuICAvKipcbiAgICogRGVwbG95IHB1cmUgQ1NTIHN0cmluZyB0byBhIHJlbmRlcmFibGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlcGxveSA9IGZ1bmN0aW9uIGRlcGxveSgpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5kZXBsb3koKTtcbiAgICB0aGlzLmRlcGxveWVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBmdW5jdGlvbiB2YWx1ZXMgd2l0aCBhIG5ldyBkYXRhLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIF90aGlzJHJ1bGVzO1xuXG4gICAgKF90aGlzJHJ1bGVzID0gdGhpcy5ydWxlcykudXBkYXRlLmFwcGx5KF90aGlzJHJ1bGVzLCBhcmd1bWVudHMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBzaW5nbGUgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlT25lID0gZnVuY3Rpb24gdXBkYXRlT25lKHJ1bGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnJ1bGVzLnVwZGF0ZU9uZShydWxlLCBkYXRhLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBydWxlcyB0byBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBTdHlsZVNoZWV0O1xufSgpO1xuXG52YXIgUGx1Z2luc1JlZ2lzdHJ5ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGx1Z2luc1JlZ2lzdHJ5KCkge1xuICAgIHRoaXMucGx1Z2lucyA9IHtcbiAgICAgIGludGVybmFsOiBbXSxcbiAgICAgIGV4dGVybmFsOiBbXVxuICAgIH07XG4gICAgdGhpcy5yZWdpc3RyeSA9IHZvaWQgMDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQbHVnaW5zUmVnaXN0cnkucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBDYWxsIGBvbkNyZWF0ZVJ1bGVgIGhvb2tzIGFuZCByZXR1cm4gYW4gb2JqZWN0IGlmIHJldHVybmVkIGJ5IGEgaG9vay5cbiAgICovXG4gIF9wcm90by5vbkNyZWF0ZVJ1bGUgPSBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vbkNyZWF0ZVJ1bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5yZWdpc3RyeS5vbkNyZWF0ZVJ1bGVbaV0obmFtZSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgICBpZiAocnVsZSkgcmV0dXJuIHJ1bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1J1bGVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NSdWxlID0gZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgaWYgKHJ1bGUuaXNQcm9jZXNzZWQpIHJldHVybjtcbiAgICB2YXIgc2hlZXQgPSBydWxlLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzUnVsZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NSdWxlW2ldKHJ1bGUsIHNoZWV0KTtcbiAgICB9XG5cbiAgICBpZiAocnVsZS5zdHlsZSkgdGhpcy5vblByb2Nlc3NTdHlsZShydWxlLnN0eWxlLCBydWxlLCBzaGVldCk7XG4gICAgcnVsZS5pc1Byb2Nlc3NlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1N0eWxlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25Qcm9jZXNzU3R5bGUgPSBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSwgc2hlZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgcnVsZS5zdHlsZSA9IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU3R5bGVbaV0ocnVsZS5zdHlsZSwgcnVsZSwgc2hlZXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzU2hlZXRgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NTaGVldCA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1NoZWV0KHNoZWV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1NoZWV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1NoZWV0W2ldKHNoZWV0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uVXBkYXRlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25VcGRhdGUgPSBmdW5jdGlvbiBvblVwZGF0ZShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblVwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblVwZGF0ZVtpXShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvbkNoYW5nZVZhbHVlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25DaGFuZ2VWYWx1ZSA9IGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3AsIHJ1bGUpIHtcbiAgICB2YXIgcHJvY2Vzc2VkVmFsdWUgPSB2YWx1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vbkNoYW5nZVZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9jZXNzZWRWYWx1ZSA9IHRoaXMucmVnaXN0cnkub25DaGFuZ2VWYWx1ZVtpXShwcm9jZXNzZWRWYWx1ZSwgcHJvcCwgcnVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2Nlc3NlZFZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHBsdWdpbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXNlID0gZnVuY3Rpb24gdXNlKG5ld1BsdWdpbiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHF1ZXVlOiAnZXh0ZXJuYWwnXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwbHVnaW5zID0gdGhpcy5wbHVnaW5zW29wdGlvbnMucXVldWVdOyAvLyBBdm9pZHMgYXBwbHlpbmcgc2FtZSBwbHVnaW4gdHdpY2UsIGF0IGxlYXN0IGJhc2VkIG9uIHJlZi5cblxuICAgIGlmIChwbHVnaW5zLmluZGV4T2YobmV3UGx1Z2luKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwbHVnaW5zLnB1c2gobmV3UGx1Z2luKTtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gW10uY29uY2F0KHRoaXMucGx1Z2lucy5leHRlcm5hbCwgdGhpcy5wbHVnaW5zLmludGVybmFsKS5yZWR1Y2UoZnVuY3Rpb24gKHJlZ2lzdHJ5LCBwbHVnaW4pIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcGx1Z2luKSB7XG4gICAgICAgIGlmIChuYW1lIGluIHJlZ2lzdHJ5KSB7XG4gICAgICAgICAgcmVnaXN0cnlbbmFtZV0ucHVzaChwbHVnaW5bbmFtZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gVW5rbm93biBob29rIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdpc3RyeTtcbiAgICB9LCB7XG4gICAgICBvbkNyZWF0ZVJ1bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzUnVsZTogW10sXG4gICAgICBvblByb2Nlc3NTdHlsZTogW10sXG4gICAgICBvblByb2Nlc3NTaGVldDogW10sXG4gICAgICBvbkNoYW5nZVZhbHVlOiBbXSxcbiAgICAgIG9uVXBkYXRlOiBbXVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBQbHVnaW5zUmVnaXN0cnk7XG59KCk7XG5cbi8qKlxuICogU2hlZXRzIHJlZ2lzdHJ5IHRvIGFjY2VzcyB0aGVtIGFsbCBhdCBvbmUgcGxhY2UuXG4gKi9cbnZhciBTaGVldHNSZWdpc3RyeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNoZWV0c1JlZ2lzdHJ5KCkge1xuICAgIHRoaXMucmVnaXN0cnkgPSBbXTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTaGVldHNSZWdpc3RyeS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgU3R5bGUgU2hlZXQuXG4gICAqL1xuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHNoZWV0KSB7XG4gICAgdmFyIHJlZ2lzdHJ5ID0gdGhpcy5yZWdpc3RyeTtcbiAgICB2YXIgaW5kZXggPSBzaGVldC5vcHRpb25zLmluZGV4O1xuICAgIGlmIChyZWdpc3RyeS5pbmRleE9mKHNoZWV0KSAhPT0gLTEpIHJldHVybjtcblxuICAgIGlmIChyZWdpc3RyeS5sZW5ndGggPT09IDAgfHwgaW5kZXggPj0gdGhpcy5pbmRleCkge1xuICAgICAgcmVnaXN0cnkucHVzaChzaGVldCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGaW5kIGEgcG9zaXRpb24uXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWdpc3RyeVtpXS5vcHRpb25zLmluZGV4ID4gaW5kZXgpIHtcbiAgICAgICAgcmVnaXN0cnkuc3BsaWNlKGksIDAsIHNoZWV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzZXQgdGhlIHJlZ2lzdHJ5LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMucmVnaXN0cnkgPSBbXTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgU3R5bGUgU2hlZXQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShzaGVldCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMucmVnaXN0cnkuaW5kZXhPZihzaGVldCk7XG4gICAgdGhpcy5yZWdpc3RyeS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IGFsbCBhdHRhY2hlZCBzaGVldHMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKF90ZW1wKSB7XG4gICAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgICAgYXR0YWNoZWQgPSBfcmVmLmF0dGFjaGVkLFxuICAgICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiYXR0YWNoZWRcIl0pO1xuXG4gICAgdmFyIGNzcyA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2hlZXQgPSB0aGlzLnJlZ2lzdHJ5W2ldO1xuXG4gICAgICBpZiAoYXR0YWNoZWQgIT0gbnVsbCAmJiBzaGVldC5hdHRhY2hlZCAhPT0gYXR0YWNoZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjc3MpIGNzcyArPSAnXFxuJztcbiAgICAgIGNzcyArPSBzaGVldC50b1N0cmluZyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTaGVldHNSZWdpc3RyeSwgW3tcbiAgICBrZXk6IFwiaW5kZXhcIixcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGlnaGVzdCBpbmRleCBudW1iZXIuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5sZW5ndGggPT09IDAgPyAwIDogdGhpcy5yZWdpc3RyeVt0aGlzLnJlZ2lzdHJ5Lmxlbmd0aCAtIDFdLm9wdGlvbnMuaW5kZXg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoZWV0c1JlZ2lzdHJ5O1xufSgpO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBnbG9iYWwgc2hlZXRzIHJlZ2lzdHJ5LiBPbmx5IERvbVJlbmRlcmVyIHdpbGwgYWRkIHNoZWV0cyB0byBpdC5cbiAqIE9uIHRoZSBzZXJ2ZXIgb25lIHNob3VsZCB1c2UgYW4gb3duIFNoZWV0c1JlZ2lzdHJ5IGluc3RhbmNlIGFuZCBhZGQgdGhlXG4gKiBzaGVldHMgdG8gaXQsIGJlY2F1c2UgeW91IG5lZWQgdG8gbWFrZSBzdXJlIHRvIGNyZWF0ZSBhIG5ldyByZWdpc3RyeSBmb3JcbiAqIGVhY2ggcmVxdWVzdCBpbiBvcmRlciB0byBub3QgbGVhayBzaGVldHMgYWNyb3NzIHJlcXVlc3RzLlxuICovXG5cbnZhciByZWdpc3RyeSA9IG5ldyBTaGVldHNSZWdpc3RyeSgpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vKipcbiAqIE5vdyB0aGF0IGBnbG9iYWxUaGlzYCBpcyBhdmFpbGFibGUgb24gbW9zdCBwbGF0Zm9ybXNcbiAqIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9nbG9iYWxUaGlzI2Jyb3dzZXJfY29tcGF0aWJpbGl0eSlcbiAqIHdlIGNoZWNrIGZvciBgZ2xvYmFsVGhpc2AgZmlyc3QuIGBnbG9iYWxUaGlzYCBpcyBuZWNlc3NhcnkgZm9yIGpzc1xuICogdG8gcnVuIGluIEFnb3JpYydzIHNlY3VyZSB2ZXJzaW9uIG9mIEphdmFTY3JpcHQgKFNFUykuIFVuZGVyIFNFUyxcbiAqIGBnbG9iYWxUaGlzYCBleGlzdHMsIGJ1dCBgd2luZG93YCwgYHNlbGZgLCBhbmQgYEZ1bmN0aW9uKCdyZXR1cm5cbiAqIHRoaXMnKSgpYCBhcmUgYWxsIHVuZGVmaW5lZCBmb3Igc2VjdXJpdHkgcmVhc29ucy5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxuICovXG52YXIgZ2xvYmFsVGhpcyQxID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09PSBNYXRoID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgbnMgPSAnMmYxYWNjNmMzYTYwNmIwODJlNWVlZjVlNTQ0MTRmZmInO1xuaWYgKGdsb2JhbFRoaXMkMVtuc10gPT0gbnVsbCkgZ2xvYmFsVGhpcyQxW25zXSA9IDA7IC8vIEJ1bmRsZSBtYXkgY29udGFpbiBtdWx0aXBsZSBKU1MgdmVyc2lvbnMgYXQgdGhlIHNhbWUgdGltZS4gSW4gb3JkZXIgdG8gaWRlbnRpZnlcbi8vIHRoZSBjdXJyZW50IHZlcnNpb24gd2l0aCBqdXN0IG9uZSBzaG9ydCBudW1iZXIgYW5kIHVzZSBpdCBmb3IgY2xhc3NlcyBnZW5lcmF0aW9uXG4vLyB3ZSB1c2UgYSBjb3VudGVyLiBBbHNvIGl0IGlzIG1vcmUgYWNjdXJhdGUsIGJlY2F1c2UgdXNlciBjYW4gbWFudWFsbHkgcmVldmFsdWF0ZVxuLy8gdGhlIG1vZHVsZS5cblxudmFyIG1vZHVsZUlkID0gZ2xvYmFsVGhpcyQxW25zXSsrO1xuXG52YXIgbWF4UnVsZXMgPSAxZTEwO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgdW5pcXVlIGNsYXNzIG5hbWVzIGJhc2VkIG9uIGNvdW50ZXJzLlxuICogV2hlbiBuZXcgZ2VuZXJhdG9yIGZ1bmN0aW9uIGlzIGNyZWF0ZWQsIHJ1bGUgY291bnRlciBpcyByZXNldGVkLlxuICogV2UgbmVlZCB0byByZXNldCB0aGUgcnVsZSBjb3VudGVyIGZvciBTU1IgZm9yIGVhY2ggcmVxdWVzdC5cbiAqL1xudmFyIGNyZWF0ZUdlbmVyYXRlSWQgPSBmdW5jdGlvbiBjcmVhdGVHZW5lcmF0ZUlkKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBydWxlQ291bnRlciA9IDA7XG5cbiAgdmFyIGdlbmVyYXRlSWQgPSBmdW5jdGlvbiBnZW5lcmF0ZUlkKHJ1bGUsIHNoZWV0KSB7XG4gICAgcnVsZUNvdW50ZXIgKz0gMTtcblxuICAgIGlmIChydWxlQ291bnRlciA+IG1heFJ1bGVzKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFlvdSBtaWdodCBoYXZlIGEgbWVtb3J5IGxlYWsuIFJ1bGUgY291bnRlciBpcyBhdCBcIiArIHJ1bGVDb3VudGVyICsgXCIuXCIpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBqc3NJZCA9ICcnO1xuICAgIHZhciBwcmVmaXggPSAnJztcblxuICAgIGlmIChzaGVldCkge1xuICAgICAgaWYgKHNoZWV0Lm9wdGlvbnMuY2xhc3NOYW1lUHJlZml4KSB7XG4gICAgICAgIHByZWZpeCA9IHNoZWV0Lm9wdGlvbnMuY2xhc3NOYW1lUHJlZml4O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hlZXQub3B0aW9ucy5qc3MuaWQgIT0gbnVsbCkge1xuICAgICAgICBqc3NJZCA9IFN0cmluZyhzaGVldC5vcHRpb25zLmpzcy5pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWluaWZ5KSB7XG4gICAgICAvLyBVc2luZyBcImNcIiBiZWNhdXNlIGEgbnVtYmVyIGNhbid0IGJlIHRoZSBmaXJzdCBjaGFyIGluIGEgY2xhc3MgbmFtZS5cbiAgICAgIHJldHVybiBcIlwiICsgKHByZWZpeCB8fCAnYycpICsgbW9kdWxlSWQgKyBqc3NJZCArIHJ1bGVDb3VudGVyO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXggKyBydWxlLmtleSArIFwiLVwiICsgbW9kdWxlSWQgKyAoanNzSWQgPyBcIi1cIiArIGpzc0lkIDogJycpICsgXCItXCIgKyBydWxlQ291bnRlcjtcbiAgfTtcblxuICByZXR1cm4gZ2VuZXJhdGVJZDtcbn07XG5cbi8qKlxuICogQ2FjaGUgdGhlIHZhbHVlIGZyb20gdGhlIGZpcnN0IHRpbWUgYSBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gKi9cbnZhciBtZW1vaXplID0gZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgdmFsdWU7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF2YWx1ZSkgdmFsdWUgPSBmbigpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn07XG5cbi8qKlxuICogR2V0IGEgc3R5bGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbnZhciBnZXRQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24gZ2V0UHJvcGVydHlWYWx1ZShjc3NSdWxlLCBwcm9wKSB7XG4gIHRyeSB7XG4gICAgLy8gU3VwcG9ydCBDU1NUT00uXG4gICAgaWYgKGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXApIHtcbiAgICAgIHJldHVybiBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLmdldChwcm9wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzUnVsZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJRSBtYXkgdGhyb3cgaWYgcHJvcGVydHkgaXMgdW5rbm93bi5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGEgc3R5bGUgcHJvcGVydHkuXG4gKi9cbnZhciBzZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByb3BlcnR5KGNzc1J1bGUsIHByb3AsIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgdmFyIGNzc1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNzc1ZhbHVlID0gdG9Dc3NWYWx1ZSh2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJyFpbXBvcnRhbnQnKSB7XG4gICAgICAgIGNzc1J1bGUuc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgY3NzVmFsdWUsICdpbXBvcnRhbnQnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBTdXBwb3J0IENTU1RPTS5cblxuXG4gICAgaWYgKGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXApIHtcbiAgICAgIGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXAuc2V0KHByb3AsIGNzc1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3NzUnVsZS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBjc3NWYWx1ZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJRSBtYXkgdGhyb3cgaWYgcHJvcGVydHkgaXMgdW5rbm93bi5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgc3R5bGUgcHJvcGVydHkuXG4gKi9cbnZhciByZW1vdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIHJlbW92ZVByb3BlcnR5KGNzc1J1bGUsIHByb3ApIHtcbiAgdHJ5IHtcbiAgICAvLyBTdXBwb3J0IENTU1RPTS5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcC5kZWxldGUocHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNzc1J1bGUuc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIERPTUV4Y2VwdGlvbiBcXFwiXCIgKyBlcnIubWVzc2FnZSArIFwiXFxcIiB3YXMgdGhyb3duLiBUcmllZCB0byByZW1vdmUgcHJvcGVydHkgXFxcIlwiICsgcHJvcCArIFwiXFxcIi5cIikgOiB2b2lkIDA7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHRoZSBzZWxlY3Rvci5cbiAqL1xudmFyIHNldFNlbGVjdG9yID0gZnVuY3Rpb24gc2V0U2VsZWN0b3IoY3NzUnVsZSwgc2VsZWN0b3JUZXh0KSB7XG4gIGNzc1J1bGUuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3JUZXh0OyAvLyBSZXR1cm4gZmFsc2UgaWYgc2V0dGVyIHdhcyBub3Qgc3VjY2Vzc2Z1bC5cbiAgLy8gQ3VycmVudGx5IHdvcmtzIGluIGNocm9tZSBvbmx5LlxuXG4gIHJldHVybiBjc3NSdWxlLnNlbGVjdG9yVGV4dCA9PT0gc2VsZWN0b3JUZXh0O1xufTtcbi8qKlxuICogR2V0cyB0aGUgYGhlYWRgIGVsZW1lbnQgdXBvbiB0aGUgZmlyc3QgY2FsbCBhbmQgY2FjaGVzIGl0LlxuICogV2UgYXNzdW1lIGl0IGNhbid0IGJlIG51bGwuXG4gKi9cblxuXG52YXIgZ2V0SGVhZCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xufSk7XG4vKipcbiAqIEZpbmQgYXR0YWNoZWQgc2hlZXQgd2l0aCBhbiBpbmRleCBoaWdoZXIgdGhhbiB0aGUgcGFzc2VkIG9uZS5cbiAqL1xuXG5mdW5jdGlvbiBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzaGVldCA9IHJlZ2lzdHJ5W2ldO1xuXG4gICAgaWYgKHNoZWV0LmF0dGFjaGVkICYmIHNoZWV0Lm9wdGlvbnMuaW5kZXggPiBvcHRpb25zLmluZGV4ICYmIHNoZWV0Lm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPT09IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQpIHtcbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRmluZCBhdHRhY2hlZCBzaGVldCB3aXRoIHRoZSBoaWdoZXN0IGluZGV4LlxuICovXG5cblxuZnVuY3Rpb24gZmluZEhpZ2hlc3RTaGVldChyZWdpc3RyeSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gcmVnaXN0cnkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgc2hlZXQgPSByZWdpc3RyeVtpXTtcblxuICAgIGlmIChzaGVldC5hdHRhY2hlZCAmJiBzaGVldC5vcHRpb25zLmluc2VydGlvblBvaW50ID09PSBvcHRpb25zLmluc2VydGlvblBvaW50KSB7XG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEZpbmQgYSBjb21tZW50IHdpdGggXCJqc3NcIiBpbnNpZGUuXG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kQ29tbWVudE5vZGUodGV4dCkge1xuICB2YXIgaGVhZCA9IGdldEhlYWQoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gaGVhZC5jaGlsZE5vZGVzW2ldO1xuXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUudHJpbSgpID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBGaW5kIGEgbm9kZSBiZWZvcmUgd2hpY2ggd2UgY2FuIGluc2VydCB0aGUgc2hlZXQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQcmV2Tm9kZShvcHRpb25zKSB7XG4gIHZhciByZWdpc3RyeSQxID0gcmVnaXN0cnkucmVnaXN0cnk7XG5cbiAgaWYgKHJlZ2lzdHJ5JDEubGVuZ3RoID4gMCkge1xuICAgIC8vIFRyeSB0byBpbnNlcnQgYmVmb3JlIHRoZSBuZXh0IGhpZ2hlciBzaGVldC5cbiAgICB2YXIgc2hlZXQgPSBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnkkMSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoc2hlZXQgJiYgc2hlZXQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogc2hlZXQucmVuZGVyZXIuZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBzaGVldC5yZW5kZXJlci5lbGVtZW50XG4gICAgICB9O1xuICAgIH0gLy8gT3RoZXJ3aXNlIGluc2VydCBhZnRlciB0aGUgbGFzdCBhdHRhY2hlZC5cblxuXG4gICAgc2hlZXQgPSBmaW5kSGlnaGVzdFNoZWV0KHJlZ2lzdHJ5JDEsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNoZWV0ICYmIHNoZWV0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogc2hlZXQucmVuZGVyZXIuZWxlbWVudC5uZXh0U2libGluZ1xuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gVHJ5IHRvIGZpbmQgYSBjb21tZW50IHBsYWNlaG9sZGVyIGlmIHJlZ2lzdHJ5IGlzIGVtcHR5LlxuXG5cbiAgdmFyIGluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcblxuICBpZiAoaW5zZXJ0aW9uUG9pbnQgJiYgdHlwZW9mIGluc2VydGlvblBvaW50ID09PSAnc3RyaW5nJykge1xuICAgIHZhciBjb21tZW50ID0gZmluZENvbW1lbnROb2RlKGluc2VydGlvblBvaW50KTtcblxuICAgIGlmIChjb21tZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IGNvbW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogY29tbWVudC5uZXh0U2libGluZ1xuICAgICAgfTtcbiAgICB9IC8vIElmIHVzZXIgc3BlY2lmaWVzIGFuIGluc2VydGlvbiBwb2ludCBhbmQgaXQgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIGRvY3VtZW50IC1cbiAgICAvLyBiYWQgc3BlY2lmaWNpdHkgaXNzdWVzIG1heSBhcHBlYXIuXG5cblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gSW5zZXJ0aW9uIHBvaW50IFxcXCJcIiArIGluc2VydGlvblBvaW50ICsgXCJcXFwiIG5vdCBmb3VuZC5cIikgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEluc2VydCBzdHlsZSBlbGVtZW50IGludG8gdGhlIERPTS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlKHN0eWxlLCBvcHRpb25zKSB7XG4gIHZhciBpbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG4gIHZhciBuZXh0Tm9kZSA9IGZpbmRQcmV2Tm9kZShvcHRpb25zKTtcblxuICBpZiAobmV4dE5vZGUgIT09IGZhbHNlICYmIG5leHROb2RlLnBhcmVudCkge1xuICAgIG5leHROb2RlLnBhcmVudC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHROb2RlLm5vZGUpO1xuICAgIHJldHVybjtcbiAgfSAvLyBXb3JrcyB3aXRoIGlmcmFtZXMgYW5kIGFueSBub2RlIHR5cGVzLlxuXG5cbiAgaWYgKGluc2VydGlvblBvaW50ICYmIHR5cGVvZiBpbnNlcnRpb25Qb2ludC5ub2RlVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MTMyODcyOC9mb3JjZS1jYXN0aW5nLWluLWZsb3dcbiAgICB2YXIgaW5zZXJ0aW9uUG9pbnRFbGVtZW50ID0gaW5zZXJ0aW9uUG9pbnQ7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBpbnNlcnRpb25Qb2ludEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIGluc2VydGlvblBvaW50RWxlbWVudC5uZXh0U2libGluZyk7ZWxzZSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnW0pTU10gSW5zZXJ0aW9uIHBvaW50IGlzIG5vdCBpbiB0aGUgRE9NLicpIDogdm9pZCAwO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGdldEhlYWQoKS5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG4vKipcbiAqIFJlYWQganNzIG5vbmNlIHNldHRpbmcgZnJvbSB0aGUgcGFnZSBpZiB0aGUgdXNlciBoYXMgc2V0IGl0LlxuICovXG5cblxudmFyIGdldE5vbmNlID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtwcm9wZXJ0eT1cImNzcC1ub25jZVwiXScpO1xuICByZXR1cm4gbm9kZSA/IG5vZGUuZ2V0QXR0cmlidXRlKCdjb250ZW50JykgOiBudWxsO1xufSk7XG5cbnZhciBfaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIGluc2VydFJ1bGUoY29udGFpbmVyLCBydWxlLCBpbmRleCkge1xuICB0cnkge1xuICAgIGlmICgnaW5zZXJ0UnVsZScgaW4gY29udGFpbmVyKSB7XG4gICAgICB2YXIgYyA9IGNvbnRhaW5lcjtcbiAgICAgIGMuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gICAgfSAvLyBLZXlmcmFtZXMgcnVsZS5cbiAgICBlbHNlIGlmICgnYXBwZW5kUnVsZScgaW4gY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBfYyA9IGNvbnRhaW5lcjtcblxuICAgICAgICBfYy5hcHBlbmRSdWxlKHJ1bGUpO1xuICAgICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFwiICsgZXJyLm1lc3NhZ2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb250YWluZXIuY3NzUnVsZXNbaW5kZXhdO1xufTtcblxudmFyIGdldFZhbGlkUnVsZUluc2VydGlvbkluZGV4ID0gZnVuY3Rpb24gZ2V0VmFsaWRSdWxlSW5zZXJ0aW9uSW5kZXgoY29udGFpbmVyLCBpbmRleCkge1xuICB2YXIgbWF4SW5kZXggPSBjb250YWluZXIuY3NzUnVsZXMubGVuZ3RoOyAvLyBJbiBjYXNlIHByZXZpb3VzIGluc2VydGlvbiBmYWlscywgcGFzc2VkIGluZGV4IG1pZ2h0IGJlIHdyb25nXG5cbiAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPiBtYXhJbmRleCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJldHVybiBtYXhJbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG5cbnZhciBjcmVhdGVTdHlsZSA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlKCkge1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpOyAvLyBXaXRob3V0IGl0LCBJRSB3aWxsIGhhdmUgYSBicm9rZW4gc291cmNlIG9yZGVyIHNwZWNpZmljaXR5IGlmIHdlXG4gIC8vIGluc2VydCBydWxlcyBhZnRlciB3ZSBpbnNlcnQgdGhlIHN0eWxlIHRhZy5cbiAgLy8gSXQgc2VlbXMgdG8ga2ljay1vZmYgdGhlIHNvdXJjZSBvcmRlciBzcGVjaWZpY2l0eSBhbGdvcml0aG0uXG5cbiAgZWwudGV4dENvbnRlbnQgPSAnXFxuJztcbiAgcmV0dXJuIGVsO1xufTtcblxudmFyIERvbVJlbmRlcmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gSFRNTFN0eWxlRWxlbWVudCBuZWVkcyBmaXhpbmcgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI2OTZcbiAgLy8gV2lsbCBiZSBlbXB0eSBpZiBsaW5rOiB0cnVlIG9wdGlvbiBpcyBub3Qgc2V0LCBiZWNhdXNlXG4gIC8vIGl0IGlzIG9ubHkgZm9yIHVzZSB0b2dldGhlciB3aXRoIGluc2VydFJ1bGUgQVBJLlxuICBmdW5jdGlvbiBEb21SZW5kZXJlcihzaGVldCkge1xuICAgIHRoaXMuZ2V0UHJvcGVydHlWYWx1ZSA9IGdldFByb3BlcnR5VmFsdWU7XG4gICAgdGhpcy5zZXRQcm9wZXJ0eSA9IHNldFByb3BlcnR5O1xuICAgIHRoaXMucmVtb3ZlUHJvcGVydHkgPSByZW1vdmVQcm9wZXJ0eTtcbiAgICB0aGlzLnNldFNlbGVjdG9yID0gc2V0U2VsZWN0b3I7XG4gICAgdGhpcy5lbGVtZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuc2hlZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5oYXNJbnNlcnRlZFJ1bGVzID0gZmFsc2U7XG4gICAgdGhpcy5jc3NSdWxlcyA9IFtdO1xuICAgIC8vIFRoZXJlIGlzIG5vIHNoZWV0IHdoZW4gdGhlIHJlbmRlcmVyIGlzIHVzZWQgZnJvbSBhIHN0YW5kYWxvbmUgU3R5bGVSdWxlLlxuICAgIGlmIChzaGVldCkgcmVnaXN0cnkuYWRkKHNoZWV0KTtcbiAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG5cbiAgICB2YXIgX3JlZiA9IHRoaXMuc2hlZXQgPyB0aGlzLnNoZWV0Lm9wdGlvbnMgOiB7fSxcbiAgICAgICAgbWVkaWEgPSBfcmVmLm1lZGlhLFxuICAgICAgICBtZXRhID0gX3JlZi5tZXRhLFxuICAgICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50O1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudCB8fCBjcmVhdGVTdHlsZSgpO1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtanNzJywgJycpO1xuICAgIGlmIChtZWRpYSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gICAgaWYgKG1ldGEpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbWV0YScsIG1ldGEpO1xuICAgIHZhciBub25jZSA9IGdldE5vbmNlKCk7XG4gICAgaWYgKG5vbmNlKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHN0eWxlIGVsZW1lbnQgaW50byByZW5kZXIgdHJlZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gRG9tUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgLy8gSW4gdGhlIGNhc2UgdGhlIGVsZW1lbnQgbm9kZSBpcyBleHRlcm5hbCBhbmQgaXQgaXMgYWxyZWFkeSBpbiB0aGUgRE9NLlxuICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSB8fCAhdGhpcy5zaGVldCkgcmV0dXJuO1xuICAgIGluc2VydFN0eWxlKHRoaXMuZWxlbWVudCwgdGhpcy5zaGVldC5vcHRpb25zKTsgLy8gV2hlbiBydWxlcyBhcmUgaW5zZXJ0ZWQgdXNpbmcgYGluc2VydFJ1bGVgIEFQSSwgYWZ0ZXIgYHNoZWV0LmRldGFjaCgpLmF0dGFjaCgpYFxuICAgIC8vIG1vc3QgYnJvd3NlcnMgY3JlYXRlIGEgbmV3IENTU1N0eWxlU2hlZXQsIGV4Y2VwdCBvZiBhbGwgSUVzLlxuXG4gICAgdmFyIGRlcGxveWVkID0gQm9vbGVhbih0aGlzLnNoZWV0ICYmIHRoaXMuc2hlZXQuZGVwbG95ZWQpO1xuXG4gICAgaWYgKHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyAmJiBkZXBsb3llZCkge1xuICAgICAgdGhpcy5oYXNJbnNlcnRlZFJ1bGVzID0gZmFsc2U7XG4gICAgICB0aGlzLmRlcGxveSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHN0eWxlIGVsZW1lbnQgZnJvbSByZW5kZXIgdHJlZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgIGlmICghdGhpcy5zaGVldCkgcmV0dXJuO1xuICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTsgLy8gSW4gdGhlIG1vc3QgYnJvd3NlcnMsIHJ1bGVzIGluc2VydGVkIHVzaW5nIGluc2VydFJ1bGUoKSBBUEkgd2lsbCBiZSBsb3N0IHdoZW4gc3R5bGUgZWxlbWVudCBpcyByZW1vdmVkLlxuICAgIC8vIFRob3VnaCBJRSB3aWxsIGtlZXAgdGhlbSBhbmQgd2UgbmVlZCBhIGNvbnNpc3RlbnQgYmVoYXZpb3IuXG5cbiAgICBpZiAodGhpcy5zaGVldC5vcHRpb25zLmxpbmspIHtcbiAgICAgIHRoaXMuY3NzUnVsZXMgPSBbXTtcbiAgICAgIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudCA9ICdcXG4nO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5qZWN0IENTUyBzdHJpbmcgaW50byBlbGVtZW50LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXBsb3kgPSBmdW5jdGlvbiBkZXBsb3koKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5zaGVldDtcbiAgICBpZiAoIXNoZWV0KSByZXR1cm47XG5cbiAgICBpZiAoc2hlZXQub3B0aW9ucy5saW5rKSB7XG4gICAgICB0aGlzLmluc2VydFJ1bGVzKHNoZWV0LnJ1bGVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQudGV4dENvbnRlbnQgPSBcIlxcblwiICsgc2hlZXQudG9TdHJpbmcoKSArIFwiXFxuXCI7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBSdWxlTGlzdCBpbnRvIGFuIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluc2VydFJ1bGVzID0gZnVuY3Rpb24gaW5zZXJ0UnVsZXMocnVsZXMsIG5hdGl2ZVBhcmVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMuaW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlcy5pbmRleFtpXSwgaSwgbmF0aXZlUGFyZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBhIHJ1bGUgaW50byBlbGVtZW50LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlLCBpbmRleCwgbmF0aXZlUGFyZW50KSB7XG4gICAgaWYgKG5hdGl2ZVBhcmVudCA9PT0gdm9pZCAwKSB7XG4gICAgICBuYXRpdmVQYXJlbnQgPSB0aGlzLmVsZW1lbnQuc2hlZXQ7XG4gICAgfVxuXG4gICAgaWYgKHJ1bGUucnVsZXMpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBydWxlO1xuICAgICAgdmFyIGxhdGVzdE5hdGl2ZVBhcmVudCA9IG5hdGl2ZVBhcmVudDtcblxuICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ2NvbmRpdGlvbmFsJyB8fCBydWxlLnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICAgIHZhciBfaW5zZXJ0aW9uSW5kZXggPSBnZXRWYWxpZFJ1bGVJbnNlcnRpb25JbmRleChuYXRpdmVQYXJlbnQsIGluZGV4KTsgLy8gV2UgbmVlZCB0byByZW5kZXIgdGhlIGNvbnRhaW5lciB3aXRob3V0IGNoaWxkcmVuIGZpcnN0LlxuXG5cbiAgICAgICAgbGF0ZXN0TmF0aXZlUGFyZW50ID0gX2luc2VydFJ1bGUobmF0aXZlUGFyZW50LCBwYXJlbnQudG9TdHJpbmcoe1xuICAgICAgICAgIGNoaWxkcmVuOiBmYWxzZVxuICAgICAgICB9KSwgX2luc2VydGlvbkluZGV4KTtcblxuICAgICAgICBpZiAobGF0ZXN0TmF0aXZlUGFyZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVmQ3NzUnVsZShydWxlLCBfaW5zZXJ0aW9uSW5kZXgsIGxhdGVzdE5hdGl2ZVBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zZXJ0UnVsZXMocGFyZW50LnJ1bGVzLCBsYXRlc3ROYXRpdmVQYXJlbnQpO1xuICAgICAgcmV0dXJuIGxhdGVzdE5hdGl2ZVBhcmVudDtcbiAgICB9XG5cbiAgICB2YXIgcnVsZVN0ciA9IHJ1bGUudG9TdHJpbmcoKTtcbiAgICBpZiAoIXJ1bGVTdHIpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0aW9uSW5kZXggPSBnZXRWYWxpZFJ1bGVJbnNlcnRpb25JbmRleChuYXRpdmVQYXJlbnQsIGluZGV4KTtcblxuICAgIHZhciBuYXRpdmVSdWxlID0gX2luc2VydFJ1bGUobmF0aXZlUGFyZW50LCBydWxlU3RyLCBpbnNlcnRpb25JbmRleCk7XG5cbiAgICBpZiAobmF0aXZlUnVsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSB0cnVlO1xuICAgIHRoaXMucmVmQ3NzUnVsZShydWxlLCBpbnNlcnRpb25JbmRleCwgbmF0aXZlUnVsZSk7XG4gICAgcmV0dXJuIG5hdGl2ZVJ1bGU7XG4gIH07XG5cbiAgX3Byb3RvLnJlZkNzc1J1bGUgPSBmdW5jdGlvbiByZWZDc3NSdWxlKHJ1bGUsIGluZGV4LCBjc3NSdWxlKSB7XG4gICAgcnVsZS5yZW5kZXJhYmxlID0gY3NzUnVsZTsgLy8gV2Ugb25seSB3YW50IHRvIHJlZmVyZW5jZSB0aGUgdG9wIGxldmVsIHJ1bGVzLCBkZWxldGVSdWxlIEFQSSBkb2Vzbid0IHN1cHBvcnQgcmVtb3ZpbmcgbmVzdGVkIHJ1bGVzXG4gICAgLy8gbGlrZSBydWxlcyBpbnNpZGUgbWVkaWEgcXVlcmllcyBvciBrZXlmcmFtZXNcblxuICAgIGlmIChydWxlLm9wdGlvbnMucGFyZW50IGluc3RhbmNlb2YgU3R5bGVTaGVldCkge1xuICAgICAgdGhpcy5jc3NSdWxlc1tpbmRleF0gPSBjc3NSdWxlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVsZXRlUnVsZSA9IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUoY3NzUnVsZSkge1xuICAgIHZhciBzaGVldCA9IHRoaXMuZWxlbWVudC5zaGVldDtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgIHRoaXMuY3NzUnVsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgQ1NTIFJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKGNzc1J1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5jc3NSdWxlcy5pbmRleE9mKGNzc1J1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyBDU1MgcnVsZSBhbmQgcmVwbGFjZSB0aGUgZXhpc3Rpbmcgb25lLlxuICAgKlxuICAgKiBPbmx5IHVzZWQgZm9yIHNvbWUgb2xkIGJyb3dzZXJzIGJlY2F1c2UgdGhleSBjYW4ndCBzZXQgYSBzZWxlY3Rvci5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVwbGFjZVJ1bGUgPSBmdW5jdGlvbiByZXBsYWNlUnVsZShjc3NSdWxlLCBydWxlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKGNzc1J1bGUpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLmVsZW1lbnQuc2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XG4gICAgdGhpcy5jc3NSdWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0aGlzLmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIHJ1bGVzIGVsZW1lbnRzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRSdWxlcyA9IGZ1bmN0aW9uIGdldFJ1bGVzKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuc2hlZXQuY3NzUnVsZXM7XG4gIH07XG5cbiAgcmV0dXJuIERvbVJlbmRlcmVyO1xufSgpO1xuXG52YXIgaW5zdGFuY2VDb3VudGVyID0gMDtcblxudmFyIEpzcyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEpzcyhvcHRpb25zKSB7XG4gICAgdGhpcy5pZCA9IGluc3RhbmNlQ291bnRlcisrO1xuICAgIHRoaXMudmVyc2lvbiA9IFwiMTAuNy4xXCI7XG4gICAgdGhpcy5wbHVnaW5zID0gbmV3IFBsdWdpbnNSZWdpc3RyeSgpO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGlkOiB7XG4gICAgICAgIG1pbmlmeTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBjcmVhdGVHZW5lcmF0ZUlkOiBjcmVhdGVHZW5lcmF0ZUlkLFxuICAgICAgUmVuZGVyZXI6IGlzSW5Ccm93c2VyID8gRG9tUmVuZGVyZXIgOiBudWxsLFxuICAgICAgcGx1Z2luczogW11cbiAgICB9O1xuICAgIHRoaXMuZ2VuZXJhdGVJZCA9IGNyZWF0ZUdlbmVyYXRlSWQoe1xuICAgICAgbWluaWZ5OiBmYWxzZVxuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnBsdWdpbnMudXNlKHBsdWdpbnNbaV0sIHtcbiAgICAgICAgcXVldWU6ICdpbnRlcm5hbCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc2V0dXAob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFByZXBhcmVzIHZhcmlvdXMgb3B0aW9ucywgYXBwbGllcyBwbHVnaW5zLlxuICAgKiBTaG91bGQgbm90IGJlIHVzZWQgdHdpY2Ugb24gdGhlIHNhbWUgaW5zdGFuY2UsIGJlY2F1c2UgdGhlcmUgaXMgbm8gcGx1Z2luc1xuICAgKiBkZWR1cGxpY2F0aW9uIGxvZ2ljLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBKc3MucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXR1cCA9IGZ1bmN0aW9uIHNldHVwKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQgPSBvcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5pZCA9IF9leHRlbmRzKHt9LCB0aGlzLm9wdGlvbnMuaWQsIG9wdGlvbnMuaWQpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQgfHwgb3B0aW9ucy5pZCkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUlkID0gdGhpcy5vcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQodGhpcy5vcHRpb25zLmlkKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbnNlcnRpb25Qb2ludCAhPSBudWxsKSB0aGlzLm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuXG4gICAgaWYgKCdSZW5kZXJlcicgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zLlJlbmRlcmVyID0gb3B0aW9ucy5SZW5kZXJlcjtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG5cblxuICAgIGlmIChvcHRpb25zLnBsdWdpbnMpIHRoaXMudXNlLmFwcGx5KHRoaXMsIG9wdGlvbnMucGx1Z2lucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFN0eWxlIFNoZWV0LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jcmVhdGVTdHlsZVNoZWV0ID0gZnVuY3Rpb24gY3JlYXRlU3R5bGVTaGVldChzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgaW5kZXggPSBfb3B0aW9ucy5pbmRleDtcblxuICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICBpbmRleCA9IHJlZ2lzdHJ5LmluZGV4ID09PSAwID8gMCA6IHJlZ2lzdHJ5LmluZGV4ICsgMTtcbiAgICB9XG5cbiAgICB2YXIgc2hlZXQgPSBuZXcgU3R5bGVTaGVldChzdHlsZXMsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBqc3M6IHRoaXMsXG4gICAgICBnZW5lcmF0ZUlkOiBvcHRpb25zLmdlbmVyYXRlSWQgfHwgdGhpcy5nZW5lcmF0ZUlkLFxuICAgICAgaW5zZXJ0aW9uUG9pbnQ6IHRoaXMub3B0aW9ucy5pbnNlcnRpb25Qb2ludCxcbiAgICAgIFJlbmRlcmVyOiB0aGlzLm9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9KSk7XG4gICAgdGhpcy5wbHVnaW5zLm9uUHJvY2Vzc1NoZWV0KHNoZWV0KTtcbiAgICByZXR1cm4gc2hlZXQ7XG4gIH1cbiAgLyoqXG4gICAqIERldGFjaCB0aGUgU3R5bGUgU2hlZXQgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlU3R5bGVTaGVldCA9IGZ1bmN0aW9uIHJlbW92ZVN0eWxlU2hlZXQoc2hlZXQpIHtcbiAgICBzaGVldC5kZXRhY2goKTtcbiAgICByZWdpc3RyeS5yZW1vdmUoc2hlZXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBydWxlIHdpdGhvdXQgYSBTdHlsZSBTaGVldC5cbiAgICogW0RlcHJlY2F0ZWRdIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jcmVhdGVSdWxlID0gZnVuY3Rpb24gY3JlYXRlUnVsZSQxKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKHN0eWxlID09PSB2b2lkIDApIHtcbiAgICAgIHN0eWxlID0ge307XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIC8vIEVuYWJsZSBydWxlIHdpdGhvdXQgbmFtZSBmb3IgaW5saW5lIHN0eWxlcy5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXVxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUnVsZSh1bmRlZmluZWQsIG5hbWUsIHN0eWxlKTtcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdXG5cblxuICAgIHZhciBydWxlT3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAganNzOiB0aGlzLFxuICAgICAgUmVuZGVyZXI6IHRoaXMub3B0aW9ucy5SZW5kZXJlclxuICAgIH0pO1xuXG4gICAgaWYgKCFydWxlT3B0aW9ucy5nZW5lcmF0ZUlkKSBydWxlT3B0aW9ucy5nZW5lcmF0ZUlkID0gdGhpcy5nZW5lcmF0ZUlkO1xuICAgIGlmICghcnVsZU9wdGlvbnMuY2xhc3NlcykgcnVsZU9wdGlvbnMuY2xhc3NlcyA9IHt9O1xuICAgIGlmICghcnVsZU9wdGlvbnMua2V5ZnJhbWVzKSBydWxlT3B0aW9ucy5rZXlmcmFtZXMgPSB7fTtcblxuICAgIHZhciBydWxlID0gY3JlYXRlUnVsZShuYW1lLCBzdHlsZSwgcnVsZU9wdGlvbnMpO1xuXG4gICAgaWYgKHJ1bGUpIHRoaXMucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBwbHVnaW4uIFBhc3NlZCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgd2l0aCBhIHJ1bGUgaW5zdGFuY2UuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVzZSA9IGZ1bmN0aW9uIHVzZSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBsdWdpbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBwbHVnaW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBfdGhpcy5wbHVnaW5zLnVzZShwbHVnaW4pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBKc3M7XG59KCk7XG5cbi8qKlxuICogRXh0cmFjdHMgYSBzdHlsZXMgb2JqZWN0IHdpdGggb25seSBwcm9wcyB0aGF0IGNvbnRhaW4gZnVuY3Rpb24gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXREeW5hbWljU3R5bGVzKHN0eWxlcykge1xuICB2YXIgdG8gPSBudWxsO1xuXG4gIGZvciAodmFyIGtleSBpbiBzdHlsZXMpIHtcbiAgICB2YXIgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoIXRvKSB0byA9IHt9O1xuICAgICAgdG9ba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YXIgZXh0cmFjdGVkID0gZ2V0RHluYW1pY1N0eWxlcyh2YWx1ZSk7XG5cbiAgICAgIGlmIChleHRyYWN0ZWQpIHtcbiAgICAgICAgaWYgKCF0bykgdG8gPSB7fTtcbiAgICAgICAgdG9ba2V5XSA9IGV4dHJhY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG87XG59XG5cbi8qKlxuICogU2hlZXRzTWFuYWdlciBpcyBsaWtlIGEgV2Vha01hcCB3aGljaCBpcyBkZXNpZ25lZCB0byBjb3VudCBTdHlsZVNoZWV0XG4gKiBpbnN0YW5jZXMgYW5kIGF0dGFjaC9kZXRhY2ggYXV0b21hdGljYWxseS5cbiAqL1xudmFyIFNoZWV0c01hbmFnZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaGVldHNNYW5hZ2VyKCkge1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnNoZWV0cyA9IG5ldyBXZWFrTWFwKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2hlZXRzTWFuYWdlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLnNoZWV0cy5nZXQoa2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkuc2hlZXQ7XG4gIH07XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChrZXksIHNoZWV0KSB7XG4gICAgaWYgKHRoaXMuc2hlZXRzLmhhcyhrZXkpKSByZXR1cm47XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgICB0aGlzLnNoZWV0cy5zZXQoa2V5LCB7XG4gICAgICBzaGVldDogc2hlZXQsXG4gICAgICByZWZzOiAwXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLm1hbmFnZSA9IGZ1bmN0aW9uIG1hbmFnZShrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLnNoZWV0cy5nZXQoa2V5KTtcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgaWYgKGVudHJ5LnJlZnMgPT09IDApIHtcbiAgICAgICAgZW50cnkuc2hlZXQuYXR0YWNoKCk7XG4gICAgICB9XG5cbiAgICAgIGVudHJ5LnJlZnMrKztcbiAgICAgIHJldHVybiBlbnRyeS5zaGVldDtcbiAgICB9XG5cbiAgICB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFNoZWV0c01hbmFnZXI6IGNhbid0IGZpbmQgc2hlZXQgdG8gbWFuYWdlXCIpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgX3Byb3RvLnVubWFuYWdlID0gZnVuY3Rpb24gdW5tYW5hZ2Uoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zaGVldHMuZ2V0KGtleSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGlmIChlbnRyeS5yZWZzID4gMCkge1xuICAgICAgICBlbnRyeS5yZWZzLS07XG4gICAgICAgIGlmIChlbnRyeS5yZWZzID09PSAwKSBlbnRyeS5zaGVldC5kZXRhY2goKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgXCJTaGVldHNNYW5hZ2VyOiBjYW4ndCBmaW5kIHNoZWV0IHRvIHVubWFuYWdlXCIpO1xuICAgIH1cbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU2hlZXRzTWFuYWdlciwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaGVldHNNYW5hZ2VyO1xufSgpO1xuXG4vKipcbiAqIEEgYmV0dGVyIGFic3RyYWN0aW9uIG92ZXIgQ1NTLlxuICpcbiAqIEBjb3B5cmlnaHQgT2xlZyBJc29uZW4gKFNsb2JvZHNrb2kpIC8gSXNvbmVuIDIwMTQtcHJlc2VudFxuICogQHdlYnNpdGUgaHR0cHM6Ly9naXRodWIuY29tL2Nzc2luanMvanNzXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4vKipcbiAqIEV4cG9ydCBhIGNvbnN0YW50IGluZGljYXRpbmcgaWYgdGhpcyBicm93c2VyIGhhcyBDU1NUT00gc3VwcG9ydC5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTgvMDMvY3Nzb21cbiAqL1xudmFyIGhhc0NTU1RPTVN1cHBvcnQgPSB0eXBlb2YgQ1NTID09PSAnb2JqZWN0JyAmJiBDU1MgIT0gbnVsbCAmJiAnbnVtYmVyJyBpbiBDU1M7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgSnNzLlxuICovXG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEpzcyhvcHRpb25zKTtcbn07XG4vKipcbiAqIEEgZ2xvYmFsIEpzcyBpbnN0YW5jZS5cbiAqL1xuXG52YXIganNzID0gY3JlYXRlKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGpzcztcbmV4cG9ydCB7IFJ1bGVMaXN0LCBTaGVldHNNYW5hZ2VyLCBTaGVldHNSZWdpc3RyeSwgY3JlYXRlLCBjcmVhdGVHZW5lcmF0ZUlkLCBjcmVhdGVSdWxlLCBnZXREeW5hbWljU3R5bGVzLCBoYXNDU1NUT01TdXBwb3J0LCByZWdpc3RyeSBhcyBzaGVldHMsIHRvQ3NzVmFsdWUgfTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTWF0aGlldSBUdXJjb3R0ZVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvY2hlY2tzJyk7IiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxMiBNYXRoaWV1IFR1cmNvdHRlXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBlcnJvcnMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbmZ1bmN0aW9uIGZhaWxDaGVjayhFeGNlcHRpb25Db25zdHJ1Y3RvciwgY2FsbGVlLCBtZXNzYWdlRm9ybWF0LCBmb3JtYXRBcmdzKSB7XG4gICAgbWVzc2FnZUZvcm1hdCA9IG1lc3NhZ2VGb3JtYXQgfHwgJyc7XG4gICAgdmFyIG1lc3NhZ2UgPSB1dGlsLmZvcm1hdC5hcHBseSh0aGlzLCBbbWVzc2FnZUZvcm1hdF0uY29uY2F0KGZvcm1hdEFyZ3MpKTtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXhjZXB0aW9uQ29uc3RydWN0b3IobWVzc2FnZSk7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIGNhbGxlZSk7XG4gICAgdGhyb3cgZXJyb3I7XG59XG5cbmZ1bmN0aW9uIGZhaWxBcmd1bWVudENoZWNrKGNhbGxlZSwgbWVzc2FnZSwgZm9ybWF0QXJncykge1xuICAgIGZhaWxDaGVjayhlcnJvcnMuSWxsZWdhbEFyZ3VtZW50RXJyb3IsIGNhbGxlZSwgbWVzc2FnZSwgZm9ybWF0QXJncyk7XG59XG5cbmZ1bmN0aW9uIGZhaWxTdGF0ZUNoZWNrKGNhbGxlZSwgbWVzc2FnZSwgZm9ybWF0QXJncykge1xuICAgIGZhaWxDaGVjayhlcnJvcnMuSWxsZWdhbFN0YXRlRXJyb3IsIGNhbGxlZSwgbWVzc2FnZSwgZm9ybWF0QXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmNoZWNrQXJndW1lbnQgPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgZmFpbEFyZ3VtZW50Q2hlY2soYXJndW1lbnRzLmNhbGxlZSwgbWVzc2FnZSxcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmNoZWNrU3RhdGUgPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgZmFpbFN0YXRlQ2hlY2soYXJndW1lbnRzLmNhbGxlZSwgbWVzc2FnZSxcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmNoZWNrSXNEZWYgPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmYWlsQXJndW1lbnRDaGVjayhhcmd1bWVudHMuY2FsbGVlLCBtZXNzYWdlIHx8XG4gICAgICAgICdFeHBlY3RlZCB2YWx1ZSB0byBiZSBkZWZpbmVkIGJ1dCB3YXMgdW5kZWZpbmVkLicsXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuY2hlY2tJc0RlZkFuZE5vdE51bGwgPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xuICAgIC8vIE5vdGUgdGhhdCB1bmRlZmluZWQgPT0gbnVsbC5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZmFpbEFyZ3VtZW50Q2hlY2soYXJndW1lbnRzLmNhbGxlZSwgbWVzc2FnZSB8fFxuICAgICAgICAnRXhwZWN0ZWQgdmFsdWUgdG8gYmUgZGVmaW5lZCBhbmQgbm90IG51bGwgYnV0IGdvdCBcIicgK1xuICAgICAgICB0eXBlT2YodmFsdWUpICsgJ1wiLicsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xufTtcblxuLy8gRml4ZWQgdmVyc2lvbiBvZiB0aGUgdHlwZU9mIG9wZXJhdG9yIHdoaWNoIHJldHVybnMgJ251bGwnIGZvciBudWxsIHZhbHVlc1xuLy8gYW5kICdhcnJheScgZm9yIGFycmF5cy5cbmZ1bmN0aW9uIHR5cGVPZih2YWx1ZSkge1xuICAgIHZhciBzID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmIChzID09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIHR5cGVDaGVjayhleHBlY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlT2YodmFsdWUpO1xuXG4gICAgICAgIGlmICh0eXBlID09IGV4cGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZmFpbEFyZ3VtZW50Q2hlY2soYXJndW1lbnRzLmNhbGxlZSwgbWVzc2FnZSB8fFxuICAgICAgICAgICAgJ0V4cGVjdGVkIFwiJyArIGV4cGVjdCArICdcIiBidXQgZ290IFwiJyArIHR5cGUgKyAnXCIuJyxcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzLmNoZWNrSXNTdHJpbmcgPSB0eXBlQ2hlY2soJ3N0cmluZycpO1xubW9kdWxlLmV4cG9ydHMuY2hlY2tJc0FycmF5ID0gdHlwZUNoZWNrKCdhcnJheScpO1xubW9kdWxlLmV4cG9ydHMuY2hlY2tJc051bWJlciA9IHR5cGVDaGVjaygnbnVtYmVyJyk7XG5tb2R1bGUuZXhwb3J0cy5jaGVja0lzQm9vbGVhbiA9IHR5cGVDaGVjaygnYm9vbGVhbicpO1xubW9kdWxlLmV4cG9ydHMuY2hlY2tJc0Z1bmN0aW9uID0gdHlwZUNoZWNrKCdmdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMuY2hlY2tJc09iamVjdCA9IHR5cGVDaGVjaygnb2JqZWN0Jyk7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE1hdGhpZXUgVHVyY290dGVcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gSWxsZWdhbEFyZ3VtZW50RXJyb3IobWVzc2FnZSkge1xuICAgIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cbnV0aWwuaW5oZXJpdHMoSWxsZWdhbEFyZ3VtZW50RXJyb3IsIEVycm9yKTtcblxuSWxsZWdhbEFyZ3VtZW50RXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSWxsZWdhbEFyZ3VtZW50RXJyb3InO1xuXG5mdW5jdGlvbiBJbGxlZ2FsU3RhdGVFcnJvcihtZXNzYWdlKSB7XG4gICAgRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxudXRpbC5pbmhlcml0cyhJbGxlZ2FsU3RhdGVFcnJvciwgRXJyb3IpO1xuXG5JbGxlZ2FsU3RhdGVFcnJvci5wcm90b3R5cGUubmFtZSA9ICdJbGxlZ2FsU3RhdGVFcnJvcic7XG5cbm1vZHVsZS5leHBvcnRzLklsbGVnYWxTdGF0ZUVycm9yID0gSWxsZWdhbFN0YXRlRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5JbGxlZ2FsQXJndW1lbnRFcnJvciA9IElsbGVnYWxBcmd1bWVudEVycm9yOyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgcG9ueWZpbGwgZnJvbSAnLi9wb255ZmlsbC5qcyc7XG5cbnZhciByb290O1xuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSBwb255ZmlsbChyb290KTtcbmV4cG9ydCBkZWZhdWx0IHJlc3VsdDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0U3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbmZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghaXNQcm9kdWN0aW9uKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gXCJXYXJuaW5nOiBcIiArIG1lc3NhZ2U7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4odGV4dCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRocm93IEVycm9yKHRleHQpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgd2FybmluZztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBDYW5jZWxhYmxlUHJvbWlzZSA9IHJlcXVpcmUoJy4vdXRpbC9jYW5jZWxhYmxlcHJvbWlzZScpO1xuLyoqXG4gKiBDcmVhdGUgYSB7QGxpbmsgQ2FuY2VsYWJsZVByb21pc2U8Um9vbT59LlxuICogQHBhcmFtIHtmdW5jdGlvbihmdW5jdGlvbihBcnJheTxMb2NhbFRyYWNrPik6IENhbmNlbGFibGVQcm9taXNlPFJvb21TaWduYWxpbmc+KTpcbiAqICAgUHJvbWlzZTxmdW5jdGlvbigpOiBDYW5jZWxhYmxlUHJvbWlzZTxSb29tU2lnbmFsaW5nPj59IGdldExvY2FsVHJhY2tzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEFycmF5PExvY2FsVHJhY2s+KTogTG9jYWxQYXJ0aWNpcGFudH0gY3JlYXRlTG9jYWxQYXJ0aWNpcGFudFxuICogQHBhcmFtIHtmdW5jdGlvbihBcnJheTxMb2NhbFRyYWNrPik6IENhbmNlbGFibGVQcm9taXNlPFJvb21TaWduYWxpbmc+fSBjcmVhdGVSb29tU2lnbmFsaW5nXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKExvY2FsUGFydGljaXBhbnQsIFJvb21TaWduYWxpbmcpOiBSb29tfSBjcmVhdGVSb29tXG4gKiBAcmV0dXJucyBDYW5jZWxhYmxlUHJvbWlzZTxSb29tPlxuICovXG5mdW5jdGlvbiBjcmVhdGVDYW5jZWxhYmxlUm9vbVByb21pc2UoZ2V0TG9jYWxUcmFja3MsIGNyZWF0ZUxvY2FsUGFydGljaXBhbnQsIGNyZWF0ZVJvb21TaWduYWxpbmcsIGNyZWF0ZVJvb20pIHtcbiAgICB2YXIgY2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlO1xuICAgIHZhciBjYW5jZWxsYXRpb25FcnJvciA9IG5ldyBFcnJvcignQ2FuY2VsZWQnKTtcbiAgICByZXR1cm4gbmV3IENhbmNlbGFibGVQcm9taXNlKGZ1bmN0aW9uIG9uQ3JlYXRlKHJlc29sdmUsIHJlamVjdCwgaXNDYW5jZWxlZCkge1xuICAgICAgICB2YXIgbG9jYWxQYXJ0aWNpcGFudDtcbiAgICAgICAgZ2V0TG9jYWxUcmFja3MoZnVuY3Rpb24gZ2V0TG9jYWxUcmFja3NTdWNjZWVkZWQobG9jYWxUcmFja3MpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbmNlbGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FuY2VsYWJsZVByb21pc2UucmVqZWN0KGNhbmNlbGxhdGlvbkVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUGFydGljaXBhbnQgPSBjcmVhdGVMb2NhbFBhcnRpY2lwYW50KGxvY2FsVHJhY2tzKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVSb29tU2lnbmFsaW5nKGxvY2FsUGFydGljaXBhbnQpLnRoZW4oZnVuY3Rpb24gY3JlYXRlUm9vbVNpZ25hbGluZ1N1Y2NlZWRlZChnZXRDYW5jZWxhYmxlUm9vbVNpZ25hbGluZ1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDYW5jZWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNhbmNlbGxhdGlvbkVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlUm9vbVNpZ25hbGluZ1Byb21pc2UgPSBnZXRDYW5jZWxhYmxlUm9vbVNpZ25hbGluZ1Byb21pc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gcm9vbVNpZ25hbGluZ0Nvbm5lY3RlZChyb29tU2lnbmFsaW5nKSB7XG4gICAgICAgICAgICBpZiAoaXNDYW5jZWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcm9vbVNpZ25hbGluZy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgY2FuY2VsbGF0aW9uRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGNyZWF0ZVJvb20obG9jYWxQYXJ0aWNpcGFudCwgcm9vbVNpZ25hbGluZykpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiBvbkNhbmNlbCgpIHtcbiAgICAgICAgaWYgKGNhbmNlbGFibGVSb29tU2lnbmFsaW5nUHJvbWlzZSkge1xuICAgICAgICAgICAgY2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNhbmNlbGFibGVSb29tUHJvbWlzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbmNlbGFibGVyb29tcHJvbWlzZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgTWVkaWFTdHJlYW1UcmFjayA9IHJlcXVpcmUoJy4vd2VicnRjJykuTWVkaWFTdHJlYW1UcmFjaztcbnZhciBfYSA9IHJlcXVpcmUoJy4vd2VicnRjL3V0aWwnKSwgZ3Vlc3NCcm93c2VyID0gX2EuZ3Vlc3NCcm93c2VyLCBndWVzc0Jyb3dzZXJWZXJzaW9uID0gX2EuZ3Vlc3NCcm93c2VyVmVyc2lvbjtcbnZhciBjcmVhdGVDYW5jZWxhYmxlUm9vbVByb21pc2UgPSByZXF1aXJlKCcuL2NhbmNlbGFibGVyb29tcHJvbWlzZScpO1xudmFyIEVuY29kaW5nUGFyYW1ldGVyc0ltcGwgPSByZXF1aXJlKCcuL2VuY29kaW5ncGFyYW1ldGVycycpO1xudmFyIExvY2FsUGFydGljaXBhbnQgPSByZXF1aXJlKCcuL2xvY2FscGFydGljaXBhbnQnKTtcbnZhciBJbnNpZ2h0c1B1Ymxpc2hlciA9IHJlcXVpcmUoJy4vdXRpbC9pbnNpZ2h0c3B1Ymxpc2hlcicpO1xudmFyIE51bGxJbnNpZ2h0c1B1Ymxpc2hlciA9IHJlcXVpcmUoJy4vdXRpbC9pbnNpZ2h0c3B1Ymxpc2hlci9udWxsJyk7XG52YXIgX2IgPSByZXF1aXJlKCcuL21lZGlhL3RyYWNrL2VzNScpLCBMb2NhbEF1ZGlvVHJhY2sgPSBfYi5Mb2NhbEF1ZGlvVHJhY2ssIExvY2FsRGF0YVRyYWNrID0gX2IuTG9jYWxEYXRhVHJhY2ssIExvY2FsVmlkZW9UcmFjayA9IF9iLkxvY2FsVmlkZW9UcmFjaztcbnZhciBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25JbXBsID0gcmVxdWlyZSgnLi9uZXR3b3JrcXVhbGl0eWNvbmZpZ3VyYXRpb24nKTtcbnZhciBSb29tID0gcmVxdWlyZSgnLi9yb29tJyk7XG52YXIgU2lnbmFsaW5nVjIgPSByZXF1aXJlKCcuL3NpZ25hbGluZy92MicpO1xudmFyIF9jID0gcmVxdWlyZSgnLi91dGlsJyksIGFzTG9jYWxUcmFjayA9IF9jLmFzTG9jYWxUcmFjaywgYnVpbGRMb2dMZXZlbHMgPSBfYy5idWlsZExvZ0xldmVscywgZmlsdGVyT2JqZWN0ID0gX2MuZmlsdGVyT2JqZWN0LCBpc05vbkFycmF5T2JqZWN0ID0gX2MuaXNOb25BcnJheU9iamVjdDtcbnZhciBfZCA9IHJlcXVpcmUoJy4vdXRpbC9jb25zdGFudHMnKSwgREVGQVVMVF9FTlZJUk9OTUVOVCA9IF9kLkRFRkFVTFRfRU5WSVJPTk1FTlQsIERFRkFVTFRfTE9HX0xFVkVMID0gX2QuREVGQVVMVF9MT0dfTEVWRUwsIERFRkFVTFRfTE9HR0VSX05BTUUgPSBfZC5ERUZBVUxUX0xPR0dFUl9OQU1FLCBERUZBVUxUX1JFQUxNID0gX2QuREVGQVVMVF9SRUFMTSwgREVGQVVMVF9SRUdJT04gPSBfZC5ERUZBVUxUX1JFR0lPTiwgV1NfU0VSVkVSID0gX2QuV1NfU0VSVkVSLCBTREtfTkFNRSA9IF9kLlNES19OQU1FLCBTREtfVkVSU0lPTiA9IF9kLlNES19WRVJTSU9OLCBFID0gX2QudHlwZUVycm9ycztcbnZhciBDYW5jZWxhYmxlUHJvbWlzZSA9IHJlcXVpcmUoJy4vdXRpbC9jYW5jZWxhYmxlcHJvbWlzZScpO1xudmFyIEV2ZW50T2JzZXJ2ZXIgPSByZXF1aXJlKCcuL3V0aWwvZXZlbnRvYnNlcnZlcicpO1xudmFyIERlZmF1bHRMb2cgPSByZXF1aXJlKCcuL3V0aWwvbG9nJyk7XG52YXIgdmFsaWRhdGVCYW5kd2lkdGhQcm9maWxlID0gcmVxdWlyZSgnLi91dGlsL3ZhbGlkYXRlJykudmFsaWRhdGVCYW5kd2lkdGhQcm9maWxlO1xudmFyIHNhZmFyaVZlcnNpb24gPSBndWVzc0Jyb3dzZXIoKSA9PT0gJ3NhZmFyaScgJiYgZ3Vlc3NCcm93c2VyVmVyc2lvbigpO1xuLy8gVGhpcyBpcyB1c2VkIHRvIG1ha2Ugb3V0IHdoaWNoIGNvbm5lY3QoKSBjYWxsIGEgcGFydGljdWxhciBMb2cgc3RhdGVtZW50XG4vLyBiZWxvbmdzIHRvLiBFYWNoIGNhbGwgdG8gY29ubmVjdCgpIGluY3JlbWVudHMgdGhpcyBjb3VudGVyLlxudmFyIGNvbm5lY3RDYWxscyA9IDA7XG52YXIgZGlkUHJpbnRTYWZhcmlXYXJuaW5nID0gZmFsc2U7XG52YXIgaXNTYWZhcmlXaXRob3V0VlA4U3VwcG9ydCA9IGZhbHNlO1xuaWYgKHNhZmFyaVZlcnNpb24pIHtcbiAgICB2YXIgc2FmYXJpTWFqb3JWZXJzaW9uID0gc2FmYXJpVmVyc2lvbi5tYWpvciwgc2FmYXJpTWlub3JWZXJzaW9uID0gc2FmYXJpVmVyc2lvbi5taW5vcjtcbiAgICBpc1NhZmFyaVdpdGhvdXRWUDhTdXBwb3J0ID0gc2FmYXJpTWFqb3JWZXJzaW9uIDwgMTIgfHwgKHNhZmFyaU1ham9yVmVyc2lvbiA9PT0gMTIgJiYgc2FmYXJpTWlub3JWZXJzaW9uIDwgMSk7XG59XG52YXIgZGVwcmVjYXRlZENvbm5lY3RPcHRpb25zUHJvcHMgPSBuZXcgU2V0KFtcbiAgICB7IGRpZFdhcm46IGZhbHNlLCBzaG91bGREZWxldGU6IHRydWUsIG5hbWU6ICdhYm9ydE9uSWNlU2VydmVyc1RpbWVvdXQnIH0sXG4gICAgeyBkaWRXYXJuOiBmYWxzZSwgc2hvdWxkRGVsZXRlOiB0cnVlLCBuYW1lOiAnZHNjcFRhZ2dpbmcnLCBuZXdOYW1lOiAnZW5hYmxlRHNjcCcgfSxcbiAgICB7IGRpZFdhcm46IGZhbHNlLCBzaG91bGREZWxldGU6IHRydWUsIG5hbWU6ICdpY2VTZXJ2ZXJzVGltZW91dCcgfSxcbiAgICB7IGRpZFdhcm46IGZhbHNlLCBzaG91bGREZWxldGU6IGZhbHNlLCBuYW1lOiAnZXZlbnRMaXN0ZW5lcicsIG5ld05hbWU6ICdWaWRlby5Mb2dnZXInIH0sXG4gICAgeyBkaWRXYXJuOiBmYWxzZSwgc2hvdWxkRGVsZXRlOiBmYWxzZSwgbmFtZTogJ2xvZ0xldmVsJywgbmV3TmFtZTogJ1ZpZGVvLkxvZ2dlcicgfSxcbl0pO1xudmFyIGRlcHJlY2F0ZWRWaWRlb0JhbmR3aWR0aFByb2ZpbGVPcHRpb25zID0gbmV3IFNldChbXG4gICAgeyBkaWRXYXJuOiBmYWxzZSwgc2hvdWxkRGVsZXRlOiBmYWxzZSwgbmFtZTogJ21heFRyYWNrcycsIG5ld05hbWU6ICdiYW5kd2lkdGhQcm9maWxlLnZpZGVvLmNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCcgfSxcbiAgICB7IGRpZFdhcm46IGZhbHNlLCBzaG91bGREZWxldGU6IGZhbHNlLCBuYW1lOiAncmVuZGVyRGltZW5zaW9ucycsIG5ld05hbWU6ICdiYW5kd2lkdGhQcm9maWxlLnZpZGVvLmNvbnRlbnRQcmVmZXJlbmNlc01vZGUnIH0sXG5dKTtcbi8qKlxuICogQ29ubmVjdCB0byBhIHtAbGluayBSb29tfS5cbiAqICAgPGJyPjxicj5cbiAqICAgQnkgZGVmYXVsdCwgdGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgYWNxdWlyZSBhbiBhcnJheSBjb250YWluaW5nIGFcbiAqICAge0BsaW5rIExvY2FsQXVkaW9UcmFja30gYW5kIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IGJlZm9yZSBjb25uZWN0aW5nIHRvXG4gKiAgIHRoZSB7QGxpbmsgUm9vbX0uIFRoZXNlIHdpbGwgYmUgc3RvcHBlZCB3aGVuIHlvdSBkaXNjb25uZWN0IGZyb20gdGhlXG4gKiAgIHtAbGluayBSb29tfS5cbiAqICAgPGJyPjxicj5cbiAqICAgWW91IGNhbiBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBieSBzcGVjaWZ5aW5nXG4gKiAgIDxjb2RlPm9wdGlvbnM8L2NvZGU+LiBGb3IgZXhhbXBsZSwgcmF0aGVyIHRoYW4gYWNxdWlyaW5nIGFcbiAqICAge0BsaW5rIExvY2FsQXVkaW9UcmFja30gYW5kIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IGF1dG9tYXRpY2FsbHksIHlvdSBjYW5cbiAqICAgcGFzcyB5b3VyIG93biBhcnJheSB3aGljaCB5b3UgY2FuIHN0b3AgeW91cnNlbGYuIFNlZSB7QGxpbmsgQ29ubmVjdE9wdGlvbnN9XG4gKiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogICA8YnI+PGJyPlxuICogICBBIFwidHJhY2tQdWJsaXNoZWRcIiBldmVudCBpcyBmaXJlZCBvbiB0aGUge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IGZvciBlYWNoXG4gKiAgIExvY2FsVHJhY2sgdGhhdCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC4gQSBcInRyYWNrUHVibGljYXRpb25GYWlsZWRcIiBldmVudFxuICogICBpcyBmaXJlZCBmb3IgZWFjaCBMb2NhbFRyYWNrIHRoYXQgd2FzIGZhaWxlZCB0byBiZSBwdWJsaXNoZWQuXG4gKiBAYWxpYXMgbW9kdWxlOnR3aWxpby12aWRlby5jb25uZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBUaGUgQWNjZXNzIFRva2VuIHN0cmluZ1xuICogQHBhcmFtIHtDb25uZWN0T3B0aW9uc30gW29wdGlvbnNdIC0gT3B0aW9ucyB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciwgaW52YWxpZCBvcHRpb25zIGFyZSBpZ25vcmVkLlxuICogQHJldHVybnMge0NhbmNlbGFibGVQcm9taXNlPFJvb20+fVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAqIEB0aHJvd3Mge1R3aWxpb0Vycm9yfVxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICogQGV4YW1wbGVcbiAqIHZhciBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICogdmFyIHRva2VuID0gZ2V0QWNjZXNzVG9rZW4oKTtcbiAqIFZpZGVvLmNvbm5lY3QodG9rZW4sIHtcbiAqICAgbmFtZTogJ215LWNvb2wtcm9vbSdcbiAqIH0pLnRoZW4oZnVuY3Rpb24ocm9vbSkge1xuICogICByb29tLm9uKCdwYXJ0aWNpcGFudENvbm5lY3RlZCcsIGZ1bmN0aW9uKHBhcnRpY2lwYW50KSB7XG4gKiAgICAgY29uc29sZS5sb2cocGFydGljaXBhbnQuaWRlbnRpdHkgKyAnIGhhcyBjb25uZWN0ZWQnKTtcbiAqICAgfSk7XG5cbiAqICAgcm9vbS5vbmNlKCdkaXNjb25uZWN0ZWQnLCBmdW5jdGlvbigpIHtcbiAqICAgICBjb25zb2xlLmxvZygnWW91IGxlZnQgdGhlIFJvb206Jywgcm9vbS5uYW1lKTtcbiAqICAgfSk7XG4gKiB9KS5jYXRjaChlcnJvciA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdDb3VsZCBub3QgY29ubmVjdCB0byB0aGUgUm9vbTonLCBlcnJvci5tZXNzYWdlKTtcbiAqIH0pO1xuICogQGV4YW1wbGVcbiAqIHZhciBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICogdmFyIHRva2VuID0gZ2V0QWNjZXNzVG9rZW4oKTtcbiAqXG4gKiAvLyBDb25uZWN0IHdpdGggYXVkaW8tb25seVxuICogVmlkZW8uY29ubmVjdCh0b2tlbiwge1xuICogICBuYW1lOiAnbXktY29vbC1yb29tJyxcbiAqICAgYXVkaW86IHRydWVcbiAqIH0pLnRoZW4oZnVuY3Rpb24ocm9vbSkge1xuICogICByb29tLm9uKCdwYXJ0aWNpcGFudENvbm5lY3RlZCcsIGZ1bmN0aW9uKHBhcnRpY2lwYW50KSB7XG4gKiAgICAgY29uc29sZS5sb2cocGFydGljaXBhbnQuaWRlbnRpdHkgKyAnIGhhcyBjb25uZWN0ZWQnKTtcbiAqICAgfSk7XG4gKlxuICogICByb29tLm9uY2UoJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uKCkge1xuICogICAgIGNvbnNvbGUubG9nKCdZb3UgbGVmdCB0aGUgUm9vbTonLCByb29tLm5hbWUpO1xuICogICB9KTtcbiAqIH0pLmNhdGNoKGVycm9yID0+IHtcbiAqICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBjb25uZWN0IHRvIHRoZSBSb29tOicsIGVycm9yLm1lc3NhZ2UpO1xuICogfSk7XG4gKiBAZXhhbXBsZVxuICogdmFyIFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gKiB2YXIgdG9rZW4gPSBnZXRBY2Nlc3NUb2tlbigpO1xuICpcbiAqIC8vIENvbm5lY3Qgd2l0aCBtZWRpYSBhY3F1aXJlZCB1c2luZyBnZXRVc2VyTWVkaWEoKVxuICogbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICogICBhdWRpbzogdHJ1ZSxcbiAqICAgdmlkZW86IHRydWVcbiAqIH0pLnRoZW4oZnVuY3Rpb24obWVkaWFTdHJlYW0pIHtcbiAqICAgcmV0dXJuIFZpZGVvLmNvbm5lY3QodG9rZW4sIHtcbiAqICAgICBuYW1lOiAnbXktY29vbC1yb29tJyxcbiAqICAgICB0cmFja3M6IG1lZGlhU3RyZWFtLmdldFRyYWNrcygpXG4gKiAgIH0pO1xuICogfSkudGhlbihmdW5jdGlvbihyb29tKSB7XG4gKiAgIHJvb20ub24oJ3BhcnRpY2lwYW50Q29ubmVjdGVkJywgZnVuY3Rpb24ocGFydGljaXBhbnQpIHtcbiAqICAgICBjb25zb2xlLmxvZyhwYXJ0aWNpcGFudC5pZGVudGl0eSArICcgaGFzIGNvbm5lY3RlZCcpO1xuICogICB9KTtcbiAqXG4gKiAgIHJvb20ub25jZSgnZGlzY29ubmVjdGVkJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ1lvdSBsZWZ0IHRoZSBSb29tOicsIHJvb20ubmFtZSk7XG4gKiAgIH0pO1xuICogfSkuY2F0Y2goZXJyb3IgPT4ge1xuICogICBjb25zb2xlLmxvZygnQ291bGQgbm90IGNvbm5lY3QgdG8gdGhlIFJvb206JywgZXJyb3IubWVzc2FnZSk7XG4gKiB9KTtcbiAqIEBleGFtcGxlXG4gKiB2YXIgVmlkZW8gPSByZXF1aXJlKCd0d2lsaW8tdmlkZW8nKTtcbiAqIHZhciB0b2tlbiA9IGdldEFjY2Vzc1Rva2VuKCk7XG4gKlxuICogLy8gQ29ubmVjdCB3aXRoIGN1c3RvbSBuYW1lcyBmb3IgTG9jYWxBdWRpb1RyYWNrIGFuZCBMb2NhbFZpZGVvVHJhY2tcbiAqIFZpZGVvLmNvbm5lY3QodG9rZW4sIHtcbiAqICAgbmFtZTogJ215LWNvb2wtcm9vbSdcbiAqICAgYXVkaW86IHsgbmFtZTogJ21pY3JvcGhvbmUnIH0sXG4gKiAgIHZpZGVvOiB7IG5hbWU6ICdjYW1lcmEnIH1cbiAqIH0pLnRoZW4oZnVuY3Rpb24ocm9vbSkge1xuICogICByb29tLmxvY2FsUGFydGljaXBhbnQub24oJ3RyYWNrUHVibGlzaGVkJywgZnVuY3Rpb24ocHVibGljYXRpb24pIHtcbiAqICAgICBjb25zb2xlLmxvZygnVGhlIExvY2FsVHJhY2sgXCInICsgcHVibGljYXRpb24udHJhY2tOYW1lICsgJ1wiIHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkJyk7XG4gKiAgIH0pO1xuICogfSkuY2F0Y2goZXJyb3IgPT4ge1xuICogICBjb25zb2xlLmxvZygnQ291bGQgbm90IGNvbm5lY3QgdG8gdGhlIFJvb206JywgZXJyb3IubWVzc2FnZSk7XG4gKiB9KTtcbiAqIEBleGFtcGxlXG4gKiAvLyBBY2Nlc3NpbmcgdGhlIFNESyBsb2dnZXJcbiAqIHZhciB7IExvZ2dlciwgY29ubmVjdCB9ID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gKiB2YXIgdG9rZW4gPSBnZXRBY2Nlc3NUb2tlbigpO1xuICpcbiAqIHZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKCd0d2lsaW8tdmlkZW8nKTtcbiAqXG4gKiAvLyBMaXN0ZW4gZm9yIGxvZ3NcbiAqIHZhciBvcmlnaW5hbEZhY3RvcnkgPSBsb2dnZXIubWV0aG9kRmFjdG9yeTtcbiAqIGxvZ2dlci5tZXRob2RGYWN0b3J5ID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGxvZ0xldmVsLCBsb2dnZXJOYW1lKSB7XG4gKiAgIHZhciBtZXRob2QgPSBvcmlnaW5hbEZhY3RvcnkobWV0aG9kTmFtZSwgbG9nTGV2ZWwsIGxvZ2dlck5hbWUpO1xuICpcbiAqICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRldGltZSwgbG9nTGV2ZWwsIGNvbXBvbmVudCwgbWVzc2FnZSwgZGF0YSkge1xuICogICAgIG1ldGhvZChkYXRldGltZSwgbG9nTGV2ZWwsIGNvbXBvbmVudCwgbWVzc2FnZSwgZGF0YSk7XG4gKiAgICAgLy8gU2VuZCB0byB5b3VyIG93biBzZXJ2ZXJcbiAqICAgICBwb3N0RGF0YVRvU2VydmVyKGFyZ3VtZW50cyk7XG4gKiAgIH07XG4gKiB9O1xuICogbG9nZ2VyLnNldExldmVsKCdkZWJ1ZycpO1xuICpcbiAqIGNvbm5lY3QodG9rZW4sIHtcbiAqICAgbmFtZTogJ215LWNvb2wtcm9vbSdcbiAqIH0pLnRoZW4oZnVuY3Rpb24ocm9vbSkge1xuICogICByb29tLm9uKCdwYXJ0aWNpcGFudENvbm5lY3RlZCcsIGZ1bmN0aW9uKHBhcnRpY2lwYW50KSB7XG4gKiAgICAgY29uc29sZS5sb2cocGFydGljaXBhbnQuaWRlbnRpdHkgKyAnIGhhcyBjb25uZWN0ZWQnKTtcbiAqICAgfSk7XG4gKiB9KS5jYXRjaChlcnJvciA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdDb3VsZCBub3QgY29ubmVjdCB0byB0aGUgUm9vbTonLCBlcnJvci5tZXNzYWdlKTtcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBjb25uZWN0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICghaXNOb25BcnJheU9iamVjdChvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gQ2FuY2VsYWJsZVByb21pc2UucmVqZWN0KEUuSU5WQUxJRF9UWVBFKCdvcHRpb25zJywgJ29iamVjdCcpKTtcbiAgICB9XG4gICAgdmFyIExvZyA9IG9wdGlvbnMuTG9nIHx8IERlZmF1bHRMb2c7XG4gICAgdmFyIGxvZ2dlck5hbWUgPSBvcHRpb25zLmxvZ2dlck5hbWUgfHwgREVGQVVMVF9MT0dHRVJfTkFNRTtcbiAgICB2YXIgbG9nTGV2ZWwgPSBvcHRpb25zLmxvZ0xldmVsIHx8IERFRkFVTFRfTE9HX0xFVkVMO1xuICAgIHZhciBsb2dMZXZlbHMgPSBidWlsZExvZ0xldmVscyhsb2dMZXZlbCk7XG4gICAgdmFyIGxvZ0NvbXBvbmVudE5hbWUgPSBcIltjb25uZWN0ICNcIiArICsrY29ubmVjdENhbGxzICsgXCJdXCI7XG4gICAgdmFyIGxvZztcbiAgICB0cnkge1xuICAgICAgICBsb2cgPSBuZXcgTG9nKCdkZWZhdWx0JywgbG9nQ29tcG9uZW50TmFtZSwgbG9nTGV2ZWxzLCBsb2dnZXJOYW1lKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBDYW5jZWxhYmxlUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICAvLyBOT1RFKGNzYW50b3MpOiBMb2cgYSB3YXJuaW5nIGZvciB0aGUgZGVwcmVjYXRlZCBDb25uZWN0T3B0aW9ucyBwcm9wZXJ0aWVzLlxuICAgIC8vIFRoZSB3YXJuaW5nIGlzIGRpc3BsYXllZCBvbmx5IGZvciB0aGUgZmlyc3QgY2FsbCB0byBjb25uZWN0KCkgcGVyIGJyb3dzZXIgc2Vzc2lvbi5cbiAgICAvLyBBZGRpdGlvbmFsbHksIHRoZSBvcHRpb25zIHRoYXQgYXJlIG5vIGxvbmdlciBuZWVkZWQgd2lsbCBiZSByZW1vdmVkLlxuICAgIGRlcHJlY2F0ZU9wdGlvbnMob3B0aW9ucywgJ0Nvbm5lY3RPcHRpb25zJywgbG9nLCBkZXByZWNhdGVkQ29ubmVjdE9wdGlvbnNQcm9wcyk7XG4gICAgdmFyIGFkYXB0aXZlU2ltdWxjYXN0ID0gb3B0aW9ucy5wcmVmZXJyZWRWaWRlb0NvZGVjcyA9PT0gJ2F1dG8nO1xuICAgIGlmIChhZGFwdGl2ZVNpbXVsY2FzdCkge1xuICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogZW5hYmxlIGFkYXB0aXZlU2ltdWxjYXN0LlxuICAgICAgICBvcHRpb25zLnByZWZlcnJlZFZpZGVvQ29kZWNzID0gW3sgY29kZWM6ICdWUDgnLCBzaW11bGNhc3Q6IHRydWUsIGFkYXB0aXZlU2ltdWxjYXN0OiB0cnVlIH1dO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tYXhWaWRlb0JpdHJhdGUgJiYgYWRhcHRpdmVTaW11bGNhc3QpIHtcbiAgICAgICAgbG9nLmVycm9yKCdDb25uZWN0T3B0aW9ucyBcIm1heFZpZGVvQml0cmF0ZVwiIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggXCJwcmVmZXJyZWRWaWRlb0NvZGVjcz1hdXRvXCInKTtcbiAgICAgICAgcmV0dXJuIENhbmNlbGFibGVQcm9taXNlLnJlamVjdChFLklMTEVHQUxfSU5WT0tFKCdjb25uZWN0JywgJ0Nvbm5lY3RPcHRpb25zIFwibWF4VmlkZW9CaXRyYXRlXCIgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBcInByZWZlcnJlZFZpZGVvQ29kZWNzPWF1dG9cIicpKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBhdXRvbWF0aWNTdWJzY3JpcHRpb246IHRydWUsXG4gICAgICAgIGRvbWluYW50U3BlYWtlcjogZmFsc2UsXG4gICAgICAgIGVuYWJsZURzY3A6IGZhbHNlLFxuICAgICAgICBlbnZpcm9ubWVudDogREVGQVVMVF9FTlZJUk9OTUVOVCxcbiAgICAgICAgZXZlbnRMaXN0ZW5lcjogbnVsbCxcbiAgICAgICAgaW5zaWdodHM6IHRydWUsXG4gICAgICAgIExvY2FsQXVkaW9UcmFjazogTG9jYWxBdWRpb1RyYWNrLFxuICAgICAgICBMb2NhbERhdGFUcmFjazogTG9jYWxEYXRhVHJhY2ssXG4gICAgICAgIExvY2FsUGFydGljaXBhbnQ6IExvY2FsUGFydGljaXBhbnQsXG4gICAgICAgIExvY2FsVmlkZW9UcmFjazogTG9jYWxWaWRlb1RyYWNrLFxuICAgICAgICBMb2c6IExvZyxcbiAgICAgICAgTWVkaWFTdHJlYW1UcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgICAgICAgbG9nZ2VyTmFtZTogbG9nZ2VyTmFtZSxcbiAgICAgICAgbG9nTGV2ZWw6IGxvZ0xldmVsLFxuICAgICAgICBtYXhBdWRpb0JpdHJhdGU6IG51bGwsXG4gICAgICAgIG1heFZpZGVvQml0cmF0ZTogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgbmV0d29ya01vbml0b3I6IHRydWUsXG4gICAgICAgIG5ldHdvcmtRdWFsaXR5OiBmYWxzZSxcbiAgICAgICAgcHJlZmVycmVkQXVkaW9Db2RlY3M6IFtdLFxuICAgICAgICBwcmVmZXJyZWRWaWRlb0NvZGVjczogW10sXG4gICAgICAgIHJlYWxtOiBERUZBVUxUX1JFQUxNLFxuICAgICAgICByZWdpb246IERFRkFVTFRfUkVHSU9OLFxuICAgICAgICBzaWduYWxpbmc6IFNpZ25hbGluZ1YyXG4gICAgfSwgZmlsdGVyT2JqZWN0KG9wdGlvbnMpKTtcbiAgICAvKiBlc2xpbnQgbmV3LWNhcDowICovXG4gICAgdmFyIGV2ZW50UHVibGlzaGVyT3B0aW9ucyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53c1NlcnZlckluc2lnaHRzID09PSAnc3RyaW5nJykge1xuICAgICAgICBldmVudFB1Ymxpc2hlck9wdGlvbnMuZ2F0ZXdheSA9IG9wdGlvbnMud3NTZXJ2ZXJJbnNpZ2h0cztcbiAgICB9XG4gICAgdmFyIEV2ZW50UHVibGlzaGVyID0gb3B0aW9ucy5pbnNpZ2h0cyA/IEluc2lnaHRzUHVibGlzaGVyIDogTnVsbEluc2lnaHRzUHVibGlzaGVyO1xuICAgIHZhciBldmVudFB1Ymxpc2hlciA9IG5ldyBFdmVudFB1Ymxpc2hlcih0b2tlbiwgU0RLX05BTUUsIFNES19WRVJTSU9OLCBvcHRpb25zLmVudmlyb25tZW50LCBvcHRpb25zLnJlYWxtLCBldmVudFB1Ymxpc2hlck9wdGlvbnMpO1xuICAgIHZhciB3c1NlcnZlciA9IFdTX1NFUlZFUihvcHRpb25zLmVudmlyb25tZW50LCBvcHRpb25zLnJlZ2lvbik7XG4gICAgdmFyIGV2ZW50T2JzZXJ2ZXIgPSBuZXcgRXZlbnRPYnNlcnZlcihldmVudFB1Ymxpc2hlciwgRGF0ZS5ub3coKSwgbG9nLCBvcHRpb25zLmV2ZW50TGlzdGVuZXIpO1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgZXZlbnRPYnNlcnZlcjogZXZlbnRPYnNlcnZlciwgd3NTZXJ2ZXI6IHdzU2VydmVyIH0sIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMubG9nID0gbG9nO1xuICAgIC8vIE5PVEUobXJvYmVydHMpOiBQcmludCB0aGUgU2FmYXJpIHdhcm5pbmcgb25jZSBpZiB0aGUgbG9nLWxldmVsIGlzIGF0IGxlYXN0XG4gICAgLy8gXCJ3YXJuXCIsIGkuZS4gbmVpdGhlciBcImVycm9yXCIgbm9yIFwib2ZmXCIuXG4gICAgLy8gTk9URShtbWFsYXZhbGxpKTogUHJpbnQgdGhlIFNhZmFyaSB3YXJuaW5nIG9ubHkgZm9yIHZlcnNpb25zIDEyLjAgYW5kIGJlbG93LlxuICAgIGlmIChpc1NhZmFyaVdpdGhvdXRWUDhTdXBwb3J0XG4gICAgICAgICYmICFkaWRQcmludFNhZmFyaVdhcm5pbmdcbiAgICAgICAgJiYgKGxvZy5sb2dMZXZlbCAhPT0gJ2Vycm9yJyAmJiBsb2cubG9nTGV2ZWwgIT09ICdvZmYnKSkge1xuICAgICAgICBkaWRQcmludFNhZmFyaVdhcm5pbmcgPSB0cnVlO1xuICAgICAgICBsb2cud2FybihbXG4gICAgICAgICAgICAnU3VwcG9ydCBmb3IgU2FmYXJpIDEyLjAgYW5kIGJlbG93IGlzIGxpbWl0ZWQgYmVjYXVzZSBpdCBkb2VzIG5vdCBzdXBwb3J0IFZQOC4nLFxuICAgICAgICAgICAgJ1RoaXMgbWVhbnMgeW91IG1heSBleHBlcmllbmNlIGNvZGVjIGlzc3VlcyBpbiBHcm91cCBSb29tcy4gWW91IG1heSBhbHNvJyxcbiAgICAgICAgICAgICdleHBlcmllbmNlIGNvZGVjIGlzc3VlcyBpbiBQZWVyLXRvLVBlZXIgKFAyUCkgUm9vbXMgY29udGFpbmluZyBBbmRyb2lkLSBvcicsXG4gICAgICAgICAgICAnaU9TLWJhc2VkIFBhcnRpY2lwYW50cyB3aG8gZG8gbm90IHN1cHBvcnQgSC4yNjQuIEhvd2V2ZXIsIFAyUCBSb29tcycsXG4gICAgICAgICAgICAnd2l0aCBicm93c2VyLWJhc2VkIFBhcnRpY2lwYW50cyBzaG91bGQgd29yay4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHBsZWFzZScsXG4gICAgICAgICAgICAncmVmZXIgdG8gdGhpcyBndWlkZTogaHR0cHM6Ly93d3cudHdpbGlvLmNvbS9kb2NzL3ZpZGVvL2phdmFzY3JpcHQtdjItZGV2ZWxvcGluZy1zYWZhcmktMTEnXG4gICAgICAgIF0uam9pbignICcpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIENhbmNlbGFibGVQcm9taXNlLnJlamVjdChFLklOVkFMSURfVFlQRSgndG9rZW4nLCAnc3RyaW5nJykpO1xuICAgIH1cbiAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBUaGUgUm9vbSBcIm5hbWVcIiBpbiBcIm9wdGlvbnNcIiB3YXMgYmVpbmcgdXNlZFxuICAgIC8vIGFzIHRoZSBMb2NhbFRyYWNrIG5hbWUgaW4gYXNMb2NhbFRyYWNrKCkuIFNvIHdlIHBhc3MgYSBjb3B5IG9mXG4gICAgLy8gXCJvcHRpb25zXCIgd2l0aG91dCB0aGUgXCJuYW1lXCIuXG4gICAgdmFyIGxvY2FsVHJhY2tPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgZGVsZXRlIGxvY2FsVHJhY2tPcHRpb25zLm5hbWU7XG4gICAgaWYgKCd0cmFja3MnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMudHJhY2tzKSkge1xuICAgICAgICAgICAgcmV0dXJuIENhbmNlbGFibGVQcm9taXNlLnJlamVjdChFLklOVkFMSURfVFlQRSgnb3B0aW9ucy50cmFja3MnLCAnQXJyYXkgb2YgTG9jYWxBdWRpb1RyYWNrLCBMb2NhbFZpZGVvVHJhY2sgb3IgTWVkaWFTdHJlYW1UcmFjaycpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb3B0aW9ucy50cmFja3MgPSBvcHRpb25zLnRyYWNrcy5tYXAoZnVuY3Rpb24gKHRyYWNrKSB7IHJldHVybiBhc0xvY2FsVHJhY2sodHJhY2ssIGxvY2FsVHJhY2tPcHRpb25zKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2FuY2VsYWJsZVByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZUJhbmR3aWR0aFByb2ZpbGUob3B0aW9ucy5iYW5kd2lkdGhQcm9maWxlKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIENhbmNlbGFibGVQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIC8vIE5vdGUobXBhdHdhcmRoYW4pOiBcImNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbFwiIGFsbG93cyB0cmFja3MgdG8gYmUgc3dpdGNoZWQgb2ZmXG4gICAgLy8gYW5kIFwiY29udGVudFByZWZlcmVuY2VzTW9kZVwiIGFsbG93cyB0cmFjayBkaW1lbnNpb25zIHRvIGJlIHNwZWNpZmllZCBkeW5hbWljYWxseS5cbiAgICAvLyBUaGUgcHJvcGVydGllcyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIHZhbHVlcyBpbnRlcm5hbGx5OlxuICAgIC8vIDEpIFwiYXV0b1wiID0gc2RrIHdpbGwgZGVjaWRlIGFuZCBzZW5kIHRoZSBoaW50cy5cbiAgICAvLyAyKSBcIm1hbnVhbFwiIC0gYXBwIGNhbiB1c2UgYXBpIHRvIHNlbmQgdGhlIGhpbnRzLlxuICAgIC8vIDMpIFwiZGlzYWJsZWRcIiA9IGRvIG5vdCBlbmFibGUgdGhpcyBmZWF0dXJlLiAodGhpcyBpcyBpbnRlcm5hbCBvbmx5IHZhbHVlKVxuICAgIC8vICdkaXNhYmxlZCcgaXMgbmVlZGVkIGJlY2F1c2UgY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sIGFuZCBjb250ZW50UHJlZmVyZW5jZXNNb2RlIGFyZSBpbmNvbXBhdGlibGUgd2l0aFxuICAgIC8vIGRlcHJlY2F0ZWQgcHJvcGVydGllcyBtYXhUcmFja3MgYW5kIHJlbmRlckRpbWVuc2lvbnMgcmVzcGVjdGl2ZWx5LiBvbmNlIHdlIG1ha2UgQGJyZWFraW5nX3ZlcnNpb25fY2hhbmdlXG4gICAgLy8gd2UgY2FuIHJlbW92ZSAnZGlzYWJsZWQnIHN0YXRlIGFsb25nIHdpdGggbWF4VHJhY2tzIGFuZCByZW5kZXJEaW1lbnNpb25zLlxuICAgIG9wdGlvbnMuY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sID0gJ2Rpc2FibGVkJzsgLy8gc2hvdWxkIHNkayB0dXJuIG9mZiBpZGxlIHRyYWNrcyBhdXRvbWF0aWNhbGx5P1xuICAgIG9wdGlvbnMuY29udGVudFByZWZlcmVuY2VzTW9kZSA9ICdkaXNhYmxlZCc7IC8vIHNob3VsZCBzZGsgIHVzZSB2aWRlbyBlbGVtZW50IGRpbWVuc2lvbnMgZm9yIGNvbnRlbnQgaGludHM/XG4gICAgaWYgKG9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZSkge1xuICAgICAgICBvcHRpb25zLmNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCA9ICdhdXRvJztcbiAgICAgICAgb3B0aW9ucy5jb250ZW50UHJlZmVyZW5jZXNNb2RlID0gJ2F1dG8nO1xuICAgICAgICBpZiAob3B0aW9ucy5iYW5kd2lkdGhQcm9maWxlLnZpZGVvKSB7XG4gICAgICAgICAgICAvLyBsb2cgYW55IHdhcm5pbmdzIGFib3V0IGRlcHJlY2F0ZWQgYndwIG9wdGlvbnNcbiAgICAgICAgICAgIGRlcHJlY2F0ZU9wdGlvbnMob3B0aW9ucy5iYW5kd2lkdGhQcm9maWxlLnZpZGVvLCAnQ29ubmVjdE9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlbycsIGxvZywgZGVwcmVjYXRlZFZpZGVvQmFuZHdpZHRoUHJvZmlsZU9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCdtYXhUcmFja3MnIGluIG9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlbykge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gZGVwcmVjYXRlZCBtYXhUcmFja3MgaXMgc3BlY2lmaWVkLiBkaXNhYmxlIGNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sID0gJ2Rpc2FibGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlby5jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgPT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgPSAnbWFudWFsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sID0gJ2F1dG8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdtYXhUcmFja3MnIGluIG9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlbykge1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgbWF4VHJhY2tzIG92ZXIgdG8gbmV3IHByb3BlcnR5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBSU1AgcGF5bG9hZFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlby5tYXhTd2l0Y2hlZE9uVHJhY2tzID0gb3B0aW9ucy5iYW5kd2lkdGhQcm9maWxlLnZpZGVvLm1heFRyYWNrcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgncmVuZGVyRGltZW5zaW9ucycgaW4gb3B0aW9ucy5iYW5kd2lkdGhQcm9maWxlLnZpZGVvKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb250ZW50UHJlZmVyZW5jZXNNb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlby5jb250ZW50UHJlZmVyZW5jZXNNb2RlID09PSAnbWFudWFsJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29udGVudFByZWZlcmVuY2VzTW9kZSA9ICdtYW51YWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb250ZW50UHJlZmVyZW5jZXNNb2RlID0gJ2F1dG8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBTaWduYWxpbmcgPSBvcHRpb25zLnNpZ25hbGluZztcbiAgICB2YXIgc2lnbmFsaW5nID0gbmV3IFNpZ25hbGluZyhvcHRpb25zLndzU2VydmVyLCBvcHRpb25zKTtcbiAgICBsb2cuaW5mbygnQ29ubmVjdGluZyB0byBhIFJvb20nKTtcbiAgICBsb2cuZGVidWcoJ09wdGlvbnM6Jywgb3B0aW9ucyk7XG4gICAgdmFyIGVuY29kaW5nUGFyYW1ldGVycyA9IG5ldyBFbmNvZGluZ1BhcmFtZXRlcnNJbXBsKHtcbiAgICAgICAgbWF4QXVkaW9CaXRyYXRlOiBvcHRpb25zLm1heEF1ZGlvQml0cmF0ZSxcbiAgICAgICAgbWF4VmlkZW9CaXRyYXRlOiBvcHRpb25zLm1heFZpZGVvQml0cmF0ZVxuICAgIH0sIGFkYXB0aXZlU2ltdWxjYXN0KTtcbiAgICB2YXIgcHJlZmVycmVkQ29kZWNzID0ge1xuICAgICAgICBhdWRpbzogb3B0aW9ucy5wcmVmZXJyZWRBdWRpb0NvZGVjcy5tYXAobm9ybWFsaXplQ29kZWNTZXR0aW5ncyksXG4gICAgICAgIHZpZGVvOiBvcHRpb25zLnByZWZlcnJlZFZpZGVvQ29kZWNzLm1hcChub3JtYWxpemVDb2RlY1NldHRpbmdzKVxuICAgIH07XG4gICAgdmFyIG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbiA9IG5ldyBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25JbXBsKGlzTm9uQXJyYXlPYmplY3Qob3B0aW9ucy5uZXR3b3JrUXVhbGl0eSkgPyBvcHRpb25zLm5ldHdvcmtRdWFsaXR5IDoge30pO1xuICAgIC8vIENyZWF0ZSBhIENhbmNlbGFibGVSb29tUHJvbWlzZTxSb29tPiB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZXNlIHN0ZXBzOlxuICAgIC8vIDEgLSBHZXQgdGhlIExvY2FsVHJhY2tzLlxuICAgIC8vIDIgLSBDcmVhdGUgdGhlIExvY2FsUGFydGljaXBhbnQgdXNpbmcgb3B0aW9ucy50cmFja3MuXG4gICAgLy8gMyAtIENvbm5lY3QgdG8gcnRjLXJvb20tc2VydmljZSBhbmQgY3JlYXRlIHRoZSBSb29tU2lnbmFsaW5nLlxuICAgIC8vIDQgLSBDcmVhdGUgdGhlIFJvb20gYW5kIHRoZW4gcmVzb2x2ZSB0aGUgQ2FuY2VsYWJsZVByb21pc2UuXG4gICAgdmFyIGNhbmNlbGFibGVSb29tUHJvbWlzZSA9IGNyZWF0ZUNhbmNlbGFibGVSb29tUHJvbWlzZShnZXRMb2NhbFRyYWNrcy5iaW5kKG51bGwsIG9wdGlvbnMpLCBjcmVhdGVMb2NhbFBhcnRpY2lwYW50LmJpbmQobnVsbCwgc2lnbmFsaW5nLCBsb2csIGVuY29kaW5nUGFyYW1ldGVycywgbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uLCBvcHRpb25zKSwgY3JlYXRlUm9vbVNpZ25hbGluZy5iaW5kKG51bGwsIHRva2VuLCBvcHRpb25zLCBzaWduYWxpbmcsIGVuY29kaW5nUGFyYW1ldGVycywgcHJlZmVycmVkQ29kZWNzKSwgY3JlYXRlUm9vbS5iaW5kKG51bGwsIG9wdGlvbnMpKTtcbiAgICBjYW5jZWxhYmxlUm9vbVByb21pc2UudGhlbihmdW5jdGlvbiAocm9vbSkge1xuICAgICAgICBldmVudFB1Ymxpc2hlci5jb25uZWN0KHJvb20uc2lkLCByb29tLmxvY2FsUGFydGljaXBhbnQuc2lkKTtcbiAgICAgICAgbG9nLmluZm8oJ0Nvbm5lY3RlZCB0byBSb29tOicsIHJvb20udG9TdHJpbmcoKSk7XG4gICAgICAgIGxvZy5pbmZvKCdSb29tIG5hbWU6Jywgcm9vbS5uYW1lKTtcbiAgICAgICAgbG9nLmRlYnVnKCdSb29tOicsIHJvb20pO1xuICAgICAgICByb29tLm9uY2UoJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50UHVibGlzaGVyLmRpc2Nvbm5lY3QoKTsgfSk7XG4gICAgICAgIHJldHVybiByb29tO1xuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBldmVudFB1Ymxpc2hlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIGlmIChjYW5jZWxhYmxlUm9vbVByb21pc2UuX2lzQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgIGxvZy5pbmZvKCdBdHRlbXB0IHRvIGNvbm5lY3QgdG8gYSBSb29tIHdhcyBjYW5jZWxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nLmluZm8oJ0Vycm9yIHdoaWxlIGNvbm5lY3RpbmcgdG8gYSBSb29tOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjYW5jZWxhYmxlUm9vbVByb21pc2U7XG59XG4vKipcbiAqIFlvdSBtYXkgcGFzcyB0aGVzZSBvcHRpb25zIHRvIHtAbGluayBjb25uZWN0fSBpbiBvcmRlciB0byBvdmVycmlkZSB0aGVcbiAqIGRlZmF1bHQgYmVoYXZpb3IuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBDb25uZWN0T3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufENyZWF0ZUxvY2FsVHJhY2tPcHRpb25zfSBbYXVkaW89dHJ1ZV0gLSBXaGV0aGVyIG9yIG5vdCB0b1xuICogICBnZXQgbG9jYWwgYXVkaW8gd2l0aCA8Y29kZT5nZXRVc2VyTWVkaWE8L2NvZGU+IHdoZW4gPGNvZGU+dHJhY2tzPC9jb2RlPlxuICogICBhcmUgbm90IHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXV0b21hdGljU3Vic2NyaXB0aW9uPXRydWVdIC0gQnkgZGVmYXVsdCwgeW91IHdpbGwgc3Vic2NyaWJlXG4gKiAgIHRvIGFsbCBSZW1vdGVUcmFja3Mgc2hhcmVkIGJ5IG90aGVyIFBhcnRpY2lwYW50cyBpbiBhIFJvb20uIFlvdSBjYW4gbm93IG92ZXJyaWRlIHRoaXNcbiAqICAgYmVoYXZpb3IgYnkgc2V0dGluZyB0aGlzIGZsYWcgdG8gPGNvZGU+ZmFsc2U8L2NvZGU+LiBJdCB3aWxsIG1ha2Ugc3VyZSB0aGF0IHlvdSB3aWxsXG4gKiAgIG5vdCBzdWJzY3JpYmUgdG8gYW55IFJlbW90ZVRyYWNrIGluIGEgR3JvdXAgb3IgU21hbGwgR3JvdXAgUm9vbS4gU2V0dGluZyBpdCB0b1xuICogICA8Y29kZT50cnVlPC9jb2RlPiwgb3Igbm90IHNldHRpbmcgaXQgYXQgYWxsIHByZXNlcnZlcyB0aGUgZGVmYXVsdCBiZWhhdmlvci4gVGhpc1xuICogICBmbGFnIGRvZXMgbm90IGhhdmUgYW55IGVmZmVjdCBpbiBhIFBlZXItdG8tUGVlciBSb29tLlxuICogQHByb3BlcnR5IHtCYW5kd2lkdGhQcm9maWxlfSBbYmFuZHdpZHRoUHJvZmlsZV0gLSBZb3UgY2FuIG9wdGlvbmFsbHkgY29uZmlndXJlXG4gKiAgIGhvdyB5b3VyIGF2YWlsYWJsZSBkb3dubGluayBiYW5kd2lkdGggaXMgc2hhcmVkIGFtb25nIHRoZSBSZW1vdGVUcmFja3MgeW91IGhhdmUgc3Vic2NyaWJlZFxuICogICB0byBpbiBhIEdyb3VwIFJvb20uIEJ5IGRlZmF1bHQsIGJhbmR3aWR0aCBpcyBzaGFyZWQgZXF1YWxseSBhbW9uZyB0aGUgUmVtb3RlVHJhY2tzLlxuICogICBUaGlzIGhhcyBubyBlZmZlY3QgaW4gUGVlci10by1QZWVyIFJvb21zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZG9taW5hbnRTcGVha2VyPWZhbHNlXSAtIFdoZXRoZXIgdG8gZW5hYmxlIHRoZSBEb21pbmFudFxuICogICBTcGVha2VyIEFQSSBvciBub3QuIFRoaXMgb25seSB0YWtlcyBlZmZlY3QgaW4gR3JvdXAgUm9vbXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkc2NwVGFnZ2luZz1mYWxzZV0gLSA8Y29kZT4oZGVwcmVjYXRlZDogdXNlIFwiZW5hYmxlRHNjcFwiIGluc3RlYWQpPC9jb2RlPlxuICogICBEU0NQIHRhZ2dpbmcgYWxsb3dzIHlvdSB0byByZXF1ZXN0IGVuaGFuY2VkIFFvUyB0cmVhdG1lbnQgZm9yIFJUUCBtZWRpYSBwYWNrZXRzIGZyb20gYW55XG4gKiAgIGZpcmV3YWxsIHRoYXQgdGhlIGNsaWVudCBtYXkgYmUgYmVoaW5kLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIDxjb2RlPnRydWU8L2NvZGU+IHdpbGxcbiAqICAgcmVxdWVzdCBEU0NQIHRhZ2dpbmcgZm9yIG1lZGlhIHBhY2tldHMgb24gc3VwcG9ydGVkIGJyb3dzZXJzIChvbmx5IENocm9tZSBzdXBwb3J0cyB0aGlzXG4gKiAgIGFzIG9mIG5vdykuIEF1ZGlvIHBhY2tldHMgd2lsbCBiZSBzZW50IHdpdGggRFNDUCBoZWFkZXIgdmFsdWUgc2V0IHRvIDB4Yjggd2hpY2ggY29ycmVzcG9uZHNcbiAqICAgdG8gRXhwZWRpdGVkIEZvcndhcmRpbmcgKEVGKS4gVmlkZW8gcGFja2V0cyB3aWxsIGJlIHNlbnQgd2l0aCBEU0NQIGhlYWRlciB2YWx1ZSBzZXQgdG8gMHg4OFxuICogICB3aGljaCBjb3JyZXNwb25kcyB0byBBc3N1cmVkIEZvcndhcmRpbmcgKEFGNDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZW5hYmxlRHNjcD1mYWxzZV0gLSBEU0NQIHRhZ2dpbmcgYWxsb3dzIHlvdSB0byByZXF1ZXN0IGVuaGFuY2VkXG4gKiAgIFFvUyB0cmVhdG1lbnQgZm9yIFJUUCBtZWRpYSBwYWNrZXRzIGZyb20gYW55IGZpcmV3YWxsIHRoYXQgdGhlIGNsaWVudCBtYXkgYmUgYmVoaW5kLlxuICogICBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIDxjb2RlPnRydWU8L2NvZGU+IHdpbGwgcmVxdWVzdCBEU0NQIHRhZ2dpbmcgZm9yIG1lZGlhIHBhY2tldHNcbiAqICAgb24gc3VwcG9ydGVkIGJyb3dzZXJzIChvbmx5IENocm9tZSBzdXBwb3J0cyB0aGlzIGFzIG9mIG5vdykuIEF1ZGlvIHBhY2tldHMgd2lsbCBiZVxuICogICBzZW50IHdpdGggRFNDUCBoZWFkZXIgdmFsdWUgc2V0IHRvIDB4Yjggd2hpY2ggY29ycmVzcG9uZHMgdG8gRXhwZWRpdGVkIEZvcndhcmRpbmcgKEVGKS5cbiAqICAgVmlkZW8gcGFja2V0cyB3aWxsIGJlIHNlbnQgd2l0aCBEU0NQIGhlYWRlciB2YWx1ZSBzZXQgdG8gMHg4OCB3aGljaCBjb3JyZXNwb25kcyB0b1xuICogICBBc3N1cmVkIEZvcndhcmRpbmcgKEFGNDEpLlxuICogQHByb3BlcnR5IHtFdmVudExpc3RlbmVyfSBbZXZlbnRMaXN0ZW5lcl0gLSA8Y29kZT4oZGVwcmVjYXRlZDogdXNlIFtWaWRlby5Mb2dnZXJdKG1vZHVsZS10d2lsaW8tdmlkZW8uaHRtbCk8L2NvZGU+XG4gKiAgIHlvdSBjYW4gbGlzdGVuIHRvIGZpbmUtZ3JhaW5lZCBldmVudHMgcmVsYXRlZCB0byBzaWduYWxpbmcgYW5kIG1lZGlhIHRoYXQgYXJlXG4gKiAgIG5vdCBhdmFpbGFibGUgaW4gdGhlIHB1YmxpYyBBUElzLiBUaGVzZSBldmVudHMgbWlnaHQgYmUgdXNlZnVsIGZvciB5b3VyIG93biByZXBvcnRpbmdcbiAqICAgYW5kIGRpYWdub3N0aWNzLlxuICogQHByb3BlcnR5IHtBcnJheTxSVENJY2VTZXJ2ZXI+fSBpY2VTZXJ2ZXJzIC0gT3ZlcnJpZGUgdGhlIFNUVU4gYW5kIFRVUk5cbiAqICAgc2VydmVycyB1c2VkIHdoZW4gY29ubmVjdGluZyB0byB7QGxpbmsgUm9vbX1zXG4gKiBAcHJvcGVydHkge1JUQ0ljZVRyYW5zcG9ydFBvbGljeX0gW2ljZVRyYW5zcG9ydFBvbGljeT1cImFsbFwiXSAtIE92ZXJyaWRlIHRoZVxuICogICBJQ0UgdHJhbnNwb3J0IHBvbGljeSB0byBiZSBvbmUgb2YgXCJyZWxheVwiIG9yIFwiYWxsXCJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2luc2lnaHRzPXRydWVdIC0gV2hldGhlciBwdWJsaXNoaW5nIGV2ZW50c1xuICogICB0byB0aGUgSW5zaWdodHMgZ2F0ZXdheSBpcyBlbmFibGVkIG9yIG5vdFxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBbbWF4QXVkaW9CaXRyYXRlPW51bGxdIC0gTWF4IG91dGdvaW5nIGF1ZGlvIGJpdHJhdGUgKGJwcyk7XG4gKiAgIEEgPGNvZGU+bnVsbDwvY29kZT4gb3IgYSA8Y29kZT4wPC9jb2RlPiB2YWx1ZSBkb2VzIG5vdCBzZXQgYW55IGJpdHJhdGUgbGltaXQ7XG4gKiAgIFRoaXMgdmFsdWUgaXMgc2V0IGFzIGEgaGludCBmb3IgdmFyaWFibGUgYml0cmF0ZSBjb2RlY3MsIGJ1dCB3aWxsIG5vdCB0YWtlXG4gKiAgIGVmZmVjdCBmb3IgZml4ZWQgYml0cmF0ZSBjb2RlY3M7IEJhc2VkIG9uIG91ciB0ZXN0cywgQ2hyb21lLCBGaXJlZm94IGFuZCBTYWZhcmlcbiAqICAgc3VwcG9ydCBhIGJpdHJhdGUgcmFuZ2Ugb2YgMTIwMDAgYnBzIHRvIDI1NjAwMCBicHMgZm9yIE9wdXMgY29kZWM7IFRoaXMgcGFyYW1ldGVyXG4gKiAgIGhhcyBubyBlZmZlY3Qgb24gaVNBQywgUENNVSBhbmQgUENNQSBjb2RlY3NcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gW21heFZpZGVvQml0cmF0ZT1udWxsXSAtIE1heCBvdXRnb2luZyB2aWRlbyBiaXRyYXRlIChicHMpO1xuICogICBBIDxjb2RlPm51bGw8L2NvZGU+IG9yIDxjb2RlPjA8L2NvZGU+IHZhbHVlIGRvZXMgbm90IHNldCBhbnkgYml0cmF0ZSBsaW1pdDtcbiAqICAgVGhpcyB2YWx1ZSBpcyBzZXQgYXMgYSBoaW50IGZvciB2YXJpYWJsZSBiaXRyYXRlIGNvZGVjcywgYnV0IHdpbGwgbm90IHRha2VcbiAqICAgZWZmZWN0IGZvciBmaXhlZCBiaXRyYXRlIGNvZGVjczsgQmFzZWQgb24gb3VyIHRlc3RzLCBDaHJvbWUsIEZpcmVmb3ggYW5kIFNhZmFyaVxuICogICBhbGwgc2VlbSB0byBzdXBwb3J0IGFuIGF2ZXJhZ2UgYml0cmF0ZSByYW5nZSBvZiAyMDAwMCBicHMgKDIwIGticHMpIHRvXG4gKiAgIDgwMDAwMDAgYnBzICg4IG1icHMpIGZvciBhIDcyMHAgVmlkZW9UcmFja1xuICogICBUaGlzIHBhcmFtZXRlciBtdXN0IG5vdCBiZSBzZXQgd2hlbiB3aGVuIHByZWZlcnJlZFZpZGVvQ29kZWNzIGlzIHNldCB0byBgYXV0b2AuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IFtuYW1lPW51bGxdIC0gU2V0IHRvIGNvbm5lY3QgdG8gYSB7QGxpbmsgUm9vbX0gYnkgbmFtZVxuICogQHByb3BlcnR5IHtib29sZWFufE5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbn0gW25ldHdvcmtRdWFsaXR5PWZhbHNlXSAtIFdoZXRoZXIgdG8gZW5hYmxlIHRoZSBOZXR3b3JrXG4gKiAgIFF1YWxpdHkgQVBJIG9yIG5vdC4gVGhpcyBvbmx5IHRha2VzIGVmZmVjdCBpbiBHcm91cCBSb29tcy4gUGFzcyBhIHtAbGluayBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb259XG4gKiAgIHRvIGNvbmZpZ3VyZSB2ZXJib3NpdHkgbGV2ZWxzIGZvciBuZXR3b3JrIHF1YWxpdHkgaW5mb3JtYXRpb24gZm9yIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fVxuICogICBhbmQge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fXMuIEEgPGNvZGU+dHJ1ZTwvY29kZT4gdmFsdWUgd2lsbCBzZXQgdGhlIHtAbGluayBOZXR3b3JrUXVhbGl0eVZlcmJvc2l0eX1cbiAqICAgZm9yIHRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gdG8ge0BsaW5rIE5ldHdvcmtRdWFsaXR5VmVyYm9zaXR5fTxjb2RlIHN0eWxlPVwicGFkZGluZzowIDBcIj4jbWluaW1hbDwvY29kZT5cbiAqICAgYW5kIHRoZSB7QGxpbmsgTmV0d29ya1F1YWxpdHlWZXJib3NpdHl9IGZvciB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9cyB0b1xuICogICB7QGxpbmsgTmV0d29ya1F1YWxpdHlWZXJib3NpdHl9PGNvZGUgc3R5bGU9XCJwYWRkaW5nOjAgMFwiPiNub25lPC9jb2RlPi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcmVnaW9uPSdnbGwnXSAtIFByZWZlcnJlZCBzaWduYWxpbmcgcmVnaW9uOyBCeSBkZWZhdWx0LCB5b3Ugd2lsbCBiZSBjb25uZWN0ZWQgdG8gdGhlXG4gKiAgIG5lYXJlc3Qgc2lnbmFsaW5nIHNlcnZlciBkZXRlcm1pbmVkIGJ5IGxhdGVuY3kgYmFzZWQgcm91dGluZy4gU2V0dGluZyBhIHZhbHVlIG90aGVyXG4gKiAgIHRoYW4gPGNvZGUgc3R5bGU9XCJwYWRkaW5nOjAgMFwiPmdsbDwvY29kZT4gYnlwYXNzZXMgcm91dGluZyBhbmQgZ3VhcmFudGVlcyB0aGF0IHNpZ25hbGluZyB0cmFmZmljIHdpbGwgYmVcbiAqICAgdGVybWluYXRlZCBpbiB0aGUgcmVnaW9uIHRoYXQgeW91IHByZWZlci4gUGxlYXNlIHJlZmVyIHRvIHRoaXMgPGEgaHJlZj1cImh0dHBzOi8vd3d3LnR3aWxpby5jb20vZG9jcy92aWRlby9pcC1hZGRyZXNzLXdoaXRlbGlzdGluZyNzaWduYWxpbmctY29tbXVuaWNhdGlvblwiIHRhcmdldD1cIl9ibGFua1wiPnRhYmxlPC9hPlxuICogICBmb3IgdGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIHNpZ25hbGluZyByZWdpb25zLlxuICogQHByb3BlcnR5IHtBcnJheTxBdWRpb0NvZGVjfEF1ZGlvQ29kZWNTZXR0aW5ncz59IFtwcmVmZXJyZWRBdWRpb0NvZGVjcz1bXV0gLSBQcmVmZXJyZWQgYXVkaW8gY29kZWNzO1xuICogIEFuIGVtcHR5IGFycmF5IHByZXNlcnZlcyB0aGUgY3VycmVudCBhdWRpbyBjb2RlYyBwcmVmZXJlbmNlIG9yZGVyLlxuICogQHByb3BlcnR5IHtBcnJheTxWaWRlb0NvZGVjfFZpZGVvQ29kZWNTZXR0aW5ncz58VmlkZW9FbmNvZGluZ01vZGV9IFtwcmVmZXJyZWRWaWRlb0NvZGVjcz1bXV0gLVxuICogIFByZWZlcnJlZCB2aWRlbyBjb2RlY3M7IHdoZW4gc2V0IHRvICdWaWRlb0VuY29kaW5nTW9kZS5BdXRvJywgU0RLIG1hbmFnZXMgdGhlIHZpZGVvIGNvZGVjLFxuICogIGJ5IHByZWZlcnJpbmcgVlA4IHNpbXVsY2FzdCBpbiBncm91cCByb29tcy4gSXQgYWxzbyBlbmFibGVzIGFkYXB0aXZlIHNpbXVsY2FzdCwgd2hpY2ggYWxsb3dzIFNES1xuICogIHRvIHR1cm4gb2ZmIHNpbXVsY2FzdCBsYXllcnMgdGhhdCBhcmUgbm90IG5lZWRlZCBmb3IgZWZmaWNpZW50IGJhbmR3aWR0aCBhbmQgQ1BVIHVzYWdlLlxuICogIEFuIGVtcHR5IGFycmF5IHByZXNlcnZlcyB0aGUgY3VycmVudCB2aWRlbyBjb2RlYy5cbiAqICBwcmVmZXJlbmNlIG9yZGVyLiBJZiB5b3Ugd2FudCB0byBzZXQgYSBwcmVmZXJyZWQgdmlkZW8gY29kZWMgb24gYSBHcm91cCBSb29tLFxuICogIHlvdSB3aWxsIG5lZWQgdG8gY3JlYXRlIHRoZSBSb29tIHVzaW5nIHRoZSBSRVNUIEFQSSBhbmQgc2V0IHRoZVxuICogIDxjb2RlPlZpZGVvQ29kZWNzPC9jb2RlPiBwcm9wZXJ0eS5cbiAqICBTZWUgPGEgaHJlZj1cImh0dHBzOi8vd3d3LnR3aWxpby5jb20vZG9jcy9hcGkvdmlkZW8vcm9vbXMtcmVzb3VyY2UjY3JlYXRlLXJvb21cIj5cbiAqICBoZXJlPC9hPiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7TG9nTGV2ZWx8TG9nTGV2ZWxzfSBbbG9nTGV2ZWw9J3dhcm4nXSAtIDxjb2RlPihkZXByZWNhdGVkOiB1c2UgW1ZpZGVvLkxvZ2dlcl0obW9kdWxlLXR3aWxpby12aWRlby5odG1sKSBpbnN0ZWFkLlxuICogICBTZWUgW2V4YW1wbGVzXShtb2R1bGUtdHdpbGlvLXZpZGVvLmh0bWwjLmNvbm5lY3QpIGZvciBkZXRhaWxzKTwvY29kZT5cbiAqICAgU2V0IHRoZSBkZWZhdWx0IGxvZyB2ZXJib3NpdHlcbiAqICAgb2YgbG9nZ2luZy4gUGFzc2luZyBhIHtAbGluayBMb2dMZXZlbH0gc3RyaW5nIHdpbGwgdXNlIHRoZSBzYW1lXG4gKiAgIGxldmVsIGZvciBhbGwgY29tcG9uZW50cy4gUGFzcyBhIHtAbGluayBMb2dMZXZlbHN9IHRvIHNldCBzcGVjaWZpYyBsb2dcbiAqICAgbGV2ZWxzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsb2dnZXJOYW1lPSd0d2lsaW8tdmlkZW8nXSAtIFRoZSBuYW1lIG9mIHRoZSBsb2dnZXIuIFVzZSB0aGlzIG5hbWUgd2hlbiBhY2Nlc3NpbmcgdGhlIGxvZ2dlciB1c2VkIGJ5IHRoZSBTREsuXG4gKiAgIFNlZSBbZXhhbXBsZXNdKG1vZHVsZS10d2lsaW8tdmlkZW8uaHRtbCMuY29ubmVjdCkgZm9yIGRldGFpbHMuXG4gKiBAcHJvcGVydHkge0FycmF5PExvY2FsVHJhY2t8TWVkaWFTdHJlYW1UcmFjaz59IFt0cmFja3NdIC0gVGhlXG4gKiAgIHtAbGluayBMb2NhbFRyYWNrfXMgb3IgTWVkaWFTdHJlYW1UcmFja3Mgd2l0aCB3aGljaCB0byBqb2luIHRoZVxuICogICB7QGxpbmsgUm9vbX0uIFRoZXNlIHRyYWNrcyBjYW4gYmUgb2J0YWluZWQgZWl0aGVyIGJ5IGNhbGxpbmdcbiAqICAge0BsaW5rIGNyZWF0ZUxvY2FsVHJhY2tzfSwgb3IgYnkgY29uc3RydWN0aW5nIHRoZW0gZnJvbSB0aGUgTWVkaWFTdHJlYW1cbiAqICAgb2J0YWluZWQgYnkgY2FsbGluZyA8Y29kZT5nZXRVc2VyTWVkaWEoKTwvY29kZT4uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58Q3JlYXRlTG9jYWxUcmFja09wdGlvbnN9IFt2aWRlbz10cnVlXSAtIFdoZXRoZXIgb3Igbm90IHRvXG4gKiAgIGdldCBsb2NhbCB2aWRlbyB3aXRoIDxjb2RlPmdldFVzZXJNZWRpYTwvY29kZT4gd2hlbiA8Y29kZT50cmFja3M8L2NvZGU+XG4gKiAgIGFyZSBub3QgcHJvdmlkZWQuXG4gKi9cbi8qKlxuICoge0BsaW5rIEJhbmR3aWR0aFByb2ZpbGV9IGFsbG93cyB5b3UgdG8gY29uZmlndXJlIGhvdyB5b3VyIGF2YWlsYWJsZSBkb3dubGlua1xuICogYmFuZHdpZHRoIGlzIHNoYXJlZCBhbW9uZyB0aGUgUmVtb3RlVHJhY2tzIHlvdSBoYXZlIHN1YnNjcmliZWQgdG8gaW4gYSBHcm91cCBSb29tLlxuICogQHR5cGVkZWYge29iamVjdH0gQmFuZHdpZHRoUHJvZmlsZVxuICogQHByb3BlcnR5IHtWaWRlb0JhbmR3aWR0aFByb2ZpbGV9IFt2aWRlb10gLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gY29uZmlndXJlXG4gKiAgIGhvdyB5b3VyIGF2YWlsYWJsZSBkb3dubGluayBiYW5kd2lkdGggaXMgc2hhcmVkIGFtb25nIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zIHlvdVxuICogICBoYXZlIHN1YnNjcmliZWQgdG8gaW4gYSBHcm91cCBSb29tLlxuICogQHByb3BlcnR5IHtBdWRpb0JhbmR3aWR0aFByb2ZpbGV9IFthdWRpb10gLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gY29uZmlndXJlXG4gKiAgIGhvdyB5b3VyIGF2YWlsYWJsZSBkb3dubGluayBiYW5kd2lkdGggaXMgc2hhcmVkIGFtb25nIHRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja31zIHlvdVxuICogICBoYXZlIHN1YnNjcmliZWQgdG8gaW4gYSBHcm91cCBSb29tLlxuICovXG4vKipcbiAqIHtAbGluayBBdWRpb0JhbmR3aWR0aFByb2ZpbGV9IGFsbG93cyB5b3UgdG8gY29uZmlndXJlIGhvdyB5b3VyIGF2YWlsYWJsZSBkb3dubGlua1xuICogYmFuZHdpZHRoIGlzIHNoYXJlZCBhbW9uZyB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9cyB5b3UgaGF2ZSBzdWJzY3JpYmVkIHRvIGluIGEgR3JvdXAgUm9vbS5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IEF1ZGlvQmFuZHdpZHRoUHJvZmlsZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhTd2l0Y2hlZE9uVHJhY2tzXSAtIE9wdGlvbmFsXG4gKiAgIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBtYXhpbXVtIG51bWJlciBvZiB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja31zLCB3aGljaCB3aWxsIGJlIHNlbGVjdGVkIGJhc2VkIG9uXG4gKiAgIE4tTG91ZGVzdCBwb2xpY3kuIElmIG5vdCBzcGVjaWZpZWQgc2VydmVyIGRlZmF1bHRzIHdpbGwgYmUgdXNlZC5cbiAqL1xuLyoqXG4gKiB7QGxpbmsgVmlkZW9CYW5kd2lkdGhQcm9maWxlfSBhbGxvd3MgeW91IHRvIGNvbmZpZ3VyZSBob3cgeW91ciBhdmFpbGFibGUgZG93bmxpbmtcbiAqIGJhbmR3aWR0aCBpcyBzaGFyZWQgYW1vbmcgdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMgeW91IGhhdmUgc3Vic2NyaWJlZCB0byBpbiBhIEdyb3VwIFJvb20uXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBWaWRlb0JhbmR3aWR0aFByb2ZpbGVcbiAqIEBwcm9wZXJ0eSB7VHJhY2suUHJpb3JpdHl9IFtkb21pbmFudFNwZWFrZXJQcmlvcml0eT1cInN0YW5kYXJkXCJdIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvXG4gKiAgIHNwZWNpZnkgdGhlIG1pbmltdW0gc3Vic2NyaWJlIHtAbGluayBUcmFjay5Qcmlvcml0eX0gb2YgdGhlIERvbWluYW50IFNwZWFrZXIncyB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zLlxuICogICBUaGlzIG1lYW5zIHRoYXQgdGhlIERvbWluYW50IFNwZWFrZXIncyB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zIHRoYXQgYXJlIHB1Ymxpc2hlZCB3aXRoXG4gKiAgIGxvd2VyIHtAbGluayBUcmFjay5Qcmlvcml0eX0gd2lsbCBiZSBzdWJzY3JpYmVkIHRvIHdpdGggdGhlIHtAbGluayBUcmFjay5Qcmlvcml0eX0gc3BlY2lmaWVkIGhlcmUuXG4gKiAgIFRoaXMgaGFzIG5vIGVmZmVjdCBvbiB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zIHB1Ymxpc2hlZCB3aXRoIGhpZ2hlciB7QGxpbmsgVHJhY2suUHJpb3JpdHl9LCB3aGljaCB3aWxsXG4gKiAgIHN0aWxsIGJlIHN1YnNjcmliZWQgdG8gd2l0aCB3aXRoIHRoZSBzYW1lIHtAbGluayBUcmFjay5Qcmlvcml0eX0uIElmIG5vdCBzcGVjaWZpZWQsIHRoaXMgZGVmYXVsdHMgdG8gXCJzdGFuZGFyZFwiLlxuICogICBUaGlzIHBhcmFtZXRlciBvbmx5IGFwcGxpZXMgdG8gYSBHcm91cCBSb29tIFBhcnRpY2lwYW50IHdoZW4ge0BsaW5rIENvbm5lY3RPcHRpb25zfS5kb21pbmFudFNwZWFrZXIgaXMgc2V0IHRvIHRydWUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFN1YnNjcmlwdGlvbkJpdHJhdGVdIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIG1heGltdW1cbiAqICAgZG93bmxpbmsgdmlkZW8gYmFuZHdpZHRoIGluIGJpdHMgcGVyIHNlY29uZCAoYnBzKS4gQnkgZGVmYXVsdCwgdGhlcmUgYXJlIG5vIGxpbWl0cyBvblxuICogICB0aGUgZG93bmxpbmsgdmlkZW8gYmFuZHdpZHRoLlxuICogQHByb3BlcnR5IHtDbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2x9IFtjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2w9XCJhdXRvXCJdIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgZGV0ZXJtaW5lc1xuICogICAgd2hlbiB0byB0dXJuIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gb24gb3Igb2ZmLiBXaGVuIHNldCB0byBcImF1dG9cIiwgU0RLIHdpbGwgdXNlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZVxuICogICAgYXR0YWNoZWQgZWxlbWVudHMgdG8gZGV0ZXJtaW5lIGlmIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gc2hvdWxkIGJlIHR1cm5lZCBvZmYgb3Igb24uIFdoZW4gdGhlIGF0dGFjaGVkIHZpZGVvIGVsZW1lbnRzIGJlY29tZSBpbnZpc2libGUgdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB3aWxsXG4gKiAgICBiZSB0dXJuZWQgb2ZmLCBhbmQgd2hlbiBlbGVtZW50cyBiZWNvbWUgdmlzaWJsZSB0aGV5IHdpbGwgYmUgdHVybmVkIG9uLiBXaGVuIHNldCB0byBcIm1hbnVhbFwiIHlvdSBjYW4gdHVybiB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9XG4gKiAgICBvbiBhbmQgb2ZmIHVzaW5nIHRoZSBhcGkge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2sjc3dpdGNoT259IGFuZCB7QGxpbmsgUmVtb3RlVmlkZW9UcmFjayNzd2l0Y2hPZmZ9IHJlc3BlY3RpdmVseS5cbiAqIEBwcm9wZXJ0eSB7VmlkZW9Db250ZW50UHJlZmVyZW5jZXNNb2RlfSBbY29udGVudFByZWZlcmVuY2VzTW9kZT1cImF1dG9cIl0gLSBUaGlzIE9wdGlvbmFsIHBhcmFtZXRlciBjb25maWd1cmVzXG4gKiAgICB0aGUgbW9kZSBmb3Igc3BlY2lmeWluZyBjb250ZW50IHByZWZlcmVuY2VzIGZvciB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9LiBXaGVuIHNldCB0byBcImF1dG9cIiB0aGVcbiAqICAgIFNESyBkZXRlcm1pbmVzIHRoZSByZW5kZXIgZGltZW5zaW9ucyBieSBpbnNwZWN0aW5nIHRoZSBhdHRhY2hlZCB2aWRlbyBlbGVtZW50cy4ge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cyByZW5kZXJlZCBpbiBzbWFsbGVyIHZpZGVvIGVsZW1lbnRzXG4gKiAgICB3aWxsIHJlY2VpdmUgYSBsb3dlciByZXNvbHV0aW9uIHN0cmVhbSBjb21wYXJlZCB0byB0aGUgdmlkZW8gcmVuZGVyZWQgaW4gbGFyZ2VyIHZpZGVvIGVsZW1lbnRzLiBXaGVuIHNldCB0byBcIm1hbnVhbFwiIHlvdSBjYW4gc2V0XG4gKiAgICB0aGUgZGltZW5zaW9ucyBwcm9ncmFtbWF0aWNhbGx5IGJ5IGNhbGxpbmcge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2sjc2V0Q29udGVudFByZWZlcmVuY2VzfS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4VHJhY2tzXSAtIDxjb2RlPihkZXByZWNhdGVkOiB1c2UgXCJjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2xcIiBpbnN0ZWFkKTwvY29kZT4uIE9wdGlvbmFsXG4gKiAgIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBtYXhpbXVtIG51bWJlciBvZiB2aXNpYmxlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMsIHdoaWNoIHdpbGwgYmUgc2VsZWN0ZWQgYmFzZWQgb25cbiAqICAge0BsaW5rIFRyYWNrLlByaW9yaXR5fSBhbmQgYW4gTi1Mb3VkZXN0IHBvbGljeS4gQnkgZGVmYXVsdCB0aGVyZSBhcmUgbm8gbGltaXRzIG9uIHRoZSBudW1iZXIgb2YgdmlzaWJsZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zLlxuICogICAwIG9yIGEgbmVnYXRpdmUgdmFsdWUgd2lsbCByZW1vdmUgYW55IGxpbWl0IG9uIHRoZSBtYXhpbXVtIG51bWJlciBvZiB2aXNpYmxlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFN3aXRjaGVkT25UcmFja3NdIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIG1heGltdW0gbnVtYmVyIG9mIHZpc2libGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cyxcbiAqICAgd2hpY2ggd2lsbCBiZSBzZWxlY3RlZCBiYXNlZCBvbiB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IGFuZCBhbiBOLUxvdWRlc3QgcG9saWN5LiBCeSBkZWZhdWx0IHRoZXJlIGFyZSBubyBsaW1pdHNcbiAqICAgb24gdGhlIG51bWJlciBvZiB2aXNpYmxlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMuIDAgb3IgYSBuZWdhdGl2ZSB2YWx1ZSB3aWxsIHJlbW92ZSBhbnkgbGltaXRcbiAqICAgb24gdGhlIG1heGltdW0gbnVtYmVyIG9mIHZpc2libGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cy5cbiAqIEBwcm9wZXJ0eSB7QmFuZHdpZHRoUHJvZmlsZU1vZGV9IFttb2RlPVwiZ3JpZFwiXSAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IGhvdyB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cydcbiAqICAgVHJhY2tQcmlvcml0eSB2YWx1ZXMgYXJlIG1hcHBlZCB0byBiYW5kd2lkdGggYWxsb2NhdGlvbiBpbiBHcm91cCBSb29tcy4gVGhpcyBkZWZhdWx0cyB0byBcImdyaWRcIixcbiAqICAgd2hpY2ggcmVzdWx0cyBpbiBlcXVhbCBiYW5kd2lkdGggc2hhcmUgYWxsb2NhdGlvbiB0byBhbGwge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cy5cbiAqIEBwcm9wZXJ0eSB7VmlkZW9SZW5kZXJEaW1lbnNpb25zfSBbcmVuZGVyRGltZW5zaW9uc10gLSA8Y29kZT4oZGVwcmVjYXRlZDogdXNlIFwiY29udGVudFByZWZlcmVuY2VzTW9kZVwiIGluc3RlYWQpPC9jb2RlPi4gT3B0aW9uYWxcbiAqICAgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIGRlc2lyZWQgcmVuZGVyIGRpbWVuc2lvbnMgb2Yge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cy5cbiAqIEBwcm9wZXJ0eSB7VHJhY2tTd2l0Y2hPZmZNb2RlfSBbdHJhY2tTd2l0Y2hPZmZNb2RlPVwicHJlZGljdGVkXCJdIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIGNvbmZpZ3VyZVxuICogICBob3cge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cyBhcmUgc3dpdGNoZWQgb2ZmIGluIHJlc3BvbnNlIHRvIGJhbmR3aWR0aCBwcmVzc3VyZS4gRGVmYXVsdHMgdG8gXCJwcmVkaWN0ZWRcIi5cbiAqL1xuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICoge0BsaW5rIFZpZGVvUmVuZGVyRGltZW5zaW9uc30gYWxsb3dzIHlvdSB0byBzcGVjaWZ5IHRoZSBkZXNpcmVkIHJlbmRlciBkaW1lbnNpb25zIG9mIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMuXG4gKiBZb3UgY2FuIHNwZWNpZnkgJ2F1dG8nIGZvciB0aGlzIGZpZWxkIC0gd2hpY2ggaXMgYWxzbyBkZWZhdWx0IHZhbHVlIC0gIGJhc2VkIG9uIHtAbGluayBUcmFjay5Qcmlvcml0eX0uIFRoZSBiYW5kd2lkdGggYWxsb2NhdGlvbiBhbGdvcml0aG0gd2lsbCBkaXN0cmlidXRlIHRoZSBhdmFpbGFibGUgZG93bmxpbmsgYmFuZHdpZHRoXG4gKiBwcm9wb3J0aW9uYWwgdG8gdGhlIHJlcXVlc3RlZCByZW5kZXIgZGltZW5zaW9ucy4gVGhpcyBpcyBqdXN0IGFuIGlucHV0IGZvciBjYWxjdWxhdGluZyB0aGUgYmFuZHdpZHRoIHRvIGJlIGFsbG9jYXRlZFxuICogYW5kIGRvZXMgbm90IGFmZmVjdCB0aGUgYWN0dWFsIHJlc29sdXRpb24gb2YgdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBWaWRlb1JlbmRlckRpbWVuc2lvbnNcbiAqIEBwcm9wZXJ0eSB7VmlkZW9UcmFjay5EaW1lbnNpb25zfSBbaGlnaF0gLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgZGVzaXJlZCByZW5kZXJpbmcgZGltZW5zaW9ucyBvZlxuICogICB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gd2hvc2Uge0BsaW5rIFRyYWNrLlByaW9yaXR5fSBpcyBcImhpZ2hcIi4gMCBvciBhIG5lZ2F0aXZlIHZhbHVlIHdpbGwgcmVzdWx0IGluIHRoZSBsb3dlc3RcbiAqICAgcG9zc2libGUgcmVzb2x1dGlvbi4gVGhpcyBkZWZhdWx0cyB0byAxMjgwIHggNzIwIChIRCkuXG4gKiBAcHJvcGVydHkge1ZpZGVvVHJhY2suRGltZW5zaW9uc30gW2xvd10gLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgZGVzaXJlZCByZW5kZXJpbmcgZGltZW5zaW9ucyBvZlxuICogICB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gd2hvc2Uge0BsaW5rIFRyYWNrLlByaW9yaXR5fSBpcyBcImxvd1wiLiAwIG9yIGEgbmVnYXRpdmUgdmFsdWUgd2lsbCByZXN1bHQgaW4gdGhlIGxvd2VzdFxuICogICBwb3NzaWJsZSByZXNvbHV0aW9uLiBUaGlzIGRlZmF1bHRzIHRvIDE3NiB4IDE0NCAoUUNJRikuXG4gKiBAcHJvcGVydHkge1ZpZGVvVHJhY2suRGltZW5zaW9uc30gW3N0YW5kYXJkXSAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBkZXNpcmVkIHJlbmRlcmluZyBkaW1lbnNpb25zIG9mXG4gKiAgIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB3aG9zZSB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IGlzIFwic3RhbmRhcmRcIi4gMCBvciBhIG5lZ2F0aXZlIHZhbHVlIHdpbGwgcmVzdWx0IGluIHRoZSBsb3dlc3RcbiAqICAgcG9zc2libGUgcmVzb2x1dGlvbi4gVGhpcyBkZWZhdWx0cyB0byA2NDAgeCA0ODAgKFZHQSkuXG4gKi9cbi8qKlxuICogQ29uZmlndXJlIHZlcmJvc2l0eSBsZXZlbHMgZm9yIG5ldHdvcmsgcXVhbGl0eSBpbmZvcm1hdGlvbiBmb3JcbiAqIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBhbmQge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fXMuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25cbiAqIEBwcm9wZXJ0eSB7TmV0d29ya1F1YWxpdHlWZXJib3NpdHl9IFtsb2NhbD0xXSAtIFZlcmJvc2l0eSBsZXZlbCBmb3Ige0BsaW5rIExvY2FsUGFydGljaXBhbnR9XG4gKiBAcHJvcGVydHkge05ldHdvcmtRdWFsaXR5VmVyYm9zaXR5fSBbcmVtb3RlPTBdIC0gVmVyYm9zaXR5IGxldmVsIGZvciB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9c1xuICovXG4vKipcbiAqIFlvdSBtYXkgcGFzcyB0aGVzZSBsZXZlbHMgdG8ge0BsaW5rIENvbm5lY3RPcHRpb25zfSB0byBvdmVycmlkZVxuICogbG9nIGxldmVscyBmb3IgaW5kaXZpZHVhbCBjb21wb25lbnRzLlxuICogQHR5cGVkZWYge29iamVjdH0gTG9nTGV2ZWxzXG4gKiBAcHJvcGVydHkge0xvZ0xldmVsfSBbZGVmYXVsdD0nd2FybiddIC0gTG9nIGxldmVsIGZvciAnZGVmYXVsdCcgbW9kdWxlcy5cbiAqIEBwcm9wZXJ0eSB7TG9nTGV2ZWx9IFttZWRpYT0nd2FybiddIC0gTG9nIGxldmVsIGZvciAnbWVkaWEnIG1vZHVsZXMuXG4gKiBAcHJvcGVydHkge0xvZ0xldmVsfSBbc2lnbmFsaW5nPSd3YXJuJ10gLSBMb2cgbGV2ZWwgZm9yICdzaWduYWxpbmcnIG1vZHVsZXMuXG4gKiBAcHJvcGVydHkge0xvZ0xldmVsfSBbd2VicnRjPSd3YXJuJ10gLSBMb2cgbGV2ZWwgZm9yICd3ZWJydGMnIG1vZHVsZXMuXG4gKi9cbi8qKlxuICogQXVkaW8gY29kZWMgc2V0dGluZ3MuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBBdWRpb0NvZGVjU2V0dGluZ3NcbiAqIEBwcm9wZXJ0eSB7QXVkaW9Db2RlY30gY29kZWMgLSBBdWRpbyBjb2RlYyBuYW1lXG4gKi9cbi8qKlxuICogT3B1cyBjb2RlYyBzZXR0aW5ncy5cbiAqIEB0eXBlZGVmIHtBdWRpb0NvZGVjU2V0dGluZ3N9IE9wdXNDb2RlY1NldHRpbmdzXG4gKiBAcHJvcGVydHkge0F1ZGlvQ29kZWN9IG5hbWUgLSBcIm9wdXNcIlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZHR4PXRydWVdIC0gRW5hYmxlL2Rpc2FibGUgZGlzY29udGludW91cyB0cmFuc21pc3Npb24gKERUWCk7XG4gKiAgIElmIGVuYWJsZWQgYWxsIHB1Ymxpc2hlZCB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfXMgd2lsbCByZWR1Y2UgdGhlIG91dGdvaW5nIGJpdHJhdGVcbiAqICAgdG8gbmVhci16ZXJvIHdoZW5ldmVyIHNwZWVjaCBpcyBub3QgZGV0ZWN0ZWQsIHJlc3VsdGluZyBpbiBiYW5kd2lkdGggYW5kIENQVSBzYXZpbmdzO1xuICogICBJdCBkZWZhdWx0cyB0byB0cnVlLlxuICovXG4vKipcbiAqIFZpZGVvIGNvZGVjIHNldHRpbmdzLlxuICogQHR5cGVkZWYge29iamVjdH0gVmlkZW9Db2RlY1NldHRpbmdzXG4gKiBAcHJvcGVydHkge1ZpZGVvQ29kZWN9IGNvZGVjIC0gVmlkZW8gY29kZWMgbmFtZVxuICovXG4vKipcbiAqIFZQOCBjb2RlYyBzZXR0aW5ncy5cbiAqIEB0eXBlZGVmIHtWaWRlb0NvZGVjU2V0dGluZ3N9IFZQOENvZGVjU2V0dGluZ3NcbiAqIEBwcm9wZXJ0eSB7VmlkZW9Db2RlY30gbmFtZSAtIFwiVlA4XCJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NpbXVsY2FzdD1mYWxzZV0gLSBFbmFibGUvZGlzYWJsZSBWUDggc2ltdWxjYXN0OyBJZlxuICogICBlbmFibGVkLCBUd2lsaW8ncyBWaWRlbyBTREsgd2lsbCBzZW5kIHRocmVlIHZpZGVvIHN0cmVhbXMgb2YgZGlmZmVyZW50XG4gKiAgIHF1YWxpdGllc1xuICovXG4vKipcbiAqIE5hbWVzIG9mIHRoZSBzdXBwb3J0ZWQgYXVkaW8gY29kZWNzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG52YXIgQXVkaW9Db2RlYyA9IHtcbiAgICBpc2FjOiAnaXNhYycsXG4gICAgb3B1czogJ29wdXMnLFxuICAgIFBDTUE6ICdQQ01BJyxcbiAgICBQQ01VOiAnUENNVSdcbn07XG4vKipcbiAqIE5hbWVzIG9mIHRoZSBzdXBwb3J0ZWQgVmlkZW9FbmNvZGluZ01vZGUuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbnZhciBWaWRlb0VuY29kaW5nTW9kZSA9IHtcbiAgICBBdXRvOiAnYXV0bycsXG59O1xuLyoqXG4gKiBOYW1lcyBvZiB0aGUgc3VwcG9ydGVkIHZpZGVvIGNvZGVjcy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIFZpZGVvQ29kZWMgPSB7XG4gICAgSDI2NDogJ0gyNjQnLFxuICAgIFZQODogJ1ZQOCdcbn07XG4vLyBWUDkgaXMgc3VwcG9ydGVkIGJ5IG1vc3QgYnJvd3NlcnMsIGJ1dCBiYWNrZW5kIGRvZXNuJ3QgYXQgdGhlIG1vbWVudC5cbi8vIEhpZGUgaXQgZnJvbSBwdWJsaWMgZG9jdW1lbnRhdGlvbiB1bnRpbCB0aGVuLlxuVmlkZW9Db2RlYy5WUDkgPSAnVlA5Jztcbi8qKlxuICogTGV2ZWxzIGZvciBsb2dnaW5nIHZlcmJvc2l0eS5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIExvZ0xldmVsID0ge1xuICAgIGRlYnVnOiAnZGVidWcnLFxuICAgIGluZm86ICdpbmZvJyxcbiAgICB3YXJuOiAnd2FybicsXG4gICAgZXJyb3I6ICdlcnJvcicsXG4gICAgb2ZmOiAnb2ZmJ1xufTtcbi8qKlxuICogVGhlIHZlcmJvc2l0eSBsZXZlbCBvZiBuZXR3b3JrIHF1YWxpdHkgaW5mb3JtYXRpb24gb2YgYSB7QGxpbmsgUGFydGljaXBhbnR9LlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG52YXIgTmV0d29ya1F1YWxpdHlWZXJib3NpdHkgPSB7XG4gICAgLyoqXG4gICAgICogTm90aGluZyBpcyByZXBvcnRlZCBmb3IgdGhlIHtAbGluayBQYXJ0aWNpcGFudH0uIFRoaXMgaGFzIG5vIGVmZmVjdCBhbmRcbiAgICAgKiBkZWZhdWx0cyB0byB7QGxpbmsgTmV0d29ya1F1YWxpdHlWZXJib3NpdHl9PGNvZGUgc3R5bGU9XCJwYWRkaW5nOjAgMFwiPiNtaW5pbWFsPC9jb2RlPlxuICAgICAqIGZvciB0aGUge0BsaW5rIExvY2FsUGFydGljaXBhbnR9LlxuICAgICAqL1xuICAgIG5vbmU6IDAsXG4gICAgLyoqXG4gICAgICogUmVwb3J0cyB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gZm9yIHRoZSB7QGxpbmsgUGFydGljaXBhbnR9LlxuICAgICAqL1xuICAgIG1pbmltYWw6IDEsXG4gICAgLyoqXG4gICAgICogUmVwb3J0cyB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gYW5kIHtAbGluayBOZXR3b3JrUXVhbGl0eVN0YXRzfSBmb3IgdGhlIHtAbGluayBQYXJ0aWNpcGFudH0uXG4gICAgICoge0BsaW5rIE5ldHdvcmtRdWFsaXR5U3RhdHN9IGlzIHBvcHVsYXRlZCB3aXRoIGF1ZGlvIGFuZCB2aWRlbyB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH1zXG4gICAgICogYmFzZWQgb24gd2hpY2ggdGhlIHtAbGluayBQYXJ0aWNpcGFudH0ncyB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gaXMgY2FsY3VsYXRlZC5cbiAgICAgKi9cbiAgICBtb2RlcmF0ZTogMixcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfSBhbmQge0BsaW5rIE5ldHdvcmtRdWFsaXR5U3RhdHN9IGZvciB0aGUge0BsaW5rIFBhcnRpY2lwYW50fS5cbiAgICAgKiB7QGxpbmsgTmV0d29ya1F1YWxpdHlTdGF0c30gaXMgcG9wdWxhdGVkIHdpdGggYXVkaW8gYW5kIFZpZGVvIHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfXNcbiAgICAgKiBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyB7QGxpbmsgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzfSBiYXNlZCBvbiB3aGljaCB0aGVcbiAgICAgKiB7QGxpbmsgUGFydGljaXBhbnR9J3Mge0BsaW5rIE5ldHdvcmtRdWFsaXR5TGV2ZWx9IGlzIGNhbGN1bGF0ZWQuXG4gICAgICovXG4gICAgZGV0YWlsZWQ6IDNcbn07XG4vKipcbiAqIHtAbGluayBUcmFja1N3aXRjaE9mZk1vZGV9IHNwZWNpZmllcyB3aGVuIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMnIGFyZSBzd2l0Y2hlZCBvZmYuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbnZhciBUcmFja1N3aXRjaE9mZk1vZGUgPSB7XG4gICAgLyoqXG4gICAgICogSW4gdGhpcyBtb2RlLCB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zIGFyZSBzd2l0Y2hlZCBvZmYgb25seSB3aGVuIG5ldHdvcmsgY29uZ2VzdGlvblxuICAgICAqIGlzIGRldGVjdGVkLlxuICAgICAqL1xuICAgIGRldGVjdGVkOiAnZGV0ZWN0ZWQnLFxuICAgIC8qKlxuICAgICAqIEluIHRoaXMgbW9kZSwge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cyBhcmUgcHJvLWFjdGl2ZWx5IHN3aXRjaGVkIG9mZiB3aGVuIG5ldHdvcmtcbiAgICAgKiBjb25nZXN0aW9uIGlzIHByZWRpY3RlZCBieSB0aGUgYmFuZHdpZHRoIGVzdGltYXRpb24gbWVjaGFuaXNtLlxuICAgICAqL1xuICAgIHByZWRpY3RlZDogJ3ByZWRpY3RlZCcsXG4gICAgLyoqXG4gICAgICogSW4gdGhpcyBtb2RlLCB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zIGFyZSBub3Qgc3dpdGNoZWQgb2ZmLiBJbnN0ZWFkIGluIHJlc3BvbnNlIHRvIG5ldHdvcmtcbiAgICAgKiBjb25nZXN0aW9uLCB0cmFja3Mgd2lsbCBiZSBhZGp1c3RlZCB0byBsb3dlciBxdWFsaXR5LlxuICAgICAqL1xuICAgIGRpc2FibGVkOiAnZGlzYWJsZWQnXG59O1xuLyoqXG4gKiB7QGxpbmsgVHJhY2tTd2l0Y2hPZmZSZWFzb259IGRlc2NyaWJlcyB3aHkgYSB7QGxpbmsgUmVtb3RlVHJhY2t9IGlzIHN3aXRjaGVkIG9mZi4gVGhpcyByZWFzb25cbiAqIGFjY29tcGFuaWVzIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IGV2ZW50IDxjb2RlPnN3aXRjaGVkT2ZmPC9jb2RlPiBhbmQgaXMgdXNlZCBmb3JcbiAqIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHByb3BlcnR5IDxjb2RlPnN3aXRjaE9mZlJlYXNvbjwvY29kZT4uXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgVHJhY2tTd2l0Y2hPZmZSZWFzb24gPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBSZW1vdGVUcmFja30gd2FzIGRpc2FibGVkIGJ5IHRoZSBwdWJsaXNoaW5nIHtAbGluayBQYXJ0aWNpcGFudH0uXG4gICAgICogVGhlIG1lZGlhIHNlcnZlciBkb2VzIG5vdCBzZW5kIG1lZGlhIHRvIHRoZSBzdWJzY3JpYmluZyB7QGxpbmsgUGFydGljaXBhbnR9c1xuICAgICAqIGZvciBhIGRpc2FibGVkIHtAbGluayBUcmFja30uXG4gICAgICovXG4gICAgJ2Rpc2FibGVkLWJ5LXB1Ymxpc2hlcic6ICdkaXNhYmxlZC1ieS1wdWJsaXNoZXInLFxuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gd2FzIGRpc2FibGVkIGJ5IHRoZSBzdWJzY3JpYmluZyB7QGxpbmsgUGFydGljaXBhbnR9XG4gICAgICogYW5kIHRoZSBtZWRpYSBzZXJ2ZXIgc3RvcHBlZCBzZW5kaW5nIGl0cyBtZWRpYS5cbiAgICAgKi9cbiAgICAnZGlzYWJsZWQtYnktc3Vic2NyaWJlcic6ICdkaXNhYmxlZC1ieS1zdWJzY3JpYmVyJyxcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHdhcyBzd2l0Y2hlZCBvZmYgYmVjYXVzZSB0aGUgcmVtYWluaW5nXG4gICAgICogZG93bmxpbmsgYmFuZHdpZHRoIGlzIG5vdCBzdWZmaWNpZW50IHRvIHJlY2VpdmUgaXRzIG1lZGlhLiBUaGUgYmFuZHdpZHRoXG4gICAgICogbGltaXQgaXMgY29uZmlndXJlZCBieSBzcGVjaWZ5aW5nIDxjb2RlPm1heFN1YnNjcmlwdGlvbkJpdHJhdGU8L2NvZGU+XG4gICAgICogaW4ge0BsaW5rIFZpZGVvQmFuZHdpZHRoUHJvZmlsZX0gb3IgYSBkZWZhdWx0IHZhbHVlIGlzIHNlbGVjdGVkXG4gICAgICogYnkgdGhlIG1lZGlhIHNlcnZlci5cbiAgICAgKi9cbiAgICAnbWF4LWJhbmR3aWR0aC1yZWFjaGVkJzogJ21heC1iYW5kd2lkdGgtcmVhY2hlZCcsXG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBSZW1vdGVUcmFja30gd2FzIHN3aXRjaGVkIG9mZiBiZWNhdXNlIHRoZSBudW1iZXIgb2Ygc3dpdGNoZWQgb25cbiAgICAgKiB7QGxpbmsgVHJhY2t9cyByZWFjaGVkIHRoZSBsaW1pdCBzZXQgYnkgdGhlIG1lZGlhIHNlcnZlci5cbiAgICAgKi9cbiAgICAnbWF4LXRyYWNrcy1zd2l0Y2hlZC1vbic6ICdtYXgtdHJhY2tzLXN3aXRjaGVkLW9uJyxcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHdhcyBzd2l0Y2hlZCBvZmYgYmVjYXVzZSBuZXR3b3JrIGNvbmdlc3Rpb25cbiAgICAgKiB3YXMgZGV0ZWN0ZWQgb3IgcHJlZGljdGVkLiBUaGUgPGNvZGU+dHJhY2tTd2l0Y2hPZmZNb2RlPC9jb2RlPiBwcm9wZXJ0eVxuICAgICAqIG9uIHtAbGluayBWaWRlb0JhbmR3aWR0aFByb2ZpbGV9IGFsbG93cyB5b3UgdG8gc3BlY2lmeSBob3cgdGhlXG4gICAgICogc3dpdGNoIG9mZiBpcyBtYW5hZ2VkLlxuICAgICAqL1xuICAgICduZXR3b3JrLWNvbmdlc3Rpb24nOiAnbmV0d29yay1jb25nZXN0aW9uJ1xufTtcbi8qKlxuICoge0BsaW5rIEJhbmR3aWR0aFByb2ZpbGVNb2RlfSBzcGVjaWZpZXMgaG93IHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMnIHtAbGluayBUcmFjay5Qcmlvcml0eX0gdmFsdWVzXG4gKiBhcmUgbWFwcGVkIHRvIGJhbmR3aWR0aCBhbGxvY2F0aW9uIGluIEdyb3VwIFJvb21zLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG52YXIgQmFuZHdpZHRoUHJvZmlsZU1vZGUgPSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBtb2RlIGlzIGZvciB1c2UgY2FzZXMgd2hlcmUgYWxsIHRoZSBzdWJzY3JpYmVkIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMgYXJlXG4gICAgICogZXF1YWxseSBpbXBvcnRhbnQuIFRoZSBiYW5kd2lkdGggYWxsb2NhdGlvbiBhbGdvcml0aG0gd2lsbCBzaGFyZSB0aGUgYXZhaWxhYmxlXG4gICAgICogZG93bmxpbmsgYmFuZHdpZHRoIGVxdWFsbHkgYW1vbmcgdGhlIHN1YnNjcmliZWQge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cywgaXJyZXNwZWN0aXZlXG4gICAgICogb2YgdGhlaXIge0BsaW5rIFRyYWNrLlByaW9yaXR5fS4gSW4gY2FzZSBvZiBpbnN1ZmZpY2llbnQgZG93bmxpbmsgYmFuZHdpZHRoLCB0aGUgbG93ZXJcbiAgICAgKiBwcmlvcml0eSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zIGFyZSBzd2l0Y2hlZCBvZmYuXG4gICAgICovXG4gICAgZ3JpZDogJ2dyaWQnLFxuICAgIC8qKlxuICAgICAqIFRoaXMgbW9kZSBpcyBmb3IgdXNlIGNhc2VzIHdoZXJlIHNvbWUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cyBhcmUgcHJpb3JpdGl6ZWQgbW9yZSB0aGFuXG4gICAgICogb3RoZXJzLiBIb3dldmVyLCB0aGUgbG93ZXIgcHJpb3JpdHkge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cyBzdGlsbCBuZWVkIHRvIGJlIHZpc2libGUuXG4gICAgICogVGhlIGJhbmR3aWR0aCBhbGxvY2F0aW9uIGFsZ29yaXRobSB3aWxsIHNoYXJlIHRoZSBhdmFpbGFibGUgZG93bmxpbmsgYmFuZHdpZHRoIHByb3BvcnRpb25hbFxuICAgICAqIHRvIHRoZSByZXF1ZXN0ZWQge0BsaW5rIFZpZGVvUmVuZGVyRGltZW5zaW9uc30gY29ycmVzcG9uZGluZyB0byB0aGVpciB7QGxpbmsgVHJhY2suUHJpb3JpdHl9LlxuICAgICAqIEluIGNhc2Ugb2YgaW5zdWZmaWNpZW50IGRvd25saW5rIGJhbmR3aWR0aCwgdGhlIHF1YWxpdHkgb2YgaGlnaGVyIHByaW9yaXR5IHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXNcbiAgICAgKiBtYXkgYmUgZGVncmFkZWQgdG8gYXZvaWQgc3dpdGNoaW5nIG9mZiBsb3dlciBwcmlvcml0eSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zLlxuICAgICAqL1xuICAgIGNvbGxhYm9yYXRpb246ICdjb2xsYWJvcmF0aW9uJyxcbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZGUgaXMgZm9yIHVzZSBjYXNlcyB3aGVyZSBzb21lIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMgYXJlIGRlZW1lZCBjcml0aWNhbCBhbmQgbXVzdFxuICAgICAqIGJlIHByZXNlcnZlZCBhdCBhbnkgY29zdCBvdmVyIHRoZSBvdGhlciB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zLiBUaGUgYmFuZHdpZHRoIGFsbG9jYXRpb25cbiAgICAgKiBhbGdvcml0aG0gd2lsbCBhbGxvY2F0ZSBhcyBiaWcgYSBzaGFyZSBvZiB0aGUgYXZhaWxhYmxlIGRvd25saW5rIGJhbmR3aWR0aCBhcyBpdCBwb3NzaWJseVxuICAgICAqIGNhbiB0byB0aGUgaGlnaGVyIHByaW9yaXR5IHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMsIGFuZCBvbmx5IHRoZW4gY29uc2lkZXIgdGhlIGxvd2VyIHByaW9yaXR5XG4gICAgICoge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cy4gSW4gY2FzZSBvZiBpbnN1ZmZpY2llbnQgZG93bmxpbmsgYmFuZHdpZHRoLCB0aGUgbG93ZXIgcHJpb3JpdHlcbiAgICAgKiB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zIGFyZSBzd2l0Y2hlZCBvZmYgaW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIHF1YWxpdHkgb2YgdGhlIGhpZ2hlclxuICAgICAqIHByaW9yaXR5IHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMuXG4gICAgICovXG4gICAgcHJlc2VudGF0aW9uOiAncHJlc2VudGF0aW9uJ1xufTtcbi8qKlxuICoge0BsaW5rIFZpZGVvQ29udGVudFByZWZlcmVuY2VzTW9kZX0gc3BlY2lmaWVzIGhvdyB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zJyByZW5kZXIgZGltZW5zaW9ucyBhcmVcbiAqIGRlY2lkZWQgYnkgdGhlIFNESy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIFZpZGVvQ29udGVudFByZWZlcmVuY2VzTW9kZSA9IHtcbiAgICAvKipcbiAgICAgKiB3aGVuIHNldCB0byBhdXRvLCBTREsgdXNlcyB0aGUgc2l6ZXMgb2YgdGhlIHZpZGVvIGVsZW1lbnRzIGF0dGFjaGVkIHRvIHRoZSB0byB0aGUgIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSBkeW5hbWljYWxseSB0b1xuICAgICAqIGRlY2lkZSB0aGUgcmVuZGVyIGRpbWVuc2lvbnMuIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMgcmVuZGVyZWQgaW4gc21hbGxlciB2aWRlbyBlbGVtZW50cyB3aWxsIGJlIGdpdmVuIHNtYWxsZXIgYmFuZHdpZHRoIGFsbG9jYXRpb25cbiAgICAgKiBjb21wYXJlZCB0byB0aGUgdHJhY2tzIHJlbmRlcmVkIGluIGxhcmdlIHZpZGVvIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGF1dG86ICdhdXRvJyxcbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBtYW51YWwsIGFwcGxpY2F0aW9uIGNhbiB1c2Uge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2sjc2V0Q29udGVudFByZWZlcmVuY2V9IHRvIHNldCB0aGVcbiAgICAgKiBkZXNpcmVkIHJlbmRlciBkaW1lbnNpb25zIGZvciB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9LlxuICAgICAqL1xuICAgIG1hbnVhbDogJ21hbnVhbCdcbn07XG4vKipcbiAqIHtAbGluayBDbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2x9IHNwZWNpZmllcyBob3cge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cycgdHVybmVkIG9uIGFuZCBvZmZcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIENsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCA9IHtcbiAgICAvKipcbiAgICAgKiB3aGVuIHNldCB0byBhdXRvLCBTREsgdXNlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgdmlkZW8gZWxlbWVudHMgYXR0YWNoZWQgdG8gdGhlIHRvIHRoZSAge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHRvIGRlY2lkZS5cbiAgICAgKiBvbiB0dXJuaW5nIHRyYWNrcyBvbiBvciBvZmYuIFRoZSB0cmFjayB0aGF0IGFyZSBub3QgYXR0YWNoZWQgdG8gYW55IHZpZGVvIGVsZW1lbnRzIG9yIG5vdCB2aXNpYmxlIG9uIHRoZSBzY3JlZW4gd2lsbCBiZSB0dXJuZWRcbiAgICAgKiBvZmYgYXV0b21hdGljYWxseS5cbiAgICAgKi9cbiAgICBhdXRvOiAnYXV0bycsXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gbWFudWFsLCBhcHBsaWNhdGlvbiBjYW4gdXNlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMgc3dpdGNoT2ZmIGFuZCBzd2l0Y2hPbiBhcGlzIHRvIGNvbnRyb2wgdHVybiB0aGUgdHJhY2sgb24gb3Igb2ZmLlxuICAgICAqL1xuICAgIG1hbnVhbDogJ21hbnVhbCdcbn07XG4vKipcbiAqIE5hbWVzIG9mIHRoZSBzdXBwb3J0ZWQgbGV2ZWxzIGZvciB7QGxpbmsgRXZlbnRMaXN0ZW5lckV2ZW50fXMuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbnZhciBFdmVudExpc3RlbmVyTGV2ZWwgPSB7XG4gICAgZGVidWc6ICdkZWJ1ZycsXG4gICAgZXJyb3I6ICdlcnJvcicsXG4gICAgaW5mbzogJ2luZm8nLFxuICAgIHdhcm5pbmc6ICd3YXJuaW5nJ1xufTtcbi8qKlxuICogTmFtZXMgb2YgdGhlIHN1cHBvcnRlZCBncm91cHMgZm9yIHtAbGluayBFdmVudExpc3RlbmVyRXZlbnR9cy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIEV2ZW50TGlzdGVuZXJHcm91cCA9IHtcbiAgICAvKipcbiAgICAgKiBFdmVudHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25uZWN0aW9uIHRvIFR3aWxpbydzIHNpZ25hbGluZyBzZXJ2ZXJcbiAgICAgKi9cbiAgICBzaWduYWxpbmc6ICdzaWduYWxpbmcnXG59O1xuLyoqXG4gKiBBbiB7QGxpbmsgRXZlbnRMaXN0ZW5lcn0gYWxsb3dzIHlvdSB0byBsaXN0ZW4gdG8gZmluZS1ncmFpbmVkIHtAbGluayBFdmVudExpc3RlbmVyRXZlbnR9cyByZWxhdGVkXG4gKiB0byBzaWduYWxpbmcgYW5kIG1lZGlhIHRoYXQgYXJlIG5vdCBhdmFpbGFibGUgaW4gdGhlIHB1YmxpYyBBUElzLCB3aGljaCBtaWdodCBiZSB1c2VmdWwgZm9yIHlvdXIgb3duXG4gKiByZXBvcnRpbmcgYW5kIGRpYWdub3N0aWNzLlxuICogQHR5cGVkZWYge0V2ZW50RW1pdHRlcn0gRXZlbnRMaXN0ZW5lclxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdldmVudHMnKTtcbiAqIGNvbnN0IHsgY29ubmVjdCB9ID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gKlxuICogY29uc3QgZXZlbnRMaXN0ZW5lciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAqIGV2ZW50TGlzdGVuZXIub24oJ2V2ZW50JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgY29uc29sZS5sb2coJ1RoZSBTREsgcmFpc2VkIGFuIGV2ZW50OicsIGV2ZW50KTtcbiAqIH0pO1xuICpcbiAqIGNvbm5lY3QoJ3Rva2VuJywge1xuICogICBldmVudExpc3RlbmVyOiBldmVudExpc3RlbmVyXG4gKiB9KTtcbiAqL1xuLyoqXG4gKiBUaGUgU0RLIHJhaXNlZCBhbiB7QGxpbmsgRXZlbnRMaXN0ZW5lckV2ZW50fS5cbiAqIEBldmVudCBFdmVudExpc3RlbmVyI2V2ZW50XG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJFdmVudH0gZXZlbnQgLSBDb250ZXh0IGFib3V0IHRoZSBldmVudCByYWlzZWQgYnkgdGhlIFNESy5cbiAqIFRoaXMgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICogICoge0BsaW5rIEV2ZW50TGlzdGVuZXJDbG9zZWRFdmVudH1cbiAqICAqIHtAbGluayBFdmVudExpc3RlbmVyQ29ubmVjdGluZ0V2ZW50fVxuICogICoge0BsaW5rIEV2ZW50TGlzdGVuZXJFYXJseUV2ZW50fVxuICogICoge0BsaW5rIEV2ZW50TGlzdGVuZXJPcGVuRXZlbnR9XG4gKiAgKiB7QGxpbmsgRXZlbnRMaXN0ZW5lcldhaXRpbmdFdmVudH1cbiAqL1xuLyoqXG4gKiBBbiB7QGxpbmsgRXZlbnRMaXN0ZW5lckV2ZW50fSBwcm92aWRlcyBjb250ZXh0IGFib3V0IGFuIGV2ZW50IHJhaXNlZCBieSB0aGUgU0RLIG9uIHRoZVxuICoge0BsaW5rIEV2ZW50TGlzdGVuZXJ9LiBBcGFydCBmcm9tIHRoZSBwcm9wZXJ0aWVzIGxpc3RlZCBoZXJlLCBpdCBtYXkgYWxzbyBpbmNsdWRlIHNvbWVcbiAqIGV2ZW50LXNwZWNpZmljIGRhdGEgd2l0aGluIGFuIG9wdGlvbmFsIFwicGF5bG9hZFwiIHByb3BlcnR5LiBUaGUgZGlmZmVyZW50IHR5cGVzIG9mXG4gKiB7QGxpbmsgRXZlbnRMaXN0ZW5lckV2ZW50fXMgYXJlIGxpc3RlZCBiZWxvdzpcbiAqICAqIHtAbGluayBFdmVudExpc3RlbmVyQ2xvc2VkRXZlbnR9XG4gKiAgKiB7QGxpbmsgRXZlbnRMaXN0ZW5lckNvbm5lY3RpbmdFdmVudH1cbiAqICAqIHtAbGluayBFdmVudExpc3RlbmVyRWFybHlFdmVudH1cbiAqICAqIHtAbGluayBFdmVudExpc3RlbmVyT3BlbkV2ZW50fVxuICogICoge0BsaW5rIEV2ZW50TGlzdGVuZXJXYWl0aW5nRXZlbnR9XG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBFdmVudExpc3RlbmVyRXZlbnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGFwc2VkVGltZSAtIFRoZSB0aW1lIGVsYXBzZWQgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIGNvbm5lY3QoKSB3YXMgY2FsbGVkXG4gKiBAcHJvcGVydHkge0V2ZW50TGlzdGVuZXJHcm91cH0gZ3JvdXAgLSBUaGUgZ3JvdXAgdW5kZXIgd2hpY2ggdGhlIGV2ZW50IGlzIGNsYXNzaWZpZWRcbiAqIEBwcm9wZXJ0eSB7RXZlbnRMaXN0ZW5lckxldmVsfSBsZXZlbCAtIFRoZSB2ZXJib3NpdHkgbGV2ZWwgb2YgdGhlIGV2ZW50LCB3aGljaCBjYW4gYmUgb25lIG9mIFwiZGVidWdcIiwgXCJlcnJvclwiLCBcImluZm9cIiwgXCJ3YXJuaW5nXCJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gKiBAcHJvcGVydHkgeyp9IFtwYXlsb2FkXSAtIE9wdGlvbmFsIGV2ZW50LXNwZWNpZmljIGRhdGFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lc3RhbXAgLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgcmVsYXRpdmUgdG8gdGhlIFVuaXggRXBvY2ggd2hlbiB0aGUgZXZlbnQgd2FzIHJhaXNlZFxuICovXG4vKipcbiAqIFRoZSBjb25uZWN0aW9uIHRvIFR3aWxpbydzIHNpZ25hbGluZyBzZXJ2ZXIgd2FzIGNsb3NlZC5cbiAqIEB0eXBlZGVmIHtFdmVudExpc3RlbmVyRXZlbnR9IEV2ZW50TGlzdGVuZXJDbG9zZWRFdmVudFxuICogQHByb3BlcnR5IHtFdmVudExpc3RlbmVyR3JvdXB9IGdyb3VwPSdzaWduYWxpbmcnXG4gKiBAcHJvcGVydHkge0V2ZW50TGlzdGVuZXJMZXZlbH0gbGV2ZWwgLSAnaW5mbycgaWYgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBieSB0aGUgY2xpZW50LCAnZXJyb3InIG90aGVyd2lzZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWU9J2Nsb3NlZCdcbiAqIEBwcm9wZXJ0eSB7e3JlYXNvbjogc3RyaW5nfX0gcGF5bG9hZCAtIFJlYXNvbiBmb3IgdGhlIGNvbm5lY3Rpb24gYmVpbmcgY2xvc2VkLiBJdCBjYW4gYmUgb25lIG9mXG4gKiAgICdidXN5JywgJ2ZhaWxlZCcsICdsb2NhbCcsICdyZW1vdGUnIG9yICd0aW1lb3V0J1xuICovXG4vKipcbiAqIFRoZSBTREsgaXMgY29ubmVjdGluZyB0byBUd2lsaW8ncyBzaWduYWxpbmcgc2VydmVyLlxuICogQHR5cGVkZWYge0V2ZW50TGlzdGVuZXJFdmVudH0gRXZlbnRMaXN0ZW5lckNvbm5lY3RpbmdFdmVudFxuICogQHByb3BlcnR5IHtFdmVudExpc3RlbmVyR3JvdXB9IGdyb3VwPSdzaWduYWxpbmcnXG4gKiBAcHJvcGVydHkge0V2ZW50TGlzdGVuZXJMZXZlbH0gbGV2ZWw9J2luZm8nXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZT0nY29ubmVjdGluZydcbiAqL1xuLyoqXG4gKiBUaGUgU0RLIGlzIGFib3V0IHRvIGNvbm5lY3QgdG8gVHdpbGlvJ3Mgc2lnbmFsaW5nIHNlcnZlci5cbiAqIEB0eXBlZGVmIHtFdmVudExpc3RlbmVyRXZlbnR9IEV2ZW50TGlzdGVuZXJFYXJseUV2ZW50XG4gKiBAcHJvcGVydHkge0V2ZW50TGlzdGVuZXJHcm91cH0gZ3JvdXA9J3NpZ25hbGluZydcbiAqIEBwcm9wZXJ0eSB7RXZlbnRMaXN0ZW5lckxldmVsfSBsZXZlbD0naW5mbydcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lPSdlYXJseSdcbiAqL1xuLyoqXG4gKiBUaGUgU0RLIGhhcyBlc3RhYmxpc2hlZCBhIHNpZ25hbGluZyBjb25uZWN0aW9uIHRvIFR3aWxpbydzIHNpZ25hbGluZyBzZXJ2ZXIuXG4gKiBAdHlwZWRlZiB7RXZlbnRMaXN0ZW5lckV2ZW50fSBFdmVudExpc3RlbmVyT3BlbkV2ZW50XG4gKiBAcHJvcGVydHkge0V2ZW50TGlzdGVuZXJHcm91cH0gZ3JvdXA9J3NpZ25hbGluZydcbiAqIEBwcm9wZXJ0eSB7RXZlbnRMaXN0ZW5lckxldmVsfSBsZXZlbD0naW5mbydcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lPSdvcGVuJ1xuICovXG4vKipcbiAqIFRoZSBTREsgaXMgd2FpdGluZyB0byByZXRyeSBjb25uZWN0aW5nIHRoIFR3aWxpbydzIHNpZ25hbGluZyBzZXJ2ZXIuIFRoaXMgY2FuXG4gKiBoYXBwZW4gaWYgdGhlIHNlcnZlciBpcyBidXN5IHdpdGggdG9vIG1hbnkgY29ubmVjdGlvbiByZXF1ZXN0cy5cbiAqIEB0eXBlZGVmIHtFdmVudExpc3RlbmVyRXZlbnR9IEV2ZW50TGlzdGVuZXJXYWl0aW5nRXZlbnRcbiAqIEBwcm9wZXJ0eSB7RXZlbnRMaXN0ZW5lckdyb3VwfSBncm91cD0nc2lnbmFsaW5nJ1xuICogQHByb3BlcnR5IHtFdmVudExpc3RlbmVyTGV2ZWx9IGxldmVsPSd3YXJuaW5nJ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWU9J3dhaXRpbmcnXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZU9wdGlvbnMob3B0aW9ucywgb3B0aW9uc05hbWUsIGxvZywgZGVwcmVjYXRpb25UYWJsZSkge1xuICAgIGRlcHJlY2F0aW9uVGFibGUuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICB2YXIgZGlkV2FybiA9IHByb3AuZGlkV2FybiwgbmFtZSA9IHByb3AubmFtZSwgbmV3TmFtZSA9IHByb3AubmV3TmFtZSwgc2hvdWxkRGVsZXRlID0gcHJvcC5zaG91bGREZWxldGU7XG4gICAgICAgIGlmIChuYW1lIGluIG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnNbbmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAobmV3TmFtZSAmJiBzaG91bGREZWxldGUpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW25ld05hbWVdID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGREZWxldGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGlkV2FybiAmJiAhWydlcnJvcicsICdvZmYnXS5pbmNsdWRlcyhsb2cubGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4oXCJUaGUgXCIgKyBvcHRpb25zTmFtZSArIFwiIHByb3BlcnR5IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgXCIgKyAobmV3TmFtZVxuICAgICAgICAgICAgICAgICAgICA/IFwiZGVwcmVjYXRlZCBhbmQgc2NoZWR1bGVkIGZvciByZW1vdmFsLiBQbGVhc2UgdXNlIFxcXCJcIiArIG5ld05hbWUgKyBcIlxcXCIgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICAgICAgICA6ICdubyBsb25nZXIgYXBwbGljYWJsZSBhbmQgd2lsbCBiZSBpZ25vcmVkLicpKTtcbiAgICAgICAgICAgICAgICBwcm9wLmRpZFdhcm4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVMb2NhbFBhcnRpY2lwYW50KHNpZ25hbGluZywgbG9nLCBlbmNvZGluZ1BhcmFtZXRlcnMsIG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbiwgb3B0aW9ucywgbG9jYWxUcmFja3MpIHtcbiAgICB2YXIgbG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZyA9IHNpZ25hbGluZy5jcmVhdGVMb2NhbFBhcnRpY2lwYW50U2lnbmFsaW5nKGVuY29kaW5nUGFyYW1ldGVycywgbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uKTtcbiAgICBsb2cuZGVidWcoJ0NyZWF0aW5nIGEgbmV3IExvY2FsUGFydGljaXBhbnQ6JywgbG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZyk7XG4gICAgcmV0dXJuIG5ldyBvcHRpb25zLkxvY2FsUGFydGljaXBhbnQobG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZywgbG9jYWxUcmFja3MsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbShvcHRpb25zLCBsb2NhbFBhcnRpY2lwYW50LCByb29tU2lnbmFsaW5nKSB7XG4gICAgdmFyIHJvb20gPSBuZXcgUm9vbShsb2NhbFBhcnRpY2lwYW50LCByb29tU2lnbmFsaW5nLCBvcHRpb25zKTtcbiAgICB2YXIgbG9nID0gb3B0aW9ucy5sb2c7XG4gICAgbG9nLmRlYnVnKCdDcmVhdGluZyBhIG5ldyBSb29tOicsIHJvb20pO1xuICAgIHJvb21TaWduYWxpbmcub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICBsb2cuaW5mbygnRGlzY29ubmVjdGVkIGZyb20gUm9vbTonLCByb29tLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgcm9vbVNpZ25hbGluZy5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByb29tO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbVNpZ25hbGluZyh0b2tlbiwgb3B0aW9ucywgc2lnbmFsaW5nLCBlbmNvZGluZ1BhcmFtZXRlcnMsIHByZWZlcnJlZENvZGVjcywgbG9jYWxQYXJ0aWNpcGFudCkge1xuICAgIG9wdGlvbnMubG9nLmRlYnVnKCdDcmVhdGluZyBhIG5ldyBSb29tU2lnbmFsaW5nJyk7XG4gICAgcmV0dXJuIHNpZ25hbGluZy5jb25uZWN0KGxvY2FsUGFydGljaXBhbnQuX3NpZ25hbGluZywgdG9rZW4sIGVuY29kaW5nUGFyYW1ldGVycywgcHJlZmVycmVkQ29kZWNzLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGdldExvY2FsVHJhY2tzKG9wdGlvbnMsIGhhbmRsZUxvY2FsVHJhY2tzKSB7XG4gICAgdmFyIGxvZyA9IG9wdGlvbnMubG9nO1xuICAgIG9wdGlvbnMuc2hvdWxkU3RvcExvY2FsVHJhY2tzID0gIW9wdGlvbnMudHJhY2tzO1xuICAgIGlmIChvcHRpb25zLnNob3VsZFN0b3BMb2NhbFRyYWNrcykge1xuICAgICAgICBsb2cuaW5mbygnTG9jYWxUcmFja3Mgd2VyZSBub3QgcHJvdmlkZWQsIHNvIHRoZXkgd2lsbCBiZSBhY3F1aXJlZCAnXG4gICAgICAgICAgICArICdhdXRvbWF0aWNhbGx5IGJlZm9yZSBjb25uZWN0aW5nIHRvIHRoZSBSb29tLiBMb2NhbFRyYWNrcyB3aWxsICdcbiAgICAgICAgICAgICsgJ2JlIHJlbGVhc2VkIGlmIGNvbm5lY3RpbmcgdG8gdGhlIFJvb20gZmFpbHMgb3IgaWYgdGhlIFJvb20gJ1xuICAgICAgICAgICAgKyAnaXMgZGlzY29ubmVjdGVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2cuaW5mbygnR2V0dGluZyBMb2NhbFRyYWNrcycpO1xuICAgICAgICBsb2cuZGVidWcoJ09wdGlvbnM6Jywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmNyZWF0ZUxvY2FsVHJhY2tzKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gZ2V0TG9jYWxUcmFja3NTdWNjZWVkZWQobG9jYWxUcmFja3MpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBoYW5kbGVMb2NhbFRyYWNrcyhsb2NhbFRyYWNrcyk7XG4gICAgICAgIHByb21pc2UuY2F0Y2goZnVuY3Rpb24gaGFuZGxlTG9jYWxUcmFja3NGYWlsZWQoKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRTdG9wTG9jYWxUcmFja3MpIHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbygnVGhlIGF1dG9tYXRpY2FsbHkgYWNxdWlyZWQgTG9jYWxUcmFja3Mgd2lsbCBub3cgYmUgc3RvcHBlZCcpO1xuICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29kZWNTZXR0aW5ncyhuYW1lT3JTZXR0aW5ncykge1xuICAgIHZhciBzZXR0aW5ncyA9IHR5cGVvZiBuYW1lT3JTZXR0aW5ncyA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB7IGNvZGVjOiBuYW1lT3JTZXR0aW5ncyB9XG4gICAgICAgIDogbmFtZU9yU2V0dGluZ3M7XG4gICAgc3dpdGNoIChzZXR0aW5ncy5jb2RlYy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ29wdXMnOiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGR0eDogdHJ1ZSB9LCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndnA4Jzoge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBzaW11bGNhc3Q6IGZhbHNlIH0sIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgICAgIH1cbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfYSA9IHJlcXVpcmUoJy4vdXRpbC9jb25zdGFudHMnKSwgREVGQVVMVF9MT0dfTEVWRUwgPSBfYS5ERUZBVUxUX0xPR19MRVZFTCwgREVGQVVMVF9MT0dHRVJfTkFNRSA9IF9hLkRFRkFVTFRfTE9HR0VSX05BTUU7XG4vKipcbiAqIFJlcXVlc3QgYSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSBvciB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfS5cbiAqIEBwYXJhbSB7VHJhY2suS2luZH0ga2luZCAtIFwiYXVkaW9cIiBvciBcInZpZGVvXCJcbiAqIEBwYXJhbSB7Q3JlYXRlTG9jYWxUcmFja09wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8TG9jYWxBdWRpb1RyYWNrfExvY2FsVmlkZW9UcmFjaz59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVMb2NhbFRyYWNrKGtpbmQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGxvZ2dlck5hbWU6IERFRkFVTFRfTE9HR0VSX05BTUUsXG4gICAgICAgIGxvZ0xldmVsOiBERUZBVUxUX0xPR19MRVZFTCxcbiAgICB9LCBvcHRpb25zKTtcbiAgICB2YXIgY3JlYXRlT3B0aW9ucyA9IHt9O1xuICAgIGNyZWF0ZU9wdGlvbnMubG9nZ2VyTmFtZSA9IG9wdGlvbnMubG9nZ2VyTmFtZTtcbiAgICBjcmVhdGVPcHRpb25zLmxvZ0xldmVsID0gb3B0aW9ucy5sb2dMZXZlbDtcbiAgICBkZWxldGUgb3B0aW9ucy5sb2dnZXJOYW1lO1xuICAgIGRlbGV0ZSBvcHRpb25zLmxvZ0xldmVsO1xuICAgIHZhciBjcmVhdGVMb2NhbFRyYWNrcyA9IG9wdGlvbnMuY3JlYXRlTG9jYWxUcmFja3M7XG4gICAgZGVsZXRlIG9wdGlvbnMuY3JlYXRlTG9jYWxUcmFja3M7XG4gICAgY3JlYXRlT3B0aW9uc1traW5kXSA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCA+IDAgPyBvcHRpb25zIDogdHJ1ZTtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWxUcmFja3MoY3JlYXRlT3B0aW9ucykudGhlbihmdW5jdGlvbiAobG9jYWxUcmFja3MpIHsgcmV0dXJuIGxvY2FsVHJhY2tzWzBdOyB9KTtcbn1cbi8qKlxuICogUmVxdWVzdCBhIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9LlxuICogQGFsaWFzIG1vZHVsZTp0d2lsaW8tdmlkZW8uY3JlYXRlTG9jYWxBdWRpb1RyYWNrXG4gKiBAcGFyYW0ge0NyZWF0ZUxvY2FsVHJhY2tPcHRpb25zfSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciByZXF1ZXN0aW5nIGEge0BsaW5rIExvY2FsQXVkaW9UcmFja31cbiAqIEByZXR1cm5zIHtQcm9taXNlPExvY2FsQXVkaW9UcmFjaz59XG4gKiBAZXhhbXBsZVxuICogdmFyIFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gKlxuICogLy8gQ29ubmVjdCB0byB0aGUgUm9vbSB3aXRoIGp1c3QgdmlkZW9cbiAqIFZpZGVvLmNvbm5lY3QoJ215LXRva2VuJywge1xuICogICBuYW1lOiAnbXktY29vbC1yb29tJyxcbiAqICAgdmlkZW86IHRydWVcbiAqIH0pLnRoZW4oZnVuY3Rpb24ocm9vbSkge1xuICogICAvLyBBZGQgYXVkaW8gYWZ0ZXIgY29ubmVjdGluZyB0byB0aGUgUm9vbVxuICogICBWaWRlby5jcmVhdGVMb2NhbEF1ZGlvVHJhY2soKS50aGVuKGZ1bmN0aW9uKGxvY2FsVHJhY2spIHtcbiAqICAgICByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKGxvY2FsVHJhY2spO1xuICogICB9KTtcbiAqIH0pO1xuICogQGV4YW1wbGVcbiAqIHZhciBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICpcbiAqIC8vIFJlcXVlc3QgdGhlIGRlZmF1bHQgTG9jYWxBdWRpb1RyYWNrIHdpdGggYSBjdXN0b20gbmFtZVxuICogVmlkZW8uY3JlYXRlTG9jYWxBdWRpb1RyYWNrKHsgbmFtZTogJ21pY3JvcGhvbmUnIH0pLnRoZW4oZnVuY3Rpb24obG9jYWxUcmFjaykge1xuICogICBjb25zb2xlLmxvZyhsb2NhbFRyYWNrLm5hbWUpOyAvLyAnbWljcm9waG9uZSdcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBjcmVhdGVMb2NhbEF1ZGlvVHJhY2sob3B0aW9ucykge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbFRyYWNrKCdhdWRpbycsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBSZXF1ZXN0IGEge0BsaW5rIExvY2FsVmlkZW9UcmFja30uIE5vdGUgdGhhdCBvbiBtb2JpbGUgYnJvd3NlcnMsXG4gKiB0aGUgY2FtZXJhIGNhbiBiZSByZXNlcnZlZCBieSBvbmx5IG9uZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSBhdCBhbnkgZ2l2ZW5cbiAqIHRpbWUuIElmIHlvdSBhdHRlbXB0IHRvIGNyZWF0ZSBhIHNlY29uZCB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSwgdmlkZW8gZnJhbWVzXG4gKiB3aWxsIG5vIGxvbmdlciBiZSBzdXBwbGllZCB0byB0aGUgZmlyc3Qge0BsaW5rIExvY2FsVmlkZW9UcmFja30uXG4gKiBAYWxpYXMgbW9kdWxlOnR3aWxpby12aWRlby5jcmVhdGVMb2NhbFZpZGVvVHJhY2tcbiAqIEBwYXJhbSB7Q3JlYXRlTG9jYWxUcmFja09wdGlvbnN9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHJlcXVlc3RpbmcgYSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfVxuICogQHJldHVybnMge1Byb21pc2U8TG9jYWxWaWRlb1RyYWNrPn1cbiAqIEBleGFtcGxlXG4gKiB2YXIgVmlkZW8gPSByZXF1aXJlKCd0d2lsaW8tdmlkZW8nKTtcbiAqXG4gKiAvLyBDb25uZWN0IHRvIHRoZSBSb29tIHdpdGgganVzdCBhdWRpb1xuICogVmlkZW8uY29ubmVjdCgnbXktdG9rZW4nLCB7XG4gKiAgIG5hbWU6ICdteS1jb29sLXJvb20nLFxuICogICBhdWRpbzogdHJ1ZVxuICogfSkudGhlbihmdW5jdGlvbihyb29tKSB7XG4gKiAgIC8vIEFkZCB2aWRlbyBhZnRlciBjb25uZWN0aW5nIHRvIHRoZSBSb29tXG4gKiAgIFZpZGVvLmNyZWF0ZUxvY2FsVmlkZW9UcmFjaygpLnRoZW4oZnVuY3Rpb24obG9jYWxUcmFjaykge1xuICogICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sobG9jYWxUcmFjayk7XG4gKiAgIH0pO1xuICogfSk7XG4gKiBAZXhhbXBsZVxuICogdmFyIFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gKlxuICogLy8gUmVxdWVzdCB0aGUgZGVmYXVsdCBMb2NhbFZpZGVvVHJhY2sgd2l0aCBhIGN1c3RvbSBuYW1lXG4gKiBWaWRlby5jcmVhdGVMb2NhbFZpZGVvVHJhY2soeyBuYW1lOiAnY2FtZXJhJyB9KS50aGVuKGZ1bmN0aW9uKGxvY2FsVHJhY2spIHtcbiAqICAgY29uc29sZS5sb2cobG9jYWxUcmFjay5uYW1lKTsgLy8gJ2NhbWVyYSdcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBjcmVhdGVMb2NhbFZpZGVvVHJhY2sob3B0aW9ucykge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbFRyYWNrKCd2aWRlbycsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGUge0BsaW5rIExvY2FsVHJhY2t9IG9wdGlvbnMuIEFwYXJ0IGZyb20gdGhlIHByb3BlcnRpZXMgbGlzdGVkIGhlcmUsIHlvdSBjYW5cbiAqIGFsc28gc3BlY2lmeSBhbnkgb2YgdGhlIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja0NvbnN0cmFpbnRzXCIgdGFyZ2V0PVwiX2JsYW5rXCI+TWVkaWFUcmFja0NvbnN0cmFpbnRzPC9hPlxuICogcHJvcGVydGllcy5cbiAqIEB0eXBlZGVmIHtNZWRpYVRyYWNrQ29uc3RyYWludHN9IENyZWF0ZUxvY2FsVHJhY2tPcHRpb25zXG4gKiBAcHJvcGVydHkge0xvZ0xldmVsfExvZ0xldmVsc30gW2xvZ0xldmVsPSd3YXJuJ10gLSA8Y29kZT4oZGVwcmVjYXRlZDogdXNlIFtWaWRlby5Mb2dnZXJdKG1vZHVsZS10d2lsaW8tdmlkZW8uaHRtbCkgaW5zdGVhZC5cbiAqICAgU2VlIFtleGFtcGxlc10obW9kdWxlLXR3aWxpby12aWRlby5odG1sIy5jb25uZWN0KSBmb3IgZGV0YWlscyk8L2NvZGU+XG4gKiAgIFNldCB0aGUgZGVmYXVsdCBsb2cgdmVyYm9zaXR5XG4gKiAgIG9mIGxvZ2dpbmcuIFBhc3NpbmcgYSB7QGxpbmsgTG9nTGV2ZWx9IHN0cmluZyB3aWxsIHVzZSB0aGUgc2FtZVxuICogICBsZXZlbCBmb3IgYWxsIGNvbXBvbmVudHMuIFBhc3MgYSB7QGxpbmsgTG9nTGV2ZWxzfSB0byBzZXQgc3BlY2lmaWMgbG9nXG4gKiAgIGxldmVscy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbG9nZ2VyTmFtZT0ndHdpbGlvLXZpZGVvJ10gLSBUaGUgbmFtZSBvZiB0aGUgbG9nZ2VyLiBVc2UgdGhpcyBuYW1lIHdoZW4gYWNjZXNzaW5nIHRoZSBsb2dnZXIgdXNlZCBieSB0aGUgU0RLLlxuICogICBTZWUgW2V4YW1wbGVzXShtb2R1bGUtdHdpbGlvLXZpZGVvLmh0bWwjLmNvbm5lY3QpIGZvciBkZXRhaWxzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSAtIFRoZSB7QGxpbmsgTG9jYWxUcmFja30ncyBuYW1lOyBieSBkZWZhdWx0LFxuICogICBpdCBpcyBzZXQgdG8gdGhlIHtAbGluayBMb2NhbFRyYWNrfSdzIElELlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd29ya2Fyb3VuZFdlYktpdEJ1ZzE4MDc0OD1mYWxzZV0gLSBPbmx5IHZhbGlkIGZvclxuICogICB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfXM7IHNldHRpbmcgdGhpcyBhdHRlbXB0cyB0byB3b3JrYXJvdW5kIFdlYktpdCBCdWdcbiAqICAgMTgwNzQ4LCB3aGVyZSwgaW4gU2FmYXJpLCBnZXRVc2VyTWVkaWEgbWF5IHJldHVybiBhIHNpbGVudCBhdWRpb1xuICogICBNZWRpYVN0cmVhbVRyYWNrLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhdWRpbzogY3JlYXRlTG9jYWxBdWRpb1RyYWNrLFxuICAgIHZpZGVvOiBjcmVhdGVMb2NhbFZpZGVvVHJhY2tcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVsb2NhbHRyYWNrLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgICAgICB0b1tqXSA9IGZyb21baV07XG4gICAgcmV0dXJuIHRvO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTG9jYWxUcmFja3MgPSB2b2lkIDA7XG52YXIgX2EgPSByZXF1aXJlKCcuL3V0aWwnKSwgYXNMb2NhbFRyYWNrID0gX2EuYXNMb2NhbFRyYWNrLCBidWlsZExvZ0xldmVscyA9IF9hLmJ1aWxkTG9nTGV2ZWxzO1xudmFyIF9iID0gcmVxdWlyZSgnLi93ZWJydGMnKSwgZ2V0VXNlck1lZGlhID0gX2IuZ2V0VXNlck1lZGlhLCBNZWRpYVN0cmVhbVRyYWNrID0gX2IuTWVkaWFTdHJlYW1UcmFjaztcbnZhciBfYyA9IHJlcXVpcmUoJy4vbWVkaWEvdHJhY2svZXM1JyksIExvY2FsQXVkaW9UcmFjayA9IF9jLkxvY2FsQXVkaW9UcmFjaywgTG9jYWxEYXRhVHJhY2sgPSBfYy5Mb2NhbERhdGFUcmFjaywgTG9jYWxWaWRlb1RyYWNrID0gX2MuTG9jYWxWaWRlb1RyYWNrO1xudmFyIExvZyA9IHJlcXVpcmUoJy4vdXRpbC9sb2cnKTtcbnZhciBfZCA9IHJlcXVpcmUoJy4vdXRpbC9jb25zdGFudHMnKSwgREVGQVVMVF9MT0dfTEVWRUwgPSBfZC5ERUZBVUxUX0xPR19MRVZFTCwgREVGQVVMVF9MT0dHRVJfTkFNRSA9IF9kLkRFRkFVTFRfTE9HR0VSX05BTUU7XG52YXIgd29ya2Fyb3VuZDE4MDc0OCA9IHJlcXVpcmUoJy4vd2ViYXVkaW8vd29ya2Fyb3VuZDE4MDc0OCcpO1xuLy8gVGhpcyBpcyB1c2VkIHRvIG1ha2Ugb3V0IHdoaWNoIGNyZWF0ZUxvY2FsVHJhY2tzKCkgY2FsbCBhIHBhcnRpY3VsYXIgTG9nXG4vLyBzdGF0ZW1lbnQgYmVsb25ncyB0by4gRWFjaCBjYWxsIHRvIGNyZWF0ZUxvY2FsVHJhY2tzKCkgaW5jcmVtZW50cyB0aGlzXG4vLyBjb3VudGVyLlxudmFyIGNyZWF0ZUxvY2FsVHJhY2tDYWxscyA9IDA7XG4vKipcbiAqIFJlcXVlc3Qge0BsaW5rIExvY2FsVHJhY2t9cy4gQnkgZGVmYXVsdCwgaXQgcmVxdWVzdHMgYVxuICoge0BsaW5rIExvY2FsQXVkaW9UcmFja30gYW5kIGEge0BsaW5rIExvY2FsVmlkZW9UcmFja30uXG4gKiBOb3RlIHRoYXQgb24gbW9iaWxlIGJyb3dzZXJzLCB0aGUgY2FtZXJhIGNhbiBiZSByZXNlcnZlZCBieSBvbmx5IG9uZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfVxuICogYXQgYW55IGdpdmVuIHRpbWUuIElmIHlvdSBhdHRlbXB0IHRvIGNyZWF0ZSBhIHNlY29uZCB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSwgdmlkZW8gZnJhbWVzXG4gKiB3aWxsIG5vIGxvbmdlciBiZSBzdXBwbGllZCB0byB0aGUgZmlyc3Qge0BsaW5rIExvY2FsVmlkZW9UcmFja30uXG4gKiBAYWxpYXMgbW9kdWxlOnR3aWxpby12aWRlby5jcmVhdGVMb2NhbFRyYWNrc1xuICogQHBhcmFtIHtDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8TG9jYWxUcmFjaz4+fVxuICogQGV4YW1wbGVcbiAqIHZhciBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICogLy8gUmVxdWVzdCBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gKiBWaWRlby5jcmVhdGVMb2NhbFRyYWNrcygpLnRoZW4oZnVuY3Rpb24obG9jYWxUcmFja3MpIHtcbiAqICAgdmFyIGxvY2FsTWVkaWFDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9jYWwtbWVkaWEtY29udGFpbmVyLWlkJyk7XG4gKiAgIGxvY2FsVHJhY2tzLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAqICAgICBsb2NhbE1lZGlhQ29udGFpbmVyLmFwcGVuZENoaWxkKHRyYWNrLmF0dGFjaCgpKTtcbiAqICAgfSk7XG4gKiB9KTtcbiAqIEBleGFtcGxlXG4gKiB2YXIgVmlkZW8gPSByZXF1aXJlKCd0d2lsaW8tdmlkZW8nKTtcbiAqIC8vIFJlcXVlc3QganVzdCB0aGUgZGVmYXVsdCBhdWRpbyB0cmFja1xuICogVmlkZW8uY3JlYXRlTG9jYWxUcmFja3MoeyBhdWRpbzogdHJ1ZSB9KS50aGVuKGZ1bmN0aW9uKGxvY2FsVHJhY2tzKSB7XG4gKiAgIHJldHVybiBWaWRlby5jb25uZWN0KCdteS10b2tlbicsIHtcbiAqICAgICBuYW1lOiAnbXktY29vbC1yb29tJyxcbiAqICAgICB0cmFja3M6IGxvY2FsVHJhY2tzXG4gKiAgIH0pO1xuICogfSk7XG4gKiBAZXhhbXBsZVxuICogdmFyIFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gKiAvLyBSZXF1ZXN0IHRoZSBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzIHdpdGggY3VzdG9tIG5hbWVzXG4gKiBWaWRlby5jcmVhdGVMb2NhbFRyYWNrcyh7XG4gKiAgIGF1ZGlvOiB7IG5hbWU6ICdtaWNyb3Bob25lJyB9LFxuICogICB2aWRlbzogeyBuYW1lOiAnY2FtZXJhJyB9XG4gKiB9KS50aGVuKGZ1bmN0aW9uKGxvY2FsVHJhY2tzKSB7XG4gKiAgIGxvY2FsVHJhY2tzLmZvckVhY2goZnVuY3Rpb24obG9jYWxUcmFjaykge1xuICogICAgIGNvbnNvbGUubG9nKGxvY2FsVHJhY2submFtZSk7XG4gKiAgIH0pO1xuICogfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICogdmFyIGxvY2FsVHJhY2tzO1xuICpcbiAqIC8vIFByZS1hY3F1aXJlIHRyYWNrcyB0byBkaXNwbGF5IGNhbWVyYSBwcmV2aWV3LlxuICogVmlkZW8uY3JlYXRlTG9jYWxUcmFja3MoKS50aGVuKGZ1bmN0aW9uKHRyYWNrcykge1xuICogIGxvY2FsVHJhY2tzID0gdHJhY2tzO1xuICogIHZhciBsb2NhbFZpZGVvVHJhY2sgPSBsb2NhbFRyYWNrcy5maW5kKHRyYWNrID0+IHRyYWNrLmtpbmQgPT09ICd2aWRlbycpO1xuICogIGRpdkNvbnRhaW5lci5hcHBlbmRDaGlsZChsb2NhbFZpZGVvVHJhY2suYXR0YWNoKCkpO1xuICogfSlcbiAqXG4gKiAvLyBMYXRlciwgam9pbiB0aGUgUm9vbSB3aXRoIHRoZSBwcmUtYWNxdWlyZWQgTG9jYWxUcmFja3MuXG4gKiBWaWRlby5jb25uZWN0KCd0b2tlbicsIHtcbiAqICAgbmFtZTogJ215LWNvb2wtcm9vbScsXG4gKiAgIHRyYWNrczogbG9jYWxUcmFja3NcbiAqIH0pO1xuICpcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxUcmFja3Mob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlzQXVkaW9WaWRlb0Fic2VudCwgZnVsbE9wdGlvbnMsIGxvZ0NvbXBvbmVudE5hbWUsIGxvZ0xldmVscywgbG9nLCBsb2NhbFRyYWNrT3B0aW9ucywgZXh0cmFMb2NhbFRyYWNrT3B0aW9ucywgbWVkaWFTdHJlYW1Db25zdHJhaW50cywgd29ya2Fyb3VuZFdlYktpdEJ1ZzE4MDc0OCwgbWVkaWFTdHJlYW0sIG1lZGlhU3RyZWFtVHJhY2tzLCBlcnJvcl8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpc0F1ZGlvVmlkZW9BYnNlbnQgPSAhKG9wdGlvbnMgJiYgKCdhdWRpbycgaW4gb3B0aW9ucyB8fCAndmlkZW8nIGluIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgZnVsbE9wdGlvbnMgPSBfX2Fzc2lnbih7IGF1ZGlvOiBpc0F1ZGlvVmlkZW9BYnNlbnQsIGdldFVzZXJNZWRpYTogZ2V0VXNlck1lZGlhLCBsb2dnZXJOYW1lOiBERUZBVUxUX0xPR0dFUl9OQU1FLCBsb2dMZXZlbDogREVGQVVMVF9MT0dfTEVWRUwsIExvY2FsQXVkaW9UcmFjazogTG9jYWxBdWRpb1RyYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgTG9jYWxEYXRhVHJhY2s6IExvY2FsRGF0YVRyYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgTG9jYWxWaWRlb1RyYWNrOiBMb2NhbFZpZGVvVHJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBNZWRpYVN0cmVhbVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgTG9nOiBMb2csIHZpZGVvOiBpc0F1ZGlvVmlkZW9BYnNlbnQgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0NvbXBvbmVudE5hbWUgPSBcIltjcmVhdGVMb2NhbFRyYWNrcyAjXCIgKyArK2NyZWF0ZUxvY2FsVHJhY2tDYWxscyArIFwiXVwiO1xuICAgICAgICAgICAgICAgICAgICBsb2dMZXZlbHMgPSBidWlsZExvZ0xldmVscyhmdWxsT3B0aW9ucy5sb2dMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZyA9IG5ldyBmdWxsT3B0aW9ucy5Mb2coJ2RlZmF1bHQnLCBsb2dDb21wb25lbnROYW1lLCBsb2dMZXZlbHMsIGZ1bGxPcHRpb25zLmxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFRyYWNrT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBsb2c6IGxvZyB9LCBmdWxsT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFRoZSBSb29tIFwibmFtZVwiIGluIFwib3B0aW9uc1wiIHdhcyBiZWluZyB1c2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBMb2NhbFRyYWNrIG5hbWUgaW4gYXNMb2NhbFRyYWNrKCkuIFNvIHdlIHBhc3MgYSBjb3B5IG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIFwib3B0aW9uc1wiIHdpdGhvdXQgdGhlIFwibmFtZVwiLlxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFKGpvbWEpOiBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMgdHlwZSBkb2VzIG5vdCByZWFsbHkgaGF2ZSBhIFwibmFtZVwiIHByb3BlcnR5IHdoZW4gdXNlZCBwdWJsaWNseSBieSBjdXN0b21lcnMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1dCB3ZSBhcmUgcGFzc2luZyB0aGlzIHByb3BlcnR5IHdoZW4gdXNlZCBpbnRlcm5hbGx5IGJ5IG90aGVyIEpTIGZpbGVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gdXBkYXRlIHRoaXMgXCJhbnlcIiB0eXBlIG9uY2UgdGhvc2UgSlMgZmlsZXMgYXJlIGNvbnZlcnRlZCB0byBUUy5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsVHJhY2tPcHRpb25zLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdWxsT3B0aW9ucy5hdWRpbyA9PT0gZmFsc2UgJiYgZnVsbE9wdGlvbnMudmlkZW8gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuaW5mbygnTmVpdGhlciBhdWRpbyBub3IgdmlkZW8gcmVxdWVzdGVkLCBzbyByZXR1cm5pbmcgZW1wdHkgTG9jYWxUcmFja3MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBbXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGxPcHRpb25zLnRyYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmluZm8oJ0FkZGluZyB1c2VyLXByb3ZpZGVkIExvY2FsVHJhY2tzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ0xvY2FsVHJhY2tzOicsIGZ1bGxPcHRpb25zLnRyYWNrcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnVsbE9wdGlvbnMudHJhY2tzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHRyYUxvY2FsVHJhY2tPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW86IHR5cGVvZiBmdWxsT3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcgJiYgZnVsbE9wdGlvbnMuYXVkaW8ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBuYW1lOiBmdWxsT3B0aW9ucy5hdWRpby5uYW1lIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW86IHR5cGVvZiBmdWxsT3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcgJiYgZnVsbE9wdGlvbnMudmlkZW8ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBuYW1lOiBmdWxsT3B0aW9ucy52aWRlby5uYW1lIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhTG9jYWxUcmFja09wdGlvbnMuYXVkaW8uaXNDcmVhdGVkQnlDcmVhdGVMb2NhbFRyYWNrcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhTG9jYWxUcmFja09wdGlvbnMudmlkZW8uaXNDcmVhdGVkQnlDcmVhdGVMb2NhbFRyYWNrcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZnVsbE9wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnICYmIHR5cGVvZiBmdWxsT3B0aW9ucy5hdWRpby53b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYUxvY2FsVHJhY2tPcHRpb25zLmF1ZGlvLndvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2ID0gZnVsbE9wdGlvbnMuYXVkaW8ud29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmdWxsT3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGZ1bGxPcHRpb25zLnZpZGVvLndvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhTG9jYWxUcmFja09wdGlvbnMudmlkZW8ud29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTYgPSBmdWxsT3B0aW9ucy52aWRlby53b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZ1bGxPcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZ1bGxPcHRpb25zLmF1ZGlvLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmdWxsT3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmdWxsT3B0aW9ucy52aWRlby5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhU3RyZWFtQ29uc3RyYWludHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpbzogZnVsbE9wdGlvbnMuYXVkaW8sXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlbzogZnVsbE9wdGlvbnMudmlkZW9cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2Fyb3VuZFdlYktpdEJ1ZzE4MDc0OCA9IHR5cGVvZiBmdWxsT3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcgJiYgZnVsbE9wdGlvbnMuYXVkaW8ud29ya2Fyb3VuZFdlYktpdEJ1ZzE4MDc0ODtcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKHdvcmthcm91bmRXZWJLaXRCdWcxODA3NDhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHdvcmthcm91bmQxODA3NDgobG9nLCBmdWxsT3B0aW9ucy5nZXRVc2VyTWVkaWEsIG1lZGlhU3RyZWFtQ29uc3RyYWludHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmdWxsT3B0aW9ucy5nZXRVc2VyTWVkaWEobWVkaWFTdHJlYW1Db25zdHJhaW50cykpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhU3RyZWFtID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBtZWRpYVN0cmVhbVRyYWNrcyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkpKSwgX19yZWFkKG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmluZm8oJ0NhbGwgdG8gZ2V0VXNlck1lZGlhIHN1Y2Nlc3NmdWw7IGdvdCBNZWRpYVN0cmVhbVRyYWNrczonLCBtZWRpYVN0cmVhbVRyYWNrcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBtZWRpYVN0cmVhbVRyYWNrcy5tYXAoZnVuY3Rpb24gKG1lZGlhU3RyZWFtVHJhY2spIHsgcmV0dXJuIGFzTG9jYWxUcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXh0cmFMb2NhbFRyYWNrT3B0aW9uc1ttZWRpYVN0cmVhbVRyYWNrLmtpbmRdKSwgbG9jYWxUcmFja09wdGlvbnMpKTsgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oJ0NhbGwgdG8gZ2V0VXNlck1lZGlhIGZhaWxlZDonLCBlcnJvcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JfMTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUxvY2FsVHJhY2tzID0gY3JlYXRlTG9jYWxUcmFja3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVsb2NhbHRyYWNrcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIERhdGFUcmFja1RyYW5zY2VpdmVyID0gcmVxdWlyZSgnLi90cmFuc2NlaXZlcicpO1xudmFyIERhdGFUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuLyoqXG4gKiBBIHtAbGluayBEYXRhVHJhY2tSZWNlaXZlcn0gcmVwcmVzZW50cyBhIHtAbGluayBEYXRhVHJhY2tUcmFuc2NlaXZlcn0gb3ZlclxuICogd2hpY2ggZGF0YSBjYW4gYmUgcmVjZWl2ZWQuIEludGVybmFsbHksIGl0IHVzZXJzIGEgc2luZ2xlIFJUQ0RhdGFDaGFubmVsIHRvXG4gKiByZWNlaXZlIGRhdGEuXG4gKiBAZXh0ZW5kcyBEYXRhVHJhY2tUcmFuc2NlaXZlclxuICogQGVtaXRzIERhdGFUcmFja1JlY2VpdmVyI21lc3NhZ2VcbiAqIEBlbWl0cyBEYXRhVHJhY2tSZWNlaXZlciNjbG9zZVxuICovXG52YXIgRGF0YVRyYWNrUmVjZWl2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERhdGFUcmFja1JlY2VpdmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiB7QGxpbmsgRGF0YVRyYWNrUmVjZWl2ZXJ9LlxuICAgICAqIEBwYXJhbSB7UlRDRGF0YUNoYW5uZWx9IGRhdGFDaGFubmVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0YVRyYWNrUmVjZWl2ZXIoZGF0YUNoYW5uZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGF0YUNoYW5uZWwubGFiZWwsIGRhdGFDaGFubmVsLm1heFBhY2tldExpZmVUaW1lLCBkYXRhQ2hhbm5lbC5tYXhSZXRyYW5zbWl0cywgZGF0YUNoYW5uZWwub3JkZXJlZCkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9kYXRhQ2hhbm5lbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhQ2hhbm5lbFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogSW4gRmlyZWZveCwgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIFwiYmluYXJ5VHlwZVwiIGlzIFwiYmxvYlwiLlxuICAgICAgICAvLyBTbywgd2Ugc2V0IGl0IHRvIFwiYXJyYXlidWZmZXJcIiB0byBlbnN1cmUgdGhhdCBpdCBpcyBjb25zaXN0ZW50IHdpdGggQ2hyb21lXG4gICAgICAgIC8vIGFuZCBTYWZhcmkuXG4gICAgICAgIGRhdGFDaGFubmVsLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICBkYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdtZXNzYWdlJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERhdGFUcmFja1JlY2VpdmVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5jbG9zZSgpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnN0b3AuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHtAbGluayBEYXRhVHJhbnNwb3J0fSBmcm9tIHRoZSB7QGxpbmsgRGF0YVRyYWNrUmVjZWl2ZXJ9LlxuICAgICAqIEByZXR1cm5zIHtEYXRhVHJhbnNwb3J0fVxuICAgICAqL1xuICAgIERhdGFUcmFja1JlY2VpdmVyLnByb3RvdHlwZS50b0RhdGFUcmFuc3BvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVRyYW5zcG9ydCh0aGlzLl9kYXRhQ2hhbm5lbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YVRyYWNrUmVjZWl2ZXI7XG59KERhdGFUcmFja1RyYW5zY2VpdmVyKSk7XG4vKipcbiAqIEBldmVudCBEYXRhVHJhY2tSZWNlaXZlciNtZXNzYWdlXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheUJ1ZmZlcn0gZGF0YVxuICovXG4vKipcbiAqIEBldmVudCBEYXRhVHJhY2tSZWNlaXZlciNjbG9zZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFUcmFja1JlY2VpdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjZWl2ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBEYXRhVHJhY2tUcmFuc2NlaXZlciA9IHJlcXVpcmUoJy4vdHJhbnNjZWl2ZXInKTtcbnZhciBtYWtlVVVJRCA9IHJlcXVpcmUoJy4uL3V0aWwnKS5tYWtlVVVJRDtcbi8qKlxuICogQSB7QGxpbmsgRGF0YVRyYWNrU2VuZGVyfSByZXByZXNlbnRzIGEge0BsaW5rIERhdGFUcmFja1RyYW5zY2VpdmVyfSBvdmVyXG4gKiB3aGljaCBkYXRhIGNhbiBiZSBzZW50LiBJbnRlcm5hbGx5LCBpdCB1c2VzIGEgY29sbGVjdGlvbiBvZiBSVENEYXRhQ2hhbm5lbHNcbiAqIHRvIHNlbmQgZGF0YS5cbiAqIEBleHRlbmRzIERhdGFUcmFja1RyYW5zY2VpdmVyXG4gKi9cbnZhciBEYXRhVHJhY2tTZW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERhdGFUcmFja1NlbmRlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgRGF0YVRyYWNrU2VuZGVyfS5cbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IG1heFBhY2tldExpZmVUaW1lXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBtYXhSZXRyYW5zbWl0c1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3JkZXJlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGFUcmFja1NlbmRlcihtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc210aXMsIG9yZGVyZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWFrZVVVSUQoKSwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtdGlzLCBvcmRlcmVkKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2Nsb25lczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZGF0YUNoYW5uZWxzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjbG9uZWQge0BsaW5rIERhdGFUcmFja1NlbmRlcn0uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBEYXRhVHJhY2tTZW5kZXIucHJvdG90eXBlLl9hZGRDbG9uZSA9IGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICB0aGlzLl9jbG9uZXMuYWRkKGNsb25lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGNsb25lZCB7QGxpbmsgRGF0YVRyYWNrU2VuZGVyfS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBEYXRhVHJhY2tTZW5kZXIucHJvdG90eXBlLnJlbW92ZUNsb25lID0gZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgIHRoaXMuX2Nsb25lcy5kZWxldGUoY2xvbmUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGFuIFJUQ0RhdGFDaGFubmVsIHRvIHRoZSB7QGxpbmsgRGF0YVRyYWNrU2VuZGVyfS5cbiAgICAgKiBAcGFyYW0ge1JUQ0RhdGFDaGFubmVsfSBkYXRhQ2hhbm5lbFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIERhdGFUcmFja1NlbmRlci5wcm90b3R5cGUuYWRkRGF0YUNoYW5uZWwgPSBmdW5jdGlvbiAoZGF0YUNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWxzLmFkZChkYXRhQ2hhbm5lbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IHtAbGluayBEYXRhVHJhY2tTZW5kZXJ9LiBBbnkgbWVzc2FnZSBzZW50IG92ZXIgdGhpc1xuICAgICAqIHtAbGluayBEYXRhVHJhY2tTZW5kZXJ9IHdpbGwgYWxzbyBiZSBzZW50IG92ZXIgdGhlIGNsb25lLiBXaGVuZXZlciB0aGlzXG4gICAgICoge0BsaW5rIERhdGFUcmFja1NlbmRlcn0gaXMgc3RvcHBlZCwgc28gdG8gd2lsbCB0aGUgY2xvbmUuXG4gICAgICogQHJldHVybnMge0RhdGFUcmFja1NlbmRlcn1cbiAgICAgKi9cbiAgICBEYXRhVHJhY2tTZW5kZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2xvbmUgPSBuZXcgRGF0YVRyYWNrU2VuZGVyKHRoaXMubWF4UGFja2V0TGlmZVRpbWUsIHRoaXMubWF4UmV0cmFuc21pdHMsIHRoaXMub3JkZXJlZCk7XG4gICAgICAgIHRoaXMuX2FkZENsb25lKGNsb25lKTtcbiAgICAgICAgY2xvbmUub25jZSgnc3RvcHBlZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlbW92ZUNsb25lKGNsb25lKTsgfSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBSVENEYXRhQ2hhbm5lbCBmcm9tIHRoZSB7QGxpbmsgRGF0YVRyYWNrU2VuZGVyfS5cbiAgICAgKiBAcGFyYW0ge1JUQ0RhdGFDaGFubmVsfSBkYXRhQ2hhbm5lbFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIERhdGFUcmFja1NlbmRlci5wcm90b3R5cGUucmVtb3ZlRGF0YUNoYW5uZWwgPSBmdW5jdGlvbiAoZGF0YUNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWxzLmRlbGV0ZShkYXRhQ2hhbm5lbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIG92ZXIgdGhlIHtAbGluayBEYXRhVHJhY2tTZW5kZXJ9LiBJbnRlcm5hbGx5LCB0aGlzIGNhbGxzXG4gICAgICogPGNvZGU+c2VuZDwvY29kZT4gb3ZlciBlYWNoIG9mIHRoZSB1bmRlcmx5aW5nIFJUQ0RhdGFDaGFubmVscy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xCbG9ifEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gZGF0YVxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIERhdGFUcmFja1NlbmRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVscy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhQ2hhbm5lbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbC5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjbG9uZS5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRGF0YVRyYWNrU2VuZGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUNoYW5uZWwpIHsgcmV0dXJuIGRhdGFDaGFubmVsLmNsb3NlKCk7IH0pO1xuICAgICAgICB0aGlzLl9jbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHsgcmV0dXJuIGNsb25lLnN0b3AoKTsgfSk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc3RvcC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFUcmFja1NlbmRlcjtcbn0oRGF0YVRyYWNrVHJhbnNjZWl2ZXIpKTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YVRyYWNrU2VuZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VuZGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgVHJhY2tUcmFuc2NlaXZlciA9IHJlcXVpcmUoJy4uL3RyYW5zY2VpdmVyJyk7XG4vKipcbiAqIEEge0BsaW5rIERhdGFUcmFja1RyYW5zY2VpdmVyfSByZXByZXNlbnRzIGVpdGhlciBvbmUgb3IgbW9yZSBsb2NhbFxuICogUlRDRGF0YUNoYW5uZWxzIG9yIGEgc2luZ2xlIHJlbW90ZSBSVENEYXRhQ2hhbm5lbC4gSXQgY2FuIGJlIHVzZWQgdG8gc2VuZCBvclxuICogcmVjZWl2ZSBkYXRhLlxuICogQGV4dGVuZHMgVHJhY2tUcmFuc2NlaXZlclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkXG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2luZCAtIFwiZGF0YVwiXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IG1heFBhY2tldExpZmVUaW1lXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IG1heFJldHJhbnNtaXRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9yZGVyZWRcbiAqL1xudmFyIERhdGFUcmFja1RyYW5zY2VpdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRhVHJhY2tUcmFuc2NlaXZlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgRGF0YVRyYWNrVHJhbnNjZWl2ZXJ9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gbWF4UGFja2V0TGlmZVRpbWVcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IG1heFJldHJhbnNtaXRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvcmRlcmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0YVRyYWNrVHJhbnNjZWl2ZXIoaWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgb3JkZXJlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgJ2RhdGEnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtYXhQYWNrZXRMaWZlVGltZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWF4UmV0cmFuc21pdHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcmRlcmVkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3JkZXJlZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRGF0YVRyYWNrVHJhbnNjZWl2ZXI7XG59KFRyYWNrVHJhbnNjZWl2ZXIpKTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YVRyYWNrVHJhbnNjZWl2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2NlaXZlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbi8qKlxuICogQGNsYXNzZGVzYyBBIHtAbGluayBEYXRhVHJhbnNwb3J0fSBpbXBsZW1lbnRzIHtAbGluayBNZWRpYVNpZ25hbGluZ1RyYW5zcG9ydH1cbiAqICAgaW4gdGVybXMgb2YgYW4gUlRDRGF0YUNoYW5uZWwuXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBpbXBsZW1lbnRzIE1lZGlhU2lnbmFsaW5nVHJhbnNwb3J0XG4gKiBAZW1pdHMgRGF0YVRyYW5zcG9ydCNtZXNzYWdlXG4gKi9cbnZhciBEYXRhVHJhbnNwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRhVHJhbnNwb3J0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBEYXRhVHJhbnNwb3J0fS5cbiAgICAgKiBAcGFyYW0ge1JUQ0RhdGFDaGFubmVsfSBkYXRhQ2hhbm5lbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGFUcmFuc3BvcnQoZGF0YUNoYW5uZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9kYXRhQ2hhbm5lbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhQ2hhbm5lbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9tZXNzYWdlUXVldWU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWVzc2FnZVF1ZXVlLnNwbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBfdGhpcy5fcHVibGlzaChtZXNzYWdlKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IF9hLmRhdGE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMucHVibGlzaCh7IHR5cGU6ICdyZWFkeScgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERhdGFUcmFuc3BvcnQucHJvdG90eXBlLl9wdWJsaXNoID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeShtZXNzYWdlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGEgbWVzc2FnZS4gUmV0dXJucyB0cnVlIGlmIGNhbGxpbmcgdGhlIG1ldGhvZCByZXN1bHRlZCBpblxuICAgICAqIHB1Ymxpc2hpbmcgKG9yIGV2ZW50dWFsbHkgcHVibGlzaGluZykgdGhlIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIERhdGFUcmFuc3BvcnQucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgZGF0YUNoYW5uZWwgPSB0aGlzLl9kYXRhQ2hhbm5lbDtcbiAgICAgICAgaWYgKGRhdGFDaGFubmVsLnJlYWR5U3RhdGUgPT09ICdjbG9zaW5nJyB8fCBkYXRhQ2hhbm5lbC5yZWFkeVN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhQ2hhbm5lbC5yZWFkeVN0YXRlID09PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VRdWV1ZS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHVibGlzaChtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YVRyYW5zcG9ydDtcbn0oRXZlbnRFbWl0dGVyKSk7XG4vKipcbiAqIFRoZSB7QGxpbmsgRGF0YVRyYW5zcG9ydH0gcmVjZWl2ZWQgYSBtZXNzYWdlLlxuICogQGV2ZW50IERhdGFUcmFuc3BvcnQjbWVzc2FnZVxuICogQHBhcmFtIHtvYmplY3R9IG1lc3NhZ2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBEYXRhVHJhbnNwb3J0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNwb3J0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuLyoqXG4gKiB7QGxpbmsgRW5jb2RpbmdQYXJhbWV0ZXJzSW1wbH0gcmVwcmVzZW50cyBhbiBvYmplY3Qgd2hpY2ggbm90aWZpZXMgaXRzXG4gKiBsaXN0ZW5lcnMgb2YgYW55IGNoYW5nZXMgaW4gdGhlIHZhbHVlcyBvZiBpdHMgcHJvcGVydGllcy5cbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQGltcGxlbWVudHMgRW5jb2RpbmdQYXJhbWV0ZXJzXG4gKiBAZW1pdHMgRW5jb2RpbmdQYXJhbWV0ZXJzSW1wbCNjaGFuZ2VkXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IG1heEF1ZGlvQml0cmF0ZVxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBtYXhWaWRlb0JpdHJhdGVcbiAqL1xudmFyIEVuY29kaW5nUGFyYW1ldGVyc0ltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVuY29kaW5nUGFyYW1ldGVyc0ltcGwsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIHtAbGluayBFbmNvZGluZ1BhcmFtZXRlcnNJbXBsfS5cbiAgICAgKiBAcGFyYW0ge0VuY29kaW5nUGFyYW10ZXJzfSBlbmNvZGluZ1BhcmFtZXRlcnMgLSBJbml0aWFsIHtAbGluayBFbmNvZGluZ1BhcmFtZXRlcnN9XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhZGFwdGl2ZVNpbXVsY2FzdCAtIHRydWUgaWYgYWRhcHRpdmUgc2ltdWxjYXN0IHdhcyBlbmFibGVkIGJ5IGNvbm5lY3Qgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbmNvZGluZ1BhcmFtZXRlcnNJbXBsKGVuY29kaW5nUGFyYW1ldGVycywgYWRhcHRpdmVTaW11bGNhc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBtYXhBdWRpb0JpdHJhdGU6IG51bGwsXG4gICAgICAgICAgICBtYXhWaWRlb0JpdHJhdGU6IG51bGxcbiAgICAgICAgfSwgZW5jb2RpbmdQYXJhbWV0ZXJzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIG1heEF1ZGlvQml0cmF0ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBlbmNvZGluZ1BhcmFtZXRlcnMubWF4QXVkaW9CaXRyYXRlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4VmlkZW9CaXRyYXRlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGVuY29kaW5nUGFyYW1ldGVycy5tYXhWaWRlb0JpdHJhdGUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGFwdGl2ZVNpbXVsY2FzdDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBhZGFwdGl2ZVNpbXVsY2FzdFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXRyYXRlIHZhbHVlcyBpbiBhbiB7QGxpbmsgRW5jb2RpbmdQYXJhbWV0ZXJzfS5cbiAgICAgKiBAcmV0dXJucyB7RW5jb2RpbmdQYXJhbWV0ZXJzfVxuICAgICAqL1xuICAgIEVuY29kaW5nUGFyYW1ldGVyc0ltcGwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1heEF1ZGlvQml0cmF0ZTogdGhpcy5tYXhBdWRpb0JpdHJhdGUsXG4gICAgICAgICAgICBtYXhWaWRlb0JpdHJhdGU6IHRoaXMubWF4VmlkZW9CaXRyYXRlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGJpdHJhdGUgdmFsdWVzIHdpdGggdGhvc2UgaW4gdGhlIGdpdmVuIHtAbGluayBFbmNvZGluZ1BhcmFtZXRlcnN9LlxuICAgICAqIEBwYXJhbSB7RW5jb2RpbmdQYXJhbWV0ZXJzfSBlbmNvZGluZ1BhcmFtZXRlcnMgLSBUaGUgbmV3IHtAbGluayBFbmNvZGluZ1BhcmFtZXRlcnN9XG4gICAgICogQGZpcmVzIEVuY29kaW5nUGFyYW1ldGVyc0ltcGwjY2hhbmdlZFxuICAgICAqL1xuICAgIEVuY29kaW5nUGFyYW1ldGVyc0ltcGwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmNvZGluZ1BhcmFtZXRlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBtYXhBdWRpb0JpdHJhdGU6IHRoaXMubWF4QXVkaW9CaXRyYXRlLFxuICAgICAgICAgICAgbWF4VmlkZW9CaXRyYXRlOiB0aGlzLm1heFZpZGVvQml0cmF0ZVxuICAgICAgICB9LCBlbmNvZGluZ1BhcmFtZXRlcnMpO1xuICAgICAgICB2YXIgc2hvdWxkRW1pdENoYW5nZWQgPSBbXG4gICAgICAgICAgICAnbWF4QXVkaW9CaXRyYXRlJyxcbiAgICAgICAgICAgICdtYXhWaWRlb0JpdHJhdGUnXG4gICAgICAgIF0ucmVkdWNlKGZ1bmN0aW9uIChzaG91bGRFbWl0Q2hhbmdlZCwgbWF4S2luZEJpdHJhdGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpc1ttYXhLaW5kQml0cmF0ZV0gIT09IGVuY29kaW5nUGFyYW1ldGVyc1ttYXhLaW5kQml0cmF0ZV0pIHtcbiAgICAgICAgICAgICAgICBfdGhpc1ttYXhLaW5kQml0cmF0ZV0gPSBlbmNvZGluZ1BhcmFtZXRlcnNbbWF4S2luZEJpdHJhdGVdO1xuICAgICAgICAgICAgICAgIHNob3VsZEVtaXRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaG91bGRFbWl0Q2hhbmdlZDtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICBpZiAoc2hvdWxkRW1pdENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRW5jb2RpbmdQYXJhbWV0ZXJzSW1wbDtcbn0oRXZlbnRFbWl0dGVyKSk7XG4vKipcbiAqIEF0IGxlYXN0IG9uZSBvZiB0aGUge0BsaW5rIEVuY29kaW5nUGFyYW1ldGVyc0ltcGx9J3MgYml0cmF0ZSB2YWx1ZXMgY2hhbmdlZC5cbiAqIEBldmVudCBFbmNvZGluZ1BhcmFtZXRlcnNJbXBsI2NoYW5nZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBFbmNvZGluZ1BhcmFtZXRlcnNJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jb2RpbmdwYXJhbWV0ZXJzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaGlkZVByaXZhdGVBbmRDZXJ0YWluUHVibGljUHJvcGVydGllc0luQ2xhc3MgPSByZXF1aXJlKCcuL3V0aWwnKS5oaWRlUHJpdmF0ZUFuZENlcnRhaW5QdWJsaWNQcm9wZXJ0aWVzSW5DbGFzcztcbm1vZHVsZS5leHBvcnRzID0gaGlkZVByaXZhdGVBbmRDZXJ0YWluUHVibGljUHJvcGVydGllc0luQ2xhc3MoRXZlbnRFbWl0dGVyLCBbJ2RvbWFpbiddKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50ZW1pdHRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNyZWF0ZWxvY2FsdHJhY2tzXzEgPSByZXF1aXJlKFwiLi9jcmVhdGVsb2NhbHRyYWNrc1wiKTtcbnZhciBwcmVmbGlnaHR0ZXN0XzEgPSByZXF1aXJlKFwiLi9wcmVmbGlnaHQvcHJlZmxpZ2h0dGVzdFwiKTtcbnZhciBpbnRlcm5hbHMgPSB7XG4gICAgY29ubmVjdDogcmVxdWlyZSgnLi9jb25uZWN0JyksXG4gICAgY3JlYXRlTG9jYWxBdWRpb1RyYWNrOiByZXF1aXJlKCcuL2NyZWF0ZWxvY2FsdHJhY2snKS5hdWRpbyxcbiAgICBjcmVhdGVMb2NhbFZpZGVvVHJhY2s6IHJlcXVpcmUoJy4vY3JlYXRlbG9jYWx0cmFjaycpLnZpZGVvLFxuICAgIGlzU3VwcG9ydGVkOiByZXF1aXJlKCcuL3V0aWwvc3VwcG9ydCcpKCksXG4gICAgdmVyc2lvbjogcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbixcbiAgICBMb2dnZXI6IHJlcXVpcmUoJy4vdmVuZG9yL2xvZ2xldmVsJyksXG4gICAgTG9jYWxBdWRpb1RyYWNrOiByZXF1aXJlKCcuL21lZGlhL3RyYWNrL2VzNScpLkxvY2FsQXVkaW9UcmFjayxcbiAgICBMb2NhbERhdGFUcmFjazogcmVxdWlyZSgnLi9tZWRpYS90cmFjay9lczUnKS5Mb2NhbERhdGFUcmFjayxcbiAgICBMb2NhbFZpZGVvVHJhY2s6IHJlcXVpcmUoJy4vbWVkaWEvdHJhY2svZXM1JykuTG9jYWxWaWRlb1RyYWNrXG59O1xuZnVuY3Rpb24gY29ubmVjdCh0b2tlbiwgb3B0aW9ucykge1xuICAgIHZhciBpbnRlcm5hbE9wdGlvbnMgPSBfX2Fzc2lnbih7IGNyZWF0ZUxvY2FsVHJhY2tzOiBjcmVhdGVsb2NhbHRyYWNrc18xLmNyZWF0ZUxvY2FsVHJhY2tzIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBpbnRlcm5hbHMuY29ubmVjdCh0b2tlbiwgaW50ZXJuYWxPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsQXVkaW9UcmFjayhvcHRpb25zKSB7XG4gICAgdmFyIGludGVybmFsT3B0aW9ucyA9IF9fYXNzaWduKHsgY3JlYXRlTG9jYWxUcmFja3M6IGNyZWF0ZWxvY2FsdHJhY2tzXzEuY3JlYXRlTG9jYWxUcmFja3MgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGludGVybmFscy5jcmVhdGVMb2NhbEF1ZGlvVHJhY2soaW50ZXJuYWxPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsVmlkZW9UcmFjayhvcHRpb25zKSB7XG4gICAgdmFyIGludGVybmFsT3B0aW9ucyA9IF9fYXNzaWduKHsgY3JlYXRlTG9jYWxUcmFja3M6IGNyZWF0ZWxvY2FsdHJhY2tzXzEuY3JlYXRlTG9jYWxUcmFja3MgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGludGVybmFscy5jcmVhdGVMb2NhbFZpZGVvVHJhY2soaW50ZXJuYWxPcHRpb25zKTtcbn1cbi8qKlxuICogQG1vZHVsZSB0d2lsaW8tdmlkZW9cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTdXBwb3J0ZWQgLSB0cnVlIGlmIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgb2ZmaWNpYWxseVxuICogICBzdXBwb3J0ZWQgYnkgdHdpbGlvLXZpZGVvLmpzOyBJbiB0aGlzIGNvbnRleHQsIFwic3VwcG9ydGVkXCIgbWVhbnMgdGhhdFxuICogICB0d2lsaW8tdmlkZW8uanMgaGFzIGJlZW4gZXh0ZW5zaXZlbHkgdGVzdGVkIHdpdGggdGhpcyBicm93c2VyOyBUaGlzXG4gKiAgIDxhIGhyZWY9XCJodHRwczovL3d3dy50d2lsaW8uY29tL2RvY3MvdmlkZW8vamF2YXNjcmlwdCNzdXBwb3J0ZWQtYnJvd3NlcnNcIiB0YXJnZXQ9XCJfYmxhbmtcIj50YWJsZTwvYT5cbiAqICAgc3BlY2lmaWVzIHRoZSBsaXN0IG9mIG9mZmljaWFsbHkgc3VwcG9ydGVkIGJyb3dzZXJzLlxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBMb2dnZXIgLSBUaGUgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2xvZ2xldmVsXCIgdGFyZ2V0PVwiX2JsYW5rXCI+bG9nbGV2ZWw8L2E+XG4gKiAgICBtb2R1bGUgdXNlZCBieSB0aGUgU0RLLiBVc2UgdGhpcyBvYmplY3QgdG8gYWNjZXNzIHRoZSBpbnRlcm5hbCBsb2dnZXJzIGFuZCBwZXJmb3JtIGFjdGlvbnMgYXMgZGVmaW5lZCBieSB0aGVcbiAqICAgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2xvZ2xldmVsXCIgdGFyZ2V0PVwiX2JsYW5rXCI+bG9nbGV2ZWw8L2E+IEFQSXMuXG4gKiAgIFNlZSBbY29ubmVjdF0oIy5jb25uZWN0KSBmb3IgZXhhbXBsZXMuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZlcnNpb24gLSBjdXJyZW50IHZlcnNpb24gb2YgdHdpbGlvLXZpZGVvLmpzLlxuICovXG52YXIgaXNTdXBwb3J0ZWQgPSBpbnRlcm5hbHMuaXNTdXBwb3J0ZWQ7XG52YXIgdmVyc2lvbiA9IGludGVybmFscy52ZXJzaW9uO1xudmFyIExvZ2dlciA9IGludGVybmFscy5Mb2dnZXI7XG52YXIgTG9jYWxBdWRpb1RyYWNrID0gaW50ZXJuYWxzLkxvY2FsQXVkaW9UcmFjaztcbnZhciBMb2NhbFZpZGVvVHJhY2sgPSBpbnRlcm5hbHMuTG9jYWxWaWRlb1RyYWNrO1xudmFyIExvY2FsRGF0YVRyYWNrID0gaW50ZXJuYWxzLkxvY2FsRGF0YVRyYWNrO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29ubmVjdDogY29ubmVjdCxcbiAgICBjcmVhdGVMb2NhbEF1ZGlvVHJhY2s6IGNyZWF0ZUxvY2FsQXVkaW9UcmFjayxcbiAgICBjcmVhdGVMb2NhbFZpZGVvVHJhY2s6IGNyZWF0ZUxvY2FsVmlkZW9UcmFjayxcbiAgICBjcmVhdGVMb2NhbFRyYWNrczogY3JlYXRlbG9jYWx0cmFja3NfMS5jcmVhdGVMb2NhbFRyYWNrcyxcbiAgICBydW5QcmVmbGlnaHQ6IHByZWZsaWdodHRlc3RfMS5ydW5QcmVmbGlnaHQsXG4gICAgaXNTdXBwb3J0ZWQ6IGlzU3VwcG9ydGVkLFxuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgTG9nZ2VyOiBMb2dnZXIsXG4gICAgTG9jYWxBdWRpb1RyYWNrOiBMb2NhbEF1ZGlvVHJhY2ssXG4gICAgTG9jYWxWaWRlb1RyYWNrOiBMb2NhbFZpZGVvVHJhY2ssXG4gICAgTG9jYWxEYXRhVHJhY2s6IExvY2FsRGF0YVRyYWNrXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBNZWRpYVN0cmVhbVRyYWNrID0gcmVxdWlyZSgnLi93ZWJydGMnKS5NZWRpYVN0cmVhbVRyYWNrO1xudmFyIF9hID0gcmVxdWlyZSgnLi91dGlsJyksIGFzTG9jYWxUcmFjayA9IF9hLmFzTG9jYWxUcmFjaywgYXNMb2NhbFRyYWNrUHVibGljYXRpb24gPSBfYS5hc0xvY2FsVHJhY2tQdWJsaWNhdGlvbiwgcmVlbWl0VHJhY2tQdWJsaWNhdGlvbkV2ZW50cyA9IF9hLnJlZW1pdFRyYWNrUHVibGljYXRpb25FdmVudHMsIHRyYWNrQ2xhc3MgPSBfYS50cmFja0NsYXNzO1xudmFyIF9iID0gcmVxdWlyZSgnLi91dGlsL2NvbnN0YW50cycpLCBFID0gX2IudHlwZUVycm9ycywgdHJhY2tQcmlvcml0eSA9IF9iLnRyYWNrUHJpb3JpdHk7XG52YXIgdmFsaWRhdGVMb2NhbFRyYWNrID0gcmVxdWlyZSgnLi91dGlsL3ZhbGlkYXRlJykudmFsaWRhdGVMb2NhbFRyYWNrO1xudmFyIF9jID0gcmVxdWlyZSgnLi9tZWRpYS90cmFjay9lczUnKSwgTG9jYWxBdWRpb1RyYWNrID0gX2MuTG9jYWxBdWRpb1RyYWNrLCBMb2NhbERhdGFUcmFjayA9IF9jLkxvY2FsRGF0YVRyYWNrLCBMb2NhbFZpZGVvVHJhY2sgPSBfYy5Mb2NhbFZpZGVvVHJhY2s7XG52YXIgTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb24gPSByZXF1aXJlKCcuL21lZGlhL3RyYWNrL2xvY2FsYXVkaW90cmFja3B1YmxpY2F0aW9uJyk7XG52YXIgTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvbiA9IHJlcXVpcmUoJy4vbWVkaWEvdHJhY2svbG9jYWxkYXRhdHJhY2twdWJsaWNhdGlvbicpO1xudmFyIExvY2FsVmlkZW9UcmFja1B1YmxpY2F0aW9uID0gcmVxdWlyZSgnLi9tZWRpYS90cmFjay9sb2NhbHZpZGVvdHJhY2twdWJsaWNhdGlvbicpO1xudmFyIFBhcnRpY2lwYW50ID0gcmVxdWlyZSgnLi9wYXJ0aWNpcGFudCcpO1xuLyoqXG4gKiBBIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSByZXByZXNlbnRzIHRoZSBsb2NhbCB7QGxpbmsgUGFydGljaXBhbnR9IGluIGFcbiAqIHtAbGluayBSb29tfS5cbiAqIEBleHRlbmRzIFBhcnRpY2lwYW50XG4gKiBAcHJvcGVydHkge01hcDxUcmFjay5TSUQsIExvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9uPn0gYXVkaW9UcmFja3MgLVxuICogICAgVGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSdzIHtAbGluayBMb2NhbEF1ZGlvVHJhY2tQdWJsaWNhdGlvbn1zXG4gKiBAcHJvcGVydHkge01hcDxUcmFjay5TSUQsIExvY2FsRGF0YVRyYWNrUHVibGljYXRpb24+fSBkYXRhVHJhY2tzIC1cbiAqICAgIFRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0ncyB7QGxpbmsgTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvbn1zXG4gKiBAcHJvcGVydHkge01hcDxUcmFjay5TSUQsIExvY2FsVHJhY2tQdWJsaWNhdGlvbj59IHRyYWNrcyAtXG4gKiAgICBUaGUge0BsaW5rIExvY2FsUGFydGljaXBhbnR9J3Mge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn1zXG4gKiBAcHJvcGVydHkge01hcDxUcmFjay5TSUQsIExvY2FsVmlkZW9UcmFja1B1YmxpY2F0aW9uPn0gdmlkZW9UcmFja3MgLVxuICogICAgVGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSdzIHtAbGluayBMb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvbn1zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2lnbmFsaW5nUmVnaW9uIC0gVGhlIGdlb2dyYXBoaWNhbCByZWdpb24gb2YgdGhlXG4gKiAgICAgc2lnbmFsaW5nIGVkZ2UgdGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBpcyBjb25uZWN0ZWQgdG8uXG4gKlxuICogQGVtaXRzIFJlbW90ZVBhcnRpY2lwYW50I3JlY29ubmVjdGVkXG4gKiBAZW1pdHMgUmVtb3RlUGFydGljaXBhbnQjcmVjb25uZWN0aW5nXG4gKiBAZW1pdHMgTG9jYWxQYXJ0aWNpcGFudCN0cmFja0RpbWVuc2lvbnNDaGFuZ2VkXG4gKiBAZW1pdHMgTG9jYWxQYXJ0aWNpcGFudCN0cmFja0Rpc2FibGVkXG4gKiBAZW1pdHMgTG9jYWxQYXJ0aWNpcGFudCN0cmFja0VuYWJsZWRcbiAqIEBlbWl0cyBMb2NhbFBhcnRpY2lwYW50I3RyYWNrUHVibGljYXRpb25GYWlsZWRcbiAqIEBlbWl0cyBMb2NhbFBhcnRpY2lwYW50I3RyYWNrUHVibGlzaGVkXG4gKiBAZW1pdHMgTG9jYWxQYXJ0aWNpcGFudCN0cmFja1N0YXJ0ZWRcbiAqIEBlbWl0cyBMb2NhbFBhcnRpY2lwYW50I3RyYWNrU3RvcHBlZFxuICovXG52YXIgTG9jYWxQYXJ0aWNpcGFudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9jYWxQYXJ0aWNpcGFudCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0uXG4gICAgICogQHBhcmFtIHtQYXJ0aWNpcGFudFNpZ25hbGluZ30gc2lnbmFsaW5nXG4gICAgICogQHBhcmFtIHtBcnJheTxMb2NhbFRyYWNrPn0gbG9jYWxUcmFja3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvY2FsUGFydGljaXBhbnQoc2lnbmFsaW5nLCBsb2NhbFRyYWNrcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBMb2NhbEF1ZGlvVHJhY2s6IExvY2FsQXVkaW9UcmFjayxcbiAgICAgICAgICAgIExvY2FsVmlkZW9UcmFjazogTG9jYWxWaWRlb1RyYWNrLFxuICAgICAgICAgICAgTG9jYWxEYXRhVHJhY2s6IExvY2FsRGF0YVRyYWNrLFxuICAgICAgICAgICAgTWVkaWFTdHJlYW1UcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgICAgICAgICAgIExvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9uOiBMb2NhbEF1ZGlvVHJhY2tQdWJsaWNhdGlvbixcbiAgICAgICAgICAgIExvY2FsVmlkZW9UcmFja1B1YmxpY2F0aW9uOiBMb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvbixcbiAgICAgICAgICAgIExvY2FsRGF0YVRyYWNrUHVibGljYXRpb246IExvY2FsRGF0YVRyYWNrUHVibGljYXRpb24sXG4gICAgICAgICAgICBzaG91bGRTdG9wTG9jYWxUcmFja3M6IGZhbHNlLFxuICAgICAgICAgICAgdHJhY2tzOiBsb2NhbFRyYWNrc1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHRyYWNrc1RvU3RvcCA9IG9wdGlvbnMuc2hvdWxkU3RvcExvY2FsVHJhY2tzXG4gICAgICAgICAgICA/IG5ldyBTZXQobG9jYWxUcmFja3MuZmlsdGVyKGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7IHJldHVybiBsb2NhbFRyYWNrLmtpbmQgIT09ICdkYXRhJzsgfSkpXG4gICAgICAgICAgICA6IG5ldyBTZXQoKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzaWduYWxpbmcsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfZXZlbnRPYnNlcnZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmV2ZW50T2JzZXJ2ZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfTG9jYWxBdWRpb1RyYWNrOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuTG9jYWxBdWRpb1RyYWNrXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX0xvY2FsRGF0YVRyYWNrOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuTG9jYWxEYXRhVHJhY2tcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfTG9jYWxWaWRlb1RyYWNrOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuTG9jYWxWaWRlb1RyYWNrXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX01lZGlhU3RyZWFtVHJhY2s6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5NZWRpYVN0cmVhbVRyYWNrXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX0xvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLkxvY2FsRGF0YVRyYWNrUHVibGljYXRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfTG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5Mb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90cmFja3NUb1N0b3A6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhY2tzVG9TdG9wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lnbmFsaW5nUmVnaW9uOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hbGluZy5zaWduYWxpbmdSZWdpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuX2hhbmRsZVRyYWNrU2lnbmFsaW5nRXZlbnRzKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0xvY2FsVHJhY2t9IHRyYWNrXG4gICAgICogQHBhcmFtIHtUcmFjay5Qcmlvcml0eX0gcHJpb3JpdHlcbiAgICAgKiBAcmV0dXJucyB7P0xvY2FsVHJhY2t9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudC5wcm90b3R5cGUuX2FkZFRyYWNrID0gZnVuY3Rpb24gKHRyYWNrLCBwcmlvcml0eSkge1xuICAgICAgICB2YXIgYWRkZWRUcmFjayA9IF9zdXBlci5wcm90b3R5cGUuX2FkZFRyYWNrLmNhbGwodGhpcywgdHJhY2ssIHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKGFkZGVkVHJhY2sgJiYgdGhpcy5zdGF0ZSAhPT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZExvY2FsVHJhY2sodHJhY2ssIHByaW9yaXR5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkZWRUcmFjaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtMb2NhbFRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uXG4gICAgICogQHJldHVybnMgez9Mb2NhbFRyYWNrUHVibGljYXRpb259XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudC5wcm90b3R5cGUuX2FkZFRyYWNrUHVibGljYXRpb24gPSBmdW5jdGlvbiAocHVibGljYXRpb24pIHtcbiAgICAgICAgcHVibGljYXRpb24gPSBfc3VwZXIucHJvdG90eXBlLl9hZGRUcmFja1B1YmxpY2F0aW9uLmNhbGwodGhpcywgcHVibGljYXRpb24pO1xuICAgICAgICBpZiAocHVibGljYXRpb24pIHtcbiAgICAgICAgICAgIHJlZW1pdFRyYWNrUHVibGljYXRpb25FdmVudHModGhpcywgcHVibGljYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtMb2NhbFRyYWNrfSB0cmFja1xuICAgICAqIEBwYXJhbSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5XG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudC5wcm90b3R5cGUuX2FkZExvY2FsVHJhY2sgPSBmdW5jdGlvbiAodHJhY2ssIHByaW9yaXR5KSB7XG4gICAgICAgIHRoaXMuX3NpZ25hbGluZy5hZGRUcmFjayh0cmFjay5fdHJhY2tTZW5kZXIsIHRyYWNrLm5hbWUsIHByaW9yaXR5KTtcbiAgICAgICAgdGhpcy5fbG9nLmluZm8oXCJBZGRlZCBhIG5ldyBcIiArIHRyYWNrQ2xhc3ModHJhY2ssIHRydWUpICsgXCI6XCIsIHRyYWNrLmlkKTtcbiAgICAgICAgdGhpcy5fbG9nLmRlYnVnKHRyYWNrQ2xhc3ModHJhY2ssIHRydWUpICsgXCI6XCIsIHRyYWNrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtMb2NhbFRyYWNrfSB0cmFja1xuICAgICAqIEByZXR1cm5zIHs/TG9jYWxUcmFja31cbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50LnByb3RvdHlwZS5fcmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFyIHJlbW92ZWRUcmFjayA9IF9zdXBlci5wcm90b3R5cGUuX3JlbW92ZVRyYWNrLmNhbGwodGhpcywgdHJhY2ssIHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKHJlbW92ZWRUcmFjayAmJiB0aGlzLnN0YXRlICE9PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsaW5nLnJlbW92ZVRyYWNrKHRyYWNrLl90cmFja1NlbmRlcik7XG4gICAgICAgICAgICB0aGlzLl9sb2cuaW5mbyhcIlJlbW92ZWQgYSBcIiArIHRyYWNrQ2xhc3ModHJhY2ssIHRydWUpICsgXCI6XCIsIHRyYWNrLmlkKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1Zyh0cmFja0NsYXNzKHRyYWNrLCB0cnVlKSArIFwiOlwiLCB0cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW92ZWRUcmFjaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUge0BsaW5rIExvY2FsVHJhY2t9IGV2ZW50cyB0byByZS1lbWl0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5PHN0cmluZz4+fSBldmVudHNcbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50LnByb3RvdHlwZS5fZ2V0VHJhY2tFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl9nZXRUcmFja0V2ZW50cy5jYWxsKHRoaXMpLmNvbmNhdChbXG4gICAgICAgICAgICBbJ2Rpc2FibGVkJywgJ3RyYWNrRGlzYWJsZWQnXSxcbiAgICAgICAgICAgIFsnZW5hYmxlZCcsICd0cmFja0VuYWJsZWQnXSxcbiAgICAgICAgICAgIFsnc3RvcHBlZCcsICd0cmFja1N0b3BwZWQnXVxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIExvY2FsUGFydGljaXBhbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbTG9jYWxQYXJ0aWNpcGFudCAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgKHRoaXMuc2lkID8gXCI6IFwiICsgdGhpcy5zaWQgOiAnJykgKyBcIl1cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudC5wcm90b3R5cGUuX2hhbmRsZVRyYWNrU2lnbmFsaW5nRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2lnbmFsaW5nID0gdGhpcy5fc2lnbmFsaW5nO1xuICAgICAgICBmdW5jdGlvbiBsb2NhbFRyYWNrRGlzYWJsZWQobG9jYWxUcmFjaykge1xuICAgICAgICAgICAgdmFyIHRyYWNrU2lnbmFsaW5nID0gc2lnbmFsaW5nLmdldFB1YmxpY2F0aW9uKGxvY2FsVHJhY2suX3RyYWNrU2VuZGVyKTtcbiAgICAgICAgICAgIGlmICh0cmFja1NpZ25hbGluZykge1xuICAgICAgICAgICAgICAgIHRyYWNrU2lnbmFsaW5nLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJEaXNhYmxlZCB0aGUgXCIgKyB0cmFja0NsYXNzKGxvY2FsVHJhY2ssIHRydWUpICsgXCI6XCIsIGxvY2FsVHJhY2suaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvY2FsVHJhY2tFbmFibGVkKGxvY2FsVHJhY2spIHtcbiAgICAgICAgICAgIHZhciB0cmFja1NpZ25hbGluZyA9IHNpZ25hbGluZy5nZXRQdWJsaWNhdGlvbihsb2NhbFRyYWNrLl90cmFja1NlbmRlcik7XG4gICAgICAgICAgICBpZiAodHJhY2tTaWduYWxpbmcpIHtcbiAgICAgICAgICAgICAgICB0cmFja1NpZ25hbGluZy5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJFbmFibGVkIHRoZSBcIiArIHRyYWNrQ2xhc3MobG9jYWxUcmFjaywgdHJ1ZSkgKyBcIjpcIiwgbG9jYWxUcmFjay5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9jYWxUcmFja1N0b3BwZWQobG9jYWxUcmFjaykge1xuICAgICAgICAgICAgLy8gTk9URShtcm9iZXJ0cyk6IFdlIHNob3VsZG4ndCBuZWVkIHRvIGNoZWNrIGZvciBgc3RvcGAsIHNpbmNlIERhdGFUcmFja3NcbiAgICAgICAgICAgIC8vIGRvIG5vdCBlbWl0IFwic3RvcHBlZFwiLlxuICAgICAgICAgICAgdmFyIHRyYWNrU2lnbmFsaW5nID0gc2lnbmFsaW5nLmdldFB1YmxpY2F0aW9uKGxvY2FsVHJhY2suX3RyYWNrU2VuZGVyKTtcbiAgICAgICAgICAgIGlmICh0cmFja1NpZ25hbGluZykge1xuICAgICAgICAgICAgICAgIHRyYWNrU2lnbmFsaW5nLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFja1NpZ25hbGluZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uKCd0cmFja0Rpc2FibGVkJywgbG9jYWxUcmFja0Rpc2FibGVkKTtcbiAgICAgICAgdGhpcy5vbigndHJhY2tFbmFibGVkJywgbG9jYWxUcmFja0VuYWJsZWQpO1xuICAgICAgICB0aGlzLm9uKCd0cmFja1N0b3BwZWQnLCBsb2NhbFRyYWNrU3RvcHBlZCk7XG4gICAgICAgIHRoaXMuX3RyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgX3RoaXMuX2FkZExvY2FsVHJhY2sodHJhY2ssIHRyYWNrUHJpb3JpdHkuUFJJT1JJVFlfU1RBTkRBUkQpO1xuICAgICAgICAgICAgX3RoaXMuX2dldE9yQ3JlYXRlTG9jYWxUcmFja1B1YmxpY2F0aW9uKHRyYWNrKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBKdXN0IGxvZyBhIHdhcm5pbmcgZm9yIG5vdy5cbiAgICAgICAgICAgICAgICBsb2cud2FybihcIkZhaWxlZCB0byBnZXQgb3IgY3JlYXRlIExvY2FsVHJhY2tQdWJsaWNhdGlvbiBmb3IgXCIgKyB0cmFjayArIFwiOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2lnbmFsaW5nLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBzdGF0ZUNoYW5nZWQoc3RhdGUpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZygnVHJhbnNpdGlvbmVkIHRvIHN0YXRlOicsIHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ1JlbW92aW5nIExvY2FsVHJhY2sgZXZlbnQgbGlzdGVuZXJzJyk7XG4gICAgICAgICAgICAgICAgc2lnbmFsaW5nLnJlbW92ZUxpc3RlbmVyKCdzdGF0ZUNoYW5nZWQnLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3RyYWNrRGlzYWJsZWQnLCBsb2NhbFRyYWNrRGlzYWJsZWQpO1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3RyYWNrRW5hYmxlZCcsIGxvY2FsVHJhY2tFbmFibGVkKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd0cmFja1N0b3BwZWQnLCBsb2NhbFRyYWNrU3RvcHBlZCk7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogUmVtb3ZlIHRoZSBzdGFsZSBNZWRpYVRyYWNrU2VuZGVyIGNsb25lcyBzbyB0aGF0IHdlXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGNhbGwgcmVwbGFjZVRyYWNrKCkgb24gdGhlaXIgUlRDUnRwU2VuZGVycy5cbiAgICAgICAgICAgICAgICBzZWxmLl90cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrU2lnbmFsaW5nID0gbG9jYWxUcmFja1N0b3BwZWQodHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tTaWduYWxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLl90cmFja1NlbmRlci5yZW1vdmVDbG9uZSh0cmFja1NpZ25hbGluZy5fdHJhY2tUcmFuc2NlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhcIkxvY2FsUGFydGljaXBhbnQgZGlzY29ubmVjdGVkLiBTdG9wcGluZyBcIiArIHNlbGYuX3RyYWNrc1RvU3RvcC5zaXplICsgXCIgYXV0b21hdGljYWxseS1hY3F1aXJlZCBMb2NhbFRyYWNrc1wiKTtcbiAgICAgICAgICAgICAgICBzZWxmLl90cmFja3NUb1N0b3AuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogQW55IHRyYW5zaXRpb24gdG8gXCJjb25uZWN0ZWRcIiBoZXJlIGlzIGEgcmVzdWx0IG9mXG4gICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBzaWduYWxpbmcgcmVjb25uZWN0aW9uLCBhbmQgbm90IGEgZmlyc3QtdGltZSBlc3RhYmxpc2htZW50XG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgIGxvZy5pbmZvKCdyZWNvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBgc3RhdGVDaGFuZ2VkYCBjYW4gZ2V0IGVtaXR0ZWQgd2l0aCBTdGF0ZU1hY2hpbmUgbG9ja2VkLlxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBzaWduYWwgIHB1YmxpYyBldmVudHMgc3luY2hyb25vdXNseSB3aXRoIGxvY2sgaGVsZC5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuZW1pdCgncmVjb25uZWN0ZWQnKTsgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0xvY2FsVHJhY2t9IGxvY2FsVHJhY2tcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMb2NhbFRyYWNrUHVibGljYXRpb24+fVxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnQucHJvdG90eXBlLl9nZXRPckNyZWF0ZUxvY2FsVHJhY2tQdWJsaWNhdGlvbiA9IGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7XG4gICAgICAgIHZhciBsb2NhbFRyYWNrUHVibGljYXRpb24gPSBnZXRUcmFja1B1YmxpY2F0aW9uKHRoaXMudHJhY2tzLCBsb2NhbFRyYWNrKTtcbiAgICAgICAgaWYgKGxvY2FsVHJhY2tQdWJsaWNhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsb2NhbFRyYWNrUHVibGljYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHRyYWNrU2lnbmFsaW5nID0gdGhpcy5fc2lnbmFsaW5nLmdldFB1YmxpY2F0aW9uKGxvY2FsVHJhY2suX3RyYWNrU2VuZGVyKTtcbiAgICAgICAgaWYgKCF0cmFja1NpZ25hbGluZykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZXJyb3I6IFRoZSBcIiArIGxvY2FsVHJhY2sgKyBcIiBjYW5ub3QgYmUgcHVibGlzaGVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bnB1Ymxpc2gocHVibGljYXRpb24pIHtcbiAgICAgICAgICAgIHNlbGYudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVkKCkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IHRyYWNrU2lnbmFsaW5nLmVycm9yO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0cmFja1NpZ25hbGluZy5yZW1vdmVMaXN0ZW5lcigndXBkYXRlZCcsIHVwZGF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihcIkZhaWxlZCB0byBwdWJsaXNoIHRoZSBcIiArIHRyYWNrQ2xhc3MobG9jYWxUcmFjaywgdHJ1ZSkgKyBcIjogXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlVHJhY2sobG9jYWxUcmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KCd0cmFja1B1YmxpY2F0aW9uRmFpbGVkJywgZXJyb3IsIGxvY2FsVHJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuX3RyYWNrcy5oYXMobG9jYWxUcmFjay5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tTaWduYWxpbmcucmVtb3ZlTGlzdGVuZXIoJ3VwZGF0ZWQnLCB1cGRhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRoZSBcIiArIGxvY2FsVHJhY2sgKyBcIiB3YXMgdW5wdWJsaXNoZWRcIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzaWQgPSB0cmFja1NpZ25hbGluZy5zaWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFzaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFja1NpZ25hbGluZy5yZW1vdmVMaXN0ZW5lcigndXBkYXRlZCcsIHVwZGF0ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2c6IGxvZyxcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb246IHNlbGYuX0xvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICBMb2NhbERhdGFUcmFja1B1YmxpY2F0aW9uOiBzZWxmLl9Mb2NhbERhdGFUcmFja1B1YmxpY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICBMb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvbjogc2VsZi5fTG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb25cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tQdWJsaWNhdGlvbiA9IGdldFRyYWNrUHVibGljYXRpb24oc2VsZi50cmFja3MsIGxvY2FsVHJhY2spO1xuICAgICAgICAgICAgICAgIGlmICghbG9jYWxUcmFja1B1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tQdWJsaWNhdGlvbiA9IGFzTG9jYWxUcmFja1B1YmxpY2F0aW9uKGxvY2FsVHJhY2ssIHRyYWNrU2lnbmFsaW5nLCB1bnB1Ymxpc2gsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRUcmFja1B1YmxpY2F0aW9uKGxvY2FsVHJhY2tQdWJsaWNhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHNlbGYuX3NpZ25hbGluZy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdjb25uZWN0ZWQnIHx8IHN0YXRlID09PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsVHJhY2suX3Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsVHJhY2suX3Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIub24oJ2V2ZW50JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZXZlbnRPYnNlcnZlci5lbWl0KCdldmVudCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZXZlbnQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6ICd2aWRlby1wcm9jZXNzb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogJ2luZm8nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFKGNzYW50b3MpOiBGb3IgdHJhY2tzIGNyZWF0ZWQgYmVmb3JlIGpvaW5pbmcgYSByb29tIG9yIGFscmVhZHkgam9pbmVkIGJ1dCBhYm91dCB0byBwdWJsaXNoIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFRyYWNrLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFRyYWNrLl9jYXB0dXJlRnJhbWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFRyYWNrLl9zZXRTZW5kZXJNZWRpYVN0cmVhbVRyYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ3RyYWNrUHVibGlzaGVkJywgbG9jYWxUcmFja1B1YmxpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUobG9jYWxUcmFja1B1YmxpY2F0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrU2lnbmFsaW5nLm9uKCd1cGRhdGVkJywgdXBkYXRlZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIGEge0BsaW5rIExvY2FsVHJhY2t9IHRvIHRoZSB7QGxpbmsgUm9vbX0uXG4gICAgICogQHBhcmFtIHtMb2NhbFRyYWNrfSBsb2NhbFRyYWNrIC0gVGhlIHtAbGluayBMb2NhbFRyYWNrfSB0byBwdWJsaXNoXG4gICAgICogQHBhcmFtIHtMb2NhbFRyYWNrUHVibGlzaE9wdGlvbnN9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgTG9jYWxUcmFja1B1Ymxpc2hPcHRpb25zfVxuICAgICAqICAgZm9yIHB1Ymxpc2hpbmcgdGhlIHtAbGluayBMb2NhbFRyYWNrfVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbj59IC0gUmVzb2x2ZXMgd2l0aCB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqICAge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn0gaWYgc3VjY2Vzc2Z1bDsgSW4gYSBMYXJnZSBHcm91cCBSb29tIChNYXhpbXVtXG4gICAgICogICBQYXJ0aWNpcGFudHMgZ3JlYXRlciB0aGFuIDUwKSwgcmVqZWN0cyB3aXRoIGEge0BsaW5rIFBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvcn1cbiAgICAgKiAgIGlmIGVpdGhlciB0aGUgdG90YWwgbnVtYmVyIG9mIHB1Ymxpc2hlZCBUcmFja3MgaW4gdGhlIFJvb20gZXhjZWVkcyAxNiwgb3IgdGhlIHtAbGluayBMb2NhbFRyYWNrfVxuICAgICAqICAgaXMgcGFydCBvZiBhIHNldCBvZiB7QGxpbmsgTG9jYWxUcmFja31zIHdoaWNoIGFsb25nIHdpdGggdGhlIHB1Ymxpc2hlZCBUcmFja3MgZXhjZWVkcyAxNi5cbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICAgICAqXG4gICAgICogVmlkZW8uY29ubmVjdCh0b2tlbiwge1xuICAgICAqICAgbmFtZTogJ215LWNvb2wtcm9vbScsXG4gICAgICogICBhdWRpbzogdHJ1ZVxuICAgICAqIH0pLnRoZW4oZnVuY3Rpb24ocm9vbSkge1xuICAgICAqICAgcmV0dXJuIFZpZGVvLmNyZWF0ZUxvY2FsVmlkZW9UcmFjayh7XG4gICAgICogICAgIG5hbWU6ICdjYW1lcmEnXG4gICAgICogICB9KS50aGVuKGZ1bmN0aW9uKGxvY2FsVmlkZW9UcmFjaykge1xuICAgICAqICAgICByZXR1cm4gcm9vbS5sb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hUcmFjayhsb2NhbFZpZGVvVHJhY2ssIHtcbiAgICAgKiAgICAgICBwcmlvcml0eTogJ2hpZ2gnXG4gICAgICogICAgIH0pO1xuICAgICAqICAgfSk7XG4gICAgICogfSkudGhlbihmdW5jdGlvbihwdWJsaWNhdGlvbikge1xuICAgICAqICAgY29uc29sZS5sb2coJ1RoZSBMb2NhbFRyYWNrIFwiJyArIHB1YmxpY2F0aW9uLnRyYWNrTmFtZVxuICAgICAqICAgICArICdcIiB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZCB3aXRoIHByaW9yaXR5IFwiJ1xuICAgICAqICAgICAqIHB1YmxpY2F0aW9uLnByaW9yaXR5ICsgJ1wiJyk7XG4gICAgICogfSk7XG4gICAgKi8gLyoqXG4gICAgICogUHVibGlzaGVzIGEgTWVkaWFTdHJlYW1UcmFjayB0byB0aGUge0BsaW5rIFJvb219LlxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gbWVkaWFTdHJlYW1UcmFjayAtIFRoZSBNZWRpYVN0cmVhbVRyYWNrXG4gICAgICogICB0byBwdWJsaXNoOyBpZiBhIGNvcnJlc3BvbmRpbmcge0BsaW5rIExvY2FsQXVkaW9UcmFja30gb3JcbiAgICAgKiAgIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IGhhcyBub3QgeWV0IGJlZW4gcHVibGlzaGVkLCB0aGlzIG1ldGhvZCB3aWxsXG4gICAgICogICBjb25zdHJ1Y3Qgb25lXG4gICAgICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrUHVibGlzaE9wdGlvbnN9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zIGZvciBwdWJsaXNoaW5nXG4gICAgICogICB0aGUgTWVkaWFTdHJlYW1UcmFja1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbj59IC0gUmVzb2x2ZXMgd2l0aCB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqICAge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn0gaWYgc3VjY2Vzc2Z1bDsgSW4gYSBMYXJnZSBHcm91cCBSb29tIChNYXhpbXVtXG4gICAgICogICBQYXJ0aWNpcGFudHMgZ3JlYXRlciB0aGFuIDUwKSwgcmVqZWN0cyB3aXRoIGEge0BsaW5rIFBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvcn1cbiAgICAgKiAgIGlmIHRoZSB0b3RhbCBudW1iZXIgb2YgcHVibGlzaGVkIFRyYWNrcyBpbiB0aGUgUm9vbSBleGNlZWRzIDE2LCBvciB0aGUge0BsaW5rIExvY2FsVHJhY2t9XG4gICAgICogICBpcyBwYXJ0IG9mIGEgc2V0IG9mIHtAbGluayBMb2NhbFRyYWNrfXMgd2hpY2ggYWxvbmcgd2l0aCB0aGUgcHVibGlzaGVkIFRyYWNrcyBleGNlZWRzIDE2LlxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gICAgICpcbiAgICAgKiBWaWRlby5jb25uZWN0KHRva2VuLCB7XG4gICAgICogICBuYW1lOiAnbXktY29vbC1yb29tJyxcbiAgICAgKiAgIGF1ZGlvOiB0cnVlXG4gICAgICogfSkudGhlbihmdW5jdGlvbihyb29tKSB7XG4gICAgICogICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAqICAgICB2aWRlbzogdHJ1ZVxuICAgICAqICAgfSkudGhlbihmdW5jdGlvbihtZWRpYVN0cmVhbSkge1xuICAgICAqICAgICB2YXIgbWVkaWFTdHJlYW1UcmFjayA9IG1lZGlhU3RyZWFtLmdldFRyYWNrcygpWzBdO1xuICAgICAqICAgICByZXR1cm4gcm9vbS5sb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hUcmFjayhtZWRpYVN0cmVhbVRyYWNrLCB7XG4gICAgICogICAgICAgbmFtZTogJ2NhbWVyYScsXG4gICAgICogICAgICAgcHJpb3JpdHk6ICdoaWdoJ1xuICAgICAqICAgICB9KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pLnRoZW4oZnVuY3Rpb24ocHVibGljYXRpb24pIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdUaGUgTG9jYWxUcmFjayBcIicgKyBwdWJsaWNhdGlvbi50cmFja05hbWVcbiAgICAgKiAgICAgKyAnXCIgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQgd2l0aCBwcmlvcml0eSBcIidcbiAgICAgKiAgICAgKiBwdWJsaWNhdGlvbi5wcmlvcml0eSArICdcIicpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnQucHJvdG90eXBlLnB1Ymxpc2hUcmFjayA9IGZ1bmN0aW9uIChsb2NhbFRyYWNrT3JNZWRpYVN0cmVhbVRyYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0cmFja1B1YmxpY2F0aW9uID0gZ2V0VHJhY2tQdWJsaWNhdGlvbih0aGlzLnRyYWNrcywgbG9jYWxUcmFja09yTWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgIGlmICh0cmFja1B1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRyYWNrUHVibGljYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGxvZzogdGhpcy5fbG9nLFxuICAgICAgICAgICAgcHJpb3JpdHk6IHRyYWNrUHJpb3JpdHkuUFJJT1JJVFlfU1RBTkRBUkQsXG4gICAgICAgICAgICBMb2NhbEF1ZGlvVHJhY2s6IHRoaXMuX0xvY2FsQXVkaW9UcmFjayxcbiAgICAgICAgICAgIExvY2FsRGF0YVRyYWNrOiB0aGlzLl9Mb2NhbERhdGFUcmFjayxcbiAgICAgICAgICAgIExvY2FsVmlkZW9UcmFjazogdGhpcy5fTG9jYWxWaWRlb1RyYWNrLFxuICAgICAgICAgICAgTWVkaWFTdHJlYW1UcmFjazogdGhpcy5fTWVkaWFTdHJlYW1UcmFja1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIGxvY2FsVHJhY2s7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2NhbFRyYWNrID0gYXNMb2NhbFRyYWNrKGxvY2FsVHJhY2tPck1lZGlhU3RyZWFtVHJhY2ssIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJpb3JpdHlWYWx1ZXMgPSBPYmplY3QudmFsdWVzKHRyYWNrUHJpb3JpdHkpO1xuICAgICAgICBpZiAoIXByaW9yaXR5VmFsdWVzLmluY2x1ZGVzKG9wdGlvbnMucHJpb3JpdHkpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEUuSU5WQUxJRF9WQUxVRSgnTG9jYWxUcmFja1B1Ymxpc2hPcHRpb25zLnByaW9yaXR5JywgcHJpb3JpdHlWYWx1ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRkZWRMb2NhbFRyYWNrID0gdGhpcy5fYWRkVHJhY2sobG9jYWxUcmFjaywgb3B0aW9ucy5wcmlvcml0eSlcbiAgICAgICAgICAgIHx8IHRoaXMuX3RyYWNrcy5nZXQobG9jYWxUcmFjay5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZUxvY2FsVHJhY2tQdWJsaWNhdGlvbihhZGRlZExvY2FsVHJhY2spO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIG11bHRpcGxlIHtAbGluayBMb2NhbFRyYWNrfXMgdG8gdGhlIHtAbGluayBSb29tfS5cbiAgICAgKiBAcGFyYW0ge0FycmF5PExvY2FsVHJhY2t8TWVkaWFTdHJlYW1UcmFjaz59IHRyYWNrcyAtIFRoZSB7QGxpbmsgTG9jYWxUcmFja31zXG4gICAgICogICB0byBwdWJsaXNoOyBmb3IgYW55IE1lZGlhU3RyZWFtVHJhY2tzIHByb3ZpZGVkLCBpZiBhIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IG9yIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IGhhcyBub3QgeWV0IGJlZW5cbiAgICAgKiAgIHB1Ymxpc2hlZCwgdGhpcyBtZXRob2Qgd2lsbCBjb25zdHJ1Y3Qgb25lXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8TG9jYWxUcmFja1B1YmxpY2F0aW9uPj59IC0gVGhlIHJlc3VsdGluZ1xuICAgICAqICAge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn1zIGlmIHN1Y2Nlc3NmdWw7IEluIGEgTGFyZ2UgR3JvdXAgUm9vbSAoTWF4aW11bVxuICAgICAqICAgUGFydGljaXBhbnRzIGdyZWF0ZXIgdGhhbiA1MCksIHJlamVjdHMgd2l0aCBhIHtAbGluayBQYXJ0aWNpcGFudE1heFRyYWNrc0V4Y2VlZGVkRXJyb3J9XG4gICAgICogICBpZiB0aGUgdG90YWwgbnVtYmVyIG9mIHB1Ymxpc2hlZCBUcmFja3MgaW4gdGhlIFJvb20gZXhjZWVkcyAxNiwgb3IgdGhlIHtAbGluayBMb2NhbFRyYWNrfXNcbiAgICAgKiAgIGFsb25nIHdpdGggdGhlIHB1Ymxpc2hlZCBUcmFja3MgZXhjZWVkcyAxNi5cbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudC5wcm90b3R5cGUucHVibGlzaFRyYWNrcyA9IGZ1bmN0aW9uICh0cmFja3MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRyYWNrcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gICAgICAgICAgICB0aHJvdyBFLklOVkFMSURfVFlQRSgndHJhY2tzJywgJ0FycmF5IG9mIExvY2FsQXVkaW9UcmFjaywgTG9jYWxWaWRlb1RyYWNrLCBMb2NhbERhdGFUcmFjaywgb3IgTWVkaWFTdHJlYW1UcmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0cmFja3MubWFwKHRoaXMucHVibGlzaFRyYWNrLCB0aGlzKSk7XG4gICAgfTtcbiAgICBMb2NhbFBhcnRpY2lwYW50LnByb3RvdHlwZS5zZXRCYW5kd2lkdGhQcm9maWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2cud2Fybignc2V0QmFuZHdpZHRoUHJvZmlsZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0IGFuZCBtYXkgYmUgYXZhaWxhYmxlIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiB0d2lsaW8tdmlkZW8uanMnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHtAbGluayBOZXR3b3JrUXVhbGl0eVZlcmJvc2l0eX0gZm9yIHRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gYW5kXG4gICAgICoge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fXMuIEl0IGRvZXMgbm90aGluZyBpZiBOZXR3b3JrIFF1YWxpdHkgaXMgbm90IGVuYWJsZWRcbiAgICAgKiB3aGlsZSBjYWxsaW5nIHtAbGluayBjb25uZWN0fS5cbiAgICAgKiBAcGFyYW0ge05ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbn0gbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uIC0gVGhlIG5ld1xuICAgICAqICAge0BsaW5rIE5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbn07IElmIGVpdGhlciBvciBib3RoIG9mIHRoZSBsb2NhbCBhbmRcbiAgICAgKiAgIHJlbW90ZSB7QGxpbmsgTmV0d29ya1F1YWxpdHlWZXJib3NpdHl9IHZhbHVlcyBhcmUgYWJzZW50LCB0aGVuIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogICBleGlzdGluZyB2YWx1ZXMgYXJlIHJldGFpbmVkXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBVcGRhdGUgdmVyYm9zaXR5IGxldmVscyBmb3IgYm90aCBMb2NhbFBhcnRpY2lwYW50IGFuZCBSZW1vdGVQYXJ0aWNpcGFudHNcbiAgICAgKiBsb2NhbFBhcnRpY2lwYW50LnNldE5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbih7XG4gICAgICogICBsb2NhbDogMSxcbiAgICAgKiAgIHJlbW90ZTogMlxuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gVXBkYXRlIHZlcmJvc2l0eSBsZXZlbCBmb3Igb25seSB0aGUgTG9jYWxQYXJ0aWNpcGFudFxuICAgICAqIGxvY2FsUGFydGljaXBhbnQuc2V0TmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uKHtcbiAgICAgKiAgIGxvY2FsOiAxXG4gICAgICogfSk7XG4gICAgICogIEBleGFtcGxlXG4gICAgICogLy8gVXBkYXRlIHZlcmJvc2l0eSBsZXZlbCBmb3Igb25seSB0aGUgUmVtb3RlUGFydGljaXBhbnRzXG4gICAgICogbG9jYWxQYXJ0aWNpcGFudC5zZXROZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24oe1xuICAgICAqICAgcmVtb3RlOiAyXG4gICAgICogfSk7XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudC5wcm90b3R5cGUuc2V0TmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uID0gZnVuY3Rpb24gKG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbiAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgIHx8IG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgICAgICAgICAgIHRocm93IEUuSU5WQUxJRF9UWVBFKCduZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24nLCAnTmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgWydsb2NhbCcsICdyZW1vdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24gJiYgKHR5cGVvZiBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25bcHJvcF0gIT09ICdudW1iZXInIHx8IGlzTmFOKG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbltwcm9wXSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgICAgICAgICAgICAgICB0aHJvdyBFLklOVkFMSURfVFlQRShcIm5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbi5cIiArIHByb3AsICdudW1iZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NpZ25hbGluZy5zZXROZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24obmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSdzIHtAbGluayBFbmNvZGluZ1BhcmFtZXRlcnN9LlxuICAgICAqIEBwYXJhbSB7P0VuY29kaW5nUGFyYW1ldGVyc30gW2VuY29kaW5nUGFyYW1ldGVyc10gLSBUaGUgbmV3XG4gICAgICogICB7QGxpbmsgRW5jb2RpbmdQYXJhbWV0ZXJzfTsgSWYgbnVsbCwgdGhlbiB0aGUgYml0cmF0ZSBsaW1pdHMgYXJlIHJlbW92ZWQ7XG4gICAgICogICBJZiBub3Qgc3BlY2lmaWVkLCB0aGVuIHRoZSBleGlzdGluZyBiaXRyYXRlIGxpbWl0cyBhcmUgcHJlc2VydmVkXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfVxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnQucHJvdG90eXBlLnNldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoZW5jb2RpbmdQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmdQYXJhbWV0ZXJzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgJiYgdHlwZW9mIGVuY29kaW5nUGFyYW1ldGVycyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gICAgICAgICAgICB0aHJvdyBFLklOVkFMSURfVFlQRSgnZW5jb2RpbmdQYXJhbWV0ZXJzJywgJ0VuY29kaW5nUGFyYW1ldGVycywgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jb2RpbmdQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2lnbmFsaW5nLmdldFBhcmFtZXRlcnMoKS5hZGFwdGl2ZVNpbXVsY2FzdCAmJiBlbmNvZGluZ1BhcmFtZXRlcnMubWF4VmlkZW9CaXRyYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgICAgICAgICAgICAgICB0aHJvdyBFLklOVkFMSURfVFlQRSgnZW5jb2RpbmdQYXJhbWV0ZXJzJywgJ2VuY29kaW5nUGFyYW1ldGVycy5tYXhWaWRlb0JpdHJhdGUgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBcInByZWZlcnJlZFZpZGVvQ29kZWNzPWF1dG9cIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgWydtYXhBdWRpb0JpdHJhdGUnLCAnbWF4VmlkZW9CaXRyYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmdQYXJhbWV0ZXJzW3Byb3BdICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAmJiB0eXBlb2YgZW5jb2RpbmdQYXJhbWV0ZXJzW3Byb3BdICE9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAmJiBlbmNvZGluZ1BhcmFtZXRlcnNbcHJvcF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRS5JTlZBTElEX1RZUEUoXCJlbmNvZGluZ1BhcmFtZXRlcnMuXCIgKyBwcm9wLCAnbnVtYmVyLCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5nUGFyYW1ldGVycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzID0geyBtYXhBdWRpb0JpdHJhdGU6IG51bGwsIG1heFZpZGVvQml0cmF0ZTogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpZ25hbGluZy5zZXRQYXJhbWV0ZXJzKGVuY29kaW5nUGFyYW1ldGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcHMgcHVibGlzaGluZyBhIHtAbGluayBMb2NhbFRyYWNrfSB0byB0aGUge0BsaW5rIFJvb219LlxuICAgICAqIEBwYXJhbSB7TG9jYWxUcmFja3xNZWRpYVN0cmVhbVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgTG9jYWxUcmFja31cbiAgICAgKiAgIHRvIHN0b3AgcHVibGlzaGluZzsgaWYgYSBNZWRpYVN0cmVhbVRyYWNrIGlzIHByb3ZpZGVkLCB0aGlzIG1ldGhvZFxuICAgICAqICAgbG9va3MgdXAgdGhlIGNvcnJlc3BvbmRpbmcge0BsaW5rIExvY2FsQXVkaW9UcmFja30gb3JcbiAgICAgKiAgIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IHRvIHN0b3AgcHVibGlzaGluZ1xuICAgICAqIEByZXR1cm5zIHs/TG9jYWxUcmFja1B1YmxpY2F0aW9ufSAtIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogICB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9ufSBpZiB0aGUge0BsaW5rIExvY2FsVHJhY2t9IHdhcyBwcmV2aW91c2x5XG4gICAgICogICBwdWJsaXNoZWQsIG51bGwgb3RoZXJ3aXNlXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfVxuICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudC5wcm90b3R5cGUudW5wdWJsaXNoVHJhY2sgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFsaWRhdGVMb2NhbFRyYWNrKHRyYWNrLCB7XG4gICAgICAgICAgICBMb2NhbEF1ZGlvVHJhY2s6IHRoaXMuX0xvY2FsQXVkaW9UcmFjayxcbiAgICAgICAgICAgIExvY2FsRGF0YVRyYWNrOiB0aGlzLl9Mb2NhbERhdGFUcmFjayxcbiAgICAgICAgICAgIExvY2FsVmlkZW9UcmFjazogdGhpcy5fTG9jYWxWaWRlb1RyYWNrLFxuICAgICAgICAgICAgTWVkaWFTdHJlYW1UcmFjazogdGhpcy5fTWVkaWFTdHJlYW1UcmFja1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxvY2FsVHJhY2sgPSB0aGlzLl90cmFja3MuZ2V0KHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKCFsb2NhbFRyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhY2tTaWduYWxpbmcgPSB0aGlzLl9zaWduYWxpbmcuZ2V0UHVibGljYXRpb24obG9jYWxUcmFjay5fdHJhY2tTZW5kZXIpO1xuICAgICAgICB0cmFja1NpZ25hbGluZy5wdWJsaXNoRmFpbGVkKG5ldyBFcnJvcihcIlRoZSBcIiArIGxvY2FsVHJhY2sgKyBcIiB3YXMgdW5wdWJsaXNoZWRcIikpO1xuICAgICAgICBsb2NhbFRyYWNrID0gdGhpcy5fcmVtb3ZlVHJhY2sobG9jYWxUcmFjayk7XG4gICAgICAgIGlmICghbG9jYWxUcmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvY2FsVHJhY2tQdWJsaWNhdGlvbiA9IGdldFRyYWNrUHVibGljYXRpb24odGhpcy50cmFja3MsIGxvY2FsVHJhY2spO1xuICAgICAgICBpZiAobG9jYWxUcmFja1B1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVUcmFja1B1YmxpY2F0aW9uKGxvY2FsVHJhY2tQdWJsaWNhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsVHJhY2tQdWJsaWNhdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3BzIHB1Ymxpc2hpbmcgbXVsdGlwbGUge0BsaW5rIExvY2FsVHJhY2t9cyB0byB0aGUge0BsaW5rIFJvb219LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8TG9jYWxUcmFja3xNZWRpYVN0cmVhbVRyYWNrPn0gdHJhY2tzIC0gVGhlIHtAbGluayBMb2NhbFRyYWNrfXNcbiAgICAgKiAgIHRvIHN0b3AgcHVibGlzaGluZzsgZm9yIGFueSBNZWRpYVN0cmVhbVRyYWNrcyBwcm92aWRlZCwgdGhpcyBtZXRob2QgbG9va3NcbiAgICAgKiAgIHVwIHRoZSBjb3JyZXNwb25kaW5nIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IG9yIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IHRvXG4gICAgICogICBzdG9wIHB1Ymxpc2hpbmdcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8TG9jYWxUcmFja1B1YmxpY2F0aW9uPn0gLSBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqICAge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn1zIHRoYXQgd2VyZSBzdWNjZXNzZnVsbHkgdW5wdWJsaXNoZWRcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudC5wcm90b3R5cGUudW5wdWJsaXNoVHJhY2tzID0gZnVuY3Rpb24gKHRyYWNrcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodHJhY2tzKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgICAgICAgICAgIHRocm93IEUuSU5WQUxJRF9UWVBFKCd0cmFja3MnLCAnQXJyYXkgb2YgTG9jYWxBdWRpb1RyYWNrLCBMb2NhbFZpZGVvVHJhY2ssIExvY2FsRGF0YVRyYWNrLCBvciBNZWRpYVN0cmVhbVRyYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYWNrcy5yZWR1Y2UoZnVuY3Rpb24gKHVucHVibGlzaGVkVHJhY2tzLCB0cmFjaykge1xuICAgICAgICAgICAgdmFyIHVucHVibGlzaGVkVHJhY2sgPSBfdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgICAgICAgICByZXR1cm4gdW5wdWJsaXNoZWRUcmFjayA/IHVucHVibGlzaGVkVHJhY2tzLmNvbmNhdCh1bnB1Ymxpc2hlZFRyYWNrKSA6IHVucHVibGlzaGVkVHJhY2tzO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxQYXJ0aWNpcGFudDtcbn0oUGFydGljaXBhbnQpKTtcbi8qKlxuICogVGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBoYXMgcmVjb25uZWN0ZWQgdG8gdGhlIHtAbGluayBSb29tfSBhZnRlciBhIHNpZ25hbGluZyBjb25uZWN0aW9uIGRpc3J1cHRpb24uXG4gKiBAZXZlbnQgTG9jYWxQYXJ0aWNpcGFudCNyZWNvbm5lY3RlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gaXMgcmVjb25uZWN0aW5nIHRvIHRoZSB7QGxpbmsgUm9vbX0gYWZ0ZXIgYSBzaWduYWxpbmcgY29ubmVjdGlvbiBkaXNydXB0aW9uLlxuICogQGV2ZW50IExvY2FsUGFydGljaXBhbnQjcmVjb25uZWN0aW5nXG4gKi9cbi8qKlxuICogT25lIG9mIHRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0ncyB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSdzIGRpbWVuc2lvbnMgY2hhbmdlZC5cbiAqIEBwYXJhbSB7TG9jYWxWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSB3aG9zZSBkaW1lbnNpb25zIGNoYW5nZWRcbiAqIEBldmVudCBMb2NhbFBhcnRpY2lwYW50I3RyYWNrRGltZW5zaW9uc0NoYW5nZWRcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBMb2NhbFRyYWNrfSB3YXMgZGlzYWJsZWQgYnkgdGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fS5cbiAqIEBwYXJhbSB7TG9jYWxUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIExvY2FsVHJhY2t9IHRoYXQgd2FzIGRpc2FibGVkXG4gKiBAZXZlbnQgTG9jYWxQYXJ0aWNpcGFudCN0cmFja0Rpc2FibGVkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgTG9jYWxUcmFja30gd2FzIGVuYWJsZWQgYnkgdGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fS5cbiAqIEBwYXJhbSB7TG9jYWxUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIExvY2FsVHJhY2t9IHRoYXQgd2FzIGVuYWJsZWRcbiAqIEBldmVudCBMb2NhbFBhcnRpY2lwYW50I3RyYWNrRW5hYmxlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIExvY2FsVHJhY2t9IGZhaWxlZCB0byBwdWJsaXNoLiBDaGVjayB0aGUgZXJyb3IgbWVzc2FnZSBmb3IgbW9yZVxuICogaW5mb3JtYXRpb24uIEluIGEgTGFyZ2UgR3JvdXAgUm9vbSAoTWF4aW11bSBQYXJ0aWNpcGFudHMgZ3JlYXRlciB0aGFuIDUwKSxcbiAqIHRoaXMgZXZlbnQgaXMgcmFpc2VkIHdpdGggYSB7QGxpbmsgUGFydGljaXBhbnRNYXhUcmFja3NFeGNlZWRlZEVycm9yfSBlaXRoZXJcbiAqIHdoZW4gYXR0ZW1wdGluZyB0byBwdWJsaXNoIHRoZSB7QGxpbmsgTG9jYWxUcmFja30gd2lsbCBleGNlZWQgdGhlIE1heGltdW0gUHVibGlzaGVkXG4gKiBUcmFja3MgbGltaXQgb2YgMTYsIG9yIHRoZSB7QGxpbmsgTG9jYWxUcmFja30gaXMgcGFydCBvZiBhIHNldCBvZiB7QGxpbmsgTG9jYWxUcmFja31zXG4gKiB3aGljaCBhbG9uZyB3aXRoIHRoZSBwdWJsaXNoZWQgVHJhY2tzIGV4Y2VlZHMgMTYuXG4gKiBAcGFyYW0ge1R3aWxpb0Vycm9yfSBlcnJvciAtIEEge0BsaW5rIFR3aWxpb0Vycm9yfSBleHBsYWluaW5nIHdoeSBwdWJsaWNhdGlvblxuICogICBmYWlsZWRcbiAqIEBwYXJhbSB7TG9jYWxUcmFja30gbG9jYWxUcmFjayAtIFRoZSB7QGxpbmsgTG9jYWxUcmFja30gdGhhdCBmYWlsZWQgdG9cbiAqICAgcHVibGlzaFxuICogQGV2ZW50IExvY2FsUGFydGljaXBhbnQjdHJhY2tQdWJsaWNhdGlvbkZhaWxlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIExvY2FsVHJhY2t9IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHBhcmFtIHtMb2NhbFRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlIHJlc3VsdGluZ1xuICogICB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9ufSBmb3IgdGhlIHB1Ymxpc2hlZCB7QGxpbmsgTG9jYWxUcmFja31cbiAqIEBldmVudCBMb2NhbFBhcnRpY2lwYW50I3RyYWNrUHVibGlzaGVkXG4gKi9cbi8qKlxuICogT25lIG9mIHRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0ncyB7QGxpbmsgTG9jYWxUcmFja31zIHN0YXJ0ZWQuXG4gKiBAcGFyYW0ge0xvY2FsVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBMb2NhbFRyYWNrfSB0aGF0IHN0YXJ0ZWRcbiAqIEBldmVudCBMb2NhbFBhcnRpY2lwYW50I3RyYWNrU3RhcnRlZFxuICovXG4vKipcbiAqIE9uZSBvZiB0aGUge0BsaW5rIExvY2FsUGFydGljaXBhbnR9J3Mge0BsaW5rIExvY2FsVHJhY2t9cyBzdG9wcGVkLCBlaXRoZXJcbiAqIGJlY2F1c2Uge0BsaW5rIExvY2FsVHJhY2sjc3RvcH0gd2FzIGNhbGxlZCBvciBiZWNhdXNlIHRoZSB1bmRlcmx5aW5nXG4gKiBNZWRpYVN0cmVhbVRyYWNrIGVuZGVkKS5cbiAqIEBwYXJhbSB7TG9jYWxUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIExvY2FsVHJhY2t9IHRoYXQgc3RvcHBlZFxuICogQGV2ZW50IExvY2FsUGFydGljaXBhbnQjdHJhY2tTdG9wcGVkXG4gKi9cbi8qKlxuICogT3V0Z29pbmcgbWVkaWEgZW5jb2RpbmcgcGFyYW1ldGVycy5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IEVuY29kaW5nUGFyYW1ldGVyc1xuICogQHByb3BlcnR5IHs/bnVtYmVyfSBbbWF4QXVkaW9CaXRyYXRlXSAtIE1heCBvdXRnb2luZyBhdWRpbyBiaXRyYXRlIChicHMpO1xuICogICBJZiBub3Qgc3BlY2lmaWVkLCByZXRhaW5zIHRoZSBleGlzdGluZyBiaXRyYXRlIGxpbWl0OyBBIDxjb2RlPm51bGw8L2NvZGU+IG9yIGFcbiAqICAgPGNvZGU+MDwvY29kZT4gdmFsdWUgcmVtb3ZlcyBhbnkgcHJldmlvdXNseSBzZXQgYml0cmF0ZSBsaW1pdDsgVGhpcyB2YWx1ZSBpcyBzZXRcbiAqICAgYXMgYSBoaW50IGZvciB2YXJpYWJsZSBiaXRyYXRlIGNvZGVjcywgYnV0IHdpbGwgbm90IHRha2UgZWZmZWN0IGZvciBmaXhlZCBiaXRyYXRlXG4gKiAgIGNvZGVjczsgQmFzZWQgb24gb3VyIHRlc3RzLCBDaHJvbWUsIEZpcmVmb3ggYW5kIFNhZmFyaSBzdXBwb3J0IGEgYml0cmF0ZSByYW5nZSBvZlxuICogICAxMjAwMCBicHMgdG8gMjU2MDAwIGJwcyBmb3IgT3B1cyBjb2RlYzsgVGhpcyBwYXJhbWV0ZXIgaGFzIG5vIGVmZmVjdCBvbiBpU0FDLCBQQ01VXG4gKiAgIGFuZCBQQ01BIGNvZGVjc1xuICogQHByb3BlcnR5IHs/bnVtYmVyfSBbbWF4VmlkZW9CaXRyYXRlXSAtIE1heCBvdXRnb2luZyB2aWRlbyBiaXRyYXRlIChicHMpO1xuICogICBJZiBub3Qgc3BlY2lmaWVkLCByZXRhaW5zIHRoZSBleGlzdGluZyBiaXRyYXRlIGxpbWl0OyBBIDxjb2RlPm51bGw8L2NvZGU+IG9yXG4gKiAgIGEgPGNvZGU+MDwvY29kZT4gdmFsdWUgcmVtb3ZlcyBhbnkgcHJldmlvdXNseSBzZXQgYml0cmF0ZSBsaW1pdDsgVGhpcyB2YWx1ZSBpc1xuICogICBzZXQgYXMgYSBoaW50IGZvciB2YXJpYWJsZSBiaXRyYXRlIGNvZGVjcywgYnV0IHdpbGwgbm90IHRha2UgZWZmZWN0IGZvciBmaXhlZFxuICogICBiaXRyYXRlIGNvZGVjczsgQmFzZWQgb24gb3VyIHRlc3RzLCBDaHJvbWUsIEZpcmVmb3ggYW5kIFNhZmFyaSBhbGwgc2VlbSB0byBzdXBwb3J0XG4gKiAgIGFuIGF2ZXJhZ2UgYml0cmF0ZSByYW5nZSBvZiAyMDAwMCBicHMgKDIwIGticHMpIHRvIDgwMDAwMDAgYnBzICg4IG1icHMpIGZvciBhXG4gKiAgIDcyMHAgVmlkZW9UcmFjay5cbiAqICAgTm90ZTogdGhpcyBsaW1pdCBpcyBub3QgYXBwbGllZCBmb3Igc2NyZWVuIHNoYXJlIHRyYWNrcyBwdWJsaXNoZWQgb24gQ2hyb21lLlxuICovXG4vKipcbiAqIE9wdGlvbnMgZm9yIHB1Ymxpc2hpbmcgYSB7QGxpbmsgTG9jYWxUcmFja30uXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBMb2NhbFRyYWNrUHVibGlzaE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7VHJhY2suUHJpb3JpdHl9IFtwcmlvcml0eT0nc3RhbmRhcmQnXSAtIFRoZSBwcmlvcml0eSB3aXRoIHdoaWNoIHRoZSB7QGxpbmsgTG9jYWxUcmFja31cbiAqICAgaXMgdG8gYmUgcHVibGlzaGVkOyBJbiBHcm91cCBvciBTbWFsbCBHcm91cCBSb29tcywgdGhlIGFwcHJvcHJpYXRlIGJhbmR3aWR0aCBpc1xuICogICBhbGxvY2F0ZWQgdG8gdGhlIHtAbGluayBMb2NhbFRyYWNrfSBiYXNlZCBvbiBpdHMge0BsaW5rIFRyYWNrLlByaW9yaXR5fTsgSXQgaGFzIG5vXG4gKiAgIGVmZmVjdCBpbiBQZWVyLXRvLVBlZXIgUm9vbXM7IEl0IGRlZmF1bHRzIHRvIFwic3RhbmRhcmRcIiB3aGVuIG5vdCBwcm92aWRlZFxuICovXG4vKipcbiAqIE9wdGlvbnMgZm9yIHB1Ymxpc2hpbmcgYSB7QGxpbmsgTWVkaWFTdHJlYW1UcmFja30uXG4gKiBAdHlwZWRlZiB7TG9jYWxUcmFja09wdGlvbnN9IE1lZGlhU3RyZWFtVHJhY2tQdWJsaXNoT3B0aW9uc1xuICogQHByb3BlcnR5IHtUcmFjay5Qcmlvcml0eX0gW3ByaW9yaXR5PSdzdGFuZGFyZCddIC0gVGhlIHByaW9yaXR5IHdpdGggd2hpY2ggdGhlIHtAbGluayBMb2NhbFRyYWNrfVxuICogICBpcyB0byBiZSBwdWJsaXNoZWQ7IEluIEdyb3VwIG9yIFNtYWxsIEdyb3VwIFJvb21zLCB0aGUgYXBwcm9wcmlhdGUgYmFuZHdpZHRoIGlzXG4gKiAgIGFsbG9jYXRlZCB0byB0aGUge0BsaW5rIExvY2FsVHJhY2t9IGJhc2VkIG9uIGl0cyB7QGxpbmsgVHJhY2suUHJpb3JpdHl9OyBJdCBoYXMgbm9cbiAqICAgZWZmZWN0IGluIFBlZXItdG8tUGVlciBSb29tczsgSXQgZGVmYXVsdHMgdG8gXCJzdGFuZGFyZFwiIHdoZW4gbm90IHByb3ZpZGVkXG4gKi9cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TWFwPFRyYWNrLlNJRCwgTG9jYWxUcmFja1B1YmxpY2F0aW9uPn0gdHJhY2tQdWJsaWNhdGlvbnNcbiAqIEBwYXJhbSB7TG9jYWxUcmFja3xNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICogQHJldHVybnMgez9Mb2NhbFRyYWNrUHVibGljYXRpb259IHRyYWNrUHVibGljYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhY2tQdWJsaWNhdGlvbih0cmFja1B1YmxpY2F0aW9ucywgdHJhY2spIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0cmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmluZChmdW5jdGlvbiAodHJhY2tQdWJsaWNhdGlvbikgeyByZXR1cm4gdHJhY2tQdWJsaWNhdGlvbi50cmFjayA9PT0gdHJhY2tcbiAgICAgICAgfHwgdHJhY2tQdWJsaWNhdGlvbi50cmFjay5tZWRpYVN0cmVhbVRyYWNrID09PSB0cmFjazsgfSkgfHwgbnVsbDtcbn1cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxQYXJ0aWNpcGFudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FscGFydGljaXBhbnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBNZWRpYVRyYWNrID0gcmVxdWlyZSgnLi9tZWRpYXRyYWNrJyk7XG4vKipcbiAqIEFuIHtAbGluayBBdWRpb1RyYWNrfSBpcyBhIHtAbGluayBUcmFja30gcmVwcmVzZW50aW5nIGF1ZGlvLlxuICogQGV4dGVuZHMgVHJhY2tcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTdGFydGVkIC0gV2hldGhlciBvciBub3QgdGhlIHtAbGluayBBdWRpb1RyYWNrfSBoYXNcbiAqICAgc3RhcnRlZDsgaWYgdGhlIHtAbGluayBBdWRpb1RyYWNrfSBzdGFydGVkLCB0aGVyZSBpcyBlbm91Z2ggYXVkaW8gZGF0YSB0b1xuICogICBiZWdpbiBwbGF5YmFja1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc0VuYWJsZWQgLSBXaGV0aGVyIG9yIG5vdCB0aGUge0BsaW5rIEF1ZGlvVHJhY2t9IGlzXG4gKiAgIGVuYWJsZWQ7IGlmIHRoZSB7QGxpbmsgQXVkaW9UcmFja30gaXMgbm90IGVuYWJsZWQsIGl0IGlzIFwibXV0ZWRcIlxuICogQHByb3BlcnR5IHtUcmFjay5LaW5kfSBraW5kIC0gXCJhdWRpb1wiXG4gKiBAcHJvcGVydHkgez9NZWRpYVN0cmVhbVRyYWNrfSBtZWRpYVN0cmVhbVRyYWNrIC0gUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nXG4gKiAgIE1lZGlhU3RyZWFtVHJhY2s7IEl0IGlzIHNldCB0byA8Y29kZT5udWxsPC9jb2RlPiBpZiBpdCBpcyBhIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfVxuICogICB0aGF0IGlzIHN3aXRjaGVkIG9mZlxuICogQHByb3BlcnR5IHs/TWVkaWFTdHJlYW1UcmFja30gcHJvY2Vzc2VkVHJhY2sgLSBUaGUgc291cmNlIG9mIHByb2Nlc3NlZCBhdWRpbyBzYW1wbGVzLlxuICogSXQgaXMgYWx3YXlzIG51bGwgYXMgYXVkaW8gcHJvY2Vzc2luZyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAqIEBlbWl0cyBBdWRpb1RyYWNrI2Rpc2FibGVkXG4gKiBAZW1pdHMgQXVkaW9UcmFjayNlbmFibGVkXG4gKiBAZW1pdHMgQXVkaW9UcmFjayNzdGFydGVkXG4gKi9cbnZhciBBdWRpb1RyYWNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBdWRpb1RyYWNrLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiB7QGxpbmsgQXVkaW9UcmFja30uXG4gICAgICogQHBhcmFtIHs/TWVkaWFUcmFja1RyYW5zY2VpdmVyfSBtZWRpYVRyYWNrVHJhbnNjZWl2ZXJcbiAgICAgKiBAcGFyYW0ge3tsb2c6IExvZywgbmFtZTogc3RyaW5nfX0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF1ZGlvVHJhY2sobWVkaWFUcmFja1RyYW5zY2VpdmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAnYXVkaW8nLCBtZWRpYVRyYWNrVHJhbnNjZWl2ZXIsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQXVkaW9UcmFjay5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9zdGFydC5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fZHVtbXlFbCkge1xuICAgICAgICAgICAgLy8gb25jZSBzdGFydGVkIGxldCBnbyBvZiBkdW1teSBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLl9kdW1teUVsLnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9kdW1teUVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIEhUTUxBdWRpb0VsZW1lbnQgYW5kIGF0dGFjaCB0aGUge0BsaW5rIEF1ZGlvVHJhY2t9IHRvIGl0LlxuICAgICAqXG4gICAgICogVGhlIEhUTUxBdWRpb0VsZW1lbnQncyA8Y29kZT5zcmNPYmplY3Q8L2NvZGU+IHdpbGwgYmUgc2V0IHRvIGEgbmV3XG4gICAgICogTWVkaWFTdHJlYW0gY29udGFpbmluZyB0aGUge0BsaW5rIEF1ZGlvVHJhY2t9J3MgTWVkaWFTdHJlYW1UcmFjay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtIVE1MQXVkaW9FbGVtZW50fSBhdWRpb0VsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gICAgICpcbiAgICAgKiBWaWRlby5jcmVhdGVMb2NhbEF1ZGlvVHJhY2soKS50aGVuKGZ1bmN0aW9uKGF1ZGlvVHJhY2spIHtcbiAgICAgKiAgIGNvbnN0IGF1ZGlvRWxlbWVudCA9IGF1ZGlvVHJhY2suYXR0YWNoKCk7XG4gICAgICogICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGF1ZGlvRWxlbWVudCk7XG4gICAgICogfSk7XG4gICAgKi8gLyoqXG4gICAgICogQXR0YWNoIHRoZSB7QGxpbmsgQXVkaW9UcmFja30gdG8gYW4gZXhpc3RpbmcgSFRNTE1lZGlhRWxlbWVudC4gVGhlXG4gICAgICogSFRNTE1lZGlhRWxlbWVudCBjb3VsZCBiZSBhbiBIVE1MQXVkaW9FbGVtZW50IG9yIGFuIEhUTUxWaWRlb0VsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgSFRNTE1lZGlhRWxlbWVudCdzIDxjb2RlPnNyY09iamVjdDwvY29kZT4gaXMgbm90IHNldCB0byBhIE1lZGlhU3RyZWFtLFxuICAgICAqIHRoaXMgbWV0aG9kIHNldHMgaXQgdG8gYSBuZXcgTWVkaWFTdHJlYW0gY29udGFpbmluZyB0aGUge0BsaW5rIEF1ZGlvVHJhY2t9J3NcbiAgICAgKiBNZWRpYVN0cmVhbVRyYWNrOyBvdGhlcndpc2UsIGl0IGFkZHMgdGhlIHtAbGluayBNZWRpYVRyYWNrfSdzXG4gICAgICogTWVkaWFTdHJlYW1UcmFjayB0byB0aGUgZXhpc3RpbmcgTWVkaWFTdHJlYW0uIEZpbmFsbHksIGlmIHRoZXJlIGFyZSBhbnkgb3RoZXJcbiAgICAgKiBNZWRpYVN0cmVhbVRyYWNrcyBvZiB0aGUgc2FtZSBraW5kIG9uIHRoZSBNZWRpYVN0cmVhbSwgdGhpcyBtZXRob2QgcmVtb3Zlc1xuICAgICAqIHRoZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhRWxlbWVudCAtIFRoZSBIVE1MTWVkaWFFbGVtZW50IHRvIGF0dGFjaCB0b1xuICAgICAqIEByZXR1cm5zIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYUVsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gICAgICpcbiAgICAgKiBjb25zdCB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAqIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodmlkZW9FbGVtZW50KTtcbiAgICAgKlxuICAgICAqIFZpZGVvLmNyZWF0ZUxvY2FsQXVkaW9UcmFjaygpLnRoZW4oZnVuY3Rpb24oYXVkaW9UcmFjaykge1xuICAgICAqICAgYXVkaW9UcmFjay5hdHRhY2godmlkZW9FbGVtZW50KTtcbiAgICAgKiB9KTtcbiAgICAqLyAvKipcbiAgICAgKiBBdHRhY2ggdGhlIHtAbGluayBBdWRpb1RyYWNrfSB0byBhbiBIVE1MTWVkaWFFbGVtZW50IHNlbGVjdGVkIGJ5XG4gICAgICogPGNvZGU+ZG9jdW1lbnQucXVlcnlTZWxlY3RvcjwvY29kZT4uIFRoZSBIVE1MTWVkaWFFbGVtZW50IGNvdWxkIGJlIGFuXG4gICAgICogSFRNTEF1ZGlvRWxlbWVudCBvciBhbiBIVE1MVmlkZW9FbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgdGhlIEhUTUxNZWRpYUVsZW1lbnQncyA8Y29kZT5zcmNPYmplY3Q8L2NvZGU+IGlzIG5vdCBzZXQgdG8gYSBNZWRpYVN0cmVhbSxcbiAgICAgKiB0aGlzIG1ldGhvZCBzZXRzIGl0IHRvIGEgbmV3IE1lZGlhU3RyZWFtIGNvbnRhaW5pbmcgdGhlIHtAbGluayBBdWRpb1RyYWNrfSdzXG4gICAgICogTWVkaWFTdHJlYW1UcmFjazsgb3RoZXJ3aXNlLCBpdCBhZGRzIHRoZSB7QGxpbmsgQXVkaW9UcmFja30nc1xuICAgICAqIE1lZGlhU3RyZWFtVHJhY2sgdG8gdGhlIGV4aXN0aW5nIE1lZGlhU3RyZWFtLiBGaW5hbGx5LCBpZiB0aGVyZSBhcmUgYW55IG90aGVyXG4gICAgICogTWVkaWFTdHJlYW1UcmFja3Mgb2YgdGhlIHNhbWUga2luZCBvbiB0aGUgTWVkaWFTdHJlYW0sIHRoaXMgbWV0aG9kIHJlbW92ZXNcbiAgICAgKiB0aGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gQSBxdWVyeSBzZWxlY3RvciBmb3IgdGhlIEhUTUxNZWRpYUVsZW1lbnQgdG9cbiAgICAgKiAgIGF0dGFjaCB0b1xuICAgICAqIEByZXR1cm5zIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYUVsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gICAgICpcbiAgICAgKiBjb25zdCB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAqIHZpZGVvRWxlbWVudC5pZCA9ICdteS12aWRlby1lbGVtZW50JztcbiAgICAgKiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHZpZGVvRWxlbWVudCk7XG4gICAgICpcbiAgICAgKiBWaWRlby5jcmVhdGVMb2NhbEF1ZGlvVHJhY2soKS50aGVuKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICogICB0cmFjay5hdHRhY2goJyNteS12aWRlby1lbGVtZW50Jyk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgQXVkaW9UcmFjay5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5hdHRhY2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaCB0aGUge0BsaW5rIEF1ZGlvVHJhY2t9IGZyb20gYWxsIHByZXZpb3VzbHkgYXR0YWNoZWQgSFRNTE1lZGlhRWxlbWVudHMuXG4gICAgICogQHJldHVybnMge0FycmF5PEhUTUxNZWRpYUVsZW1lbnQ+fSBtZWRpYUVsZW1lbnRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBtZWRpYUVsZW1lbnRzID0gYXVkaW9UcmFjay5kZXRhY2goKTtcbiAgICAgKiBtZWRpYUVsZW1lbnRzLmZvckVhY2gobWVkaWFFbGVtZW50ID0+IG1lZGlhRWxlbWVudC5yZW1vdmUoKSk7XG4gICAgKi8gLyoqXG4gICAgICogRGV0YWNoIHRoZSB7QGxpbmsgQXVkaW9UcmFja30gZnJvbSBhIHByZXZpb3VzbHkgYXR0YWNoZWQgSFRNTE1lZGlhRWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhRWxlbWVudCAtIE9uZSBvZiB0aGUgSFRNTE1lZGlhRWxlbWVudHMgdG9cbiAgICAgKiAgIHdoaWNoIHRoZSB7QGxpbmsgQXVkaW9UcmFja30gaXMgYXR0YWNoZWRcbiAgICAgKiBAcmV0dXJucyB7SFRNTE1lZGlhRWxlbWVudH0gbWVkaWFFbGVtZW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXktdmlkZW8tZWxlbWVudCcpO1xuICAgICAqIGF1ZGlvVHJhY2suZGV0YWNoKHZpZGVvRWxlbWVudCkucmVtb3ZlKCk7XG4gICAgKi8gLyoqXG4gICAgICogRGV0YWNoIHRoZSB7QGxpbmsgQXVkaW9UcmFja30gZnJvbSBhIHByZXZpb3VzbHkgYXR0YWNoZWQgSFRNTE1lZGlhRWxlbWVudFxuICAgICAqICAgc3BlY2lmaWVkIGJ5IDxjb2RlPmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3I8L2NvZGU+LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIFRoZSBxdWVyeSBzZWxlY3RvciBvZiBIVE1MTWVkaWFFbGVtZW50IHRvIHdoaWNoXG4gICAgICogICAgdGhlIHtAbGluayBBdWRpb1RyYWNrfSBpcyBhdHRhY2hlZFxuICAgICAqIEByZXR1cm5zIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYUVsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF1ZGlvVHJhY2suZGV0YWNoKCcjbXktdmlkZW8tZWxlbWVudCcpLnJlbW92ZSgpO1xuICAgICAqL1xuICAgIEF1ZGlvVHJhY2sucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZGV0YWNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICByZXR1cm4gQXVkaW9UcmFjaztcbn0oTWVkaWFUcmFjaykpO1xuLyoqXG4gKiBUaGUge0BsaW5rIEF1ZGlvVHJhY2t9IHdhcyBkaXNhYmxlZCwgaS5lLiBcIm11dGVkXCIuXG4gKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBBdWRpb1RyYWNrfSB0aGF0IHdhcyBkaXNhYmxlZFxuICogQGV2ZW50IEF1ZGlvVHJhY2sjZGlzYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIEF1ZGlvVHJhY2t9IHdhcyBlbmFibGVkLCBpLmUuIFwidW5tdXRlZFwiLlxuICogQHBhcmFtIHtBdWRpb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgQXVkaW9UcmFja30gdGhhdCB3YXMgZW5hYmxlZFxuICogQGV2ZW50IEF1ZGlvVHJhY2sjZW5hYmxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgQXVkaW9UcmFja30gc3RhcnRlZC4gVGhpcyBtZWFucyB0aGVyZSBpcyBlbm91Z2ggYXVkaW8gZGF0YSB0b1xuICogYmVnaW4gcGxheWJhY2suXG4gKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBBdWRpb1RyYWNrfSB0aGF0IHN0YXJ0ZWRcbiAqIEBldmVudCBBdWRpb1RyYWNrI3N0YXJ0ZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBdWRpb1RyYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXVkaW90cmFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBMb2NhbEF1ZGlvVHJhY2s6IHJlcXVpcmUoJy4vbG9jYWxhdWRpb3RyYWNrJyksXG4gICAgTG9jYWxWaWRlb1RyYWNrOiByZXF1aXJlKCcuL2xvY2FsdmlkZW90cmFjaycpLFxuICAgIExvY2FsRGF0YVRyYWNrOiByZXF1aXJlKCcuL2xvY2FsZGF0YXRyYWNrJylcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8td2FybmluZy1jb21tZW50c1xuLy8gVE9ETyhtcm9iZXJ0cyk6IFJlbW92ZSB0aGlzIHdoZW4gd2UgZ28gdG8gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gVGhpcyBpc1xuLy8gb25seSBpbiBwbGFjZSBzbyB0aGF0IHdlIGNhbiBzdXBwb3J0IEVTNiBjbGFzc2VzIHdpdGhvdXQgcmVxdWlyaW5nIGBuZXdgLlxuJ3VzZSBzdHJpY3QnO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIExvY2FsQXVkaW9UcmFja0NsYXNzID0gcmVxdWlyZSgnLi4vbG9jYWxhdWRpb3RyYWNrJyk7XG5mdW5jdGlvbiBMb2NhbEF1ZGlvVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgb3B0aW9ucykge1xuICAgIHZhciB0cmFjayA9IG5ldyBMb2NhbEF1ZGlvVHJhY2tDbGFzcyhtZWRpYVN0cmVhbVRyYWNrLCBvcHRpb25zKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodHJhY2ssIExvY2FsQXVkaW9UcmFjay5wcm90b3R5cGUpO1xuICAgIHJldHVybiB0cmFjaztcbn1cbmluaGVyaXRzKExvY2FsQXVkaW9UcmFjaywgTG9jYWxBdWRpb1RyYWNrQ2xhc3MpO1xubW9kdWxlLmV4cG9ydHMgPSBMb2NhbEF1ZGlvVHJhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbGF1ZGlvdHJhY2suanMubWFwIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXdhcm5pbmctY29tbWVudHNcbi8vIFRPRE8obXJvYmVydHMpOiBSZW1vdmUgdGhpcyB3aGVuIHdlIGdvIHRvIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uIFRoaXMgaXNcbi8vIG9ubHkgaW4gcGxhY2Ugc28gdGhhdCB3ZSBjYW4gc3VwcG9ydCBFUzYgY2xhc3NlcyB3aXRob3V0IHJlcXVpcmluZyBgbmV3YC5cbid1c2Ugc3RyaWN0JztcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBMb2NhbERhdGFUcmFja0NsYXNzID0gcmVxdWlyZSgnLi4vbG9jYWxkYXRhdHJhY2snKTtcbmZ1bmN0aW9uIExvY2FsRGF0YVRyYWNrKG9wdGlvbnMpIHtcbiAgICB2YXIgdHJhY2sgPSBuZXcgTG9jYWxEYXRhVHJhY2tDbGFzcyhvcHRpb25zKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodHJhY2ssIExvY2FsRGF0YVRyYWNrLnByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHRyYWNrO1xufVxuaW5oZXJpdHMoTG9jYWxEYXRhVHJhY2ssIExvY2FsRGF0YVRyYWNrQ2xhc3MpO1xubW9kdWxlLmV4cG9ydHMgPSBMb2NhbERhdGFUcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsZGF0YXRyYWNrLmpzLm1hcCIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby13YXJuaW5nLWNvbW1lbnRzXG4vLyBUT0RPKG1yb2JlcnRzKTogUmVtb3ZlIHRoaXMgd2hlbiB3ZSBnbyB0byB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiBUaGlzIGlzXG4vLyBvbmx5IGluIHBsYWNlIHNvIHRoYXQgd2UgY2FuIHN1cHBvcnQgRVM2IGNsYXNzZXMgd2l0aG91dCByZXF1aXJpbmcgYG5ld2AuXG4ndXNlIHN0cmljdCc7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG52YXIgTG9jYWxWaWRlb1RyYWNrQ2xhc3MgPSByZXF1aXJlKCcuLi9sb2NhbHZpZGVvdHJhY2snKTtcbmZ1bmN0aW9uIExvY2FsVmlkZW9UcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIHRyYWNrID0gbmV3IExvY2FsVmlkZW9UcmFja0NsYXNzKG1lZGlhU3RyZWFtVHJhY2ssIG9wdGlvbnMpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0cmFjaywgTG9jYWxWaWRlb1RyYWNrLnByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHRyYWNrO1xufVxuaW5oZXJpdHMoTG9jYWxWaWRlb1RyYWNrLCBMb2NhbFZpZGVvVHJhY2tDbGFzcyk7XG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsVmlkZW9UcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsdmlkZW90cmFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50ZW1pdHRlcicpO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLCBidWlsZExvZ0xldmVscyA9IF9hLmJ1aWxkTG9nTGV2ZWxzLCB2YWx1ZVRvSlNPTiA9IF9hLnZhbHVlVG9KU09OO1xudmFyIERFRkFVTFRfTE9HX0xFVkVMID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25zdGFudHMnKS5ERUZBVUxUX0xPR19MRVZFTDtcbnZhciBMb2cgPSByZXF1aXJlKCcuLi8uLi91dGlsL2xvZycpO1xudmFyIG5JbnN0YW5jZXMgPSAwO1xuLyoqXG4gKiBBIHtAbGluayBUcmFja30gcmVwcmVzZW50cyBhIHN0cmVhbSBvZiBhdWRpbywgdmlkZW8sIG9yIGRhdGEuXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZCAtIFRoZSB7QGxpbmsgVHJhY2t9J3Mga2luZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUge0BsaW5rIFRyYWNrfSdzIG5hbWVcbiAqL1xudmFyIFRyYWNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFjaywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgVHJhY2t9LlxuICAgICAqIEBwYXJhbSB7VHJhY2suS2luZH0ga2luZCAtIFRoZSB7QGxpbmsgVHJhY2t9J3Mga2luZFxuICAgICAqIEBwYXJhbSB7eyBsb2c6IExvZywgbmFtZTogc3RyaW5nIH19IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFjayhraW5kLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGxvZzogbnVsbCxcbiAgICAgICAgICAgIGxvZ0xldmVsOiBERUZBVUxUX0xPR19MRVZFTFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICB2YXIgbmFtZSA9IFN0cmluZyhvcHRpb25zLm5hbWUpO1xuICAgICAgICB2YXIgbG9nTGV2ZWxzID0gYnVpbGRMb2dMZXZlbHMob3B0aW9ucy5sb2dMZXZlbCk7XG4gICAgICAgIHZhciBsb2cgPSBvcHRpb25zLmxvZ1xuICAgICAgICAgICAgPyBvcHRpb25zLmxvZy5jcmVhdGVMb2coJ21lZGlhJywgX3RoaXMpXG4gICAgICAgICAgICA6IG5ldyBMb2coJ21lZGlhJywgX3RoaXMsIGxvZ0xldmVscywgb3B0aW9ucy5sb2dnZXJOYW1lKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9pbnN0YW5jZUlkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICsrbkluc3RhbmNlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sb2c6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbG9nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2luZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGtpbmRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUcmFjay5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWVUb0pTT04odGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhY2s7XG59KEV2ZW50RW1pdHRlcikpO1xuLyoqXG4gKiBUaGUge0BsaW5rIFRyYWNrfSBJRCBpcyBhIHN0cmluZyBpZGVudGlmaWVyIGZvciB0aGUge0BsaW5rIFRyYWNrfS5cbiAqIEB0eXBlZGVmIHtzdHJpbmd9IFRyYWNrLklEXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBUcmFja30ga2luZCBpcyBlaXRoZXIgXCJhdWRpb1wiLCBcInZpZGVvXCIsIG9yIFwiZGF0YVwiLlxuICogQHR5cGVkZWYge3N0cmluZ30gVHJhY2suS2luZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgVHJhY2t9J3MgcHJpb3JpdHkgY2FuIGJlIFwibG93XCIsIFwic3RhbmRhcmRcIiwgb3IgXCJoaWdoXCIuXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBUcmFjay5Qcmlvcml0eVxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgVHJhY2t9IFNJRCBpcyBhIHVuaXF1ZSBzdHJpbmcgaWRlbnRpZmllciBmb3IgdGhlIHtAbGluayBUcmFja31cbiAqIHRoYXQgaXMgcHVibGlzaGVkIHRvIGEge0BsaW5rIFJvb219LlxuICogQHR5cGVkZWYge3N0cmluZ30gVHJhY2suU0lEXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgRGF0YVRyYWNrfSBpcyBhIHtAbGluayBMb2NhbERhdGFUcmFja30gb3Ige0BsaW5rIFJlbW90ZURhdGFUcmFja30uXG4gKiBAdHlwZWRlZiB7TG9jYWxEYXRhVHJhY2t8UmVtb3RlRGF0YVRyYWNrfSBEYXRhVHJhY2tcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBMb2NhbFRyYWNrfSBpcyBhIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9LCB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSxcbiAqIG9yIHtAbGluayBMb2NhbERhdGFUcmFja30uXG4gKiBAdHlwZWRlZiB7TG9jYWxBdWRpb1RyYWNrfExvY2FsVmlkZW9UcmFja3xMb2NhbERhdGFUcmFja30gTG9jYWxUcmFja1xuICovXG4vKipcbiAqIHtAbGluayBMb2NhbFRyYWNrfSBvcHRpb25zXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBMb2NhbFRyYWNrT3B0aW9uc1xuICogQHByb3BlcnR5IHtMb2dMZXZlbHxMb2dMZXZlbHN9IGxvZ0xldmVsIC0gTG9nIGxldmVsIGZvciAnbWVkaWEnIG1vZHVsZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gLSBUaGUge0BsaW5rIExvY2FsVHJhY2t9J3MgbmFtZTsgYnkgZGVmYXVsdCxcbiAqICAgaXQgaXMgc2V0IHRvIHRoZSB7QGxpbmsgTG9jYWxUcmFja30ncyBJRC5cbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVUcmFja30gaXMgYSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30sXG4gKiB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30sIG9yIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9LlxuICogQHR5cGVkZWYge1JlbW90ZUF1ZGlvVHJhY2t8UmVtb3RlVmlkZW9UcmFja3xSZW1vdGVEYXRhVHJhY2t9IFJlbW90ZVRyYWNrXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVHJhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIEF1ZGlvVHJhY2sgPSByZXF1aXJlKCcuL2F1ZGlvdHJhY2snKTtcbnZhciBtaXhpbkxvY2FsTWVkaWFUcmFjayA9IHJlcXVpcmUoJy4vbG9jYWxtZWRpYXRyYWNrJyk7XG52YXIgTG9jYWxNZWRpYUF1ZGlvVHJhY2sgPSBtaXhpbkxvY2FsTWVkaWFUcmFjayhBdWRpb1RyYWNrKTtcbi8qKlxuICogQSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSBpcyBhbiB7QGxpbmsgQXVkaW9UcmFja30gcmVwcmVzZW50aW5nIGF1ZGlvIHRoYXRcbiAqIHlvdXIge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IGNhbiBwdWJsaXNoIHRvIGEge0BsaW5rIFJvb219LiBJdCBjYW4gYmVcbiAqIGVuYWJsZWQgYW5kIGRpc2FibGVkIHdpdGgge0BsaW5rIExvY2FsQXVkaW9UcmFjayNlbmFibGV9IGFuZFxuICoge0BsaW5rIExvY2FsQXVkaW9UcmFjayNkaXNhYmxlfSBvciBzdG9wcGVkIGNvbXBsZXRlbHkgd2l0aFxuICoge0BsaW5rIExvY2FsQXVkaW9UcmFjayNzdG9wfS5cbiAqIEBleHRlbmRzIEF1ZGlvVHJhY2tcbiAqIEBwcm9wZXJ0eSB7VHJhY2suSUR9IGlkIC0gVGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9J3MgSURcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTdG9wcGVkIC0gV2hldGhlciBvciBub3QgdGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IGlzXG4gKiAgIHN0b3BwZWRcbiAqIEBlbWl0cyBMb2NhbEF1ZGlvVHJhY2sjZGlzYWJsZWRcbiAqIEBlbWl0cyBMb2NhbEF1ZGlvVHJhY2sjZW5hYmxlZFxuICogQGVtaXRzIExvY2FsQXVkaW9UcmFjayNzdGFydGVkXG4gKiBAZW1pdHMgTG9jYWxBdWRpb1RyYWNrI3N0b3BwZWRcbiAqL1xudmFyIExvY2FsQXVkaW9UcmFjayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9jYWxBdWRpb1RyYWNrLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IGZyb20gYSBNZWRpYVN0cmVhbVRyYWNrLlxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gbWVkaWFTdHJlYW1UcmFjayAtIEFuIGF1ZGlvIE1lZGlhU3RyZWFtVHJhY2tcbiAgICAgKiBAcGFyYW0ge0xvY2FsVHJhY2tPcHRpb25zfSBbb3B0aW9uc10gLSB7QGxpbmsgTG9jYWxUcmFja30gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvY2FsQXVkaW9UcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBtZWRpYVN0cmVhbVRyYWNrLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIH1cbiAgICBMb2NhbEF1ZGlvVHJhY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbTG9jYWxBdWRpb1RyYWNrICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyBcIjogXCIgKyB0aGlzLmlkICsgXCJdXCI7XG4gICAgfTtcbiAgICBMb2NhbEF1ZGlvVHJhY2sucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbCA9IF9zdXBlci5wcm90b3R5cGUuYXR0YWNoLmNhbGwodGhpcywgZWwpO1xuICAgICAgICBlbC5tdXRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTG9jYWxBdWRpb1RyYWNrLnByb3RvdHlwZS5fZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5fZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIHRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfS4gVGhpcyBpcyBlZmZlY3RpdmVseSBcIm11dGVcIi5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAZmlyZXMgTG9jYWxBdWRpb1RyYWNrI2Rpc2FibGVkXG4gICAgICovXG4gICAgTG9jYWxBdWRpb1RyYWNrLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5kaXNhYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbmFibGUgdGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9LiBUaGlzIGlzIGVmZmVjdGl2ZWx5IFwidW5tdXRlXCIuXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGZpcmVzIExvY2FsQXVkaW9UcmFjayNlbmFibGVkXG4gICAgKi8gLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9LiBUaGlzIGlzIGVmZmVjdGl2ZWx5IFwidW5tdXRlXCJcbiAgICAgKiBvciBcIm11dGVcIi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmFibGVkXSAtIFNwZWNpZnkgZmFsc2UgdG8gbXV0ZSB0aGVcbiAgICAgKiAgIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9XG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGZpcmVzIExvY2FsQXVkaW9UcmFjayNkaXNhYmxlZFxuICAgICAqIEBmaXJlcyBMb2NhbEF1ZGlvVHJhY2sjZW5hYmxlZFxuICAgICAqL1xuICAgIExvY2FsQXVkaW9UcmFjay5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5lbmFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc3RhcnQgdGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9LiBUaGlzIHN0b3BzIHRoZSBleGlzdGluZyBNZWRpYVN0cmVhbVRyYWNrXG4gICAgICogYW5kIGNyZWF0ZXMgYSBuZXcgTWVkaWFTdHJlYW1UcmFjay4gSWYgdGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IGlzIGJlaW5nIHB1Ymxpc2hlZFxuICAgICAqIHRvIGEge0BsaW5rIFJvb219LCB0aGVuIGFsbCB0aGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fXMgd2lsbCBzdGFydCByZWNlaXZpbmcgbWVkaWFcbiAgICAgKiBmcm9tIHRoZSBuZXdseSBjcmVhdGVkIE1lZGlhU3RyZWFtVHJhY2suIFlvdSBjYW4gYWNjZXNzIHRoZSBuZXcgTWVkaWFTdHJlYW1UcmFjayB2aWFcbiAgICAgKiB0aGUgPGNvZGU+bWVkaWFTdHJlYW1UcmFjazwvY29kZT4gcHJvcGVydHkuIElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBldmVudHMgb25cbiAgICAgKiB0aGUgTWVkaWFTdHJlYW1UcmFjayBkaXJlY3RseSwgcGxlYXNlIGRvIHNvIGluIHRoZSBcInN0YXJ0ZWRcIiBldmVudCBoYW5kbGVyLiBBbHNvLFxuICAgICAqIHRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSdzIElEIGlzIG5vIGxvbmdlciBndWFyYW50ZWVkIHRvIGJlIHRoZSBzYW1lIGFzIHRoZVxuICAgICAqIHVuZGVybHlpbmcgTWVkaWFTdHJlYW1UcmFjaydzIElELlxuICAgICAqIEBwYXJhbSB7TWVkaWFUcmFja0NvbnN0cmFpbnRzfSBbY29uc3RyYWludHNdIC0gVGhlIG9wdGlvbmFsIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja0NvbnN0cmFpbnRzXCIgdGFyZ2V0PVwiX2JsYW5rXCI+TWVkaWFUcmFja0NvbnN0cmFpbnRzPC9hPlxuICAgICAqICAgZm9yIHJlc3RhcnRpbmcgdGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9OyBJZiBub3Qgc3BlY2lmaWVkLCB0aGVuIHRoZSBjdXJyZW50IE1lZGlhVHJhY2tDb25zdHJhaW50c1xuICAgICAqICAgd2lsbCBiZSB1c2VkOyBJZiA8Y29kZT57fTwvY29kZT4gKGVtcHR5IG9iamVjdCkgaXMgc3BlY2lmaWVkLCB0aGVuIHRoZSBkZWZhdWx0IE1lZGlhVHJhY2tDb25zdHJhaW50c1xuICAgICAqICAgd2lsbCBiZSB1c2VkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlamVjdHMgd2l0aCBhIFR5cGVFcnJvciBpZiB0aGUge0BsaW5rIExvY2FsQXVkaW9UcmFja30gd2FzIG5vdCBjcmVhdGVkXG4gICAgICogICB1c2luZyBhbiBvbmUgb2YgPGNvZGU+Y3JlYXRlTG9jYWxBdWRpb1RyYWNrPC9jb2RlPiwgPGNvZGU+Y3JlYXRlTG9jYWxUcmFja3M8L2NvZGU+IG9yIDxjb2RlPmNvbm5lY3Q8L2NvZGU+O1xuICAgICAqICAgQWxzbyByZWplY3RzIHdpdGggdGhlIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFEZXZpY2VzL2dldFVzZXJNZWRpYSNFeGNlcHRpb25zXCIgdGFyZ2V0PVwiX2JsYW5rXCI+RE9NRXhjZXB0aW9uPC9hPlxuICAgICAqICAgcmFpc2VkIGJ5IDxjb2RlPmdldFVzZXJNZWRpYTwvY29kZT4gd2hlbiBpdCBmYWlsc1xuICAgICAqIEBmaXJlcyBMb2NhbEF1ZGlvVHJhY2sjc3RvcHBlZFxuICAgICAqIEBmaXJlcyBMb2NhbEF1ZGlvVHJhY2sjc3RhcnRlZFxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgeyBjb25uZWN0LCBjcmVhdGVMb2NhbEF1ZGlvVHJhY2sgfSA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIGEgTG9jYWxBdWRpb1RyYWNrIHRoYXQgY2FwdHVyZXMgYXVkaW8gZnJvbSBhIFVTQiBtaWNyb3Bob25lLlxuICAgICAqIGNyZWF0ZUxvY2FsQXVkaW9UcmFjayh7IGRldmljZUlkOiAndXNiLW1pYy1pZCcgfSkudGhlbihmdW5jdGlvbihsb2NhbEF1ZGlvVHJhY2spIHtcbiAgICAgKiAgIHJldHVybiBjb25uZWN0KCd0b2tlbicsIHtcbiAgICAgKiAgICAgbmFtZTogJ215LWNvb2wtcm9vbScsXG4gICAgICogICAgIHRyYWNrczogW2xvY2FsQXVkaW9UcmFja11cbiAgICAgKiAgIH0pO1xuICAgICAqIH0pLnRoZW4oZnVuY3Rpb24ocm9vbSkge1xuICAgICAqICAgLy8gUmVzdGFydCB0aGUgTG9jYWxBdWRpb1RyYWNrIHRvIGNhcHR1cmUgYXVkaW8gZnJvbSB0aGUgZGVmYXVsdCBtaWNyb3Bob25lLlxuICAgICAqICAgY29uc3QgbG9jYWxBdWRpb1RyYWNrID0gQXJyYXkuZnJvbShyb29tLmxvY2FsUGFydGljaXBhbnQuYXVkaW9UcmFja3MudmFsdWVzKCkpWzBdLnRyYWNrO1xuICAgICAqICAgcmV0dXJuIGxvY2FsQXVkaW9UcmFjay5yZXN0YXJ0KHsgZGV2aWNlSWQ6ICdkZWZhdWx0LW1pYy1pZCcgfSk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgTG9jYWxBdWRpb1RyYWNrLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZXN0YXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxscyBzdG9wIG9uIHRoZSB1bmRlcmx5aW5nIE1lZGlhU3RyZWFtVHJhY2suIElmIHlvdSBjaG9vc2UgdG8gc3RvcCBhXG4gICAgICoge0BsaW5rIExvY2FsQXVkaW9UcmFja30sIHlvdSBzaG91bGQgdW5wdWJsaXNoIGl0IGFmdGVyIHN0b3BwaW5nLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBmaXJlcyBMb2NhbEF1ZGlvVHJhY2sjc3RvcHBlZFxuICAgICAqL1xuICAgIExvY2FsQXVkaW9UcmFjay5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc3RvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2FsQXVkaW9UcmFjaztcbn0oTG9jYWxNZWRpYUF1ZGlvVHJhY2spKTtcbi8qKlxuICogVGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IHdhcyBkaXNhYmxlZCwgaS5lLiBcIm11dGVkXCIuXG4gKiBAcGFyYW0ge0xvY2FsQXVkaW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIExvY2FsQXVkaW9UcmFja30gdGhhdCB3YXNcbiAqICAgZGlzYWJsZWRcbiAqIEBldmVudCBMb2NhbEF1ZGlvVHJhY2sjZGlzYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIExvY2FsQXVkaW9UcmFja30gd2FzIGVuYWJsZWQsIGkuZS4gXCJ1bm11dGVkXCIuXG4gKiBAcGFyYW0ge0xvY2FsQXVkaW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIExvY2FsQXVkaW9UcmFja30gdGhhdCB3YXMgZW5hYmxlZFxuICogQGV2ZW50IExvY2FsQXVkaW9UcmFjayNlbmFibGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IHN0YXJ0ZWQuIFRoaXMgbWVhbnMgdGhlcmUgaXMgZW5vdWdoIGF1ZGlvIGRhdGEgdG9cbiAqIGJlZ2luIHBsYXliYWNrLlxuICogQHBhcmFtIHtMb2NhbEF1ZGlvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IHRoYXQgc3RhcnRlZFxuICogQGV2ZW50IExvY2FsQXVkaW9UcmFjayNzdGFydGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IHN0b3BwZWQsIGVpdGhlciBiZWNhdXNlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2sjc3RvcH1cbiAqIG9yIHtAbGluayBMb2NhbEF1ZGlvVHJhY2sjcmVzdGFydH0gd2FzIGNhbGxlZCBvciBiZWNhdXNlIHRoZSB1bmRlcmx5aW5nXG4gKiBNZWRpYVN0cmVhbVRyYWNrIGVuZGVkLlxuICogQHBhcmFtIHtMb2NhbEF1ZGlvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IHRoYXQgc3RvcHBlZFxuICogQGV2ZW50IExvY2FsQXVkaW9UcmFjayNzdG9wcGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxBdWRpb1RyYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxhdWRpb3RyYWNrLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTG9jYWxUcmFja1B1YmxpY2F0aW9uID0gcmVxdWlyZSgnLi9sb2NhbHRyYWNrcHVibGljYXRpb24nKTtcbi8qKlxuICogQSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb259IGlzIGEge0BsaW5rIExvY2FsQXVkaW9UcmFja30gdGhhdCBoYXNcbiAqIGJlZW4gcHVibGlzaGVkIHRvIGEge0BsaW5rIFJvb219LlxuICogQGV4dGVuZHMgTG9jYWxUcmFja1B1YmxpY2F0aW9uXG4gKiBAcHJvcGVydHkge1RyYWNrLktpbmR9IGtpbmQgLSBcImF1ZGlvXCJcbiAqIEBwcm9wZXJ0eSB7TG9jYWxBdWRpb1RyYWNrfSB0cmFjayAtIHRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfVxuICovXG52YXIgTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9uLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBMb2NhbEF1ZGlvVHJhY2tQdWJsaWNhdGlvbn0uXG4gICAgICogQHBhcmFtIHtMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9IHNpZ25hbGluZyAtIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogICB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfVxuICAgICAqIEBwYXJhbSB7TG9jYWxBdWRpb1RyYWNrfSB0cmFjayAtIHRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oTG9jYWxUcmFja1B1YmxpY2F0aW9uKTogdm9pZH0gdW5wdWJsaXNoIC0gVGhlIGNhbGxiYWNrXG4gICAgICogICAgdGhhdCB1bnB1Ymxpc2hlcyB0aGUge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn1cbiAgICAgKiBAcGFyYW0ge1RyYWNrUHVibGljYXRpb25PcHRpb25zfSBvcHRpb25zIC0ge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9uKHNpZ25hbGluZywgdHJhY2ssIHVucHVibGlzaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc2lnbmFsaW5nLCB0cmFjaywgdW5wdWJsaXNoLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIH1cbiAgICBMb2NhbEF1ZGlvVHJhY2tQdWJsaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltMb2NhbEF1ZGlvVHJhY2tQdWJsaWNhdGlvbiAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgdGhpcy50cmFja1NpZCArIFwiXVwiO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9uO1xufShMb2NhbFRyYWNrUHVibGljYXRpb24pKTtcbm1vZHVsZS5leHBvcnRzID0gTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbGF1ZGlvdHJhY2twdWJsaWNhdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFRyYWNrID0gcmVxdWlyZSgnLi8nKTtcbnZhciBEZWZhdWx0RGF0YVRyYWNrU2VuZGVyID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9zZW5kZXInKTtcbi8qKlxuICogQSB7QGxpbmsgTG9jYWxEYXRhVHJhY2t9IGlzIGEge0BsaW5rIFRyYWNrfSByZXByZXNlbnRpbmcgZGF0YSB0aGF0IHlvdXJcbiAqIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBjYW4gcHVibGlzaCB0byBhIHtAbGluayBSb29tfS5cbiAqIEBleHRlbmRzIFRyYWNrXG4gKiBAcHJvcGVydHkge1RyYWNrLklEfSBpZCAtIFRoZSB7QGxpbmsgTG9jYWxEYXRhVHJhY2t9J3MgSURcbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZCAtIFwiZGF0YVwiXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IG1heFBhY2tldExpZmVUaW1lIC0gSWYgbm9uLW51bGwsIHRoaXMgcmVwcmVzZW50cyBhIHRpbWVcbiAqICAgbGltaXQgKGluIG1pbGxpc2Vjb25kcykgZHVyaW5nIHdoaWNoIHRoZSB7QGxpbmsgTG9jYWxEYXRhVHJhY2t9IHdpbGwgc2VuZFxuICogICBvciByZS1zZW5kIGRhdGEgaWYgbm90IGFja25vd2xlZGdlZCBvbiB0aGUgdW5kZXJseWluZyBSVENEYXRhQ2hhbm5lbChzKS5cbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gbWF4UmV0cmFuc21pdHMgLSBJZiBub24tbnVsbCwgdGhpcyByZXByZXNlbnRzIHRoZSBudW1iZXJcbiAqICAgb2YgdGltZXMgdGhlIHtAbGluayBMb2NhbERhdGFUcmFja30gd2lsbCByZXNlbmQgZGF0YSBpZiBub3Qgc3VjY2Vzc2Z1bGx5XG4gKiAgIGRlbGl2ZXJlZCBvbiB0aGUgdW5kZXJseWluZyBSVENEYXRhQ2hhbm5lbChzKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3JkZXJlZCAtIHRydWUgaWYgZGF0YSBvbiB0aGUge0BsaW5rIExvY2FsRGF0YVRyYWNrfSBpc1xuICogICBndWFyYW50ZWVkIHRvIGJlIHNlbnQgaW4gb3JkZXIuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJlbGlhYmxlIC0gVGhpcyBpcyB0cnVlIGlmIGJvdGhcbiAqICAgPGNvZGU+bWF4UGFja2V0TGlmZVRpbWU8L2NvZGU+IGFuZCA8Y29kZT5tYXhSZXRyYW5zbWl0czwvY29kZT4gYXJlIHNldCB0b1xuICogICBudWxsLiBJbiBvdGhlciB3b3JkcywgaWYgdGhpcyBpcyB0cnVlLCB0aGVyZSBpcyBubyBib3VuZCBvbiBwYWNrZXQgbGlmZXRpbWVcbiAqICAgb3IgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUge0BsaW5rIExvY2FsRGF0YVRyYWNrfSB3aWxsIGF0dGVtcHQgdG8gc2VuZFxuICogICBkYXRhLCBlbnN1cmluZyBcInJlbGlhYmxlXCIgdHJhbnNtaXNzaW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICpcbiAqIHZhciBsb2NhbERhdGFUcmFjayA9IG5ldyBWaWRlby5Mb2NhbERhdGFUcmFjaygpO1xuICogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgIGxvY2FsRGF0YVRyYWNrLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICogICAgIHg6IGUuY2xpZW50WCxcbiAqICAgICB5OiBlLmNsaWVudFlcbiAqICAgfSkpO1xuICogfSk7XG4gKlxuICogdmFyIHRva2VuMSA9IGdldEFjY2Vzc1Rva2VuKCk7XG4gKiBWaWRlby5jb25uZWN0KHRva2VuMSwge1xuICogICBuYW1lOiAnbXktY29vbC1yb29tJyxcbiAqICAgdHJhY2tzOiBbbG9jYWxEYXRhVHJhY2tdXG4gKiB9KTtcbiAqXG4gKiB2YXIgdG9rZW4yID0gZ2V0QWNjZXNzVG9rZW4oKTtcbiAqIFZpZGVvLmNvbm5lY3QodG9rZW4yLCB7XG4gKiAgIG5hbWU6ICdteS1jb29sLXJvb20nLFxuICogICB0cmFja3M6IFtdXG4gKiB9KS50aGVuKGZ1bmN0aW9uKHJvb20pIHtcbiAqICAgcm9vbS5vbigndHJhY2tTdWJzY3JpYmVkJywgZnVuY3Rpb24odHJhY2spIHtcbiAqICAgICB0cmFjay5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKEpTT04ucGFyc2UobWVzc2FnZSkpOyAvLyB7IHg6IDxudW1iZXI+LCB5OiA8bnVtYmVyPiB9XG4gKiAgICAgfSk7XG4gKiAgIH0pO1xuICogfSk7XG4gKi9cbnZhciBMb2NhbERhdGFUcmFjayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9jYWxEYXRhVHJhY2ssIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIExvY2FsRGF0YVRyYWNrfS5cbiAgICAgKiBAcGFyYW0ge0xvY2FsRGF0YVRyYWNrT3B0aW9uc30gW29wdGlvbnNdIC0ge0BsaW5rIExvY2FsRGF0YVRyYWNrfSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9jYWxEYXRhVHJhY2sob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBEYXRhVHJhY2tTZW5kZXI6IERlZmF1bHREYXRhVHJhY2tTZW5kZXIsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZTogbnVsbCxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiBudWxsLFxuICAgICAgICAgICAgb3JkZXJlZDogdHJ1ZVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIERhdGFUcmFja1NlbmRlciA9IG9wdGlvbnMuRGF0YVRyYWNrU2VuZGVyO1xuICAgICAgICB2YXIgZGF0YVRyYWNrU2VuZGVyID0gbmV3IERhdGFUcmFja1NlbmRlcihvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLCBvcHRpb25zLm1heFJldHJhbnNtaXRzLCBvcHRpb25zLm9yZGVyZWQpO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBuYW1lOiBkYXRhVHJhY2tTZW5kZXIuaWRcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ2RhdGEnLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX3RyYWNrU2VuZGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFUcmFja1NlbmRlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YVRyYWNrU2VuZGVyLmlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLm1heFJldHJhbnNtaXRzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3JkZXJlZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMub3JkZXJlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbGlhYmxlOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSA9PT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAmJiBvcHRpb25zLm1heFJldHJhbnNtaXRzID09PSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlIG92ZXIgdGhlIHtAbGluayBMb2NhbERhdGFUcmFja30uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QmxvYnxBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBMb2NhbERhdGFUcmFjay5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrU2VuZGVyLnNlbmQoZGF0YSk7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxEYXRhVHJhY2s7XG59KFRyYWNrKSk7XG4vKipcbiAqIHtAbGluayBMb2NhbERhdGFUcmFja30gb3B0aW9uc1xuICogQHR5cGVkZWYge0xvY2FsVHJhY2tPcHRpb25zfSBMb2NhbERhdGFUcmFja09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gW21heFBhY2tldExpZmVUaW1lPW51bGxdIC0gU2V0IHRoaXMgdG8gbGltaXQgdGhlIHRpbWVcbiAqICAgKGluIG1pbGxpc2Vjb25kcykgZHVyaW5nIHdoaWNoIHRoZSBMb2NhbERhdGFUcmFjayB3aWxsIHNlbmQgb3IgcmUtc2VuZCBkYXRhXG4gKiAgIGlmIG5vdCBzdWNjZXNzZnVsbHkgZGVsaXZlcmVkIG9uIHRoZSB1bmRlcmx5aW5nIFJUQ0RhdGFDaGFubmVsKHMpLiBJdCBpcyBhblxuICogICBlcnJvciB0byBzcGVjaWZ5IGJvdGggdGhpcyBhbmQgPGNvZGU+bWF4UmV0cmFuc21pdHM8L2NvZGU+LlxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBbbWF4UmV0cmFuc21pdHM9bnVsbF0gLSBTZXQgdGhpcyB0byBsaW1pdCB0aGUgbnVtYmVyIG9mXG4gKiAgIHRpbWVzIHRoZSB7QGxpbmsgTG9jYWxEYXRhVHJhY2t9IHdpbGwgc2VuZCBvciByZS1zZW5kIGRhdGEgaWYgbm90XG4gKiAgIGFja25vd2xlZGdlZCBvbiB0aGUgdW5kZXJseWluZyBSVENEYXRhQ2hhbm5lbChzKS4gSXQgaXMgYW4gZXJyb3IgdG8gc3BlY2lmeVxuICogICBib3RoIHRoaXMgYW5kIDxjb2RlPm1heFBhY2tldExpZmVUaW1lPC9jb2RlPi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29yZGVyZWQ9dHJ1ZV0gLSBTZXQgdGhpcyB0byBmYWxzZSB0byBhbGxvdyBkYXRhIG9uIHRoZVxuICogICBMb2NhbERhdGFUcmFjayB0byBiZSBzZW50IG91dC1vZi1vcmRlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBMb2NhbERhdGFUcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsZGF0YXRyYWNrLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTG9jYWxUcmFja1B1YmxpY2F0aW9uID0gcmVxdWlyZSgnLi9sb2NhbHRyYWNrcHVibGljYXRpb24nKTtcbi8qKlxuICogQSB7QGxpbmsgTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvbn0gaXMgYSB7QGxpbmsgTG9jYWxEYXRhVHJhY2t9IHRoYXQgaGFzIGJlZW5cbiAqIHB1Ymxpc2hlZCB0byBhIHtAbGluayBSb29tfS5cbiAqIEBleHRlbmRzIExvY2FsVHJhY2tQdWJsaWNhdGlvblxuICogQHByb3BlcnR5IHtUcmFjay5LaW5kfSBraW5kIC0gXCJkYXRhXCJcbiAqIEBwcm9wZXJ0eSB7TG9jYWxEYXRhVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBMb2NhbERhdGFUcmFja31cbiAqL1xudmFyIExvY2FsRGF0YVRyYWNrUHVibGljYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvY2FsRGF0YVRyYWNrUHVibGljYXRpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIExvY2FsRGF0YVRyYWNrUHVibGljYXRpb259LlxuICAgICAqIEBwYXJhbSB7TG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfSBzaWduYWxpbmcgLSBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqICAge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ31cbiAgICAgKiBAcGFyYW0ge0xvY2FsRGF0YVRyYWNrfSB0cmFjayAtIHRoZSB7QGxpbmsgTG9jYWxEYXRhVHJhY2t9XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihMb2NhbFRyYWNrUHVibGljYXRpb24pOiB2b2lkfSB1bnB1Ymxpc2ggLSBUaGUgY2FsbGJhY2tcbiAgICAgKiAgICB0aGF0IHVucHVibGlzaGVzIHRoZSB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9ufVxuICAgICAqIEBwYXJhbSB7VHJhY2tQdWJsaWNhdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9ufSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvbihzaWduYWxpbmcsIHRyYWNrLCB1bnB1Ymxpc2gsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNpZ25hbGluZywgdHJhY2ssIHVucHVibGlzaCwgb3B0aW9ucykgfHwgdGhpcztcbiAgICB9XG4gICAgTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltMb2NhbERhdGFUcmFja1B1YmxpY2F0aW9uICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyBcIjogXCIgKyB0aGlzLnRyYWNrU2lkICsgXCJdXCI7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvbjtcbn0oTG9jYWxUcmFja1B1YmxpY2F0aW9uKSk7XG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsRGF0YVRyYWNrUHVibGljYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbGRhdGF0cmFja3B1YmxpY2F0aW9uLmpzLm1hcCIsIi8qIGVzbGludCBuZXctY2FwOjAgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgZ2V0VXNlck1lZGlhID0gcmVxdWlyZSgnLi4vLi4vd2VicnRjJykuZ2V0VXNlck1lZGlhO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vLi4vd2VicnRjL3V0aWwnKSwgZ3Vlc3NCcm93c2VyID0gX2EuZ3Vlc3NCcm93c2VyLCBpc0lPU0Nocm9tZSA9IF9hLmlzSU9TQ2hyb21lO1xudmFyIF9iID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLCBjYXBpdGFsaXplID0gX2IuY2FwaXRhbGl6ZSwgZGVmZXIgPSBfYi5kZWZlciwgaXNVc2VyTWVkaWFUcmFjayA9IF9iLmlzVXNlck1lZGlhVHJhY2ssIHdhaXRGb3JTb21ldGltZSA9IF9iLndhaXRGb3JTb21ldGltZSwgd2FpdEZvckV2ZW50ID0gX2Iud2FpdEZvckV2ZW50O1xudmFyIElMTEVHQUxfSU5WT0tFID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25zdGFudHMnKS50eXBlRXJyb3JzLklMTEVHQUxfSU5WT0tFO1xudmFyIGRldGVjdFNpbGVudEF1ZGlvID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kZXRlY3RzaWxlbnRhdWRpbycpO1xudmFyIGRldGVjdFNpbGVudFZpZGVvID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kZXRlY3RzaWxlbnR2aWRlbycpO1xudmFyIGRvY3VtZW50VmlzaWJpbGl0eU1vbml0b3IgPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvY3VtZW50dmlzaWJpbGl0eW1vbml0b3IuanMnKTtcbnZhciBsb2NhbE1lZGlhUmVzdGFydERlZmVycmVkcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbG9jYWxtZWRpYXJlc3RhcnRkZWZlcnJlZHMnKTtcbnZhciBnVU1TaWxlbnRUcmFja1dvcmthcm91bmQgPSByZXF1aXJlKCcuLi8uLi93ZWJhdWRpby93b3JrYXJvdW5kMTgwNzQ4Jyk7XG52YXIgTWVkaWFUcmFja1NlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyJyk7XG5mdW5jdGlvbiBtaXhpbkxvY2FsTWVkaWFUcmFjayhBdWRpb09yVmlkZW9UcmFjaykge1xuICAgIC8qKlxuICAgICAqIEEge0BsaW5rIExvY2FsTWVkaWFUcmFja30gcmVwcmVzZW50cyBhdWRpbyBvciB2aWRlbyB0aGF0IHlvdXJcbiAgICAgKiB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gaXMgc2VuZGluZyB0byBhIHtAbGluayBSb29tfS4gQXMgc3VjaCwgaXQgY2FuIGJlXG4gICAgICogZW5hYmxlZCBhbmQgZGlzYWJsZWQgd2l0aCB7QGxpbmsgTG9jYWxNZWRpYVRyYWNrI2VuYWJsZX0gYW5kXG4gICAgICoge0BsaW5rIExvY2FsTWVkaWFUcmFjayNkaXNhYmxlfSBvciBzdG9wcGVkIGNvbXBsZXRlbHkgd2l0aFxuICAgICAqIHtAbGluayBMb2NhbE1lZGlhVHJhY2sjc3RvcH0uXG4gICAgICogQGVtaXRzIExvY2FsTWVkaWFUcmFjayNzdG9wcGVkXG4gICAgICovXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKExvY2FsTWVkaWFUcmFjaywgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBMb2NhbE1lZGlhVHJhY2t9IGZyb20gYSBNZWRpYVN0cmVhbVRyYWNrLlxuICAgICAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IG1lZGlhU3RyZWFtVHJhY2sgLSBUaGUgdW5kZXJseWluZyBNZWRpYVN0cmVhbVRyYWNrXG4gICAgICAgICAqIEBwYXJhbSB7TG9jYWxUcmFja09wdGlvbnN9IFtvcHRpb25zXSAtIHtAbGluayBMb2NhbFRyYWNrfSBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBMb2NhbE1lZGlhVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBieSBkZWZhdWx0IHdvcmthcm91bmQgZm9yIFdlYktpdEJ1ZzEyMDg1MTYgd2lsbCBiZSBlbmFibGVkIG9uIFNhZmFyaSBicm93c2Vyc1xuICAgICAgICAgICAgLy8gYWx0aG91Z2ggdGhlIGJ1ZyBpcyBzZWVuICBtYWlubHkgb24gaU9TIGRldmljZXMsIHdlIGRvIG5vdCBoYXZlIGEgcmVsaWFibGUgd2F5IHRvIHRlbGwgaU9TIGZyb20gTWFjT3NcbiAgICAgICAgICAgIC8vIHVzZXJBZ2VudCBvbiBpT1MgcHJldGVuZHMgaXRzIG1hY09zIGlmIFNhZmFyaSBpcyBzZXQgdG8gcmVxdWVzdCBkZXNrdG9wIHBhZ2VzLlxuICAgICAgICAgICAgdmFyIHdvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2ID0gKGd1ZXNzQnJvd3NlcigpID09PSAnc2FmYXJpJyB8fCBpc0lPU0Nocm9tZSgpKVxuICAgICAgICAgICAgICAgICYmIGlzVXNlck1lZGlhVHJhY2sobWVkaWFTdHJlYW1UcmFjaylcbiAgICAgICAgICAgICAgICAmJiB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgJiYgdHlwZW9mIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAmJiB0eXBlb2YgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnc3RyaW5nJztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBnZXRVc2VyTWVkaWE6IGdldFVzZXJNZWRpYSxcbiAgICAgICAgICAgICAgICBpc0NyZWF0ZWRCeUNyZWF0ZUxvY2FsVHJhY2tzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBtZWRpYVN0cmVhbVRyYWNrLmlkLFxuICAgICAgICAgICAgICAgIHdvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2OiB3b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNixcbiAgICAgICAgICAgICAgICBnVU1TaWxlbnRUcmFja1dvcmthcm91bmQ6IGdVTVNpbGVudFRyYWNrV29ya2Fyb3VuZFxuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgbWVkaWFUcmFja1NlbmRlciA9IG5ldyBNZWRpYVRyYWNrU2VuZGVyKG1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICAgICAgdmFyIGtpbmQgPSBtZWRpYVRyYWNrU2VuZGVyLmtpbmQ7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lZGlhVHJhY2tTZW5kZXIsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgICAgIF9jb25zdHJhaW50czoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW9mIG9wdGlvbnNba2luZF0gPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnNba2luZF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZ2V0VXNlck1lZGlhOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmdldFVzZXJNZWRpYVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2dVTVNpbGVudFRyYWNrV29ya2Fyb3VuZDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5nVU1TaWxlbnRUcmFja1dvcmthcm91bmRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF93b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNjoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy53b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX3dvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2Q2xlYW51cDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9kaWRDYWxsRW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9pc0NyZWF0ZWRCeUNyZWF0ZUxvY2FsVHJhY2tzOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmlzQ3JlYXRlZEJ5Q3JlYXRlTG9jYWxUcmFja3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF90cmFja1NlbmRlcjoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWVkaWFUcmFja1NlbmRlclxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1lZGlhVHJhY2tTZW5kZXIuaWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzRW5hYmxlZDoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYVRyYWNrU2VuZGVyLmVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzU3RvcHBlZDoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYVRyYWNrU2VuZGVyLnJlYWR5U3RhdGUgPT09ICdlbmRlZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBBcyBhIHdvcmthcm91bmQgZm9yIFdlYktpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg1MTYsXG4gICAgICAgICAgICAvLyB1cG9uIGZvcmVncm91bmRpbmcsIHJlLWFjcXVpcmUgbmV3IE1lZGlhU3RyZWFtVHJhY2sgaWYgdGhlIGV4aXN0aW5nIG9uZSBpcyBlbmRlZCBvciBtdXRlZC5cbiAgICAgICAgICAgIGlmIChfdGhpcy5fd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTZDbGVhbnVwID0gcmVzdGFydFdoZW5JbmFkdmVydGVudGx5U3RvcHBlZChfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhbE1lZGlhVHJhY2sucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlkQ2FsbEVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2VuZC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fZGlkQ2FsbEVuZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3BwZWQnLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhbE1lZGlhVHJhY2sucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RpZENhbGxFbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWRDYWxsRW5kID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9pbml0aWFsaXplLmNhbGwodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYWxNZWRpYVRyYWNrLnByb3RvdHlwZS5fcmVhY3F1aXJlVHJhY2sgPSBmdW5jdGlvbiAoY29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfYiA9IHRoaXMsIGdldFVzZXJNZWRpYSA9IF9iLl9nZXRVc2VyTWVkaWEsIGdVTVNpbGVudFRyYWNrV29ya2Fyb3VuZCA9IF9iLl9nVU1TaWxlbnRUcmFja1dvcmthcm91bmQsIGxvZyA9IF9iLl9sb2csIGtpbmQgPSBfYi5tZWRpYVN0cmVhbVRyYWNrLmtpbmQ7XG4gICAgICAgICAgICBsb2cuaW5mbygnUmUtYWNxdWlyaW5nIHRoZSBNZWRpYVN0cmVhbVRyYWNrJyk7XG4gICAgICAgICAgICBsb2cuZGVidWcoJ0NvbnN0cmFpbnRzOicsIGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIHZhciBnVU1Db25zdHJhaW50cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2aWRlbzogZmFsc2VcbiAgICAgICAgICAgIH0sIChfYSA9IHt9LCBfYVtraW5kXSA9IGNvbnN0cmFpbnRzLCBfYSkpO1xuICAgICAgICAgICAgdmFyIGdVTVByb21pc2UgPSB0aGlzLl93b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNkNsZWFudXBcbiAgICAgICAgICAgICAgICA/IGdVTVNpbGVudFRyYWNrV29ya2Fyb3VuZChsb2csIGdldFVzZXJNZWRpYSwgZ1VNQ29uc3RyYWludHMpXG4gICAgICAgICAgICAgICAgOiBnZXRVc2VyTWVkaWEoZ1VNQ29uc3RyYWludHMpO1xuICAgICAgICAgICAgcmV0dXJuIGdVTVByb21pc2UudGhlbihmdW5jdGlvbiAobWVkaWFTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKClbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhbE1lZGlhVHJhY2sucHJvdG90eXBlLl9yZXN0YXJ0ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGxvZyA9IHRoaXMuX2xvZztcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMgfHwgdGhpcy5fY29uc3RyYWludHM7XG4gICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBJZiB3ZSB0cnkgYW5kIHJlc3RhcnQgYSBzaWxlbnQgTWVkaWFTdHJlYW1UcmFja1xuICAgICAgICAgICAgLy8gd2l0aG91dCBzdG9wcGluZyBpdCBmaXJzdCwgdGhlbiBhIE5vdFJlYWRhYmxlRXJyb3IgaXMgcmFpc2VkIGluIGNhc2Ugb2ZcbiAgICAgICAgICAgIC8vIHZpZGVvLCBvciB0aGUgcmVzdGFydGVkIGF1ZGlvIHdpbGwgc3RpbGwgYmUgc2lsZW50LiBIZW5jZSwgd2Ugc3RvcCB0aGVcbiAgICAgICAgICAgIC8vIE1lZGlhU3RyZWFtVHJhY2sgaGVyZS5cbiAgICAgICAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFjcXVpcmVUcmFjayhjb25zdHJhaW50cykuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKCdGYWlsZWQgdG8gcmUtYWNxdWlyZSB0aGUgTWVkaWFTdHJlYW1UcmFjazonLCB7IGVycm9yOiBlcnJvciwgY29uc3RyYWludHM6IGNvbnN0cmFpbnRzIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAobmV3TWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKCdSZS1hY3F1aXJlZCB0aGUgTWVkaWFTdHJlYW1UcmFjaycpO1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZygnTWVkaWFTdHJlYW1UcmFjazonLCBuZXdNZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKHt9LCBjb25zdHJhaW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9zZXRNZWRpYVN0cmVhbVRyYWNrKG5ld01lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYWxNZWRpYVRyYWNrLnByb3RvdHlwZS5fc2V0TWVkaWFTdHJlYW1UcmFjayA9IGZ1bmN0aW9uIChtZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IFByZXNlcnZlIHRoZSB2YWx1ZSBvZiB0aGUgXCJlbmFibGVkXCIgZmxhZy5cbiAgICAgICAgICAgIG1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IHRoaXMubWVkaWFTdHJlYW1UcmFjay5lbmFibGVkO1xuICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogU3RvcCB0aGUgY3VycmVudCBNZWRpYVN0cmVhbVRyYWNrLiBJZiBub3QgYWxyZWFkeVxuICAgICAgICAgICAgLy8gc3RvcHBlZCwgdGhpcyBzaG91bGQgZmlyZSBhIFwic3RvcHBlZFwiIGV2ZW50LlxuICAgICAgICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgICAgICAgLy8gTk9URShjc2FudG9zKTogSWYgdGhlcmUncyBhbiB1bnByb2Nlc3NlZFRyYWNrLCB0aGlzIG1lYW5zIFJUQ1J0cFNlbmRlciBoYXNcbiAgICAgICAgICAgIC8vIHRoZSBwcm9jZXNzZWRUcmFjayBhbHJlYWR5IHNldCwgd2UgZG9uJ3Qgd2FudCB0byByZXBsYWNlIHRoYXQuXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX3VucHJvY2Vzc2VkVHJhY2sgPyBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdW5wcm9jZXNzZWRUcmFjayA9IG1lZGlhU3RyZWFtVHJhY2s7XG4gICAgICAgICAgICB9KSA6IHRoaXMuX3RyYWNrU2VuZGVyLnNldE1lZGlhU3RyZWFtVHJhY2sobWVkaWFTdHJlYW1UcmFjaykuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy53YXJuKCdzZXRNZWRpYVN0cmVhbVRyYWNrIGZhaWxlZDonLCB7IGVycm9yOiBlcnJvciwgbWVkaWFTdHJlYW1UcmFjazogbWVkaWFTdHJlYW1UcmFjayB9KTtcbiAgICAgICAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9nZXRBbGxBdHRhY2hlZEVsZW1lbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIF90aGlzLl9hdHRhY2goZWwpOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIExvY2FsTWVkaWFUcmFjay5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5fZW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgTG9jYWxNZWRpYVRyYWNrLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgZW5hYmxlZCA9IHR5cGVvZiBlbmFibGVkID09PSAnYm9vbGVhbicgPyBlbmFibGVkIDogdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlbmFibGVkICE9PSB0aGlzLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5pbmZvKChlbmFibGVkID8gJ0VuJyA6ICdEaXMnKSArIFwiYWJsaW5nXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZW5hYmxlZCA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCcsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIExvY2FsTWVkaWFUcmFjay5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuYWJsZShmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIExvY2FsTWVkaWFUcmFjay5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uIChjb25zdHJhaW50cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBraW5kID0gdGhpcy5raW5kO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0NyZWF0ZWRCeUNyZWF0ZUxvY2FsVHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KElMTEVHQUxfSU5WT0tFKCdyZXN0YXJ0JywgJ2NhbiBvbmx5IGJlIGNhbGxlZCBvbiBhJ1xuICAgICAgICAgICAgICAgICAgICArIChcIiBMb2NhbFwiICsgY2FwaXRhbGl6ZShraW5kKSArIFwiVHJhY2sgdGhhdCBpcyBjcmVhdGVkIHVzaW5nIGNyZWF0ZUxvY2FsVHJhY2tzXCIpXG4gICAgICAgICAgICAgICAgICAgICsgKFwiIG9yIGNyZWF0ZUxvY2FsXCIgKyBjYXBpdGFsaXplKGtpbmQpICsgXCJUcmFjay5cIikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl93b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNkNsZWFudXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNkNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNkNsZWFudXAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9yZXN0YXJ0KGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNikge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTZDbGVhbnVwID0gcmVzdGFydFdoZW5JbmFkdmVydGVudGx5U3RvcHBlZChfdGhpcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgTG9jYWxNZWRpYVRyYWNrLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmluZm8oJ1N0b3BwaW5nJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTZDbGVhbnVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTZDbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTZDbGVhbnVwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMb2NhbE1lZGlhVHJhY2s7XG4gICAgfShBdWRpb09yVmlkZW9UcmFjaykpO1xufVxuLyoqXG4gKiBSZXN0YXJ0IHRoZSBnaXZlbiB7QGxpbmsgTG9jYWxNZWRpYVRyYWNrfSBpZiBpdCBoYXMgYmVlbiBpbmFkdmVydGVudGx5IHN0b3BwZWQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtMb2NhbEF1ZGlvVHJhY2t8TG9jYWxWaWRlb1RyYWNrfSBsb2NhbE1lZGlhVHJhY2tcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gQ2xlYW4gdXAgbGlzdGVuZXJzIGF0dGFjaGVkIGJ5IHRoZSB3b3JrYXJvdW5kXG4gKi9cbmZ1bmN0aW9uIHJlc3RhcnRXaGVuSW5hZHZlcnRlbnRseVN0b3BwZWQobG9jYWxNZWRpYVRyYWNrKSB7XG4gICAgdmFyIGxvZyA9IGxvY2FsTWVkaWFUcmFjay5fbG9nLCBraW5kID0gbG9jYWxNZWRpYVRyYWNrLmtpbmQ7XG4gICAgdmFyIGRldGVjdFNpbGVuY2UgPSB7IGF1ZGlvOiBkZXRlY3RTaWxlbnRBdWRpbywgdmlkZW86IGRldGVjdFNpbGVudFZpZGVvIH1ba2luZF07XG4gICAgdmFyIGVsID0gbG9jYWxNZWRpYVRyYWNrLl9kdW1teUVsLCBtZWRpYVN0cmVhbVRyYWNrID0gbG9jYWxNZWRpYVRyYWNrLm1lZGlhU3RyZWFtVHJhY2s7XG4gICAgdmFyIHRyYWNrQ2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgZnVuY3Rpb24gY2hlY2tTaWxlbmNlKCkge1xuICAgICAgICAvLyBUaGUgZHVtbXkgZWxlbWVudCBpcyBwYXVzZWQsIHNvIHBsYXkgaXQgYW5kIHRoZW4gZGV0ZWN0IHNpbGVuY2UuXG4gICAgICAgIHJldHVybiBlbC5wbGF5KCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBkZXRlY3RTaWxlbmNlKGVsKTsgfSkudGhlbihmdW5jdGlvbiAoaXNTaWxlbnQpIHtcbiAgICAgICAgICAgIGlmIChpc1NpbGVudCkge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKCdTaWxlbmNlIGRldGVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbygnTm9uLXNpbGVuY2UgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NpbGVudDtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBsb2cud2FybignRmFpbGVkIHRvIGRldGVjdCBzaWxlbmNlOicsIGVycm9yKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBQYXVzZSB0aGUgZHVtbXkgZWxlbWVudCBhZ2Fpbi5cbiAgICAgICAgICAgIGVsLnBhdXNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRSZWFjcXVpcmVUcmFjaygpIHtcbiAgICAgICAgdmFyIF93b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNkNsZWFudXAgPSBsb2NhbE1lZGlhVHJhY2suX3dvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2Q2xlYW51cCwgaXNTdG9wcGVkID0gbG9jYWxNZWRpYVRyYWNrLmlzU3RvcHBlZCwgbXV0ZWQgPSBsb2NhbE1lZGlhVHJhY2subWVkaWFTdHJlYW1UcmFjay5tdXRlZDtcbiAgICAgICAgdmFyIGlzSW5hZHZlcnRlbnRseVN0b3BwZWQgPSBpc1N0b3BwZWQgJiYgISFfd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTZDbGVhbnVwO1xuICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBSZXN0YXJ0IHRoZSBMb2NhbE1lZGlhVHJhY2sgaWY6XG4gICAgICAgIC8vIDEuIFRoZSBhcHAgaXMgZm9yZWdyb3VuZGVkLCBhbmRcbiAgICAgICAgLy8gMi4gQSByZXN0YXJ0IGlzIG5vdCBhbHJlYWR5IGluIHByb2dyZXNzLCBhbmRcbiAgICAgICAgLy8gMy4gVGhlIExvY2FsTWVkaWFUcmFjayBpcyBlaXRoZXIgbXV0ZWQsIGluYWR2ZXJ0ZW50bHkgc3RvcHBlZCBvciBzaWxlbnRcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgJiYgIXRyYWNrQ2hhbmdlSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICYmIChtdXRlZCB8fCBpc0luYWR2ZXJ0ZW50bHlTdG9wcGVkIHx8IGNoZWNrU2lsZW5jZSgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1heWJlUmVzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICB3YWl0Rm9yRXZlbnQobWVkaWFTdHJlYW1UcmFjaywgJ3VubXV0ZScpLFxuICAgICAgICAgICAgd2FpdEZvclNvbWV0aW1lKDUwKVxuICAgICAgICBdKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNob3VsZFJlYWNxdWlyZVRyYWNrKCk7IH0pLnRoZW4oZnVuY3Rpb24gKHNob3VsZFJlYWNxdWlyZSkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFJlYWNxdWlyZSAmJiAhdHJhY2tDaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tDaGFuZ2VJblByb2dyZXNzID0gZGVmZXIoKTtcbiAgICAgICAgICAgICAgICBsb2NhbE1lZGlhVHJhY2suX3Jlc3RhcnQoKS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBsb2NhbE1lZGlhVHJhY2suX2R1bW15RWw7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU1lZGlhU3RyZWFtVHJhY2tMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFTdHJlYW1UcmFjayA9IGxvY2FsTWVkaWFUcmFjay5tZWRpYVN0cmVhbVRyYWNrO1xuICAgICAgICAgICAgICAgICAgICBhZGRNZWRpYVN0cmVhbVRyYWNrTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrQ2hhbmdlSW5Qcm9ncmVzcy5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrQ2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcignZmFpbGVkIHRvIHJlc3RhcnQgdHJhY2s6ICcsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IElmIHRoZSBNZWRpYVN0cmVhbVRyYWNrIGVuZHMgYmVmb3JlIHRoZSBET00gaXMgdmlzaWJsZSxcbiAgICAgICAgICAgIC8vIHRoZW4gdGhpcyBtYWtlcyBzdXJlIHRoYXQgdmlzaWJpbGl0eSBjYWxsYmFjayBmb3IgcGhhc2UgMiBpcyBjYWxsZWQgb25seVxuICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIE1lZGlhU3RyZWFtVHJhY2sgaXMgcmUtYWNxdWlyZWQuXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9ICh0cmFja0NoYW5nZUluUHJvZ3Jlc3MgJiYgdHJhY2tDaGFuZ2VJblByb2dyZXNzLnByb21pc2UpIHx8IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBsb2NhbE1lZGlhUmVzdGFydERlZmVycmVkcy5yZXNvbHZlRGVmZXJyZWQoa2luZCk7IH0pO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXgpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihcImVycm9yIGluIG1heWJlUmVzdGFydDogXCIgKyBleC5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTXV0ZSgpIHtcbiAgICAgICAgdmFyIGxvZyA9IGxvY2FsTWVkaWFUcmFjay5fbG9nLCBraW5kID0gbG9jYWxNZWRpYVRyYWNrLmtpbmQ7XG4gICAgICAgIGxvZy5pbmZvKCdNdXRlZCcpO1xuICAgICAgICBsb2cuZGVidWcoJ0xvY2FsTWVkaWFUcmFjazonLCBsb2NhbE1lZGlhVHJhY2spO1xuICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBXaGVuIGEgTG9jYWxNZWRpYVRyYWNrIGlzIG11dGVkIHdpdGhvdXQgdGhlIGFwcCBiZWluZ1xuICAgICAgICAvLyBiYWNrZ3JvdW5kZWQsIGFuZCB0aGUgaW5hZHZlcnRlbnRseSBwYXVzZWQgZWxlbWVudHMgYXJlIHBsYXllZCBiZWZvcmUgaXRcbiAgICAgICAgLy8gaXMgcmVzdGFydGVkLCBpdCBuZXZlciBnZXRzIHVubXV0ZWQgZHVlIHRvIHRoZSBXZWJLaXQgQnVnIDIxMzg1My4gSGVuY2UsXG4gICAgICAgIC8vIHNldHRpbmcgdGhpcyBEZWZlcnJlZCB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZSBpbmFkdmVydGVudGx5IHBhdXNlZCBlbGVtZW50c1xuICAgICAgICAvLyBhcmUgcGxheWVkIG9ubHkgYWZ0ZXIgdGhlIExvY2FsTWVkaWFUcmFjayBpcyB1bm11dGVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBCdWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMTM4NTNcbiAgICAgICAgLy9cbiAgICAgICAgbG9jYWxNZWRpYVJlc3RhcnREZWZlcnJlZHMuc3RhcnREZWZlcnJlZChraW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkTWVkaWFTdHJlYW1UcmFja0xpc3RlbmVycygpIHtcbiAgICAgICAgbWVkaWFTdHJlYW1UcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIG1heWJlUmVzdGFydCk7XG4gICAgICAgIG1lZGlhU3RyZWFtVHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbXV0ZScsIG9uTXV0ZSk7XG4gICAgICAgIG1lZGlhU3RyZWFtVHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgbWF5YmVSZXN0YXJ0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTWVkaWFTdHJlYW1UcmFja0xpc3RlbmVycygpIHtcbiAgICAgICAgbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIG1heWJlUmVzdGFydCk7XG4gICAgICAgIG1lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignbXV0ZScsIG9uTXV0ZSk7XG4gICAgICAgIG1lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgbWF5YmVSZXN0YXJ0KTtcbiAgICB9XG4gICAgLy8gTk9URShtcGF0d2FyZGhhbik6IGxpc3RlbiBmb3IgZG9jdW1lbnQgdmlzaWJpbGl0eSBjYWxsYmFjayBvbiBwaGFzZSAxLlxuICAgIC8vIHRoaXMgZW5zdXJlcyB0aGF0IHdlIGFjcXVpcmUgbWVkaWEgdHJhY2tzIGJlZm9yZSBSZW1vdGVNZWRpYVRyYWNrXG4gICAgLy8gdHJpZXMgdG8gYHBsYXlgIHRoZW0gKGluIHBoYXNlIDIpLiBUaGlzIG9yZGVyIGlzIGltcG9ydGFudCBiZWNhdXNlXG4gICAgLy8gcGxheSBjYW4gZmFpbCBvbiBzYWZhcmkgaWYgYXVkaW8gaXMgbm90IGJlaW5nIGNhcHR1cmVkLlxuICAgIHZhciBvblZpc2liaWxpdHlDaGFuZ2UgPSBmdW5jdGlvbiAoaXNWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBpc1Zpc2libGUgPyBtYXliZVJlc3RhcnQoKSA6IGZhbHNlO1xuICAgIH07XG4gICAgZG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvci5vblZpc2liaWxpdHlDaGFuZ2UoMSwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICBhZGRNZWRpYVN0cmVhbVRyYWNrTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvci5vZmZWaXNpYmlsaXR5Q2hhbmdlKDEsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICAgIHJlbW92ZU1lZGlhU3RyZWFtVHJhY2tMaXN0ZW5lcnMoKTtcbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBtaXhpbkxvY2FsTWVkaWFUcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsbWVkaWF0cmFjay5qcy5tYXAiLCIvKiBlc2xpbnQgbmV3LWNhcDowICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFRyYWNrUHVibGljYXRpb24gPSByZXF1aXJlKCcuL3RyYWNrcHVibGljYXRpb24nKTtcbnZhciBfYSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uc3RhbnRzJyksIEUgPSBfYS50eXBlRXJyb3JzLCB0cmFja1ByaW9yaXR5ID0gX2EudHJhY2tQcmlvcml0eTtcbi8qKlxuICogQSB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9ufSBpcyBhIHtAbGluayBMb2NhbFRyYWNrfSB0aGF0IGhhcyBiZWVuXG4gKiBwdWJsaXNoZWQgdG8gYSB7QGxpbmsgUm9vbX0uXG4gKiBAZXh0ZW5kcyBUcmFja1B1YmxpY2F0aW9uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzVHJhY2tFbmFibGVkIC0gd2hldGhlciB0aGUgcHVibGlzaGVkIHtAbGluayBMb2NhbFRyYWNrfVxuICogICBpcyBlbmFibGVkXG4gKiBAcHJvcGVydHkge1RyYWNrLktpbmR9IGtpbmQgLSBraW5kIG9mIHRoZSBwdWJsaXNoZWQge0BsaW5rIExvY2FsVHJhY2t9XG4gKiBAcHJvcGVydHkge1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eSAtIHRoZSBwdWJsaXNoIHByaW9yaXR5IG9mIHRoZSB7QGxpbmsgTG9jYWxUcmFja31cbiAqIEBwcm9wZXJ0eSB7TG9jYWxUcmFja30gdHJhY2sgLSB0aGUge0BsaW5rIExvY2FsVHJhY2t9XG4gKi9cbnZhciBMb2NhbFRyYWNrUHVibGljYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvY2FsVHJhY2tQdWJsaWNhdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9ufS5cbiAgICAgKiBAcGFyYW0ge0xvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ30gc2lnbmFsaW5nIC0gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9XG4gICAgICogQHBhcmFtIHtMb2NhbFRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgTG9jYWxUcmFja31cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKExvY2FsVHJhY2tQdWJsaWNhdGlvbik6IHZvaWR9IHVucHVibGlzaCAtIFRoZSBjYWxsYmFja1xuICAgICAqICAgdGhhdCB1bnB1Ymxpc2hlcyB0aGUge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn1cbiAgICAgKiBAcGFyYW0ge1RyYWNrUHVibGljYXRpb25PcHRpb25zfSBvcHRpb25zIC0ge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn1cbiAgICAgKiAgIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2NhbFRyYWNrUHVibGljYXRpb24oc2lnbmFsaW5nLCB0cmFjaywgdW5wdWJsaXNoLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYWNrLm5hbWUsIHNpZ25hbGluZy5zaWQsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfcmVlbWl0VHJhY2tFdmVudDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5lbWl0KF90aGlzLmlzVHJhY2tFbmFibGVkXG4gICAgICAgICAgICAgICAgICAgID8gJ3RyYWNrRW5hYmxlZCdcbiAgICAgICAgICAgICAgICAgICAgOiAndHJhY2tEaXNhYmxlZCcpOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NpZ25hbGluZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzaWduYWxpbmdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdW5wdWJsaXNoOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHVucHVibGlzaFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzVHJhY2tFbmFibGVkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2sua2luZCA9PT0gJ2RhdGEnID8gdHJ1ZSA6IHRoaXMudHJhY2suaXNFbmFibGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBraW5kOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhY2sua2luZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByaW9yaXR5OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hbGluZy51cGRhdGVkUHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYWNrOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRyYWNrLm9uKCdkaXNhYmxlZCcsIF90aGlzLl9yZWVtaXRUcmFja0V2ZW50KTtcbiAgICAgICAgdHJhY2sub24oJ2VuYWJsZWQnLCBfdGhpcy5fcmVlbWl0VHJhY2tFdmVudCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTG9jYWxUcmFja1B1YmxpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW0xvY2FsVHJhY2tQdWJsaWNhdGlvbiAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgdGhpcy50cmFja1NpZCArIFwiXVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IG9mIHRoZSBwdWJsaXNoZWQge0BsaW5rIExvY2FsVHJhY2t9LlxuICAgICAqIEBwYXJhbSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5IC0gdGhlIG5ldyB7QGxpbmsgVHJhY2sucHJpb3JpdHl9XG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAgICAgKi9cbiAgICBMb2NhbFRyYWNrUHVibGljYXRpb24ucHJvdG90eXBlLnNldFByaW9yaXR5ID0gZnVuY3Rpb24gKHByaW9yaXR5KSB7XG4gICAgICAgIHZhciBwcmlvcml0eVZhbHVlcyA9IE9iamVjdC52YWx1ZXModHJhY2tQcmlvcml0eSk7XG4gICAgICAgIGlmICghcHJpb3JpdHlWYWx1ZXMuaW5jbHVkZXMocHJpb3JpdHkpKSB7XG4gICAgICAgICAgICB0aHJvdyBFLklOVkFMSURfVkFMVUUoJ3ByaW9yaXR5JywgcHJpb3JpdHlWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpZ25hbGluZy5zZXRQcmlvcml0eShwcmlvcml0eSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5wdWJsaXNoIGEge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn0uIFRoaXMgbWVhbnMgdGhhdCB0aGUgbWVkaWFcbiAgICAgKiBmcm9tIHRoaXMge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn0gaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgUm9vbX0ncyB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9cy5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBMb2NhbFRyYWNrUHVibGljYXRpb24ucHJvdG90eXBlLnVucHVibGlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmFjay5yZW1vdmVMaXN0ZW5lcignZGlzYWJsZWQnLCB0aGlzLl9yZWVtaXRUcmFja0V2ZW50KTtcbiAgICAgICAgdGhpcy50cmFjay5yZW1vdmVMaXN0ZW5lcignZW5hYmxlZCcsIHRoaXMuX3JlZW1pdFRyYWNrRXZlbnQpO1xuICAgICAgICB0aGlzLl91bnB1Ymxpc2godGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2FsVHJhY2tQdWJsaWNhdGlvbjtcbn0oVHJhY2tQdWJsaWNhdGlvbikpO1xubW9kdWxlLmV4cG9ydHMgPSBMb2NhbFRyYWNrUHVibGljYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbHRyYWNrcHVibGljYXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfYSA9IHJlcXVpcmUoJy4uLy4uL3dlYnJ0Yy91dGlsJyksIGd1ZXNzQnJvd3NlciA9IF9hLmd1ZXNzQnJvd3NlciwgaXNJT1NDaHJvbWUgPSBfYS5pc0lPU0Nocm9tZTtcbnZhciBkZXRlY3RTaWxlbnRWaWRlbyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZGV0ZWN0c2lsZW50dmlkZW8nKTtcbnZhciBtaXhpbkxvY2FsTWVkaWFUcmFjayA9IHJlcXVpcmUoJy4vbG9jYWxtZWRpYXRyYWNrJyk7XG52YXIgVmlkZW9UcmFjayA9IHJlcXVpcmUoJy4vdmlkZW90cmFjaycpO1xudmFyIGlzVXNlck1lZGlhVHJhY2sgPSByZXF1aXJlKCcuLi8uLi91dGlsJykuaXNVc2VyTWVkaWFUcmFjaztcbnZhciBMb2NhbE1lZGlhVmlkZW9UcmFjayA9IG1peGluTG9jYWxNZWRpYVRyYWNrKFZpZGVvVHJhY2spO1xuLyoqXG4gKiBBIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IGlzIGEge0BsaW5rIFZpZGVvVHJhY2t9IHJlcHJlc2VudGluZyB2aWRlbyB0aGF0XG4gKiB5b3VyIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBjYW4gcHVibGlzaCB0byBhIHtAbGluayBSb29tfS4gSXQgY2FuIGJlXG4gKiBlbmFibGVkIGFuZCBkaXNhYmxlZCB3aXRoIHtAbGluayBMb2NhbFZpZGVvVHJhY2sjZW5hYmxlfSBhbmRcbiAqIHtAbGluayBMb2NhbFZpZGVvVHJhY2sjZGlzYWJsZX0gb3Igc3RvcHBlZCBjb21wbGV0ZWx5IHdpdGhcbiAqIHtAbGluayBMb2NhbFZpZGVvVHJhY2sjc3RvcH0uXG4gKiBAZXh0ZW5kcyBWaWRlb1RyYWNrXG4gKiBAcHJvcGVydHkge1RyYWNrLklEfSBpZCAtIFRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSdzIElEXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU3RvcHBlZCAtIFdoZXRoZXIgb3Igbm90IHRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSBpc1xuICogICBzdG9wcGVkXG4gKiBAZW1pdHMgTG9jYWxWaWRlb1RyYWNrI2Rpc2FibGVkXG4gKiBAZW1pdHMgTG9jYWxWaWRlb1RyYWNrI2VuYWJsZWRcbiAqIEBlbWl0cyBMb2NhbFZpZGVvVHJhY2sjc3RhcnRlZFxuICogQGVtaXRzIExvY2FsVmlkZW9UcmFjayNzdG9wcGVkXG4gKi9cbnZhciBMb2NhbFZpZGVvVHJhY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvY2FsVmlkZW9UcmFjaywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSBmcm9tIGEgTWVkaWFTdHJlYW1UcmFjay5cbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IG1lZGlhU3RyZWFtVHJhY2sgLSBUaGUgdW5kZXJseWluZyBNZWRpYVN0cmVhbVRyYWNrXG4gICAgICogQHBhcmFtIHtMb2NhbFRyYWNrT3B0aW9uc30gW29wdGlvbnNdIC0ge0BsaW5rIExvY2FsVHJhY2t9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2NhbFZpZGVvVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICB3b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlbzogKGd1ZXNzQnJvd3NlcigpID09PSAnc2FmYXJpJyB8fCBpc0lPU0Nocm9tZSgpKVxuICAgICAgICAgICAgICAgICYmIGlzVXNlck1lZGlhVHJhY2sobWVkaWFTdHJlYW1UcmFjaylcbiAgICAgICAgICAgICAgICAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVkaWFTdHJlYW1UcmFjaywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF93b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlbzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLndvcmthcm91bmRTaWxlbnRMb2NhbFZpZGVvXG4gICAgICAgICAgICAgICAgICAgID8gd29ya2Fyb3VuZFNpbGVudExvY2FsVmlkZW9cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3dvcmthcm91bmRTaWxlbnRMb2NhbFZpZGVvQ2xlYW51cDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBJbiBpT1MgU2FmYXJpLCB3ZSB3b3JrIGFyb3VuZCBhIGJ1ZyB3aGVyZSBsb2NhbCB2aWRlb1xuICAgICAgICAvLyBNZWRpYVN0cmVhbVRyYWNrcyBhcmUgc2lsZW50IChldmVuIHRob3VnaCB0aGV5IGFyZSBlbmFibGVkLCBsaXZlIGFuZCB1bm11dGVkKVxuICAgICAgICAvLyBhZnRlciBhY2NlcHRpbmcvcmVqZWN0aW5nIGEgcGhvbmUgY2FsbC5cbiAgICAgICAgaWYgKF90aGlzLl93b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlbykge1xuICAgICAgICAgICAgX3RoaXMuX3dvcmthcm91bmRTaWxlbnRMb2NhbFZpZGVvQ2xlYW51cCA9IF90aGlzLl93b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlbyhfdGhpcywgZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTG9jYWxWaWRlb1RyYWNrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW0xvY2FsVmlkZW9UcmFjayAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgdGhpcy5pZCArIFwiXVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBMb2NhbFZpZGVvVHJhY2sucHJvdG90eXBlLl9jaGVja0lmQ2FuQ2FwdHVyZUZyYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX2NoZWNrSWZDYW5DYXB0dXJlRnJhbWVzLmNhbGwodGhpcywgdGhpcy5fdHJhY2tTZW5kZXIuaXNQdWJsaXNoaW5nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTG9jYWxWaWRlb1RyYWNrLnByb3RvdHlwZS5fZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5fZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIExvY2FsVmlkZW9UcmFjay5wcm90b3R5cGUuX3NldFNlbmRlck1lZGlhU3RyZWFtVHJhY2sgPSBmdW5jdGlvbiAodXNlUHJvY2Vzc2VkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1bnByb2Nlc3NlZFRyYWNrID0gdGhpcy5tZWRpYVN0cmVhbVRyYWNrO1xuICAgICAgICB2YXIgbWVkaWFTdHJlYW1UcmFjayA9IHVzZVByb2Nlc3NlZCA/IHRoaXMucHJvY2Vzc2VkVHJhY2sgOiB1bnByb2Nlc3NlZFRyYWNrO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tTZW5kZXIuc2V0TWVkaWFTdHJlYW1UcmFjayhtZWRpYVN0cmVhbVRyYWNrKVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gX3RoaXMuX2xvZy53YXJuKCdzZXRNZWRpYVN0cmVhbVRyYWNrIGZhaWxlZCBvbiBMb2NhbFZpZGVvVHJhY2sgUlRDUnRwU2VuZGVyJywgeyBlcnJvcjogZXJyb3IsIG1lZGlhU3RyZWFtVHJhY2s6IG1lZGlhU3RyZWFtVHJhY2sgfSk7IH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fdW5wcm9jZXNzZWRUcmFjayA9IHVzZVByb2Nlc3NlZCA/IHVucHJvY2Vzc2VkVHJhY2sgOiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIHtAbGluayBWaWRlb1Byb2Nlc3Nvcn0gdG8gYWxsb3cgZm9yIGN1c3RvbSBwcm9jZXNzaW5nIG9mIHZpZGVvIGZyYW1lcyBiZWxvbmdpbmcgdG8gYSBWaWRlb1RyYWNrLlxuICAgICAqIE9ubHkgQ2hyb21lIHN1cHBvcnRzIHRoaXMgYXMgb2Ygbm93LiBDYWxsaW5nIHRoaXMgQVBJIGZyb20gYSBub24tc3VwcG9ydGVkIGJyb3dzZXIgd2lsbCByZXN1bHQgaW4gYSBsb2cgd2FybmluZy5cbiAgICAgKiBAcGFyYW0ge1ZpZGVvUHJvY2Vzc29yfSBwcm9jZXNzb3IgLSBUaGUge0BsaW5rIFZpZGVvUHJvY2Vzc29yfSB0byB1c2UuXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjbGFzcyBHcmF5U2NhbGVQcm9jZXNzb3Ige1xuICAgICAqICAgY29uc3RydWN0b3IocGVyY2VudGFnZSkge1xuICAgICAqICAgICB0aGlzLnBlcmNlbnRhZ2UgPSBwZXJjZW50YWdlO1xuICAgICAqICAgfVxuICAgICAqICAgcHJvY2Vzc0ZyYW1lKGlucHV0RnJhbWVCdWZmZXIsIG91dHB1dEZyYW1lQnVmZmVyKSB7XG4gICAgICogICAgIGNvbnN0IGNvbnRleHQgPSBvdXRwdXRGcmFtZUJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAqICAgICBjb250ZXh0LmZpbHRlciA9IGBncmF5c2NhbGUoJHt0aGlzLnBlcmNlbnRhZ2V9JSlgO1xuICAgICAqICAgICBjb250ZXh0LmRyYXdJbWFnZShpbnB1dEZyYW1lQnVmZmVyLCAwLCAwLCBpbnB1dEZyYW1lQnVmZmVyLndpZHRoLCBpbnB1dEZyYW1lQnVmZmVyLmhlaWdodCk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgbG9jYWxWaWRlb1RyYWNrID0gQXJyYXkuZnJvbShyb29tLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja3MudmFsdWVzKCkpWzBdLnRyYWNrO1xuICAgICAqIGxvY2FsVmlkZW9UcmFjay5hZGRQcm9jZXNzb3IobmV3IEdyYXlTY2FsZVByb2Nlc3NvcigxMDApKTtcbiAgICAgKi9cbiAgICBMb2NhbFZpZGVvVHJhY2sucHJvdG90eXBlLmFkZFByb2Nlc3NvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdBZGRpbmcgVmlkZW9Qcm9jZXNzb3IgdG8gdGhlIExvY2FsVmlkZW9UcmFjaycpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5hZGRQcm9jZXNzb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nLndhcm4oJ1VuYWJsZSB0byBhZGQgYSBWaWRlb1Byb2Nlc3NvciB0byB0aGUgTG9jYWxWaWRlb1RyYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdVcGRhdGluZyBMb2NhbFZpZGVvVHJhY2tcXCdzIE1lZGlhU3RyZWFtVHJhY2sgd2l0aCB0aGUgcHJvY2Vzc2VkIE1lZGlhU3RyZWFtVHJhY2snLCB0aGlzLnByb2Nlc3NlZFRyYWNrKTtcbiAgICAgICAgdGhpcy5fc2V0U2VuZGVyTWVkaWFTdHJlYW1UcmFjayh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgcHJldmlvdXNseSBhZGRlZCB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9IHVzaW5nIGBhZGRQcm9jZXNzb3JgIEFQSS5cbiAgICAgKiBAcGFyYW0ge1ZpZGVvUHJvY2Vzc29yfSBwcm9jZXNzb3IgLSBUaGUge0BsaW5rIFZpZGVvUHJvY2Vzc29yfSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjbGFzcyBHcmF5U2NhbGVQcm9jZXNzb3Ige1xuICAgICAqICAgY29uc3RydWN0b3IocGVyY2VudGFnZSkge1xuICAgICAqICAgICB0aGlzLnBlcmNlbnRhZ2UgPSBwZXJjZW50YWdlO1xuICAgICAqICAgfVxuICAgICAqICAgcHJvY2Vzc0ZyYW1lKGlucHV0RnJhbWVCdWZmZXIsIG91dHB1dEZyYW1lQnVmZmVyKSB7XG4gICAgICogICAgIGNvbnN0IGNvbnRleHQgPSBvdXRwdXRGcmFtZUJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAqICAgICBjb250ZXh0LmZpbHRlciA9IGBncmF5c2NhbGUoJHt0aGlzLnBlcmNlbnRhZ2V9JSlgO1xuICAgICAqICAgICBjb250ZXh0LmRyYXdJbWFnZShpbnB1dEZyYW1lQnVmZmVyLCAwLCAwLCBpbnB1dEZyYW1lQnVmZmVyLndpZHRoLCBpbnB1dEZyYW1lQnVmZmVyLmhlaWdodCk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgbG9jYWxWaWRlb1RyYWNrID0gQXJyYXkuZnJvbShyb29tLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja3MudmFsdWVzKCkpWzBdLnRyYWNrO1xuICAgICAqIGNvbnN0IGdyYXlTY2FsZVByb2Nlc3NvciA9IG5ldyBHcmF5U2NhbGVQcm9jZXNzb3IoMTAwKTtcbiAgICAgKiBsb2NhbFZpZGVvVHJhY2suYWRkUHJvY2Vzc29yKGdyYXlTY2FsZVByb2Nlc3Nvcik7XG4gICAgICpcbiAgICAgKiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVtb3ZlLWJ1dHRvbicpLm9uY2xpY2sgPSAoKSA9PiBsb2NhbFZpZGVvVHJhY2sucmVtb3ZlUHJvY2Vzc29yKGdyYXlTY2FsZVByb2Nlc3Nvcik7XG4gICAgICovXG4gICAgTG9jYWxWaWRlb1RyYWNrLnByb3RvdHlwZS5yZW1vdmVQcm9jZXNzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygnUmVtb3ZpbmcgVmlkZW9Qcm9jZXNzb3IgZnJvbSB0aGUgTG9jYWxWaWRlb1RyYWNrJyk7XG4gICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLnJlbW92ZVByb2Nlc3Nvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ1VwZGF0aW5nIExvY2FsVmlkZW9UcmFja1xcJ3MgTWVkaWFTdHJlYW1UcmFjayB3aXRoIHRoZSBvcmlnaW5hbCBNZWRpYVN0cmVhbVRyYWNrJyk7XG4gICAgICAgIHRoaXMuX3NldFNlbmRlck1lZGlhU3RyZWFtVHJhY2soKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3VwZGF0ZUVsZW1lbnRzTWVkaWFTdHJlYW1UcmFjaygpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9LiBUaGlzIGlzIGVmZmVjdGl2ZWx5IFwicGF1c2VcIi5cbiAgICAgKiBJZiBhIHtAbGluayBWaWRlb1Byb2Nlc3Nvcn0gaXMgYWRkZWQsIHRoZW4gYHByb2Nlc3NlZFRyYWNrYCBpcyBkaXNhYmxlZCBhcyB3ZWxsLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBmaXJlcyBWaWRlb1RyYWNrI2Rpc2FibGVkXG4gICAgICovXG4gICAgTG9jYWxWaWRlb1RyYWNrLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5kaXNhYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NlZFRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfS4gVGhpcyBpcyBlZmZlY3RpdmVseSBcInVucGF1c2VcIi5cbiAgICAgKiBJZiBhIHtAbGluayBWaWRlb1Byb2Nlc3Nvcn0gaXMgYWRkZWQsIHRoZW4gYHByb2Nlc3NlZFRyYWNrYCBpcyBlbmFibGVkIGFzIHdlbGwuXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGZpcmVzIFZpZGVvVHJhY2sjZW5hYmxlZFxuICAgICovIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfS4gVGhpcyBpcyBlZmZlY3RpdmVseSBcInVucGF1c2VcIlxuICAgICAqIG9yIFwicGF1c2VcIi4gSWYgYSB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9IGlzIGFkZGVkLFxuICAgICAqIHRoZW4gYHByb2Nlc3NlZFRyYWNrYCBpcyBlbmFibGVkIG9yIGRpc2FibGVkIGFzIHdlbGwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZW5hYmxlZF0gLSBTcGVjaWZ5IGZhbHNlIHRvIHBhdXNlIHRoZVxuICAgICAqICAge0BsaW5rIExvY2FsVmlkZW9UcmFja31cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAZmlyZXMgVmlkZW9UcmFjayNkaXNhYmxlZFxuICAgICAqIEBmaXJlcyBWaWRlb1RyYWNrI2VuYWJsZWRcbiAgICAgKi9cbiAgICBMb2NhbFZpZGVvVHJhY2sucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIGlmIChlbmFibGVkID09PSB2b2lkIDApIHsgZW5hYmxlZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuZW5hYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NlZFRyYWNrLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYXB0dXJlRnJhbWVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdVcGRhdGluZyBMb2NhbFZpZGVvVHJhY2tcXCdzIE1lZGlhU3RyZWFtVHJhY2sgd2l0aCB0aGUgcHJvY2Vzc2VkIE1lZGlhU3RyZWFtVHJhY2snLCB0aGlzLnByb2Nlc3NlZFRyYWNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTZW5kZXJNZWRpYVN0cmVhbVRyYWNrKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXN0YXJ0IHRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfS4gVGhpcyBzdG9wcyB0aGUgZXhpc3RpbmcgTWVkaWFTdHJlYW1UcmFja1xuICAgICAqIGFuZCBjcmVhdGVzIGEgbmV3IE1lZGlhU3RyZWFtVHJhY2suIElmIHRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSBpcyBiZWluZyBwdWJsaXNoZWRcbiAgICAgKiB0byBhIHtAbGluayBSb29tfSwgdGhlbiBhbGwgdGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH1zIHdpbGwgc3RhcnQgcmVjZWl2aW5nIG1lZGlhXG4gICAgICogZnJvbSB0aGUgbmV3bHkgY3JlYXRlZCBNZWRpYVN0cmVhbVRyYWNrLiBZb3UgY2FuIGFjY2VzcyB0aGUgbmV3IE1lZGlhU3RyZWFtVHJhY2sgdmlhXG4gICAgICogdGhlIDxjb2RlPm1lZGlhU3RyZWFtVHJhY2s8L2NvZGU+IHByb3BlcnR5LiBJZiB5b3Ugd2FudCB0byBsaXN0ZW4gdG8gZXZlbnRzIG9uXG4gICAgICogdGhlIE1lZGlhU3RyZWFtVHJhY2sgZGlyZWN0bHksIHBsZWFzZSBkbyBzbyBpbiB0aGUgXCJzdGFydGVkXCIgZXZlbnQgaGFuZGxlci4gQWxzbyxcbiAgICAgKiB0aGUge0BsaW5rIExvY2FsVmlkZW9UcmFja30ncyBJRCBpcyBubyBsb25nZXIgZ3VhcmFudGVlZCB0byBiZSB0aGUgc2FtZSBhcyB0aGVcbiAgICAgKiB1bmRlcmx5aW5nIE1lZGlhU3RyZWFtVHJhY2sncyBJRC5cbiAgICAgKiBAcGFyYW0ge01lZGlhVHJhY2tDb25zdHJhaW50c30gW2NvbnN0cmFpbnRzXSAtIFRoZSBvcHRpb25hbCA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhVHJhY2tDb25zdHJhaW50c1wiIHRhcmdldD1cIl9ibGFua1wiPk1lZGlhVHJhY2tDb25zdHJhaW50czwvYT5cbiAgICAgKiAgIGZvciByZXN0YXJ0aW5nIHRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfTsgSWYgbm90IHNwZWNpZmllZCwgdGhlbiB0aGUgY3VycmVudCBNZWRpYVRyYWNrQ29uc3RyYWludHNcbiAgICAgKiAgIHdpbGwgYmUgdXNlZDsgSWYgPGNvZGU+e308L2NvZGU+IChlbXB0eSBvYmplY3QpIGlzIHNwZWNpZmllZCwgdGhlbiB0aGUgZGVmYXVsdCBNZWRpYVRyYWNrQ29uc3RyYWludHNcbiAgICAgKiAgIHdpbGwgYmUgdXNlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZWplY3RzIHdpdGggYSBUeXBlRXJyb3IgaWYgdGhlIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IHdhcyBub3QgY3JlYXRlZFxuICAgICAqICAgdXNpbmcgYW4gb25lIG9mIDxjb2RlPmNyZWF0ZUxvY2FsVmlkZW9UcmFjazwvY29kZT4sIDxjb2RlPmNyZWF0ZUxvY2FsVHJhY2tzPC9jb2RlPiBvciA8Y29kZT5jb25uZWN0PC9jb2RlPjtcbiAgICAgKiAgIEFsc28gcmVqZWN0cyB3aXRoIHRoZSA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhRGV2aWNlcy9nZXRVc2VyTWVkaWEjRXhjZXB0aW9uc1wiIHRhcmdldD1cIl9ibGFua1wiPkRPTUV4Y2VwdGlvbjwvYT5cbiAgICAgKiAgIHJhaXNlZCBieSA8Y29kZT5nZXRVc2VyTWVkaWE8L2NvZGU+IHdoZW4gaXQgZmFpbHNcbiAgICAgKiBAZmlyZXMgTG9jYWxWaWRlb1RyYWNrI3N0b3BwZWRcbiAgICAgKiBAZmlyZXMgTG9jYWxWaWRlb1RyYWNrI3N0YXJ0ZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHsgY29ubmVjdCwgY3JlYXRlTG9jYWxWaWRlb1RyYWNrIH0gPSByZXF1aXJlKCd0d2lsaW8tdmlkZW8nKTtcbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBhIExvY2FsVmlkZW9UcmFjayB0aGF0IGNhcHR1cmVzIHZpZGVvIGZyb20gdGhlIGZyb250LWZhY2luZyBjYW1lcmEuXG4gICAgICogY3JlYXRlTG9jYWxWaWRlb1RyYWNrKHsgZmFjaW5nTW9kZTogJ3VzZXInIH0pLnRoZW4oZnVuY3Rpb24obG9jYWxWaWRlb1RyYWNrKSB7XG4gICAgICogICByZXR1cm4gY29ubmVjdCgndG9rZW4nLCB7XG4gICAgICogICAgIG5hbWU6ICdteS1jb29sLXJvb20nLFxuICAgICAqICAgICB0cmFja3M6IFtsb2NhbFZpZGVvVHJhY2tdXG4gICAgICogICB9KTtcbiAgICAgKiB9KS50aGVuKGZ1bmN0aW9uKHJvb20pIHtcbiAgICAgKiAgIC8vIFJlc3RhcnQgdGhlIExvY2FsVmlkZW9UcmFjayB0byBjYXB0dXJlIHZpZGVvIGZyb20gdGhlIGJhY2stZmFjaW5nIGNhbWVyYS5cbiAgICAgKiAgIGNvbnN0IGxvY2FsVmlkZW9UcmFjayA9IEFycmF5LmZyb20ocm9vbS5sb2NhbFBhcnRpY2lwYW50LnZpZGVvVHJhY2tzLnZhbHVlcygpKVswXS50cmFjaztcbiAgICAgKiAgIHJldHVybiBsb2NhbFZpZGVvVHJhY2sucmVzdGFydCh7IGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcgfSk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgTG9jYWxWaWRlb1RyYWNrLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fd29ya2Fyb3VuZFNpbGVudExvY2FsVmlkZW9DbGVhbnVwKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlb0NsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmthcm91bmRTaWxlbnRMb2NhbFZpZGVvQ2xlYW51cCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb21pc2UgPSBfc3VwZXIucHJvdG90eXBlLnJlc3RhcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXN0YXJ0UHJvY2Vzc29yKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fd29ya2Fyb3VuZFNpbGVudExvY2FsVmlkZW8pIHtcbiAgICAgICAgICAgIHByb21pc2UuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3dvcmthcm91bmRTaWxlbnRMb2NhbFZpZGVvQ2xlYW51cCA9IF90aGlzLl93b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlbyhfdGhpcywgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxscyBzdG9wIG9uIHRoZSB1bmRlcmx5aW5nIE1lZGlhU3RyZWFtVHJhY2suIElmIHlvdSBjaG9vc2UgdG8gc3RvcCBhXG4gICAgICoge0BsaW5rIExvY2FsVmlkZW9UcmFja30sIHlvdSBzaG91bGQgdW5wdWJsaXNoIGl0IGFmdGVyIHN0b3BwaW5nLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBmaXJlcyBMb2NhbFZpZGVvVHJhY2sjc3RvcHBlZFxuICAgICAqL1xuICAgIExvY2FsVmlkZW9UcmFjay5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmthcm91bmRTaWxlbnRMb2NhbFZpZGVvQ2xlYW51cCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya2Fyb3VuZFNpbGVudExvY2FsVmlkZW9DbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLl93b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlb0NsZWFudXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnN0b3AuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHJldHVybiBMb2NhbFZpZGVvVHJhY2s7XG59KExvY2FsTWVkaWFWaWRlb1RyYWNrKSk7XG4vKipcbiAqIFdvcmsgYXJvdW5kIGEgYnVnIHdoZXJlIGxvY2FsIHZpZGVvIE1lZGlhU3RyZWFtVHJhY2tzIGFyZSBzaWxlbnQgKGV2ZW4gdGhvdWdoXG4gKiB0aGV5IGFyZSBlbmFibGVkLCBsaXZlIGFuZCB1bm11dGVkKSBhZnRlciBhY2NlcHRpbmcvcmVqZWN0aW5nIGEgcGhvbmUgY2FsbC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0xvY2FsVmlkZW9UcmFja30gbG9jYWxWaWRlb1RyYWNrXG4gKiBAcGFyYW0ge0hUTUxEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IENsZWFucyB1cCBsaXN0ZW5lcnMgYXR0YWNoZWQgYnkgdGhlIHdvcmthcm91bmRcbiAqL1xuZnVuY3Rpb24gd29ya2Fyb3VuZFNpbGVudExvY2FsVmlkZW8obG9jYWxWaWRlb1RyYWNrLCBkb2MpIHtcbiAgICB2YXIgbG9nID0gbG9jYWxWaWRlb1RyYWNrLl9sb2c7XG4gICAgdmFyIGVsID0gbG9jYWxWaWRlb1RyYWNrLl9kdW1teUVsLCBtZWRpYVN0cmVhbVRyYWNrID0gbG9jYWxWaWRlb1RyYWNrLm1lZGlhU3RyZWFtVHJhY2s7XG4gICAgZnVuY3Rpb24gb25Vbm11dGUoKSB7XG4gICAgICAgIGlmICghbG9jYWxWaWRlb1RyYWNrLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZy5pbmZvKCdVbm11dGVkLCBjaGVja2luZyBzaWxlbmNlJyk7XG4gICAgICAgIC8vIFRoZSBkdW1teSBlbGVtZW50IGlzIHBhdXNlZCwgc28gcGxheSBpdCBhbmQgdGhlbiBkZXRlY3Qgc2lsZW5jZS5cbiAgICAgICAgZWwucGxheSgpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZGV0ZWN0U2lsZW50VmlkZW8oZWwsIGRvYyk7IH0pLnRoZW4oZnVuY3Rpb24gKGlzU2lsZW50KSB7XG4gICAgICAgICAgICBpZiAoIWlzU2lsZW50KSB7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oJ05vbi1zaWxlbnQgZnJhbWVzIGRldGVjdGVkLCBzbyBubyBuZWVkIHRvIHJlc3RhcnQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2cud2FybignU2lsZW5jZSBkZXRlY3RlZCwgcmVzdGFydGluZycpO1xuICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogSWYgd2UgdHJ5IGFuZCByZXN0YXJ0IGEgc2lsZW50IE1lZGlhU3RyZWFtVHJhY2tcbiAgICAgICAgICAgIC8vIHdpdGhvdXQgc3RvcHBpbmcgaXQgZmlyc3QsIHRoZW4gYSBOb3RSZWFkYWJsZUVycm9yIGlzIHJhaXNlZC4gSGVuY2UsXG4gICAgICAgICAgICAvLyB3ZSBzdG9wIHRoZSBNZWRpYVN0cmVhbVRyYWNrIGhlcmUuXG4gICAgICAgICAgICBsb2NhbFZpZGVvVHJhY2suX3N0b3AoKTtcbiAgICAgICAgICAgIC8vIFJlc3RhcnQgdGhlIExvY2FsVmlkZW9UcmFjay5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmlkZW9UcmFjay5fcmVzdGFydCgpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKCdGYWlsZWQgdG8gZGV0ZWN0IHNpbGVuY2UgYW5kIHJlc3RhcnQ6JywgZXJyb3IpO1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHNpbGVudCBmcmFtZXMgd2VyZSBub3QgZGV0ZWN0ZWQsIHRoZW4gcGF1c2UgdGhlIGR1bW15IGVsZW1lbnQgYWdhaW4uXG4gICAgICAgICAgICBlbCA9IGxvY2FsVmlkZW9UcmFjay5fZHVtbXlFbDtcbiAgICAgICAgICAgIGlmICghZWwucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgZWwucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSB1bm11dGUgaGFuZGxlci5cbiAgICAgICAgICAgIG1lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgb25Vbm11dGUpO1xuICAgICAgICAgICAgbWVkaWFTdHJlYW1UcmFjayA9IGxvY2FsVmlkZW9UcmFjay5tZWRpYVN0cmVhbVRyYWNrO1xuICAgICAgICAgICAgbWVkaWFTdHJlYW1UcmFjay5hZGRFdmVudExpc3RlbmVyKCd1bm11dGUnLCBvblVubXV0ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTZXQgdGhlIHVubXV0ZSBoYW5kbGVyLlxuICAgIG1lZGlhU3RyZWFtVHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgb25Vbm11dGUpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgb25Vbm11dGUpO1xuICAgIH07XG59XG4vKipcbiAqIFRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSB3YXMgZGlzYWJsZWQsIGkuZS4gXCJtdXRlZFwiLlxuICogQHBhcmFtIHtMb2NhbFZpZGVvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IHRoYXQgd2FzXG4gKiAgIGRpc2FibGVkXG4gKiBAZXZlbnQgTG9jYWxWaWRlb1RyYWNrI2Rpc2FibGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IHdhcyBlbmFibGVkLCBpLmUuIFwidW5tdXRlZFwiLlxuICogQHBhcmFtIHtMb2NhbFZpZGVvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IHRoYXQgd2FzIGVuYWJsZWRcbiAqIEBldmVudCBMb2NhbFZpZGVvVHJhY2sjZW5hYmxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSBzdGFydGVkLiBUaGlzIG1lYW5zIHRoZXJlIGlzIGVub3VnaCB2aWRlbyBkYXRhXG4gKiB0byBiZWdpbiBwbGF5YmFjay5cbiAqIEBwYXJhbSB7TG9jYWxWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSB0aGF0IHN0YXJ0ZWRcbiAqIEBldmVudCBMb2NhbFZpZGVvVHJhY2sjc3RhcnRlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSBzdG9wcGVkLCBlaXRoZXIgYmVjYXVzZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrI3N0b3B9XG4gKiBvciB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrI3Jlc3RhcnR9IHdhcyBjYWxsZWQgb3IgYmVjYXVzZSB0aGUgdW5kZXJseWluZ1xuICogTWVkaWFTdHJlYW1UcmFjayBlbmRlZC5cbiAqIEBwYXJhbSB7TG9jYWxWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSB0aGF0IHN0b3BwZWRcbiAqIEBldmVudCBMb2NhbFZpZGVvVHJhY2sjc3RvcHBlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsVmlkZW9UcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsdmlkZW90cmFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIExvY2FsVHJhY2tQdWJsaWNhdGlvbiA9IHJlcXVpcmUoJy4vbG9jYWx0cmFja3B1YmxpY2F0aW9uJyk7XG4vKipcbiAqIEEge0BsaW5rIExvY2FsVmlkZW9UcmFja1B1YmxpY2F0aW9ufSBpcyBhIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IHRoYXQgaGFzXG4gKiBiZWVuIHB1Ymxpc2hlZCB0byBhIHtAbGluayBSb29tfS5cbiAqIEBleHRlbmRzIExvY2FsVHJhY2tQdWJsaWNhdGlvblxuICogQHByb3BlcnR5IHtUcmFjay5LaW5kfSBraW5kIC0gXCJ2aWRlb1wiXG4gKiBAcHJvcGVydHkge0xvY2FsVmlkZW9UcmFja30gdHJhY2sgLSB0aGUge0BsaW5rIExvY2FsVmlkZW9UcmFja31cbiAqL1xudmFyIExvY2FsVmlkZW9UcmFja1B1YmxpY2F0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb259LlxuICAgICAqIEBwYXJhbSB7TG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfSBzaWduYWxpbmcgLSBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqICAge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ31cbiAgICAgKiBAcGFyYW0ge0xvY2FsVmlkZW9UcmFja30gdHJhY2sgLSB0aGUge0BsaW5rIExvY2FsVmlkZW9UcmFja31cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKExvY2FsVHJhY2tQdWJsaWNhdGlvbik6IHZvaWR9IHVucHVibGlzaCAtIFRoZSBjYWxsYmFja1xuICAgICAqICAgIHRoYXQgdW5wdWJsaXNoZXMgdGhlIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb259XG4gICAgICogQHBhcmFtIHtUcmFja1B1YmxpY2F0aW9uT3B0aW9uc30gb3B0aW9ucyAtIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb259IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvbihzaWduYWxpbmcsIHRyYWNrLCB1bnB1Ymxpc2gsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNpZ25hbGluZywgdHJhY2ssIHVucHVibGlzaCwgb3B0aW9ucykgfHwgdGhpcztcbiAgICB9XG4gICAgTG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbTG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb24gI1wiICsgdGhpcy5faW5zdGFuY2VJZCArIFwiOiBcIiArIHRoaXMudHJhY2tTaWQgKyBcIl1cIjtcbiAgICB9O1xuICAgIHJldHVybiBMb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvbjtcbn0oTG9jYWxUcmFja1B1YmxpY2F0aW9uKSk7XG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsVmlkZW9UcmFja1B1YmxpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWx2aWRlb3RyYWNrcHVibGljYXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfYSA9IHJlcXVpcmUoJy4uLy4uL3dlYnJ0Yy91dGlsJyksIGd1ZXNzQnJvd3NlciA9IF9hLmd1ZXNzQnJvd3NlciwgaXNJT1NDaHJvbWUgPSBfYS5pc0lPU0Nocm9tZTtcbnZhciBNZWRpYVN0cmVhbSA9IHJlcXVpcmUoJy4uLy4uL3dlYnJ0YycpLk1lZGlhU3RyZWFtO1xudmFyIF9iID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLCB3YWl0Rm9yRXZlbnQgPSBfYi53YWl0Rm9yRXZlbnQsIHdhaXRGb3JTb21ldGltZSA9IF9iLndhaXRGb3JTb21ldGltZTtcbnZhciBsb2NhbE1lZGlhUmVzdGFydERlZmVycmVkcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbG9jYWxtZWRpYXJlc3RhcnRkZWZlcnJlZHMnKTtcbnZhciBUcmFjayA9IHJlcXVpcmUoJy4vJyk7XG4vKipcbiAqIEEge0BsaW5rIE1lZGlhVHJhY2t9IHJlcHJlc2VudHMgYXVkaW8gb3IgdmlkZW8gdGhhdCBjYW4gYmUgc2VudCB0byBvclxuICogcmVjZWl2ZWQgZnJvbSBhIHtAbGluayBSb29tfS5cbiAqIEBleHRlbmRzIFRyYWNrXG4gKiBAcHJvcGVydHkge1RyYWNrLklEfSBpZCAtIFRoaXMge0BsaW5rIFRyYWNrfSdzIElEXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU3RhcnRlZCAtIFdoZXRoZXIgb3Igbm90IHRoZSB7QGxpbmsgTWVkaWFUcmFja30gaGFzXG4gKiAgIHN0YXJ0ZWRcbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZCAtIFRoZSBraW5kIG9mIHRoZSB1bmRlcmx5aW5nXG4gKiAgIE1lZGlhU3RyZWFtVHJhY2ssIFwiYXVkaW9cIiBvciBcInZpZGVvXCJcbiAqIEBwcm9wZXJ0eSB7P01lZGlhU3RyZWFtVHJhY2t9IG1lZGlhU3RyZWFtVHJhY2sgLSBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIHVuZGVybHlpbmdcbiAqICAgTWVkaWFTdHJlYW1UcmFjazsgSXQgaXMgc2V0IHRvIDxjb2RlPm51bGw8L2NvZGU+IGlmIGl0IGlzIGEge0BsaW5rIFJlbW90ZVRyYWNrfVxuICogICB0aGF0IGlzIHN3aXRjaGVkIG9mZlxuICogQGVtaXRzIE1lZGlhVHJhY2sjc3RhcnRlZFxuICovXG52YXIgTWVkaWFUcmFjayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVkaWFUcmFjaywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTWVkaWFUcmFja30uXG4gICAgICogQHBhcmFtIHtUcmFjay5LaW5kfSBraW5kXG4gICAgICogQHBhcmFtIHs/TWVkaWFUcmFja1RyYW5zY2VpdmVyfSBtZWRpYVRyYWNrVHJhbnNjZWl2ZXJcbiAgICAgKiBAcGFyYW0ge3sgbG9nOiBMb2csIG5hbWU6IHN0cmluZyB9fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWVkaWFUcmFjayhraW5kLCBtZWRpYVRyYWNrVHJhbnNjZWl2ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgcGxheVBhdXNlZEVsZW1lbnRzSWZOb3RCYWNrZ3JvdW5kZWQ6IChndWVzc0Jyb3dzZXIoKSA9PT0gJ3NhZmFyaScgfHwgaXNJT1NDaHJvbWUoKSlcbiAgICAgICAgICAgICAgICAmJiB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgJiYgdHlwZW9mIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAmJiB0eXBlb2YgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnc3RyaW5nJ1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBraW5kLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBNZWRpYVN0cmVhbTogTWVkaWFTdHJlYW1cbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfYXR0YWNobWVudHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFNldCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2R1bW15RWw6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9lbFNoaW1zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBXZWFrTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaXNTdGFydGVkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21lZGlhVHJhY2tUcmFuc2NlaXZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBtZWRpYVRyYWNrVHJhbnNjZWl2ZXIsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcGxheVBhdXNlZEVsZW1lbnRzSWZOb3RCYWNrZ3JvdW5kZWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5wbGF5UGF1c2VkRWxlbWVudHNJZk5vdEJhY2tncm91bmRlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaG91bGRTaGltQXR0YWNoZWRFbGVtZW50czoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLndvcmthcm91bmRXZWJLaXRCdWcyMTI3ODBcbiAgICAgICAgICAgICAgICAgICAgfHwgb3B0aW9ucy5wbGF5UGF1c2VkRWxlbWVudHNJZk5vdEJhY2tncm91bmRlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF91bnByb2Nlc3NlZFRyYWNrOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfTWVkaWFTdHJlYW06IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5NZWRpYVN0cmVhbVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzU3RhcnRlZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1N0YXJ0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lZGlhU3RyZWFtVHJhY2s6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5wcm9jZXNzZWRUcmFjayB8fCAodGhpcy5fbWVkaWFUcmFja1RyYW5zY2VpdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX21lZGlhVHJhY2tUcmFuc2NlaXZlci50cmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2Vzc2VkVHJhY2s6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWVkaWFUcmFjay5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ1N0YXJ0ZWQnKTtcbiAgICAgICAgdGhpcy5faXNTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2R1bW15RWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2R1bW15RWwub25jYW5wbGF5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgdGhpcy5lbWl0KCdzdGFydGVkJywgdGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1lZGlhVHJhY2sucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBpZiAoIXRoaXMubWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICAgICAgbG9nLmRlYnVnKCdTa2lwcGluZyBpbml0aWFsaXphdGlvbiBhcyAubWVkaWFTdHJlYW1UcmFjayBpcyBudWxsJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBsb2cuZGVidWcoJ0luaXRpYWxpemluZycpO1xuICAgICAgICB0aGlzLl9kdW1teUVsID0gdGhpcy5fY3JlYXRlRWxlbWVudCgpO1xuICAgICAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBmdW5jdGlvbiBvbmVuZGVkKCkge1xuICAgICAgICAgICAgc2VsZi5fZW5kKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgb25lbmRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fZHVtbXlFbCkge1xuICAgICAgICAgICAgdGhpcy5fZHVtbXlFbC5tdXRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9kdW1teUVsLm9uY2FucGxheSA9IHRoaXMuX3N0YXJ0LmJpbmQodGhpcywgdGhpcy5fZHVtbXlFbCk7XG4gICAgICAgICAgICAvLyBOT1RFKGNzYW50b3MpOiBXZSBhbHdheXMgd2FudCB0byBhdHRhY2ggdGhlIG9yaWdpbmFsIG1lZGlhU3RyZWFtVHJhY2sgZm9yIGR1bW15RWxcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaCh0aGlzLl9kdW1teUVsLCB0aGlzLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1lZGlhVHJhY2sucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIGlmICghdGhpcy5tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoJ1NraXBwaW5nIGVuZGVkIGFzIC5tZWRpYVN0cmVhbVRyYWNrIGlzIG51bGwnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZHVtbXlFbCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdFbmRlZCcpO1xuICAgICAgICAgICAgdGhpcy5fZHVtbXlFbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuX2R1bW15RWwuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2R1bW15RWwub25jYW5wbGF5ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2R1bW15RWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZWRpYVRyYWNrLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVsID0gdGhpcy5fc2VsZWN0RWxlbWVudChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWVsKSB7XG4gICAgICAgICAgICBlbCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0F0dGVtcHRpbmcgdG8gYXR0YWNoIHRvIGVsZW1lbnQ6JywgZWwpO1xuICAgICAgICBlbCA9IHRoaXMuX2F0dGFjaChlbCk7XG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRTaGltQXR0YWNoZWRFbGVtZW50cyAmJiAhdGhpcy5fZWxTaGltcy5oYXMoZWwpKSB7XG4gICAgICAgICAgICB2YXIgb25VbmludGVudGlvbmFsbHlQYXVzZWQgPSB0aGlzLl9wbGF5UGF1c2VkRWxlbWVudHNJZk5vdEJhY2tncm91bmRlZFxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGxheUlmUGF1c2VkQW5kTm90QmFja2dyb3VuZGVkKGVsLCBfdGhpcy5fbG9nKTsgfVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2VsU2hpbXMuc2V0KGVsLCBzaGltTWVkaWFFbGVtZW50KGVsLCBvblVuaW50ZW50aW9uYWxseVBhdXNlZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGUgcHJvdmlkZWQgTWVkaWFTdHJlYW1UcmFjayB0byB0aGUgbWVkaWEgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gZWwgLSBUaGUgbWVkaWEgZWxlbWVudCB0byBhdHRhY2ggdG9cbiAgICAgKiBAcGFyYW0gbWVkaWFTdHJlYW1UcmFjayAtIFRoZSBNZWRpYVN0cmVhbVRyYWNrIHRvIGF0dGFjaC4gSWYgdGhpcyBpc1xuICAgICAqIG5vdCBwcm92aWRlZCwgaXQgdXNlcyB0aGUgLnByb2Nlc3NlZFRyYWNrIGlmIGl0IGV4aXN0cyxcbiAgICAgKiBvciBpdCBkZWZhdWx0cyB0byB0aGUgY3VycmVudCAubWVkaWFTdHJlYW1UcmFja1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWVkaWFUcmFjay5wcm90b3R5cGUuX2F0dGFjaCA9IGZ1bmN0aW9uIChlbCwgbWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICBpZiAobWVkaWFTdHJlYW1UcmFjayA9PT0gdm9pZCAwKSB7IG1lZGlhU3RyZWFtVHJhY2sgPSB0aGlzLnByb2Nlc3NlZFRyYWNrIHx8IHRoaXMubWVkaWFTdHJlYW1UcmFjazsgfVxuICAgICAgICB2YXIgbWVkaWFTdHJlYW0gPSBlbC5zcmNPYmplY3QgfHwgbmV3IHRoaXMuX01lZGlhU3RyZWFtKCk7XG4gICAgICAgIHZhciBnZXRUcmFja3MgPSB0aGlzLmtpbmQgPT09ICdhdWRpbycgPyAnZ2V0QXVkaW9UcmFja3MnIDogJ2dldFZpZGVvVHJhY2tzJztcbiAgICAgICAgbWVkaWFTdHJlYW1bZ2V0VHJhY2tzXSgpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7IHJldHVybiBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7IH0pO1xuICAgICAgICBpZiAobWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICAgICAgbWVkaWFTdHJlYW0uYWRkVHJhY2sobWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IHJlc2V0dGluZyBgc3JjT2JqZWN0YCBoZXJlLCBjYXVzZXMgZmxpY2tlciAoSlNESy0yNjQxKSwgYnV0IGl0IGxldHMgdXNcbiAgICAgICAgLy8gc2lkZXN0ZXAgdGhlIGNocm9tZSBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwNTIzNTNcbiAgICAgICAgZWwuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgICAgIGVsLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgZWwucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICBpZiAoZWwgIT09IHRoaXMuX2R1bW15RWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaG1lbnRzLmFkZChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrLnByb3RvdHlwZS5fc2VsZWN0RWxlbWVudCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0b3IgbWF0Y2hlZCBubyBlbGVtZW50OiBcIiArIHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1lZGlhVHJhY2sucHJvdG90eXBlLl91cGRhdGVFbGVtZW50c01lZGlhU3RyZWFtVHJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygnUmVhdHRhY2hpbmcgYWxsIGVsZW1lbnRzIHRvIHVwZGF0ZSAubWVkaWFTdHJlYW1UcmFjaycpO1xuICAgICAgICB0aGlzLl9nZXRBbGxBdHRhY2hlZEVsZW1lbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIF90aGlzLl9hdHRhY2goZWwpOyB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXdhcm5pbmctY29tbWVudHNcbiAgICAgICAgLy8gVE9ETyhtcGF0d2FyZGhhbik6IHNob3VsZCB3ZSBlbWl0IHRoYXQgbWVkaWFTdHJlYW1UcmFjayB3YXMgdXBkYXRlZD9cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWVkaWFUcmFjay5wcm90b3R5cGUuX2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5raW5kKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH07XG4gICAgTWVkaWFUcmFjay5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBlbHM7XG4gICAgICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbHMgPSBbdGhpcy5fc2VsZWN0RWxlbWVudChlbCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFlbCkge1xuICAgICAgICAgICAgZWxzID0gdGhpcy5fZ2V0QWxsQXR0YWNoZWRFbGVtZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxzID0gW2VsXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0F0dGVtcHRpbmcgdG8gZGV0YWNoIGZyb20gZWxlbWVudHM6JywgZWxzKTtcbiAgICAgICAgdGhpcy5fZGV0YWNoRWxlbWVudHMoZWxzKTtcbiAgICAgICAgcmV0dXJuIGVsID8gZWxzWzBdIDogZWxzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrLnByb3RvdHlwZS5fZGV0YWNoRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLm1hcCh0aGlzLl9kZXRhY2hFbGVtZW50LmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrLnByb3RvdHlwZS5fZGV0YWNoRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoIXRoaXMuX2F0dGFjaG1lbnRzLmhhcyhlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVkaWFTdHJlYW0gPSBlbC5zcmNPYmplY3Q7XG4gICAgICAgIHZhciBtZWRpYVN0cmVhbVRyYWNrID0gdGhpcy5wcm9jZXNzZWRUcmFjayB8fCB0aGlzLm1lZGlhU3RyZWFtVHJhY2s7XG4gICAgICAgIGlmIChtZWRpYVN0cmVhbSAmJiBtZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayhtZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hdHRhY2htZW50cy5kZWxldGUoZWwpO1xuICAgICAgICBpZiAodGhpcy5fc2hvdWxkU2hpbUF0dGFjaGVkRWxlbWVudHMgJiYgdGhpcy5fZWxTaGltcy5oYXMoZWwpKSB7XG4gICAgICAgICAgICB2YXIgc2hpbSA9IHRoaXMuX2VsU2hpbXMuZ2V0KGVsKTtcbiAgICAgICAgICAgIHNoaW0udW5TaGltKCk7XG4gICAgICAgICAgICB0aGlzLl9lbFNoaW1zLmRlbGV0ZShlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrLnByb3RvdHlwZS5fZ2V0QWxsQXR0YWNoZWRFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fYXR0YWNobWVudHMpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lZGlhVHJhY2s7XG59KFRyYWNrKSk7XG4vKipcbiAqIFBsYXkgYW4gSFRNTE1lZGlhRWxlbWVudCBpZiBpdCBpcyBwYXVzZWQgYW5kIG5vdCBiYWNrZ3JvdW5kZWQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBlbFxuICogQHBhcmFtIHtMb2d9IGxvZ1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHBsYXlJZlBhdXNlZEFuZE5vdEJhY2tncm91bmRlZChlbCwgbG9nKSB7XG4gICAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBsb2cud2FybignVW5pbnRlbnRpb25hbGx5IHBhdXNlZDonLCBlbCk7XG4gICAgLy8gTk9URShtbWFsYXZhbGxpKTogV2hlbiB0aGUgZWxlbWVudCBpcyB1bmludGVudGlvbmFsbHkgcGF1c2VkLCB3ZSB3YWl0IG9uZVxuICAgIC8vIHNlY29uZCBmb3IgdGhlIFwib252aXNpYmlsaXR5Y2hhbmdlXCIgZXZlbnQgb24gdGhlIEhUTUxEb2N1bWVudCB0byBzZWUgaWYgdGhlXG4gICAgLy8gYXBwIHdpbGwgYmUgYmFja2dyb3VuZGVkLiBJZiBub3QsIHRoZW4gdGhlIGVsZW1lbnQgY2FuIGJlIHNhZmVseSBwbGF5ZWQuXG4gICAgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgd2FpdEZvckV2ZW50KGRvY3VtZW50LCAndmlzaWJpbGl0eWNoYW5nZScpLFxuICAgICAgICB3YWl0Rm9yU29tZXRpbWUoMTAwMClcbiAgICBdKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBXZSBwbGF5IHRoZSBpbmFkdmVydGVudGx5IHBhdXNlZCBlbGVtZW50cyBvbmx5IGFmdGVyXG4gICAgICAgICAgICAvLyB0aGUgTG9jYWxBdWRpb1RyYWNrIGlzIHVubXV0ZWQgdG8gd29yayBhcm91bmQgV2ViS2l0IEJ1ZyAyMTM4NTMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjEzODUzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgbG9jYWxNZWRpYVJlc3RhcnREZWZlcnJlZHMud2hlblJlc29sdmVkKCdhdWRpbycpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiUGxheWluZyB1bmludGVudGlvbmFsbHkgcGF1c2VkIDxcIiArIHRhZyArIFwiPiBlbGVtZW50XCIpO1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZygnRWxlbWVudDonLCBlbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLnBsYXkoKTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiU3VjY2Vzc2Z1bGx5IHBsYXllZCB1bmludGVudGlvbmFsbHkgcGF1c2VkIDxcIiArIHRhZyArIFwiPiBlbGVtZW50XCIpO1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZygnRWxlbWVudDonLCBlbCk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybihcIkVycm9yIHdoaWxlIHBsYXlpbmcgdW5pbnRlbnRpb25hbGx5IHBhdXNlZCA8XCIgKyB0YWcgKyBcIj4gZWxlbWVudDpcIiwgeyBlcnJvcjogZXJyb3IsIGVsOiBlbCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFNoaW0gdGhlIHBhdXNlKCkgYW5kIHBsYXkoKSBtZXRob2RzIG9mIHRoZSBnaXZlbiBIVE1MTWVkaWFFbGVtZW50IHNvIHRoYXRcbiAqIHdlIGNhbiBkZXRlY3QgaWYgaXQgd2FzIHBhdXNlZCB1bmludGVudGlvbmFsbHkuXG4gKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IGVsXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gW29uVW5pbnRlbnRpb25hbGx5UGF1c2VkPW51bGxdXG4gKiBAcmV0dXJucyB7e3BhdXNlZEludGVudGlvbmFsbHk6IGZ1bmN0aW9uLCB1blNoaW06IGZ1bmN0aW9ufX1cbiAqL1xuZnVuY3Rpb24gc2hpbU1lZGlhRWxlbWVudChlbCwgb25VbmludGVudGlvbmFsbHlQYXVzZWQpIHtcbiAgICBpZiAob25VbmludGVudGlvbmFsbHlQYXVzZWQgPT09IHZvaWQgMCkgeyBvblVuaW50ZW50aW9uYWxseVBhdXNlZCA9IG51bGw7IH1cbiAgICB2YXIgb3JpZ1BhdXNlID0gZWwucGF1c2U7XG4gICAgdmFyIG9yaWdQbGF5ID0gZWwucGxheTtcbiAgICB2YXIgcGF1c2VkSW50ZW50aW9uYWxseSA9IGZhbHNlO1xuICAgIGVsLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwYXVzZWRJbnRlbnRpb25hbGx5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9yaWdQYXVzZS5jYWxsKGVsKTtcbiAgICB9O1xuICAgIGVsLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhdXNlZEludGVudGlvbmFsbHkgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9yaWdQbGF5LmNhbGwoZWwpO1xuICAgIH07XG4gICAgdmFyIG9uUGF1c2UgPSBvblVuaW50ZW50aW9uYWxseVBhdXNlZCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFwYXVzZWRJbnRlbnRpb25hbGx5KSB7XG4gICAgICAgICAgICBvblVuaW50ZW50aW9uYWxseVBhdXNlZCgpO1xuICAgICAgICB9XG4gICAgfSA6IG51bGw7XG4gICAgaWYgKG9uUGF1c2UpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCBvblBhdXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF1c2VkSW50ZW50aW9uYWxseTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdXNlZEludGVudGlvbmFsbHk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuU2hpbTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWwucGF1c2UgPSBvcmlnUGF1c2U7XG4gICAgICAgICAgICBlbC5wbGF5ID0gb3JpZ1BsYXk7XG4gICAgICAgICAgICBpZiAob25QYXVzZSkge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgb25QYXVzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBNZWRpYVRyYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWF0cmFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIE1lZGlhVHJhY2tUcmFuc2NlaXZlciA9IHJlcXVpcmUoJy4vdHJhbnNjZWl2ZXInKTtcbi8qKlxuICogQSB7QGxpbmsgTWVkaWFUcmFja1JlY2VpdmVyfSByZXByZXNlbnRzIGEgcmVtb3RlIE1lZGlhU3RyZWFtVHJhY2suXG4gKiBAZXh0ZW5kcyBNZWRpYVRyYWNrVHJhbnNjZWl2ZXJcbiAqL1xudmFyIE1lZGlhVHJhY2tSZWNlaXZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVkaWFUcmFja1JlY2VpdmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBNZWRpYVRyYWNrUmVjZWl2ZXJ9LlxuICAgICAqIEBwYXJhbSB7VHJhY2suSUR9IGlkIC0gVGhlIE1lZGlhU3RyZWFtVHJhY2sgSUQgc2lnbmFsZWQgdGhyb3VnaCBSU1AvU0RQXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBtaWQgLSBUaGUgTUlEIGFzc29jaWF0ZWQgd2l0aCB0aGUgTWVkaWFTdHJlYW1UcmFja1xuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gbWVkaWFTdHJlYW1UcmFjayAtIFRoZSByZW1vdGUgTWVkaWFTdHJlYW1UcmFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1lZGlhVHJhY2tSZWNlaXZlcihpZCwgbWlkLCBtZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgbWlkLCBtZWRpYVN0cmVhbVRyYWNrKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWVkaWFUcmFja1JlY2VpdmVyO1xufShNZWRpYVRyYWNrVHJhbnNjZWl2ZXIpKTtcbm1vZHVsZS5leHBvcnRzID0gTWVkaWFUcmFja1JlY2VpdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjZWl2ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBBdWRpb1RyYWNrID0gcmVxdWlyZSgnLi9hdWRpb3RyYWNrJyk7XG52YXIgbWl4aW5SZW1vdGVNZWRpYVRyYWNrID0gcmVxdWlyZSgnLi9yZW1vdGVtZWRpYXRyYWNrJyk7XG52YXIgUmVtb3RlTWVkaWFBdWRpb1RyYWNrID0gbWl4aW5SZW1vdGVNZWRpYVRyYWNrKEF1ZGlvVHJhY2spO1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSByZXByZXNlbnRzIGFuIHtAbGluayBBdWRpb1RyYWNrfSBwdWJsaXNoZWQgdG8gYVxuICoge0BsaW5rIFJvb219IGJ5IGEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fS5cbiAqIEBleHRlbmRzIEF1ZGlvVHJhY2tcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNFbmFibGVkIC0gPGNvZGU+RGVwcmVjYXRlZDogVXNlICguc3dpdGNoT2ZmUmVhc29uICE9PSBcImRpc2FibGVkLWJ5LXB1Ymxpc2hlclwiKSBpbnN0ZWFkPC9jb2RlPlxuICogICBXaGV0aGVyIHRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gaXMgZW5hYmxlZCAoRGVwcmVjYXRlZCBvbmx5IGZvciBsYXJnZSBncm91cCBSb29tcylcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTd2l0Y2hlZE9mZiAtIFdoZXRoZXIgdGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSBpcyBzd2l0Y2hlZCBvZmZcbiAqIEBwcm9wZXJ0eSB7P1RyYWNrU3dpdGNoT2ZmUmVhc29ufSBzd2l0Y2hPZmZSZWFzb24gLSBUaGUgcmVhc29uIGZvciB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IGJlaW5nIHN3aXRjaGVkIG9mZjtcbiAqICAgSWYgc3dpdGNoZWQgb24sIGl0IGlzIHNldCB0byA8Y29kZT5udWxsPC9jb2RlPjsgVGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSBpcyBpbml0aWFsbHkgc3dpdGNoZWQgb2ZmIHdpdGggdGhpc1xuICogICBwcm9wZXJ0eSBzZXQgdG8gPGNvZGU+ZGlzYWJsZWQtYnktc3Vic2NyaWJlcjwvY29kZT5cbiAqIEBwcm9wZXJ0eSB7VHJhY2suU0lEfSBzaWQgLSBUaGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9J3MgU0lEXG4gKiBAcHJvcGVydHkgez9UcmFjay5Qcmlvcml0eX0gcHJpb3JpdHkgLSBUaGUgc3Vic2NyaWJlIHByaW9yaXR5IG9mIHRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja31cbiAqIEBlbWl0cyBSZW1vdGVBdWRpb1RyYWNrI2Rpc2FibGVkXG4gKiBAZW1pdHMgUmVtb3RlQXVkaW9UcmFjayNlbmFibGVkXG4gKiBAZW1pdHMgUmVtb3RlQXVkaW9UcmFjayNzdGFydGVkXG4gKiBAZW1pdHMgUmVtb3RlQXVkaW9UcmFjayNzd2l0Y2hlZE9mZlxuICogQGVtaXRzIFJlbW90ZUF1ZGlvVHJhY2sjc3dpdGNoZWRPblxuICovXG52YXIgUmVtb3RlQXVkaW9UcmFjayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVtb3RlQXVkaW9UcmFjaywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30uXG4gICAgICogQHBhcmFtIHtUcmFjay5TSUR9IHNpZCAtIFRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30ncyBTSURcbiAgICAgKiBAcGFyYW0gez9NZWRpYVRyYWNrUmVjZWl2ZXJ9IG1lZGlhVHJhY2tSZWNlaXZlciAtIEFuIGF1ZGlvIE1lZGlhU3RyZWFtVHJhY2sgY29udGFpbmVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0VuYWJsZWQgLSBXaGV0aGVyIHRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gaXMgZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTd2l0Y2hlZE9mZiAtIFdoZXRoZXIgdGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSBpcyBzd2l0Y2hlZCBvZmZcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHN3aXRjaE9mZlJlYXNvbiAtIFRoZSByZWFzb24gdGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSBpcyBzd2l0Y2hlZCBvZmZcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9UcmFjay5Qcmlvcml0eSk6IHZvaWR9IHNldFByaW9yaXR5IC0gU2V0IG9yIGNsZWFyIHRoZSBzdWJzY3JpYmVcbiAgICAgKiAge0BsaW5rIFRyYWNrLlByaW9yaXR5fSBvZiB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihDbGllbnRSZW5kZXJIaW50KTogdm9pZH0gc2V0UmVuZGVySGludCAtIFNldCByZW5kZXIgaGludHMuXG4gICAgICogQHBhcmFtIHt7bG9nOiBMb2csIG5hbWU6IHN0cmluZ319IG9wdGlvbnMgLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrfSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVtb3RlQXVkaW9UcmFjayhzaWQsIG1lZGlhVHJhY2tSZWNlaXZlciwgaXNFbmFibGVkLCBpc1N3aXRjaGVkT2ZmLCBzd2l0Y2hPZmZSZWFzb24sIHNldFByaW9yaXR5LCBzZXRSZW5kZXJIaW50LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAnYXVkaW8nLCBzaWQsIG1lZGlhVHJhY2tSZWNlaXZlciwgaXNFbmFibGVkLCBpc1N3aXRjaGVkT2ZmLCBzd2l0Y2hPZmZSZWFzb24sIHNldFByaW9yaXR5LCBzZXRSZW5kZXJIaW50LCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZW1vdGVBdWRpb1RyYWNrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW1JlbW90ZUF1ZGlvVHJhY2sgI1wiICsgdGhpcy5faW5zdGFuY2VJZCArIFwiOiBcIiArIHRoaXMuc2lkICsgXCJdXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHN1YnNjcmliZSB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IG9mIHRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30uXG4gICAgICogQHBhcmFtIHs/VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5IC0gdGhlIG5ldyBzdWJzY3JpYmUge0BsaW5rIFRyYWNrLlByaW9yaXR5fTtcbiAgICAgKiAgIEN1cnJlbnRseSBzZXRQcmlvcml0eSBoYXMgbm8gZWZmZWN0IG9uIGF1ZGlvIHRyYWNrcy5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICAgICAqL1xuICAgIFJlbW90ZUF1ZGlvVHJhY2sucHJvdG90eXBlLnNldFByaW9yaXR5ID0gZnVuY3Rpb24gKHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnNldFByaW9yaXR5LmNhbGwodGhpcywgcHJpb3JpdHkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbW90ZUF1ZGlvVHJhY2s7XG59KFJlbW90ZU1lZGlhQXVkaW9UcmFjaykpO1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IHdhcyBkaXNhYmxlZCwgaS5lLiBcIm11dGVkXCIgKERlcHJlY2F0ZWQgb25seSBmb3IgbGFyZ2UgZ3JvdXAgUm9vbXMpLlxuICogQGRlcHJlY2F0ZWQgVXNlIDxhIGhyZWY9XCIjZXZlbnQ6c3dpdGNoZWRPZmZcIj48Y29kZT5zd2l0Y2hlZE9mZjwvY29kZT48L2E+ICg8Y29kZT4uc3dpdGNoT2ZmUmVhc29uID09PSBcImRpc2FibGVkLWJ5LXB1Ymxpc2hlclwiPC9jb2RlPikgaW5zdGVhZFxuICogQHBhcmFtIHtSZW1vdGVBdWRpb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gdGhhdCB3YXNcbiAqICAgZGlzYWJsZWRcbiAqIEBldmVudCBSZW1vdGVBdWRpb1RyYWNrI2Rpc2FibGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSB3YXMgZW5hYmxlZCwgaS5lLiBcInVubXV0ZWRcIiAoRGVwcmVjYXRlZCBvbmx5IGZvciBsYXJnZSBncm91cCBSb29tcykuXG4gKiBAZGVwcmVjYXRlZCBVc2UgPGEgaHJlZj1cIiNldmVudDpzd2l0Y2hlZE9uXCI+PGNvZGU+c3dpdGNoZWRPbjwvY29kZT48L2E+IGluc3RlYWRcbiAqIEBwYXJhbSB7UmVtb3RlQXVkaW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IHRoYXQgd2FzXG4gKiAgIGVuYWJsZWRcbiAqIEBldmVudCBSZW1vdGVBdWRpb1RyYWNrI2VuYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IHN0YXJ0ZWQuIFRoaXMgbWVhbnMgdGhlcmUgaXMgZW5vdWdoIGF1ZGlvIGRhdGFcbiAqIHRvIGJlZ2luIHBsYXliYWNrLlxuICogQHBhcmFtIHtSZW1vdGVBdWRpb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gdGhhdCBzdGFydGVkXG4gKiBAZXZlbnQgUmVtb3RlQXVkaW9UcmFjayNzdGFydGVkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gd2FzIHN3aXRjaGVkIG9mZi4gVGhlIG1lZGlhIHNlcnZlciBzdG9wcyBzZW5kaW5nIG1lZGlhIGZvciB0aGVcbiAqIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSB1bnRpbCBpdCBpcyBzd2l0Y2hlZCBiYWNrIG9uLiBKdXN0IGJlZm9yZSB0aGUgZXZlbnQgaXMgcmFpc2VkLFxuICogPGNvZGU+aXNTd2l0Y2hlZE9mZjwvY29kZT4gaXMgc2V0IHRvIDxjb2RlPnRydWU8L2NvZGU+IGFuZCA8Y29kZT5zd2l0Y2hPZmZSZWFzb248L2NvZGU+IGlzXG4gKiBzZXQgdG8gYSB7QGxpbmsgVHJhY2tTd2l0Y2hPZmZSZWFzb259IGluIGxhcmdlIGdyb3VwIFJvb21zICg8Y29kZT5zd2l0Y2hPZmZSZWFzb248L2NvZGU+IGlzXG4gKiA8Y29kZT5udWxsPC9jb2RlPiBub24tbGFyZ2UgZ3JvdXAgUm9vbXMpLiBBbHNvLCB0aGUgPGNvZGU+bWVkaWFTdHJlYW1UcmFjazwvY29kZT4gcHJvcGVydHlcbiAqIGlzIHNldCB0byA8Y29kZT5udWxsPC9jb2RlPiAob25seSBpbiBsYXJnZSBncm91cCBSb29tcykuXG4gKiBAcGFyYW0ge1JlbW90ZUF1ZGlvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSB0aGF0IHdhc1xuICogICBzd2l0Y2hlZCBvZmZcbiAqIEBwYXJhbSB7P1RyYWNrU3dpdGNoT2ZmUmVhc29ufSBzd2l0Y2hPZmZSZWFzb24gLSBUaGUgcmVhc29uIHRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja31cbiAqICAgd2FzIHN3aXRjaGVkIG9mZlxuICogQGV2ZW50IFJlbW90ZUF1ZGlvVHJhY2sjc3dpdGNoZWRPZmZcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSB3YXMgc3dpdGNoZWQgb24uIFRoZSBtZWRpYSBzZXJ2ZXIgc3RhcnRzIHNlbmRpbmcgbWVkaWEgZm9yIHRoZVxuICoge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IHVudGlsIGl0IGlzIHN3aXRjaGVkIG9mZi4gSnVzdCBiZWZvcmUgdGhlIGV2ZW50IGlzIHJhaXNlZCxcbiAqIDxjb2RlPmlzU3dpdGNoZWRPZmY8L2NvZGU+IGlzIHNldCB0byA8Y29kZT5mYWxzZTwvY29kZT4gYW5kIDxjb2RlPnN3aXRjaE9mZlJlYXNvbjwvY29kZT5cbiAqIGlzIHNldCB0byA8Y29kZT5udWxsPC9jb2RlPi4gQWxzbywgdGhlIDxjb2RlPm1lZGlhU3RyZWFtVHJhY2s8L2NvZGU+IHByb3BlcnR5IGlzIHNldCB0byBhXG4gKiBNZWRpYVN0cmVhbVRyYWNrIHRoYXQgaXMgdGhlIHNvdXJjZSBvZiB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9J3MgbWVkaWEuXG4gKiBAcGFyYW0ge1JlbW90ZUF1ZGlvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSB0aGF0IHdhc1xuICogICBzd2l0Y2hlZCBvblxuICogQGV2ZW50IFJlbW90ZUF1ZGlvVHJhY2sjc3dpdGNoZWRPblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW90ZUF1ZGlvVHJhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdGVhdWRpb3RyYWNrLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiA9IHJlcXVpcmUoJy4vcmVtb3RldHJhY2twdWJsaWNhdGlvbicpO1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb259IHJlcHJlc2VudHMgYSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja31cbiAqIHRoYXQgaGFzIGJlZW4gcHVibGlzaGVkIHRvIGEge0BsaW5rIFJvb219LlxuICogQHByb3BlcnR5IHtUcmFjay5LaW5kfSBraW5kIC0gXCJhdWRpb1wiXG4gKiBAcHJvcGVydHkgez9SZW1vdGVBdWRpb1RyYWNrfSB0cmFjayAtIHVubGVzcyB5b3UgaGF2ZSBzdWJzY3JpYmVkIHRvIHRoZVxuICogICB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30sIHRoaXMgcHJvcGVydHkgaXMgbnVsbFxuICogQGVtaXRzIFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbiNzdWJzY3JpYmVkXG4gKiBAZW1pdHMgUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uI3N1YnNjcmlwdGlvbkZhaWxlZFxuICogQGVtaXRzIFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbiN0cmFja0Rpc2FibGVkXG4gKiBAZW1pdHMgUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uI3RyYWNrRW5hYmxlZFxuICogQGVtaXRzIFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbiN1bnN1YnNjcmliZWRcbiAqL1xudmFyIFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb259LlxuICAgICAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ30gc2lnbmFsaW5nIC0ge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259IHNpZ25hbGluZ1xuICAgICAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn1cbiAgICAgKiAgIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24oc2lnbmFsaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzaWduYWxpbmcsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24gI1wiICsgdGhpcy5faW5zdGFuY2VJZCArIFwiOiBcIiArIHRoaXMudHJhY2tTaWQgKyBcIl1cIjtcbiAgICB9O1xuICAgIHJldHVybiBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb247XG59KFJlbW90ZVRyYWNrUHVibGljYXRpb24pKTtcbi8qKlxuICogWW91ciB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gc3Vic2NyaWJlZCB0byB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9LlxuICogQHBhcmFtIHtSZW1vdGVBdWRpb1RyYWNrfSB0cmFjayAtIHRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gdGhhdCB3YXMgc3Vic2NyaWJlZCB0b1xuICogQGV2ZW50IFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbiNzdWJzY3JpYmVkXG4gKi9cbi8qKlxuICogWW91ciB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gZmFpbGVkIHRvIHN1YnNjcmliZSB0byB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9LlxuICogQHBhcmFtIHtUd2lsaW9FcnJvcn0gZXJyb3IgLSB0aGUgcmVhc29uIHRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gY291bGQgbm90IGJlXG4gKiAgIHN1YnNjcmliZWQgdG9cbiAqIEBldmVudCBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24jc3Vic2NyaXB0aW9uRmFpbGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSB3YXMgZGlzYWJsZWQuIEl0IGlzIGZpcmVkIG9ubHkgaWYgPGNvZGU+LmlzU3Vic2NyaWJlZDwvY29kZT5cbiAqIGlzIHNldCB0byA8Y29kZT50cnVlPC9jb2RlPiAoRGVwcmVjYXRlZCBvbmx5IGZvciBsYXJnZSBncm91cCBSb29tcykuXG4gKiBAZGVwcmVjYXRlZCBVc2UgPGEgaHJlZj1cImV2ZW50OnRyYWNrU3dpdGNoZWRPZmZcIj48Y29kZT50cmFja1N3aXRjaGVkT2ZmPC9jb2RlPjwvYT4gKDxjb2RlPnRyYWNrLnN3aXRjaE9mZlJlYXNvbiA9PT0gXCJkaXNhYmxlZC1ieS1wdWJsaXNoZXJcIjwvY29kZT4pIGluc3RlYWRcbiAqIEBldmVudCBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24jdHJhY2tEaXNhYmxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gd2FzIGVuYWJsZWQuIEl0IGlzIGZpcmVkIG9ubHkgaWYgPGNvZGU+LmlzU3Vic2NyaWJlZDwvY29kZT5cbiAqIGlzIHNldCB0byA8Y29kZT50cnVlPC9jb2RlPiAoRGVwcmVjYXRlZCBvbmx5IGZvciBsYXJnZSBncm91cCBSb29tcykuXG4gKiBAZGVwcmVjYXRlZCBVc2UgPGEgaHJlZj1cImV2ZW50OnRyYWNrU3dpdGNoZWRPblwiPjxjb2RlPnRyYWNrU3dpdGNoZWRPbjwvY29kZT48L2E+IGluc3RlYWRcbiAqIEBldmVudCBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24jdHJhY2tFbmFibGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSB3YXMgc3dpdGNoZWQgb2ZmLiBUaGUgbWVkaWEgc2VydmVyIHN0b3BzIHNlbmRpbmcgbWVkaWEgZm9yXG4gKiB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IHVudGlsIGl0IGlzIHN3aXRjaGVkIGJhY2sgb24uIEp1c3QgYmVmb3JlIHRoZSBldmVudCBpcyByYWlzZWQsXG4gKiA8Y29kZT5pc1N3aXRjaGVkT2ZmPC9jb2RlPiBpcyBzZXQgdG8gPGNvZGU+dHJ1ZTwvY29kZT4gYW5kIDxjb2RlPnN3aXRjaE9mZlJlYXNvbjwvY29kZT5cbiAqIGlzIHNldCB0byBhIHtAbGluayBUcmFja1N3aXRjaE9mZlJlYXNvbn0gaW4gbGFyZ2UgZ3JvdXAgUm9vbXMgKDxjb2RlPnN3aXRjaE9mZlJlYXNvbjwvY29kZT4gaXNcbiAqIDxjb2RlPm51bGw8L2NvZGU+IG5vbi1sYXJnZSBncm91cCBSb29tcykuIEFsc28sIGlmIHRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gcmVjZWl2ZXMgYXVkaW9cbiAqIG1lZGlhLCB0aGUgPGNvZGU+bWVkaWFTdHJlYW1UcmFjazwvY29kZT4gcHJvcGVydHkgaXMgc2V0IHRvIDxjb2RlPm51bGw8L2NvZGU+LiAob25seSBpbiBsYXJnZVxuICogZ3JvdXAgUm9vbXMpXG4gKiBAcGFyYW0ge1JlbW90ZUF1ZGlvVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSB0aGF0IHdhcyBzd2l0Y2hlZCBvZmZcbiAqIEBwYXJhbSB7P1RyYWNrU3dpdGNoT2ZmUmVhc29ufSBzd2l0Y2hPZmZSZWFzb24gLSB0aGUgcmVhc29uIHRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja31cbiAqICAgd2FzIHN3aXRjaGVkIG9mZlxuICogQGV2ZW50IFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbiN0cmFja1N3aXRjaGVkT2ZmXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSB3YXMgc3dpdGNoZWQgb24uIFRoZSBtZWRpYSBzZXJ2ZXIgc3RhcnRzIHNlbmRpbmcgbWVkaWEgZm9yXG4gKiB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IHVudGlsIGl0IGlzIHN3aXRjaGVkIG9mZi4gSnVzdCBiZWZvcmUgdGhlIGV2ZW50IGlzIHJhaXNlZCxcbiAqIDxjb2RlPmlzU3dpdGNoZWRPZmY8L2NvZGU+IGlzIHNldCB0byA8Y29kZT5mYWxzZTwvY29kZT4gYW5kIDxjb2RlPnN3aXRjaE9mZlJlYXNvbjwvY29kZT5cbiAqIGlzIHNldCB0byA8Y29kZT5udWxsPC9jb2RlPi4gQWxzbywgdGhlIDxjb2RlPm1lZGlhU3RyZWFtVHJhY2s8L2NvZGU+IHByb3BlcnR5IGlzIHNldCB0byBhXG4gKiBNZWRpYVN0cmVhbVRyYWNrIHRoYXQgaXMgdGhlIHNvdXJjZSBvZiB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9J3MgbWVkaWEuXG4gKiBAcGFyYW0ge1JlbW90ZUF1ZGlvVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSB0aGF0IHdhcyBzd2l0Y2hlZCBvblxuICogQGV2ZW50IFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbiN0cmFja1N3aXRjaGVkT25cbiAqL1xuLyoqXG4gKiBZb3VyIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSB1bnN1YnNjcmliZWQgZnJvbSB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9LlxuICogQHBhcmFtIHtSZW1vdGVBdWRpb1RyYWNrfSB0cmFjayAtIHRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gdGhhdCB3YXMgdW5zdWJzY3JpYmVkIGZyb21cbiAqIEBldmVudCBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24jdW5zdWJzY3JpYmVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RlYXVkaW90cmFja3B1YmxpY2F0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICByZXR1cm4gdG87XG59O1xudmFyIFRyYWNrID0gcmVxdWlyZSgnLi8nKTtcbnZhciBfYSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uc3RhbnRzJyksIEUgPSBfYS50eXBlRXJyb3JzLCB0cmFja1ByaW9yaXR5ID0gX2EudHJhY2tQcmlvcml0eTtcbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfSByZXByZXNlbnRzIGRhdGEgcHVibGlzaGVkIHRvIGEge0BsaW5rIFJvb219IGJ5IGFcbiAqIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0uXG4gKiBAZXh0ZW5kcyBUcmFja1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc0VuYWJsZWQgLSB0cnVlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU3Vic2NyaWJlZCAtIFdoZXRoZXIgdGhlIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9IGlzXG4gKiAgIHN1YnNjcmliZWQgdG9cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTd2l0Y2hlZE9mZiAtIFdoZXRoZXIgdGhlIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9IGlzXG4gKiAgIHN3aXRjaGVkIG9mZlxuICogQHByb3BlcnR5IHtUcmFjay5LaW5kfSBraW5kIC0gXCJkYXRhXCJcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gbWF4UGFja2V0TGlmZVRpbWUgLSBJZiBub24tbnVsbCwgdGhpcyByZXByZXNlbnRzIGEgdGltZVxuICogICBsaW1pdCAoaW4gbWlsbGlzZWNvbmRzKSBkdXJpbmcgd2hpY2ggZGF0YSB3aWxsIGJlIHRyYW5zbWl0dGVkIG9yXG4gKiAgIHJldHJhbnNtaXR0ZWQgaWYgbm90IGFja25vd2xlZGdlZCBvbiB0aGUgdW5kZXJseWluZyBSVENEYXRhQ2hhbm5lbC5cbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gbWF4UmV0cmFuc21pdHMgLSBJZiBub24tbnVsbCwgdGhpcyByZXByZXNlbnRzIHRoZSBudW1iZXJcbiAqICAgb2YgdGltZXMgdGhlIGRhdGEgd2lsbCBiZSByZXRyYW5zbWl0dGVkIGlmIG5vdCBzdWNjZXNzZnVsbHkgcmVjZWl2ZWQgb24gdGhlXG4gKiAgIHVuZGVybHlpbmcgUlRDRGF0YUNoYW5uZWwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9yZGVyZWQgLSB0cnVlIGlmIGRhdGEgb24gdGhlIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9IGNhblxuICogICBiZSByZWNlaXZlZCBvdXQtb2Ytb3JkZXIuXG4gKiBAcHJvcGVydHkgez9UcmFjay5Qcmlvcml0eX0gcHJpb3JpdHkgLSBUaGUgc3Vic2NyaWJlIHByaW9yaXR5IG9mIHRoZSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfVxuICogQHByb3BlcnR5IHtib29sZWFufSByZWxpYWJsZSAtIFRoaXMgaXMgdHJ1ZSBpZiBib3RoXG4gKiAgIDxjb2RlPm1heFBhY2tldExpZmVUaW1lPC9jb2RlPiBhbmQgPGNvZGU+bWF4UmV0cmFuc21pdHM8L2NvZGU+IGFyZSBzZXQgdG9cbiAqICAgbnVsbC4gSW4gb3RoZXIgd29yZHMsIGlmIHRoaXMgaXMgdHJ1ZSwgdGhlcmUgaXMgbm8gYm91bmQgb24gcGFja2V0IGxpZmV0aW1lXG4gKiAgIG9yIHRoZSBudW1iZXIgb2YgcmV0cmFuc21pdHMgdGhhdCB3aWxsIGJlIGF0dGVtcHRlZCwgZW5zdXJpbmcgXCJyZWxpYWJsZVwiXG4gKiAgIHRyYW5zbWlzc2lvbi5cbiAqIEBwcm9wZXJ0eSB7VHJhY2suU0lEfSBzaWQgLSBUaGUgU0lEIGFzc2lnbmVkIHRvIHRoZSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfVxuICogQGVtaXRzIFJlbW90ZURhdGFUcmFjayNtZXNzYWdlXG4gKiBAZW1pdHMgUmVtb3RlRGF0YVRyYWNrI3N3aXRjaGVkT2ZmXG4gKiBAZW1pdHMgUmVtb3RlRGF0YVRyYWNrI3N3aXRjaGVkT25cbiAqL1xudmFyIFJlbW90ZURhdGFUcmFjayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVtb3RlRGF0YVRyYWNrLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9IGZyb20gYSB7QGxpbmsgRGF0YVRyYWNrUmVjZWl2ZXJ9LlxuICAgICAqIEBwYXJhbSB7VHJhY2suU0lEfSBzaWRcbiAgICAgKiBAcGFyYW0ge0RhdGFUcmFja1JlY2VpdmVyfSBkYXRhVHJhY2tSZWNlaXZlclxuICAgICAqIEBwYXJhbSB7e2xvZzogTG9nLCBuYW1lOiA/c3RyaW5nfX0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbW90ZURhdGFUcmFjayhzaWQsIGRhdGFUcmFja1JlY2VpdmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICdkYXRhJywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9pc1N3aXRjaGVkT2ZmOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ByaW9yaXR5OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0VuYWJsZWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNTd2l0Y2hlZE9mZjoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1N3aXRjaGVkT2ZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFUcmFja1JlY2VpdmVyLm1heFBhY2tldExpZmVUaW1lXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhVHJhY2tSZWNlaXZlci5tYXhSZXRyYW5zbWl0c1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9yZGVyZWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhVHJhY2tSZWNlaXZlci5vcmRlcmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJpb3JpdHk6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbGlhYmxlOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YVRyYWNrUmVjZWl2ZXIubWF4UGFja2V0TGlmZVRpbWUgPT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgJiYgZGF0YVRyYWNrUmVjZWl2ZXIubWF4UmV0cmFuc21pdHMgPT09IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGFUcmFja1JlY2VpdmVyLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCBfdGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc3Vic2NyaWJlciB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IG9mIHRoZSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfS5cbiAgICAgKiBAcGFyYW0gez9UcmFjay5Qcmlvcml0eX0gcHJpb3JpdHkgLSB0aGUgbmV3IHtAbGluayBUcmFjay5wcmlvcml0eX07XG4gICAgICogICBDdXJyZW50bHkgc2V0UHJpb3JpdHkgaGFzIG5vIGVmZmVjdCBvbiBkYXRhIHRyYWNrcy5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICAgICAqL1xuICAgIFJlbW90ZURhdGFUcmFjay5wcm90b3R5cGUuc2V0UHJpb3JpdHkgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcbiAgICAgICAgdmFyIHByaW9yaXR5VmFsdWVzID0gX19zcHJlYWRBcnJheShbbnVsbF0sIF9fcmVhZChPYmplY3QudmFsdWVzKHRyYWNrUHJpb3JpdHkpKSk7XG4gICAgICAgIGlmICghcHJpb3JpdHlWYWx1ZXMuaW5jbHVkZXMocHJpb3JpdHkpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgICAgICAgICAgdGhyb3cgRS5JTlZBTElEX1ZBTFVFKCdwcmlvcml0eScsIHByaW9yaXR5VmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBwcmlvcml0eSBoYXMgbm8gcmVhbCBlZmZlY3Qgb24gdGhlIGRhdGEgdHJhY2tzLlxuICAgICAgICB0aGlzLl9wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVtb3RlRGF0YVRyYWNrLnByb3RvdHlwZS5fc2V0RW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1N3aXRjaGVkT2ZmXG4gICAgICovXG4gICAgUmVtb3RlRGF0YVRyYWNrLnByb3RvdHlwZS5fc2V0U3dpdGNoZWRPZmYgPSBmdW5jdGlvbiAoaXNTd2l0Y2hlZE9mZikge1xuICAgICAgICBpZiAodGhpcy5faXNTd2l0Y2hlZE9mZiAhPT0gaXNTd2l0Y2hlZE9mZikge1xuICAgICAgICAgICAgdGhpcy5faXNTd2l0Y2hlZE9mZiA9IGlzU3dpdGNoZWRPZmY7XG4gICAgICAgICAgICB0aGlzLmVtaXQoaXNTd2l0Y2hlZE9mZiA/ICdzd2l0Y2hlZE9mZicgOiAnc3dpdGNoZWRPbicsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVtb3RlRGF0YVRyYWNrO1xufShUcmFjaykpO1xuLyoqXG4gKiBBIG1lc3NhZ2Ugd2FzIHJlY2VpdmVkIG92ZXIgdGhlIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9LlxuICogQGV2ZW50IFJlbW90ZURhdGFUcmFjayNtZXNzYWdlXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheUJ1ZmZlcn0gZGF0YVxuICogQHBhcmFtIHtSZW1vdGVEYXRhVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9IHRoYXQgcmVjZWl2ZWRcbiAqICAgdGhlIG1lc3NhZ2VcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9IHdhcyBzd2l0Y2hlZCBvZmYuXG4gKiBAcGFyYW0ge1JlbW90ZURhdGFUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZURhdGFUcmFja30gdGhhdCB3YXNcbiAqICAgc3dpdGNoZWQgb2ZmXG4gKiBAZXZlbnQgUmVtb3RlRGF0YVRyYWNrI3N3aXRjaGVkT2ZmXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfSB3YXMgc3dpdGNoZWQgb24uXG4gKiBAcGFyYW0ge1JlbW90ZURhdGFUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZURhdGFUcmFja30gdGhhdCB3YXNcbiAqICAgc3dpdGNoZWQgb25cbiAqIEBldmVudCBSZW1vdGVEYXRhVHJhY2sjc3dpdGNoZWRPblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW90ZURhdGFUcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW90ZWRhdGF0cmFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFJlbW90ZVRyYWNrUHVibGljYXRpb24gPSByZXF1aXJlKCcuL3JlbW90ZXRyYWNrcHVibGljYXRpb24nKTtcbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb259IHJlcHJlc2VudHMgYSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfVxuICogdGhhdCBoYXMgYmVlbiBwdWJsaXNoZWQgdG8gYSB7QGxpbmsgUm9vbX0uXG4gKiBAcHJvcGVydHkge1RyYWNrLktpbmR9IGtpbmQgLSBcImRhdGFcIlxuICogQHByb3BlcnR5IHs/UmVtb3RlRGF0YVRyYWNrfSB0cmFjayAtIHVubGVzcyB5b3UgaGF2ZSBzdWJzY3JpYmVkIHRvIHRoZVxuICogICB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfSwgdGhpcyBwcm9wZXJ0eSBpcyBudWxsXG4gKiBAZW1pdHMgUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb24jc3Vic2NyaWJlZFxuICogQGVtaXRzIFJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uI3N1YnNjcmlwdGlvbkZhaWxlZFxuICogQGVtaXRzIFJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uI3Vuc3Vic2NyaWJlZFxuICovXG52YXIgUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbn0uXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfSBzaWduYWxpbmcgLSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gc2lnbmFsaW5nXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9uT3B0aW9uc30gb3B0aW9ucyAtIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICAgICAqICAgb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uKHNpZ25hbGluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc2lnbmFsaW5nLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbiAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgdGhpcy50cmFja1NpZCArIFwiXVwiO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uO1xufShSZW1vdGVUcmFja1B1YmxpY2F0aW9uKSk7XG4vKipcbiAqIFlvdXIge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IHN1YnNjcmliZWQgdG8gdGhlIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9LlxuICogQHBhcmFtIHtSZW1vdGVEYXRhVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9IHRoYXQgd2FzIHN1YnNjcmliZWQgdG9cbiAqIEBldmVudCBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbiNzdWJzY3JpYmVkXG4gKi9cbi8qKlxuICogWW91ciB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gZmFpbGVkIHRvIHN1YnNjcmliZSB0byB0aGUge0BsaW5rIFJlbW90ZURhdGFUcmFja30uXG4gKiBAcGFyYW0ge1R3aWxpb0Vycm9yfSBlcnJvciAtIHRoZSByZWFzb24gdGhlIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9IGNvdWxkIG5vdCBiZVxuICogICBzdWJzY3JpYmVkIHRvXG4gKiBAZXZlbnQgUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb24jc3Vic2NyaXB0aW9uRmFpbGVkXG4gKi9cbi8qKlxuICogWW91ciB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gdW5zdWJzY3JpYmVkIGZyb20gdGhlIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9LlxuICogQHBhcmFtIHtSZW1vdGVEYXRhVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9IHRoYXQgd2FzIHVuc3Vic2NyaWJlZCBmcm9tXG4gKiBAZXZlbnQgUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb24jdW5zdWJzY3JpYmVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdGVkYXRhdHJhY2twdWJsaWNhdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgICAgICB0b1tqXSA9IGZyb21baV07XG4gICAgcmV0dXJuIHRvO1xufTtcbnZhciBkZXByZWNhdGVFdmVudHMgPSByZXF1aXJlKCcuLi8uLi91dGlsJykuZGVwcmVjYXRlRXZlbnRzO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25zdGFudHMnKSwgRSA9IF9hLnR5cGVFcnJvcnMsIHRyYWNrUHJpb3JpdHkgPSBfYS50cmFja1ByaW9yaXR5LCB0cmFja1N3aXRjaE9mZlJlYXNvbiA9IF9hLnRyYWNrU3dpdGNoT2ZmUmVhc29uO1xudmFyIF9iID0gcmVxdWlyZSgnLi4vLi4vd2VicnRjL3V0aWwnKSwgZ3Vlc3NCcm93c2VyID0gX2IuZ3Vlc3NCcm93c2VyLCBpc0lPU0Nocm9tZSA9IF9iLmlzSU9TQ2hyb21lO1xudmFyIGRvY3VtZW50VmlzaWJpbGl0eU1vbml0b3IgPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvY3VtZW50dmlzaWJpbGl0eW1vbml0b3IuanMnKTtcbmZ1bmN0aW9uIG1peGluUmVtb3RlTWVkaWFUcmFjayhBdWRpb09yVmlkZW9UcmFjaykge1xuICAgIC8qKlxuICAgICAqIEEge0BsaW5rIFJlbW90ZU1lZGlhVHJhY2t9IHJlcHJlc2VudHMgYSB7QGxpbmsgTWVkaWFUcmFja30gcHVibGlzaGVkIHRvIGFcbiAgICAgKiB7QGxpbmsgUm9vbX0gYnkgYSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9LlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNFbmFibGVkIC0gPGNvZGU+RGVwcmVjYXRlZDogVXNlICguc3dpdGNoT2ZmUmVhc29uICE9PSBcImRpc2FibGVkLWJ5LXB1Ymxpc2hlclwiKSBpbnN0ZWFkLjwvY29kZT5cbiAgICAgKiAgIFdoZXRoZXIgdGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSBpcyBlbmFibGVkIChEZXByZWNhdGVkIG9ubHkgZm9yIGxhcmdlIGdyb3VwIFJvb21zKVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTd2l0Y2hlZE9mZiAtIFdoZXRoZXIgdGhlIHtAbGluayBSZW1vdGVNZWRpYVRyYWNrfSBpcyBzd2l0Y2hlZCBvZmZcbiAgICAgKiBAcHJvcGVydHkgez9UcmFja1N3aXRjaE9mZlJlYXNvbn0gc3dpdGNoT2ZmUmVhc29uIC0gVGhlIHJlYXNvbiBmb3IgdGhlIHtAbGluayBSZW1vdGVNZWRpYVRyYWNrfSBiZWluZyBzd2l0Y2hlZCBvZmY7XG4gICAgICogICBJZiBzd2l0Y2hlZCBvbiwgaXQgaXMgc2V0IHRvIDxjb2RlPm51bGw8L2NvZGU+OyBUaGUge0BsaW5rIFJlbW90ZU1lZGlhVHJhY2t9IGlzIGluaXRpYWxseSBzd2l0Y2hlZCBvZmYgd2l0aCB0aGlzXG4gICAgICogICBwcm9wZXJ0eSBzZXQgdG8gPGNvZGU+ZGlzYWJsZWQtYnktc3Vic2NyaWJlcjwvY29kZT5cbiAgICAgKiBAcHJvcGVydHkge1RyYWNrLlNJRH0gc2lkIC0gVGhlIFNJRCBhc3NpZ25lZCB0byB0aGUge0BsaW5rIFJlbW90ZU1lZGlhVHJhY2t9XG4gICAgICogQHByb3BlcnR5IHs/VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5IC0gVGhlIHN1YnNjcmliZSBwcmlvcml0eSBvZiB0aGUge0BsaW5rIFJlbW90ZU1lZGlhVHJhY2t9XG4gICAgICogQGVtaXRzIFJlbW90ZU1lZGlhVHJhY2sjZGlzYWJsZWRcbiAgICAgKiBAZW1pdHMgUmVtb3RlTWVkaWFUcmFjayNlbmFibGVkXG4gICAgICogQGVtaXRzIFJlbW90ZU1lZGlhVHJhY2sjc3dpdGNoZWRPZmZcbiAgICAgKiBAZW1pdHMgUmVtb3RlTWVkaWFUcmFjayNzd2l0Y2hlZE9uXG4gICAgICovXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFJlbW90ZU1lZGlhVHJhY2ssIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30uXG4gICAgICAgICAqIEBwYXJhbSB7VHJhY2suS2luZH0ga2luZFxuICAgICAgICAgKiBAcGFyYW0ge1RyYWNrLlNJRH0gc2lkXG4gICAgICAgICAqIEBwYXJhbSB7P01lZGlhVHJhY2tSZWNlaXZlcn0gbWVkaWFUcmFja1JlY2VpdmVyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbmFibGVkXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTd2l0Y2hlZE9mZlxuICAgICAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHN3aXRjaE9mZlJlYXNvblxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9UcmFjay5Qcmlvcml0eSk6IHZvaWR9IHNldFByaW9yaXR5IC0gU2V0IG9yIGNsZWFyIHRoZSBzdWJzY3JpYmVcbiAgICAgICAgICogIHtAbGluayBUcmFjay5Qcmlvcml0eX0gb2YgdGhlIHtAbGluayBSZW1vdGVNZWRpYVRyYWNrfVxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKENsaWVudFJlbmRlckhpbnQpOiB2b2lkfSBzZXRSZW5kZXJIaW50IC0gU2V0IHJlbmRlciBoaW50cy5cbiAgICAgICAgICogQHBhcmFtIHt7bG9nOiBMb2csIG5hbWU6IHN0cmluZ319IG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJlbW90ZU1lZGlhVHJhY2soa2luZCwgc2lkLCBtZWRpYVRyYWNrUmVjZWl2ZXIsIGlzRW5hYmxlZCwgaXNTd2l0Y2hlZE9mZiwgc3dpdGNoT2ZmUmVhc29uLCBzZXRQcmlvcml0eSwgc2V0UmVuZGVySGludCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBzaG91bGREZXByZWNhdGVFbmFibGVkU3RhdGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBXZWJLaXQgYnVnOiAyMTI3ODAgc29tZXRpbWVzIGNhdXNlcyB0aGUgYXVkaW8vdmlkZW8gZWxlbWVudHMgdG8gc3RheSBwYXVzZWQgd2hlbiBzYWZhcmlcbiAgICAgICAgICAgICAgICAvLyByZWdhaW5zIGZvcmVncm91bmQuIFRvIHdvcmthcm91bmQgaXQsIHdoZW4gc2FmYXJpIGdhaW5zIGZvcmVncm91bmQgLSB3ZSB3aWxsIHBsYXkgYW55IGVsZW1lbnRzIHRoYXQgd2VyZVxuICAgICAgICAgICAgICAgIC8vIHBsYXlpbmcgYmVmb3JlIHNhZmFyaSBsb3N0IGZvcmVncm91bmQuXG4gICAgICAgICAgICAgICAgd29ya2Fyb3VuZFdlYktpdEJ1ZzIxMjc4MDogKGd1ZXNzQnJvd3NlcigpID09PSAnc2FmYXJpJyB8fCBpc0lPU0Nocm9tZSgpKVxuICAgICAgICAgICAgICAgICAgICAmJiB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgICYmIHR5cGVvZiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICYmIHR5cGVvZiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhciBzaG91bGREZXByZWNhdGVFbmFibGVkU3RhdGUgPSBvcHRpb25zLnNob3VsZERlcHJlY2F0ZUVuYWJsZWRTdGF0ZTtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVkaWFUcmFja1JlY2VpdmVyLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgICAgICBfaXNFbmFibGVkOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpc0VuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfaXNTd2l0Y2hlZE9mZjoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXNTd2l0Y2hlZE9mZixcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9wcmlvcml0eToge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9zZXRQcmlvcml0eToge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2V0UHJpb3JpdHlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9zZXRSZW5kZXJIaW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocmVuZGVySGludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZygndXBkYXRpbmcgcmVuZGVyIGhpbnQ6JywgcmVuZGVySGludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZW5kZXJIaW50KHJlbmRlckhpbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfc3dpdGNoT2ZmUmVhc29uOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzd2l0Y2hPZmZSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfd29ya2Fyb3VuZFdlYktpdEJ1ZzIxMjc4MDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy53b3JrYXJvdW5kV2ViS2l0QnVnMjEyNzgwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfd29ya2Fyb3VuZFdlYktpdEJ1ZzIxMjc4MENsZWFudXA6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0VuYWJsZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRGVwcmVjYXRlRW5hYmxlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlcHJlY2F0ZWQoJy5pc0VuYWJsZWQgaXMgZGVwcmVjYXRlZCBhbmQgc2NoZWR1bGVkIGZvciByZW1vdmFsLiAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJ1RoZSBSZW1vdGVNZWRpYVRyYWNrIGlzIGNhbiBiZSBjb25zaWRlcmVkIGRpc2FibGVkIGlmIC5zd2l0Y2hPZmZSZWFzb24gJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICdpcyBzZXQgdG8gXCJkaXNhYmxlZC1ieS1wdWJsaXNoZXJcIi4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzU3dpdGNoZWRPZmY6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNTd2l0Y2hlZE9mZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpZDoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2lkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzd2l0Y2hPZmZSZWFzb246IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2tTd2l0Y2hPZmZSZWFzb25bdGhpcy5fc3dpdGNoT2ZmUmVhc29uXSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgbG9nID0gX2EuX2xvZywgbmFtZSA9IF9hLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRGVwcmVjYXRlRW5hYmxlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlRXZlbnRzKG5hbWUsIF90aGlzLCBuZXcgTWFwKFtcbiAgICAgICAgICAgICAgICAgICAgWydkaXNhYmxlZCcsICdzd2l0Y2hlZE9mZiAoLnN3aXRjaE9mZlJlYXNvbiA9PT0gXCJkaXNhYmxlZC1ieS1wdWJsaXNoZXJcIiknXSxcbiAgICAgICAgICAgICAgICAgICAgWydlbmFibGVkJywgJ3N3aXRjaGVkT24nXVxuICAgICAgICAgICAgICAgIF0pLCBsb2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIHN1YnNjcmliZSB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IG9mIHRoZSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30uXG4gICAgICAgICAqIEBwYXJhbSB7P1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eSAtIHRoZSBuZXcgc3Vic2NyaWJlIHtAbGluayBUcmFjay5Qcmlvcml0eX07XG4gICAgICAgICAqICAgSWYgPGNvZGU+bnVsbDwvY29kZT4sIHRoZW4gdGhlIHN1YnNjcmliZSB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IGlzIGNsZWFyZWQsIHdoaWNoXG4gICAgICAgICAqICAgbWVhbnMgdGhlIHtAbGluayBUcmFjay5Qcmlvcml0eX0gc2V0IGJ5IHRoZSBwdWJsaXNoZXIgaXMgbm93IHRoZSBlZmZlY3RpdmUgcHJpb3JpdHkuXG4gICAgICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgUmVtb3RlTWVkaWFUcmFjay5wcm90b3R5cGUuc2V0UHJpb3JpdHkgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHZhciBwcmlvcml0eVZhbHVlcyA9IF9fc3ByZWFkQXJyYXkoW251bGxdLCBfX3JlYWQoT2JqZWN0LnZhbHVlcyh0cmFja1ByaW9yaXR5KSkpO1xuICAgICAgICAgICAgaWYgKCFwcmlvcml0eVZhbHVlcy5pbmNsdWRlcyhwcmlvcml0eSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgICAgICAgICAgICAgIHRocm93IEUuSU5WQUxJRF9WQUxVRSgncHJpb3JpdHknLCBwcmlvcml0eVZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpb3JpdHkgIT09IHByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcmlvcml0eShwcmlvcml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbmFibGVkXG4gICAgICAgICAqL1xuICAgICAgICBSZW1vdGVNZWRpYVRyYWNrLnByb3RvdHlwZS5fc2V0RW5hYmxlZCA9IGZ1bmN0aW9uIChpc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0VuYWJsZWQgIT09IGlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGlzRW5hYmxlZDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5faXNFbmFibGVkID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gez9NZWRpYVRyYWNrUmVjZWl2ZXJ9IG1lZGlhVHJhY2tSZWNlaXZlclxuICAgICAgICAgKi9cbiAgICAgICAgUmVtb3RlTWVkaWFUcmFjay5wcm90b3R5cGUuX3NldE1lZGlhVHJhY2tSZWNlaXZlciA9IGZ1bmN0aW9uIChtZWRpYVRyYWNrUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZWRpYVRyYWNrVHJhbnNjZWl2ZXIgIT09IG1lZGlhVHJhY2tSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhVHJhY2tUcmFuc2NlaXZlciA9IG1lZGlhVHJhY2tSZWNlaXZlcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRWxlbWVudHNNZWRpYVN0cmVhbVRyYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3dpdGNoZWRPZmZcbiAgICAgICAgICogQHBhcmFtIHs/c3RyaW5nfSBbc3dpdGNoT2ZmUmVhc29uPW51bGxdXG4gICAgICAgICAqL1xuICAgICAgICBSZW1vdGVNZWRpYVRyYWNrLnByb3RvdHlwZS5fc2V0U3dpdGNoZWRPZmYgPSBmdW5jdGlvbiAoaXNTd2l0Y2hlZE9mZiwgc3dpdGNoT2ZmUmVhc29uKSB7XG4gICAgICAgICAgICBpZiAoc3dpdGNoT2ZmUmVhc29uID09PSB2b2lkIDApIHsgc3dpdGNoT2ZmUmVhc29uID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU3dpdGNoZWRPZmYgIT09IGlzU3dpdGNoZWRPZmYgfHwgdGhpcy5fc3dpdGNoT2ZmUmVhc29uICE9PSBzd2l0Y2hPZmZSZWFzb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1N3aXRjaGVkT2ZmID0gaXNTd2l0Y2hlZE9mZjtcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2l0Y2hPZmZSZWFzb24gPSBzd2l0Y2hPZmZSZWFzb247XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW2lzU3dpdGNoZWRPZmYgPyAnc3dpdGNoZWRPZmYnIDogJ3N3aXRjaGVkT24nLCB0aGlzXSwgX19yZWFkKChpc1N3aXRjaGVkT2ZmID8gW3RoaXMuc3dpdGNoT2ZmUmVhc29uXSA6IFtdKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUmVtb3RlTWVkaWFUcmFjay5wcm90b3R5cGUuX2F0dGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXR1cm5WYWwgPSBfc3VwZXIucHJvdG90eXBlLl9hdHRhY2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hdHRhY2htZW50cy5zaXplID4gMCAmJiB0aGlzLm1lZGlhU3RyZWFtVHJhY2sgJiYgdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogd2UgZGlzYWJsZSBtZWRpYVN0cmVhbVRyYWNrIHdoZW4gdGhlcmVcbiAgICAgICAgICAgICAgICAvLyBhcmUgbm8gYXR0YWNobWVudHMgdG8gaXQgKHNlZSBub3RlcyBpbiBkZXRhY2ggZnVuY3Rpb24gYmVsb3cpLiBOb3cgdGhhdCB0aGVyZVxuICAgICAgICAgICAgICAgIC8vIGFyZSBhdHRhY2htZW50cyByZS1lbmFibGUgdGhlIHRyYWNrLlxuICAgICAgICAgICAgICAgIC8vIHdlIGhhbmRsZSB0aGlzIGluIF9hdHRhY2ggaW5zdGVhZCBvZiBwdWJsaWMgYXR0YWNoIGJlbG93IGJlY2F1c2UgZm9yIGxhcmdlIHJvb20sIHdlIHN3aXRjaCBtZWRpYVN0cmVhbVRyYWNrcyBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3RlTWVkaWFUcmFja3MgYXMgbWlkIGNoYW5nZXMsIGludm9raW5nIHRoaXMgaW50ZXJuYWwgX2F0dGFjaC5cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBnb3QgdGhlIG1lZGlhU3RyZWFtVHJhY2sgZnJvbSBSZW1vdGVNZWRpYVRyYWNrIHRoYXQgd2FzIGRldGFjaGVkLCBpdCB3b3VsZCBoYXZlXG4gICAgICAgICAgICAgICAgLy8gbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkIHNldCB0byBmYWxzZSB3aGljaCBuZWVkcyB0byBiZSBmaXhlZCBiZWZvcmUgYXR0YWNoaW5nLlxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygnRW5hYmxpbmcgbWVkaWFTdHJlYW1UcmFjayB0aGF0IHdhcyBkaXNhYmxlZCB3aGlsZSBkZXRhY2hlZC4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkVHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWRUcmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTk9URShjc2FudG9zKTogc2luY2UgcmVtb3RlIHRyYWNrcyBkaXNhYmxlcy9lbmFibGVzIHRoZSBtZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgICAgICAgICAgIC8vIGNhcHR1cmVGcmFtZXMgc3RvcHMgYWxvbmcgd2l0aCBpdC4gV2UgbmVlZCB0byBzdGFydCBpdCBhZ2FpbiBhZnRlciByZS1lbmFibGluZy5cbiAgICAgICAgICAgICAgICAvLyBTZWUgYXR0YWNoL2RldGFjaCBtZXRob2RzIGluIHRoaXMgY2xhc3MgYW5kIGluIFZpZGVvVHJhY2sgY2xhc3MuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhcHR1cmVGcmFtZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsO1xuICAgICAgICB9O1xuICAgICAgICBSZW1vdGVNZWRpYVRyYWNrLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLmF0dGFjaC5jYWxsKHRoaXMsIGVsKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93b3JrYXJvdW5kV2ViS2l0QnVnMjEyNzgwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2Fyb3VuZFdlYktpdEJ1ZzIxMjc4MENsZWFudXAgPSB0aGlzLl93b3JrYXJvdW5kV2ViS2l0QnVnMjEyNzgwQ2xlYW51cFxuICAgICAgICAgICAgICAgICAgICB8fCBwbGF5SWZQYXVzZWRXaGlsZUluQmFja2dyb3VuZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIFJlbW90ZU1lZGlhVHJhY2sucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuZGV0YWNoLmNhbGwodGhpcywgZWwpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGFjaG1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogY2hyb21lIGNvbnRpbnVlcyBwbGF5aW5nIHdlYnJ0YyBhdWRpb1xuICAgICAgICAgICAgICAgIC8vIHRyYWNrIGV2ZW4gYWZ0ZXIgYXVkaW8gZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIERPTS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD03NDk5MjhcbiAgICAgICAgICAgICAgICAvLyB0byB3b3JrYXJvdW5kOiBoZXJlIGRpc2FibGUgdGhlIHRyYWNrIHdoZW5cbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gZWxlbWVudHMgYXR0YWNoZWQgdG8gaXQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZFRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmthcm91bmRXZWJLaXRCdWcyMTI3ODBDbGVhbnVwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVuaG9vayB2aXNpYmlsaXR5IGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93b3JrYXJvdW5kV2ViS2l0QnVnMjEyNzgwQ2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93b3JrYXJvdW5kV2ViS2l0QnVnMjEyNzgwQ2xlYW51cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlbW90ZU1lZGlhVHJhY2s7XG4gICAgfShBdWRpb09yVmlkZW9UcmFjaykpO1xufVxuZnVuY3Rpb24gcGxheUlmUGF1c2VkV2hpbGVJbkJhY2tncm91bmQocmVtb3RlTWVkaWFUcmFjaykge1xuICAgIHZhciBsb2cgPSByZW1vdGVNZWRpYVRyYWNrLl9sb2csIGtpbmQgPSByZW1vdGVNZWRpYVRyYWNrLmtpbmQ7XG4gICAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlZChpc1Zpc2libGUpIHtcbiAgICAgICAgaWYgKCFpc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZW1vdGVNZWRpYVRyYWNrLl9hdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIHNoaW0gPSByZW1vdGVNZWRpYVRyYWNrLl9lbFNoaW1zLmdldChlbCk7XG4gICAgICAgICAgICB2YXIgaXNJbmFkdmVydGVudGx5UGF1c2VkID0gZWwucGF1c2VkICYmIHNoaW0gJiYgIXNoaW0ucGF1c2VkSW50ZW50aW9uYWxseSgpO1xuICAgICAgICAgICAgaWYgKGlzSW5hZHZlcnRlbnRseVBhdXNlZCkge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiUGxheWluZyBpbmFkdmVydGVudGx5IHBhdXNlZCA8XCIgKyBraW5kICsgXCI+IGVsZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKCdFbGVtZW50OicsIGVsKTtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ1JlbW90ZU1lZGlhVHJhY2s6JywgcmVtb3RlTWVkaWFUcmFjayk7XG4gICAgICAgICAgICAgICAgZWwucGxheSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsb2cuaW5mbyhcIlN1Y2Nlc3NmdWxseSBwbGF5ZWQgaW5hZHZlcnRlbnRseSBwYXVzZWQgPFwiICsga2luZCArIFwiPiBlbGVtZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ0VsZW1lbnQ6JywgZWwpO1xuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ1JlbW90ZU1lZGlhVHJhY2s6JywgcmVtb3RlTWVkaWFUcmFjayk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihcIkVycm9yIHdoaWxlIHBsYXlpbmcgaW5hZHZlcnRlbnRseSBwYXVzZWQgPFwiICsga2luZCArIFwiPiBlbGVtZW50OlwiLCB7IGVycjogZXJyLCBlbDogZWwsIHJlbW90ZU1lZGlhVHJhY2s6IHJlbW90ZU1lZGlhVHJhY2sgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogbGlzdGVuIGZvciBkb2N1bWVudCB2aXNpYmlsaXR5IGNhbGxiYWNrIG9uIHBoYXNlIDIuXG4gICAgLy8gdGhpcyBlbnN1cmVzIHRoYXQgYW55IExvY2FsTWVkaWFUcmFjaydzIHJlc3RhcnQgKHdoaWNoIGxpc3RlbiBvbiBwaGFzZSAxKSBnZXRzIGV4ZWN1dGVkXG4gICAgLy8gZmlyc3QuIFRoaXMgb3JkZXIgaXMgaW1wb3J0YW50IGJlY2F1c2Ugd2UgYHBsYXlgIHRyYWNrcyBpbiB0aGUgY2FsbGJhY2ssIGFuZFxuICAgIC8vIHBsYXkgY2FuIGZhaWwgb24gc2FmYXJpIGlmIGF1ZGlvIGlzIG5vdCBiZWluZyBjYXB0dXJlZC5cbiAgICBkb2N1bWVudFZpc2liaWxpdHlNb25pdG9yLm9uVmlzaWJpbGl0eUNoYW5nZSgyLCBvblZpc2liaWxpdHlDaGFuZ2VkKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudFZpc2liaWxpdHlNb25pdG9yLm9mZlZpc2liaWxpdHlDaGFuZ2UoMiwgb25WaXNpYmlsaXR5Q2hhbmdlZCk7XG4gICAgfTtcbn1cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30gd2FzIGRpc2FibGVkIChEZXByZWNhdGVkIG9ubHkgZm9yIGxhcmdlIGdyb3VwIFJvb21zKS5cbiAqIEBkZXByZWNhdGVkIFVzZSA8YSBocmVmPVwiI2V2ZW50OnN3aXRjaGVkT2ZmXCI+PGNvZGU+c3dpdGNoZWRPZmY8L2NvZGU+PC9hPiAoPGNvZGU+LnN3aXRjaE9mZlJlYXNvbiAhPT0gXCJkaXNhYmxlZC1ieS1wdWJsaXNoZXJcIjwvY29kZT4pIGluc3RlYWRcbiAqIEBwYXJhbSB7UmVtb3RlTWVkaWFUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZU1lZGlhVHJhY2t9IHRoYXQgd2FzXG4gKiAgIGRpc2FibGVkXG4gKiBAZXZlbnQgUmVtb3RlTWVkaWFUcmFjayNkaXNhYmxlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZU1lZGlhVHJhY2t9IHdhcyBlbmFibGVkIChEZXByZWNhdGVkIG9ubHkgZm9yIGxhcmdlIGdyb3VwIFJvb21zKS5cbiAqIEBkZXByZWNhdGVkIFVzZSA8YSBocmVmPVwiI2V2ZW50OnN3aXRjaGVkT25cIj48Y29kZT5zd2l0Y2hlZE9uPC9jb2RlPjwvYT4gaW5zdGVhZFxuICogQHBhcmFtIHtSZW1vdGVNZWRpYVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30gdGhhdCB3YXNcbiAqICAgZW5hYmxlZFxuICogQGV2ZW50IFJlbW90ZU1lZGlhVHJhY2sjZW5hYmxlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZU1lZGlhVHJhY2t9IHdhcyBzd2l0Y2hlZCBvZmYuIFRoZSBtZWRpYSBzZXJ2ZXIgc3RvcHMgc2VuZGluZyBtZWRpYSBmb3IgdGhlXG4gKiB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30gdW50aWwgaXQgaXMgc3dpdGNoZWQgYmFjayBvbi4gSnVzdCBiZWZvcmUgdGhlIGV2ZW50IGlzIHJhaXNlZCxcbiAqIDxjb2RlPmlzU3dpdGNoZWRPZmY8L2NvZGU+IGlzIHNldCB0byA8Y29kZT50cnVlPC9jb2RlPiBhbmQgPGNvZGU+c3dpdGNoT2ZmUmVhc29uPC9jb2RlPiBpc1xuICogc2V0IHRvIGEge0BsaW5rIFRyYWNrU3dpdGNoT2ZmUmVhc29ufSBpbiBsYXJnZSBncm91cCBSb29tcyAoPGNvZGU+c3dpdGNoT2ZmUmVhc29uPC9jb2RlPiBpc1xuICogPGNvZGU+bnVsbDwvY29kZT4gbm9uLWxhcmdlIGdyb3VwIFJvb21zKS4gQWxzbywgdGhlIDxjb2RlPm1lZGlhU3RyZWFtVHJhY2s8L2NvZGU+IHByb3BlcnR5XG4gKiBpcyBzZXQgdG8gPGNvZGU+bnVsbDwvY29kZT4gKG9ubHkgaW4gbGFyZ2UgZ3JvdXAgUm9vbXMpLlxuICogQHBhcmFtIHtSZW1vdGVNZWRpYVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30gdGhhdCB3YXNcbiAqICAgc3dpdGNoZWQgb2ZmXG4gKiBAcGFyYW0gez9UcmFja1N3aXRjaE9mZlJlYXNvbn0gc3dpdGNoT2ZmUmVhc29uIC0gVGhlIHJlYXNvbiB0aGUge0BsaW5rIFJlbW90ZU1lZGlhVHJhY2t9XG4gKiAgIHdhcyBzd2l0Y2hlZCBvZmZcbiAqIEBldmVudCBSZW1vdGVNZWRpYVRyYWNrI3N3aXRjaGVkT2ZmXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30gd2FzIHN3aXRjaGVkIG9uLiBUaGUgbWVkaWEgc2VydmVyIHN0YXJ0cyBzZW5kaW5nIG1lZGlhIGZvciB0aGVcbiAqIHtAbGluayBSZW1vdGVNZWRpYVRyYWNrfSB1bnRpbCBpdCBpcyBzd2l0Y2hlZCBvZmYuIEp1c3QgYmVmb3JlIHRoZSBldmVudCBpcyByYWlzZWQsXG4gKiA8Y29kZT5pc1N3aXRjaGVkT2ZmPC9jb2RlPiBpcyBzZXQgdG8gPGNvZGU+ZmFsc2U8L2NvZGU+IGFuZCA8Y29kZT5zd2l0Y2hPZmZSZWFzb248L2NvZGU+XG4gKiBpcyBzZXQgdG8gPGNvZGU+bnVsbDwvY29kZT4uIEFsc28sIHRoZSA8Y29kZT5tZWRpYVN0cmVhbVRyYWNrPC9jb2RlPiBwcm9wZXJ0eSBpcyBzZXQgdG8gYVxuICogTWVkaWFTdHJlYW1UcmFjayB0aGF0IGlzIHRoZSBzb3VyY2Ugb2YgdGhlIHtAbGluayBSZW1vdGVNZWRpYVRyYWNrfSdzIG1lZGlhLlxuICogQHBhcmFtIHtSZW1vdGVNZWRpYVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30gdGhhdCB3YXNcbiAqICAgc3dpdGNoZWQgb25cbiAqIEBldmVudCBSZW1vdGVNZWRpYVRyYWNrI3N3aXRjaGVkT25cbiAqL1xuLyoqXG4gKiBBIHtAbGluayBDbGllbnRSZW5kZXJIaW50fSBvYmplY3Qgc3BlY2lmaWVzIHRyYWNrIGRpbWVuc2lvbnMgYW5kIC9lbmFibGVkIGRpc2FibGUgc3RhdGUuXG4gKiBUaGlzIHN0YXRlIHdpbGwgYmUgdXNlZCBieSB0aGUgc2VydmVyKFNGVSkgdG8gZGV0ZXJtaW5lIGJhbmR3aWR0aCBhbGxvY2F0aW9uIGZvciB0aGUgdHJhY2ssXG4gKiBhbmQgdHVybiBpdCBvbiBvciBvZmYgYXMgbmVlZGVkLlxuICogQHR5cGVkZWYge29iamVjdH0gQ2xpZW50UmVuZGVySGludFxuICogQHByb3BlcnR5IHtib29sZWFufSBbZW5hYmxlZF0gLSB0cmFjayBpcyBlbmFibGVkIG9yIGRpc2FibGVkLiBkZWZhdWx0cyB0byBkaXNhYmxlZC5cbiAqIEBwcm9wZXJ0eSB7VmlkZW9UcmFjay5EaW1lbnNpb25zfSBbcmVuZGVyRGltZW5zaW9uc10gLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgZGVzaXJlZFxuICogICByZW5kZXIgZGltZW5zaW9ucyBvZiB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zLiBUaGlzIHByb3BlcnR5IG11c3QgYmUgc3BlY2lmaWVkIGlmIGVuYWJsZWQ9dHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IG1peGluUmVtb3RlTWVkaWFUcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW90ZW1lZGlhdHJhY2suanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xuICAgIHJldHVybiB0bztcbn07XG52YXIgZGVwcmVjYXRlRXZlbnRzID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLmRlcHJlY2F0ZUV2ZW50cztcbnZhciBUcmFja1B1YmxpY2F0aW9uID0gcmVxdWlyZSgnLi90cmFja3B1YmxpY2F0aW9uJyk7XG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259IHJlcHJlc2VudHMgYSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgaGFzXG4gKiBiZWVuIHB1Ymxpc2hlZCB0byBhIHtAbGluayBSb29tfS5cbiAqIEBleHRlbmRzIFRyYWNrUHVibGljYXRpb25cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTdWJzY3JpYmVkIC0gd2hldGhlciB0aGUgcHVibGlzaGVkIHtAbGluayBSZW1vdGVUcmFja31cbiAqICAgaXMgc3Vic2NyaWJlZCB0b1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc1RyYWNrRW5hYmxlZCAtIDxjb2RlPkRlcHJlY2F0ZWQ6IFVzZSAodHJhY2suc3dpdGNoT2ZmUmVhc29uICE9PSBcImRpc2FibGVkLWJ5LXB1Ymxpc2hlclwiKSBpbnN0ZWFkLiBUaGlzIHByb3BlcnR5IGlzIG9ubHkgdmFsaWQgaWYgdGhlIGNvcnJlc3BvbmRpbmcgUmVtb3RlVHJhY2sgaXMgc3Vic2NyaWJlZCB0by48L2NvZGU+XG4gKiAgIHdoZXRoZXIgdGhlIHB1Ymxpc2hlZCB7QGxpbmsgUmVtb3RlVHJhY2t9IGlzIGVuYWJsZWQgKERlcHJlY2F0ZWQgb25seSBmb3IgbGFyZ2UgZ3JvdXAgUm9vbXMpXG4gKiBAcHJvcGVydHkge1RyYWNrLktpbmR9IGtpbmQgLSBraW5kIG9mIHRoZSBwdWJsaXNoZWQge0BsaW5rIFJlbW90ZVRyYWNrfVxuICogQHByb3BlcnR5IHtUcmFjay5Qcmlvcml0eX0gcHVibGlzaFByaW9yaXR5IC0gdGhlIHtAbGluayBUcmFjay5Qcmlvcml0eX0gb2YgdGhlIHB1Ymxpc2hlZFxuICogICB7QGxpbmsgUmVtb3RlVHJhY2t9IHNldCBieSB0aGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fVxuICogQHByb3BlcnR5IHs/UmVtb3RlVHJhY2t9IHRyYWNrIC0gVW5sZXNzIHlvdSBoYXZlIHN1YnNjcmliZWQgdG8gdGhlXG4gKiAgIHtAbGluayBSZW1vdGVUcmFja30sIHRoaXMgcHJvcGVydHkgaXMgbnVsbFxuICogQGVtaXRzIFJlbW90ZVRyYWNrUHVibGljYXRpb24jcHVibGlzaFByaW9yaXR5Q2hhbmdlZFxuICogQGVtaXRzIFJlbW90ZVRyYWNrUHVibGljYXRpb24jc3Vic2NyaWJlZFxuICogQGVtaXRzIFJlbW90ZVRyYWNrUHVibGljYXRpb24jc3Vic2NyaXB0aW9uRmFpbGVkXG4gKiBAZW1pdHMgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiN0cmFja0Rpc2FibGVkXG4gKiBAZW1pdHMgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiN0cmFja0VuYWJsZWRcbiAqIEBlbWl0cyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uI3RyYWNrU3dpdGNoZWRPZmZcbiAqIEBlbWl0cyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uI3RyYWNrU3dpdGNoZWRPblxuICogQGVtaXRzIFJlbW90ZVRyYWNrUHVibGljYXRpb24jdW5zdWJzY3JpYmVkXG4gKlxuICovXG52YXIgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0uXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjJ8UmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzfSBzaWduYWxpbmcgLSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gc2lnbmFsaW5nXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9uT3B0aW9uc30gb3B0aW9ucyAtIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICAgICAqICAgb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbW90ZVRyYWNrUHVibGljYXRpb24oc2lnbmFsaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHJlZW1pdEV2ZW50c1RvUmVtb3RlUGFydGljaXBhbnQ6IGZ1bmN0aW9uICgpIHsgfVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHJzcFZlcnNpb24gPSBzaWduYWxpbmcucnNwVmVyc2lvbiwgc2lkID0gc2lnbmFsaW5nLnNpZCwgdHJhY2tOYW1lID0gc2lnbmFsaW5nLm5hbWU7XG4gICAgICAgIHZhciBzaG91bGREZXByZWNhdGVFbmFibGVkU3RhdGUgPSByc3BWZXJzaW9uID49IDM7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhY2tOYW1lLCBzaWQsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfc2lnbmFsaW5nOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHNpZ25hbGluZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90cmFjazoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNTdWJzY3JpYmVkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fdHJhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzVHJhY2tFbmFibGVkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZERlcHJlY2F0ZUVuYWJsZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlcHJlY2F0ZWQoJy5pc1RyYWNrRW5hYmxlZCBpcyBkZXByZWNhdGVkIGFuZCBzY2hlZHVsZWQgZm9yIHJlbW92YWwuICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICdEdXJpbmcgdGhlIGRlcHJlY2F0aW9uIHBlcmlvZCwgdGhpcyBwcm9wZXJ0eSBpcyBvbmx5IHZhbGlkIGlmIHRoZSBjb3JyZXNwb25kaW5nICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICdSZW1vdGVUcmFjayBpcyBzdWJzY3JpYmVkIHRvLiBUaGUgUmVtb3RlVHJhY2sgY2FuIGJlIGNvbnNpZGVyZWQgZGlzYWJsZWQgaWYgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJy5zd2l0Y2hPZmZSZWFzb24gaXMgc2V0IHRvIFwiZGlzYWJsZWQtYnktcHVibGlzaGVyXCIuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hbGluZy5pc0VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtpbmQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzaWduYWxpbmcua2luZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHB1Ymxpc2hQcmlvcml0eToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYWxpbmcucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYWNrOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHJlbWVtYmVyIG9yaWdpbmFsIHN0YXRlLCBhbmQgZmlyZSBldmVudHMgb25seSBvbiBjaGFuZ2UuXG4gICAgICAgIHZhciBlcnJvciA9IHNpZ25hbGluZy5lcnJvciwgaXNFbmFibGVkID0gc2lnbmFsaW5nLmlzRW5hYmxlZCwgaXNTd2l0Y2hlZE9mZiA9IHNpZ25hbGluZy5pc1N3aXRjaGVkT2ZmLCBwcmlvcml0eSA9IHNpZ25hbGluZy5wcmlvcml0eSwgX2EgPSBzaWduYWxpbmcuc3dpdGNoT2ZmUmVhc29uLCBzd2l0Y2hPZmZSZWFzb24gPSBfYSA9PT0gdm9pZCAwID8gbnVsbCA6IF9hLCB0cmFja1RyYW5zY2VpdmVyID0gc2lnbmFsaW5nLnRyYWNrVHJhbnNjZWl2ZXI7XG4gICAgICAgIHZhciBfYiA9IF90aGlzLCBsb2cgPSBfYi5fbG9nLCBuYW1lID0gX2IuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgc2lnbmFsaW5nLm9uKCd1cGRhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGVycm9yICE9PSBzaWduYWxpbmcuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IHNpZ25hbGluZy5lcnJvcjtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdzdWJzY3JpcHRpb25GYWlsZWQnLCBzaWduYWxpbmcuZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0VuYWJsZWQgIT09IHNpZ25hbGluZy5pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpc0VuYWJsZWQgPSBzaWduYWxpbmcuaXNFbmFibGVkO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50cmFjaykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmFjay5fc2V0RW5hYmxlZChzaWduYWxpbmcuaXNFbmFibGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChzaWduYWxpbmcuaXNFbmFibGVkID8gJ3RyYWNrRW5hYmxlZCcgOiAndHJhY2tEaXNhYmxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld1N3aXRjaE9mZlJlYXNvbiA9IHNpZ25hbGluZy5zd2l0Y2hPZmZSZWFzb24gfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChpc1N3aXRjaGVkT2ZmICE9PSBzaWduYWxpbmcuaXNTd2l0Y2hlZE9mZiB8fCBzd2l0Y2hPZmZSZWFzb24gIT09IG5ld1N3aXRjaE9mZlJlYXNvbikge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhfdGhpcy50cmFja1NpZCArIFwiOiBcIiArIChpc1N3aXRjaGVkT2ZmID8gJ09GRicgOiAnT04nKSArIFwiID0+IFwiICsgKHNpZ25hbGluZy5pc1N3aXRjaGVkT2ZmID8gJ09GRicgOiAnT04nKSk7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKF90aGlzLnRyYWNrU2lkICsgXCIgb2ZmX3JlYXNvbjogXCIgKyBzd2l0Y2hPZmZSZWFzb24gKyBcIiA9PiBcIiArIG5ld1N3aXRjaE9mZlJlYXNvbik7XG4gICAgICAgICAgICAgICAgaXNTd2l0Y2hlZE9mZiA9IHNpZ25hbGluZy5pc1N3aXRjaGVkT2ZmO1xuICAgICAgICAgICAgICAgIHN3aXRjaE9mZlJlYXNvbiA9IG5ld1N3aXRjaE9mZlJlYXNvbjtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJhY2suX3NldFN3aXRjaGVkT2ZmKHNpZ25hbGluZy5pc1N3aXRjaGVkT2ZmLCBzd2l0Y2hPZmZSZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0LmFwcGx5KF90aGlzLCBfX3NwcmVhZEFycmF5KFtpc1N3aXRjaGVkT2ZmID8gJ3RyYWNrU3dpdGNoZWRPZmYnIDogJ3RyYWNrU3dpdGNoZWRPbicsIF90aGlzLnRyYWNrXSwgX19yZWFkKChpc1N3aXRjaGVkT2ZmID8gW190aGlzLnRyYWNrLnN3aXRjaE9mZlJlYXNvbl0gOiBbXSkpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJUcmFjayB3YXMgbm90IHN1YnNjcmliZWQgdG8gd2hlbiBzd2l0Y2hlZCBcIiArIChpc1N3aXRjaGVkT2ZmID8gJ29mZicgOiAnb24nKSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2tUcmFuc2NlaXZlciAhPT0gc2lnbmFsaW5nLnRyYWNrVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoX3RoaXMudHJhY2tTaWQgKyBcIiBNZWRpYVRyYWNrUmVjZWl2ZXIgY2hhbmdlZDpcIiwgdHJhY2tUcmFuc2NlaXZlciwgc2lnbmFsaW5nLnRyYWNrVHJhbnNjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIHRyYWNrVHJhbnNjZWl2ZXIgPSBzaWduYWxpbmcudHJhY2tUcmFuc2NlaXZlcjtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudHJhY2sgJiYgX3RoaXMua2luZCAhPT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyYWNrLl9zZXRNZWRpYVRyYWNrUmVjZWl2ZXIodHJhY2tUcmFuc2NlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFfdGhpcy50cmFjaykge1xuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ1RyYWNrIHdhcyBub3Qgc3Vic2NyaWJlZCB0byB3aGVuIFRyYWNrUmVjZWl2ZXIgY2hhbmdlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJpb3JpdHkgIT09IHNpZ25hbGluZy5wcmlvcml0eSkge1xuICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gc2lnbmFsaW5nLnByaW9yaXR5O1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3B1Ymxpc2hQcmlvcml0eUNoYW5nZWQnLCBwcmlvcml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zLnJlZW1pdEV2ZW50c1RvUmVtb3RlUGFydGljaXBhbnQoX3RoaXMpO1xuICAgICAgICBpZiAoc2hvdWxkRGVwcmVjYXRlRW5hYmxlZFN0YXRlKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVFdmVudHMobmFtZSwgX3RoaXMsIG5ldyBNYXAoW1xuICAgICAgICAgICAgICAgIFsndHJhY2tEaXNhYmxlZCcsICd0cmFja1N3aXRjaGVkT2ZmICh0cmFjay5zd2l0Y2hPZmZSZWFzb24gPT09IFwiZGlzYWJsZWQtYnktcHVibGlzaGVyXCIpJ10sXG4gICAgICAgICAgICAgICAgWyd0cmFja0VuYWJsZWQnLCAndHJhY2tTd2l0Y2hlZE9uJ11cbiAgICAgICAgICAgIF0pLCBsb2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltSZW1vdGVUcmFja1B1YmxpY2F0aW9uICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyBcIjogXCIgKyB0aGlzLnRyYWNrU2lkICsgXCJdXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrXG4gICAgICovXG4gICAgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbi5wcm90b3R5cGUuX3N1YnNjcmliZWQgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFjayAmJiB0cmFjaykge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3Vic2NyaWJlZCcsIHRyYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFjaykge1xuICAgICAgICAgICAgdmFyIHRyYWNrID0gdGhpcy5fdHJhY2s7XG4gICAgICAgICAgICB0aGlzLl90cmFjayA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Vuc3Vic2NyaWJlZCcsIHRyYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlbW90ZVRyYWNrUHVibGljYXRpb247XG59KFRyYWNrUHVibGljYXRpb24pKTtcbi8qKlxuICogVGhlIHtAbGluayBSZW1vdGVUcmFja30ncyBwdWJsaXNoIHtAbGluayBUcmFjay5Qcmlvcml0eX0gd2FzIGNoYW5nZWQgYnkgdGhlXG4gKiB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9LlxuICogQHBhcmFtIHtUcmFjay5Qcmlvcml0eX0gcHJpb3JpdHkgLSB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSdzIG5ldyBwdWJsaXNoXG4gKiAgIHtAbGluayBUcmFjay5Qcmlvcml0eX07IFJlbW90ZVRyYWNrUHVibGljYXRpb24jcHVibGlzaFByaW9yaXR5IGlzIGFsc29cbiAqICAgdXBkYXRlZCBhY2NvcmRpbmdseVxuICogQGV2ZW50IFJlbW90ZVRyYWNrUHVibGljYXRpb24jcHVibGlzaFByaW9yaXR5Q2hhbmdlZFxuICovXG4vKipcbiAqIFlvdXIge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IHN1YnNjcmliZWQgdG8gdGhlIHtAbGluayBSZW1vdGVUcmFja30uXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrfSB0cmFjayAtIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHN1YnNjcmliZWQgdG9cbiAqIEBldmVudCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uI3N1YnNjcmliZWRcbiAqL1xuLyoqXG4gKiBZb3VyIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBmYWlsZWQgdG8gc3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9LlxuICogQHBhcmFtIHtUd2lsaW9FcnJvcn0gZXJyb3IgLSB0aGUgcmVhc29uIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IGNvdWxkIG5vdCBiZVxuICogICBzdWJzY3JpYmVkIHRvXG4gKiBAZXZlbnQgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiNzdWJzY3JpcHRpb25GYWlsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgZGlzYWJsZWQuIEluIGxhcmdlIGdyb3VwIFJvb21zLCBpdCBpcyBmaXJlZCBvbmx5IGlmIDxjb2RlPi5pc1N1YnNjcmliZWQ8L2NvZGU+XG4gKiBpcyBzZXQgdG8gPGNvZGU+dHJ1ZTwvY29kZT4gKERlcHJlY2F0ZWQgb25seSBmb3IgbGFyZ2UgZ3JvdXAgUm9vbXMpLlxuICogQGRlcHJlY2F0ZWQgVXNlIDxhIGhyZWY9XCJldmVudDp0cmFja1N3aXRjaGVkT2ZmXCI+PGNvZGU+dHJhY2tTd2l0Y2hlZE9mZjwvY29kZT48L2E+ICg8Y29kZT50cmFjay5zd2l0Y2hPZmZSZWFzb24gPT09IFwiZGlzYWJsZWQtYnktcHVibGlzaGVyXCI8L2NvZGU+KSBpbnN0ZWFkXG4gKiBAZXZlbnQgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiN0cmFja0Rpc2FibGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSZW1vdGVUcmFja30gd2FzIGVuYWJsZWQuIEluIGxhcmdlIGdyb3VwIFJvb21zLCBpdCBpcyBmaXJlZCBvbmx5IGlmIDxjb2RlPi5pc1N1YnNjcmliZWQ8L2NvZGU+XG4gKiBpcyBzZXQgdG8gPGNvZGU+dHJ1ZTwvY29kZT4gKERlcHJlY2F0ZWQgb25seSBmb3IgbGFyZ2UgZ3JvdXAgUm9vbXMpLlxuICogQGRlcHJlY2F0ZWQgVXNlIDxhIGhyZWY9XCJldmVudDp0cmFja1N3aXRjaGVkT25cIj48Y29kZT50cmFja1N3aXRjaGVkT248L2NvZGU+PC9hPiBpbnN0ZWFkXG4gKiBAZXZlbnQgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiN0cmFja0VuYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgc3dpdGNoZWQgb2ZmLiBUaGUgbWVkaWEgc2VydmVyIHN0b3BzIHNlbmRpbmcgbWVkaWEgb3IgZGF0YVxuICogZm9yIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHVudGlsIGl0IGlzIHN3aXRjaGVkIGJhY2sgb24uIEp1c3QgYmVmb3JlIHRoZSBldmVudCBpcyByYWlzZWQsXG4gKiA8Y29kZT5pc1N3aXRjaGVkT2ZmPC9jb2RlPiBpcyBzZXQgdG8gPGNvZGU+dHJ1ZTwvY29kZT4gYW5kIDxjb2RlPnN3aXRjaE9mZlJlYXNvbjwvY29kZT5cbiAqIGlzIHNldCB0byBhIHtAbGluayBUcmFja1N3aXRjaE9mZlJlYXNvbn0gaW4gbGFyZ2UgZ3JvdXAgUm9vbXMgKDxjb2RlPnN3aXRjaE9mZlJlYXNvbjwvY29kZT4gaXNcbiAqIDxjb2RlPm51bGw8L2NvZGU+IG5vbi1sYXJnZSBncm91cCBSb29tcykuIEFsc28sIGlmIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHJlY2VpdmVzIGVpdGhlclxuICogYXVkaW8gb3IgdmlkZW8gbWVkaWEsIHRoZSA8Y29kZT5tZWRpYVN0cmVhbVRyYWNrPC9jb2RlPiBwcm9wZXJ0eSBpcyBzZXQgdG8gPGNvZGU+bnVsbDwvY29kZT4uXG4gKiAob25seSBpbiBsYXJnZSBncm91cCBSb29tcylcbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCB3YXMgc3dpdGNoZWQgb2ZmXG4gKiBAcGFyYW0gez9UcmFja1N3aXRjaE9mZlJlYXNvbn0gc3dpdGNoT2ZmUmVhc29uIC0gdGhlIHJlYXNvbiB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfVxuICogICB3YXMgc3dpdGNoZWQgb2ZmXG4gKiBAZXZlbnQgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiN0cmFja1N3aXRjaGVkT2ZmXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSZW1vdGVUcmFja30gd2FzIHN3aXRjaGVkIG9uLiBUaGUgbWVkaWEgc2VydmVyIHN0YXJ0cyBzZW5kaW5nIG1lZGlhIG9yIGRhdGFcbiAqIGZvciB0aGUge0BsaW5rIFJlbW90ZU1lZGlhVHJhY2t9IHVudGlsIGl0IGlzIHN3aXRjaGVkIG9mZi4gSnVzdCBiZWZvcmUgdGhlIGV2ZW50IGlzIHJhaXNlZCxcbiAqIDxjb2RlPmlzU3dpdGNoZWRPZmY8L2NvZGU+IGlzIHNldCB0byA8Y29kZT5mYWxzZTwvY29kZT4gYW5kIDxjb2RlPnN3aXRjaE9mZlJlYXNvbjwvY29kZT5cbiAqIGlzIHNldCB0byA8Y29kZT5udWxsPC9jb2RlPi4gQWxzbywgaWYgdGhlIHtAbGluayBSZW1vdGVUcmFja30gcmVjZWl2ZXMgZWl0aGVyIGF1ZGlvIG9yIHZpZGVvXG4gKiBtZWRpYSx0aGUgPGNvZGU+bWVkaWFTdHJlYW1UcmFjazwvY29kZT4gcHJvcGVydHkgaXMgc2V0IHRvIGEgTWVkaWFTdHJlYW1UcmFjayB0aGF0IGlzIHRoZVxuICogc291cmNlIG9mIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9J3MgbWVkaWEuXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrfSB0cmFjayAtIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHN3aXRjaGVkIG9uXG4gKiBAZXZlbnQgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiN0cmFja1N3aXRjaGVkT25cbiAqL1xuLyoqXG4gKiBZb3VyIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSB1bnN1YnNjcmliZWQgZnJvbSB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfS5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCB3YXMgdW5zdWJzY3JpYmVkIGZyb21cbiAqIEBldmVudCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uI3Vuc3Vic2NyaWJlZFxuICovXG4vKipcbiAqIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBvcHRpb25zXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBSZW1vdGVUcmFja1B1YmxpY2F0aW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtMb2dMZXZlbHxMb2dMZXZlbHN9IGxvZ0xldmVsIC0gTG9nIGxldmVsIGZvciAnbWVkaWEnIG1vZHVsZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVUcmFja1B1YmxpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RldHJhY2twdWJsaWNhdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIG1peGluUmVtb3RlTWVkaWFUcmFjayA9IHJlcXVpcmUoJy4vcmVtb3RlbWVkaWF0cmFjaycpO1xudmFyIFZpZGVvVHJhY2sgPSByZXF1aXJlKCcuL3ZpZGVvdHJhY2snKTtcbnZhciBkb2N1bWVudFZpc2liaWxpdHlNb25pdG9yID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb2N1bWVudHZpc2liaWxpdHltb25pdG9yLmpzJyk7XG52YXIgTnVsbE9ic2VydmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udWxsb2JzZXJ2ZXIuanMnKS5OdWxsT2JzZXJ2ZXI7XG52YXIgVGltZW91dCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdGltZW91dCcpO1xudmFyIFJlbW90ZU1lZGlhVmlkZW9UcmFjayA9IG1peGluUmVtb3RlTWVkaWFUcmFjayhWaWRlb1RyYWNrKTtcbnZhciBUUkFDS19UVVJOX09GX0RFTEFZX01TID0gNTA7XG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHJlcHJlc2VudHMgYSB7QGxpbmsgVmlkZW9UcmFja30gcHVibGlzaGVkIHRvIGFcbiAqIHtAbGluayBSb29tfSBieSBhIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0uXG4gKiBAZXh0ZW5kcyBWaWRlb1RyYWNrXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzRW5hYmxlZCAtIDxjb2RlPkRlcHJlY2F0ZWQ6IFVzZSAoLnN3aXRjaE9mZlJlYXNvbiAhPT0gXCJkaXNhYmxlZC1ieS1wdWJsaXNoZXJcIikgaW5zdGVhZDwvY29kZT5cbiAqICAgV2hldGhlciB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IGlzIGVuYWJsZWQgKERlcHJlY2F0ZWQgb25seSBmb3IgbGFyZ2UgZ3JvdXAgUm9vbXMpXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU3dpdGNoZWRPZmYgLSBXaGV0aGVyIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gaXMgc3dpdGNoZWQgb2ZmXG4gKiBAcHJvcGVydHkgez9UcmFja1N3aXRjaE9mZlJlYXNvbn0gc3dpdGNoT2ZmUmVhc29uIC0gVGhlIHJlYXNvbiBmb3IgdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSBiZWluZyBzd2l0Y2hlZCBvZmY7XG4gKiAgIElmIHN3aXRjaGVkIG9uLCBpdCBpcyBzZXQgdG8gPGNvZGU+bnVsbDwvY29kZT47IFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gaXMgaW5pdGlhbGx5IHN3aXRjaGVkIG9mZiB3aXRoIHRoaXNcbiAqICAgcHJvcGVydHkgc2V0IHRvIDxjb2RlPmRpc2FibGVkLWJ5LXN1YnNjcmliZXI8L2NvZGU+ICogQHByb3BlcnR5IHtUcmFjay5TSUR9IHNpZCAtIFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30ncyBTSURcbiAqIEBwcm9wZXJ0eSB7P1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eSAtIFRoZSBzdWJzY3JpYmUgcHJpb3JpdHkgb2YgdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfVxuICogQGVtaXRzIFJlbW90ZVZpZGVvVHJhY2sjZGltZW5zaW9uc0NoYW5nZWRcbiAqIEBlbWl0cyBSZW1vdGVWaWRlb1RyYWNrI2Rpc2FibGVkXG4gKiBAZW1pdHMgUmVtb3RlVmlkZW9UcmFjayNlbmFibGVkXG4gKiBAZW1pdHMgUmVtb3RlVmlkZW9UcmFjayNzdGFydGVkXG4gKiBAZW1pdHMgUmVtb3RlVmlkZW9UcmFjayNzd2l0Y2hlZE9mZlxuICogQGVtaXRzIFJlbW90ZVZpZGVvVHJhY2sjc3dpdGNoZWRPblxuICovXG52YXIgUmVtb3RlVmlkZW9UcmFjayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVtb3RlVmlkZW9UcmFjaywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30uXG4gICAgICogQHBhcmFtIHtUcmFjay5TSUR9IHNpZCAtIFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30ncyBTSURcbiAgICAgKiBAcGFyYW0gez9NZWRpYVRyYWNrUmVjZWl2ZXJ9IG1lZGlhVHJhY2tSZWNlaXZlciAtIEEgdmlkZW8gTWVkaWFTdHJlYW1UcmFjayBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRW5hYmxlZCAtIHdoZXRoZXIgdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSBpcyBlbmFibGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1N3aXRjaGVkT2ZmIC0gV2hldGhlciB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IGlzIHN3aXRjaGVkIG9mZlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gc3dpdGNoT2ZmUmVhc29uIC0gVGhlIHJlYXNvbiB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IGlzIHN3aXRjaGVkIG9mZlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP1RyYWNrLlByaW9yaXR5KTogdm9pZH0gc2V0UHJpb3JpdHkgLSBTZXQgb3IgY2xlYXIgdGhlIHN1YnNjcmliZVxuICAgICAqICB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IG9mIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKENsaWVudFJlbmRlckhpbnQpOiB2b2lkfSBzZXRSZW5kZXJIaW50IC0gU2V0IHJlbmRlciBoaW50cy5cbiAgICAgKiBAcGFyYW0ge3tsb2c6IExvZywgbmFtZTogc3RyaW5nfX0gb3B0aW9ucyAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZW1vdGVWaWRlb1RyYWNrKHNpZCwgbWVkaWFUcmFja1JlY2VpdmVyLCBpc0VuYWJsZWQsIGlzU3dpdGNoZWRPZmYsIHN3aXRjaE9mZlJlYXNvbiwgc2V0UHJpb3JpdHksIHNldFJlbmRlckhpbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sOiAnYXV0bycsXG4gICAgICAgICAgICBjb250ZW50UHJlZmVyZW5jZXNNb2RlOiAnYXV0bycsXG4gICAgICAgICAgICBlbmFibGVEb2N1bWVudFZpc2liaWxpdHlUdXJuT2ZmOiB0cnVlXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBJbnRlcnNlY3Rpb25PYnNlcnZlcjogdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAndW5kZWZpbmVkJyB8fCBvcHRpb25zLmNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCAhPT0gJ2F1dG8nID8gTnVsbE9ic2VydmVyIDogSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsXG4gICAgICAgICAgICBSZXNpemVPYnNlcnZlcjogdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAndW5kZWZpbmVkJyB8fCBvcHRpb25zLmNvbnRlbnRQcmVmZXJlbmNlc01vZGUgIT09ICdhdXRvJyA/IE51bGxPYnNlcnZlciA6IFJlc2l6ZU9ic2VydmVyXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICd2aWRlbycsIHNpZCwgbWVkaWFUcmFja1JlY2VpdmVyLCBpc0VuYWJsZWQsIGlzU3dpdGNoZWRPZmYsIHN3aXRjaE9mZlJlYXNvbiwgc2V0UHJpb3JpdHksIHNldFJlbmRlckhpbnQsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfZW5hYmxlRG9jdW1lbnRWaXNpYmlsaXR5VHVybk9mZjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmVuYWJsZURvY3VtZW50VmlzaWJpbGl0eVR1cm5PZmYgPT09IHRydWUgJiYgb3B0aW9ucy5jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgPT09ICdhdXRvJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZG9jdW1lbnRWaXNpYmlsaXR5VHVybk9mZkNsZWFudXA6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NvbnRlbnRQcmVmZXJlbmNlc01vZGU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5jb250ZW50UHJlZmVyZW5jZXNNb2RlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pbnZpc2libGVFbGVtZW50czoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgV2Vha1NldCgpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9lbFRvUGlwQ2FsbGJhY2tzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBXZWFrTWFwKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2VsVG9QaXBXaW5kb3dzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBXZWFrTWFwKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3R1cm5PZmZUaW1lcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgVGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRSZW5kZXJIaW50KHsgZW5hYmxlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfSwgVFJBQ0tfVFVSTl9PRl9ERUxBWV9NUywgZmFsc2UpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZXNpemVPYnNlcnZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgb3B0aW9ucy5SZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogd2UgaWdub3JlIGVsZW1lbnRzIGluIF9pbnZpc2libGVFbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyB0byBlbnN1cmUgdGhhdCBSZXNpemVPYnNlcnZlciBkb2VzIG5vdCBlbmQtdXAgdHVybmluZyBvZmYgYSB0cmFjayB3aGVuIGEgZnJlc2ggVmlkZW8gZWxlbWVudCBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBhdHRhY2hlZCBhbmQgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaGFzIG5vdCBoYWQgaXRzIGNhbGxiYWNrIGV4ZWN1dGVkIHlldC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpc2libGVFbGVtZW50UmVzaXplZCA9IGVudHJpZXMuZmluZChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuICFfdGhpcy5faW52aXNpYmxlRWxlbWVudHMuaGFzKGVudHJ5LnRhcmdldCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaWJsZUVsZW1lbnRSZXNpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVVwZGF0ZURpbWVuc2lvbkhpbnQoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW50ZXJzZWN0aW9uT2JzZXJ2ZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IG9wdGlvbnMuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNob3VsZFNldFJlbmRlckhpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhc1Zpc2libGUgPSAhX3RoaXMuX2ludmlzaWJsZUVsZW1lbnRzLmhhcyhlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhc1Zpc2libGUgIT09IGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoJ2ludGVyc2VjdGlvbk9ic2VydmVyIGRldGVjdGVkOiBPZmYgPT4gT24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2ludmlzaWJsZUVsZW1lbnRzLmRlbGV0ZShlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZygnaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgZGV0ZWN0ZWQ6IE9uID0+IE9mZicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW52aXNpYmxlRWxlbWVudHMuYWRkKGVudHJ5LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFNldFJlbmRlckhpbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFNldFJlbmRlckhpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlVXBkYXRlRW5hYmxlZEhpbnQoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB2aXNpYmlsaXR5IG9mIGFuIGVsZW1lbnQgY2hhbmdlcyB0aGF0IG1heSBjYXVzZSB0aGUgXCJiaWdnZXN0XCIgZWxlbWVudCB0byBjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZGltZW5zaW9ucyBhcyB3ZWxsLiBzaW5jZSBkaW1lbnNpb25zIGFyZSBjYWNoZWQgYW5kIGRlLWR1cGVkIGF0IHNpZ25hbGluZyBsYXllcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0cyBva2F5IGlmIHRoZXkgZ290ICByZXNlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVVwZGF0ZURpbWVuc2lvbkhpbnQoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IDAuMjUgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVtb3RlVmlkZW9UcmFjay5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKGR1bW15RWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuX3N0YXJ0LmNhbGwodGhpcywgZHVtbXlFbCk7XG4gICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBhZnRlciBlbWl0dGluZyBzdGFydGVkLCB1cGRhdGUgdHVybiBvZmYgdHJhY2sgaWYgbm90IHZpc2libGUuXG4gICAgICAgIG1heWJlVXBkYXRlRW5hYmxlZEhpbnQodGhpcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7P01lZGlhVHJhY2tSZWNlaXZlcn0gbWVkaWFUcmFja1JlY2VpdmVyXG4gICAgICovXG4gICAgUmVtb3RlVmlkZW9UcmFjay5wcm90b3R5cGUuX3NldE1lZGlhVHJhY2tSZWNlaXZlciA9IGZ1bmN0aW9uIChtZWRpYVRyYWNrUmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIHByb2Nlc3NvciA9IHRoaXMucHJvY2Vzc29yO1xuICAgICAgICBpZiAocHJvY2Vzc29yKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVByb2Nlc3Nvcihwcm9jZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3NldE1lZGlhVHJhY2tSZWNlaXZlci5jYWxsKHRoaXMsIG1lZGlhVHJhY2tSZWNlaXZlcik7XG4gICAgICAgIGlmIChwcm9jZXNzb3IpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkUHJvY2Vzc29yKHByb2Nlc3Nvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdG8gc3dpdGNoIG9uIGEge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9LCBUaGlzIG1ldGhvZCBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHRoZSBncm91cCByb29tcyBhbmQgb25seSB3aGVuIGNvbm5lY3RlZCB3aXRoXG4gICAgICogY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sIGluIHZpZGVvIGJhbmR3aWR0aCBwcm9maWxlIG9wdGlvbnMgc2V0IHRvICdtYW51YWwnXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgUmVtb3RlVmlkZW9UcmFjay5wcm90b3R5cGUuc3dpdGNoT24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgIT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUuIFlvdSBjYW4gY2FsbCBzd2l0Y2hPbiBvbmx5IHdoZW4gYmFuZHdpZHRoUHJvZmlsZS52aWRlby5jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgaXMgc2V0IHRvIFwibWFudWFsXCInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRSZW5kZXJIaW50KHsgZW5hYmxlZDogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHRvIHN3aXRjaCBvZmYgYSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30sIFRoaXMgbWV0aG9kIGlzIGFwcGxpY2FibGUgb25seSBmb3IgdGhlIGdyb3VwIHJvb21zIGFuZCBvbmx5IHdoZW4gY29ubmVjdGVkIHdpdGhcbiAgICAgKiBjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgaW4gdmlkZW8gYmFuZHdpZHRoIHByb2ZpbGUgb3B0aW9ucyBzZXQgdG8gJ21hbnVhbCdcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBSZW1vdGVWaWRlb1RyYWNrLnByb3RvdHlwZS5zd2l0Y2hPZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgIT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUuIFlvdSBjYW4gY2FsbCBzd2l0Y2hPZmYgb25seSB3aGVuIGJhbmR3aWR0aFByb2ZpbGUudmlkZW8uY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sIGlzIHNldCB0byBcIm1hbnVhbFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0UmVuZGVySGludCh7IGVuYWJsZWQ6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9J3MgY29udGVudCBwcmVmZXJlbmNlcy4gVGhpcyBtZXRob2QgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB0aGUgZ3JvdXAgcm9vbXMgYW5kIG9ubHkgd2hlbiBjb25uZWN0ZWQgd2l0aFxuICAgICAqIHZpZGVvQ29udGVudFByZWZlcmVuY2VzTW9kZSBpbiB2aWRlbyBiYW5kd2lkdGggcHJvZmlsZSBvcHRpb25zIHNldCB0byAnbWFudWFsJ1xuICAgICAqIEBwYXJhbSB7VmlkZW9Db250ZW50UHJlZmVyZW5jZXN9IGNvbnRlbnRQcmVmZXJlbmNlcyAtIHJlcXVlc3RlZCBwcmVmZXJlbmNlcy5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBSZW1vdGVWaWRlb1RyYWNrLnByb3RvdHlwZS5zZXRDb250ZW50UHJlZmVyZW5jZXMgPSBmdW5jdGlvbiAoY29udGVudFByZWZlcmVuY2VzKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50UHJlZmVyZW5jZXNNb2RlICE9PSAnbWFudWFsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlLiBZb3UgY2FuIGNhbGwgc3dpdGNoT24gb25seSB3aGVuIGJhbmR3aWR0aFByb2ZpbGUudmlkZW8uY29udGVudFByZWZlcmVuY2VzTW9kZSBpcyBzZXQgdG8gXCJtYW51YWxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50UHJlZmVyZW5jZXMucmVuZGVyRGltZW5zaW9ucykge1xuICAgICAgICAgICAgdGhpcy5fc2V0UmVuZGVySGludCh7IHJlbmRlckRpbWVuc2lvbnM6IGNvbnRlbnRQcmVmZXJlbmNlcy5yZW5kZXJEaW1lbnNpb25zIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUmVtb3RlVmlkZW9UcmFjay5wcm90b3R5cGUuX3VuT2JzZXJ2ZVBpcCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgcGlwQ2FsbGJhY2tzID0gdGhpcy5fZWxUb1BpcENhbGxiYWNrcy5nZXQoZWwpO1xuICAgICAgICBpZiAocGlwQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbnRlcnBpY3R1cmVpbnBpY3R1cmUnLCBwaXBDYWxsYmFja3Mub25FbnRlclBpcCk7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdsZWF2ZXBpY3R1cmVpbnBpY3R1cmUnLCBwaXBDYWxsYmFja3Mub25MZWF2ZVBpcCk7XG4gICAgICAgICAgICB0aGlzLl9lbFRvUGlwQ2FsbGJhY2tzLmRlbGV0ZShlbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbW90ZVZpZGVvVHJhY2sucHJvdG90eXBlLl9vYnNlcnZlUGlwID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwaXBDYWxsYmFja3MgPSB0aGlzLl9lbFRvUGlwQ2FsbGJhY2tzLmdldChlbCk7XG4gICAgICAgIGlmICghcGlwQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB2YXIgb25FbnRlclBpcCA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuX29uRW50ZXJQaXAoZXZlbnQsIGVsKTsgfTtcbiAgICAgICAgICAgIHZhciBvbkxlYXZlUGlwID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5fb25MZWF2ZVBpcChldmVudCwgZWwpOyB9O1xuICAgICAgICAgICAgdmFyIG9uUmVzaXplUGlwID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5fb25SZXNpemVQaXAoZXZlbnQsIGVsKTsgfTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2VudGVycGljdHVyZWlucGljdHVyZScsIG9uRW50ZXJQaXApO1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbGVhdmVwaWN0dXJlaW5waWN0dXJlJywgb25MZWF2ZVBpcCk7XG4gICAgICAgICAgICB0aGlzLl9lbFRvUGlwQ2FsbGJhY2tzLnNldChlbCwgeyBvbkVudGVyUGlwOiBvbkVudGVyUGlwLCBvbkxlYXZlUGlwOiBvbkxlYXZlUGlwLCBvblJlc2l6ZVBpcDogb25SZXNpemVQaXAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbW90ZVZpZGVvVHJhY2sucHJvdG90eXBlLl9vbkVudGVyUGlwID0gZnVuY3Rpb24gKGV2ZW50LCB2aWRlb0VsKSB7XG4gICAgICAgIHRoaXMuX2xvZy5kZWJ1Zygnb25FbnRlclBpcCcpO1xuICAgICAgICB2YXIgcGlwV2luZG93ID0gZXZlbnQucGljdHVyZUluUGljdHVyZVdpbmRvdztcbiAgICAgICAgdGhpcy5fZWxUb1BpcFdpbmRvd3Muc2V0KHZpZGVvRWwsIHBpcFdpbmRvdyk7XG4gICAgICAgIHZhciBvblJlc2l6ZVBpcCA9IHRoaXMuX2VsVG9QaXBDYWxsYmFja3MuZ2V0KHZpZGVvRWwpLm9uUmVzaXplUGlwO1xuICAgICAgICBwaXBXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemVQaXApO1xuICAgICAgICBtYXliZVVwZGF0ZUVuYWJsZWRIaW50KHRoaXMpO1xuICAgIH07XG4gICAgUmVtb3RlVmlkZW9UcmFjay5wcm90b3R5cGUuX29uTGVhdmVQaXAgPSBmdW5jdGlvbiAoZXZlbnQsIHZpZGVvRWwpIHtcbiAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdvbkxlYXZlUGlwJyk7XG4gICAgICAgIHRoaXMuX2VsVG9QaXBXaW5kb3dzLmRlbGV0ZSh2aWRlb0VsKTtcbiAgICAgICAgdmFyIG9uUmVzaXplUGlwID0gdGhpcy5fZWxUb1BpcENhbGxiYWNrcy5nZXQodmlkZW9FbCkub25SZXNpemVQaXA7XG4gICAgICAgIHZhciBwaXBXaW5kb3cgPSBldmVudC5waWN0dXJlSW5QaWN0dXJlV2luZG93O1xuICAgICAgICBwaXBXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemVQaXApO1xuICAgICAgICBtYXliZVVwZGF0ZUVuYWJsZWRIaW50KHRoaXMpO1xuICAgIH07XG4gICAgUmVtb3RlVmlkZW9UcmFjay5wcm90b3R5cGUuX29uUmVzaXplUGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtYXliZVVwZGF0ZURpbWVuc2lvbkhpbnQodGhpcyk7XG4gICAgfTtcbiAgICBSZW1vdGVWaWRlb1RyYWNrLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuYXR0YWNoLmNhbGwodGhpcywgZWwpO1xuICAgICAgICBpZiAodGhpcy5fY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IG9mZiB0aGUgZWxlbWVudCBhcyBpbnZpc2libGUuIHdpbGwgbWFyayBpdFxuICAgICAgICAgICAgLy8gdmlzaWJsZSAoYW5kIHVwZGF0ZSByZW5kZXIgaGludHMpIG9uY2UgaW50ZXJzZWN0aW9uIG9ic2VydmVyIGNhbGxzIGJhY2suXG4gICAgICAgICAgICB0aGlzLl9pbnZpc2libGVFbGVtZW50cy5hZGQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKHJlc3VsdCk7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVzdWx0KTtcbiAgICAgICAgaWYgKHRoaXMuX2VuYWJsZURvY3VtZW50VmlzaWJpbGl0eVR1cm5PZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvY3VtZW50VmlzaWJpbGl0eVR1cm5PZmZDbGVhbnVwID0gdGhpcy5fZG9jdW1lbnRWaXNpYmlsaXR5VHVybk9mZkNsZWFudXAgfHwgc2V0dXBEb2N1bWVudFZpc2liaWxpdHlUdXJuT2ZmKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29ic2VydmVQaXAocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFJlbW90ZVZpZGVvVHJhY2sucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5kZXRhY2guY2FsbCh0aGlzLCBlbCk7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IEFycmF5LmlzQXJyYXkocmVzdWx0KSA/IHJlc3VsdCA6IFtyZXN1bHRdO1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5faW50ZXJzZWN0aW9uT2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgX3RoaXMuX3Jlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIF90aGlzLl9pbnZpc2libGVFbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICBfdGhpcy5fdW5PYnNlcnZlUGlwKGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2F0dGFjaG1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kb2N1bWVudFZpc2liaWxpdHlUdXJuT2ZmQ2xlYW51cCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvY3VtZW50VmlzaWJpbGl0eVR1cm5PZmZDbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnRWaXNpYmlsaXR5VHVybk9mZkNsZWFudXAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1heWJlVXBkYXRlRW5hYmxlZEhpbnQodGhpcyk7XG4gICAgICAgIG1heWJlVXBkYXRlRGltZW5zaW9uSGludCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIHtAbGluayBWaWRlb1Byb2Nlc3Nvcn0gdG8gYWxsb3cgZm9yIGN1c3RvbSBwcm9jZXNzaW5nIG9mIHZpZGVvIGZyYW1lcyBiZWxvbmdpbmcgdG8gYSBWaWRlb1RyYWNrLlxuICAgICAqIFdoZW4gYSBQYXJ0aWNpcGFudCB1bi1wdWJsaXNoZXMgYW5kIHJlLXB1Ymxpc2hlcyBhIFZpZGVvVHJhY2ssIGEgbmV3IFJlbW90ZVZpZGVvVHJhY2sgaXMgY3JlYXRlZCBhbmRcbiAgICAgKiBhbnkgVmlkZW9Qcm9jZXNzb3JzIGF0dGFjaGVkIHRvIHRoZSBwcmV2aW91cyBSZW1vdGVWaWRlb1RyYWNrIHdvdWxkIGhhdmUgdG8gYmUgcmUtYWRkZWQgYWdhaW4uXG4gICAgICogT25seSBDaHJvbWUgc3VwcG9ydHMgdGhpcyBhcyBvZiBub3cuIENhbGxpbmcgdGhpcyBBUEkgZnJvbSBhIG5vbi1zdXBwb3J0ZWQgYnJvd3NlciB3aWxsIHJlc3VsdCBpbiBhIGxvZyB3YXJuaW5nLlxuICAgICAqIEBwYXJhbSB7VmlkZW9Qcm9jZXNzb3J9IHByb2Nlc3NvciAtIFRoZSB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9IHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNsYXNzIEdyYXlTY2FsZVByb2Nlc3NvciB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwZXJjZW50YWdlKSB7XG4gICAgICogICAgIHRoaXMucGVyY2VudGFnZSA9IHBlcmNlbnRhZ2U7XG4gICAgICogICB9XG4gICAgICogICBwcm9jZXNzRnJhbWUoaW5wdXRGcmFtZUJ1ZmZlciwgb3V0cHV0RnJhbWVCdWZmZXIpIHtcbiAgICAgKiAgICAgY29uc3QgY29udGV4dCA9IG91dHB1dEZyYW1lQnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICogICAgIGNvbnRleHQuZmlsdGVyID0gYGdyYXlzY2FsZSgke3RoaXMucGVyY2VudGFnZX0lKWA7XG4gICAgICogICAgIGNvbnRleHQuZHJhd0ltYWdlKGlucHV0RnJhbWVCdWZmZXIsIDAsIDAsIGlucHV0RnJhbWVCdWZmZXIud2lkdGgsIGlucHV0RnJhbWVCdWZmZXIuaGVpZ2h0KTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBjb25zdCBncmF5c2NhbGVQcm9jZXNzb3IgPSBuZXcgR3JheVNjYWxlUHJvY2Vzc29yKDEwMCk7XG4gICAgICpcbiAgICAgKiBBcnJheS5mcm9tKHJvb20ucGFydGljaXBhbnRzLnZhbHVlcygpKS5mb3JFYWNoKHBhcnRpY2lwYW50ID0+IHtcbiAgICAgKiAgIGNvbnN0IHJlbW90ZVZpZGVvVHJhY2sgPSBBcnJheS5mcm9tKHBhcnRpY2lwYW50LnZpZGVvVHJhY2tzLnZhbHVlcygpKVswXS50cmFjaztcbiAgICAgKiAgIHJlbW90ZVZpZGVvVHJhY2suYWRkUHJvY2Vzc29yKGdyYXlzY2FsZVByb2Nlc3Nvcik7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgUmVtb3RlVmlkZW9UcmFjay5wcm90b3R5cGUuYWRkUHJvY2Vzc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5hZGRQcm9jZXNzb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgcHJldmlvdXNseSBhZGRlZCB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9IHVzaW5nIGBhZGRQcm9jZXNzb3JgIEFQSS5cbiAgICAgKiBAcGFyYW0ge1ZpZGVvUHJvY2Vzc29yfSBwcm9jZXNzb3IgLSBUaGUge0BsaW5rIFZpZGVvUHJvY2Vzc29yfSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjbGFzcyBHcmF5U2NhbGVQcm9jZXNzb3Ige1xuICAgICAqICAgY29uc3RydWN0b3IocGVyY2VudGFnZSkge1xuICAgICAqICAgICB0aGlzLnBlcmNlbnRhZ2UgPSBwZXJjZW50YWdlO1xuICAgICAqICAgfVxuICAgICAqICAgcHJvY2Vzc0ZyYW1lKGlucHV0RnJhbWVCdWZmZXIsIG91dHB1dEZyYW1lQnVmZmVyKSB7XG4gICAgICogICAgIGNvbnN0IGNvbnRleHQgPSBvdXRwdXRGcmFtZUJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAqICAgICBjb250ZXh0LmZpbHRlciA9IGBncmF5c2NhbGUoJHt0aGlzLnBlcmNlbnRhZ2V9JSlgO1xuICAgICAqICAgICBjb250ZXh0LmRyYXdJbWFnZShpbnB1dEZyYW1lQnVmZmVyLCAwLCAwLCBpbnB1dEZyYW1lQnVmZmVyLndpZHRoLCBpbnB1dEZyYW1lQnVmZmVyLmhlaWdodCk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3QgZ3JheXNjYWxlUHJvY2Vzc29yID0gbmV3IEdyYXlTY2FsZVByb2Nlc3NvcigxMDApO1xuICAgICAqXG4gICAgICogQXJyYXkuZnJvbShyb29tLnBhcnRpY2lwYW50cy52YWx1ZXMoKSkuZm9yRWFjaChwYXJ0aWNpcGFudCA9PiB7XG4gICAgICogICBjb25zdCByZW1vdGVWaWRlb1RyYWNrID0gQXJyYXkuZnJvbShwYXJ0aWNpcGFudC52aWRlb1RyYWNrcy52YWx1ZXMoKSlbMF0udHJhY2s7XG4gICAgICogICByZW1vdGVWaWRlb1RyYWNrLmFkZFByb2Nlc3NvcihncmF5c2NhbGVQcm9jZXNzb3IpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlbW92ZS1idXR0b24nKS5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAqICAgQXJyYXkuZnJvbShyb29tLnBhcnRpY2lwYW50cy52YWx1ZXMoKSkuZm9yRWFjaChwYXJ0aWNpcGFudCA9PiB7XG4gICAgICogICAgIGNvbnN0IHJlbW90ZVZpZGVvVHJhY2sgPSBBcnJheS5mcm9tKHBhcnRpY2lwYW50LnZpZGVvVHJhY2tzLnZhbHVlcygpKVswXS50cmFjaztcbiAgICAgKiAgICAgcmVtb3RlVmlkZW9UcmFjay5yZW1vdmVQcm9jZXNzb3IoZ3JheXNjYWxlUHJvY2Vzc29yKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBSZW1vdGVWaWRlb1RyYWNrLnByb3RvdHlwZS5yZW1vdmVQcm9jZXNzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlbW92ZVByb2Nlc3Nvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgUmVtb3RlVmlkZW9UcmFjay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltSZW1vdGVWaWRlb1RyYWNrICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyBcIjogXCIgKyB0aGlzLnNpZCArIFwiXVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzdWJzY3JpYmUge0BsaW5rIFRyYWNrLlByaW9yaXR5fSBvZiB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9LlxuICAgICAqIEBwYXJhbSB7P1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eSAtIHRoZSBuZXcgc3Vic2NyaWJlIHtAbGluayBUcmFjay5Qcmlvcml0eX07XG4gICAgICogICBJZiA8Y29kZT5udWxsPC9jb2RlPiwgdGhlbiB0aGUgc3Vic2NyaWJlIHtAbGluayBUcmFjay5Qcmlvcml0eX0gaXMgY2xlYXJlZCwgd2hpY2hcbiAgICAgKiAgIG1lYW5zIHRoZSB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IHNldCBieSB0aGUgcHVibGlzaGVyIGlzIG5vdyB0aGUgZWZmZWN0aXZlIHByaW9yaXR5LlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9XG4gICAgICovXG4gICAgUmVtb3RlVmlkZW9UcmFjay5wcm90b3R5cGUuc2V0UHJpb3JpdHkgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc2V0UHJpb3JpdHkuY2FsbCh0aGlzLCBwcmlvcml0eSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVtb3RlVmlkZW9UcmFjaztcbn0oUmVtb3RlTWVkaWFWaWRlb1RyYWNrKSk7XG5mdW5jdGlvbiBzZXR1cERvY3VtZW50VmlzaWJpbGl0eVR1cm5PZmYocmVtb3ZlVmlkZW9UcmFjaykge1xuICAgIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgICAgIG1heWJlVXBkYXRlRW5hYmxlZEhpbnQocmVtb3ZlVmlkZW9UcmFjayk7XG4gICAgfVxuICAgIGRvY3VtZW50VmlzaWJpbGl0eU1vbml0b3Iub25WaXNpYmlsaXR5Q2hhbmdlKDEsIG9uVmlzaWJpbGl0eUNoYW5nZWQpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50VmlzaWJpbGl0eU1vbml0b3Iub2ZmVmlzaWJpbGl0eUNoYW5nZSgxLCBvblZpc2liaWxpdHlDaGFuZ2VkKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWF5YmVVcGRhdGVFbmFibGVkSGludChyZW1vdGVWaWRlb1RyYWNrKSB7XG4gICAgaWYgKHJlbW90ZVZpZGVvVHJhY2suX2NsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCAhPT0gJ2F1dG8nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHZpc2libGVFbGVtZW50cyA9IHJlbW90ZVZpZGVvVHJhY2suX2dldEFsbEF0dGFjaGVkRWxlbWVudHMoKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhcmVtb3RlVmlkZW9UcmFjay5faW52aXNpYmxlRWxlbWVudHMuaGFzKGVsKTsgfSk7XG4gICAgdmFyIHBpcFdpbmRvd3MgPSByZW1vdGVWaWRlb1RyYWNrLl9nZXRBbGxBdHRhY2hlZEVsZW1lbnRzKCkuZmlsdGVyKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gcmVtb3RlVmlkZW9UcmFjay5fZWxUb1BpcFdpbmRvd3MuaGFzKGVsKTsgfSk7XG4gICAgLy8gZXZlbiB3aGVuIGRvY3VtZW50IGlzIGludmlzaWJsZSB3ZSBtYXkgaGF2ZSB0cmFjayBwbGF5aW5nIGluIHBpcCB3aW5kb3cuXG4gICAgdmFyIGVuYWJsZWQgPSBwaXBXaW5kb3dzLmxlbmd0aCA+IDAgfHwgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnICYmIHZpc2libGVFbGVtZW50cy5sZW5ndGggPiAwKTtcbiAgICBpZiAoZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZW1vdGVWaWRlb1RyYWNrLl90dXJuT2ZmVGltZXIuY2xlYXIoKTtcbiAgICAgICAgcmVtb3RlVmlkZW9UcmFjay5fc2V0UmVuZGVySGludCh7IGVuYWJsZWQ6IHRydWUgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFyZW1vdGVWaWRlb1RyYWNrLl90dXJuT2ZmVGltZXIuaXNTZXQpIHtcbiAgICAgICAgLy8gc2V0IHRoZSB0cmFjayB0byBiZSB0dXJuZWQgb2ZmIGFmdGVyIHNvbWUgZGVsYXkuXG4gICAgICAgIHJlbW90ZVZpZGVvVHJhY2suX3R1cm5PZmZUaW1lci5zdGFydCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1heWJlVXBkYXRlRGltZW5zaW9uSGludChyZW1vdGVWaWRlb1RyYWNrKSB7XG4gICAgaWYgKHJlbW90ZVZpZGVvVHJhY2suX2NvbnRlbnRQcmVmZXJlbmNlc01vZGUgIT09ICdhdXRvJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB2aXNpYmxlRWxlbWVudHMgPSByZW1vdGVWaWRlb1RyYWNrLl9nZXRBbGxBdHRhY2hlZEVsZW1lbnRzKCkuZmlsdGVyKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gIXJlbW90ZVZpZGVvVHJhY2suX2ludmlzaWJsZUVsZW1lbnRzLmhhcyhlbCk7IH0pO1xuICAgIHZhciBwaXBFbGVtZW50cyA9IHJlbW90ZVZpZGVvVHJhY2suX2dldEFsbEF0dGFjaGVkRWxlbWVudHMoKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBwaXBXaW5kb3cgPSByZW1vdGVWaWRlb1RyYWNrLl9lbFRvUGlwV2luZG93cy5nZXQoZWwpO1xuICAgICAgICByZXR1cm4gcGlwV2luZG93ID8geyBjbGllbnRIZWlnaHQ6IHBpcFdpbmRvdy5oZWlnaHQsIGNsaWVudFdpZHRoOiBwaXBXaW5kb3cud2lkdGggfSA6IHsgY2xpZW50SGVpZ2h0OiAwLCBjbGllbnRXaWR0aDogMCB9O1xuICAgIH0pO1xuICAgIHZhciB0b3RhbEVsZW1lbnRzID0gdmlzaWJsZUVsZW1lbnRzLmNvbmNhdChwaXBFbGVtZW50cyk7XG4gICAgaWYgKHRvdGFsRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQodG90YWxFbGVtZW50cy5zb3J0KGZ1bmN0aW9uIChlbDEsIGVsMikge1xuICAgICAgICAgICAgcmV0dXJuIGVsMi5jbGllbnRIZWlnaHQgKyBlbDIuY2xpZW50V2lkdGggLSBlbDEuY2xpZW50SGVpZ2h0IC0gZWwxLmNsaWVudFdpZHRoIC0gMTtcbiAgICAgICAgfSksIDEpLCBfYiA9IF9hWzBdLCBjbGllbnRIZWlnaHQgPSBfYi5jbGllbnRIZWlnaHQsIGNsaWVudFdpZHRoID0gX2IuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciByZW5kZXJEaW1lbnNpb25zID0geyBoZWlnaHQ6IGNsaWVudEhlaWdodCwgd2lkdGg6IGNsaWVudFdpZHRoIH07XG4gICAgICAgIHJlbW90ZVZpZGVvVHJhY2suX3NldFJlbmRlckhpbnQoeyByZW5kZXJEaW1lbnNpb25zOiByZW5kZXJEaW1lbnNpb25zIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVmlkZW9Db250ZW50UHJlZmVyZW5jZXNcbiAqIEBwcm9wZXJ0eSB7VmlkZW9UcmFjay5EaW1lbnNpb25zfSBbcmVuZGVyRGltZW5zaW9uc10gLSBSZW5kZXIgRGltZW5zaW9ucyB0byByZXF1ZXN0IGZvciB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9LlxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30ncyBkaW1lbnNpb25zIGNoYW5nZWQuXG4gKiBAcGFyYW0ge1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB3aG9zZVxuICogICBkaW1lbnNpb25zIGNoYW5nZWRcbiAqIEBldmVudCBSZW1vdGVWaWRlb1RyYWNrI2RpbWVuc2lvbnNDaGFuZ2VkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB3YXMgZGlzYWJsZWQsIGkuZS4gXCJwYXVzZWRcIiAoRGVwcmVjYXRlZCBvbmx5IGZvciBsYXJnZSBncm91cCBSb29tcykuXG4gKiBAZGVwcmVjYXRlZCBVc2UgPGEgaHJlZj1cIiNldmVudDpzd2l0Y2hlZE9mZlwiPjxjb2RlPnN3aXRjaGVkT2ZmPC9jb2RlPjwvYT4gKDxjb2RlPi5zd2l0Y2hPZmZSZWFzb24gPT09IFwiZGlzYWJsZWQtYnktcHVibGlzaGVyXCI8L2NvZGU+KSBpbnN0ZWFkXG4gKiBAcGFyYW0ge1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB0aGF0IHdhc1xuICogICBkaXNhYmxlZFxuICogQGV2ZW50IFJlbW90ZVZpZGVvVHJhY2sjZGlzYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHdhcyBlbmFibGVkLCBpLmUuIFwicmVzdW1lZFwiIChEZXByZWNhdGVkIG9ubHkgZm9yIGxhcmdlIGdyb3VwIFJvb21zKS5cbiAqIEBkZXByZWNhdGVkIFVzZSA8YSBocmVmPVwiI2V2ZW50OnN3aXRjaGVkT25cIj48Y29kZT5zd2l0Y2hlZE9uPC9jb2RlPjwvYT4gaW5zdGVhZFxuICogQHBhcmFtIHtSZW1vdGVWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gdGhhdCB3YXNcbiAqICAgZW5hYmxlZFxuICogQGV2ZW50IFJlbW90ZVZpZGVvVHJhY2sjZW5hYmxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gc3RhcnRlZC4gVGhpcyBtZWFucyB0aGVyZSBpcyBlbm91Z2ggdmlkZW8gZGF0YVxuICogdG8gYmVnaW4gcGxheWJhY2suXG4gKiBAcGFyYW0ge1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB0aGF0IHN0YXJ0ZWRcbiAqIEBldmVudCBSZW1vdGVWaWRlb1RyYWNrI3N0YXJ0ZWRcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB3YXMgc3dpdGNoZWQgb2ZmLiBUaGUgbWVkaWEgc2VydmVyIHN0b3BzIHNlbmRpbmcgbWVkaWEgZm9yIHRoZVxuICoge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHVudGlsIGl0IGlzIHN3aXRjaGVkIGJhY2sgb24uIEp1c3QgYmVmb3JlIHRoZSBldmVudCBpcyByYWlzZWQsXG4gKiA8Y29kZT5pc1N3aXRjaGVkT2ZmPC9jb2RlPiBpcyBzZXQgdG8gPGNvZGU+dHJ1ZTwvY29kZT4gYW5kIDxjb2RlPnN3aXRjaE9mZlJlYXNvbjwvY29kZT4gaXNcbiAqIHNldCB0byBhIHtAbGluayBUcmFja1N3aXRjaE9mZlJlYXNvbn0gaW4gbGFyZ2UgZ3JvdXAgUm9vbXMgKDxjb2RlPnN3aXRjaE9mZlJlYXNvbjwvY29kZT4gaXNcbiAqIDxjb2RlPm51bGw8L2NvZGU+IG5vbi1sYXJnZSBncm91cCBSb29tcykuIEFsc28sIHRoZSA8Y29kZT5tZWRpYVN0cmVhbVRyYWNrPC9jb2RlPiBwcm9wZXJ0eVxuICogaXMgc2V0IHRvIDxjb2RlPm51bGw8L2NvZGU+IChvbmx5IGluIGxhcmdlIGdyb3VwIFJvb21zKS5cbiAqIEBwYXJhbSB7UmVtb3RlVmlkZW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHRoYXQgd2FzXG4gKiAgIHN3aXRjaGVkIG9mZlxuICogQHBhcmFtIHs/VHJhY2tTd2l0Y2hPZmZSZWFzb259IHN3aXRjaE9mZlJlYXNvbiAtIFRoZSByZWFzb24gdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfVxuICogICB3YXMgc3dpdGNoZWQgb2ZmXG4gKiBAZXZlbnQgUmVtb3RlVmlkZW9UcmFjayNzd2l0Y2hlZE9mZlxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHdhcyBzd2l0Y2hlZCBvbi5cbiAqIEBwYXJhbSB7UmVtb3RlVmlkZW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHRoYXQgd2FzXG4gKiAgIHN3aXRjaGVkIG9uXG4gKiBAZXZlbnQgUmVtb3RlVmlkZW9UcmFjayNzd2l0Y2hlZE9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlVmlkZW9UcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW90ZXZpZGVvdHJhY2suanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBSZW1vdGVUcmFja1B1YmxpY2F0aW9uID0gcmVxdWlyZSgnLi9yZW1vdGV0cmFja3B1YmxpY2F0aW9uJyk7XG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbn0gcmVwcmVzZW50cyBhIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfVxuICogdGhhdCBoYXMgYmVlbiBwdWJsaXNoZWQgdG8gYSB7QGxpbmsgUm9vbX0uXG4gKiBAcHJvcGVydHkge1RyYWNrLktpbmR9IGtpbmQgLSBcInZpZGVvXCJcbiAqIEBwcm9wZXJ0eSB7P1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gdW5sZXNzIHlvdSBoYXZlIHN1YnNjcmliZWQgdG8gdGhlXG4gKiAgIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSwgdGhpcyBwcm9wZXJ0eSBpcyBudWxsXG4gKiBAZW1pdHMgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uI3N1YnNjcmliZWRcbiAqIEBlbWl0cyBSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb24jc3Vic2NyaXB0aW9uRmFpbGVkXG4gKiBAZW1pdHMgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uI3RyYWNrRGlzYWJsZWRcbiAqIEBlbWl0cyBSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb24jdHJhY2tFbmFibGVkXG4gKiBAZW1pdHMgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uI3Vuc3Vic2NyaWJlZFxuICovXG52YXIgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbn0uXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfSBzaWduYWxpbmcgLSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gc2lnbmFsaW5nXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9uT3B0aW9uc30gb3B0aW9ucyAtIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICAgICAqICAgb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbihzaWduYWxpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNpZ25hbGluZywgb3B0aW9ucykgfHwgdGhpcztcbiAgICB9XG4gICAgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW1JlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbiAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgdGhpcy50cmFja1NpZCArIFwiXVwiO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbjtcbn0oUmVtb3RlVHJhY2tQdWJsaWNhdGlvbikpO1xuLyoqXG4gKiBZb3VyIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBzdWJzY3JpYmVkIHRvIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30uXG4gKiBAcGFyYW0ge1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB0aGF0IHdhcyBzdWJzY3JpYmVkIHRvXG4gKiBAZXZlbnQgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uI3N1YnNjcmliZWRcbiAqL1xuLyoqXG4gKiBZb3VyIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBmYWlsZWQgdG8gc3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30uXG4gKiBAcGFyYW0ge1R3aWxpb0Vycm9yfSBlcnJvciAtIHRoZSByZWFzb24gdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSBjb3VsZCBub3QgYmVcbiAqICAgc3Vic2NyaWJlZCB0b1xuICogQGV2ZW50IFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbiNzdWJzY3JpcHRpb25GYWlsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHdhcyBkaXNhYmxlZC4gSXQgaXMgZmlyZWQgb25seSBpZiA8Y29kZT4uaXNTdWJzY3JpYmVkPC9jb2RlPlxuICogaXMgc2V0IHRvIDxjb2RlPnRydWU8L2NvZGU+IChEZXByZWNhdGVkIG9ubHkgZm9yIGxhcmdlIGdyb3VwIFJvb21zKS5cbiAqIEBkZXByZWNhdGVkIFVzZSA8YSBocmVmPVwiZXZlbnQ6dHJhY2tTd2l0Y2hlZE9mZlwiPjxjb2RlPnRyYWNrU3dpdGNoZWRPZmY8L2NvZGU+PC9hPiAoPGNvZGU+dHJhY2suc3dpdGNoT2ZmUmVhc29uID09PSBcImRpc2FibGVkLWJ5LXB1Ymxpc2hlclwiPC9jb2RlPikgaW5zdGVhZFxuICogQGV2ZW50IFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbiN0cmFja0Rpc2FibGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB3YXMgZW5hYmxlZC4gSXQgaXMgZmlyZWQgb25seSBpZiA8Y29kZT4uaXNTdWJzY3JpYmVkPC9jb2RlPlxuICogaXMgc2V0IHRvIDxjb2RlPnRydWU8L2NvZGU+IChEZXByZWNhdGVkIG9ubHkgZm9yIGxhcmdlIGdyb3VwIFJvb21zKS5cbiAqIEBkZXByZWNhdGVkIFVzZSA8YSBocmVmPVwiZXZlbnQ6dHJhY2tTd2l0Y2hlZE9uXCI+PGNvZGU+dHJhY2tTd2l0Y2hlZE9uPC9jb2RlPjwvYT4gaW5zdGVhZFxuICogQGV2ZW50IFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbiN0cmFja0VuYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHdhcyBzd2l0Y2hlZCBvZmYuIFRoZSBtZWRpYSBzZXJ2ZXIgc3RvcHMgc2VuZGluZyBtZWRpYSBmb3JcbiAqIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gdW50aWwgaXQgaXMgc3dpdGNoZWQgYmFjayBvbi4gSnVzdCBiZWZvcmUgdGhlIGV2ZW50IGlzIHJhaXNlZCxcbiAqIDxjb2RlPmlzU3dpdGNoZWRPZmY8L2NvZGU+IGlzIHNldCB0byA8Y29kZT50cnVlPC9jb2RlPiBhbmQgPGNvZGU+c3dpdGNoT2ZmUmVhc29uPC9jb2RlPlxuICogaXMgc2V0IHRvIGEge0BsaW5rIFRyYWNrU3dpdGNoT2ZmUmVhc29ufSBpbiBsYXJnZSBncm91cCBSb29tcyAoPGNvZGU+c3dpdGNoT2ZmUmVhc29uPC9jb2RlPiBpc1xuICogPGNvZGU+bnVsbDwvY29kZT4gbm9uLWxhcmdlIGdyb3VwIFJvb21zKS4gQWxzbywgaWYgdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSByZWNlaXZlcyBhdWRpb1xuICogbWVkaWEsIHRoZSA8Y29kZT5tZWRpYVN0cmVhbVRyYWNrPC9jb2RlPiBwcm9wZXJ0eSBpcyBzZXQgdG8gPGNvZGU+bnVsbDwvY29kZT4uIChvbmx5IGluIGxhcmdlXG4gKiBncm91cCBSb29tcylcbiAqIEBwYXJhbSB7UmVtb3RlVmlkZW9UcmFja30gdHJhY2sgLSB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHRoYXQgd2FzIHN3aXRjaGVkIG9mZlxuICogQHBhcmFtIHs/VHJhY2tTd2l0Y2hPZmZSZWFzb259IHN3aXRjaE9mZlJlYXNvbiAtIHRoZSByZWFzb24gdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfVxuICogICB3YXMgc3dpdGNoZWQgb2ZmXG4gKiBAZXZlbnQgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uI3RyYWNrU3dpdGNoZWRPZmZcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHdhcyBzd2l0Y2hlZCBvbi4gVGhlIG1lZGlhIHNlcnZlciBzdGFydHMgc2VuZGluZyBtZWRpYSBmb3JcbiAqIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gdW50aWwgaXQgaXMgc3dpdGNoZWQgb2ZmLiBKdXN0IGJlZm9yZSB0aGUgZXZlbnQgaXMgcmFpc2VkLFxuICogPGNvZGU+aXNTd2l0Y2hlZE9mZjwvY29kZT4gaXMgc2V0IHRvIDxjb2RlPmZhbHNlPC9jb2RlPiBhbmQgPGNvZGU+c3dpdGNoT2ZmUmVhc29uPC9jb2RlPlxuICogaXMgc2V0IHRvIDxjb2RlPm51bGw8L2NvZGU+LiBBbHNvLCB0aGUgPGNvZGU+bWVkaWFTdHJlYW1UcmFjazwvY29kZT4gcHJvcGVydHkgaXMgc2V0IHRvIGFcbiAqIE1lZGlhU3RyZWFtVHJhY2sgdGhhdCBpcyB0aGUgc291cmNlIG9mIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30ncyBtZWRpYS5cbiAqIEBwYXJhbSB7UmVtb3RlVmlkZW9UcmFja30gdHJhY2sgLSB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHRoYXQgd2FzIHN3aXRjaGVkIG9uXG4gKiBAZXZlbnQgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uI3RyYWNrU3dpdGNoZWRPblxuICovXG4vKipcbiAqIFlvdXIge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IHVuc3Vic2NyaWJlZCBmcm9tIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30uXG4gKiBAcGFyYW0ge1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB0aGF0IHdhcyB1bnN1YnNjcmliZWQgZnJvbVxuICogQGV2ZW50IFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbiN1bnN1YnNjcmliZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdGV2aWRlb3RyYWNrcHVibGljYXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBNZWRpYVRyYWNrVHJhbnNjZWl2ZXIgPSByZXF1aXJlKCcuL3RyYW5zY2VpdmVyJyk7XG4vKipcbiAqIEEge0BsaW5rIE1lZGlhVHJhY2tTZW5kZXJ9IHJlcHJlc2VudHMgb25lIG9yIG1vcmUgbG9jYWwgUlRDUnRwU2VuZGVycy5cbiAqIEBleHRlbmRzIE1lZGlhVHJhY2tUcmFuc2NlaXZlclxuICogQGVtaXRzIE1lZGlhVHJhY2tTZW5kZXIjcmVwbGFjZWRcbiAqL1xudmFyIE1lZGlhVHJhY2tTZW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lZGlhVHJhY2tTZW5kZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIE1lZGlhVHJhY2tTZW5kZXJ9LlxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gbWVkaWFTdHJlYW1UcmFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1lZGlhVHJhY2tTZW5kZXIobWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZWRpYVN0cmVhbVRyYWNrLmlkLCBudWxsLCBtZWRpYVN0cmVhbVRyYWNrKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2Nsb25lczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2VuZGVyczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2VuZGVyVG9QdWJsaXNoZXJIaW50Q2FsbGJhY2tzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzUHVibGlzaGluZzoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLl9jbG9uZXMuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyB7QGxpbmsgTWVkaWFUcmFja1NlbmRlcn0gY29udGFpbmluZyBhIGNsb25lIG9mIHRoZSB1bmRlcmx5aW5nXG4gICAgICogTWVkaWFTdHJlYW1UcmFjay4gTm8gUlRDUnRwU2VuZGVycyBhcmUgY29waWVkLlxuICAgICAqIEByZXR1cm5zIHtNZWRpYVRyYWNrU2VuZGVyfVxuICAgICAqL1xuICAgIE1lZGlhVHJhY2tTZW5kZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xvbmUgPSBuZXcgTWVkaWFUcmFja1NlbmRlcih0aGlzLnRyYWNrLmNsb25lKCkpO1xuICAgICAgICB0aGlzLl9jbG9uZXMuYWRkKGNsb25lKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY2xvbmVkIHtAbGluayBNZWRpYVRyYWNrU2VuZGVyfS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrU2VuZGVyLnByb3RvdHlwZS5yZW1vdmVDbG9uZSA9IGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICB0aGlzLl9jbG9uZXMuZGVsZXRlKGNsb25lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZ2l2ZW4gTWVkaWFTdHJlYW1UcmFjay5cbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IG1lZGlhU3RyZWFtVHJhY2tcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrU2VuZGVyLnByb3RvdHlwZS5zZXRNZWRpYVN0cmVhbVRyYWNrID0gZnVuY3Rpb24gKG1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNsb25lcyA9IEFycmF5LmZyb20odGhpcy5fY2xvbmVzKTtcbiAgICAgICAgdmFyIHNlbmRlcnMgPSBBcnJheS5mcm9tKHRoaXMuX3NlbmRlcnMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2xvbmVzLm1hcChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZS5zZXRNZWRpYVN0cmVhbVRyYWNrKG1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKSk7XG4gICAgICAgIH0pLmNvbmNhdChzZW5kZXJzLm1hcChmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlcGxhY2VUcmFjayhzZW5kZXIsIG1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICB9KSkpLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3RyYWNrID0gbWVkaWFTdHJlYW1UcmFjaztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gUlRDUnRwU2VuZGVyLlxuICAgICAqIEBwYXJhbSB7UlRDUnRwU2VuZGVyfSBzZW5kZXJcbiAgICAgKiBAcGFyYW0gez8oKT0+UHJvbWlzZTxzdHJpbmc+fSBwdWJsaXNoZXJIaW50Q2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrU2VuZGVyLnByb3RvdHlwZS5hZGRTZW5kZXIgPSBmdW5jdGlvbiAoc2VuZGVyLCBwdWJsaXNoZXJIaW50Q2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fc2VuZGVycy5hZGQoc2VuZGVyKTtcbiAgICAgICAgaWYgKHB1Ymxpc2hlckhpbnRDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fc2VuZGVyVG9QdWJsaXNoZXJIaW50Q2FsbGJhY2tzLnNldChzZW5kZXIsIHB1Ymxpc2hlckhpbnRDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gUlRDUnRwU2VuZGVyLlxuICAgICAqIEBwYXJhbSB7UlRDUnRwU2VuZGVyfSBzZW5kZXJcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrU2VuZGVyLnByb3RvdHlwZS5yZW1vdmVTZW5kZXIgPSBmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICAgIHRoaXMuX3NlbmRlcnMuZGVsZXRlKHNlbmRlcik7XG4gICAgICAgIHRoaXMuX3NlbmRlclRvUHVibGlzaGVySGludENhbGxiYWNrcy5kZWxldGUoc2VuZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGdpdmVuIGVuY29kaW5ncywgb3IgcmVzZXRzIGVuY29kaW5ncyBpZiBub25lIHNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5PHtlbmFibGVkOiBib29sZWFuLCBsYXllcl9pbmRleDogbnVtYmVyfT58bnVsbH0gZW5jb2RpbmdzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrU2VuZGVyLnByb3RvdHlwZS5zZXRQdWJsaXNoZXJIaW50ID0gZnVuY3Rpb24gKGVuY29kaW5ncykge1xuICAgICAgICAvLyBOb3RlKG1wYXR3YXJkaGFuKTogc2luY2UgcHVibGlzaGVyIGhpbnQgYXBwbGllcyBvbmx5IHRvIGdyb3VwIHJvb21zIHdlIG9ubHkgbG9vayBhdCAxc3QgY2FsbCBjYWxsYmFjay5cbiAgICAgICAgdmFyIF9hID0gX19yZWFkKEFycmF5LmZyb20odGhpcy5fc2VuZGVyVG9QdWJsaXNoZXJIaW50Q2FsbGJhY2tzLnZhbHVlcygpKSwgMSksIHB1Ymxpc2hlckhpbnRDYWxsYmFjayA9IF9hWzBdO1xuICAgICAgICByZXR1cm4gcHVibGlzaGVySGludENhbGxiYWNrID8gcHVibGlzaGVySGludENhbGxiYWNrKGVuY29kaW5ncykgOiBQcm9taXNlLnJlc29sdmUoJ0NPVUxEX05PVF9BUFBMWV9ISU5UJyk7XG4gICAgfTtcbiAgICBNZWRpYVRyYWNrU2VuZGVyLnByb3RvdHlwZS5fcmVwbGFjZVRyYWNrID0gZnVuY3Rpb24gKHNlbmRlciwgbWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2VuZGVyLnJlcGxhY2VUcmFjayhtZWRpYVN0cmVhbVRyYWNrKS50aGVuKGZ1bmN0aW9uIChyZXBsYWNlVHJhY2tSZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIGFueSBwdWJsaXNoZXJIaW50cyBhbmQgYXBwbHkgZGVmYXVsdCBlbmNvZGluZ3MuXG4gICAgICAgICAgICBfdGhpcy5zZXRQdWJsaXNoZXJIaW50KG51bGwpLmNhdGNoKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdyZXBsYWNlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VUcmFja1Jlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVkaWFUcmFja1NlbmRlcjtcbn0oTWVkaWFUcmFja1RyYW5zY2VpdmVyKSk7XG4vKipcbiAqIFRoZSB7QGxpbmsgTWVkaWFUcmFja1NlbmRlcn0gcmVwbGFjZWQgdGhlIHVuZGVybHlpbmcgbWVkaWFTdHJlYW1UcmFja1xuICogQGV2ZW50IE1lZGlhVHJhY2tTZW5kZXIjcmVwbGFjZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBNZWRpYVRyYWNrU2VuZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VuZGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRlbWl0dGVyJyk7XG52YXIgX2EgPSByZXF1aXJlKCcuLi8uLi91dGlsJyksIGJ1aWxkTG9nTGV2ZWxzID0gX2EuYnVpbGRMb2dMZXZlbHMsIHZhbHVlVG9KU09OID0gX2EudmFsdWVUb0pTT047XG52YXIgREVGQVVMVF9MT0dfTEVWRUwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbnN0YW50cycpLkRFRkFVTFRfTE9HX0xFVkVMO1xudmFyIExvZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbG9nJyk7XG52YXIgbkluc3RhbmNlcyA9IDA7XG4vKipcbiAqIEEge0BsaW5rIFRyYWNrUHVibGljYXRpb259IHJlcHJlc2VudHMgYSB7QGxpbmsgVHJhY2t9IHRoYXRcbiAqIGhhcyBiZWVuIHB1Ymxpc2hlZCB0byBhIHtAbGluayBSb29tfS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0cmFja05hbWUgLSB0aGUgcHVibGlzaGVkIHtAbGluayBUcmFja30ncyBuYW1lXG4gKiBAcHJvcGVydHkge1RyYWNrLlNJRH0gdHJhY2tTaWQgLSBTSUQgYXNzaWduZWQgdG8gdGhlIHB1Ymxpc2hlZCB7QGxpbmsgVHJhY2t9XG4gKiBAZW1pdHMgVHJhY2tQdWJsaWNhdGlvbiN0cmFja0Rpc2FibGVkXG4gKiBAZW1pdHMgVHJhY2tQdWJsaWNhdGlvbiN0cmFja0VuYWJsZWRcbiAqL1xudmFyIFRyYWNrUHVibGljYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYWNrUHVibGljYXRpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFRyYWNrUHVibGljYXRpb259LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFja05hbWUgLSB0aGUgcHVibGlzaGVkIHtAbGluayBUcmFja30ncyBuYW1lXG4gICAgICogQHBhcmFtIHtUcmFjay5TSUR9IHRyYWNrU2lkIC0gU0lEIGFzc2lnbmVkIHRvIHRoZSB7QGxpbmsgVHJhY2t9XG4gICAgICogQHBhcmFtIHtUcmFja1B1YmxpY2F0aW9uT3B0aW9uc30gb3B0aW9ucyAtIHtAbGluayBUcmFja1B1YmxpY2F0aW9ufSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhY2tQdWJsaWNhdGlvbih0cmFja05hbWUsIHRyYWNrU2lkLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGxvZ0xldmVsOiBERUZBVUxUX0xPR19MRVZFTFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIGxvZ0xldmVscyA9IGJ1aWxkTG9nTGV2ZWxzKG9wdGlvbnMubG9nTGV2ZWwpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2luc3RhbmNlSWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbkluc3RhbmNlcysrXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xvZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmxvZyA/IG9wdGlvbnMubG9nLmNyZWF0ZUxvZygnZGVmYXVsdCcsIF90aGlzKSA6IG5ldyBMb2coJ2RlZmF1bHQnLCBfdGhpcywgbG9nTGV2ZWxzLCBvcHRpb25zLmxvZ2dlck5hbWUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2tOYW1lOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhY2tOYW1lXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2tTaWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0cmFja1NpZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUcmFja1B1YmxpY2F0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVRvSlNPTih0aGlzKTtcbiAgICB9O1xuICAgIFRyYWNrUHVibGljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbVHJhY2tQdWJsaWNhdGlvbiAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgdGhpcy50cmFja1NpZCArIFwiXVwiO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb247XG59KEV2ZW50RW1pdHRlcikpO1xuLyoqXG4gKiBUaGUgcHVibGlzaGVkIHtAbGluayBUcmFja30gd2FzIGRpc2FibGVkLlxuICogQGV2ZW50IFRyYWNrUHVibGljYXRpb24jdHJhY2tEaXNhYmxlZFxuICovXG4vKipcbiAqIFRoZSBwdWJsaXNoZWQge0BsaW5rIFRyYWNrfSB3YXMgZW5hYmxlZC5cbiAqIEBldmVudCBUcmFja1B1YmxpY2F0aW9uI3RyYWNrRW5hYmxlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIExvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9ufSBvciBhIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb259LlxuICogQHR5cGVkZWYge0xvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9ufFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbn0gQXVkaW9UcmFja1B1YmxpY2F0aW9uXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvbn0gb3IgYSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb259LlxuICogQHR5cGVkZWYge0xvY2FsRGF0YVRyYWNrUHVibGljYXRpb258UmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb259IERhdGFUcmFja1B1YmxpY2F0aW9uXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb259IG9yIGEge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbn0uXG4gKiBAdHlwZWRlZiB7TG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb258UmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9ufSBWaWRlb1RyYWNrUHVibGljYXRpb25cbiAqL1xuLyoqXG4gKiB7QGxpbmsgVHJhY2tQdWJsaWNhdGlvbn0gb3B0aW9uc1xuICogQHR5cGVkZWYge29iamVjdH0gVHJhY2tQdWJsaWNhdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7TG9nTGV2ZWx8TG9nTGV2ZWxzfSBsb2dMZXZlbCAtIExvZyBsZXZlbCBmb3IgJ21lZGlhJyBtb2R1bGVzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVHJhY2tQdWJsaWNhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNrcHVibGljYXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBUcmFja1RyYW5zY2VpdmVyID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNjZWl2ZXInKTtcbi8qKlxuICogQSB7QGxpbmsgTWVkaWFUcmFja1RyYW5zY2VpdmVyfSByZXByZXNlbnRzIGVpdGhlciBvbmUgb3IgbW9yZSBsb2NhbFxuICogUlRDUnRwU2VuZGVycywgb3IgYSBzaW5nbGUgUlRDUnRwUmVjZWl2ZXIuXG4gKiBAZXh0ZW5kcyBUcmFja1RyYW5zY2VpdmVyXG4gKiBAcHJvcGVydHkge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gKi9cbnZhciBNZWRpYVRyYWNrVHJhbnNjZWl2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lZGlhVHJhY2tUcmFuc2NlaXZlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTWVkaWFUcmFja1RyYW5zY2VpdmVyfS5cbiAgICAgKiBAcGFyYW0ge1RyYWNrLklEfSBpZCAtIFRoZSBNZWRpYVN0cmVhbVRyYWNrIElEIHNpZ25hbGVkIHRocm91Z2ggUlNQL1NEUFxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gbWlkIC0gVGhlIE1JRCBhc3NvY2lhdGVkIHdpdGggdGhlIE1lZGlhU3RyZWFtVHJhY2tcbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IG1lZGlhU3RyZWFtVHJhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZWRpYVRyYWNrVHJhbnNjZWl2ZXIoaWQsIG1pZCwgbWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgbWVkaWFTdHJlYW1UcmFjay5raW5kKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX3RyYWNrOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG1lZGlhU3RyZWFtVHJhY2ssXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrLmVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1pZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1pZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWR5U3RhdGU6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2sucmVhZHlTdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2s6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNZWRpYVRyYWNrVHJhbnNjZWl2ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJhY2suc3RvcCgpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnN0b3AuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBNZWRpYVRyYWNrVHJhbnNjZWl2ZXI7XG59KFRyYWNrVHJhbnNjZWl2ZXIpKTtcbm1vZHVsZS5leHBvcnRzID0gTWVkaWFUcmFja1RyYW5zY2VpdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNjZWl2ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgREVGQVVMVF9WSURFT19QUk9DRVNTT1JfU1RBVFNfSU5URVJWQUxfTVMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbnN0YW50cycpLkRFRkFVTFRfVklERU9fUFJPQ0VTU09SX1NUQVRTX0lOVEVSVkFMX01TO1xuLyoqXG4gKiBWaWRlb1Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIgbGlzdGVucyB0byB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9IHJlbGF0ZWQgZXZlbnRzXG4gKiBhbmQgcmUtZW1pdHMgdGhlbSBhcyBhIGdlbmVyaWMgZXZlbnQgd2l0aCBzb21lIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBlbWl0cyBWaWRlb1Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIjZXZlbnRcbiAqL1xudmFyIFZpZGVvUHJvY2Vzc29yRXZlbnRPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlkZW9Qcm9jZXNzb3JFdmVudE9ic2VydmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB7TG9nfSBsb2dcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaWRlb1Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIobG9nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfbGFzdFN0YXRzU2F2ZVRpbWU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sYXN0U3RhdHNQdWJsaXNoVGltZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xvZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsb2dcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcHJvY2Vzc29ySW5mbzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3N0YXRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uKCdhZGQnLCBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgICAgX3RoaXMuX2xhc3RTdGF0c1NhdmVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIF90aGlzLl9sYXN0U3RhdHNQdWJsaXNoVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBfdGhpcy5fcHJvY2Vzc29ySW5mbyA9IGluZm87XG4gICAgICAgICAgICBfdGhpcy5fc3RhdHMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLl9yZWVtaXRFdmVudCgnYWRkJywgX3RoaXMuX2dldEV2ZW50RGF0YSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IF90aGlzLl9nZXRFdmVudERhdGEoKTtcbiAgICAgICAgICAgIF90aGlzLl9sYXN0U3RhdHNTYXZlVGltZSA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5fbGFzdFN0YXRzUHVibGlzaFRpbWUgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuX3Byb2Nlc3NvckluZm8gPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuX3N0YXRzID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLl9yZWVtaXRFdmVudCgncmVtb3ZlJywgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVlbWl0RXZlbnQoJ3N0YXJ0JywgX3RoaXMuX2dldEV2ZW50RGF0YSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uKCdzdG9wJywgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZWVtaXRFdmVudCgnc3RvcCcsIE9iamVjdC5hc3NpZ24oeyBtZXNzYWdlOiBtZXNzYWdlIH0sIF90aGlzLl9nZXRFdmVudERhdGEoKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMub24oJ3N0YXRzJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX21heWJlRW1pdFN0YXRzKCk7IH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlkZW9Qcm9jZXNzb3JFdmVudE9ic2VydmVyLnByb3RvdHlwZS5fZ2V0RXZlbnREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Byb2Nlc3NvckluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLl9wcm9jZXNzb3JJbmZvLCBwcm9jZXNzb3IgPSBfYS5wcm9jZXNzb3IsIGNhcHR1cmVIZWlnaHQgPSBfYS5jYXB0dXJlSGVpZ2h0LCBjYXB0dXJlV2lkdGggPSBfYS5jYXB0dXJlV2lkdGgsIGlucHV0RnJhbWVSYXRlID0gX2EuaW5wdXRGcmFtZVJhdGUsIGlzUmVtb3RlVmlkZW9UcmFjayA9IF9hLmlzUmVtb3RlVmlkZW9UcmFjaztcbiAgICAgICAgdmFyIGRhdGEgPSB7IGNhcHR1cmVIZWlnaHQ6IGNhcHR1cmVIZWlnaHQsIGNhcHR1cmVXaWR0aDogY2FwdHVyZVdpZHRoLCBpbnB1dEZyYW1lUmF0ZTogaW5wdXRGcmFtZVJhdGUsIGlzUmVtb3RlVmlkZW9UcmFjazogaXNSZW1vdGVWaWRlb1RyYWNrIH07XG4gICAgICAgIGRhdGEubmFtZSA9IHByb2Nlc3Nvci5fbmFtZSB8fCAnVmlkZW9Qcm9jZXNzb3InO1xuICAgICAgICBbJ2Fzc2V0c1BhdGgnLCAnYmx1ckZpbHRlclJhZGl1cycsICdmaXRUeXBlJywgJ2lzU2ltZEVuYWJsZWQnLCAnbWFza0JsdXJSYWRpdXMnLCAndmVyc2lvbiddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBwcm9jZXNzb3JbXCJfXCIgKyBwcm9wXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRhdGFbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gZGF0YVtwcm9wXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBkYXRhW3Byb3BdID0gdmFsID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2F2ZSBzdGF0cyBldmVyeSBzZWNvbmQuIElmIGEgc3BlY2lmaWMgdGltZSBpbnRlcnZhbCBoYXMgZWxhcHNlZCxcbiAgICAgKiB0aGUgc3RhdHMgZXZlbnQgd2lsbCBiZSBlbWl0dGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWaWRlb1Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIucHJvdG90eXBlLl9tYXliZUVtaXRTdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0cyB8fCAhdGhpcy5fcHJvY2Vzc29ySW5mbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZW5jaG1hcmsgPSB0aGlzLl9wcm9jZXNzb3JJbmZvLnByb2Nlc3Nvci5fYmVuY2htYXJrO1xuICAgICAgICBpZiAoIWJlbmNobWFyaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IC0gdGhpcy5fbGFzdFN0YXRzU2F2ZVRpbWUgPCAxMDAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0geyBvdXRwdXRGcmFtZVJhdGU6IGJlbmNobWFyay5nZXRSYXRlKCd0b3RhbFByb2Nlc3NpbmdEZWxheScpIH07XG4gICAgICAgIFsnY2FwdHVyZUZyYW1lRGVsYXknLCAnaW1hZ2VDb21wb3NpdGlvbkRlbGF5JywgJ2lucHV0SW1hZ2VSZXNpemVEZWxheScsICdwcm9jZXNzRnJhbWVEZWxheScsICdzZWdtZW50YXRpb25EZWxheSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGVudHJ5W25hbWVdID0gYmVuY2htYXJrLmdldEF2ZXJhZ2VEZWxheShuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xhc3RTdGF0c1NhdmVUaW1lID0gbm93O1xuICAgICAgICB0aGlzLl9zdGF0cy5wdXNoKGVudHJ5KTtcbiAgICAgICAgaWYgKG5vdyAtIHRoaXMuX2xhc3RTdGF0c1B1Ymxpc2hUaW1lIDwgREVGQVVMVF9WSURFT19QUk9DRVNTT1JfU1RBVFNfSU5URVJWQUxfTVMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0U3RhdHNQdWJsaXNoVGltZSA9IG5vdztcbiAgICAgICAgdmFyIHN0YXRzID0gdGhpcy5fc3RhdHMuc3BsaWNlKDApO1xuICAgICAgICB2YXIgYXZlcmFnZXMgPSBzdGF0cy5yZWR1Y2UoZnVuY3Rpb24gKGF2ZXJhZ2VzLCBjdXJyZW50LCBuKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghYXZlcmFnZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXZlcmFnZXNbbmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdmVyYWdlc1tuYW1lXSA9ICgoYXZlcmFnZXNbbmFtZV0gKiBuKSArIGN1cnJlbnRbbmFtZV0pIC8gKG4gKyAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGF2ZXJhZ2VzO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF2ZXJhZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBhdmVyYWdlc1tuYW1lXSA9IHBhcnNlRmxvYXQoYXZlcmFnZXNbbmFtZV0udG9GaXhlZCgyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9yZWVtaXRFdmVudCgnc3RhdHMnLCBPYmplY3QuYXNzaWduKHt9LCBhdmVyYWdlcywgdGhpcy5fZ2V0RXZlbnREYXRhKCkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlkZW9Qcm9jZXNzb3JFdmVudE9ic2VydmVyLnByb3RvdHlwZS5fcmVlbWl0RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZGF0YSkge1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJWaWRlb1Byb2Nlc3NvcjpcIiArIG5hbWUsIGRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ2V2ZW50JywgeyBuYW1lOiBuYW1lLCBkYXRhOiBkYXRhIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFZpZGVvUHJvY2Vzc29yRXZlbnRPYnNlcnZlcjtcbn0oRXZlbnRFbWl0dGVyKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFZpZGVvUHJvY2Vzc29yRXZlbnRPYnNlcnZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZGVvcHJvY2Vzc29yZXZlbnRvYnNlcnZlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIE1lZGlhVHJhY2sgPSByZXF1aXJlKCcuL21lZGlhdHJhY2snKTtcbnZhciBWaWRlb1Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIgPSByZXF1aXJlKCcuL3ZpZGVvcHJvY2Vzc29yZXZlbnRvYnNlcnZlcicpO1xudmFyIERFRkFVTFRfRlJBTUVfUkFURSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uc3RhbnRzJykuREVGQVVMVF9GUkFNRV9SQVRFO1xuLyoqXG4gKiBBIHtAbGluayBWaWRlb1RyYWNrfSBpcyBhIHtAbGluayBUcmFja30gcmVwcmVzZW50aW5nIHZpZGVvLlxuICogQGV4dGVuZHMgVHJhY2tcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTdGFydGVkIC0gV2hldGhlciBvciBub3QgdGhlIHtAbGluayBWaWRlb1RyYWNrfSBoYXNcbiAqICAgc3RhcnRlZDsgaWYgdGhlIHtAbGluayBWaWRlb1RyYWNrfSBzdGFydGVkLCB0aGVyZSBpcyBlbm91Z2ggdmlkZW8gZGF0YSB0b1xuICogICBiZWdpbiBwbGF5YmFja1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc0VuYWJsZWQgLSBXaGV0aGVyIG9yIG5vdCB0aGUge0BsaW5rIFZpZGVvVHJhY2t9IGlzXG4gKiAgIGVuYWJsZWQ7IGlmIHRoZSB7QGxpbmsgVmlkZW9UcmFja30gaXMgbm90IGVuYWJsZWQsIGl0IGlzIFwicGF1c2VkXCJcbiAqIEBwcm9wZXJ0eSB7VmlkZW9UcmFjay5EaW1lbnNpb25zfSBkaW1lbnNpb25zIC0gVGhlIHtAbGluayBWaWRlb1RyYWNrfSdzXG4gKiAgIHtAbGluayBWaWRlb1RyYWNrLkRpbWVuc2lvbnN9XG4gKiBAcHJvcGVydHkge1RyYWNrLktpbmR9IGtpbmQgLSBcInZpZGVvXCJcbiAqIEBwcm9wZXJ0eSB7P01lZGlhU3RyZWFtVHJhY2t9IG1lZGlhU3RyZWFtVHJhY2sgLSBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIHVuZGVybHlpbmdcbiAqICAgTWVkaWFTdHJlYW1UcmFjazsgSXQgaXMgc2V0IHRvIDxjb2RlPm51bGw8L2NvZGU+IGlmIGl0IGlzIGEge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9XG4gKiAgIHRoYXQgaXMgc3dpdGNoZWQgb2ZmXG4gKiBAcHJvcGVydHkgez9NZWRpYVN0cmVhbVRyYWNrfSBwcm9jZXNzZWRUcmFjayAtIFRoZSBzb3VyY2Ugb2YgcHJvY2Vzc2VkIHZpZGVvIGZyYW1lcy5cbiAqIEl0IGlzIG51bGwgaWYgbm8gVmlkZW9Qcm9jZXNzb3IgaGFzIGJlZW4gYWRkZWQuXG4gKiBAcHJvcGVydHkgez9WaWRlb1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIC0gQSB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9IHRoYXQgaXMgY3VycmVudGx5XG4gKiAgIHByb2Nlc3NpbmcgdmlkZW8gZnJhbWVzLiBJdCBpcyBudWxsIGlmIHZpZGVvIGZyYW1lcyBhcmUgbm90IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBlbWl0cyBWaWRlb1RyYWNrI2RpbWVuc2lvbnNDaGFuZ2VkXG4gKiBAZW1pdHMgVmlkZW9UcmFjayNkaXNhYmxlZFxuICogQGVtaXRzIFZpZGVvVHJhY2sjZW5hYmxlZFxuICogQGVtaXRzIFZpZGVvVHJhY2sjc3RhcnRlZFxuICovXG52YXIgVmlkZW9UcmFjayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlkZW9UcmFjaywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgVmlkZW9UcmFja30uXG4gICAgICogQHBhcmFtIHs/TWVkaWFUcmFja1RyYW5zY2VpdmVyfSBtZWRpYVRyYWNrVHJhbnNjZWl2ZXJcbiAgICAgKiBAcGFyYW0ge3tsb2c6IExvZywgbmFtZTogc3RyaW5nfX0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZpZGVvVHJhY2sobWVkaWFUcmFja1RyYW5zY2VpdmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIFZpZGVvUHJvY2Vzc29yRXZlbnRPYnNlcnZlcjogVmlkZW9Qcm9jZXNzb3JFdmVudE9ic2VydmVyXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICd2aWRlbycsIG1lZGlhVHJhY2tUcmFuc2NlaXZlciwgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9jYXB0dXJlVGltZW91dElkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaXNDYXB0dXJpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW5wdXRGcmFtZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX291dHB1dEZyYW1lOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcHJvY2Vzc29yRXZlbnRPYnNlcnZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgb3B0aW9ucy5WaWRlb1Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIoX3RoaXMuX2xvZyksXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3VubXV0ZUhhbmRsZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2Vzc29yOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZGVvVHJhY2sucHJvdG90eXBlLl9jaGVja0lmQ2FuQ2FwdHVyZUZyYW1lcyA9IGZ1bmN0aW9uIChpc1B1Ymxpc2hpbmcpIHtcbiAgICAgICAgaWYgKGlzUHVibGlzaGluZyA9PT0gdm9pZCAwKSB7IGlzUHVibGlzaGluZyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBjYW5DYXB0dXJlRnJhbWVzID0gdHJ1ZTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnJztcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgICAgIGNhbkNhcHR1cmVGcmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnTWVkaWFTdHJlYW1UcmFjayBpcyBudWxsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGNhbkNhcHR1cmVGcmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnTWVkaWFTdHJlYW1UcmFjayBpcyBkaXNhYmxlZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tZWRpYVN0cmVhbVRyYWNrLnJlYWR5U3RhdGUgPT09ICdlbmRlZCcpIHtcbiAgICAgICAgICAgIGNhbkNhcHR1cmVGcmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnTWVkaWFTdHJlYW1UcmFjayBpcyBlbmRlZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgICBjYW5DYXB0dXJlRnJhbWVzID0gZmFsc2U7XG4gICAgICAgICAgICBtZXNzYWdlID0gJ1ZpZGVvUHJvY2Vzc29yIG5vdCBkZXRlY3RlZC4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9hdHRhY2htZW50cy5zaXplICYmICFpc1B1Ymxpc2hpbmcpIHtcbiAgICAgICAgICAgIGNhbkNhcHR1cmVGcmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnVmlkZW9UcmFjayBpcyBub3QgcHVibGlzaGluZyBhbmQgdGhlcmUgaXMgbm8gYXR0YWNoZWQgZWxlbWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2FuQ2FwdHVyZUZyYW1lczogY2FuQ2FwdHVyZUZyYW1lcywgbWVzc2FnZTogbWVzc2FnZSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWaWRlb1RyYWNrLnByb3RvdHlwZS5fY2FwdHVyZUZyYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2FwdHVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0lnbm9yaW5nIGNhcHR1cmVGcmFtZXMgY2FsbC4gQ2FwdHVyZSBpcyBhbHJlYWR5IGluIHByb2dyZXNzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja0lmQ2FuQ2FwdHVyZUZyYW1lcygpLmNhbkNhcHR1cmVGcmFtZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2FwdHVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0Nhbm5vdCBjYXB0dXJlIGZyYW1lcy4gSWdub3JpbmcgY2FwdHVyZUZyYW1lcyBjYWxsLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzQ2FwdHVyaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc29yRXZlbnRPYnNlcnZlci5lbWl0KCdzdGFydCcpO1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ1N0YXJ0IGNhcHR1cmluZyBmcmFtZXMnKTtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBwcm9jZXNzRnJhbWVQZXJpb2RNcztcbiAgICAgICAgdGhpcy5fZHVtbXlFbC5wbGF5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZUZyYW1lID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLl9jYXB0dXJlVGltZW91dElkKTtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSAoX3RoaXMubWVkaWFTdHJlYW1UcmFja1xuICAgICAgICAgICAgICAgICAgICA/IF90aGlzLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKVxuICAgICAgICAgICAgICAgICAgICA6IHt9KS5mcmFtZVJhdGUsIGZyYW1lUmF0ZSA9IF9hID09PSB2b2lkIDAgPyBERUZBVUxUX0ZSQU1FX1JBVEUgOiBfYTtcbiAgICAgICAgICAgICAgICB2YXIgY2FwdHVyZVBlcmlvZE1zID0gTWF0aC5mbG9vcigxMDAwIC8gZnJhbWVSYXRlKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVsYXkgPSBjYXB0dXJlUGVyaW9kTXMgLSBwcm9jZXNzRnJhbWVQZXJpb2RNcztcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXkgPCAwIHx8IHR5cGVvZiBwcm9jZXNzRnJhbWVQZXJpb2RNcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fY2FwdHVyZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoY2IsIGRlbGF5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tSZXN1bHQgPSBfdGhpcy5fY2hlY2tJZkNhbkNhcHR1cmVGcmFtZXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrUmVzdWx0LmNhbkNhcHR1cmVGcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzQ2FwdHVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcm9jZXNzb3JFdmVudE9ic2VydmVyLmVtaXQoJ3N0b3AnLCBjaGVja1Jlc3VsdC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZygnQ2Fubm90IGNhcHR1cmUgZnJhbWVzLiBTdG9wcGluZyBjYXB0dXJpbmcgZnJhbWVzLicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMubWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLCBfYiA9IF9hLndpZHRoLCB3aWR0aCA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsIF9jID0gX2EuaGVpZ2h0LCBoZWlnaHQgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jO1xuICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgdGhlIGNhbnZhcycgZGltZW5zaW9uIHRyaWdnZXJzIGEgcmVkcmF3LlxuICAgICAgICAgICAgICAgIC8vIE9ubHkgc2V0IGl0IGlmIGl0IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faW5wdXRGcmFtZS53aWR0aCAhPT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lucHV0RnJhbWUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lucHV0RnJhbWUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX291dHB1dEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb3V0cHV0RnJhbWUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9vdXRwdXRGcmFtZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX2lucHV0RnJhbWUuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoX3RoaXMuX2R1bW15RWwsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF90aGlzLnByb2Nlc3Nvci5wcm9jZXNzRnJhbWUoX3RoaXMuX2lucHV0RnJhbWUsIF90aGlzLl9vdXRwdXRGcmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKCdFeGNlcHRpb24gZGV0ZWN0ZWQgYWZ0ZXIgY2FsbGluZyBwcm9jZXNzRnJhbWUuJywgZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpID8gcmVzdWx0IDogUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9vdXRwdXRGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc2VkVHJhY2sucmVxdWVzdEZyYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvY2Vzc29yRXZlbnRPYnNlcnZlci5lbWl0KCdzdGF0cycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRnJhbWVQZXJpb2RNcyA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGNhcHR1cmVGcmFtZShwcm9jZXNzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXB0dXJlRnJhbWUocHJvY2Vzcyk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gX3RoaXMuX2xvZy5lcnJvcignVmlkZW8gZWxlbWVudCBjYW5ub3QgYmUgcGxheWVkJywgeyBlcnJvcjogZXJyb3IsIHRyYWNrOiBfdGhpcyB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZGVvVHJhY2sucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9pbml0aWFsaXplLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9kdW1teUVsKSB7XG4gICAgICAgICAgICB0aGlzLl9kdW1teUVsLm9ubG9hZGVkbWV0YWRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnNDaGFuZ2VkKF90aGlzLCBfdGhpcy5fZHVtbXlFbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGltZW5zaW9ucy53aWR0aCA9IF90aGlzLl9kdW1teUVsLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpbWVuc2lvbnMuaGVpZ2h0ID0gX3RoaXMuX2R1bW15RWwudmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2R1bW15RWwub25yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnNDaGFuZ2VkKF90aGlzLCBfdGhpcy5fZHVtbXlFbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGltZW5zaW9ucy53aWR0aCA9IF90aGlzLl9kdW1teUVsLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpbWVuc2lvbnMuaGVpZ2h0ID0gX3RoaXMuX2R1bW15RWwudmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoJ0RpbWVuc2lvbnMgY2hhbmdlZDonLCBfdGhpcy5kaW1lbnNpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoVmlkZW9UcmFjay5ESU1FTlNJT05TX0NIQU5HRUQsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlkZW9UcmFjay5wcm90b3R5cGUuX3Jlc3RhcnRQcm9jZXNzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9jZXNzb3IgPSB0aGlzLnByb2Nlc3NvcjtcbiAgICAgICAgaWYgKHByb2Nlc3Nvcikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQcm9jZXNzb3IocHJvY2Vzc29yKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUHJvY2Vzc29yKHByb2Nlc3Nvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlkZW9UcmFjay5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKGR1bW15RWwpIHtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLndpZHRoID0gZHVtbXlFbC52aWRlb1dpZHRoO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMuaGVpZ2h0ID0gZHVtbXlFbC52aWRlb0hlaWdodDtcbiAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdEaW1lbnNpb25zOicsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl9zdGFydC5jYWxsKHRoaXMsIGR1bW15RWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEge0BsaW5rIFZpZGVvUHJvY2Vzc29yfSB0byBhbGxvdyBmb3IgY3VzdG9tIHByb2Nlc3Npbmcgb2YgdmlkZW8gZnJhbWVzIGJlbG9uZ2luZyB0byBhIFZpZGVvVHJhY2suXG4gICAgICogT25seSBDaHJvbWUgc3VwcG9ydHMgdGhpcyBhcyBvZiBub3cuIENhbGxpbmcgdGhpcyBBUEkgZnJvbSBhIG5vbi1zdXBwb3J0ZWQgYnJvd3NlciB3aWxsIHJlc3VsdCBpbiBhIGxvZyB3YXJuaW5nLlxuICAgICAqIEBwYXJhbSB7VmlkZW9Qcm9jZXNzb3J9IHByb2Nlc3NvciAtIFRoZSB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9IHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNsYXNzIEdyYXlTY2FsZVByb2Nlc3NvciB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwZXJjZW50YWdlKSB7XG4gICAgICogICAgIHRoaXMucGVyY2VudGFnZSA9IHBlcmNlbnRhZ2U7XG4gICAgICogICB9XG4gICAgICogICBwcm9jZXNzRnJhbWUoaW5wdXRGcmFtZUJ1ZmZlciwgb3V0cHV0RnJhbWVCdWZmZXIpIHtcbiAgICAgKiAgICAgY29uc3QgY29udGV4dCA9IG91dHB1dEZyYW1lQnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICogICAgIGNvbnRleHQuZmlsdGVyID0gYGdyYXlzY2FsZSgke3RoaXMucGVyY2VudGFnZX0lKWA7XG4gICAgICogICAgIGNvbnRleHQuZHJhd0ltYWdlKGlucHV0RnJhbWVCdWZmZXIsIDAsIDAsIGlucHV0RnJhbWVCdWZmZXIud2lkdGgsIGlucHV0RnJhbWVCdWZmZXIuaGVpZ2h0KTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBWaWRlby5jcmVhdGVMb2NhbFZpZGVvVHJhY2soKS50aGVuKGZ1bmN0aW9uKHZpZGVvVHJhY2spIHtcbiAgICAgKiAgIHZpZGVvVHJhY2suYWRkUHJvY2Vzc29yKG5ldyBHcmF5U2NhbGVQcm9jZXNzb3IoMTAwKSk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgVmlkZW9UcmFjay5wcm90b3R5cGUuYWRkUHJvY2Vzc29yID0gZnVuY3Rpb24gKHByb2Nlc3Nvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZy53YXJuKCdBZGRpbmcgYSBWaWRlb1Byb2Nlc3NvciBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb2Nlc3NvciB8fCB0eXBlb2YgcHJvY2Vzc29yLnByb2Nlc3NGcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWNlaXZlZCBhbiBpbnZhbGlkIFZpZGVvUHJvY2Vzc29yIGZyb20gYWRkUHJvY2Vzc29yLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3Nvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIFZpZGVvUHJvY2Vzc29yIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9kdW1teUVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpZGVvVHJhY2sgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygnQWRkaW5nIFZpZGVvUHJvY2Vzc29yIHRvIHRoZSBWaWRlb1RyYWNrJywgcHJvY2Vzc29yKTtcbiAgICAgICAgaWYgKCF0aGlzLl91bm11dGVIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl91bm11dGVIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoJ21lZGlhU3RyZWFtVHJhY2sgdW5tdXRlZCcpO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUoY3NhbnRvcyk6IE9uIGNlcnRhaW4gc2NlbmFyaW9zIHdoZXJlIG1lZGlhU3RyZWFtVHJhY2sgaXMgY29taW5nIGZyb20gbXV0ZWQgdG8gdW5tdXRlZCBzdGF0ZSxcbiAgICAgICAgICAgICAgICAvLyB0aGUgcHJvY2Vzc2VkVHJhY2sgZG9lc24ndCB1bm11dGVzIGF1dG9tYXRpY2FsbHkgYWx0aG91Z2ggZW5hYmxlZCBpcyBhbHJlYWR5IHNldCB0byB0cnVlLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB0ZXJtaW5hbCBzdGF0ZSBmb3IgdGhlIHByb2Nlc3NlZFRyYWNrIGFuZCBzaG91bGQgYmUgcmVzdGFydGVkLiAoVklERU8tNDE3NilcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvY2Vzc2VkVHJhY2subXV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZygnbWVkaWFTdHJlYW1UcmFjayBpcyB1bm11dGVkIGJ1dCBwcm9jZXNzZWRUcmFjayBpcyBtdXRlZC4gUmVzdGFydGluZyBwcm9jZXNzb3IuJyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXN0YXJ0UHJvY2Vzc29yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5fdW5tdXRlSGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5tZWRpYVN0cmVhbVRyYWNrXG4gICAgICAgICAgICA/IHRoaXMubWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpXG4gICAgICAgICAgICA6IHt9LCBfYiA9IF9hLndpZHRoLCB3aWR0aCA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsIF9jID0gX2EuaGVpZ2h0LCBoZWlnaHQgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jLCBfZCA9IF9hLmZyYW1lUmF0ZSwgZnJhbWVSYXRlID0gX2QgPT09IHZvaWQgMCA/IERFRkFVTFRfRlJBTUVfUkFURSA6IF9kO1xuICAgICAgICB0aGlzLl9pbnB1dEZyYW1lID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fb3V0cHV0RnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0RnJhbWUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5fb3V0cHV0RnJhbWUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnByb2Nlc3NlZFRyYWNrID0gdGhpcy5fb3V0cHV0RnJhbWUuY2FwdHVyZVN0cmVhbSgwKS5nZXRUcmFja3MoKVswXTtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWRUcmFjay5lbmFibGVkID0gdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQ7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgICAgICB0aGlzLl9wcm9jZXNzb3JFdmVudE9ic2VydmVyLmVtaXQoJ2FkZCcsIHtcbiAgICAgICAgICAgIHByb2Nlc3NvcjogcHJvY2Vzc29yLFxuICAgICAgICAgICAgY2FwdHVyZUhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgY2FwdHVyZVdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGlucHV0RnJhbWVSYXRlOiBmcmFtZVJhdGUsXG4gICAgICAgICAgICBpc1JlbW90ZVZpZGVvVHJhY2s6IHRoaXMudG9TdHJpbmcoKS5pbmNsdWRlcygnUmVtb3RlVmlkZW9UcmFjaycpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl91cGRhdGVFbGVtZW50c01lZGlhU3RyZWFtVHJhY2soKTtcbiAgICAgICAgdGhpcy5fY2FwdHVyZUZyYW1lcygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBIVE1MVmlkZW9FbGVtZW50IGFuZCBhdHRhY2ggdGhlIHtAbGluayBWaWRlb1RyYWNrfSB0byBpdC5cbiAgICAgKlxuICAgICAqIFRoZSBIVE1MVmlkZW9FbGVtZW50J3MgPGNvZGU+c3JjT2JqZWN0PC9jb2RlPiB3aWxsIGJlIHNldCB0byBhIG5ld1xuICAgICAqIE1lZGlhU3RyZWFtIGNvbnRhaW5pbmcgdGhlIHtAbGluayBWaWRlb1RyYWNrfSdzIE1lZGlhU3RyZWFtVHJhY2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTFZpZGVvRWxlbWVudH0gdmlkZW9FbGVtZW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICAgICAqXG4gICAgICogVmlkZW8uY3JlYXRlTG9jYWxWaWRlb1RyYWNrKCkudGhlbihmdW5jdGlvbih2aWRlb1RyYWNrKSB7XG4gICAgICogICBjb25zdCB2aWRlb0VsZW1lbnQgPSB2aWRlb1RyYWNrLmF0dGFjaCgpO1xuICAgICAqICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh2aWRlb0VsZW1lbnQpO1xuICAgICAqIH0pO1xuICAgICovIC8qKlxuICAgICAqIEF0dGFjaCB0aGUge0BsaW5rIFZpZGVvVHJhY2t9IHRvIGFuIGV4aXN0aW5nIEhUTUxNZWRpYUVsZW1lbnQuIFRoZVxuICAgICAqIEhUTUxNZWRpYUVsZW1lbnQgY291bGQgYmUgYW4gSFRNTEF1ZGlvRWxlbWVudCBvciBhbiBIVE1MVmlkZW9FbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgdGhlIEhUTUxNZWRpYUVsZW1lbnQncyA8Y29kZT5zcmNPYmplY3Q8L2NvZGU+IGlzIG5vdCBzZXQgdG8gYSBNZWRpYVN0cmVhbSxcbiAgICAgKiB0aGlzIG1ldGhvZCBzZXRzIGl0IHRvIGEgbmV3IE1lZGlhU3RyZWFtIGNvbnRhaW5pbmcgdGhlIHtAbGluayBWaWRlb1RyYWNrfSdzXG4gICAgICogTWVkaWFTdHJlYW1UcmFjazsgb3RoZXJ3aXNlLCBpdCBhZGRzIHRoZSB7QGxpbmsgTWVkaWFUcmFja30nc1xuICAgICAqIE1lZGlhU3RyZWFtVHJhY2sgdG8gdGhlIGV4aXN0aW5nIE1lZGlhU3RyZWFtLiBGaW5hbGx5LCBpZiB0aGVyZSBhcmUgYW55IG90aGVyXG4gICAgICogTWVkaWFTdHJlYW1UcmFja3Mgb2YgdGhlIHNhbWUga2luZCBvbiB0aGUgTWVkaWFTdHJlYW0sIHRoaXMgbWV0aG9kIHJlbW92ZXNcbiAgICAgKiB0aGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYUVsZW1lbnQgLSBUaGUgSFRNTE1lZGlhRWxlbWVudCB0byBhdHRhY2ggdG9cbiAgICAgKiBAcmV0dXJucyB7SFRNTE1lZGlhRWxlbWVudH0gbWVkaWFFbGVtZW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICAgICAqXG4gICAgICogY29uc3QgdmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgKiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHZpZGVvRWxlbWVudCk7XG4gICAgICpcbiAgICAgKiBWaWRlby5jcmVhdGVMb2NhbFZpZGVvVHJhY2soKS50aGVuKGZ1bmN0aW9uKHZpZGVvVHJhY2spIHtcbiAgICAgKiAgIHZpZGVvVHJhY2suYXR0YWNoKHZpZGVvRWxlbWVudCk7XG4gICAgICogfSk7XG4gICAgKi8gLyoqXG4gICAgICogQXR0YWNoIHRoZSB7QGxpbmsgVmlkZW9UcmFja30gdG8gYW4gSFRNTE1lZGlhRWxlbWVudCBzZWxlY3RlZCBieVxuICAgICAqIDxjb2RlPmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3I8L2NvZGU+LiBUaGUgSFRNTE1lZGlhRWxlbWVudCBjb3VsZCBiZSBhblxuICAgICAqIEhUTUxBdWRpb0VsZW1lbnQgb3IgYW4gSFRNTFZpZGVvRWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBIVE1MTWVkaWFFbGVtZW50J3MgPGNvZGU+c3JjT2JqZWN0PC9jb2RlPiBpcyBub3Qgc2V0IHRvIGEgTWVkaWFTdHJlYW0sXG4gICAgICogdGhpcyBtZXRob2Qgc2V0cyBpdCB0byBhIG5ldyBNZWRpYVN0cmVhbSBjb250YWluaW5nIHRoZSB7QGxpbmsgVmlkZW9UcmFja30nc1xuICAgICAqIE1lZGlhU3RyZWFtVHJhY2s7IG90aGVyd2lzZSwgaXQgYWRkcyB0aGUge0BsaW5rIFZpZGVvVHJhY2t9J3NcbiAgICAgKiBNZWRpYVN0cmVhbVRyYWNrIHRvIHRoZSBleGlzdGluZyBNZWRpYVN0cmVhbS4gRmluYWxseSwgaWYgdGhlcmUgYXJlIGFueSBvdGhlclxuICAgICAqIE1lZGlhU3RyZWFtVHJhY2tzIG9mIHRoZSBzYW1lIGtpbmQgb24gdGhlIE1lZGlhU3RyZWFtLCB0aGlzIG1ldGhvZCByZW1vdmVzXG4gICAgICogdGhlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIEEgcXVlcnkgc2VsZWN0b3IgZm9yIHRoZSBIVE1MTWVkaWFFbGVtZW50IHRvXG4gICAgICogICBhdHRhY2ggdG9cbiAgICAgKiBAcmV0dXJucyB7SFRNTE1lZGlhRWxlbWVudH0gbWVkaWFFbGVtZW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICAgICAqXG4gICAgICogY29uc3QgdmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgKiB2aWRlb0VsZW1lbnQuaWQgPSAnbXktdmlkZW8tZWxlbWVudCc7XG4gICAgICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh2aWRlb0VsZW1lbnQpO1xuICAgICAqXG4gICAgICogVmlkZW8uY3JlYXRlTG9jYWxWaWRlb1RyYWNrKCkudGhlbihmdW5jdGlvbih0cmFjaykge1xuICAgICAqICAgdHJhY2suYXR0YWNoKCcjbXktdmlkZW8tZWxlbWVudCcpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIFZpZGVvVHJhY2sucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuYXR0YWNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3Nvcikge1xuICAgICAgICAgICAgdGhpcy5fY2FwdHVyZUZyYW1lcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRhY2ggdGhlIHtAbGluayBWaWRlb1RyYWNrfSBmcm9tIGFsbCBwcmV2aW91c2x5IGF0dGFjaGVkIEhUTUxNZWRpYUVsZW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxIVE1MTWVkaWFFbGVtZW50Pn0gbWVkaWFFbGVtZW50c1xuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbWVkaWFFbGVtZW50cyA9IHZpZGVvVHJhY2suZGV0YWNoKCk7XG4gICAgICogbWVkaWFFbGVtZW50cy5mb3JFYWNoKG1lZGlhRWxlbWVudCA9PiBtZWRpYUVsZW1lbnQucmVtb3ZlKCkpO1xuICAgICovIC8qKlxuICAgICAqIERldGFjaCB0aGUge0BsaW5rIFZpZGVvVHJhY2t9IGZyb20gYSBwcmV2aW91c2x5IGF0dGFjaGVkIEhUTUxNZWRpYUVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYUVsZW1lbnQgLSBPbmUgb2YgdGhlIEhUTUxNZWRpYUVsZW1lbnRzIHRvXG4gICAgICogICB3aGljaCB0aGUge0BsaW5rIFZpZGVvVHJhY2t9IGlzIGF0dGFjaGVkXG4gICAgICogQHJldHVybnMge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhRWxlbWVudFxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgdmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215LXZpZGVvLWVsZW1lbnQnKTtcbiAgICAgKiB2aWRlb1RyYWNrLmRldGFjaCh2aWRlb0VsZW1lbnQpLnJlbW92ZSgpO1xuICAgICovIC8qKlxuICAgICAqIERldGFjaCB0aGUge0BsaW5rIFZpZGVvVHJhY2t9IGZyb20gYSBwcmV2aW91c2x5IGF0dGFjaGVkIEhUTUxNZWRpYUVsZW1lbnRcbiAgICAgKiAgIHNwZWNpZmllZCBieSA8Y29kZT5kb2N1bWVudC5xdWVyeVNlbGVjdG9yPC9jb2RlPi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgLSBUaGUgcXVlcnkgc2VsZWN0b3Igb2YgSFRNTE1lZGlhRWxlbWVudCB0byB3aGljaFxuICAgICAqICAgIHRoZSB7QGxpbmsgVmlkZW9UcmFja30gaXMgYXR0YWNoZWRcbiAgICAgKiBAcmV0dXJucyB7SFRNTE1lZGlhRWxlbWVudH0gbWVkaWFFbGVtZW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2aWRlb1RyYWNrLmRldGFjaCgnI215LXZpZGVvLWVsZW1lbnQnKS5yZW1vdmUoKTtcbiAgICAgKi9cbiAgICBWaWRlb1RyYWNrLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmRldGFjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBwcmV2aW91c2x5IGFkZGVkIHtAbGluayBWaWRlb1Byb2Nlc3Nvcn0gdXNpbmcgYGFkZFByb2Nlc3NvcmAgQVBJLlxuICAgICAqIEBwYXJhbSB7VmlkZW9Qcm9jZXNzb3J9IHByb2Nlc3NvciAtIFRoZSB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9IHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNsYXNzIEdyYXlTY2FsZVByb2Nlc3NvciB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwZXJjZW50YWdlKSB7XG4gICAgICogICAgIHRoaXMucGVyY2VudGFnZSA9IHBlcmNlbnRhZ2U7XG4gICAgICogICB9XG4gICAgICogICBwcm9jZXNzRnJhbWUoaW5wdXRGcmFtZUJ1ZmZlciwgb3V0cHV0RnJhbWVCdWZmZXIpIHtcbiAgICAgKiAgICAgY29uc3QgY29udGV4dCA9IG91dHB1dEZyYW1lQnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICogICAgIGNvbnRleHQuZmlsdGVyID0gYGdyYXlzY2FsZSgke3RoaXMucGVyY2VudGFnZX0lKWA7XG4gICAgICogICAgIGNvbnRleHQuZHJhd0ltYWdlKGlucHV0RnJhbWVCdWZmZXIsIDAsIDAsIGlucHV0RnJhbWVCdWZmZXIud2lkdGgsIGlucHV0RnJhbWVCdWZmZXIuaGVpZ2h0KTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBWaWRlby5jcmVhdGVMb2NhbFZpZGVvVHJhY2soKS50aGVuKGZ1bmN0aW9uKHZpZGVvVHJhY2spIHtcbiAgICAgKiAgIGNvbnN0IGdyYXlTY2FsZVByb2Nlc3NvciA9IG5ldyBHcmF5U2NhbGVQcm9jZXNzb3IoMTAwKTtcbiAgICAgKiAgIHZpZGVvVHJhY2suYWRkUHJvY2Vzc29yKGdyYXlTY2FsZVByb2Nlc3Nvcik7XG4gICAgICogICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVtb3ZlLWJ1dHRvbicpLm9uY2xpY2sgPSAoKSA9PiB2aWRlb1RyYWNrLnJlbW92ZVByb2Nlc3NvcihncmF5U2NhbGVQcm9jZXNzb3IpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIFZpZGVvVHJhY2sucHJvdG90eXBlLnJlbW92ZVByb2Nlc3NvciA9IGZ1bmN0aW9uIChwcm9jZXNzb3IpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjZWl2ZWQgYW4gaW52YWxpZCBWaWRlb1Byb2Nlc3NvciBmcm9tIHJlbW92ZVByb2Nlc3Nvci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV4aXN0aW5nIFZpZGVvUHJvY2Vzc29yIGRldGVjdGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzb3IgIT09IHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBWaWRlb1Byb2Nlc3NvciBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgZXhpc3Rpbmcgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIuZW1pdCgncmVtb3ZlJyk7XG4gICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygnUmVtb3ZpbmcgVmlkZW9Qcm9jZXNzb3IgZnJvbSB0aGUgVmlkZW9UcmFjaycsIHByb2Nlc3Nvcik7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jYXB0dXJlVGltZW91dElkKTtcbiAgICAgICAgaWYgKHRoaXMubWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuX3VubXV0ZUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VubXV0ZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9pc0NhcHR1cmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkVHJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbnB1dEZyYW1lLmdldENvbnRleHQoJzJkJykuY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2lucHV0RnJhbWUud2lkdGgsIHRoaXMuX2lucHV0RnJhbWUuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fb3V0cHV0RnJhbWUuZ2V0Q29udGV4dCgnMmQnKS5jbGVhclJlY3QoMCwgMCwgdGhpcy5fb3V0cHV0RnJhbWUud2lkdGgsIHRoaXMuX291dHB1dEZyYW1lLmhlaWdodCk7XG4gICAgICAgIHRoaXMuX2lucHV0RnJhbWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9vdXRwdXRGcmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUVsZW1lbnRzTWVkaWFTdHJlYW1UcmFjaygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBWaWRlb1RyYWNrO1xufShNZWRpYVRyYWNrKSk7XG5WaWRlb1RyYWNrLkRJTUVOU0lPTlNfQ0hBTkdFRCA9ICdkaW1lbnNpb25zQ2hhbmdlZCc7XG5mdW5jdGlvbiBkaW1lbnNpb25zQ2hhbmdlZCh0cmFjaywgZWxlbSkge1xuICAgIHJldHVybiB0cmFjay5kaW1lbnNpb25zLndpZHRoICE9PSBlbGVtLnZpZGVvV2lkdGhcbiAgICAgICAgfHwgdHJhY2suZGltZW5zaW9ucy5oZWlnaHQgIT09IGVsZW0udmlkZW9IZWlnaHQ7XG59XG4vKipcbiAqIEEge0BsaW5rIFZpZGVvVHJhY2t9J3Mgd2lkdGggYW5kIGhlaWdodC5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IFZpZGVvVHJhY2suRGltZW5zaW9uc1xuICogQHByb3BlcnR5IHs/bnVtYmVyfSB3aWR0aCAtIFRoZSB7QGxpbmsgVmlkZW9UcmFja30ncyB3aWR0aCBvciBudWxsIGlmIHRoZVxuICogICB7QGxpbmsgVmlkZW9UcmFja30gaGFzIG5vdCB5ZXQgc3RhcnRlZFxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBoZWlnaHQgLSBUaGUge0BsaW5rIFZpZGVvVHJhY2t9J3MgaGVpZ2h0IG9yIG51bGwgaWYgdGhlXG4gKiAgIHtAbGluayBWaWRlb1RyYWNrfSBoYXMgbm90IHlldCBzdGFydGVkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9LCB3aGVuIGFkZGVkIHZpYSB7QGxpbmsgVmlkZW9UcmFjayNhZGRQcm9jZXNzb3J9LFxuICogaXMgdXNlZCB0byBwcm9jZXNzIGluY29taW5nIHZpZGVvIGZyYW1lcyBiZWZvcmVcbiAqIHNlbmRpbmcgdG8gdGhlIGVuY29kZXIgb3IgcmVuZGVyZXIuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBWaWRlb1Byb2Nlc3NvclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcHJvY2Vzc0ZyYW1lIC0gQSBjYWxsYmFjayB0byByZWNlaXZlIGlucHV0IGFuZCBvdXRwdXQgZnJhbWUgYnVmZmVycyBmb3IgcHJvY2Vzc2luZy5cbiAqIFRoZSBpbnB1dCBmcmFtZSBidWZmZXIgY29udGFpbnMgdGhlIG9yaWdpbmFsIHZpZGVvIGZyYW1lIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBhZGRpdGlvbmFsIHByb2Nlc3NpbmdcbiAqIHN1Y2ggYXMgYXBwbHlpbmcgZmlsdGVycyB0byBpdC4gVGhlIG91dHB1dCBmcmFtZSBidWZmZXIgaXMgdXNlZCB0byByZWNlaXZlIHRoZSBwcm9jZXNzZWQgdmlkZW8gZnJhbWVcbiAqIGJlZm9yZSBzZW5kaW5nIHRvIHRoZSBlbmNvZGVyIG9yIHJlbmRlcmVyLlxuICpcbiAqIEFueSBleGNlcHRpb24gcmFpc2VkIChlaXRoZXIgc3luY2hyb25vdXNseSBvciBhc3luY2hyb25vdXNseSkgaW4gYHByb2Nlc3NGcmFtZWAgd2lsbCByZXN1bHQgaW4gdGhlIGZyYW1lIGJlaW5nIGRyb3BwZWQuXG4gKiBUaGlzIGNhbGxiYWNrIGhhcyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTo8YnIvPjxici8+XG4gKiA8Y29kZT5wcm9jZXNzRnJhbWUoPC9jb2RlPjxici8+XG4gKiAmbmJzcDsmbmJzcDs8Y29kZT5pbnB1dEZyYW1lQnVmZmVyOiBPZmZzY3JlZW5DYW52YXMsPC9jb2RlPjxici8+XG4gKiAmbmJzcDsmbmJzcDs8Y29kZT5vdXRwdXRGcmFtZUJ1ZmZlcjogSFRNTENhbnZhc0VsZW1lbnQ8L2NvZGU+PGJyLz5cbiAqIDxjb2RlPik6IFByb21pc2UmbHQ7dm9pZCZndDsgfCB2b2lkOzwvY29kZT5cbiAqXG4gKiBAZXhhbXBsZVxuICogY2xhc3MgR3JheVNjYWxlUHJvY2Vzc29yIHtcbiAqICAgY29uc3RydWN0b3IocGVyY2VudGFnZSkge1xuICogICAgIHRoaXMucGVyY2VudGFnZSA9IHBlcmNlbnRhZ2U7XG4gKiAgIH1cbiAqICAgcHJvY2Vzc0ZyYW1lKGlucHV0RnJhbWVCdWZmZXIsIG91dHB1dEZyYW1lQnVmZmVyKSB7XG4gKiAgICAgY29uc3QgY29udGV4dCA9IG91dHB1dEZyYW1lQnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gKiAgICAgY29udGV4dC5maWx0ZXIgPSBgZ3JheXNjYWxlKCR7dGhpcy5wZXJjZW50YWdlfSUpYDtcbiAqICAgICBjb250ZXh0LmRyYXdJbWFnZShpbnB1dEZyYW1lQnVmZmVyLCAwLCAwLCBpbnB1dEZyYW1lQnVmZmVyLndpZHRoLCBpbnB1dEZyYW1lQnVmZmVyLmhlaWdodCk7XG4gKiAgIH1cbiAqIH1cbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFZpZGVvVHJhY2t9J3MgZGltZW5zaW9ucyBjaGFuZ2VkLlxuICogQHBhcmFtIHtWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgVmlkZW9UcmFja30gd2hvc2UgZGltZW5zaW9ucyBjaGFuZ2VkXG4gKiBAZXZlbnQgVmlkZW9UcmFjayNkaW1lbnNpb25zQ2hhbmdlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgVmlkZW9UcmFja30gd2FzIGRpc2FibGVkLCBpLmUuIFwicGF1c2VkXCIuXG4gKiBAcGFyYW0ge1ZpZGVvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBWaWRlb1RyYWNrfSB0aGF0IHdhcyBkaXNhYmxlZFxuICogQGV2ZW50IFZpZGVvVHJhY2sjZGlzYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFZpZGVvVHJhY2t9IHdhcyBlbmFibGVkLCBpLmUuIFwidW5wYXVzZWRcIi5cbiAqIEBwYXJhbSB7VmlkZW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFZpZGVvVHJhY2t9IHRoYXQgd2FzIGVuYWJsZWRcbiAqIEBldmVudCBWaWRlb1RyYWNrI2VuYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFZpZGVvVHJhY2t9IHN0YXJ0ZWQuIFRoaXMgbWVhbnMgdGhlcmUgaXMgZW5vdWdoIHZpZGVvIGRhdGEgdG9cbiAqIGJlZ2luIHBsYXliYWNrLlxuICogQHBhcmFtIHtWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgVmlkZW9UcmFja30gdGhhdCBzdGFydGVkXG4gKiBAZXZlbnQgVmlkZW9UcmFjayNzdGFydGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlkZW9UcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZGVvdHJhY2suanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgX2EgPSByZXF1aXJlKCcuL3V0aWwvY29uc3RhbnRzJyksIERFRkFVTFRfTlFfTEVWRUxfTE9DQUwgPSBfYS5ERUZBVUxUX05RX0xFVkVMX0xPQ0FMLCBERUZBVUxUX05RX0xFVkVMX1JFTU9URSA9IF9hLkRFRkFVTFRfTlFfTEVWRUxfUkVNT1RFLCBNQVhfTlFfTEVWRUwgPSBfYS5NQVhfTlFfTEVWRUw7XG52YXIgaW5SYW5nZSA9IHJlcXVpcmUoJy4vdXRpbCcpLmluUmFuZ2U7XG4vKipcbiAqIHtAbGluayBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25JbXBsfSByZXByZXNlbnRzIGFuIG9iamVjdCB3aGljaCBub3RpZmllcyBpdHNcbiAqIGxpc3RlbmVycyBvZiBhbnkgY2hhbmdlcyBpbiB0aGUgdmFsdWVzIG9mIGl0cyBwcm9wZXJ0aWVzLlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAaW1wbGVtZW50cyBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25cbiAqIEBwcm9wZXJ0eSB7P05ldHdvcmtRdWFsaXR5VmVyYm9zaXR5fSBsb2NhbCAtIFZlcmJvc2l0eSBsZXZlbCBmb3Ige0BsaW5rIExvY2FsUGFydGljaXBhbnR9XG4gKiBAcHJvcGVydHkgez9OZXR3b3JrUXVhbGl0eVZlcmJvc2l0eX0gcmVtb3RlIC0gVmVyYm9zaXR5IGxldmVsIGZvciB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9c1xuICovXG52YXIgTmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uSW1wbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4ge0BsaW5rIE5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbkltcGx9LlxuICAgICAqIEBwYXJhbSB7TmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9ufSBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24gLSBJbml0aWFsIHtAbGluayBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb259XG4gICAgICovXG4gICAgZnVuY3Rpb24gTmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uSW1wbChuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBsb2NhbDogREVGQVVMVF9OUV9MRVZFTF9MT0NBTCxcbiAgICAgICAgICAgIHJlbW90ZTogREVGQVVMVF9OUV9MRVZFTF9SRU1PVEVcbiAgICAgICAgfSwgbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIGxvY2FsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGluUmFuZ2UobmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uLmxvY2FsLCBERUZBVUxUX05RX0xFVkVMX0xPQ0FMLCBNQVhfTlFfTEVWRUwpXG4gICAgICAgICAgICAgICAgICAgID8gbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uLmxvY2FsXG4gICAgICAgICAgICAgICAgICAgIDogREVGQVVMVF9OUV9MRVZFTF9MT0NBTCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpblJhbmdlKG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbi5yZW1vdGUsIERFRkFVTFRfTlFfTEVWRUxfUkVNT1RFLCBNQVhfTlFfTEVWRUwpXG4gICAgICAgICAgICAgICAgICAgID8gbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uLnJlbW90ZVxuICAgICAgICAgICAgICAgICAgICA6IERFRkFVTFRfTlFfTEVWRUxfUkVNT1RFLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdmVyYm9zaXR5IGxldmVscyBmb3IgbmV0d29yayBxdWFsaXR5IGluZm9ybWF0aW9uIGZvclxuICAgICAqIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBhbmQge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB3aXRoIHRob3NlXG4gICAgICogaW4gdGhlIGdpdmVuIHtAbGluayBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb259LlxuICAgICAqIEBwYXJhbSB7TmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9ufSBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24gLSBUaGUgbmV3IHtAbGluayBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb259XG4gICAgICovXG4gICAgTmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uSW1wbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGxvY2FsOiB0aGlzLmxvY2FsLFxuICAgICAgICAgICAgcmVtb3RlOiB0aGlzLnJlbW90ZVxuICAgICAgICB9LCBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBbXG4gICAgICAgICAgICBbJ2xvY2FsJywgREVGQVVMVF9OUV9MRVZFTF9MT0NBTCwgM10sXG4gICAgICAgICAgICBbJ3JlbW90ZScsIERFRkFVTFRfTlFfTEVWRUxfUkVNT1RFLCAzXVxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDMpLCBsb2NhbE9yUmVtb3RlID0gX2JbMF0sIG1pbiA9IF9iWzFdLCBtYXggPSBfYlsyXTtcbiAgICAgICAgICAgIF90aGlzW2xvY2FsT3JSZW1vdGVdID0gdHlwZW9mIG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbltsb2NhbE9yUmVtb3RlXSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAmJiBpblJhbmdlKG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbltsb2NhbE9yUmVtb3RlXSwgbWluLCBtYXgpXG4gICAgICAgICAgICAgICAgPyBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25bbG9jYWxPclJlbW90ZV1cbiAgICAgICAgICAgICAgICA6IG1pbjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uSW1wbDtcbn0oRXZlbnRFbWl0dGVyKSk7XG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbkltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrcXVhbGl0eWNvbmZpZ3VyYXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xuICAgIHJldHVybiB0bztcbn07XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9ldmVudGVtaXR0ZXInKTtcbnZhciBSZW1vdGVBdWRpb1RyYWNrID0gcmVxdWlyZSgnLi9tZWRpYS90cmFjay9yZW1vdGVhdWRpb3RyYWNrJyk7XG52YXIgUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uID0gcmVxdWlyZSgnLi9tZWRpYS90cmFjay9yZW1vdGVhdWRpb3RyYWNrcHVibGljYXRpb24nKTtcbnZhciBSZW1vdGVEYXRhVHJhY2sgPSByZXF1aXJlKCcuL21lZGlhL3RyYWNrL3JlbW90ZWRhdGF0cmFjaycpO1xudmFyIFJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uID0gcmVxdWlyZSgnLi9tZWRpYS90cmFjay9yZW1vdGVkYXRhdHJhY2twdWJsaWNhdGlvbicpO1xudmFyIFJlbW90ZVZpZGVvVHJhY2sgPSByZXF1aXJlKCcuL21lZGlhL3RyYWNrL3JlbW90ZXZpZGVvdHJhY2snKTtcbnZhciBSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb24gPSByZXF1aXJlKCcuL21lZGlhL3RyYWNrL3JlbW90ZXZpZGVvdHJhY2twdWJsaWNhdGlvbicpO1xudmFyIF9hID0gcmVxdWlyZSgnLi91dGlsJyksIHJlZW1pdFRyYWNrUHVibGljYXRpb25FdmVudHMgPSBfYS5yZWVtaXRUcmFja1B1YmxpY2F0aW9uRXZlbnRzLCB0cmFja0NsYXNzID0gX2EudHJhY2tDbGFzcywgdHJhY2tQdWJsaWNhdGlvbkNsYXNzID0gX2EudHJhY2tQdWJsaWNhdGlvbkNsYXNzLCB2YWx1ZVRvSlNPTiA9IF9hLnZhbHVlVG9KU09OO1xudmFyIG5JbnN0YW5jZXMgPSAwO1xuLyoqXG4gKiB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gaXMgYSB2YWx1ZSBmcm9tIDDigJM1LCBpbmNsdXNpdmUsIHJlcHJlc2VudGluZyB0aGVcbiAqIHF1YWxpdHkgb2YgYSBuZXR3b3JrIGNvbm5lY3Rpb24uXG4gKiBAdHlwZWRlZiB7bnVtYmVyfSBOZXR3b3JrUXVhbGl0eUxldmVsXG4gKi9cbi8qKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAcHJvcGVydHkge01hcDxUcmFjay5TSUQsIEF1ZGlvVHJhY2tQdWJsaWNhdGlvbj59IGF1ZGlvVHJhY2tzIC1cbiAqICAgIFRoZSB7QGxpbmsgUGFydGljaXBhbnR9J3Mge0BsaW5rIEF1ZGlvVHJhY2tQdWJsaWNhdGlvbn1zXG4gKiBAcHJvcGVydHkge01hcDxUcmFjay5TSUQsIERhdGFUcmFja1B1YmxpY2F0aW9uPn0gZGF0YVRyYWNrcyAtXG4gKiAgICBUaGUge0BsaW5rIFBhcnRpY2lwYW50fSdzIHtAbGluayBEYXRhVHJhY2tQdWJsaWNhdGlvbn1zLlxuICogQHByb3BlcnR5IHtQYXJ0aWNpcGFudC5JZGVudGl0eX0gaWRlbnRpdHkgLSBUaGUgaWRlbnRpdHkgb2YgdGhlIHtAbGluayBQYXJ0aWNpcGFudH1cbiAqIEBwcm9wZXJ0eSB7P05ldHdvcmtRdWFsaXR5TGV2ZWx9IG5ldHdvcmtRdWFsaXR5TGV2ZWwgLSBUaGVcbiAqICAgIHtAbGluayBQYXJ0aWNpcGFudH0ncyBjdXJyZW50IHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfSwgaWYgYW55XG4gKiBAcHJvcGVydHkgez9OZXR3b3JrUXVhbGl0eVN0YXRzfSBuZXR3b3JrUXVhbGl0eVN0YXRzIC0gVGhlXG4gKiAgICB7QGxpbmsgUGFydGljaXBhbnR9J3MgY3VycmVudCB7QGxpbmsgTmV0d29ya1F1YWxpdHlTdGF0c30sIGlmIGFueVxuICogQHByb3BlcnR5IHtQYXJ0aWNpcGFudC5TSUR9IHNpZCAtIFRoZSB7QGxpbmsgUGFydGljaXBhbnR9J3MgU0lEXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBcImNvbm5lY3RlZFwiLCBcImRpc2Nvbm5lY3RlZFwiIG9yIFwicmVjb25uZWN0aW5nXCJcbiAqIEBwcm9wZXJ0eSB7TWFwPFRyYWNrLlNJRCwgVHJhY2tQdWJsaWNhdGlvbj59IHRyYWNrcyAtXG4gKiAgICBUaGUge0BsaW5rIFBhcnRpY2lwYW50fSdzIHtAbGluayBUcmFja1B1YmxpY2F0aW9ufXNcbiAqIEBwcm9wZXJ0eSB7TWFwPFRyYWNrLlNJRCwgVmlkZW9UcmFja1B1YmxpY2F0aW9uPn0gdmlkZW9UcmFja3MgLVxuICogICAgVGhlIHtAbGluayBQYXJ0aWNpcGFudH0ncyB7QGxpbmsgVmlkZW9UcmFja1B1YmxpY2F0aW9ufXNcbiAqIEBlbWl0cyBQYXJ0aWNpcGFudCNkaXNjb25uZWN0ZWRcbiAqIEBlbWl0cyBQYXJ0aWNpcGFudCNuZXR3b3JrUXVhbGl0eUxldmVsQ2hhbmdlZFxuICogQGVtaXRzIFBhcnRpY2lwYW50I3JlY29ubmVjdGVkXG4gKiBAZW1pdHMgUGFydGljaXBhbnQjcmVjb25uZWN0aW5nXG4gKiBAZW1pdHMgUGFydGljaXBhbnQjdHJhY2tEaW1lbnNpb25zQ2hhbmdlZFxuICogQGVtaXRzIFBhcnRpY2lwYW50I3RyYWNrU3RhcnRlZFxuICovXG52YXIgUGFydGljaXBhbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcnRpY2lwYW50LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBQYXJ0aWNpcGFudH0uXG4gICAgICogQHBhcmFtIHtQYXJ0aWNpcGFudFNpZ25hbGluZ30gc2lnbmFsaW5nXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhcnRpY2lwYW50KHNpZ25hbGluZywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBSZW1vdGVBdWRpb1RyYWNrOiBSZW1vdGVBdWRpb1RyYWNrLFxuICAgICAgICAgICAgUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uOiBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24sXG4gICAgICAgICAgICBSZW1vdGVEYXRhVHJhY2s6IFJlbW90ZURhdGFUcmFjayxcbiAgICAgICAgICAgIFJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uOiBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbixcbiAgICAgICAgICAgIFJlbW90ZVZpZGVvVHJhY2s6IFJlbW90ZVZpZGVvVHJhY2ssXG4gICAgICAgICAgICBSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb246IFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbixcbiAgICAgICAgICAgIHRyYWNrczogW11cbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBpbmRleGVkID0gaW5kZXhUcmFja3NCeUlkKG9wdGlvbnMudHJhY2tzKTtcbiAgICAgICAgdmFyIGxvZyA9IG9wdGlvbnMubG9nLmNyZWF0ZUxvZygnZGVmYXVsdCcsIF90aGlzKTtcbiAgICAgICAgdmFyIGF1ZGlvVHJhY2tzID0gbmV3IE1hcChpbmRleGVkLmF1ZGlvVHJhY2tzKTtcbiAgICAgICAgdmFyIGRhdGFUcmFja3MgPSBuZXcgTWFwKGluZGV4ZWQuZGF0YVRyYWNrcyk7XG4gICAgICAgIHZhciB0cmFja3MgPSBuZXcgTWFwKGluZGV4ZWQudHJhY2tzKTtcbiAgICAgICAgdmFyIHZpZGVvVHJhY2tzID0gbmV3IE1hcChpbmRleGVkLnZpZGVvVHJhY2tzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9SZW1vdGVBdWRpb1RyYWNrOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuUmVtb3RlQXVkaW9UcmFja1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9SZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5SZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfUmVtb3RlRGF0YVRyYWNrOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuUmVtb3RlRGF0YVRyYWNrXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX1JlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfUmVtb3RlVmlkZW9UcmFjazoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLlJlbW90ZVZpZGVvVHJhY2tcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2F1ZGlvVHJhY2tzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGF1ZGlvVHJhY2tzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2RhdGFUcmFja3M6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YVRyYWNrc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pbnN0YW5jZUlkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICsrbkluc3RhbmNlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NvbnRlbnRQcmVmZXJlbmNlc01vZGU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5jb250ZW50UHJlZmVyZW5jZXNNb2RlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sb2c6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbG9nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NpZ25hbGluZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzaWduYWxpbmdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdHJhY2tzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRyYWNrc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90cmFja0V2ZW50UmVlbWl0dGVyczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdHJhY2tQdWJsaWNhdGlvbkV2ZW50UmVlbWl0dGVyczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdHJhY2tTaWduYWxpbmdVcGRhdGVkRXZlbnRDYWxsYmFja3M6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ZpZGVvVHJhY2tzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZpZGVvVHJhY2tzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXVkaW9UcmFja3M6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhVHJhY2tzOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWRlbnRpdHk6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsaW5nLmlkZW50aXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXR3b3JrUXVhbGl0eUxldmVsOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hbGluZy5uZXR3b3JrUXVhbGl0eUxldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXR3b3JrUXVhbGl0eVN0YXRzOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hbGluZy5uZXR3b3JrUXVhbGl0eVN0YXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsaW5nLnNpZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsaW5nLnN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFja3M6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aWRlb1RyYWNrczoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuX3RyYWNrcy5mb3JFYWNoKHJlZW1pdFRyYWNrRXZlbnRzLmJpbmQobnVsbCwgX3RoaXMpKTtcbiAgICAgICAgc2lnbmFsaW5nLm9uKCduZXR3b3JrUXVhbGl0eUxldmVsQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCduZXR3b3JrUXVhbGl0eUxldmVsQ2hhbmdlZCcsIF90aGlzLm5ldHdvcmtRdWFsaXR5TGV2ZWwsIF90aGlzLm5ldHdvcmtRdWFsaXR5U3RhdHMgJiZcbiAgICAgICAgICAgICAgICAoX3RoaXMubmV0d29ya1F1YWxpdHlTdGF0cy5hdWRpbyB8fCBfdGhpcy5uZXR3b3JrUXVhbGl0eVN0YXRzLnZpZGVvKVxuICAgICAgICAgICAgICAgID8gX3RoaXMubmV0d29ya1F1YWxpdHlTdGF0c1xuICAgICAgICAgICAgICAgIDogbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZWVtaXRTaWduYWxpbmdTdGF0ZUNoYW5nZWRFdmVudHMoX3RoaXMsIHNpZ25hbGluZyk7XG4gICAgICAgIGxvZy5pbmZvKFwiQ3JlYXRlZCBhIG5ldyBQYXJ0aWNpcGFudFwiICsgKF90aGlzLmlkZW50aXR5ID8gXCI6IFwiICsgX3RoaXMuaWRlbnRpdHkgOiAnJykpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSBldmVudHMgdG8gcmUtZW1pdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxzdHJpbmc+Pn0gZXZlbnRzXG4gICAgICovXG4gICAgUGFydGljaXBhbnQucHJvdG90eXBlLl9nZXRUcmFja0V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFsnZGltZW5zaW9uc0NoYW5nZWQnLCAndHJhY2tEaW1lbnNpb25zQ2hhbmdlZCddLFxuICAgICAgICAgICAgWydtZXNzYWdlJywgJ3RyYWNrTWVzc2FnZSddLFxuICAgICAgICAgICAgWydzdGFydGVkJywgJ3RyYWNrU3RhcnRlZCddXG4gICAgICAgIF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBhcnRpY2lwYW50LnByb3RvdHlwZS5fZ2V0VHJhY2tQdWJsaWNhdGlvbkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgUGFydGljaXBhbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbUGFydGljaXBhbnQgI1wiICsgdGhpcy5faW5zdGFuY2VJZCArIFwiOiBcIiArIHRoaXMuc2lkICsgXCJdXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrXG4gICAgICogQHBhcmFtIHtrZXl9IGtleVxuICAgICAqIEByZXR1cm5zIHs/VHJhY2t9XG4gICAgICovXG4gICAgUGFydGljaXBhbnQucHJvdG90eXBlLl9hZGRUcmFjayA9IGZ1bmN0aW9uICh0cmFjaywga2V5KSB7XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIGlmICh0aGlzLl90cmFja3MuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYWNrcy5zZXQoa2V5LCB0cmFjayk7XG4gICAgICAgIHZhciB0cmFja3NCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogdGhpcy5fYXVkaW9UcmFja3MsXG4gICAgICAgICAgICB2aWRlbzogdGhpcy5fdmlkZW9UcmFja3MsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLl9kYXRhVHJhY2tzXG4gICAgICAgIH1bdHJhY2sua2luZF07XG4gICAgICAgIHRyYWNrc0J5S2luZC5zZXQoa2V5LCB0cmFjayk7XG4gICAgICAgIHJlZW1pdFRyYWNrRXZlbnRzKHRoaXMsIHRyYWNrLCBrZXkpO1xuICAgICAgICBsb2cuaW5mbyhcIkFkZGVkIGEgbmV3IFwiICsgdHJhY2tDbGFzcyh0cmFjaykgKyBcIjpcIiwga2V5KTtcbiAgICAgICAgbG9nLmRlYnVnKHRyYWNrQ2xhc3ModHJhY2spICsgXCI6XCIsIHRyYWNrKTtcbiAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1RyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uXG4gICAgICogQHJldHVybnMgez9UcmFja1B1YmxpY2F0aW9ufVxuICAgICAqL1xuICAgIFBhcnRpY2lwYW50LnByb3RvdHlwZS5fYWRkVHJhY2tQdWJsaWNhdGlvbiA9IGZ1bmN0aW9uIChwdWJsaWNhdGlvbikge1xuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBpZiAodGhpcy50cmFja3MuaGFzKHB1YmxpY2F0aW9uLnRyYWNrU2lkKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja3Muc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIHZhciB0cmFja1B1YmxpY2F0aW9uc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiB0aGlzLmF1ZGlvVHJhY2tzLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhVHJhY2tzLFxuICAgICAgICAgICAgdmlkZW86IHRoaXMudmlkZW9UcmFja3NcbiAgICAgICAgfVtwdWJsaWNhdGlvbi5raW5kXTtcbiAgICAgICAgdHJhY2tQdWJsaWNhdGlvbnNCeUtpbmQuc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIGxvZy5pbmZvKFwiQWRkZWQgYSBuZXcgXCIgKyB0cmFja1B1YmxpY2F0aW9uQ2xhc3MocHVibGljYXRpb24pICsgXCI6XCIsIHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgbG9nLmRlYnVnKHRyYWNrUHVibGljYXRpb25DbGFzcyhwdWJsaWNhdGlvbikgKyBcIjpcIiwgcHVibGljYXRpb24pO1xuICAgICAgICByZXR1cm4gcHVibGljYXRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBhcnRpY2lwYW50LnByb3RvdHlwZS5faGFuZGxlVHJhY2tTaWduYWxpbmdFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGxvZyA9IF9hLl9sb2csIGNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCA9IF9hLl9jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wsIGNvbnRlbnRQcmVmZXJlbmNlc01vZGUgPSBfYS5fY29udGVudFByZWZlcmVuY2VzTW9kZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgUmVtb3RlQXVkaW9UcmFjayA9IHRoaXMuX1JlbW90ZUF1ZGlvVHJhY2s7XG4gICAgICAgIHZhciBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24gPSB0aGlzLl9SZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb247XG4gICAgICAgIHZhciBSZW1vdGVWaWRlb1RyYWNrID0gdGhpcy5fUmVtb3RlVmlkZW9UcmFjaztcbiAgICAgICAgdmFyIFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbiA9IHRoaXMuX1JlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbjtcbiAgICAgICAgdmFyIFJlbW90ZURhdGFUcmFjayA9IHRoaXMuX1JlbW90ZURhdGFUcmFjaztcbiAgICAgICAgdmFyIFJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uID0gdGhpcy5fUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb247XG4gICAgICAgIHZhciBwYXJ0aWNpcGFudFNpZ25hbGluZyA9IHRoaXMuX3NpZ25hbGluZztcbiAgICAgICAgZnVuY3Rpb24gdHJhY2tTaWduYWxpbmdBZGRlZChzaWduYWxpbmcpIHtcbiAgICAgICAgICAgIHZhciByZWVtaXRFdmVudHNUb1JlbW90ZVBhcnRpY2lwYW50ID0gZnVuY3Rpb24gKHB1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmVlbWl0VHJhY2tQdWJsaWNhdGlvbkV2ZW50cyhzZWxmLCBwdWJsaWNhdGlvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIFJlbW90ZVRyYWNrUHVibGljYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgYXVkaW86IFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbixcbiAgICAgICAgICAgICAgICBkYXRhOiBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbixcbiAgICAgICAgICAgICAgICB2aWRlbzogUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uXG4gICAgICAgICAgICB9W3NpZ25hbGluZy5raW5kXTtcbiAgICAgICAgICAgIHZhciBwdWJsaWNhdGlvbiA9IG5ldyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKHNpZ25hbGluZywgeyBsb2c6IGxvZywgcmVlbWl0RXZlbnRzVG9SZW1vdGVQYXJ0aWNpcGFudDogcmVlbWl0RXZlbnRzVG9SZW1vdGVQYXJ0aWNpcGFudCB9KTtcbiAgICAgICAgICAgIHNlbGYuX2FkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuICAgICAgICAgICAgdmFyIGlzU3Vic2NyaWJlZCA9IHNpZ25hbGluZy5pc1N1YnNjcmliZWQ7XG4gICAgICAgICAgICBpZiAoaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tTaWduYWxpbmdTdWJzY3JpYmVkKHNpZ25hbGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl90cmFja1NpZ25hbGluZ1VwZGF0ZWRFdmVudENhbGxiYWNrcy5zZXQoc2lnbmFsaW5nLnNpZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1N1YnNjcmliZWQgIT09IHNpZ25hbGluZy5pc1N1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNTdWJzY3JpYmVkID0gc2lnbmFsaW5nLmlzU3Vic2NyaWJlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tTaWduYWxpbmdTdWJzY3JpYmVkKHNpZ25hbGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJhY2tTaWduYWxpbmdVbnN1YnNjcmliZWQoc2lnbmFsaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNpZ25hbGluZy5vbigndXBkYXRlZCcsIHNlbGYuX3RyYWNrU2lnbmFsaW5nVXBkYXRlZEV2ZW50Q2FsbGJhY2tzLmdldChzaWduYWxpbmcuc2lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJhY2tTaWduYWxpbmdSZW1vdmVkKHNpZ25hbGluZykge1xuICAgICAgICAgICAgaWYgKHNpZ25hbGluZy5pc1N1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICBzaWduYWxpbmcuc2V0VHJhY2tUcmFuc2NlaXZlcihudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdXBkYXRlZCA9IHNlbGYuX3RyYWNrU2lnbmFsaW5nVXBkYXRlZEV2ZW50Q2FsbGJhY2tzLmdldChzaWduYWxpbmcuc2lkKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgc2lnbmFsaW5nLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGVkJywgdXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fdHJhY2tTaWduYWxpbmdVcGRhdGVkRXZlbnRDYWxsYmFja3MuZGVsZXRlKHNpZ25hbGluZy5zaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHB1YmxpY2F0aW9uID0gc2VsZi50cmFja3MuZ2V0KHNpZ25hbGluZy5zaWQpO1xuICAgICAgICAgICAgaWYgKHB1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJhY2tTaWduYWxpbmdTdWJzY3JpYmVkKHNpZ25hbGluZykge1xuICAgICAgICAgICAgdmFyIGlzRW5hYmxlZCA9IHNpZ25hbGluZy5pc0VuYWJsZWQsIG5hbWUgPSBzaWduYWxpbmcubmFtZSwga2luZCA9IHNpZ25hbGluZy5raW5kLCBzaWQgPSBzaWduYWxpbmcuc2lkLCB0cmFja1RyYW5zY2VpdmVyID0gc2lnbmFsaW5nLnRyYWNrVHJhbnNjZWl2ZXIsIGlzU3dpdGNoZWRPZmYgPSBzaWduYWxpbmcuaXNTd2l0Y2hlZE9mZiwgcnNwVmVyc2lvbiA9IHNpZ25hbGluZy5yc3BWZXJzaW9uLCBfYSA9IHNpZ25hbGluZy5zd2l0Y2hPZmZSZWFzb24sIHN3aXRjaE9mZlJlYXNvbiA9IF9hID09PSB2b2lkIDAgPyBudWxsIDogX2E7XG4gICAgICAgICAgICB2YXIgUmVtb3RlVHJhY2sgPSB7XG4gICAgICAgICAgICAgICAgYXVkaW86IFJlbW90ZUF1ZGlvVHJhY2ssXG4gICAgICAgICAgICAgICAgdmlkZW86IFJlbW90ZVZpZGVvVHJhY2ssXG4gICAgICAgICAgICAgICAgZGF0YTogUmVtb3RlRGF0YVRyYWNrXG4gICAgICAgICAgICB9W2tpbmRdO1xuICAgICAgICAgICAgdmFyIHB1YmxpY2F0aW9uID0gc2VsZi50cmFja3MuZ2V0KHNpZCk7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHsgbG9nOiBsb2csIG5hbWU6IG5hbWUsIGNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbDogY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sLCBjb250ZW50UHJlZmVyZW5jZXNNb2RlOiBjb250ZW50UHJlZmVyZW5jZXNNb2RlLCBzaG91bGREZXByZWNhdGVFbmFibGVkU3RhdGU6IHJzcFZlcnNpb24gPj0gMyB9O1xuICAgICAgICAgICAgdmFyIHNldFByaW9yaXR5ID0gZnVuY3Rpb24gKG5ld1ByaW9yaXR5KSB7IHJldHVybiBwYXJ0aWNpcGFudFNpZ25hbGluZy51cGRhdGVTdWJzY3JpYmVyVHJhY2tQcmlvcml0eShzaWQsIG5ld1ByaW9yaXR5KTsgfTtcbiAgICAgICAgICAgIHZhciBzZXRSZW5kZXJIaW50ID0gZnVuY3Rpb24gKHJlbmRlckhpbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsaW5nLmlzU3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudFNpZ25hbGluZy51cGRhdGVUcmFja1JlbmRlckhpbnQoc2lkLCByZW5kZXJIaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRyYWNrID0ga2luZCA9PT0gJ2RhdGEnXG4gICAgICAgICAgICAgICAgPyBuZXcgUmVtb3RlVHJhY2soc2lkLCB0cmFja1RyYW5zY2VpdmVyLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogbmV3IFJlbW90ZVRyYWNrKHNpZCwgdHJhY2tUcmFuc2NlaXZlciwgaXNFbmFibGVkLCBpc1N3aXRjaGVkT2ZmLCBzd2l0Y2hPZmZSZWFzb24sIHNldFByaW9yaXR5LCBzZXRSZW5kZXJIaW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHNlbGYuX2FkZFRyYWNrKHRyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJhY2tTaWduYWxpbmdVbnN1YnNjcmliZWQoc2lnbmFsaW5nKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSBzZWxmLl90cmFja3MuZ2V0KHNpZ25hbGluZy5zaWQpO1xuICAgICAgICAgICAgdmFyIHB1YmxpY2F0aW9uID0gc2VsZi50cmFja3MuZ2V0KHNpZ25hbGluZy5zaWQpO1xuICAgICAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlVHJhY2sodHJhY2ssIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJ0aWNpcGFudFNpZ25hbGluZy5vbigndHJhY2tBZGRlZCcsIHRyYWNrU2lnbmFsaW5nQWRkZWQpO1xuICAgICAgICBwYXJ0aWNpcGFudFNpZ25hbGluZy5vbigndHJhY2tSZW1vdmVkJywgdHJhY2tTaWduYWxpbmdSZW1vdmVkKTtcbiAgICAgICAgcGFydGljaXBhbnRTaWduYWxpbmcudHJhY2tzLmZvckVhY2godHJhY2tTaWduYWxpbmdBZGRlZCk7XG4gICAgICAgIHBhcnRpY2lwYW50U2lnbmFsaW5nLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBzdGF0ZUNoYW5nZWQoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ1JlbW92aW5nIGV2ZW50IGxpc3RlbmVycycpO1xuICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50U2lnbmFsaW5nLnJlbW92ZUxpc3RlbmVyKCdzdGF0ZUNoYW5nZWQnLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50U2lnbmFsaW5nLnJlbW92ZUxpc3RlbmVyKCd0cmFja0FkZGVkJywgdHJhY2tTaWduYWxpbmdBZGRlZCk7XG4gICAgICAgICAgICAgICAgcGFydGljaXBhbnRTaWduYWxpbmcucmVtb3ZlTGlzdGVuZXIoJ3RyYWNrUmVtb3ZlZCcsIHRyYWNrU2lnbmFsaW5nUmVtb3ZlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBBbnkgdHJhbnNpdGlvbiB0byBcImNvbm5lY3RlZFwiIGhlcmUgaXMgYSByZXN1bHQgb2ZcbiAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIHNpZ25hbGluZyByZWNvbm5lY3Rpb24sIGFuZCBub3QgYSBmaXJzdC10aW1lIGVzdGFibGlzaG1lbnRcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgbG9nLmluZm8oJ3JlY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IGBzdGF0ZUNoYW5nZWRgIGNhbiBnZXQgZW1pdHRlZCB3aXRoIFN0YXRlTWFjaGluZSBsb2NrZWQuXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHNpZ25hbCAgcHVibGljIGV2ZW50cyBzeW5jaHJvbm91c2x5IHdpdGggbG9jayBoZWxkLlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5lbWl0KCdyZWNvbm5lY3RlZCcpOyB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHs/VHJhY2t9XG4gICAgICovXG4gICAgUGFydGljaXBhbnQucHJvdG90eXBlLl9yZW1vdmVUcmFjayA9IGZ1bmN0aW9uICh0cmFjaywga2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5fdHJhY2tzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFja3MuZGVsZXRlKGtleSk7XG4gICAgICAgIHZhciB0cmFja3NCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogdGhpcy5fYXVkaW9UcmFja3MsXG4gICAgICAgICAgICB2aWRlbzogdGhpcy5fdmlkZW9UcmFja3MsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLl9kYXRhVHJhY2tzXG4gICAgICAgIH1bdHJhY2sua2luZF07XG4gICAgICAgIHRyYWNrc0J5S2luZC5kZWxldGUoa2V5KTtcbiAgICAgICAgdmFyIHJlZW1pdHRlcnMgPSB0aGlzLl90cmFja0V2ZW50UmVlbWl0dGVycy5nZXQoa2V5KSB8fCBuZXcgTWFwKCk7XG4gICAgICAgIHJlZW1pdHRlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVlbWl0dGVyLCBldmVudCkge1xuICAgICAgICAgICAgdHJhY2sucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIHJlZW1pdHRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBsb2cuaW5mbyhcIlJlbW92ZWQgYSBcIiArIHRyYWNrQ2xhc3ModHJhY2spICsgXCI6XCIsIGtleSk7XG4gICAgICAgIGxvZy5kZWJ1Zyh0cmFja0NsYXNzKHRyYWNrKSArIFwiOlwiLCB0cmFjayk7XG4gICAgICAgIHJldHVybiB0cmFjaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvblxuICAgICAqIEByZXR1cm5zIHs/UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn1cbiAgICAgKi9cbiAgICBQYXJ0aWNpcGFudC5wcm90b3R5cGUuX3JlbW92ZVRyYWNrUHVibGljYXRpb24gPSBmdW5jdGlvbiAocHVibGljYXRpb24pIHtcbiAgICAgICAgcHVibGljYXRpb24gPSB0aGlzLnRyYWNrcy5nZXQocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgICAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrcy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgICAgICB2YXIgdHJhY2tQdWJsaWNhdGlvbnNCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogdGhpcy5hdWRpb1RyYWNrcyxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YVRyYWNrcyxcbiAgICAgICAgICAgIHZpZGVvOiB0aGlzLnZpZGVvVHJhY2tzXG4gICAgICAgIH1bcHVibGljYXRpb24ua2luZF07XG4gICAgICAgIHRyYWNrUHVibGljYXRpb25zQnlLaW5kLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICAgIHZhciByZWVtaXR0ZXJzID0gdGhpcy5fdHJhY2tQdWJsaWNhdGlvbkV2ZW50UmVlbWl0dGVycy5nZXQocHVibGljYXRpb24udHJhY2tTaWQpIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgcmVlbWl0dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZWVtaXR0ZXIsIGV2ZW50KSB7XG4gICAgICAgICAgICBwdWJsaWNhdGlvbi5yZW1vdmVMaXN0ZW5lcihldmVudCwgcmVlbWl0dGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIGxvZy5pbmZvKFwiUmVtb3ZlZCBhIFwiICsgdHJhY2tQdWJsaWNhdGlvbkNsYXNzKHB1YmxpY2F0aW9uKSArIFwiOlwiLCBwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICAgIGxvZy5kZWJ1Zyh0cmFja1B1YmxpY2F0aW9uQ2xhc3MocHVibGljYXRpb24pICsgXCI6XCIsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICAgIH07XG4gICAgUGFydGljaXBhbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlVG9KU09OKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnRpY2lwYW50O1xufShFdmVudEVtaXR0ZXIpKTtcbi8qKlxuICogQSB7QGxpbmsgUGFydGljaXBhbnQuU0lEfSBpcyBhIDM0LWNoYXJhY3RlciBzdHJpbmcgc3RhcnRpbmcgd2l0aCBcIlBBXCJcbiAqIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyBhIHtAbGluayBQYXJ0aWNpcGFudH0uXG4gKiBAdHlwZSBzdHJpbmdcbiAqIEB0eXBlZGVmIFBhcnRpY2lwYW50LlNJRFxuICovXG4vKipcbiAqIEEge0BsaW5rIFBhcnRpY2lwYW50LklkZW50aXR5fSBpcyBhIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYVxuICoge0BsaW5rIFBhcnRpY2lwYW50fS4gWW91IGNhbiB0aGluayBvZiBpdCBsaWtlIGEgbmFtZS5cbiAqIEB0eXBlZGVmIHtzdHJpbmd9IFBhcnRpY2lwYW50LklkZW50aXR5XG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBQYXJ0aWNpcGFudH0gaGFzIGRpc2Nvbm5lY3RlZC5cbiAqIEBwYXJhbSB7UGFydGljaXBhbnR9IHBhcnRpY2lwYW50IC0gVGhlIHtAbGluayBQYXJ0aWNpcGFudH0gdGhhdCBkaXNjb25uZWN0ZWQuXG4gKiBAZXZlbnQgUGFydGljaXBhbnQjZGlzY29ubmVjdGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBQYXJ0aWNpcGFudH0ncyB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gY2hhbmdlZC5cbiAqIEBwYXJhbSB7TmV0d29ya1F1YWxpdHlMZXZlbH0gbmV0d29ya1F1YWxpdHlMZXZlbCAtIFRoZSBuZXdcbiAqICAge0BsaW5rIE5ldHdvcmtRdWFsaXR5TGV2ZWx9XG4gKiBAcGFyYW0gez9OZXR3b3JrUXVhbGl0eVN0YXRzfSBuZXR3b3JrUXVhbGl0eVN0YXRzIC0gVGhlIHtAbGluayBOZXR3b3JrUXVhbGl0eVN0YXRzfVxuICogICBiYXNlZCBvbiB3aGljaCB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gaXMgY2FsY3VsYXRlZCwgaWYgYW55XG4gKiBAZXZlbnQgUGFydGljaXBhbnQjbmV0d29ya1F1YWxpdHlMZXZlbENoYW5nZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFBhcnRpY2lwYW50fSBoYXMgcmVjb25uZWN0ZWQgdG8gdGhlIHtAbGluayBSb29tfSBhZnRlciBhIHNpZ25hbGluZyBjb25uZWN0aW9uIGRpc3J1cHRpb24uXG4gKiBAZXZlbnQgUGFydGljaXBhbnQjcmVjb25uZWN0ZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFBhcnRpY2lwYW50fSBpcyByZWNvbm5lY3RpbmcgdG8gdGhlIHtAbGluayBSb29tfSBhZnRlciBhIHNpZ25hbGluZyBjb25uZWN0aW9uIGRpc3J1cHRpb24uXG4gKiBAZXZlbnQgUGFydGljaXBhbnQjcmVjb25uZWN0aW5nXG4gKi9cbi8qKlxuICogT25lIG9mIHRoZSB7QGxpbmsgUGFydGljaXBhbnR9J3Mge0BsaW5rIFZpZGVvVHJhY2t9J3MgZGltZW5zaW9ucyBjaGFuZ2VkLlxuICogQHBhcmFtIHtWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgVmlkZW9UcmFja30gd2hvc2UgZGltZW5zaW9ucyBjaGFuZ2VkXG4gKiBAZXZlbnQgUGFydGljaXBhbnQjdHJhY2tEaW1lbnNpb25zQ2hhbmdlZFxuICovXG4vKipcbiAqIE9uZSBvZiB0aGUge0BsaW5rIFBhcnRpY2lwYW50fSdzIHtAbGluayBUcmFja31zIHN0YXJ0ZWQuXG4gKiBAcGFyYW0ge1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgVHJhY2t9IHRoYXQgc3RhcnRlZFxuICogQGV2ZW50IFBhcnRpY2lwYW50I3RyYWNrU3RhcnRlZFxuICovXG4vKipcbiAqIEluZGV4ZWQge0BsaW5rIFRyYWNrfXMgYnkge0BsaW5rIFRyYWNrLklEfS5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IEluZGV4ZWRUcmFja3NcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8ezA6IFRyYWNrLklELCAxOiBBdWRpb1RyYWNrfT59IGF1ZGlvVHJhY2tzIC0gSW5kZXhlZFxuICogICB7QGxpbmsgQXVkaW9UcmFja31zXG4gKiBAcHJvcGVydHkge0FycmF5PHswOiBUcmFjay5JRCwgMTogRGF0YVRyYWNrfT59IGRhdGFUcmFja3MgLSBJbmRleGVkXG4gKiAgIHtAbGluayBEYXRhVHJhY2t9c1xuICogQHByb3BlcnR5IHtBcnJheTx7MDogVHJhY2suSUQsIDE6IFRyYWNrfT59IHRyYWNrcyAtIEluZGV4ZWQge0BsaW5rIFRyYWNrfXNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8ezA6IFRyYWNrLklELCAxOiBWaWRlb1RyYWNrfT59IHZpZGVvVHJhY2tzIC0gSW5kZXhlZFxuICogICB7QGxpbmsgVmlkZW9UcmFja31zXG4gKiBAcHJpdmF0ZVxuICovXG4vKipcbiAqIEluZGV4IHRyYWNrcyBieSB7QGxpbmsgVHJhY2suSUR9LlxuICogQHBhcmFtIHtBcnJheTxUcmFjaz59IHRyYWNrc1xuICogQHJldHVybnMge0luZGV4ZWRUcmFja3N9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmRleFRyYWNrc0J5SWQodHJhY2tzKSB7XG4gICAgdmFyIGluZGV4ZWRUcmFja3MgPSB0cmFja3MubWFwKGZ1bmN0aW9uICh0cmFjaykgeyByZXR1cm4gW3RyYWNrLmlkLCB0cmFja107IH0pO1xuICAgIHZhciBpbmRleGVkQXVkaW9UcmFja3MgPSBpbmRleGVkVHJhY2tzLmZpbHRlcihmdW5jdGlvbiAoa2V5VmFsdWUpIHsgcmV0dXJuIGtleVZhbHVlWzFdLmtpbmQgPT09ICdhdWRpbyc7IH0pO1xuICAgIHZhciBpbmRleGVkVmlkZW9UcmFja3MgPSBpbmRleGVkVHJhY2tzLmZpbHRlcihmdW5jdGlvbiAoa2V5VmFsdWUpIHsgcmV0dXJuIGtleVZhbHVlWzFdLmtpbmQgPT09ICd2aWRlbyc7IH0pO1xuICAgIHZhciBpbmRleGVkRGF0YVRyYWNrcyA9IGluZGV4ZWRUcmFja3MuZmlsdGVyKGZ1bmN0aW9uIChrZXlWYWx1ZSkgeyByZXR1cm4ga2V5VmFsdWVbMV0ua2luZCA9PT0gJ2RhdGEnOyB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhdWRpb1RyYWNrczogaW5kZXhlZEF1ZGlvVHJhY2tzLFxuICAgICAgICBkYXRhVHJhY2tzOiBpbmRleGVkRGF0YVRyYWNrcyxcbiAgICAgICAgdHJhY2tzOiBpbmRleGVkVHJhY2tzLFxuICAgICAgICB2aWRlb1RyYWNrczogaW5kZXhlZFZpZGVvVHJhY2tzXG4gICAgfTtcbn1cbi8qKlxuICogUmUtZW1pdCB7QGxpbmsgUGFydGljaXBhbnRTaWduYWxpbmd9ICdzdGF0ZUNoYW5nZWQnIGV2ZW50cy5cbiAqIEBwYXJhbSB7UGFydGljaXBhbnR9IHBhcnRpY2lwYW50XG4gKiBAcGFyYW0ge1BhcnRpY2lwYW50U2lnbmFsaW5nfSBzaWduYWxpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlZW1pdFNpZ25hbGluZ1N0YXRlQ2hhbmdlZEV2ZW50cyhwYXJ0aWNpcGFudCwgc2lnbmFsaW5nKSB7XG4gICAgdmFyIGxvZyA9IHBhcnRpY2lwYW50Ll9sb2c7XG4gICAgaWYgKHBhcnRpY2lwYW50LnN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlZW1pdCBzdGF0ZSB0cmFuc2l0aW9uIGV2ZW50cyBmcm9tIHRoZSBQYXJ0aWNpcGFudFNpZ25hbGluZy5cbiAgICBzaWduYWxpbmcub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICBsb2cuZGVidWcoJ1RyYW5zaXRpb25lZCB0byBzdGF0ZTonLCBzdGF0ZSk7XG4gICAgICAgIHBhcnRpY2lwYW50LmVtaXQoc3RhdGUsIHBhcnRpY2lwYW50KTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgbG9nLmRlYnVnKCdSZW1vdmluZyBUcmFjayBldmVudCByZWVtaXR0ZXJzJyk7XG4gICAgICAgICAgICBzaWduYWxpbmcucmVtb3ZlTGlzdGVuZXIoJ3N0YXRlQ2hhbmdlZCcsIHN0YXRlQ2hhbmdlZCk7XG4gICAgICAgICAgICBwYXJ0aWNpcGFudC5fdHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogRXZlbnQgcmUtZW1pdHRlcnMgZm9yIExvY2FsVHJhY2tzIHVzZSB0aGUgVHJhY2suSUQgYXMgdGhlIGtleSxcbiAgICAgICAgICAgICAgICAvLyB3aGVyZWFzIGV2ZW50IHJlLWVtaXR0ZXJzIGZvciBSZW1vdGVUcmFja3MgdXNlIHRoZSBUcmFjay5TSUQgYXMgdGhlIGtleS5cbiAgICAgICAgICAgICAgICB2YXIgcmVlbWl0dGVycyA9IHBhcnRpY2lwYW50Ll90cmFja0V2ZW50UmVlbWl0dGVycy5nZXQodHJhY2suaWQgfHwgdHJhY2suc2lkKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2sgJiYgcmVlbWl0dGVycykge1xuICAgICAgICAgICAgICAgICAgICByZWVtaXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlZW1pdHRlciwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCByZWVtaXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby13YXJuaW5nLWNvbW1lbnRzXG4gICAgICAgICAgICAvLyBUT0RPKGpvbWEpOiBSZW1vdmluZyB0aGlzIGludHJvZHVjZWQgdW5pdCB0ZXN0IGZhaWx1cmVzIGluIHRoZSBSZW1vdGVQYXJ0aWNpcGFudC5cbiAgICAgICAgICAgIC8vIEludmVzdGlnYXRlIGZ1cnRoZXIgYmVmb3JlIHJlbW92aW5nLlxuICAgICAgICAgICAgc2lnbmFsaW5nLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja1NpZ25hbGluZykge1xuICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IHBhcnRpY2lwYW50Ll90cmFja3MuZ2V0KHRyYWNrU2lnbmFsaW5nLnNpZCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZW1pdHRlcnMgPSBwYXJ0aWNpcGFudC5fdHJhY2tFdmVudFJlZW1pdHRlcnMuZ2V0KHRyYWNrU2lnbmFsaW5nLnNpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrICYmIHJlZW1pdHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVlbWl0dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZWVtaXR0ZXIsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5yZW1vdmVMaXN0ZW5lcihldmVudCwgcmVlbWl0dGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJ0aWNpcGFudC5fdHJhY2tFdmVudFJlZW1pdHRlcnMuY2xlYXIoKTtcbiAgICAgICAgICAgIHBhcnRpY2lwYW50LnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChwdWJsaWNhdGlvbikge1xuICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50Ll90cmFja1B1YmxpY2F0aW9uRXZlbnRSZWVtaXR0ZXJzLmdldChwdWJsaWNhdGlvbi50cmFja1NpZClcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHJlZW1pdHRlciwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVibGljYXRpb24ucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIHJlZW1pdHRlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcnRpY2lwYW50Ll90cmFja1B1YmxpY2F0aW9uRXZlbnRSZWVtaXR0ZXJzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogUmUtZW1pdCB7QGxpbmsgVHJhY2t9IGV2ZW50cy5cbiAqIEBwYXJhbSB7UGFydGljaXBhbnR9IHBhcnRpY2lwYW50XG4gKiBAcGFyYW0ge1RyYWNrfSB0cmFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVlbWl0VHJhY2tFdmVudHMocGFydGljaXBhbnQsIHRyYWNrLCBrZXkpIHtcbiAgICB2YXIgdHJhY2tFdmVudFJlZW1pdHRlcnMgPSBuZXcgTWFwKCk7XG4gICAgaWYgKHBhcnRpY2lwYW50LnN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhcnRpY2lwYW50Ll9nZXRUcmFja0V2ZW50cygpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50UGFpcikge1xuICAgICAgICB2YXIgdHJhY2tFdmVudCA9IGV2ZW50UGFpclswXTtcbiAgICAgICAgdmFyIHBhcnRpY2lwYW50RXZlbnQgPSBldmVudFBhaXJbMV07XG4gICAgICAgIHRyYWNrRXZlbnRSZWVtaXR0ZXJzLnNldCh0cmFja0V2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtwYXJ0aWNpcGFudEV2ZW50XS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0aWNpcGFudC5lbWl0LmFwcGx5KHBhcnRpY2lwYW50LCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncykpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYWNrLm9uKHRyYWNrRXZlbnQsIHRyYWNrRXZlbnRSZWVtaXR0ZXJzLmdldCh0cmFja0V2ZW50KSk7XG4gICAgfSk7XG4gICAgcGFydGljaXBhbnQuX3RyYWNrRXZlbnRSZWVtaXR0ZXJzLnNldChrZXksIHRyYWNrRXZlbnRSZWVtaXR0ZXJzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gUGFydGljaXBhbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0aWNpcGFudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldENvbWJpbmVkQ29ubmVjdGlvblN0YXRzID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0U3RhdFZhbHVlcyhyZXBvcnQsIHN0YXROYW1lLCBraW5kLCByZXBvcnRUeXBlcykge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcmVwb3J0LmZvckVhY2goZnVuY3Rpb24gKHN0YXQpIHtcbiAgICAgICAgaWYgKChyZXBvcnRUeXBlcy5sZW5ndGggPT09IDAgfHwgcmVwb3J0VHlwZXMuaW5jbHVkZXMoc3RhdC50eXBlKSkgJiZcbiAgICAgICAgICAgIChraW5kLmxlbmd0aCA9PT0gMCB8fCBraW5kLmluY2x1ZGVzKHN0YXQua2luZCkpICYmXG4gICAgICAgICAgICB0eXBlb2Ygc3RhdFtzdGF0TmFtZV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goc3RhdFtzdGF0TmFtZV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5mdW5jdGlvbiBnZXRDb21iaW5lZENvbm5lY3Rpb25TdGF0cyhfYSkge1xuICAgIHZhciBwdWJsaXNoZXIgPSBfYS5wdWJsaXNoZXIsIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9iLCBwdWJsaXNoZXJTdGF0cywgc3Vic2NyaWJlclN0YXRzLCB0aW1lc3RhbXBzLCB0aW1lc3RhbXAsIGppdHRlciwgcGFja2V0cywgcGFja2V0c0xvc3QsIHRyYWNrUm91bmRUcmlwVGltZSwgY3VycmVudFJvdW5kVHJpcFRpbWUsIHJvdW5kVHJpcFRpbWUsIGJ5dGVzU2VudCwgYnl0ZXNSZWNlaXZlZCwgc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHMsIGljZUNhbmRpZGF0ZVN0YXRzO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChbcHVibGlzaGVyLCBzdWJzY3JpYmVyXS5tYXAoZnVuY3Rpb24gKHBjKSB7IHJldHVybiBwYy5nZXRTdGF0cygpOyB9KSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2IgPSBfX3JlYWQuYXBwbHkodm9pZCAwLCBbX2Muc2VudCgpLCAyXSksIHB1Ymxpc2hlclN0YXRzID0gX2JbMF0sIHN1YnNjcmliZXJTdGF0cyA9IF9iWzFdO1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXBzID0gZ2V0U3RhdFZhbHVlcyhzdWJzY3JpYmVyU3RhdHMsICd0aW1lc3RhbXAnLCBbJ2F1ZGlvJ10sIFsnaW5ib3VuZC1ydHAnXSk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRpbWVzdGFtcHMubGVuZ3RoID4gMCA/IHRpbWVzdGFtcHNbMF0gOiAwO1xuICAgICAgICAgICAgICAgICAgICBqaXR0ZXIgPSBnZXRTdGF0VmFsdWVzKHN1YnNjcmliZXJTdGF0cywgJ2ppdHRlcicsIFsnYXVkaW8nXSwgWydpbmJvdW5kLXJ0cCddKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIE1hdGgubWF4KGEsIGIpOyB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcGFja2V0cyA9IGdldFN0YXRWYWx1ZXMoc3Vic2NyaWJlclN0YXRzLCAncGFja2V0c1JlY2VpdmVkJywgWydhdWRpbycsICd2aWRlbyddLCBbJ2luYm91bmQtcnRwJ10pLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSArIGI7IH0sIDApO1xuICAgICAgICAgICAgICAgICAgICBwYWNrZXRzTG9zdCA9IGdldFN0YXRWYWx1ZXMoc3Vic2NyaWJlclN0YXRzLCAncGFja2V0c0xvc3QnLCBbJ2F1ZGlvJywgJ3ZpZGVvJ10sIFsnaW5ib3VuZC1ydHAnXSkucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgYjsgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrUm91bmRUcmlwVGltZSA9IGdldFN0YXRWYWx1ZXMocHVibGlzaGVyU3RhdHMsICdyb3VuZFRyaXBUaW1lJywgWydhdWRpbycsICd2aWRlbyddLCBbJ3JlbW90ZS1pbmJvdW5kLXJ0cCddKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIE1hdGgubWF4KGEsIGIpOyB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvdW5kVHJpcFRpbWUgPSBnZXRTdGF0VmFsdWVzKHN1YnNjcmliZXJTdGF0cywgJ2N1cnJlbnRSb3VuZFRyaXBUaW1lJywgW10sIFsnY2FuZGlkYXRlLXBhaXInXSkucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBNYXRoLm1heChhLCBiKTsgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJvdW5kVHJpcFRpbWUgPSAoY3VycmVudFJvdW5kVHJpcFRpbWUgfHwgdHJhY2tSb3VuZFRyaXBUaW1lKSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzU2VudCA9IGdldFN0YXRWYWx1ZXMocHVibGlzaGVyU3RhdHMsICdieXRlc1NlbnQnLCBbXSwgWydjYW5kaWRhdGUtcGFpciddKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgKyBiOyB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNSZWNlaXZlZCA9IGdldFN0YXRWYWx1ZXMoc3Vic2NyaWJlclN0YXRzLCAnYnl0ZXNSZWNlaXZlZCcsIFtdLCBbJ2NhbmRpZGF0ZS1wYWlyJ10pLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSArIGI7IH0sIDApO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEljZUNhbmRpZGF0ZVBhaXJTdGF0cyA9IGV4dHJhY3RTZWxlY3RlZEFjdGl2ZUNhbmRpZGF0ZVBhaXIoc3Vic2NyaWJlclN0YXRzKTtcbiAgICAgICAgICAgICAgICAgICAgaWNlQ2FuZGlkYXRlU3RhdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlclN0YXRzLmZvckVhY2goZnVuY3Rpb24gKHN0YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICdsb2NhbC1jYW5kaWRhdGUnIHx8IHN0YXQudHlwZSA9PT0gJ3JlbW90ZS1jYW5kaWRhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNlQ2FuZGlkYXRlU3RhdHMucHVzaChtYWtlU3RhbmRhcmRDYW5kaWRhdGVTdGF0cyhzdGF0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgeyB0aW1lc3RhbXA6IHRpbWVzdGFtcCwgaml0dGVyOiBqaXR0ZXIsIHBhY2tldHM6IHBhY2tldHMsIHBhY2tldHNMb3N0OiBwYWNrZXRzTG9zdCwgcm91bmRUcmlwVGltZTogcm91bmRUcmlwVGltZSwgYnl0ZXNTZW50OiBieXRlc1NlbnQsIGJ5dGVzUmVjZWl2ZWQ6IGJ5dGVzUmVjZWl2ZWQsIHNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzOiBzZWxlY3RlZEljZUNhbmRpZGF0ZVBhaXJTdGF0cywgaWNlQ2FuZGlkYXRlU3RhdHM6IGljZUNhbmRpZGF0ZVN0YXRzIH1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0Q29tYmluZWRDb25uZWN0aW9uU3RhdHMgPSBnZXRDb21iaW5lZENvbm5lY3Rpb25TdGF0cztcbmZ1bmN0aW9uIG1ha2VTdGFuZGFyZENhbmRpZGF0ZVN0YXRzKGlucHV0KSB7XG4gICAgdmFyIHN0YW5kYXJkaXplZENhbmRpZGF0ZVN0YXRzS2V5cyA9IFtcbiAgICAgICAgeyBrZXk6ICd0cmFuc3BvcnRJZCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsga2V5OiAnY2FuZGlkYXRlVHlwZScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsga2V5OiAncG9ydCcsIGFsdEtleXM6IFsncG9ydE51bWJlciddLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ2FkZHJlc3MnLCBhbHRLZXlzOiBbJ2lwJywgJ2lwQWRkcmVzcyddLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IGtleTogJ3ByaW9yaXR5JywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBrZXk6ICdwcm90b2NvbCcsIGFsdEtleXM6IFsndHJhbnNwb3J0J10sIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsga2V5OiAndXJsJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgeyBrZXk6ICdyZWxheVByb3RvY29sJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICBdO1xuICAgIHJldHVybiBzdGFuZGFyZGl6ZWRDYW5kaWRhdGVTdGF0c0tleXMucmVkdWNlKGZ1bmN0aW9uIChyZXBvcnQsIGtleUluZm8pIHtcbiAgICAgICAgdmFyIGtleXNUb0xvb2tGb3IgPSBba2V5SW5mby5rZXldO1xuICAgICAgICBpZiAoa2V5SW5mby5hbHRLZXlzKSB7XG4gICAgICAgICAgICBrZXlzVG9Mb29rRm9yID0ga2V5c1RvTG9va0Zvci5jb25jYXQoa2V5SW5mby5hbHRLZXlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0ga2V5c1RvTG9va0Zvci5maW5kKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleSBpbiBpbnB1dDsgfSk7XG4gICAgICAgIGlmIChrZXkgJiYgdHlwZW9mIGlucHV0W2tleV0gPT09IGtleUluZm8udHlwZSkge1xuICAgICAgICAgICAgcmVwb3J0W2tleUluZm8ua2V5XSA9IGlucHV0W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcG9ydDtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBleHRyYWN0U2VsZWN0ZWRBY3RpdmVDYW5kaWRhdGVQYWlyKHN0YXRzKSB7XG4gICAgdmFyIHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gbnVsbDtcbiAgICB2YXIgY2FuZGlkYXRlUGFpcnMgPSBbXTtcbiAgICBzdGF0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0KSB7XG4gICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICd0cmFuc3BvcnQnICYmIHN0YXQuc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gc3RhdC5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0LnR5cGUgPT09ICdjYW5kaWRhdGUtcGFpcicpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZVBhaXJzLnB1c2goc3RhdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgYWN0aXZlQ2FuZGlkYXRlUGFpclN0YXRzRm91bmQgPSBjYW5kaWRhdGVQYWlycy5maW5kKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgcmV0dXJuIHBhaXIuc2VsZWN0ZWQgfHxcbiAgICAgICAgICAgIC8vIFNwZWMtY29tcGxpYW50IHdheVxuICAgICAgICAgICAgKHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkICYmIHBhaXIuaWQgPT09IHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkKTtcbiAgICB9KTtcbiAgICBpZiAoIWFjdGl2ZUNhbmRpZGF0ZVBhaXJTdGF0c0ZvdW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgYWN0aXZlQ2FuZGlkYXRlUGFpclN0YXRzID0gYWN0aXZlQ2FuZGlkYXRlUGFpclN0YXRzRm91bmQ7XG4gICAgdmFyIGFjdGl2ZUxvY2FsQ2FuZGlkYXRlU3RhdHMgPSBzdGF0cy5nZXQoYWN0aXZlQ2FuZGlkYXRlUGFpclN0YXRzLmxvY2FsQ2FuZGlkYXRlSWQpO1xuICAgIHZhciBhY3RpdmVSZW1vdGVDYW5kaWRhdGVTdGF0cyA9IHN0YXRzLmdldChhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHMucmVtb3RlQ2FuZGlkYXRlSWQpO1xuICAgIGlmICghYWN0aXZlTG9jYWxDYW5kaWRhdGVTdGF0cyB8fCAhYWN0aXZlUmVtb3RlQ2FuZGlkYXRlU3RhdHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGxvY2FsQ2FuZGlkYXRlOiBtYWtlU3RhbmRhcmRDYW5kaWRhdGVTdGF0cyhhY3RpdmVMb2NhbENhbmRpZGF0ZVN0YXRzKSxcbiAgICAgICAgcmVtb3RlQ2FuZGlkYXRlOiBtYWtlU3RhbmRhcmRDYW5kaWRhdGVTdGF0cyhhY3RpdmVSZW1vdGVDYW5kaWRhdGVTdGF0cylcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Q29tYmluZWRDb25uZWN0aW9uU3RhdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFR1cm5DcmVkZW50aWFscyA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xudmFyIFR3aWxpb0Nvbm5lY3Rpb24gPSByZXF1aXJlKCcuLi90d2lsaW9jb25uZWN0aW9uLmpzJyk7XG52YXIgSUNFX1ZFUlNJT04gPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLklDRV9WRVJTSU9OO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vdXRpbC90d2lsaW8tdmlkZW8tZXJyb3JzJyksIGNyZWF0ZVR3aWxpb0Vycm9yID0gX2EuY3JlYXRlVHdpbGlvRXJyb3IsIFNpZ25hbGluZ0Nvbm5lY3Rpb25FcnJvciA9IF9hLlNpZ25hbGluZ0Nvbm5lY3Rpb25FcnJvcjtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5mdW5jdGlvbiBnZXRUdXJuQ3JlZGVudGlhbHModG9rZW4sIHdzU2VydmVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGV2ZW50T2JzZXJ2ZXIgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHZhciBjb25uZWN0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5ldHdvcmtNb25pdG9yOiBudWxsLFxuICAgICAgICAgICAgZXZlbnRPYnNlcnZlcjogZXZlbnRPYnNlcnZlcixcbiAgICAgICAgICAgIGhlbGxvQm9keToge1xuICAgICAgICAgICAgICAgIGVkZ2U6ICdyb2FtaW5nJyxcbiAgICAgICAgICAgICAgICBwcmVmbGlnaHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdpY2UnLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IElDRV9WRVJTSU9OXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdHdpbGlvQ29ubmVjdGlvbiA9IG5ldyBUd2lsaW9Db25uZWN0aW9uKHdzU2VydmVyLCBjb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHR3aWxpb0Nvbm5lY3Rpb24ub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IFNpZ25hbGluZ0Nvbm5lY3Rpb25FcnJvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHR3aWxpb0Nvbm5lY3Rpb24ub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiAobWVzc2FnZURhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gbWVzc2FnZURhdGEuY29kZSwgbWVzc2FnZSA9IG1lc3NhZ2VEYXRhLm1lc3NhZ2UsIGljZV9zZXJ2ZXJzID0gbWVzc2FnZURhdGEuaWNlX3NlcnZlcnMsIHR5cGUgPSBtZXNzYWdlRGF0YS50eXBlO1xuICAgICAgICAgICAgaWYgKCh0eXBlID09PSAnaWNlZCcgfHwgdHlwZSA9PT0gJ2Vycm9yJykgJiYgIWRvbmUpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2ljZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaWNlX3NlcnZlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGNyZWF0ZVR3aWxpb0Vycm9yKGNvZGUsIG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHdpbGlvQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0VHVybkNyZWRlbnRpYWxzID0gZ2V0VHVybkNyZWRlbnRpYWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0dHVybmNyZWRlbnRpYWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgICAgICB0b1tqXSA9IGZyb21baV07XG4gICAgcmV0dXJuIHRvO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFrZVN0YXQgPSB2b2lkIDA7XG4vKipcbiAqIENvbXB1dGVzIG1pbiwgbWF4LCBhdmVyYWdlIGZvciBnaXZlbiBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdmFsdWVzXG4gKiBAcmV0dXJucyB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcjogYXZlcmFnZTogbnVtYmVyfXxudWxsfVxuICovXG5mdW5jdGlvbiBtYWtlU3RhdCh2YWx1ZXMpIHtcbiAgICBpZiAodmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh2YWx1ZXMpKSk7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQodmFsdWVzKSkpO1xuICAgICAgICB2YXIgYXZlcmFnZSA9IHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCB2YWx1ZSkgeyByZXR1cm4gdG90YWwgKyB2YWx1ZTsgfSwgMCkgLyB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4geyBtaW46IG1pbiwgbWF4OiBtYXgsIGF2ZXJhZ2U6IGF2ZXJhZ2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLm1ha2VTdGF0ID0gbWFrZVN0YXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlc3RhdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubW9zVG9TY29yZSA9IGV4cG9ydHMuY2FsY3VsYXRlTU9TID0gdm9pZCAwO1xudmFyIHIwID0gOTQuNzY4OyAvLyBDb25zdGFudCB1c2VkIGluIGNvbXB1dGluZyBcInJGYWN0b3JcIi5cbi8vIGNvcGllZCBmcm9tIGh0dHBzOi8vY29kZS5ocS50d2lsaW8uY29tL2NsaWVudC9zZGstZnJkL2Jsb2IvbWFzdGVyL3ZvaWNlL3ZvaWNlLW1vcy1jYWxjdWxhdGlvbi5tZFxuZnVuY3Rpb24gY2FsY3VsYXRlTU9TKHJ0dCwgaml0dGVyLCBmcmFjdGlvbkxvc3QpIHtcbiAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbGF0ZW5jeS5cbiAgICB2YXIgZWZmZWN0aXZlTGF0ZW5jeSA9IHJ0dCArIChqaXR0ZXIgKiAyKSArIDEwO1xuICAgIC8vIENvbXB1dGUgdGhlIGluaXRpYWwgXCJyRmFjdG9yXCIgZnJvbSBlZmZlY3RpdmUgbGF0ZW5jeS5cbiAgICB2YXIgckZhY3RvciA9IDA7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgZWZmZWN0aXZlTGF0ZW5jeSA8IDE2MDpcbiAgICAgICAgICAgIHJGYWN0b3IgPSByMCAtIChlZmZlY3RpdmVMYXRlbmN5IC8gNDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZWZmZWN0aXZlTGF0ZW5jeSA8IDEwMDA6XG4gICAgICAgICAgICByRmFjdG9yID0gcjAgLSAoKGVmZmVjdGl2ZUxhdGVuY3kgLSAxMjApIC8gMTApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIEFkanVzdCBcInJGYWN0b3JcIiB3aXRoIHRoZSBmcmFjdGlvbiBvZiBwYWNrZXRzIGxvc3QuXG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgZnJhY3Rpb25Mb3N0IDw9IChyRmFjdG9yIC8gMi41KTpcbiAgICAgICAgICAgIHJGYWN0b3IgPSBNYXRoLm1heChyRmFjdG9yIC0gZnJhY3Rpb25Mb3N0ICogMi41LCA2LjUyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgckZhY3RvciA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSBNT1MgZnJvbSBcInJGYWN0b3JcIi5cbiAgICB2YXIgbW9zID0gMSArXG4gICAgICAgICgwLjAzNSAqIHJGYWN0b3IpICtcbiAgICAgICAgKDAuMDAwMDA3ICogckZhY3RvcikgKlxuICAgICAgICAgICAgKHJGYWN0b3IgLSA2MCkgKlxuICAgICAgICAgICAgKDEwMCAtIHJGYWN0b3IpO1xuICAgIHJldHVybiBtb3M7XG59XG5leHBvcnRzLmNhbGN1bGF0ZU1PUyA9IGNhbGN1bGF0ZU1PUztcbmZ1bmN0aW9uIG1vc1RvU2NvcmUobW9zVmFsdWUpIHtcbiAgICB2YXIgc2NvcmUgPSAwO1xuICAgIGlmICghbW9zVmFsdWUpIHtcbiAgICAgICAgc2NvcmUgPSAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChtb3NWYWx1ZSA+IDQuMikge1xuICAgICAgICBzY29yZSA9IDU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vc1ZhbHVlID4gNC4wKSB7XG4gICAgICAgIHNjb3JlID0gNDtcbiAgICB9XG4gICAgZWxzZSBpZiAobW9zVmFsdWUgPiAzLjYpIHtcbiAgICAgICAgc2NvcmUgPSAzO1xuICAgIH1cbiAgICBlbHNlIGlmIChtb3NWYWx1ZSA+IDMpIHtcbiAgICAgICAgc2NvcmUgPSAyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NvcmUgPSAxO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcmU7XG59XG5leHBvcnRzLm1vc1RvU2NvcmUgPSBtb3NUb1Njb3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ydW5QcmVmbGlnaHQgPSBleHBvcnRzLlByZWZsaWdodFRlc3QgPSB2b2lkIDA7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9jb25zdGFudHNcIik7XG52YXIgdGltZXJfMSA9IHJlcXVpcmUoXCIuL3RpbWVyXCIpO1xudmFyIG1vc18xID0gcmVxdWlyZShcIi4vbW9zXCIpO1xudmFyIGdldENvbWJpbmVkQ29ubmVjdGlvblN0YXRzXzEgPSByZXF1aXJlKFwiLi9nZXRDb21iaW5lZENvbm5lY3Rpb25TdGF0c1wiKTtcbnZhciBnZXR0dXJuY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2dldHR1cm5jcmVkZW50aWFsc1wiKTtcbnZhciBtYWtlc3RhdF8xID0gcmVxdWlyZShcIi4vbWFrZXN0YXRcIik7XG52YXIgc3ludGhldGljYXVkaW9fMSA9IHJlcXVpcmUoXCIuL3N5bnRoZXRpY2F1ZGlvXCIpO1xudmFyIHN5bnRoZXRpY3ZpZGVvXzEgPSByZXF1aXJlKFwiLi9zeW50aGV0aWN2aWRlb1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBXU19TRVJWRVIgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLldTX1NFUlZFUjtcbnZhciBMb2cgPSByZXF1aXJlKCcuLi91dGlsL2xvZycpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4uL2V2ZW50ZW1pdHRlcicpO1xudmFyIE1vdmluZ0F2ZXJhZ2VEZWx0YSA9IHJlcXVpcmUoJy4uL3V0aWwvbW92aW5nYXZlcmFnZWRlbHRhJyk7XG52YXIgRXZlbnRPYnNlcnZlciA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRvYnNlcnZlcicpO1xudmFyIEluc2lnaHRzUHVibGlzaGVyID0gcmVxdWlyZSgnLi4vdXRpbC9pbnNpZ2h0c3B1Ymxpc2hlcicpO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vdXRpbC9zaWQnKSwgY3JlYXRlU0lEID0gX2EuY3JlYXRlU0lELCBzZXNzaW9uU0lEID0gX2Euc2Vzc2lvblNJRDtcbnZhciBfYiA9IHJlcXVpcmUoJy4uL3V0aWwvdHdpbGlvLXZpZGVvLWVycm9ycycpLCBTaWduYWxpbmdDb25uZWN0aW9uVGltZW91dEVycm9yID0gX2IuU2lnbmFsaW5nQ29ubmVjdGlvblRpbWVvdXRFcnJvciwgTWVkaWFDb25uZWN0aW9uRXJyb3IgPSBfYi5NZWRpYUNvbm5lY3Rpb25FcnJvcjtcbnZhciBTRUNPTkQgPSAxMDAwO1xudmFyIERFRkFVTFRfVEVTVF9EVVJBVElPTiA9IDEwICogU0VDT05EO1xuLyoqXG4gKiBwcm9ncmVzcyB2YWx1ZXMgdGhhdCBhcmUgc2VudCBieSB7QGxpbmsgUHJlZmxpZ2h0VGVzdCNldmVudDpwcm9ncmVzc31cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciBQcmVmbGlnaHRQcm9ncmVzcyA9IHtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgUHJlZmxpZ2h0VGVzdH0gaGFzIHN1Y2Nlc3NmdWxseSBnZW5lcmF0ZWQgc3ludGhldGljIHRyYWNrc1xuICAgICAqL1xuICAgIG1lZGlhQWNxdWlyZWQ6ICdtZWRpYUFjcXVpcmVkJyxcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgUHJlZmxpZ2h0VGVzdH0gaGFzIHN1Y2Nlc3NmdWxseSBjb25uZWN0ZWQgdG8gdHdpbGlvIHNlcnZlciBhbmQgb2J0YWluZWQgdHVybiBjcmVkZW50aWFsc1xuICAgICAqL1xuICAgIGNvbm5lY3RlZDogJ2Nvbm5lY3RlZCcsXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlclBhcnRpY2lwYW50IHN1Y2Nlc3NmdWxseSBzdWJzY3JpYmVkIHRvIG1lZGlhIHRyYWNrcy5cbiAgICAgKi9cbiAgICBtZWRpYVN1YnNjcmliZWQ6ICdtZWRpYVN1YnNjcmliZWQnLFxuICAgIC8qKlxuICAgICAqIE1lZGlhIGZsb3cgd2FzIGRldGVjdGVkLlxuICAgICAqL1xuICAgIG1lZGlhU3RhcnRlZDogJ21lZGlhU3RhcnRlZCcsXG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoZWQgRFRMUyBjb25uZWN0aW9uLiBUaGlzIGlzIG1lYXN1cmVkIGZyb20gUlRDRHRsc1RyYW5zcG9ydCBgY29ubmVjdGluZ2AgdG8gYGNvbm5lY3RlZGAgc3RhdGUuXG4gICAgICogT24gU2FmYXJpLCBTdXBwb3J0IGZvciBtZWFzdXJpbmcgdGhpcyBpcyBtaXNzaW5nLCB0aGlzIGV2ZW50IHdpbGwgYmUgbm90IGJlIGVtaXR0ZWQgb24gU2FmYXJpLlxuICAgICAqL1xuICAgIGR0bHNDb25uZWN0ZWQ6ICdkdGxzQ29ubmVjdGVkJyxcbiAgICAvKipcbiAgICAgKiBFc3RhYmxpc2hlZCBhIFBlZXJDb25uZWN0aW9uLCBUaGlzIGlzIG1lYXN1cmVkIGZyb20gUGVlckNvbm5lY3Rpb24gYGNvbm5lY3RpbmdgIHRvIGBjb25uZWN0ZWRgIHN0YXRlLlxuICAgICAqIE9uIEZpcmVmb3gsIFN1cHBvcnQgZm9yIG1lYXN1cmluZyB0aGlzIGlzIG1pc3NpbmcsIHRoaXMgZXZlbnQgd2lsbCBiZSBub3QgYmUgZW1pdHRlZCBvbiBGaXJlZm94LlxuICAgICAqL1xuICAgIHBlZXJDb25uZWN0aW9uQ29ubmVjdGVkOiAncGVlckNvbm5lY3Rpb25Db25uZWN0ZWQnLFxuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaGVkIElDRSBjb25uZWN0aW9uLiBUaGlzIGlzIG1lYXN1cmVkIGZyb20gSUNFIGNvbm5lY3Rpb24gYGNoZWNraW5nYCB0byBgY29ubmVjdGVkYCBzdGF0ZS5cbiAgICAgKi9cbiAgICBpY2VDb25uZWN0ZWQ6ICdpY2VDb25uZWN0ZWQnXG59O1xuZnVuY3Rpb24gbm90RW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcbn1cbnZhciBuSW5zdGFuY2VzID0gMDtcbi8qKlxuICogQSB7QGxpbmsgUHJlZmxpZ2h0VGVzdH0gbW9uaXRvcnMgcHJvZ3Jlc3Mgb2YgYW4gb25nb2luZyBwcmVmbGlnaHQgdGVzdC5cbiAqIDxicj48YnI+XG4gKiBJbnN0YW5jZSBvZiB7QGxpbmsgUHJlZmxpZ2h0VGVzdH0gaXMgcmV0dXJuZWQgYnkgY2FsbGluZyB7QGxpbmsgbW9kdWxlOnR3aWxpby12aWRlby5ydW5QcmVmbGlnaHR9XG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBlbWl0cyBQcmVmbGlnaHRUZXN0I2NvbXBsZXRlZFxuICogQGVtaXRzIFByZWZsaWdodFRlc3QjZmFpbGVkXG4gKiBAZW1pdHMgUHJlZmxpZ2h0VGVzdCNwcm9ncmVzc1xuICovXG52YXIgUHJlZmxpZ2h0VGVzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJlZmxpZ2h0VGVzdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIHtAbGluayBQcmVmbGlnaHRUZXN0fS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAgICAgKiBAcGFyYW0gez9QcmVmbGlnaHRPcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcmVmbGlnaHRUZXN0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90ZXN0VGltaW5nID0gbmV3IHRpbWVyXzEuVGltZXIoKTtcbiAgICAgICAgX3RoaXMuX2R0bHNUaW1pbmcgPSBuZXcgdGltZXJfMS5UaW1lcigpO1xuICAgICAgICBfdGhpcy5faWNlVGltaW5nID0gbmV3IHRpbWVyXzEuVGltZXIoKTtcbiAgICAgICAgX3RoaXMuX3BlZXJDb25uZWN0aW9uVGltaW5nID0gbmV3IHRpbWVyXzEuVGltZXIoKTtcbiAgICAgICAgX3RoaXMuX21lZGlhVGltaW5nID0gbmV3IHRpbWVyXzEuVGltZXIoKTtcbiAgICAgICAgX3RoaXMuX2Nvbm5lY3RUaW1pbmcgPSBuZXcgdGltZXJfMS5UaW1lcigpO1xuICAgICAgICBfdGhpcy5fc2VudEJ5dGVzTW92aW5nQXZlcmFnZSA9IG5ldyBNb3ZpbmdBdmVyYWdlRGVsdGEoKTtcbiAgICAgICAgX3RoaXMuX3BhY2tldExvc3NNb3ZpbmdBdmVyYWdlID0gbmV3IE1vdmluZ0F2ZXJhZ2VEZWx0YSgpO1xuICAgICAgICBfdGhpcy5fcHJvZ3Jlc3NFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMuX3JlY2VpdmVkQnl0ZXNNb3ZpbmdBdmVyYWdlID0gbmV3IE1vdmluZ0F2ZXJhZ2VEZWx0YSgpO1xuICAgICAgICB2YXIgaW50ZXJuYWxPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdmFyIF9hID0gaW50ZXJuYWxPcHRpb25zLmVudmlyb25tZW50LCBlbnZpcm9ubWVudCA9IF9hID09PSB2b2lkIDAgPyAncHJvZCcgOiBfYSwgX2IgPSBpbnRlcm5hbE9wdGlvbnMucmVnaW9uLCByZWdpb24gPSBfYiA9PT0gdm9pZCAwID8gJ2dsbCcgOiBfYiwgX2MgPSBpbnRlcm5hbE9wdGlvbnMuZHVyYXRpb24sIGR1cmF0aW9uID0gX2MgPT09IHZvaWQgMCA/IERFRkFVTFRfVEVTVF9EVVJBVElPTiA6IF9jO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgICAgICB2YXIgd3NTZXJ2ZXIgPSBpbnRlcm5hbE9wdGlvbnMud3NTZXJ2ZXIgfHwgV1NfU0VSVkVSKGVudmlyb25tZW50LCByZWdpb24pO1xuICAgICAgICBfdGhpcy5fbG9nID0gbmV3IExvZygnZGVmYXVsdCcsIF90aGlzLCBjb25zdGFudHNfMS5ERUZBVUxUX0xPR19MRVZFTCwgY29uc3RhbnRzXzEuREVGQVVMVF9MT0dHRVJfTkFNRSk7XG4gICAgICAgIF90aGlzLl90ZXN0RHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgX3RoaXMuX2luc3RhbmNlSWQgPSBuSW5zdGFuY2VzKys7XG4gICAgICAgIF90aGlzLl90ZXN0VGltaW5nLnN0YXJ0KCk7XG4gICAgICAgIF90aGlzLl9ydW5QcmVmbGlnaHRUZXN0KHRva2VuLCBlbnZpcm9ubWVudCwgd3NTZXJ2ZXIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFByZWZsaWdodFRlc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbUHJlZmxpZ2h0ICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyBcIl1cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHN0b3BzIG9uZ29pbmcgdGVzdHMgYW5kIGVtaXRzIGVycm9yXG4gICAgICovXG4gICAgUHJlZmxpZ2h0VGVzdC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgfTtcbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5fZ2VuZXJhdGVQcmVmbGlnaHRSZXBvcnQgPSBmdW5jdGlvbiAoY29sbGVjdGVkU3RhdHMpIHtcbiAgICAgICAgdGhpcy5fdGVzdFRpbWluZy5zdG9wKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXN0VGltaW5nOiB0aGlzLl90ZXN0VGltaW5nLmdldFRpbWVNZWFzdXJlbWVudCgpLFxuICAgICAgICAgICAgbmV0d29ya1RpbWluZzoge1xuICAgICAgICAgICAgICAgIGR0bHM6IHRoaXMuX2R0bHNUaW1pbmcuZ2V0VGltZU1lYXN1cmVtZW50KCksXG4gICAgICAgICAgICAgICAgaWNlOiB0aGlzLl9pY2VUaW1pbmcuZ2V0VGltZU1lYXN1cmVtZW50KCksXG4gICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb246IHRoaXMuX3BlZXJDb25uZWN0aW9uVGltaW5nLmdldFRpbWVNZWFzdXJlbWVudCgpLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Q6IHRoaXMuX2Nvbm5lY3RUaW1pbmcuZ2V0VGltZU1lYXN1cmVtZW50KCksXG4gICAgICAgICAgICAgICAgbWVkaWE6IHRoaXMuX21lZGlhVGltaW5nLmdldFRpbWVNZWFzdXJlbWVudCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICAgICAgICBqaXR0ZXI6IG1ha2VzdGF0XzEubWFrZVN0YXQoY29sbGVjdGVkU3RhdHMgPT09IG51bGwgfHwgY29sbGVjdGVkU3RhdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbGxlY3RlZFN0YXRzLmppdHRlciksXG4gICAgICAgICAgICAgICAgcnR0OiBtYWtlc3RhdF8xLm1ha2VTdGF0KGNvbGxlY3RlZFN0YXRzID09PSBudWxsIHx8IGNvbGxlY3RlZFN0YXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2xsZWN0ZWRTdGF0cy5ydHQpLFxuICAgICAgICAgICAgICAgIHBhY2tldExvc3M6IG1ha2VzdGF0XzEubWFrZVN0YXQoY29sbGVjdGVkU3RhdHMgPT09IG51bGwgfHwgY29sbGVjdGVkU3RhdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbGxlY3RlZFN0YXRzLnBhY2tldExvc3MpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzOiBjb2xsZWN0ZWRTdGF0cyA/IGNvbGxlY3RlZFN0YXRzLnNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzIDogbnVsbCxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZVN0YXRzOiBjb2xsZWN0ZWRTdGF0cyA/IGNvbGxlY3RlZFN0YXRzLmljZUNhbmRpZGF0ZVN0YXRzIDogW10sXG4gICAgICAgICAgICBwcm9ncmVzc0V2ZW50czogdGhpcy5fcHJvZ3Jlc3NFdmVudHMsXG4gICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgICAgIG1vczogbWFrZXN0YXRfMS5tYWtlU3RhdChjb2xsZWN0ZWRTdGF0cyA9PT0gbnVsbCB8fCBjb2xsZWN0ZWRTdGF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sbGVjdGVkU3RhdHMubW9zKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFByZWZsaWdodFRlc3QucHJvdG90eXBlLl9leGVjdXRlUHJlZmxpZ2h0U3RlcCA9IGZ1bmN0aW9uIChzdGVwTmFtZSwgc3RlcCwgdGltZW91dEVycm9yKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBNQVhfU1RFUF9EVVJBVElPTiwgc3RlcFByb21pc2UsIHRpbWVyLCB0aW1lb3V0UHJvbWlzZSwgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdFeGVjdXRpbmcgc3RlcDogJywgc3RlcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgTUFYX1NURVBfRFVSQVRJT04gPSB0aGlzLl90ZXN0RHVyYXRpb24gKyAxMCAqIFNFQ09ORDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdG9wcGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oc3RlcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRpbWVvdXRFcnJvciB8fCBuZXcgRXJyb3Ioc3RlcE5hbWUgKyBcIiB0aW1lb3V0LlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgTUFYX1NURVBfRFVSQVRJT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgLCAzLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLnJhY2UoW3RpbWVvdXRQcm9taXNlLCBzdGVwUHJvbWlzZV0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5fY29sbGVjdE5ldHdvcmtUaW1pbmdzID0gZnVuY3Rpb24gKHBjKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgdmFyIGR0bHNUcmFuc3BvcnQ7XG4gICAgICAgICAgICBwYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2NoZWNraW5nJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faWNlVGltaW5nLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pY2VUaW1pbmcuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdXBkYXRlUHJvZ3Jlc3MoUHJlZmxpZ2h0UHJvZ3Jlc3MuaWNlQ29ubmVjdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkdGxzVHJhbnNwb3J0IHx8IGR0bHNUcmFuc3BvcnQgJiYgZHRsc1RyYW5zcG9ydC5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZmlyZWZveCBkb2VzIG5vdCBzdXBwb3J0IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZS5cbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocGMuY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3BlZXJDb25uZWN0aW9uVGltaW5nLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYy5jb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9wZWVyQ29ubmVjdGlvblRpbWluZy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl91cGRhdGVQcm9ncmVzcyhQcmVmbGlnaHRQcm9ncmVzcy5wZWVyQ29ubmVjdGlvbkNvbm5lY3RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTYWZhcmkgZG9lcyBub3QgZXhwb3NlIHNlbmRlci50cmFuc3BvcnQuXG4gICAgICAgICAgICB2YXIgc2VuZGVycyA9IHBjLmdldFNlbmRlcnMoKTtcbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnQgPSBzZW5kZXJzLm1hcChmdW5jdGlvbiAoc2VuZGVyKSB7IHJldHVybiBzZW5kZXIudHJhbnNwb3J0OyB9KS5maW5kKG5vdEVtcHR5KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhbnNwb3J0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGR0bHNUcmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgICAgICAgICAgZHRsc1RyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR0bHNUcmFuc3BvcnQuc3RhdGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2R0bHNUaW1pbmcuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZHRsc1RyYW5zcG9ydC5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9kdGxzVGltaW5nLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl91cGRhdGVQcm9ncmVzcyhQcmVmbGlnaHRQcm9ncmVzcy5kdGxzQ29ubmVjdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUHJlZmxpZ2h0VGVzdC5wcm90b3R5cGUuX3NldHVwSW5zaWdodHMgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHRva2VuID0gX2EudG9rZW4sIF9iID0gX2EuZW52aXJvbm1lbnQsIGVudmlyb25tZW50ID0gX2IgPT09IHZvaWQgMCA/IGNvbnN0YW50c18xLkRFRkFVTFRfRU5WSVJPTk1FTlQgOiBfYiwgX2MgPSBfYS5yZWFsbSwgcmVhbG0gPSBfYyA9PT0gdm9pZCAwID8gY29uc3RhbnRzXzEuREVGQVVMVF9SRUFMTSA6IF9jO1xuICAgICAgICB2YXIgZXZlbnRQdWJsaXNoZXJPcHRpb25zID0ge307XG4gICAgICAgIHZhciBldmVudFB1Ymxpc2hlciA9IG5ldyBJbnNpZ2h0c1B1Ymxpc2hlcih0b2tlbiwgY29uc3RhbnRzXzEuU0RLX05BTUUsIGNvbnN0YW50c18xLlNES19WRVJTSU9OLCBlbnZpcm9ubWVudCwgcmVhbG0sIGV2ZW50UHVibGlzaGVyT3B0aW9ucyk7XG4gICAgICAgIC8vIGV2ZW50IHB1Ymxpc2hlciByZXF1aXJlcyByb29tIHNpZC9wYXJ0aWNpcGFudCBzaWQuIHN1cHBseSBmYWtlIG9uZXMuXG4gICAgICAgIGV2ZW50UHVibGlzaGVyLmNvbm5lY3QoJ1BSRUZMSUdIVF9ST09NX1NJRCcsICdQUkVGTElHSFRfUEFSVElDSVBBTlQnKTtcbiAgICAgICAgdmFyIGV2ZW50T2JzZXJ2ZXIgPSBuZXcgRXZlbnRPYnNlcnZlcihldmVudFB1Ymxpc2hlciwgRGF0ZS5ub3coKSwgdGhpcy5fbG9nKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICAgICAgICB2YXIgdW5kZWZpbmVkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXBvcnRUb0luc2lnaHRzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHZhciByZXBvcnQgPSBfYS5yZXBvcnQ7XG4gICAgICAgICAgICAgICAgdmFyIGppdHRlclN0YXRzID0gcmVwb3J0LnN0YXRzLmppdHRlciB8fCB1bmRlZmluZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcnR0U3RhdHMgPSByZXBvcnQuc3RhdHMucnR0IHx8IHVuZGVmaW5lZFZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBwYWNrZXRMb3NzU3RhdHMgPSByZXBvcnQuc3RhdHMucGFja2V0TG9zcyB8fCB1bmRlZmluZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbW9zU3RhdHMgPSByZXBvcnQubW9zIHx8IHVuZGVmaW5lZFZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIHN0cmluZ2lmeSBpbXBvcnRhbnQgaW5mbyBmcm9tIGljZSBjYW5kaWRhdGVzLlxuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVUeXBlVG9Qcm90b2NvbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgcmVwb3J0LmljZUNhbmRpZGF0ZVN0YXRzLmZvckVhY2goZnVuY3Rpb24gKGNhbmRpZGF0ZVN0YXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGVTdGF0cy5jYW5kaWRhdGVUeXBlICYmIGNhbmRpZGF0ZVN0YXRzLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvdG9jb2xzID0gY2FuZGlkYXRlVHlwZVRvUHJvdG9jb2xzLmdldChjYW5kaWRhdGVTdGF0cy5jYW5kaWRhdGVUeXBlKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm90b2NvbHMuaW5kZXhPZihjYW5kaWRhdGVTdGF0cy5wcm90b2NvbCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xzLnB1c2goY2FuZGlkYXRlU3RhdHMucHJvdG9jb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlVHlwZVRvUHJvdG9jb2xzLnNldChjYW5kaWRhdGVTdGF0cy5jYW5kaWRhdGVUeXBlLCBwcm90b2NvbHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGljZUNhbmRpZGF0ZVN0YXRzID0gSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKGNhbmRpZGF0ZVR5cGVUb1Byb3RvY29scykpO1xuICAgICAgICAgICAgICAgIHZhciBpbnNpZ2h0c1JlcG9ydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3JlcG9ydCcsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwOiAncHJlZmxpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IHJlcG9ydC5lcnJvciA/ICdlcnJvcicgOiAnaW5mbycsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TSUQ6IHNlc3Npb25TSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmbGlnaHRTSUQ6IGNyZWF0ZVNJRCgnUEYnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzRXZlbnRzOiBKU09OLnN0cmluZ2lmeShyZXBvcnQucHJvZ3Jlc3NFdmVudHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdFRpbWluZzogcmVwb3J0LnRlc3RUaW1pbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkdGxzVGltaW5nOiByZXBvcnQubmV0d29ya1RpbWluZy5kdGxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNlVGltaW5nOiByZXBvcnQubmV0d29ya1RpbWluZy5pY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyQ29ubmVjdGlvblRpbWluZzogcmVwb3J0Lm5ldHdvcmtUaW1pbmcucGVlckNvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0VGltaW5nOiByZXBvcnQubmV0d29ya1RpbWluZy5jb25uZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFUaW1pbmc6IHJlcG9ydC5uZXR3b3JrVGltaW5nLm1lZGlhLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRMb2NhbENhbmRpZGF0ZTogKF9iID0gcmVwb3J0LnNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubG9jYWxDYW5kaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJlbW90ZUNhbmRpZGF0ZTogKF9jID0gcmVwb3J0LnNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVtb3RlQ2FuZGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNlQ2FuZGlkYXRlU3RhdHM6IGljZUNhbmRpZGF0ZVN0YXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaml0dGVyU3RhdHM6IGppdHRlclN0YXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnR0U3RhdHM6IHJ0dFN0YXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0TG9zc1N0YXRzOiBwYWNrZXRMb3NzU3RhdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3NTdGF0czogbW9zU3RhdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogcmVwb3J0LmVycm9yXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGV2ZW50T2JzZXJ2ZXIuZW1pdCgnZXZlbnQnLCBpbnNpZ2h0c1JlcG9ydCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudFB1Ymxpc2hlci5kaXNjb25uZWN0KCk7IH0sIDIwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgUHJlZmxpZ2h0VGVzdC5wcm90b3R5cGUuX3J1blByZWZsaWdodFRlc3QgPSBmdW5jdGlvbiAodG9rZW4sIGVudmlyb25tZW50LCB3c1NlcnZlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxUcmFja3MsIHBjcywgcmVwb3J0VG9JbnNpZ2h0cywgZWxlbWVudHNfMSwgaWNlU2VydmVycywgc2VuZGVyUENfMSwgcmVjZWl2ZXJQQ18xLCByZW1vdGVUcmFja3NfMSwgY29sbGVjdGVkU3RhdHNfMSwgcmVwb3J0LCBlcnJvcl8xLCBwcmVmbGlnaHRSZXBvcnQ7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxUcmFja3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBjcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0VG9JbnNpZ2h0cyA9IHRoaXMuX3NldHVwSW5zaWdodHMoeyB0b2tlbjogdG9rZW4sIGVudmlyb25tZW50OiBlbnZpcm9ubWVudCB9KS5yZXBvcnRUb0luc2lnaHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDgsIDksIDEwXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c18xID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9leGVjdXRlUHJlZmxpZ2h0U3RlcCgnQWNxdWlyZSBtZWRpYScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtzeW50aGV0aWNhdWRpb18xLnN5bnRoZXRpY0F1ZGlvKCksIHN5bnRoZXRpY3ZpZGVvXzEuc3ludGhldGljVmlkZW8oeyB3aWR0aDogNjQwLCBoZWlnaHQ6IDQ4MCB9KV07IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxUcmFja3MgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQcm9ncmVzcyhQcmVmbGlnaHRQcm9ncmVzcy5tZWRpYUFjcXVpcmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVidWcnLCB7IGxvY2FsVHJhY2tzOiBsb2NhbFRyYWNrcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RUaW1pbmcuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2V4ZWN1dGVQcmVmbGlnaHRTdGVwKCdHZXQgdHVybiBjcmVkZW50aWFscycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldHR1cm5jcmVkZW50aWFsc18xLmdldFR1cm5DcmVkZW50aWFscyh0b2tlbiwgd3NTZXJ2ZXIpOyB9LCBuZXcgU2lnbmFsaW5nQ29ubmVjdGlvblRpbWVvdXRFcnJvcigpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGljZVNlcnZlcnMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0VGltaW5nLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByb2dyZXNzKFByZWZsaWdodFByb2dyZXNzLmNvbm5lY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXJQQ18xID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHsgaWNlU2VydmVyczogaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5OiAncmVsYXknLCBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyUENfMSA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7IGljZVNlcnZlcnM6IGljZVNlcnZlcnMsIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGNzLnB1c2goc2VuZGVyUENfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwY3MucHVzaChyZWNlaXZlclBDXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFUaW1pbmcuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2V4ZWN1dGVQcmVmbGlnaHRTdGVwKCdTZXR1cCBQZWVyIENvbm5lY3Rpb25zJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3RlVHJhY2tzUHJvbWlzZSwgb2ZmZXIsIHVwZGF0ZWRPZmZlciwgYW5zd2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXJQQ18xLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQuY2FuZGlkYXRlICYmIHJlY2VpdmVyUENfMS5hZGRJY2VDYW5kaWRhdGUoZXZlbnQuY2FuZGlkYXRlKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyUENfMS5hZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50LmNhbmRpZGF0ZSAmJiBzZW5kZXJQQ18xLmFkZEljZUNhbmRpZGF0ZShldmVudC5jYW5kaWRhdGUpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxUcmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHsgcmV0dXJuIHNlbmRlclBDXzEuYWRkVHJhY2sodHJhY2spOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlVHJhY2tzUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3RlVHJhY2tzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlclBDXzEuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVUcmFja3MucHVzaChldmVudC50cmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW90ZVRyYWNrcy5sZW5ndGggPT09IGxvY2FsVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlbW90ZVRyYWNrcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzZW5kZXJQQ18xLmNyZWF0ZU9mZmVyKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZmZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRPZmZlciA9IG9mZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzZW5kZXJQQ18xLnNldExvY2FsRGVzY3JpcHRpb24odXBkYXRlZE9mZmVyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlY2VpdmVyUENfMS5zZXRSZW1vdGVEZXNjcmlwdGlvbih1cGRhdGVkT2ZmZXIpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVjZWl2ZXJQQ18xLmNyZWF0ZUFuc3dlcigpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuc3dlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVjZWl2ZXJQQ18xLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNlbmRlclBDXzEuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NvbGxlY3ROZXR3b3JrVGltaW5ncyhzZW5kZXJQQ18xKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZW1vdGVUcmFja3NQcm9taXNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0sIG5ldyBNZWRpYUNvbm5lY3Rpb25FcnJvcigpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZVRyYWNrc18xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkZWJ1ZycsIHsgcmVtb3RlVHJhY2tzOiByZW1vdGVUcmFja3NfMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZVRyYWNrc18xLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbG9nLndhcm4odHJhY2sua2luZCArICc6ZW5kZWQnKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbXV0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9sb2cud2Fybih0cmFjay5raW5kICsgJzptdXRlZCcpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCd1bm11dGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbG9nLndhcm4odHJhY2sua2luZCArICc6dW5tdXRlZCcpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJvZ3Jlc3MoUHJlZmxpZ2h0UHJvZ3Jlc3MubWVkaWFTdWJzY3JpYmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2V4ZWN1dGVQcmVmbGlnaHRTdGVwKCdXYWl0IGZvciB0cmFja3MgdG8gc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBuZXcgTWVkaWFTdHJlYW0ocmVtb3RlVHJhY2tzXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNfMS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnZGVidWdFbGVtZW50JywgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm9uY2FucGxheSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG5ldyBNZWRpYUNvbm5lY3Rpb25FcnJvcigpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhVGltaW5nLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByb2dyZXNzKFByZWZsaWdodFByb2dyZXNzLm1lZGlhU3RhcnRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9leGVjdXRlUHJlZmxpZ2h0U3RlcCgnQ29sbGVjdCBzdGF0cyBmb3IgZHVyYXRpb24nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fY29sbGVjdFJUQ1N0YXRzRm9yRHVyYXRpb24oX3RoaXMuX3Rlc3REdXJhdGlvbiwgaW5pdENvbGxlY3RlZFN0YXRzKCksIHNlbmRlclBDXzEsIHJlY2VpdmVyUENfMSk7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkU3RhdHNfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2V4ZWN1dGVQcmVmbGlnaHRTdGVwKCdHZW5lcmF0ZSByZXBvcnQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZ2VuZXJhdGVQcmVmbGlnaHRSZXBvcnQoY29sbGVjdGVkU3RhdHNfMSk7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0VG9JbnNpZ2h0cyh7IHJlcG9ydDogcmVwb3J0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb21wbGV0ZWQnLCByZXBvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmxpZ2h0UmVwb3J0ID0gdGhpcy5fZ2VuZXJhdGVQcmVmbGlnaHRSZXBvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydFRvSW5zaWdodHMoeyByZXBvcnQ6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmVmbGlnaHRSZXBvcnQpLCB7IGVycm9yOiBlcnJvcl8xID09PSBudWxsIHx8IGVycm9yXzEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yXzEudG9TdHJpbmcoKSB9KSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZmFpbGVkJywgZXJyb3JfMSwgcHJlZmxpZ2h0UmVwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGNzLmZvckVhY2goZnVuY3Rpb24gKHBjKSB7IHJldHVybiBwYy5jbG9zZSgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7IHJldHVybiB0cmFjay5zdG9wKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFByZWZsaWdodFRlc3QucHJvdG90eXBlLl9jb2xsZWN0UlRDU3RhdHMgPSBmdW5jdGlvbiAoY29sbGVjdGVkU3RhdHMsIHNlbmRlclBDLCByZWNlaXZlclBDKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21iaW5lZFN0YXRzLCB0aW1lc3RhbXAsIGJ5dGVzU2VudCwgYnl0ZXNSZWNlaXZlZCwgcGFja2V0cywgcGFja2V0c0xvc3QsIHJvdW5kVHJpcFRpbWUsIGppdHRlciwgc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHMsIGljZUNhbmRpZGF0ZVN0YXRzLCBoYXNMYXN0RGF0YSwgZnJhY3Rpb25QYWNrZXRMb3N0LCBwZXJjZW50UGFja2V0c0xvc3QsIHNjb3JlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBnZXRDb21iaW5lZENvbm5lY3Rpb25TdGF0c18xLmdldENvbWJpbmVkQ29ubmVjdGlvblN0YXRzKHsgcHVibGlzaGVyOiBzZW5kZXJQQywgc3Vic2NyaWJlcjogcmVjZWl2ZXJQQyB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkU3RhdHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBjb21iaW5lZFN0YXRzLnRpbWVzdGFtcCwgYnl0ZXNTZW50ID0gY29tYmluZWRTdGF0cy5ieXRlc1NlbnQsIGJ5dGVzUmVjZWl2ZWQgPSBjb21iaW5lZFN0YXRzLmJ5dGVzUmVjZWl2ZWQsIHBhY2tldHMgPSBjb21iaW5lZFN0YXRzLnBhY2tldHMsIHBhY2tldHNMb3N0ID0gY29tYmluZWRTdGF0cy5wYWNrZXRzTG9zdCwgcm91bmRUcmlwVGltZSA9IGNvbWJpbmVkU3RhdHMucm91bmRUcmlwVGltZSwgaml0dGVyID0gY29tYmluZWRTdGF0cy5qaXR0ZXIsIHNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzID0gY29tYmluZWRTdGF0cy5zZWxlY3RlZEljZUNhbmRpZGF0ZVBhaXJTdGF0cywgaWNlQ2FuZGlkYXRlU3RhdHMgPSBjb21iaW5lZFN0YXRzLmljZUNhbmRpZGF0ZVN0YXRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTGFzdERhdGEgPSBjb2xsZWN0ZWRTdGF0cy5qaXR0ZXIubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFN0YXRzLmppdHRlci5wdXNoKGppdHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRTdGF0cy5ydHQucHVzaChyb3VuZFRyaXBUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbnRCeXRlc01vdmluZ0F2ZXJhZ2UucHV0U2FtcGxlKGJ5dGVzU2VudCwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY2VpdmVkQnl0ZXNNb3ZpbmdBdmVyYWdlLnB1dFNhbXBsZShieXRlc1JlY2VpdmVkLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFja2V0TG9zc01vdmluZ0F2ZXJhZ2UucHV0U2FtcGxlKHBhY2tldHNMb3N0LCBwYWNrZXRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNMYXN0RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgQnl0ZXNNb3ZpbmdBdmVyYWdlIHdoaWNoIGlzIGluIGJ5dGVzL21pbGxpc2Vjb25kIHRvIGJpdHMvc2Vjb25kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkU3RhdHMub3V0Z29pbmdCaXRyYXRlLnB1c2godGhpcy5fc2VudEJ5dGVzTW92aW5nQXZlcmFnZS5nZXQoKSAqIDEwMDAgKiA4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRTdGF0cy5pbmNvbWluZ0JpdHJhdGUucHVzaCh0aGlzLl9yZWNlaXZlZEJ5dGVzTW92aW5nQXZlcmFnZS5nZXQoKSAqIDEwMDAgKiA4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFjdGlvblBhY2tldExvc3QgPSB0aGlzLl9wYWNrZXRMb3NzTW92aW5nQXZlcmFnZS5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50UGFja2V0c0xvc3QgPSBNYXRoLm1pbigxMDAsIGZyYWN0aW9uUGFja2V0TG9zdCAqIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkU3RhdHMucGFja2V0TG9zcy5wdXNoKHBlcmNlbnRQYWNrZXRzTG9zdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmUgPSBtb3NfMS5jYWxjdWxhdGVNT1Mocm91bmRUcmlwVGltZSwgaml0dGVyLCBmcmFjdGlvblBhY2tldExvc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFN0YXRzLm1vcy5wdXNoKHNjb3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sbGVjdGVkU3RhdHMuc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRTdGF0cy5zZWxlY3RlZEljZUNhbmRpZGF0ZVBhaXJTdGF0cyA9IHNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3RlZFN0YXRzLmljZUNhbmRpZGF0ZVN0YXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFN0YXRzLmljZUNhbmRpZGF0ZVN0YXRzID0gaWNlQ2FuZGlkYXRlU3RhdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUHJlZmxpZ2h0VGVzdC5wcm90b3R5cGUuX2NvbGxlY3RSVENTdGF0c0ZvckR1cmF0aW9uID0gZnVuY3Rpb24gKGR1cmF0aW9uLCBjb2xsZWN0ZWRTdGF0cywgc2VuZGVyUEMsIHJlY2VpdmVyUEMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0VGltZSwgU1RBVF9JTlRFUlZBTCwgcmVtYWluaW5nRHVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgU1RBVF9JTlRFUlZBTCA9IE1hdGgubWluKDEwMDAsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHV0aWxfMS53YWl0Rm9yU29tZXRpbWUoU1RBVF9JTlRFUlZBTCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jb2xsZWN0UlRDU3RhdHMoY29sbGVjdGVkU3RhdHMsIHNlbmRlclBDLCByZWNlaXZlclBDKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0R1cmF0aW9uID0gZHVyYXRpb24gLSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZW1haW5pbmdEdXJhdGlvbiA+IDApKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NvbGxlY3RSVENTdGF0c0ZvckR1cmF0aW9uKHJlbWFpbmluZ0R1cmF0aW9uLCBjb2xsZWN0ZWRTdGF0cywgc2VuZGVyUEMsIHJlY2VpdmVyUEMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkU3RhdHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNvbGxlY3RlZFN0YXRzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5fdXBkYXRlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gdGhpcy5fdGVzdFRpbWluZy5nZXRUaW1lTWVhc3VyZW1lbnQoKS5zdGFydDtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NFdmVudHMucHVzaCh7IGR1cmF0aW9uOiBkdXJhdGlvbiwgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIG5hbWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFByZWZsaWdodFRlc3Q7XG59KEV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5QcmVmbGlnaHRUZXN0ID0gUHJlZmxpZ2h0VGVzdDtcbmZ1bmN0aW9uIGluaXRDb2xsZWN0ZWRTdGF0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtb3M6IFtdLFxuICAgICAgICBqaXR0ZXI6IFtdLFxuICAgICAgICBydHQ6IFtdLFxuICAgICAgICBvdXRnb2luZ0JpdHJhdGU6IFtdLFxuICAgICAgICBpbmNvbWluZ0JpdHJhdGU6IFtdLFxuICAgICAgICBwYWNrZXRMb3NzOiBbXSxcbiAgICAgICAgc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHM6IG51bGwsXG4gICAgICAgIGljZUNhbmRpZGF0ZVN0YXRzOiBbXSxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIG5ldHdvcmsgdGltaW5nIG1lYXN1cmVtZW50cyBjYXB0dXJlZCBkdXJpbmcgcHJlZmxpZ2h0IHRlc3RcbiAqIEB0eXBlZGVmIHtvYmplY3R9IE5ldHdvcmtUaW1pbmdcbiAqIEBwcm9wZXJ0eSB7VGltZU1lYXN1cmVtZW50fSBbY29ubmVjdF0gLSBUaW1lIHRvIGVzdGFibGlzaCBzaWduYWxpbmcgY29ubmVjdGlvbiBhbmQgYWNxdWlyZSB0dXJuIGNyZWRlbnRpYWxzXG4gKiBAcHJvcGVydHkge1RpbWVNZWFzdXJlbWVudH0gW21lZGlhXSAtIFRpbWUgdG8gc3RhcnQgbWVkaWEuIFRoaXMgaXMgbWVhc3VyZWQgZnJvbSBjYWxsaW5nIGNvbm5lY3QgdG8gcmVtb3RlIG1lZGlhIGdldHRpbmcgc3RhcnRlZC5cbiAqIEBwcm9wZXJ0eSB7VGltZU1lYXN1cmVtZW50fSBbZHRsc10gLSBUaW1lIHRvIGVzdGFibGlzaCBkdGxzIGNvbm5lY3Rpb24uIFRoaXMgaXMgbWVhc3VyZWQgZnJvbSBSVENEdGxzVHJhbnNwb3J0IGBjb25uZWN0aW5nYCB0byBgY29ubmVjdGVkYCBzdGF0ZS4gKE5vdCBhdmFpbGFibGUgb24gU2FmYXJpKVxuICogQHByb3BlcnR5IHtUaW1lTWVhc3VyZW1lbnR9IFtpY2VdIC0gVGltZSB0byBlc3RhYmxpc2ggaWNlIGNvbm5lY3Rpdml0eS4gVGhpcyBpcyBtZWFzdXJlZCBmcm9tIElDRSBjb25uZWN0aW9uIGBjaGVja2luZ2AgdG8gYGNvbm5lY3RlZGAgc3RhdGUuXG4gKiBAcHJvcGVydHkge1RpbWVNZWFzdXJlbWVudH0gW3BlZXJDb25uZWN0aW9uXSAtIFRpbWUgdG8gZXN0YWJsaXNoIHBlZXIgY29ubmVjdGl2aXR5LiBUaGlzIGlzIG1lYXN1cmVkIGZyb20gUGVlckNvbm5lY3Rpb24gYGNvbm5lY3RpbmdgIHRvIGBjb25uZWN0ZWRgIHN0YXRlLiAoTm90IGF2YWlsYWJsZSBvbiBGaXJlZm94KVxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgc3RhdHMgZm9yIGEgbnVtZXJpY2FsIG1ldHJpYy5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IFN0YXRzXG4gKiBAcHJvcGVydHkgIHtudW1iZXJ9IFthdmVyYWdlXSAtIEF2ZXJhZ2UgdmFsdWUgb2JzZXJ2ZWQuXG4gKiBAcHJvcGVydHkgIHtudW1iZXJ9IFttYXhdIC0gTWF4IHZhbHVlIG9ic2VydmVkLlxuICogQHByb3BlcnR5ICB7bnVtYmVyfSBbbWluXSAtIE1pbiB2YWx1ZSBvYnNlcnZlZC5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIHN0YXRzIGZvciBhIG51bWVyaWNhbCBtZXRyaWMuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTZWxlY3RlZEljZUNhbmRpZGF0ZVBhaXJTdGF0c1xuICogQHByb3BlcnR5ICB7UlRDSWNlQ2FuZGlkYXRlU3RhdHN9IFtsb2NhbENhbmRpZGF0ZV0gLSBTZWxlY3RlZCBsb2NhbCBpY2UgY2FuZGlkYXRlXG4gKiBAcHJvcGVydHkgIHtSVENJY2VDYW5kaWRhdGVTdGF0c30gW3JlbW90ZUNhbmRpZGF0ZV0gLSBTZWxlY3RlZCBsb2NhbCBpY2UgY2FuZGlkYXRlXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBSVEMgcmVsYXRlZCBzdGF0cyB0aGF0IHdlcmUgb2JzZXJ2ZWQgZHVyaW5nIHByZWZsaWdodCB0ZXN0XG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQcmVmbGlnaHRSZXBvcnRTdGF0c1xuICogQHByb3BlcnR5IHtTdGF0c30gW2ppdHRlcl0gLSBQYWNrZXQgZGVsYXkgdmFyaWF0aW9uIGluIHNlY29uZHNcbiAqIEBwcm9wZXJ0eSB7U3RhdHN9IFtydHRdIC0gUm91bmQgdHJpcCB0aW1lLCB0byB0aGUgc2VydmVyIGJhY2sgdG8gdGhlIGNsaWVudCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge1N0YXRzfSBbcGFja2V0TG9zc10gLSBQYWNrZXQgbG9zcyBhcyBhIHBlcmNlbnQgb2YgdG90YWwgcGFja2V0cyBzZW50LlxuKi9cbi8qKlxuICogQSB7QGxpbmsgUHJlZmxpZ2h0UHJvZ3Jlc3N9IGV2ZW50IHdpdGggdGltaW5nIGluZm9ybWF0aW9uLlxuICogQHR5cGVkZWYge29iamVjdH0gUHJvZ3Jlc3NFdmVudFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbl0gLSBUaGUgZHVyYXRpb24gb2YgdGhlIGV2ZW50LCBtZWFzdXJlZCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgdGVzdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gLSBUaGUge0BsaW5rIFByZWZsaWdodFByb2dyZXNzfSBldmVudCBuYW1lLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgcmVwb3J0IGdlbmVyYXRlZCBieSB7QGxpbmsgUHJlZmxpZ2h0VGVzdH0uXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQcmVmbGlnaHRUZXN0UmVwb3J0XG4gKiBAcHJvcGVydHkge1RpbWVNZWFzdXJlbWVudH0gW3Rlc3RUaW1pbmddIC0gVGltZSBtZWFzdXJlbWVudHMgb2YgdGVzdCBydW4gdGltZS5cbiAqIEBwcm9wZXJ0eSB7TmV0d29ya1RpbWluZ30gW25ldHdvcmtUaW1pbmddIC0gTmV0d29yayByZWxhdGVkIHRpbWUgbWVhc3VyZW1lbnRzLlxuICogQHByb3BlcnR5IHtQcmVmbGlnaHRSZXBvcnRTdGF0c30gW3N0YXRzXSAtIFJUQyByZWxhdGVkIHN0YXRzIGNhcHR1cmVkIGR1cmluZyB0aGUgdGVzdC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8UlRDSWNlQ2FuZGlkYXRlU3RhdHM+fSBbaWNlQ2FuZGlkYXRlU3RhdHNdIC0gTGlzdCBvZiBnYXRoZXJlZCBpY2UgY2FuZGlkYXRlcy5cbiAqIEBwcm9wZXJ0eSB7U2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHN9IHNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzIC0gU3RhdHMgZm9yIHRoZSBpY2UgY2FuZGlkYXRlcyB0aGF0IHdlcmUgdXNlZCBmb3IgdGhlIGNvbm5lY3Rpb24uXG4gKiBAcHJvcGVydHkge0FycmF5PFByb2dyZXNzRXZlbnQ+fSBbcHJvZ3Jlc3NFdmVudHNdIC0ge0BsaW5rIFByb2dyZXNzRXZlbnR9IGV2ZW50cyBkZXRlY3RlZCBkdXJpbmcgdGhlIHRlc3QuXG4gKiBVc2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggc3RlcHMgd2VyZSBjb21wbGV0ZWQgYW5kIHdoaWNoIG9uZXMgd2VyZSBub3QuXG4gKi9cbi8qKlxuICogWW91IG1heSBwYXNzIHRoZXNlIG9wdGlvbnMgdG8ge0BsaW5rIG1vZHVsZTp0d2lsaW8tdmlkZW8udGVzdFByZWZsaWdodH0gaW4gb3JkZXIgdG8gb3ZlcnJpZGUgdGhlXG4gKiBkZWZhdWx0IGJlaGF2aW9yLlxuICogQHR5cGVkZWYge29iamVjdH0gUHJlZmxpZ2h0T3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtyZWdpb249J2dsbCddIC0gUHJlZmVycmVkIHNpZ25hbGluZyByZWdpb247IEJ5IGRlZmF1bHQsIHlvdSB3aWxsIGJlIGNvbm5lY3RlZCB0byB0aGVcbiAqICAgbmVhcmVzdCBzaWduYWxpbmcgc2VydmVyIGRldGVybWluZWQgYnkgbGF0ZW5jeSBiYXNlZCByb3V0aW5nLiBTZXR0aW5nIGEgdmFsdWUgb3RoZXJcbiAqICAgdGhhbiA8Y29kZSBzdHlsZT1cInBhZGRpbmc6MCAwXCI+Z2xsPC9jb2RlPiBieXBhc3NlcyByb3V0aW5nIGFuZCBndWFyYW50ZWVzIHRoYXQgc2lnbmFsaW5nIHRyYWZmaWMgd2lsbCBiZVxuICogICB0ZXJtaW5hdGVkIGluIHRoZSByZWdpb24gdGhhdCB5b3UgcHJlZmVyLiBQbGVhc2UgcmVmZXIgdG8gdGhpcyA8YSBocmVmPVwiaHR0cHM6Ly93d3cudHdpbGlvLmNvbS9kb2NzL3ZpZGVvL2lwLWFkZHJlc3Mtd2hpdGVsaXN0aW5nI3NpZ25hbGluZy1jb21tdW5pY2F0aW9uXCIgdGFyZ2V0PVwiX2JsYW5rXCI+dGFibGU8L2E+XG4gKiAgIGZvciB0aGUgbGlzdCBvZiBzdXBwb3J0ZWQgc2lnbmFsaW5nIHJlZ2lvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTEwMDAwXSAtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gcnVuIHRlc3QgZm9yLlxuICogICBvbmNlIGNvbm5lY3RlZCB0ZXN0IHdpbGwgcnVuIGZvciB0aGlzIGR1cmF0aW9uIGJlZm9yZSBnZW5lcmF0aW5nIHRoZSBzdGF0cyByZXBvcnQuXG4gKi9cbi8qKlxuICogUHJlZmxpZ2h0IHRlc3QgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gKiBAcGFyYW0ge1ByZWZsaWdodFRlc3RSZXBvcnR9IHJlcG9ydCAtIFJlc3VsdHMgb2YgdGhlIHRlc3QuXG4gKiBAZXZlbnQgUHJlZmxpZ2h0VGVzdCNjb21wbGV0ZWRcbiAqL1xuLyoqXG4gKiBQcmVmbGlnaHQgdGVzdCBoYXMgZW5jb3VudGVyZWQgYSBmYWlsdXJlIGFuZCBpcyBub3cgc3RvcHBlZC5cbiAqIEBwYXJhbSB7VHdpbGlvRXJyb3J8RXJyb3J9IGVycm9yIC0gQSBUd2lsaW9FcnJvciBvciBhIERPTUV4Y2VwdGlvbi5cbiAqIFBvc3NpYmxlIFR3aWxpb0Vycm9ycyBpbmNsdWRlIFNpZ25hbGluZyBhbmQgTWVkaWEgcmVsYXRlZCBlcnJvcnMgd2hpY2ggY2FuIGJlIGZvdW5kXG4gKiA8YSBocmVmPVwiaHR0cHM6Ly93d3cudHdpbGlvLmNvbS9kb2NzL3ZpZGVvL2J1aWxkLWpzLXZpZGVvLWFwcGxpY2F0aW9uLXJlY29tbWVuZGF0aW9ucy1hbmQtYmVzdC1wcmFjdGljZXMjY29ubmVjdGlvbi1lcnJvcnNcIiB0YXJnZXQ9XCJfYmxhbmtcIj5oZXJlPC9hPi5cbiAqIEBwYXJhbSB7UHJlZmxpZ2h0VGVzdFJlcG9ydH0gcmVwb3J0IC0gUGFydGlhbCByZXN1bHRzIGdhdGhlcmVkIGR1cmluZyB0aGUgdGVzdC4gVXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gaGVscCBkZXRlcm1pbmUgdGhlIGNhdXNlIG9mIGZhaWx1cmUuXG4gKiBAZXZlbnQgUHJlZmxpZ2h0VGVzdCNmYWlsZWRcbiAqL1xuLyoqXG4gKiBFbWl0dGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIHRoZSB0ZXN0XG4gKiBAcGFyYW0ge1ByZWZsaWdodFByb2dyZXNzfSBwcm9ncmVzcyAtIEluZGljYXRlcyB0aGUgc3RhdHVzIGNvbXBsZXRlZC5cbiAqIEBldmVudCBQcmVmbGlnaHRUZXN0I3Byb2dyZXNzXG4gKi9cbi8qKlxuICogQG1ldGhvZFxuICogQG5hbWUgcnVuUHJlZmxpZ2h0XG4gKiBAZGVzY3JpcHRpb24gUnVuIGEgcHJlZmxpZ2h0IHRlc3QuIFRoaXMgbWV0aG9kIHdpbGwgc3RhcnQgYSB0ZXN0IHRvIGNoZWNrIHRoZSBxdWFsaXR5IG9mIG5ldHdvcmsgY29ubmVjdGlvbi5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHdpbGlvLXZpZGVvXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBUaGUgQWNjZXNzIFRva2VuIHN0cmluZ1xuICogQHBhcmFtIHtQcmVmbGlnaHRPcHRpb25zfSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIHRlc3RcbiAqIEByZXR1cm5zIHtQcmVmbGlnaHRUZXN0fSBwcmVmbGlnaHRUZXN0IC0gQW4gaW5zdGFuY2UgdG8gYmUgdXNlZCB0byBtb25pdG9yIHByb2dyZXNzIG9mIHRoZSB0ZXN0LlxuICogQGV4YW1wbGVcbiAqIHZhciB7IHJ1blByZWZsaWdodCB9ID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gKiB2YXIgcHJlZmxpZ2h0ID0gcnVuUHJlZmxpZ2h0KHRva2VuLCBwcmVmbGlnaHRPcHRpb25zKTtcbiAqIHByZWZsaWdodFRlc3Qub24oJ3Byb2dyZXNzJywgcHJvZ3Jlc3MgPT4ge1xuICogICBjb25zb2xlLmxvZygncHJlZmxpZ2h0IHByb2dyZXNzOicsIHByb2dyZXNzKTtcbiAqIH0pO1xuICpcbiAqIHByZWZsaWdodFRlc3Qub24oJ2ZhaWxlZCcsIChlcnJvciwgcmVwb3J0KSA9PiB7XG4gKiAgIGNvbnNvbGUuZXJyb3IoJ3ByZWZsaWdodCBlcnJvcjonLCBlcnJvciwgcmVwb3J0KTtcbiAqIH0pO1xuICpcbiAqIHByZWZsaWdodFRlc3Qub24oJ2NvbXBsZXRlZCcsIHJlcG9ydCA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdwcmVmbGlnaHQgY29tcGxldGVkOicsIHJlcG9ydCkpO1xuICogfSk7XG4qL1xuZnVuY3Rpb24gcnVuUHJlZmxpZ2h0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgcHJlZmxpZ2h0ID0gbmV3IFByZWZsaWdodFRlc3QodG9rZW4sIG9wdGlvbnMpO1xuICAgIHJldHVybiBwcmVmbGlnaHQ7XG59XG5leHBvcnRzLnJ1blByZWZsaWdodCA9IHJ1blByZWZsaWdodDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWZsaWdodHRlc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN5bnRoZXRpY0F1ZGlvID0gdm9pZCAwO1xuZnVuY3Rpb24gc3ludGhldGljQXVkaW8oKSB7XG4gICAgLy8gTk9URShtcGF0d2FyZGhhbik6IFdlIGhhdmUgdG8gZGVsYXkgcmVxdWlyZS1pbmcgQXVkaW9Db250ZXh0RmFjdG9yeSwgYmVjYXVzZVxuICAgIC8vIGl0IGV4cG9ydHMgYSBkZWZhdWx0IGluc3RhbmNlIHdob3NlIGNvbnN0cnVjdG9yIGNhbGxzIE9iamVjdC5hc3NpZ24uXG4gICAgdmFyIGF1ZGlvQ29udGV4dEZhY3RvcnkgPSByZXF1aXJlKCcuLi93ZWJhdWRpby9hdWRpb2NvbnRleHQnKTtcbiAgICB2YXIgaG9sZGVyID0ge307XG4gICAgdmFyIGF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dEZhY3RvcnkuZ2V0T3JDcmVhdGUoaG9sZGVyKTtcbiAgICB2YXIgb3NjaWxsYXRvciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVPc2NpbGxhdG9yKCk7XG4gICAgdmFyIGRzdCA9IG9zY2lsbGF0b3IuY29ubmVjdChhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpKTtcbiAgICBvc2NpbGxhdG9yLnN0YXJ0KCk7XG4gICAgdmFyIHRyYWNrID0gZHN0LnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdO1xuICAgIHZhciBvcmlnaW5hbFN0b3AgPSB0cmFjay5zdG9wO1xuICAgIHRyYWNrLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9yaWdpbmFsU3RvcC5jYWxsKHRyYWNrKTtcbiAgICAgICAgYXVkaW9Db250ZXh0RmFjdG9yeS5yZWxlYXNlKGhvbGRlcik7XG4gICAgfTtcbiAgICByZXR1cm4gdHJhY2s7XG59XG5leHBvcnRzLnN5bnRoZXRpY0F1ZGlvID0gc3ludGhldGljQXVkaW87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zeW50aGV0aWNhdWRpby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3ludGhldGljVmlkZW8gPSB2b2lkIDA7XG5mdW5jdGlvbiBzeW50aGV0aWNWaWRlbyhfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLndpZHRoLCB3aWR0aCA9IF9jID09PSB2b2lkIDAgPyA2NDAgOiBfYywgX2QgPSBfYi5oZWlnaHQsIGhlaWdodCA9IF9kID09PSB2b2lkIDAgPyA0ODAgOiBfZDtcbiAgICB2YXIgY2FudmFzID0gT2JqZWN0LmFzc2lnbihkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSwgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ2dyZWVuJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICAgIC8vIGRyYXcgcmFuZG9tIHJlY3QvY2lyY2xlLlxuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgICAgICAgICAgdmFyIGcgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgICAgICAgICAgdmFyIGIgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgICAgICAgICAgdmFyIGEgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYShcIiArIHIgKyBcIiwgXCIgKyBnICsgXCIsIFwiICsgYiArIFwiLCBcIiArIGEgKyBcIilcIjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChNYXRoLnJhbmRvbSgpICogd2lkdGgsIE1hdGgucmFuZG9tKCkgKiBoZWlnaHQsIDUwLCA1MCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgc3RyZWFtID0gY2FudmFzLmNhcHR1cmVTdHJlYW0oMzApO1xuICAgIHZhciB0cmFjayA9IHN0cmVhbS5nZXRUcmFja3MoKVswXTtcbiAgICB2YXIgb3JpZ2luYWxTdG9wID0gdHJhY2suc3RvcDtcbiAgICB0cmFjay5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgb3JpZ2luYWxTdG9wLmNhbGwodHJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIHRyYWNrO1xufVxuZXhwb3J0cy5zeW50aGV0aWNWaWRlbyA9IHN5bnRoZXRpY1ZpZGVvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ludGhldGljdmlkZW8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRpbWVyID0gdm9pZCAwO1xudmFyIFRpbWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVyKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgICAgIHRoaXMuX2VuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgICBUaW1lci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUaW1lci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZW5kID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBUaW1lci5wcm90b3R5cGUuZ2V0VGltZU1lYXN1cmVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuX3N0YXJ0LFxuICAgICAgICAgICAgZW5kOiB0aGlzLl9lbmQsXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fZW5kID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLl9lbmQgLSB0aGlzLl9zdGFydFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVyO1xufSgpKTtcbmV4cG9ydHMuVGltZXIgPSBUaW1lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICByZXR1cm4gdG87XG59O1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbi8qKlxuICogQSB7QGxpbmsgUXVldWVpbmdFdmVudEVtaXR0ZXJ9IGNhbiBxdWV1ZSBldmVudHMgdW50aWwgYSBsaXN0ZW5lciBoYXMgYmVlblxuICogYWRkZWQuXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xudmFyIFF1ZXVlaW5nRXZlbnRFbWl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhRdWV1ZWluZ0V2ZW50RW1pdHRlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUXVldWVpbmdFdmVudEVtaXR0ZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gUXVldWVpbmdFdmVudEVtaXR0ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfcXVldWVkRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IGFueSBxdWV1ZWQgZXZlbnRzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGV2ZXJ5IGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGZhbHNlIG90aGVyd2lzZVxuICAgICovIC8qKlxuICAgICAqIEVtaXQgYW55IHF1ZXVlZCBldmVudHMgbWF0Y2hpbmcgdGhlIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgZXZlcnkgZXZlbnQgaGFkIGxpc3RlbmVycywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgUXVldWVpbmdFdmVudEVtaXR0ZXIucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfLCBxdWV1ZWRFdmVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZGVxdWV1ZShxdWV1ZWRFdmVudCkgJiYgcmVzdWx0O1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlZEV2ZW50cy5nZXQoZXZlbnQpIHx8IFtdO1xuICAgICAgICB0aGlzLl9xdWV1ZWRFdmVudHMuZGVsZXRlKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHF1ZXVlLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBhcmdzKSB7IHJldHVybiBfdGhpcy5lbWl0LmFwcGx5KF90aGlzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoW2V2ZW50XS5jb25jYXQoYXJncykpKSkgJiYgcmVzdWx0OyB9LCByZXN1bHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGV2ZW50IGhhcyBsaXN0ZW5lcnMsIGVtaXQgdGhlIGV2ZW50OyBvdGhlcndpc2UsIHF1ZXVlIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZmFsc2UgaWYgdGhlIGV2ZW50IHdhcyBxdWV1ZWRcbiAgICAgKi9cbiAgICBRdWV1ZWluZ0V2ZW50RW1pdHRlci5wcm90b3R5cGUucXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGhpcy5lbWl0LmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnQgPSBhcmdzWzBdO1xuICAgICAgICBpZiAoIXRoaXMuX3F1ZXVlZEV2ZW50cy5oYXMoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZWRFdmVudHMuc2V0KGV2ZW50LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcXVldWVkRXZlbnRzLmdldChldmVudCkucHVzaChhcmdzLnNsaWNlKDEpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIFF1ZXVlaW5nRXZlbnRFbWl0dGVyO1xufShFdmVudEVtaXR0ZXIpKTtcbm1vZHVsZS5leHBvcnRzID0gUXVldWVpbmdFdmVudEVtaXR0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZWluZ2V2ZW50ZW1pdHRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgICAgICB0b1tqXSA9IGZyb21baV07XG4gICAgcmV0dXJuIHRvO1xufTtcbnZhciBQYXJ0aWNpcGFudCA9IHJlcXVpcmUoJy4vcGFydGljaXBhbnQnKTtcbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHJlcHJlc2VudHMgYSByZW1vdGUge0BsaW5rIFBhcnRpY2lwYW50fSBpbiBhXG4gKiB7QGxpbmsgUm9vbX0uXG4gKiBAZXh0ZW5kcyBQYXJ0aWNpcGFudFxuICogQHByb3BlcnR5IHtNYXA8VHJhY2suU0lELCBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24+fSBhdWRpb1RyYWNrcyAtXG4gKiAgICBUaGUge0BsaW5rIFBhcnRpY2lwYW50fSdzIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb259c1xuICogQHByb3BlcnR5IHtNYXA8VHJhY2suU0lELCBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbj59IGRhdGFUcmFja3MgLVxuICogICAgVGhlIHtAbGluayBQYXJ0aWNpcGFudH0ncyB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb259c1xuICogQHByb3BlcnR5IHtNYXA8VHJhY2suU0lELCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uPn0gdHJhY2tzIC1cbiAqICAgIFRoZSB7QGxpbmsgUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259c1xuICogQHByb3BlcnR5IHtNYXA8VHJhY2suU0lELCBSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb24+fSB2aWRlb1RyYWNrcyAtXG4gKiAgICBUaGUge0BsaW5rIFBhcnRpY2lwYW50fSdzIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb259c1xuICogQGVtaXRzIFJlbW90ZVBhcnRpY2lwYW50I3JlY29ubmVjdGVkXG4gKiBAZW1pdHMgUmVtb3RlUGFydGljaXBhbnQjcmVjb25uZWN0aW5nXG4gKiBAZW1pdHMgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tEaW1lbnNpb25zQ2hhbmdlZFxuICogQGVtaXRzIFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrRGlzYWJsZWRcbiAqIEBlbWl0cyBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja0VuYWJsZWRcbiAqIEBlbWl0cyBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja01lc3NhZ2VcbiAqIEBlbWl0cyBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja1B1Ymxpc2hlZFxuICogQGVtaXRzIFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrUHVibGlzaFByaW9yaXR5Q2hhbmdlZFxuICogQGVtaXRzIFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrU3RhcnRlZFxuICogQGVtaXRzIFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrU3Vic2NyaWJlZFxuICogQGVtaXRzIFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrU3Vic2NyaXB0aW9uRmFpbGVkXG4gKiBAZW1pdHMgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tTd2l0Y2hlZE9mZlxuICogQGVtaXRzIFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrU3dpdGNoZWRPblxuICogQGVtaXRzIFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrVW5wdWJsaXNoZWRcbiAqIEBlbWl0cyBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja1Vuc3Vic2NyaWJlZFxuICovXG52YXIgUmVtb3RlUGFydGljaXBhbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbW90ZVBhcnRpY2lwYW50LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0uXG4gICAgICogQHBhcmFtIHtQYXJ0aWNpcGFudFNpZ25hbGluZ30gc2lnbmFsaW5nXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbW90ZVBhcnRpY2lwYW50KHNpZ25hbGluZywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzaWduYWxpbmcsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9oYW5kbGVUcmFja1NpZ25hbGluZ0V2ZW50cygpO1xuICAgICAgICBfdGhpcy5vbmNlKCdkaXNjb25uZWN0ZWQnLCBfdGhpcy5fdW5zdWJzY3JpYmVUcmFja3MuYmluZChfdGhpcykpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlbW90ZVBhcnRpY2lwYW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW1JlbW90ZVBhcnRpY2lwYW50ICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyAodGhpcy5zaWQgPyBcIjogXCIgKyB0aGlzLnNpZCA6ICcnKSArIFwiXVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1JlbW90ZVRyYWNrfSByZW1vdGVUcmFja1xuICAgICAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb25cbiAgICAgKiBAcmV0dXJucyB7P1JlbW90ZVRyYWNrfVxuICAgICAqL1xuICAgIFJlbW90ZVBhcnRpY2lwYW50LnByb3RvdHlwZS5fYWRkVHJhY2sgPSBmdW5jdGlvbiAocmVtb3RlVHJhY2ssIHB1YmxpY2F0aW9uKSB7XG4gICAgICAgIGlmICghX3N1cGVyLnByb3RvdHlwZS5fYWRkVHJhY2suY2FsbCh0aGlzLCByZW1vdGVUcmFjaywgcmVtb3RlVHJhY2suc2lkKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcHVibGljYXRpb24uX3N1YnNjcmliZWQocmVtb3RlVHJhY2spO1xuICAgICAgICB0aGlzLmVtaXQoJ3RyYWNrU3Vic2NyaWJlZCcsIHJlbW90ZVRyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIHJldHVybiByZW1vdGVUcmFjaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvblxuICAgICAqIEByZXR1cm5zIHs/UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn1cbiAgICAgKi9cbiAgICBSZW1vdGVQYXJ0aWNpcGFudC5wcm90b3R5cGUuX2FkZFRyYWNrUHVibGljYXRpb24gPSBmdW5jdGlvbiAocHVibGljYXRpb24pIHtcbiAgICAgICAgdmFyIGFkZGVkUHVibGljYXRpb24gPSBfc3VwZXIucHJvdG90eXBlLl9hZGRUcmFja1B1YmxpY2F0aW9uLmNhbGwodGhpcywgcHVibGljYXRpb24pO1xuICAgICAgICBpZiAoIWFkZGVkUHVibGljYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgndHJhY2tQdWJsaXNoZWQnLCBhZGRlZFB1YmxpY2F0aW9uKTtcbiAgICAgICAgcmV0dXJuIGFkZGVkUHVibGljYXRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlbW90ZVBhcnRpY2lwYW50LnByb3RvdHlwZS5fZ2V0VHJhY2tQdWJsaWNhdGlvbkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKF9zdXBlci5wcm90b3R5cGUuX2dldFRyYWNrUHVibGljYXRpb25FdmVudHMuY2FsbCh0aGlzKSkpLCBbXG4gICAgICAgICAgICBbJ3N1YnNjcmlwdGlvbkZhaWxlZCcsICd0cmFja1N1YnNjcmlwdGlvbkZhaWxlZCddLFxuICAgICAgICAgICAgWyd0cmFja0Rpc2FibGVkJywgJ3RyYWNrRGlzYWJsZWQnXSxcbiAgICAgICAgICAgIFsndHJhY2tFbmFibGVkJywgJ3RyYWNrRW5hYmxlZCddLFxuICAgICAgICAgICAgWydwdWJsaXNoUHJpb3JpdHlDaGFuZ2VkJywgJ3RyYWNrUHVibGlzaFByaW9yaXR5Q2hhbmdlZCddLFxuICAgICAgICAgICAgWyd0cmFja1N3aXRjaGVkT2ZmJywgJ3RyYWNrU3dpdGNoZWRPZmYnXSxcbiAgICAgICAgICAgIFsndHJhY2tTd2l0Y2hlZE9uJywgJ3RyYWNrU3dpdGNoZWRPbiddXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZW1vdGVQYXJ0aWNpcGFudC5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlVHJhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChwdWJsaWNhdGlvbikge1xuICAgICAgICAgICAgaWYgKHB1YmxpY2F0aW9uLmlzU3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IHB1YmxpY2F0aW9uLnRyYWNrO1xuICAgICAgICAgICAgICAgIHB1YmxpY2F0aW9uLl91bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3RyYWNrVW5zdWJzY3JpYmVkJywgdHJhY2ssIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHJlbW90ZVRyYWNrXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvblxuICAgICAqIEByZXR1cm5zIHs/UmVtb3RlVHJhY2t9XG4gICAgICovXG4gICAgUmVtb3RlUGFydGljaXBhbnQucHJvdG90eXBlLl9yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIChyZW1vdGVUcmFjaywgcHVibGljYXRpb24pIHtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlZFRyYWNrID0gdGhpcy5fdHJhY2tzLmdldChyZW1vdGVUcmFjay5zaWQpO1xuICAgICAgICBpZiAoIXVuc3Vic2NyaWJlZFRyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9yZW1vdmVUcmFjay5jYWxsKHRoaXMsIHVuc3Vic2NyaWJlZFRyYWNrLCB1bnN1YnNjcmliZWRUcmFjay5zaWQpO1xuICAgICAgICBwdWJsaWNhdGlvbi5fdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5lbWl0KCd0cmFja1Vuc3Vic2NyaWJlZCcsIHVuc3Vic2NyaWJlZFRyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIHJldHVybiB1bnN1YnNjcmliZWRUcmFjaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvblxuICAgICAqIEByZXR1cm5zIHs/UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn1cbiAgICAgKi9cbiAgICBSZW1vdGVQYXJ0aWNpcGFudC5wcm90b3R5cGUuX3JlbW92ZVRyYWNrUHVibGljYXRpb24gPSBmdW5jdGlvbiAocHVibGljYXRpb24pIHtcbiAgICAgICAgdGhpcy5fc2lnbmFsaW5nLmNsZWFyVHJhY2tIaW50KHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgdmFyIHJlbW92ZWRQdWJsaWNhdGlvbiA9IF9zdXBlci5wcm90b3R5cGUuX3JlbW92ZVRyYWNrUHVibGljYXRpb24uY2FsbCh0aGlzLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIGlmICghcmVtb3ZlZFB1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3RyYWNrVW5wdWJsaXNoZWQnLCByZW1vdmVkUHVibGljYXRpb24pO1xuICAgICAgICByZXR1cm4gcmVtb3ZlZFB1YmxpY2F0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbW90ZVBhcnRpY2lwYW50O1xufShQYXJ0aWNpcGFudCkpO1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSBoYXMgcmVjb25uZWN0ZWQgdG8gdGhlIHtAbGluayBSb29tfSBhZnRlciBhIHNpZ25hbGluZyBjb25uZWN0aW9uIGRpc3J1cHRpb24uXG4gKiBAZXZlbnQgUmVtb3RlUGFydGljaXBhbnQjcmVjb25uZWN0ZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSBpcyByZWNvbm5lY3RpbmcgdG8gdGhlIHtAbGluayBSb29tfSBhZnRlciBhIHNpZ25hbGluZyBjb25uZWN0aW9uIGRpc3J1cHRpb24uXG4gKiBAZXZlbnQgUmVtb3RlUGFydGljaXBhbnQjcmVjb25uZWN0aW5nXG4gKi9cbi8qKlxuICogT25lIG9mIHRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9J3MgZGltZW5zaW9ucyBjaGFuZ2VkLlxuICogQHBhcmFtIHtSZW1vdGVWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gd2hvc2UgZGltZW5zaW9ucyBjaGFuZ2VkXG4gKiBAZXZlbnQgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tEaW1lbnNpb25zQ2hhbmdlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgZGlzYWJsZWQgYnkgdGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0uXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBhc3NvY2lhdGVkIHdpdGggdGhlIGRpc2FibGVkIHtAbGluayBSZW1vdGVUcmFja31cbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja0Rpc2FibGVkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyBlbmFibGVkIGJ5IHRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9LlxuICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvbiAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gYXNzb2NpYXRlZCB3aXRoIHRoZSBlbmFibGVkIHtAbGluayBSZW1vdGVUcmFja31cbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja0VuYWJsZWRcbiAqL1xuLyoqXG4gKiBBIG1lc3NhZ2Ugd2FzIHJlY2VpdmVkIG92ZXIgb25lIG9mIHRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9J3NcbiAqIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9cy5cbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja01lc3NhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5QnVmZmVyfSBkYXRhXG4gKiBAcGFyYW0ge1JlbW90ZURhdGFUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZURhdGFUcmFja30gb3ZlciB3aGljaCB0aGVcbiAqICAgbWVzc2FnZSB3YXMgcmVjZWl2ZWRcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVUcmFja30gd2FzIHB1Ymxpc2hlZCBieSB0aGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSBhZnRlclxuICogY29ubmVjdGluZyB0byB0aGUge0BsaW5rIFJvb219LiBUaGlzIGV2ZW50IGlzIG5vdCBlbWl0dGVkIGZvclxuICoge0BsaW5rIFJlbW90ZVRyYWNrfXMgdGhhdCB3ZXJlIHB1Ymxpc2hlZCB3aGlsZSB0aGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fVxuICogd2FzIGNvbm5lY3RpbmcgdG8gdGhlIHtAbGluayBSb29tfS5cbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja1B1Ymxpc2hlZFxuICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvbiAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn1cbiAqICAgd2hpY2ggcmVwcmVzZW50cyB0aGUgcHVibGlzaGVkIHtAbGluayBSZW1vdGVUcmFja31cbiAqIEBleGFtcGxlXG4gKiBmdW5jdGlvbiB0cmFja1B1Ymxpc2hlZChwdWJsaWNhdGlvbikge1xuICogICBjb25zb2xlLmxvZyhgVHJhY2sgJHtwdWJsaWNhdGlvbi50cmFja1NpZH0gd2FzIHB1Ymxpc2hlZGApO1xuICogfVxuICpcbiAqIHJvb20ub24oJ3BhcnRpY2lwYW50Q29ubmVjdGVkJywgcGFydGljaXBhbnQgPT4ge1xuICogICAvLyBIYW5kbGUgUmVtb3RlVHJhY2tzIHB1Ymxpc2hlZCB3aGlsZSBjb25uZWN0aW5nIHRvIHRoZSBSb29tLlxuICogICBwYXJ0aWNpcGFudC50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHRyYWNrUHVibGlzaGVkKTtcbiAqXG4gKiAgIC8vIEhhbmRsZSBSZW1vdGVUcmFja3MgcHVibGlzaGVkIGFmdGVyIGNvbm5lY3RpbmcgdG8gdGhlIFJvb20uXG4gKiAgIHBhcnRpY2lwYW50Lm9uKCd0cmFja1B1Ymxpc2hlZCcsIHRyYWNrUHVibGlzaGVkKTtcbiAqIH0pO1xuICovXG4vKipcbiAqIE9uZSBvZiB0aGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSdzIHtAbGluayBSZW1vdGVUcmFja31zIHN0YXJ0ZWQuXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgc3RhcnRlZFxuICogQGV2ZW50IFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrU3RhcnRlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSdzIHtAbGluayBSZW1vdGVUcmFja30gd2FzIHN1YnNjcmliZWQgdG8uXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHN1YnNjcmliZWQgdG9cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb24gLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259XG4gKiAgIGZvciB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSB0aGF0IHdhcyBzdWJzY3JpYmVkIHRvXG4gKiBAZXZlbnQgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tTdWJzY3JpYmVkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZVRyYWNrfSBjb3VsZCBub3QgYmUgc3Vic2NyaWJlZCB0by5cbiAqIEBwYXJhbSB7VHdpbGlvRXJyb3J9IGVycm9yIC0gVGhlIHJlYXNvbiB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSBjb3VsZCBub3QgYmVcbiAqICAgc3Vic2NyaWJlZCB0b1xuICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvbiAtIFRoZVxuICogICB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gZm9yIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgY291bGQgbm90XG4gKiAgIGJlIHN1YnNjcmliZWQgdG9cbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja1N1YnNjcmlwdGlvbkZhaWxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0ncyBwdWJsaXNoIHtAbGluayBUcmFjay5Qcmlvcml0eX0gd2FzIGNoYW5nZWQgYnkgdGhlXG4gKiB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9LlxuICogQHBhcmFtIHtUcmFjay5Qcmlvcml0eX0gcHJpb3JpdHkgLSB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSdzIG5ldyBwdWJsaXNoXG4gKiAgIHtAbGluayBUcmFjay5Qcmlvcml0eX07XG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlXG4gKiAgIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBmb3IgdGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCBjaGFuZ2VkIHByaW9yaXR5XG4gKiBAZXZlbnQgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tQdWJsaXNoUHJpb3JpdHlDaGFuZ2VkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgc3dpdGNoZWQgb2ZmLiBUaGUgbWVkaWEgc2VydmVyIHN0b3BzXG4gKiBzZW5kaW5nIG1lZGlhIG9yIGRhdGEgZm9yIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHVudGlsIGl0IGlzIHN3aXRjaGVkIGJhY2sgb24uIEp1c3QgYmVmb3JlXG4gKiB0aGUgZXZlbnQgaXMgcmFpc2VkLCA8Y29kZT5pc1N3aXRjaGVkT2ZmPC9jb2RlPiBpcyBzZXQgdG8gPGNvZGU+dHJ1ZTwvY29kZT4gYW5kIDxjb2RlPnN3aXRjaE9mZlJlYXNvbjwvY29kZT5cbiAqIGlzIHNldCB0byBhIHtAbGluayBUcmFja1N3aXRjaE9mZlJlYXNvbn0uIEFsc28sIGlmIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHJlY2VpdmVzIGVpdGhlciBhdWRpbyBvciB2aWRlb1xuICogbWVkaWEsIHRoZSA8Y29kZT5tZWRpYVN0cmVhbVRyYWNrPC9jb2RlPiBwcm9wZXJ0eSBpcyBzZXQgdG8gPGNvZGU+bnVsbDwvY29kZT4uXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHN3aXRjaGVkIG9mZlxuICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvbiAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn1cbiAqICAgZm9yIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHN3aXRjaGVkIG9mZlxuICogQHBhcmFtIHs/VHJhY2tTd2l0Y2hPZmZSZWFzb259IHN3aXRjaE9mZlJlYXNvbiAtIFRoZSByZWFzb24gdGhlIHtAbGluayBSZW1vdGVNZWRpYVRyYWNrfVxuICogICB3YXMgc3dpdGNoZWQgb2ZmXG4gKiBAZXZlbnQgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tTd2l0Y2hlZE9mZlxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSdzIHtAbGluayBSZW1vdGVUcmFja30gd2FzIHN3aXRjaGVkIG9uLiBUaGUgbWVkaWEgc2VydmVyIHN0YXJ0c1xuICogc2VuZGluZyBtZWRpYSBmb3IgdGhlIHtAbGluayBSZW1vdGVUcmFja30gdW50aWwgaXQgaXMgc3dpdGNoZWQgb2ZmLiBKdXN0IGJlZm9yZSB0aGUgZXZlbnQgaXMgcmFpc2VkLFxuICogPGNvZGU+aXNTd2l0Y2hlZE9mZjwvY29kZT4gaXMgc2V0IHRvIDxjb2RlPmZhbHNlPC9jb2RlPiBhbmQgPGNvZGU+c3dpdGNoT2ZmUmVhc29uPC9jb2RlPlxuICogaXMgc2V0IHRvIDxjb2RlPm51bGw8L2NvZGU+LiBBbHNvLCBpZiB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSByZWNlaXZlcyBlaXRoZXIgYXVkaW8gb3IgdmlkZW8gbWVkaWEsXG4gKiB0aGUgPGNvZGU+bWVkaWFTdHJlYW1UcmFjazwvY29kZT4gcHJvcGVydHkgaXMgc2V0IHRvIGEgTWVkaWFTdHJlYW1UcmFjayB0aGF0IGlzIHRoZSBzb3VyY2Ugb2YgdGhlXG4gKiB7QGxpbmsgUmVtb3RlVHJhY2t9J3MgbWVkaWEuXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHN3aXRjaGVkIG9uLlxuICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvbiAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn1cbiAqICAgZm9yIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHN3aXRjaGVkIG9uXG4gKiBAZXZlbnQgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tTd2l0Y2hlZE9uXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyB1bnB1Ymxpc2hlZCBieSB0aGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fS5cbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja1VucHVibGlzaGVkXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICogICB3aGljaCByZXByZXNlbnRzIHRoZSB1bnB1Ymxpc2hlZCB7QGxpbmsgUmVtb3RlVHJhY2t9XG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgdW5zdWJzY3JpYmVkIGZyb20uXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHVuc3Vic2NyaWJlZCBmcm9tXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICogICBmb3IgdGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCB3YXMgdW5zdWJzY3JpYmVkIGZyb21cbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja1Vuc3Vic2NyaWJlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW90ZVBhcnRpY2lwYW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RlcGFydGljaXBhbnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xuICAgIHJldHVybiB0bztcbn07XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9ldmVudGVtaXR0ZXInKTtcbnZhciBSZW1vdGVQYXJ0aWNpcGFudCA9IHJlcXVpcmUoJy4vcmVtb3RlcGFydGljaXBhbnQnKTtcbnZhciBTdGF0c1JlcG9ydCA9IHJlcXVpcmUoJy4vc3RhdHMvc3RhdHNyZXBvcnQnKTtcbnZhciB2YWx1ZVRvSlNPTiA9IHJlcXVpcmUoJy4vdXRpbCcpLnZhbHVlVG9KU09OO1xudmFyIG5JbnN0YW5jZXMgPSAwO1xuLyoqXG4gKiBBIHtAbGluayBSb29tfSByZXByZXNlbnRzIGNvbW11bmljYXRpb24gYmV0d2VlbiB5b3UgYW5kIG9uZSBvciBtb3JlXG4gKiB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9cyBzaGFyaW5nIHtAbGluayBBdWRpb1RyYWNrfXMgYW5kXG4gKiB7QGxpbmsgVmlkZW9UcmFja31zLlxuICogPGJyPjxicj5cbiAqIFlvdSBjYW4gY29ubmVjdCB0byBhIHtAbGluayBSb29tfSBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6dHdpbGlvLXZpZGVvLmNvbm5lY3R9LlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAcHJvcGVydHkgez9SZW1vdGVQYXJ0aWNpcGFudH0gZG9taW5hbnRTcGVha2VyIC0gVGhlIERvbWluYW50IFNwZWFrZXIgaW4gdGhlXG4gKiAgIHtAbGluayBSb29tfSwgaWYgYW55XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzUmVjb3JkaW5nIC0gV2hldGhlciBvciBub3QgdGhlIHtAbGluayBSb29tfSBpcyBiZWluZ1xuICogICByZWNvcmRlZFxuICogQHByb3BlcnR5IHtMb2NhbFBhcnRpY2lwYW50fSBsb2NhbFBhcnRpY2lwYW50IC0gWW91ciB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH1cbiAqICAgaW4gdGhlIHtAbGluayBSb29tfVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lZGlhUmVnaW9uIC0gU3RyaW5nIGluZGljYXRpbmcgZ2VvZ3JhcGhpY2FsIHJlZ2lvblxuICogICAgd2hlcmUgIG1lZGlhIGlzIHByb2Nlc3NlZCBmb3IgdGhlIHtAbGluayBSb29tfS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIHtAbGluayBSb29tfSdzIG5hbWVcbiAqIEBwcm9wZXJ0eSB7TWFwPFBhcnRpY2lwYW50LlNJRCwgUmVtb3RlUGFydGljaXBhbnQ+fSBwYXJ0aWNpcGFudHMgLVxuICogICBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fXMgcGFydGljaXBhdGluZyBpbiB0aGlzIHtAbGluayBSb29tfVxuICogQHByb3BlcnR5IHtSb29tLlNJRH0gc2lkIC0gVGhlIHtAbGluayBSb29tfSdzIFNJRFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gXCJjb25uZWN0ZWRcIiwgXCJyZWNvbm5lY3RpbmdcIiwgb3IgXCJkaXNjb25uZWN0ZWRcIlxuICogQHRocm93cyB7U2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yfVxuICogQGVtaXRzIFJvb20jZGlzY29ubmVjdGVkXG4gKiBAZW1pdHMgUm9vbSNwYXJ0aWNpcGFudENvbm5lY3RlZFxuICogQGVtaXRzIFJvb20jcGFydGljaXBhbnREaXNjb25uZWN0ZWRcbiAqIEBlbWl0cyBSb29tI3BhcnRpY2lwYW50UmVjb25uZWN0ZWRcbiAqIEBlbWl0cyBSb29tI3BhcnRpY2lwYW50UmVjb25uZWN0aW5nXG4gKiBAZW1pdHMgUm9vbSNyZWNvbm5lY3RlZFxuICogQGVtaXRzIFJvb20jcmVjb25uZWN0aW5nXG4gKiBAZW1pdHMgUm9vbSNyZWNvcmRpbmdTdGFydGVkXG4gKiBAZW1pdHMgUm9vbSNyZWNvcmRpbmdTdG9wcGVkXG4gKiBAZW1pdHMgUm9vbSN0cmFja0RpbWVuc2lvbnNDaGFuZ2VkXG4gKiBAZW1pdHMgUm9vbSN0cmFja0Rpc2FibGVkXG4gKiBAZW1pdHMgUm9vbSN0cmFja0VuYWJsZWRcbiAqIEBlbWl0cyBSb29tI3RyYWNrTWVzc2FnZVxuICogQGVtaXRzIFJvb20jdHJhY2tQdWJsaXNoZWRcbiAqIEBlbWl0cyBSb29tI3RyYWNrUHVibGlzaFByaW9yaXR5Q2hhbmdlZFxuICogQGVtaXRzIFJvb20jdHJhY2tTdGFydGVkXG4gKiBAZW1pdHMgUm9vbSN0cmFja1N1YnNjcmliZWRcbiAqIEBlbWl0cyBSb29tI3RyYWNrU3dpdGNoZWRPZmZcbiAqIEBlbWl0cyBSb29tI3RyYWNrU3dpdGNoZWRPblxuICogQGVtaXRzIFJvb20jdHJhY2tVbnB1Ymxpc2hlZFxuICogQGVtaXRzIFJvb20jdHJhY2tVbnN1YnNjcmliZWRcbiAqL1xudmFyIFJvb20gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb20sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJvb219LlxuICAgICAqIEBwYXJhbSB7Um9vbVNpZ25hbGluZ30gc2lnbmFsaW5nXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSb29tKGxvY2FsUGFydGljaXBhbnQsIHNpZ25hbGluZywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICB2YXIgbG9nID0gb3B0aW9ucy5sb2cuY3JlYXRlTG9nKCdkZWZhdWx0JywgX3RoaXMpO1xuICAgICAgICB2YXIgcGFydGljaXBhbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2xvZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsb2dcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sIHx8ICdkaXNhYmxlZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY29udGVudFByZWZlcmVuY2VzTW9kZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmNvbnRlbnRQcmVmZXJlbmNlc01vZGUgfHwgJ2Rpc2FibGVkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pbnN0YW5jZUlkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICsrbkluc3RhbmNlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcGFydGljaXBhbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcnRpY2lwYW50c1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2lnbmFsaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9taW5hbnRTcGVha2VyOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFydGljaXBhbnRzLmdldChzaWduYWxpbmcuZG9taW5hbnRTcGVha2VyU2lkKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1JlY29yZGluZzoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYWxpbmcucmVjb3JkaW5nLmlzRW5hYmxlZCB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9jYWxQYXJ0aWNpcGFudDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxvY2FsUGFydGljaXBhbnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2lnbmFsaW5nLm5hbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJ0aWNpcGFudHM6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJ0aWNpcGFudHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzaWduYWxpbmcuc2lkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsaW5nLnN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZWRpYVJlZ2lvbjoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHNpZ25hbGluZy5tZWRpYVJlZ2lvblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlUmVjb3JkaW5nRXZlbnRzKF90aGlzLCBzaWduYWxpbmcucmVjb3JkaW5nKTtcbiAgICAgICAgaGFuZGxlU2lnbmFsaW5nRXZlbnRzKF90aGlzLCBzaWduYWxpbmcpO1xuICAgICAgICBsb2cuaW5mbygnQ3JlYXRlZCBhIG5ldyBSb29tOicsIF90aGlzLm5hbWUpO1xuICAgICAgICBsb2cuZGVidWcoJ0luaXRpYWwgUmVtb3RlUGFydGljaXBhbnRzOicsIEFycmF5LmZyb20oX3RoaXMuX3BhcnRpY2lwYW50cy52YWx1ZXMoKSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJvb20ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbUm9vbSAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgdGhpcy5zaWQgKyBcIl1cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgZnJvbSB0aGUge0BsaW5rIFJvb219LlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIFJvb20ucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xvZy5pbmZvKCdEaXNjb25uZWN0aW5nJyk7XG4gICAgICAgIHRoaXMuX3NpZ25hbGluZy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB7QGxpbmsgUm9vbX0ncyBtZWRpYSBzdGF0aXN0aWNzLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gU2FmYXJpIDEyLjAgb3IgYmVsb3dcbiAgICAgKiBkdWUgdG8gdGhpcyBidWcgOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTkyNjAxXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXk8U3RhdHNSZXBvcnQ+Pn1cbiAgICAgKi9cbiAgICBSb29tLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbGluZy5nZXRTdGF0cygpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlcykge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocmVzcG9uc2VzKS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgaWQgPSBfYlswXSwgcmVzcG9uc2UgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YXRzUmVwb3J0KGlkLCBPYmplY3QuYXNzaWduKHt9LCByZXNwb25zZSwge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbEF1ZGlvVHJhY2tTdGF0czogcmV3cml0ZUxvY2FsVHJhY2tJZHMoX3RoaXMsIHJlc3BvbnNlLmxvY2FsQXVkaW9UcmFja1N0YXRzKSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxWaWRlb1RyYWNrU3RhdHM6IHJld3JpdGVMb2NhbFRyYWNrSWRzKF90aGlzLCByZXNwb25zZS5sb2NhbFZpZGVvVHJhY2tTdGF0cylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb29tLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVRvSlNPTih0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBSb29tO1xufShFdmVudEVtaXR0ZXIpKTtcbmZ1bmN0aW9uIHJld3JpdGVMb2NhbFRyYWNrSWRzKHJvb20sIHRyYWNrU3RhdHMpIHtcbiAgICB2YXIgbG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZyA9IHJvb20ubG9jYWxQYXJ0aWNpcGFudC5fc2lnbmFsaW5nO1xuICAgIHJldHVybiB0cmFja1N0YXRzLnJlZHVjZShmdW5jdGlvbiAodHJhY2tTdGF0cywgdHJhY2tTdGF0KSB7XG4gICAgICAgIHZhciBwdWJsaWNhdGlvbiA9IGxvY2FsUGFydGljaXBhbnRTaWduYWxpbmcudHJhY2tzLmdldCh0cmFja1N0YXQudHJhY2tJZCk7XG4gICAgICAgIHZhciB0cmFja1NlbmRlciA9IGxvY2FsUGFydGljaXBhbnRTaWduYWxpbmcuZ2V0U2VuZGVyKHB1YmxpY2F0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRyYWNrU2VuZGVyXG4gICAgICAgICAgICA/IFtPYmplY3QuYXNzaWduKHt9LCB0cmFja1N0YXQsIHsgdHJhY2tJZDogdHJhY2tTZW5kZXIuaWQgfSldLmNvbmNhdCh0cmFja1N0YXRzKVxuICAgICAgICAgICAgOiB0cmFja1N0YXRzO1xuICAgIH0sIFtdKTtcbn1cbi8qKlxuICogQSB7QGxpbmsgUm9vbS5TSUR9IGlzIGEgMzQtY2hhcmFjdGVyIHN0cmluZyBzdGFydGluZyB3aXRoIFwiUk1cIlxuICogdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzIGEge0BsaW5rIFJvb219LlxuICogQHR5cGUgc3RyaW5nXG4gKiBAdHlwZWRlZiBSb29tLlNJRFxuICovXG4vKipcbiAqIFRoZSBEb21pbmFudCBTcGVha2VyIGluIHRoZSB7QGxpbmsgUm9vbX0gY2hhbmdlZC4gRWl0aGVyIHRoZSBEb21pbmFudCBTcGVha2VyXG4gKiBpcyBhIG5ldyB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IG9yIHRoZSBEb21pbmFudCBTcGVha2VyIGhhcyBiZWVuIHJlc2V0IGFuZFxuICogaXMgbm93IG51bGwuXG4gKiBAcGFyYW0gez9SZW1vdGVQYXJ0aWNpcGFudH0gZG9taW5hbnRTcGVha2VyIC0gVGhlIERvbWluYW50IFNwZWFrZXIgaW4gdGhlXG4gKiAgIHtAbGluayBSb29tfSwgaWYgYW55XG4gKiBAZXZlbnQgUm9vbSNkb21pbmFudFNwZWFrZXJDaGFuZ2VkXG4gKi9cbi8qKlxuICogWW91ciB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gd2FzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSB7QGxpbmsgUm9vbX0gYW5kIGFsbFxuICogb3RoZXIge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fXMuXG4gKiBAcGFyYW0ge1Jvb219IHJvb20gLSBUaGUge0BsaW5rIFJvb219IHlvdXJcbiAqICAge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IHdhcyBkaXNjb25uZWN0ZWQgZnJvbVxuICogQHBhcmFtIHs/VHdpbGlvRXJyb3J9IGVycm9yIC0gUHJlc2VudCB3aGVuIHRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gZ290XG4gKiAgIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSB7QGxpbmsgUm9vbX0gdW5leHBlY3RlZGx5XG4gKiBAZXZlbnQgUm9vbSNkaXNjb25uZWN0ZWRcbiAqIEBleGFtcGxlXG4gKiBteVJvb20ub24oJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uKHJvb20sIGVycm9yKSB7XG4gKiAgIGlmIChlcnJvcikge1xuICogICAgIGNvbnNvbGUubG9nKCdVbmV4cGVjdGVkbHkgZGlzY29ubmVjdGVkOicsIGVycm9yKTtcbiAqICAgfVxuICogICBteVJvb20ubG9jYWxQYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICogICAgIHRyYWNrLnN0b3AoKTtcbiAqICAgICB0cmFjay5kZXRhY2goKTtcbiAqICAgfSk7XG4gKiB9KTtcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gam9pbmVkIHRoZSB7QGxpbmsgUm9vbX0uIEluIExhcmdlIEdyb3VwIFJvb21zIChNYXhpbXVtXG4gKiBQYXJ0aWNpcGFudHMgZ3JlYXRlciB0aGFuIDUwKSwgdGhpcyBldmVudCBpcyByYWlzZWQgb25seSB3aGVuIGEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fVxuICogcHVibGlzaGVzIGF0IGxlYXN0IG9uZSB7QGxpbmsgTG9jYWxUcmFja30uXG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHdobyBqb2luZWRcbiAqIEBldmVudCBSb29tI3BhcnRpY2lwYW50Q29ubmVjdGVkXG4gKiBAZXhhbXBsZVxuICogbXlSb29tLm9uKCdwYXJ0aWNpcGFudENvbm5lY3RlZCcsIGZ1bmN0aW9uKHBhcnRpY2lwYW50KSB7XG4gKiAgIGNvbnNvbGUubG9nKHBhcnRpY2lwYW50LmlkZW50aXR5ICsgJyBqb2luZWQgdGhlIFJvb20nKTtcbiAqIH0pO1xuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSBsZWZ0IHRoZSB7QGxpbmsgUm9vbX0uIEluIExhcmdlIEdyb3VwIFJvb21zIChNYXhpbXVtXG4gKiBQYXJ0aWNpcGFudHMgZ3JlYXRlciB0aGFuIDUwKSwgdGhpcyBldmVudCBpcyByYWlzZWQgb25seSB3aGVuIGEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fVxuICogdW5wdWJsaXNoZXMgYWxsIGl0cyB7QGxpbmsgTG9jYWxUcmFja31zLlxuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudH0gcGFydGljaXBhbnQgLSBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB3aG8gbGVmdFxuICogQGV2ZW50IFJvb20jcGFydGljaXBhbnREaXNjb25uZWN0ZWRcbiAqIEBleGFtcGxlXG4gKiBteVJvb20ub24oJ3BhcnRpY2lwYW50RGlzY29ubmVjdGVkJywgZnVuY3Rpb24ocGFydGljaXBhbnQpIHtcbiAqICAgY29uc29sZS5sb2cocGFydGljaXBhbnQuaWRlbnRpdHkgKyAnIGxlZnQgdGhlIFJvb20nKTtcbiAqICAgcGFydGljaXBhbnQudHJhY2tzLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAqICAgICB0cmFjay5kZXRhY2goKS5mb3JFYWNoKGZ1bmN0aW9uKG1lZGlhRWxlbWVudCkge1xuICogICAgICAgbWVkaWFFbGVtZW50LnJlbW92ZSgpO1xuICogICAgIH0pO1xuICogICB9KTtcbiAqIH0pO1xuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSBoYXMgcmVjb25uZWN0ZWQgdG8gdGhlIHtAbGluayBSb29tfSBhZnRlciBhIHNpZ25hbGluZyBjb25uZWN0aW9uIGRpc3J1cHRpb24uXG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHRoYXQgaGFzIHJlY29ubmVjdGVkLlxuICogQGV2ZW50IFJvb20jcGFydGljaXBhbnRSZWNvbm5lY3RlZFxuICogQGV4YW1wbGVcbiAqIG15Um9vbS5vbigncGFydGljaXBhbnRSZWNvbm5lY3RlZCcsIHBhcnRpY2lwYW50ID0+IHtcbiAqICAgY29uc29sZS5sb2cocGFydGljaXBhbnQuaWRlbnRpdHkgKyAnIHJlY29ubmVjdGVkIHRvIHRoZSBSb29tJyk7XG4gKiB9KTtcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gaXMgcmVjb25uZWN0aW5nIHRvIHRoZSB7QGxpbmsgUm9vbX0gYWZ0ZXIgYSBzaWduYWxpbmcgY29ubmVjdGlvbiBkaXNydXB0aW9uLlxuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudH0gcGFydGljaXBhbnQgLSBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB0aGF0IGlzIHJlY29ubmVjdGluZy5cbiAqIEBldmVudCBSb29tI3BhcnRpY2lwYW50UmVjb25uZWN0aW5nXG4gKiBAZXhhbXBsZVxuICogbXlSb29tLm9uKCdwYXJ0aWNpcGFudFJlY29ubmVjdGluZycsIHBhcnRpY2lwYW50ID0+IHtcbiAqICAgY29uc29sZS5sb2cocGFydGljaXBhbnQuaWRlbnRpdHkgKyAnIGlzIHJlY29ubmVjdGluZyB0byB0aGUgUm9vbScpO1xuICogfSk7XG4gKi9cbi8qKlxuICogWW91ciBhcHBsaWNhdGlvbiBzdWNjZXNzZnVsbHkgcmVjb25uZWN0ZWQgdG8gdGhlIHtAbGluayBSb29tfS4gV2hlbiB0aGlzXG4gKiBldmVudCBpcyBlbWl0dGVkLCB0aGUge0BsaW5rIFJvb219IGlzIGluIHN0YXRlIFwiY29ubmVjdGVkXCIuXG4gKiBAZXZlbnQgUm9vbSNyZWNvbm5lY3RlZFxuICogQGV4YW1wbGVcbiAqIG15Um9vbS5vbigncmVjb25uZWN0ZWQnLCAoKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdSZWNvbm5lY3RlZCEnKTtcbiAqIH0pO1xuICovXG4vKipcbiAqIFlvdXIgYXBwbGljYXRpb24gaXMgcmVjb25uZWN0aW5nIHRvIHRoZSB7QGxpbmsgUm9vbX0uIFRoaXMgaGFwcGVucyB3aGVuIHRoZXJlXG4gKiBpcyBhIGRpc3J1cHRpb24gaW4geW91ciBzaWduYWxpbmcgY29ubmVjdGlvbiBhbmQvb3IgeW91ciBtZWRpYSBjb25uZWN0aW9uLiBXaGVuXG4gKiB0aGlzIGV2ZW50IGlzIGVtaXR0ZWQsIHRoZSB7QGxpbmsgUm9vbX0gaXMgaW4gc3RhdGUgXCJyZWNvbm5lY3RpbmdcIi4gSWYgcmVjb25uZWN0aW5nXG4gKiBzdWNjZWVkcywgdGhlIHtAbGluayBSb29tfSB3aWxsIGVtaXQgYSBcInJlY29ubmVjdGVkXCIgZXZlbnQuXG4gKiBAcGFyYW0ge01lZGlhQ29ubmVjdGlvbkVycm9yfFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvcn0gZXJyb3IgLSBBXG4gKiAgIHtAbGluayBNZWRpYUNvbm5lY3Rpb25FcnJvcn0gaWYgeW91ciBhcHBsaWNhdGlvbiBpcyByZWNvbm5lY3RpbmcgZHVlIHRvIGFcbiAqICAgZGlzcnVwdGlvbiBpbiB5b3VyIG1lZGlhIGNvbm5lY3Rpb24sIG9yIGEge0BsaW5rIFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvcn1cbiAqICAgaWYgeW91ciBhcHBsaWNhdGlvbiBpcyByZWNvbm5lY3RpbmcgZHVlIHRvIGEgZGlzcnVwdGlvbiBpbiB5b3VyIHNpZ25hbGluZyBjb25uZWN0aW9uXG4gKiBAZXZlbnQgUm9vbSNyZWNvbm5lY3RpbmdcbiAqIEBleGFtcGxlXG4gKiBteVJvb20ub24oJ3JlY29ubmVjdGluZycsIGVycm9yID0+IHtcbiAqICAgaWYgKGVycm9yLmNvZGUgPT09IDUzMDAxKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ1JlY29ubmVjdGluZyB5b3VyIHNpZ25hbGluZyBjb25uZWN0aW9uIScsIGVycm9yLm1lc3NhZ2UpO1xuICogICB9IGVsc2UgaWYgKGVycm9yLmNvZGUgPT09IDUzNDA1KSB7XG4gKiAgICAgY29uc29sZS5sb2coJ1JlY29ubmVjdGluZyB5b3VyIG1lZGlhIGNvbm5lY3Rpb24hJywgZXJyb3IubWVzc2FnZSk7XG4gKiAgIH1cbiAqIH0pO1xuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUm9vbX0gaXMgbm93IGJlaW5nIHJlY29yZGVkXG4gKiBAZXZlbnQgUm9vbSNyZWNvcmRpbmdTdGFydGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSb29tfSBpcyBubyBsb25nZXIgYmVpbmcgcmVjb3JkZWRcbiAqIEBldmVudCBSb29tI3JlY29yZGluZ1N0b3BwZWRcbiAqL1xuLyoqXG4gKiBPbmUgb2YgdGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0ncyB7QGxpbmsgVmlkZW9UcmFja30ncyBkaW1lbnNpb25zIGNoYW5nZWQuXG4gKiBAcGFyYW0ge1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB3aG9zZSBkaW1lbnNpb25zIGNoYW5nZWRcbiAqIEBwYXJhbSB7UmVtb3RlUGFydGljaXBhbnR9IHBhcnRpY2lwYW50IC0gVGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gd2hvc2VcbiAqICAge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9J3MgZGltZW5zaW9ucyBjaGFuZ2VkXG4gKiBAZXZlbnQgUm9vbSN0cmFja0RpbWVuc2lvbnNDaGFuZ2VkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyBkaXNhYmxlZCBieSBhIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gaW4gdGhlIHtAbGluayBSb29tfS5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb24gLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259IHRoYXQgcmVwcmVzZW50cyBkaXNhYmxlZCB7QGxpbmsgUmVtb3RlVHJhY2t9XG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHdob1xuICogICBkaXNhYmxlZCB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfVxuICogQGV2ZW50IFJvb20jdHJhY2tEaXNhYmxlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgZW5hYmxlZCBieSBhIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gaW4gdGhlIHtAbGluayBSb29tfS5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb24gLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259IHRoYXQgcmVwcmVzZW50cyBlbmFibGVkIHtAbGluayBSZW1vdGVUcmFja31cbiAqIEBwYXJhbSB7UmVtb3RlUGFydGljaXBhbnR9IHBhcnRpY2lwYW50IC0gVGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gd2hvXG4gKiAgIGVuYWJsZWQgdGhlIHtAbGluayBSZW1vdGVUcmFja31cbiAqIEBldmVudCBSb29tI3RyYWNrRW5hYmxlZFxuICovXG4vKipcbiAqIEEgbWVzc2FnZSB3YXMgcmVjZWl2ZWQgb3ZlciBvbmUgb2YgdGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0nc1xuICoge0BsaW5rIFJlbW90ZURhdGFUcmFja30ncy5cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5QnVmZmVyfSBkYXRhXG4gKiBAcGFyYW0ge1JlbW90ZURhdGFUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZURhdGFUcmFja30gb3ZlciB3aGljaCB0aGVcbiAqICAgbWVzc2FnZSB3YXMgcmVjZWl2ZWRcbiAqIEBwYXJhbSB7UmVtb3RlUGFydGljaXBhbnR9IHBhcnRpY2lwYW50IC0gVGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gd2hvc2VcbiAqICAge0BsaW5rIFJlbW90ZURhdGFUcmFja30gcmVjZWl2ZWQgdGhlIG1lc3NhZ2VcbiAqIEBldmVudCBSb29tI3RyYWNrTWVzc2FnZVxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgcHVibGlzaGVkIGJ5IGEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSBhZnRlclxuICogY29ubmVjdGluZyB0byB0aGUge0BsaW5rIFJvb219LiBUaGlzIGV2ZW50IGlzIG5vdCBlbWl0dGVkIGZvclxuICoge0BsaW5rIFJlbW90ZVRyYWNrfXMgdGhhdCB3ZXJlIHB1Ymxpc2hlZCB3aGlsZSB0aGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fVxuICogd2FzIGNvbm5lY3RpbmcgdG8gdGhlIHtAbGluayBSb29tfS5cbiAqIEBldmVudCBSb29tI3RyYWNrUHVibGlzaGVkXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICogICB3aGljaCByZXByZXNlbnRzIHRoZSBwdWJsaXNoZWQge0BsaW5rIFJlbW90ZVRyYWNrfVxuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudH0gcGFydGljaXBhbnQgLSBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB3aG9cbiAqICAgcHVibGlzaGVkIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9XG4gKiBAZXhhbXBsZVxuICogZnVuY3Rpb24gdHJhY2tQdWJsaXNoZWQocHVibGljYXRpb24sIHBhcnRpY2lwYW50KSB7XG4gKiAgIGNvbnNvbGUubG9nKGBSZW1vdGVQYXJ0aWNpcGFudCAke3BhcnRpY2lwYW50LnNpZH0gcHVibGlzaGVkIFRyYWNrICR7cHVibGljYXRpb24udHJhY2tTaWR9YCk7XG4gKiB9XG4gKlxuICogLy8gSGFuZGxlIFJlbW90ZVRyYWNrcyBwdWJsaXNoZWQgYWZ0ZXIgY29ubmVjdGluZyB0byB0aGUgUm9vbS5cbiAqIHJvb20ub24oJ3RyYWNrUHVibGlzaGVkJywgdHJhY2tQdWJsaXNoZWQpO1xuICpcbiAqIHJvb20ub24oJ3BhcnRpY2lwYW50Q29ubmVjdGVkJywgcGFydGljaXBhbnQgPT4ge1xuICogICAvLyBIYW5kbGUgUmVtb3RlVHJhY2tzIHB1Ymxpc2hlZCB3aGlsZSBjb25uZWN0aW5nIHRvIHRoZSBSb29tLlxuICogICBwYXJ0aWNpcGFudC50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHRyYWNrUHVibGlzaGVkKHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCkpO1xuICogfSk7XG4gKi9cbi8qKlxuICogT25lIG9mIGEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSdzIHtAbGluayBSZW1vdGVUcmFja31zIGluIHRoZSB7QGxpbmsgUm9vbX0gc3RhcnRlZC5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCBzdGFydGVkXG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHdob3NlXG4gKiAgIHtAbGluayBSZW1vdGVUcmFja30gc3RhcnRlZFxuICogQGV2ZW50IFJvb20jdHJhY2tTdGFydGVkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgc3Vic2NyaWJlZCB0by5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCB3YXMgc3Vic2NyaWJlZFxuICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvbiAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn1cbiAqICAgZm9yIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHN1YnNjcmliZWQgdG9cbiAqIEBwYXJhbSB7UmVtb3RlUGFydGljaXBhbnR9IHBhcnRpY2lwYW50IC0gVGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gd2hvc2VcbiAqICAge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgc3Vic2NyaWJlZFxuICogQGV2ZW50IFJvb20jdHJhY2tTdWJzY3JpYmVkXG4gKiBAZXhhbXBsZVxuICogcm9vbS5vbigndHJhY2tTdWJzY3JpYmVkJywgZnVuY3Rpb24odHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCkge1xuICogICB2YXIgcGFydGljaXBhbnRWaWV3ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcnRpY2lwYW50LXZpZXctJyArIHBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAqICAgcGFydGljaXBhbnRWaWV3LmFwcGVuZENoaWxkKHRyYWNrLmF0dGFjaCgpKTtcbiAqIH0pO1xuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSdzIHtAbGluayBSZW1vdGVUcmFja30gd2FzIHN3aXRjaGVkIG9mZi4gVGhlIG1lZGlhIHNlcnZlciBzdG9wc1xuICogc2VuZGluZyBtZWRpYSBvciBkYXRhIGZvciB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSB1bnRpbCBpdCBpcyBzd2l0Y2hlZCBiYWNrIG9uLiBKdXN0IGJlZm9yZVxuICogdGhlIGV2ZW50IGlzIHJhaXNlZCwgPGNvZGU+aXNTd2l0Y2hlZE9mZjwvY29kZT4gaXMgc2V0IHRvIDxjb2RlPnRydWU8L2NvZGU+IGFuZCA8Y29kZT5zd2l0Y2hPZmZSZWFzb248L2NvZGU+XG4gKiBpcyBzZXQgdG8gYSB7QGxpbmsgVHJhY2tTd2l0Y2hPZmZSZWFzb259LiBBbHNvLCBpZiB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSByZWNlaXZlcyBlaXRoZXIgYXVkaW8gb3IgdmlkZW9cbiAqIG1lZGlhLCB0aGUgPGNvZGU+bWVkaWFTdHJlYW1UcmFjazwvY29kZT4gcHJvcGVydHkgaXMgc2V0IHRvIDxjb2RlPm51bGw8L2NvZGU+LlxuICogQHBhcmFtIHtSZW1vdGVUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrfSB0aGF0IHdhcyBzd2l0Y2hlZCBvZmZcbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb24gLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259XG4gKiAgIGZvciB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSB0aGF0IHdhcyBzdWJzY3JpYmVkIHRvXG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHdob3NlXG4gKiAgIHtAbGluayBSZW1vdGVUcmFja30gd2FzIHN3aXRjaGVkIG9mZlxuICogQHBhcmFtIHtUcmFja1N3aXRjaE9mZlJlYXNvbn0gc3dpdGNoT2ZmUmVhc29uIC0gVGhlIHJlYXNvbiB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfVxuICogICB3YXMgc3dpdGNoZWQgb2ZmXG4gKiBAZXZlbnQgUm9vbSN0cmFja1N3aXRjaGVkT2ZmXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgc3dpdGNoZWQgb24uIFRoZSBtZWRpYSBzZXJ2ZXIgc3RhcnRzXG4gKiBzZW5kaW5nIG1lZGlhIGZvciB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSB1bnRpbCBpdCBpcyBzd2l0Y2hlZCBvZmYuIEp1c3QgYmVmb3JlIHRoZSBldmVudCBpcyByYWlzZWQsXG4gKiA8Y29kZT5pc1N3aXRjaGVkT2ZmPC9jb2RlPiBpcyBzZXQgdG8gPGNvZGU+ZmFsc2U8L2NvZGU+IGFuZCA8Y29kZT5zd2l0Y2hPZmZSZWFzb248L2NvZGU+XG4gKiBpcyBzZXQgdG8gPGNvZGU+bnVsbDwvY29kZT4uIEFsc28sIGlmIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHJlY2VpdmVzIGVpdGhlciBhdWRpbyBvciB2aWRlbyBtZWRpYSxcbiAqIHRoZSA8Y29kZT5tZWRpYVN0cmVhbVRyYWNrPC9jb2RlPiBwcm9wZXJ0eSBpcyBzZXQgdG8gYSBNZWRpYVN0cmVhbVRyYWNrIHRoYXQgaXMgdGhlIHNvdXJjZSBvZiB0aGVcbiAqIHtAbGluayBSZW1vdGVUcmFja30ncyBtZWRpYS5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCB3YXMgc3dpdGNoZWQgb25cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb24gLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259XG4gKiAgIGZvciB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSB0aGF0IHdhcyBzdWJzY3JpYmVkIHRvXG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHdob3NlXG4gKiAgIHtAbGluayBSZW1vdGVUcmFja30gd2FzIHN3aXRjaGVkIG9uXG4gKiBAZXZlbnQgUm9vbSN0cmFja1N3aXRjaGVkT25cbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0ncyB7QGxpbmsgUmVtb3RlVHJhY2t9IGNvdWxkIG5vdCBiZSBzdWJzY3JpYmVkIHRvLlxuICogQHBhcmFtIHtUd2lsaW9FcnJvcn0gZXJyb3IgLSBUaGUgcmVhc29uIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IGNvdWxkIG5vdCBiZVxuICogICBzdWJzY3JpYmVkIHRvXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlXG4gKiAgIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBmb3IgdGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCBjb3VsZCBub3RcbiAqICAgYmUgc3Vic2NyaWJlZCB0b1xuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudH0gcGFydGljaXBhbnQgLSBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB3aG9zZVxuICogICB7QGxpbmsgUmVtb3RlVHJhY2t9IGNvdWxkIG5vdCBiZSBzdWJzY3JpYmVkIHRvXG4gKiBAZXZlbnQgUm9vbSN0cmFja1N1YnNjcmlwdGlvbkZhaWxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9J3MgcHVibGlzaCB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IHdhcyBjaGFuZ2VkIGJ5IHRoZVxuICoge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fS5cbiAqIEBwYXJhbSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5IC0gdGhlIHtAbGluayBSZW1vdGVUcmFja30ncyBuZXcgcHVibGlzaFxuICogICB7QGxpbmsgVHJhY2suUHJpb3JpdHl9O1xuICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvbiAtIFRoZVxuICogICB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gZm9yIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgY2hhbmdlZCBwcmlvcml0eVxuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudH0gcGFydGljaXBhbnQgLSBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB3aG9zZVxuICogICB7QGxpbmsgUmVtb3RlVHJhY2t9IGNoYW5nZWQgcHJpb3JpdHlcbiAqIEBldmVudCBSb29tI3RyYWNrUHVibGlzaFByaW9yaXR5Q2hhbmdlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgdW5wdWJsaXNoZWQgYnkgYSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHRvIHRoZSB7QGxpbmsgUm9vbX0uXG4gKiBAZXZlbnQgUm9vbSN0cmFja1VucHVibGlzaGVkXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICogICB3aGljaCByZXByZXNlbnRzIHRoZSB1bnB1Ymxpc2hlZCB7QGxpbmsgUmVtb3RlVHJhY2t9XG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHdob1xuICogICB1bnB1Ymxpc2hlZCB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfVxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSdzIHtAbGluayBSZW1vdGVUcmFja30gd2FzIHVuc3Vic2NyaWJlZCBmcm9tLlxuICogQHBhcmFtIHtSZW1vdGVUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrfSB0aGF0IHdhcyB1bnN1YnNjcmliZWRcbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb24gLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259XG4gKiAgIGZvciB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSB0aGF0IHdhcyB1bnN1YnNjcmliZWQgZnJvbVxuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudH0gcGFydGljaXBhbnQgLSBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB3aG9zZVxuICogICB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyB1bnN1YnNjcmliZWRcbiAqIEBldmVudCBSb29tI3RyYWNrVW5zdWJzY3JpYmVkXG4gKiBAZXhhbXBsZVxuICogcm9vbS5vbigndHJhY2tVbnN1YnNjcmliZWQnLCBmdW5jdGlvbih0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KSB7XG4gKiAgIHRyYWNrLmRldGFjaCgpLmZvckVhY2goZnVuY3Rpb24obWVkaWFFbGVtZW50KSB7XG4gKiAgICAgbWVkaWFFbGVtZW50LnJlbW92ZSgpO1xuICogICB9KTtcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBjb25uZWN0UGFydGljaXBhbnQocm9vbSwgcGFydGljaXBhbnRTaWduYWxpbmcpIHtcbiAgICB2YXIgbG9nID0gcm9vbS5fbG9nLCBjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgPSByb29tLl9jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wsIGNvbnRlbnRQcmVmZXJlbmNlc01vZGUgPSByb29tLl9jb250ZW50UHJlZmVyZW5jZXNNb2RlO1xuICAgIHZhciBwYXJ0aWNpcGFudCA9IG5ldyBSZW1vdGVQYXJ0aWNpcGFudChwYXJ0aWNpcGFudFNpZ25hbGluZywgeyBsb2c6IGxvZywgY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sOiBjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wsIGNvbnRlbnRQcmVmZXJlbmNlc01vZGU6IGNvbnRlbnRQcmVmZXJlbmNlc01vZGUgfSk7XG4gICAgbG9nLmluZm8oJ0EgbmV3IFJlbW90ZVBhcnRpY2lwYW50IGNvbm5lY3RlZDonLCBwYXJ0aWNpcGFudCk7XG4gICAgcm9vbS5fcGFydGljaXBhbnRzLnNldChwYXJ0aWNpcGFudC5zaWQsIHBhcnRpY2lwYW50KTtcbiAgICByb29tLmVtaXQoJ3BhcnRpY2lwYW50Q29ubmVjdGVkJywgcGFydGljaXBhbnQpO1xuICAgIC8vIFJlZW1pdCBUcmFjayBhbmQgUmVtb3RlUGFydGljaXBhbnQgZXZlbnRzLlxuICAgIHZhciBldmVudExpc3RlbmVycyA9IFtcbiAgICAgICAgWydyZWNvbm5lY3RlZCcsICdwYXJ0aWNpcGFudFJlY29ubmVjdGVkJ10sXG4gICAgICAgIFsncmVjb25uZWN0aW5nJywgJ3BhcnRpY2lwYW50UmVjb25uZWN0aW5nJ10sXG4gICAgICAgICd0cmFja0RpbWVuc2lvbnNDaGFuZ2VkJyxcbiAgICAgICAgJ3RyYWNrRGlzYWJsZWQnLFxuICAgICAgICAndHJhY2tFbmFibGVkJyxcbiAgICAgICAgJ3RyYWNrTWVzc2FnZScsXG4gICAgICAgICd0cmFja1B1Ymxpc2hlZCcsXG4gICAgICAgICd0cmFja1B1Ymxpc2hQcmlvcml0eUNoYW5nZWQnLFxuICAgICAgICAndHJhY2tTdGFydGVkJyxcbiAgICAgICAgJ3RyYWNrU3Vic2NyaWJlZCcsXG4gICAgICAgICd0cmFja1N1YnNjcmlwdGlvbkZhaWxlZCcsXG4gICAgICAgICd0cmFja1N3aXRjaGVkT2ZmJyxcbiAgICAgICAgJ3RyYWNrU3dpdGNoZWRPbicsXG4gICAgICAgICd0cmFja1VucHVibGlzaGVkJyxcbiAgICAgICAgJ3RyYWNrVW5zdWJzY3JpYmVkJ1xuICAgIF0ubWFwKGZ1bmN0aW9uIChldmVudE9yUGFpcikge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoQXJyYXkuaXNBcnJheShldmVudE9yUGFpcilcbiAgICAgICAgICAgID8gZXZlbnRPclBhaXJcbiAgICAgICAgICAgIDogW2V2ZW50T3JQYWlyLCBldmVudE9yUGFpcl0sIDIpLCBldmVudCA9IF9hWzBdLCBwYXJ0aWNpcGFudEV2ZW50ID0gX2FbMV07XG4gICAgICAgIGZ1bmN0aW9uIHJlZW1pdCgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KHBhcnRpY2lwYW50RXZlbnQpO1xuICAgICAgICAgICAgaWYgKHBhcnRpY2lwYW50RXZlbnQgPT09ICd0cmFja1N3aXRjaGVkT2ZmJykge1xuICAgICAgICAgICAgICAgIHZhciBzd2l0Y2hPZmZSZWFzb24gPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChwYXJ0aWNpcGFudCwgc3dpdGNoT2ZmUmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChwYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb29tLmVtaXQuYXBwbHkocm9vbSwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFydGljaXBhbnQub24oZXZlbnQsIHJlZW1pdCk7XG4gICAgICAgIHJldHVybiBbZXZlbnQsIHJlZW1pdF07XG4gICAgfSk7XG4gICAgcGFydGljaXBhbnQub25jZSgnZGlzY29ubmVjdGVkJywgZnVuY3Rpb24gcGFydGljaXBhbnREaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHZhciBkb21pbmFudFNwZWFrZXIgPSByb29tLmRvbWluYW50U3BlYWtlcjtcbiAgICAgICAgbG9nLmluZm8oJ1JlbW90ZVBhcnRpY2lwYW50IGRpc2Nvbm5lY3RlZDonLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIHJvb20uX3BhcnRpY2lwYW50cy5kZWxldGUocGFydGljaXBhbnQuc2lkKTtcbiAgICAgICAgZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgcGFydGljaXBhbnQucmVtb3ZlTGlzdGVuZXIoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByb29tLmVtaXQoJ3BhcnRpY2lwYW50RGlzY29ubmVjdGVkJywgcGFydGljaXBhbnQpO1xuICAgICAgICBpZiAocGFydGljaXBhbnQgPT09IGRvbWluYW50U3BlYWtlcikge1xuICAgICAgICAgICAgcm9vbS5lbWl0KCdkb21pbmFudFNwZWFrZXJDaGFuZ2VkJywgcm9vbS5kb21pbmFudFNwZWFrZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVSZWNvcmRpbmdFdmVudHMocm9vbSwgcmVjb3JkaW5nKSB7XG4gICAgcmVjb3JkaW5nLm9uKCd1cGRhdGVkJywgZnVuY3Rpb24gdXBkYXRlZCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ZWQgPSByZWNvcmRpbmcuaXNFbmFibGVkO1xuICAgICAgICByb29tLl9sb2cuaW5mbyhcIlJlY29yZGluZyBcIiArIChzdGFydGVkID8gJ3N0YXJ0ZWQnIDogJ3N0b3BwZWQnKSk7XG4gICAgICAgIHJvb20uZW1pdChcInJlY29yZGluZ1wiICsgKHN0YXJ0ZWQgPyAnU3RhcnRlZCcgOiAnU3RvcHBlZCcpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVNpZ25hbGluZ0V2ZW50cyhyb29tLCBzaWduYWxpbmcpIHtcbiAgICB2YXIgbG9nID0gcm9vbS5fbG9nO1xuICAgIC8vIFJlZW1pdCBSZW1vdGVQYXJ0aWNpcGFudCBldmVudHMgZnJvbSB0aGUgUm9vbVNpZ25hbGluZy5cbiAgICBsb2cuZGVidWcoJ0NyZWF0aW5nIGEgbmV3IFJlbW90ZVBhcnRpY2lwYW50IGZvciBlYWNoIFBhcnRpY2lwYW50U2lnbmFsaW5nICdcbiAgICAgICAgKyAnaW4gdGhlIFJvb21TaWduYWxpbmcnKTtcbiAgICBzaWduYWxpbmcucGFydGljaXBhbnRzLmZvckVhY2goY29ubmVjdFBhcnRpY2lwYW50LmJpbmQobnVsbCwgcm9vbSkpO1xuICAgIGxvZy5kZWJ1ZygnU2V0dGluZyB1cCBSZW1vdGVQYXJ0aWNpcGFudCBjcmVhdGlvbiBmb3IgYWxsIHN1YnNlcXVlbnQgJ1xuICAgICAgICArICdQYXJ0aWNpcGFudFNpZ25hbGluZ3MgdGhhdCBjb25uZWN0IHRvIHRoZSBSb29tU2lnbmFsaW5nJyk7XG4gICAgc2lnbmFsaW5nLm9uKCdwYXJ0aWNpcGFudENvbm5lY3RlZCcsIGNvbm5lY3RQYXJ0aWNpcGFudC5iaW5kKG51bGwsIHJvb20pKTtcbiAgICBzaWduYWxpbmcub24oJ2RvbWluYW50U3BlYWtlckNoYW5nZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByb29tLmVtaXQoJ2RvbWluYW50U3BlYWtlckNoYW5nZWQnLCByb29tLmRvbWluYW50U3BlYWtlcik7IH0pO1xuICAgIC8vIFJlZW1pdCBzdGF0ZSB0cmFuc2l0aW9uIGV2ZW50cyBmcm9tIHRoZSBSb29tU2lnbmFsaW5nLlxuICAgIHNpZ25hbGluZy5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gc3RhdGVDaGFuZ2VkKHN0YXRlLCBlcnJvcikge1xuICAgICAgICBsb2cuaW5mbygnVHJhbnNpdGlvbmVkIHRvIHN0YXRlOicsIHN0YXRlKTtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICByb29tLnBhcnRpY2lwYW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudC5fdW5zdWJzY3JpYmVUcmFja3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByb29tLmVtaXQoc3RhdGUsIHJvb20sIGVycm9yKTtcbiAgICAgICAgICAgICAgICByb29tLmxvY2FsUGFydGljaXBhbnQudHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHB1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1YmxpY2F0aW9uLnVucHVibGlzaCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNpZ25hbGluZy5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlY29ubmVjdGluZyc6XG4gICAgICAgICAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IGBzdGF0ZUNoYW5nZWRgIGNhbiBnZXQgZW1pdHRlZCB3aXRoIFN0YXRlTWFjaGluZSBsb2NrZWQuXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHNpZ25hbCAgcHVibGljIGV2ZW50cyBzeW5jaHJvbm91c2x5IHdpdGggbG9jayBoZWxkLlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gcm9vbS5lbWl0KCdyZWNvbm5lY3RpbmcnLCBlcnJvcik7IH0sIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogYHN0YXRlQ2hhbmdlZGAgY2FuIGdldCBlbWl0dGVkIHdpdGggU3RhdGVNYWNoaW5lIGxvY2tlZC5cbiAgICAgICAgICAgICAgICAvLyBEbyBub3Qgc2lnbmFsICBwdWJsaWMgZXZlbnRzIHN5bmNocm9ub3VzbHkgd2l0aCBsb2NrIGhlbGQuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiByb29tLmVtaXQoJ3JlY29ubmVjdGVkJyk7IH0sIDApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IFJvb207XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb29tLmpzLm1hcCIsIi8qIGVzbGludCBjb25zaXN0ZW50LXJldHVybjowICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFBhcnRpY2lwYW50U2lnbmFsaW5nID0gcmVxdWlyZSgnLi9wYXJ0aWNpcGFudCcpO1xudmFyIFJvb21TaWduYWxpbmcgPSByZXF1aXJlKCcuL3Jvb20nKTtcbnZhciBTdGF0ZU1hY2hpbmUgPSByZXF1aXJlKCcuLi9zdGF0ZW1hY2hpbmUnKTtcbi8qXG5TaWduYWxpbmcgU3RhdGVzXG4tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgKy0tLS0tLS0tLStcbiAgICAgICAgICAgICAgfCAgICAgICAgIHxcbiAgICAgICAgICAgICAgfCBvcGVuaW5nIHxcbiAgICAgICAgICstLS0+fCAgICAgICAgIHxcbiAgICAgICAgIHwgICAgKy0tLS0tLS0tLStcbiAgICArLS0tLS0tLS0rICAgfCAgIHwgICArLS0tLS0tK1xuICAgIHwgICAgICAgIHw8LS0rICAgKy0tPnwgICAgICB8XG4gICAgfCBjbG9zZWQgfDwtLS0tLS0tLS0tfCBvcGVuIHxcbiAgICB8ICAgICAgICB8PC0tKyAgICstLT58ICAgICAgfFxuICAgICstLS0tLS0tLSsgICB8ICAgfCAgICstLS0tLS0rXG4gICAgICAgICAgICAgICstLS0tLS0tLS0rICAgfFxuICAgICAgICAgICAgICB8ICAgICAgICAgfDwtLStcbiAgICAgICAgICAgICAgfCBjbG9zaW5nIHxcbiAgICAgICAgICAgICAgfCAgICAgICAgIHxcbiAgICAgICAgICAgICAgKy0tLS0tLS0tLStcblxuKi9cbnZhciBzdGF0ZXMgPSB7XG4gICAgY2xvc2VkOiBbXG4gICAgICAgICdvcGVuaW5nJ1xuICAgIF0sXG4gICAgb3BlbmluZzogW1xuICAgICAgICAnY2xvc2VkJyxcbiAgICAgICAgJ29wZW4nXG4gICAgXSxcbiAgICBvcGVuOiBbXG4gICAgICAgICdjbG9zZWQnLFxuICAgICAgICAnY2xvc2luZydcbiAgICBdLFxuICAgIGNsb3Npbmc6IFtcbiAgICAgICAgJ2Nsb3NlZCcsXG4gICAgICAgICdvcGVuJ1xuICAgIF1cbn07XG4vKipcbiAqIEBleHRlbmRzIFN0YXRlTWFjaGluZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gb25lIG9mIFwiY2xvc2VkXCIsIFwib3BlbmluZ1wiLCBcIm9wZW5cIiwgb3IgXCJjbG9zaW5nXCJcbiAqL1xudmFyIFNpZ25hbGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCB7QGxpbmsgU2lnbmFsaW5nfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTaWduYWxpbmcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAnY2xvc2VkJywgc3RhdGVzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIC8vIE5PVEUobXJvYmVydHMpOiBUaGlzIGlzIGEgZHVtbXkgaW1wbGVtZW50YXRpb24gc3VpdGFibGUgZm9yIHRlc3RpbmcuXG4gICAgU2lnbmFsaW5nLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbignY2xvc2luZycsIGtleSk7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbignY2xvc2VkJywga2V5KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgLy8gTk9URShtcm9iZXJ0cyk6IFRoaXMgaXMgYSBkdW1teSBpbXBsZW1lbnRhdGlvbiBzdWl0YWJsZSBmb3IgdGVzdGluZy5cbiAgICBTaWduYWxpbmcucHJvdG90eXBlLl9jb25uZWN0ID0gZnVuY3Rpb24gKGxvY2FsUGFydGljaXBhbnQsIHRva2VuLCBlbmNvZGluZ1BhcmFtZXRlcnMsIHByZWZlcnJlZENvZGVjcywgb3B0aW9ucykge1xuICAgICAgICBsb2NhbFBhcnRpY2lwYW50LmNvbm5lY3QoJ1BBMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAndGVzdCcpO1xuICAgICAgICB2YXIgc2lkID0gJ1JNMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShuZXcgUm9vbVNpZ25hbGluZyhsb2NhbFBhcnRpY2lwYW50LCBzaWQsIG9wdGlvbnMpKTtcbiAgICAgICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoKSB7IH07XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAvLyBOT1RFKG1yb2JlcnRzKTogVGhpcyBpcyBhIGR1bW15IGltcGxlbWVudGF0aW9uIHN1aXRhYmxlIGZvciB0ZXN0aW5nLlxuICAgIFNpZ25hbGluZy5wcm90b3R5cGUuX29wZW4gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbignb3BlbmluZycsIGtleSk7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbignb3BlbicsIGtleSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUge0BsaW5rIFNpZ25hbGluZ30uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dGhpcz59XG4gICAgICovXG4gICAgU2lnbmFsaW5nLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJhY2tldCgnY2xvc2UnLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF90aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2Nsb3NlKGtleSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBTaWduYWxpbmcgc3RhdGUgXFxcIlwiICsgX3RoaXMuc3RhdGUgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byBhIHtAbGluayBSb29tU2lnbmFsaW5nfS5cbiAgICAgKiBAcGFyYW0ge1BhcnRpY2lwYW50U2lnbmFsaW5nfSBsb2NhbFBhcnRpY2lwYW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gICAgICogQHBhcmFtIHtFbmNvZGluZ1BhcmFtZXRlcnNJbXBsfSBlbmNvZGluZ1BhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge1ByZWZlcnJlZENvZGVjc30gcHJlZmVycmVkQ29kZWNzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxmdW5jdGlvbigpOiBDYW5jZWxhYmxlUHJvbWlzZTxSb29tU2lnbmFsaW5nPj59XG4gICAgICovXG4gICAgU2lnbmFsaW5nLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKGxvY2FsUGFydGljaXBhbnQsIHRva2VuLCBlbmNvZGluZ1BhcmFtZXRlcnMsIHByZWZlcnJlZENvZGVjcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmJyYWNrZXQoJ2Nvbm5lY3QnLCBmdW5jdGlvbiB0cmFuc2l0aW9uKGtleSkge1xuICAgICAgICAgICAgc3dpdGNoIChzZWxmLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29wZW4oa2V5KS50aGVuKHRyYW5zaXRpb24uYmluZChudWxsLCBrZXkpKTtcbiAgICAgICAgICAgICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URShtcm9iZXJ0cyk6IFdlIGRvbid0IG5lZWQgdG8gaG9sZCB0aGUgbG9jayBpbiBfY29ubmVjdC4gSW5zdGVhZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBuZWVkIHRvIGVuc3VyZSB0aGUgU2lnbmFsaW5nIHJlbWFpbnMgb3Blbi5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWxlYXNlTG9ja0NvbXBsZXRlbHkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2Nvbm5lY3QobG9jYWxQYXJ0aWNpcGFudCwgdG9rZW4sIGVuY29kaW5nUGFyYW1ldGVycywgcHJlZmVycmVkQ29kZWNzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFNpZ25hbGluZyBzdGF0ZSBcXFwiXCIgKyBzZWxmLnN0YXRlICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGxvY2FsIHtAbGluayBQYXJ0aWNpcGFudFNpZ25hbGluZ30uXG4gICAgICogQHJldHVybnMge1BhcnRpY2lwYW50U2lnbmFsaW5nfVxuICAgICAqL1xuICAgIFNpZ25hbGluZy5wcm90b3R5cGUuY3JlYXRlTG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFNpZ25hbGluZygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUge0BsaW5rIFNpZ25hbGluZ30uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dGhpcz59XG4gICAgICovXG4gICAgU2lnbmFsaW5nLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5icmFja2V0KCdvcGVuJywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgc3dpdGNoIChfdGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fb3BlbihrZXkpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBTaWduYWxpbmcgc3RhdGUgXFxcIlwiICsgX3RoaXMuc3RhdGUgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFNpZ25hbGluZztcbn0oU3RhdGVNYWNoaW5lKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hbGluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgUGFydGljaXBhbnRTaWduYWxpbmcgPSByZXF1aXJlKCcuL3BhcnRpY2lwYW50Jyk7XG52YXIgTG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMb2NhbFBhcnRpY2lwYW50U2lnbmFsaW5nKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX3B1YmxpY2F0aW9uc1RvVHJhY2tTZW5kZXJzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90cmFja1NlbmRlcnNUb1B1YmxpY2F0aW9uczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRhVHJhY2tTZW5kZXJ8TWVkaWFUcmFja1NlbmRlcn0gdHJhY2tTZW5kZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5XG4gICAgICogQHJldHVybnMge0xvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ30gcHVibGljYXRpb25cbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50U2lnbmFsaW5nLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uICh0cmFja1NlbmRlciwgbmFtZSwgcHJpb3JpdHkpIHtcbiAgICAgICAgdmFyIHB1YmxpY2F0aW9uID0gdGhpcy5fY3JlYXRlTG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nKHRyYWNrU2VuZGVyLCBuYW1lLCBwcmlvcml0eSk7XG4gICAgICAgIHRoaXMuX3RyYWNrU2VuZGVyc1RvUHVibGljYXRpb25zLnNldCh0cmFja1NlbmRlciwgcHVibGljYXRpb24pO1xuICAgICAgICB0aGlzLl9wdWJsaWNhdGlvbnNUb1RyYWNrU2VuZGVycy5zZXQocHVibGljYXRpb24sIHRyYWNrU2VuZGVyKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5hZGRUcmFjay5jYWxsKHRoaXMsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGFUcmFja1NlbmRlcnxNZWRpYVRyYWNrU2VuZGVyfSB0cmFja1NlbmRlclxuICAgICAqIEByZXR1cm5zIHs/TG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfVxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnRTaWduYWxpbmcucHJvdG90eXBlLmdldFB1YmxpY2F0aW9uID0gZnVuY3Rpb24gKHRyYWNrU2VuZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja1NlbmRlcnNUb1B1YmxpY2F0aW9ucy5nZXQodHJhY2tTZW5kZXIpIHx8IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0xvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ30gdHJhY2tQdWJsaWNhdGlvblxuICAgICAqIEByZXR1cm5zIHs/RGF0YVRyYWNrU2VuZGVyfE1lZGlhVHJhY2tTZW5kZXJ9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZy5wcm90b3R5cGUuZ2V0U2VuZGVyID0gZnVuY3Rpb24gKHRyYWNrUHVibGljYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1YmxpY2F0aW9uc1RvVHJhY2tTZW5kZXJzLmdldCh0cmFja1B1YmxpY2F0aW9uKSB8fCBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRhVHJhY2tTZW5kZXJ8TWVkaWFUcmFja1NlbmRlcn0gdHJhY2tTZW5kZXJcbiAgICAgKiBAcmV0dXJucyB7P0xvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ31cbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50U2lnbmFsaW5nLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uICh0cmFja1NlbmRlcikge1xuICAgICAgICB2YXIgcHVibGljYXRpb24gPSB0aGlzLl90cmFja1NlbmRlcnNUb1B1YmxpY2F0aW9ucy5nZXQodHJhY2tTZW5kZXIpO1xuICAgICAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFja1NlbmRlcnNUb1B1YmxpY2F0aW9ucy5kZWxldGUodHJhY2tTZW5kZXIpO1xuICAgICAgICB0aGlzLl9wdWJsaWNhdGlvbnNUb1RyYWNrU2VuZGVycy5kZWxldGUocHVibGljYXRpb24pO1xuICAgICAgICB2YXIgZGlkRGVsZXRlID0gX3N1cGVyLnByb3RvdHlwZS5yZW1vdmVUcmFjay5jYWxsKHRoaXMsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgaWYgKGRpZERlbGV0ZSkge1xuICAgICAgICAgICAgcHVibGljYXRpb24uc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBMb2NhbFBhcnRpY2lwYW50U2lnbmFsaW5nO1xufShQYXJ0aWNpcGFudFNpZ25hbGluZykpO1xubW9kdWxlLmV4cG9ydHMgPSBMb2NhbFBhcnRpY2lwYW50U2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxwYXJ0aWNpcGFudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFRyYWNrU2lnbmFsaW5nID0gcmVxdWlyZSgnLi90cmFjaycpO1xuLyoqXG4gKiBBIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb259IGltcGxlbWVudGF0aW9uXG4gKiBAZXh0ZW5kcyBUcmFja1NpZ25hbGluZ1xuICogQHByb3BlcnR5IHtUcmFjay5JRH0gaWRcbiAqL1xudmFyIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9LiB7QGxpbmsgVHJhY2tTZW5kZXJzfVxuICAgICAqIGFyZSBhbHdheXMgY2xvbmVkLlxuICAgICAqIEBwYXJhbSB7RGF0YVRyYWNrU2VuZGVyfE1lZGlhVHJhY2tTZW5kZXJ9IHRyYWNrU2VuZGVyIC0gdGhlIHtAbGluayBUcmFja1NlbmRlcn1cbiAgICAgKiAgIG9mIHRoZSB7QGxpbmsgTG9jYWxUcmFja30gdG8gYmUgcHVibGlzaGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUge0BsaW5rIExvY2FsVHJhY2t9IHRvIGJlIHB1Ymxpc2hlZFxuICAgICAqIEBwYXJhbSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5IC0gaW5pdGlhbCB7QGxpbmsgVHJhY2suUHJpb3JpdHl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nKHRyYWNrU2VuZGVyLCBuYW1lLCBwcmlvcml0eSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0cmFja1NlbmRlciA9IHRyYWNrU2VuZGVyLmNsb25lKCk7XG4gICAgICAgIHZhciBlbmFibGVkID0gdHJhY2tTZW5kZXIua2luZCA9PT0gJ2RhdGEnID8gdHJ1ZSA6IHRyYWNrU2VuZGVyLnRyYWNrLmVuYWJsZWQ7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgdHJhY2tTZW5kZXIua2luZCwgZW5hYmxlZCwgcHJpb3JpdHkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNldFRyYWNrVHJhbnNjZWl2ZXIodHJhY2tTZW5kZXIpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX3VwZGF0ZWRQcmlvcml0eToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhY2tTZW5kZXIuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZy5wcm90b3R5cGUsIFwidXBkYXRlZFByaW9yaXR5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1cGRhdGVkIHtAbGluayBUcmFjay5Qcmlvcml0eX0gb2YgdGhlIHtAbGluayBMb2NhbFRyYWNrfS5cbiAgICAgICAgICogQHByb3BlcnR5IHtUcmFjay5wcmlvcml0eX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZWRQcmlvcml0eTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSAob3IgZGlzYWJsZSkgdGhlIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9IGlmIGl0IGlzIG5vdFxuICAgICAqIGFscmVhZHkgZW5hYmxlZCAob3IgZGlzYWJsZWQpLiBUaGlzIGFsc28gdXBkYXRlcyB0aGUgY2xvbmVkXG4gICAgICoge0BsaW5rIE1lZGlhVHJhY2tTZW5kZXJ9J3MgTWVkaWFTdHJlYW1UcmFja3MgYGVuYWJsZWRgIHN0YXRlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuYWJsZWQ9dHJ1ZV1cbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuICAgIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZy5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgZW5hYmxlZCA9IHR5cGVvZiBlbmFibGVkID09PSAnYm9vbGVhbicgPyBlbmFibGVkIDogdHJ1ZTtcbiAgICAgICAgdGhpcy50cmFja1RyYW5zY2VpdmVyLnRyYWNrLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5lbmFibGUuY2FsbCh0aGlzLCBlbmFibGVkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlamVjdHMgdGhlIFNJRCdzIGRlZmVycmVkIHByb21pc2Ugd2l0aCB0aGUgZ2l2ZW4gRXJyb3IuXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmcucHJvdG90eXBlLnB1Ymxpc2hGYWlsZWQgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHNldEVycm9yKHRoaXMsIGVycm9yKSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHtAbGluayBUcmFjay5Qcmlvcml0eX0gb2YgdGhlIHB1Ymxpc2hlZCB7QGxpbmsgTG9jYWxUcmFja30uXG4gICAgICogQHBhcmFtIHtUcmFjay5wcmlvcml0eX0gcHJpb3JpdHlcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmcucHJvdG90eXBlLnNldFByaW9yaXR5ID0gZnVuY3Rpb24gKHByaW9yaXR5KSB7XG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVkUHJpb3JpdHkgIT09IHByaW9yaXR5KSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVkUHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwdWJsaXNoZWQge0BsaW5rIExvY2FsVHJhY2t9J3Mge0BsaW5rIFRyYWNrLlNJRH0uXG4gICAgICogQHBhcmFtIHtUcmFjay5TSUR9IHNpZFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZy5wcm90b3R5cGUuc2V0U2lkID0gZnVuY3Rpb24gKHNpZCkge1xuICAgICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnNldFNpZC5jYWxsKHRoaXMsIHNpZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBjbG9uZWQge0BsaW5rIFRyYWNrU2VuZGVyfS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmcucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJhY2tUcmFuc2NlaXZlci5zdG9wKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nO1xufShUcmFja1NpZ25hbGluZykpO1xuLyoqXG4gKiBAcGFyYW0ge0xvY2FsVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb25cbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdXBkYXRlZFxuICovXG5mdW5jdGlvbiBzZXRFcnJvcihwdWJsaWNhdGlvbiwgZXJyb3IpIHtcbiAgICBpZiAocHVibGljYXRpb24uX3NpZCAhPT0gbnVsbCB8fCBwdWJsaWNhdGlvbi5fZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBwdWJsaWNhdGlvbi5fZXJyb3IgPSBlcnJvcjtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWx0cmFja3B1YmxpY2F0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgU3RhdGVNYWNoaW5lID0gcmVxdWlyZSgnLi4vc3RhdGVtYWNoaW5lJyk7XG52YXIgTmV0d29ya1F1YWxpdHlTdGF0cyA9IHJlcXVpcmUoJy4uL3N0YXRzL25ldHdvcmtxdWFsaXR5c3RhdHMnKTtcbi8qXG5QYXJ0aWNpcGFudFNpZ25hbGluZyBTdGF0ZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICstLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0tLS0rXG4gICAgfCAgICAgICAgICAgIHwgICAgIHwgICAgICAgICAgIHwgICAgIHwgICAgICAgICAgICAgIHxcbiAgICB8IGNvbm5lY3RpbmcgfC0tLS0+fCBjb25uZWN0ZWQgfC0tLS0+fCBkaXNjb25uZWN0ZWQgfFxuICAgIHwgICAgICAgICAgICB8ICAgICB8ICAgICAgICAgICB8ICAgICB8ICAgICAgICAgICAgICB8XG4gICAgKy0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgXiAgICAgICAgICAgICAgICAgICAgXlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB8ICArLS0tLS0tLS0tLS0tLS0rICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB8IHwtLXwgICAgICAgICAgICAgIHwgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0+fCByZWNvbm5lY3RpbmcgfC0tfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLStcbiovXG52YXIgc3RhdGVzID0ge1xuICAgIGNvbm5lY3Rpbmc6IFtcbiAgICAgICAgJ2Nvbm5lY3RlZCdcbiAgICBdLFxuICAgIGNvbm5lY3RlZDogW1xuICAgICAgICAnZGlzY29ubmVjdGVkJyxcbiAgICAgICAgJ3JlY29ubmVjdGluZydcbiAgICBdLFxuICAgIHJlY29ubmVjdGluZzogW1xuICAgICAgICAnY29ubmVjdGVkJyxcbiAgICAgICAgJ2Rpc2Nvbm5lY3RlZCdcbiAgICBdLFxuICAgIGRpc2Nvbm5lY3RlZDogW11cbn07XG4vKipcbiAqIEEge0BsaW5rIFBhcnRpY2lwYW50fSBpbXBsZW1lbnRhdGlvblxuICogQGV4dGVuZHMgU3RhdGVNYWNoaW5lXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IGlkZW50aXR5XG4gKiBAcHJvcGVydHkgez9QYXJ0aWNpcGFudC5TSUR9IHNpZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gXCJjb25uZWN0aW5nXCIsIFwiY29ubmVjdGVkXCIsIG9yIFwiZGlzY29ubmVjdGVkXCJcbiAqIEBwcm9wZXJ0eSB7TWFwPFRyYWNrLklEIHwgVHJhY2suU0lELCBUcmFja1NpZ25hbGluZz59IHRyYWNrc1xuICogQGVtaXRzIFBhcnRpY2lwYW50U2lnbmFsaW5nI25ldHdvcmtRdWFsaXR5TGV2ZWxDaGFuZ2VkXG4gKiBAZW1pdHMgUGFydGljaXBhbnRTaWduYWxpbmcjdHJhY2tBZGRlZFxuICogQGVtaXRzIFBhcnRpY2lwYW50U2lnbmFsaW5nI3RyYWNrUmVtb3ZlZFxuICovXG52YXIgUGFydGljaXBhbnRTaWduYWxpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcnRpY2lwYW50U2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBQYXJ0aWNpcGFudFNpZ25hbGluZ30uXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFydGljaXBhbnRTaWduYWxpbmcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICdjb25uZWN0aW5nJywgc3RhdGVzKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2lkZW50aXR5OiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbmV0d29ya1F1YWxpdHlMZXZlbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX25ldHdvcmtRdWFsaXR5U3RhdHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaWQ6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkZW50aXR5OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkZW50aXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFja3M6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcnRpY2lwYW50U2lnbmFsaW5nLnByb3RvdHlwZSwgXCJuZXR3b3JrUXVhbGl0eUxldmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0sIGlmIGFueS5cbiAgICAgICAgICogQHJldHVybnMgez9OZXR3b3JrUXVhbGl0eUxldmVsfSBuZXR3b3JrUXVhbGl0eUxldmVsIC0gaW5pdGlhbGx5IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcmtRdWFsaXR5TGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFydGljaXBhbnRTaWduYWxpbmcucHJvdG90eXBlLCBcIm5ldHdvcmtRdWFsaXR5U3RhdHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHtAbGluayBOZXR3b3JrUXVhbGl0eVN0YXRzfVxuICAgICAgICAgKiBAcmV0dXJucyB7P05ldHdvcmtRdWFsaXR5U3RhdHN9IG5ldHdvcmtRdWFsaXR5U3RhdHMgLSBpbml0aWFsbHkgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29ya1F1YWxpdHlTdGF0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUge0BsaW5rIFRyYWNrU2lnbmFsaW5nfSwgTWVkaWFTdHJlYW1UcmFjaywgb3JcbiAgICAgKiB7QGxpbmsgRGF0YVRyYWNrU2VuZGVyfSB0byB0aGUge0BsaW5rIFBhcnRpY2lwYW50U2lnbmFsaW5nfS5cbiAgICAgKiBAcGFyYW0ge1RyYWNrU2lnbmFsaW5nfERhdGFUcmFja1NlbmRlcnxNZWRpYVRyYWNrU2VuZGVyfSB0cmFja1xuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBmaXJlcyBQYXJ0aWNpcGFudFNpZ25hbGluZyN0cmFja0FkZGVkXG4gICAgICovXG4gICAgUGFydGljaXBhbnRTaWduYWxpbmcucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHRoaXMudHJhY2tzLnNldCh0cmFjay5pZCB8fCB0cmFjay5zaWQsIHRyYWNrKTtcbiAgICAgICAgdGhpcy5lbWl0KCd0cmFja0FkZGVkJywgdHJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgdGhlIHtAbGluayBQYXJ0aWNpcGFudFNpZ25hbGluZ30uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgUGFydGljaXBhbnRTaWduYWxpbmcucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgdGhpcy5wcmVlbXB0KCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUge0BsaW5rIFRyYWNrU2lnbmFsaW5nfSwgTWVkaWFTdHJlYW1UcmFjaywgb3JcbiAgICAgKiB7QGxpbmsgRGF0YVRyYWNrU2VuZGVyfSBmcm9tIHRoZSB7QGxpbmsgUGFydGljaXBhbnRTaWduYWxpbmd9LlxuICAgICAqIEBwYXJhbSB7VHJhY2tTaWduYWxpbmd8RGF0YVRyYWNrU2VuZGVyfE1lZGlhVHJhY2tTZW5kZXJ9IHRyYWNrXG4gICAgICogQHJldHVybnMgez9UcmFja1NpZ25hbGluZ31cbiAgICAgKiBAZmlyZXMgUGFydGljaXBhbnRTaWduYWxpbmcjdHJhY2tSZW1vdmVkXG4gICAgICovXG4gICAgUGFydGljaXBhbnRTaWduYWxpbmcucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHZhciBzaWduYWxpbmcgPSB0aGlzLnRyYWNrcy5nZXQodHJhY2suaWQgfHwgdHJhY2suc2lkKTtcbiAgICAgICAgdGhpcy50cmFja3MuZGVsZXRlKHRyYWNrLmlkIHx8IHRyYWNrLnNpZCk7XG4gICAgICAgIGlmIChzaWduYWxpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndHJhY2tSZW1vdmVkJywgdHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduYWxpbmcgfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmV0d29ya1F1YWxpdHlMZXZlbH0gbmV0d29ya1F1YWxpdHlMZXZlbFxuICAgICAqIEBwYXJhbSB7P05ldHdvcmtRdWFsaXR5TGV2ZWxzfSBbbmV0d29ya1F1YWxpdHlMZXZlbHM9bnVsbF1cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBQYXJ0aWNpcGFudFNpZ25hbGluZy5wcm90b3R5cGUuc2V0TmV0d29ya1F1YWxpdHlMZXZlbCA9IGZ1bmN0aW9uIChuZXR3b3JrUXVhbGl0eUxldmVsLCBuZXR3b3JrUXVhbGl0eUxldmVscykge1xuICAgICAgICBpZiAodGhpcy5fbmV0d29ya1F1YWxpdHlMZXZlbCAhPT0gbmV0d29ya1F1YWxpdHlMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5fbmV0d29ya1F1YWxpdHlMZXZlbCA9IG5ldHdvcmtRdWFsaXR5TGV2ZWw7XG4gICAgICAgICAgICB0aGlzLl9uZXR3b3JrUXVhbGl0eVN0YXRzID0gbmV0d29ya1F1YWxpdHlMZXZlbHNcbiAgICAgICAgICAgICAgICAmJiAobmV0d29ya1F1YWxpdHlMZXZlbHMuYXVkaW8gfHwgbmV0d29ya1F1YWxpdHlMZXZlbHMudmlkZW8pXG4gICAgICAgICAgICAgICAgPyBuZXcgTmV0d29ya1F1YWxpdHlTdGF0cyhuZXR3b3JrUXVhbGl0eUxldmVscylcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ25ldHdvcmtRdWFsaXR5TGV2ZWxDaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdGhlIHtAbGluayBQYXJ0aWNpcGFudFNpZ25hbGluZ30uXG4gICAgICogQHBhcmFtIHtQYXJ0aWNpcGFudC5TSUR9IHNpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGl0eVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFBhcnRpY2lwYW50U2lnbmFsaW5nLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHNpZCwgaWRlbnRpdHkpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdjb25uZWN0aW5nJyB8fCB0aGlzLnN0YXRlID09PSAncmVjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaWQgPSBzaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lkZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJlZW1wdCgnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9uIHRvIFwicmVjb25uZWN0aW5nXCIgc3RhdGUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgUGFydGljaXBhbnRTaWduYWxpbmcucHJvdG90eXBlLnJlY29ubmVjdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdjb25uZWN0aW5nJyB8fCB0aGlzLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgdGhpcy5wcmVlbXB0KCdyZWNvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJ0aWNpcGFudFNpZ25hbGluZztcbn0oU3RhdGVNYWNoaW5lKSk7XG4vKipcbiAqIEBldmVudCBQYXJ0aWNpcGFudFNpZ25hbGluZyNldmVudDpuZXR3b3JrUXVhbGl0eUxldmVsQ2hhbmdlZFxuICovXG4vKipcbiAqIHtAbGluayBUcmFja1NpZ25hbGluZ30gd2FzIGFkZGVkIHRvIHRoZSB7QGxpbmsgUGFydGljaXBhbnRTaWduYWxpbmd9LlxuICogQGV2ZW50IFBhcnRpY2lwYW50U2lnbmFsaW5nI3RyYWNrQWRkZWRcbiAqIEBwYXJhbSB7VHJhY2tTaWduYWxpbmd9IHRyYWNrXG4gKi9cbi8qKlxuICoge0BsaW5rIFRyYWNrU2lnbmFsaW5nfSB3YXMgcmVtb3ZlZCBmcm9tIHRoZSB7QGxpbmsgUGFydGljaXBhbnRTaWduYWxpbmd9LlxuICogQGV2ZW50IFBhcnRpY2lwYW50U2lnbmFsaW5nI3RyYWNrUmVtb3ZlZFxuICogQHBhcmFtIHtUcmFja1NpZ25hbGluZ30gdHJhY2tcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBQYXJ0aWNpcGFudFNpZ25hbGluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRpY2lwYW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuLyoqXG4gKiBSZXByZXNlbnRzIHJlY29yZGluZyBzdGF0ZVxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBpc0VuYWJsZWRcbiAqL1xudmFyIFJlY29yZGluZ1NpZ25hbGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVjb3JkaW5nU2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSZWNvcmRpbmdTaWduYWxpbmd9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlY29yZGluZ1NpZ25hbGluZygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9pc0VuYWJsZWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRW5hYmxlZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIHRoZSB7QGxpbmsgUmVjb3JkaW5nU2lnbmFsaW5nfSBpZiBpdCBpcyBub3QgYWxyZWFkeSBkaXNhYmxlZC5cbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuICAgIFJlY29yZGluZ1NpZ25hbGluZy5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlKGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSAob3IgZGlzYWJsZSkgdGhlIHtAbGluayBSZWNvcmRpbmdTaWduYWxpbmd9IGlmIGl0IGlzIG5vdCBhbHJlYWR5IGVuYWJsZWRcbiAgICAgKiAob3IgZGlzYWJsZWQpLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuYWJsZWQ9dHJ1ZV1cbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuICAgIFJlY29yZGluZ1NpZ25hbGluZy5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgZW5hYmxlZCA9IHR5cGVvZiBlbmFibGVkID09PSAnYm9vbGVhbicgPyBlbmFibGVkIDogdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkICE9PSBlbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0VuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjb3JkaW5nU2lnbmFsaW5nO1xufShFdmVudEVtaXR0ZXIpKTtcbi8qKlxuICogRW1pdHRlZCB3aGVuZXZlciB0aGUge0BsaW5rIFJlY29yZGluZ1NpZ25hbGluZ30gaXMgdXBkYXRlZFxuICogQGV2ZW50IFJlY29yZGluZ1NpZ25hbGluZyN1cGRhdGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVjb3JkaW5nU2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjb3JkaW5nLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgUGFydGljaXBhbnRTaWduYWxpbmcgPSByZXF1aXJlKCcuL3BhcnRpY2lwYW50Jyk7XG4vKipcbiAqIEEge0BsaW5rIFBhcnRpY2lwYW50fSBpbXBsZW1lbnRhdGlvblxuICogQGV4dGVuZHMgUGFydGljaXBhbnRTaWduYWxpbmdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZGVudGl0eVxuICogQHByb3BlcnR5IHtQYXJ0aWNpcGFudC5TSUR9IHNpZFxuICovXG52YXIgUmVtb3RlUGFydGljaXBhbnRTaWduYWxpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudFNpZ25hbGluZ30uXG4gICAgICogQHBhcmFtIHtQYXJ0aWNpcGFudC5TSUR9IHNpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGl0eVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nKHNpZCwgaWRlbnRpdHkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29ubmVjdChzaWQsIGlkZW50aXR5KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVtb3RlUGFydGljaXBhbnRTaWduYWxpbmc7XG59KFBhcnRpY2lwYW50U2lnbmFsaW5nKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFJlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RlcGFydGljaXBhbnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBUcmFja1NpZ25hbGluZyA9IHJlcXVpcmUoJy4vdHJhY2snKTtcbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gaW1wbGVtZW50YXRpb25cbiAqIEBleHRlbmRzIFRyYWNrU2lnbmFsaW5nXG4gKi9cbnZhciBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfS5cbiAgICAgKiBAcGFyYW0ge1RyYWNrLlNJRH0gc2lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1RyYWNrLktpbmR9IGtpbmRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRW5hYmxlZFxuICAgICAqIEBwYXJhbSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1N3aXRjaGVkT2ZmXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJzcFZlcnNpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nKHNpZCwgbmFtZSwga2luZCwgaXNFbmFibGVkLCBwcmlvcml0eSwgaXNTd2l0Y2hlZE9mZiwgcnNwVmVyc2lvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBraW5kLCBpc0VuYWJsZWQsIHByaW9yaXR5KSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2lzU3dpdGNoZWRPZmY6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaXNTd2l0Y2hlZE9mZixcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yc3BWZXJzaW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHJzcFZlcnNpb24sXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLnNldFNpZChzaWQpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nLnByb3RvdHlwZSwgXCJpc1N3aXRjaGVkT2ZmXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfSBpcyBzd2l0Y2hlZCBvZmYuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzU3dpdGNoZWRPZmY7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVtb3RlVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZy5wcm90b3R5cGUsIFwicnNwVmVyc2lvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIFJTUCB2ZXJzaW9uIG9mIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ30gb2JqZWN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yc3BWZXJzaW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nLnByb3RvdHlwZS5zdWJzY3JpYmVGYWlsZWQgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHB1Ymxpc2gge0BsaW5rIFRyYWNrLlByaW9yaXR5fS5cbiAgICAgKiBAcGFyYW0ge1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eVxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIFJlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmcucHJvdG90eXBlLnNldFByaW9yaXR5ID0gZnVuY3Rpb24gKHByaW9yaXR5KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcmlvcml0eSAhPT0gcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdHJhY2sgc3dpdGNoIG9uL29mZiBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3dpdGNoZWRPZmZcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nLnByb3RvdHlwZS5zZXRTd2l0Y2hlZE9mZiA9IGZ1bmN0aW9uIChpc1N3aXRjaGVkT2ZmKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1N3aXRjaGVkT2ZmICE9PSBpc1N3aXRjaGVkT2ZmKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1N3aXRjaGVkT2ZmID0gaXNTd2l0Y2hlZE9mZjtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmc7XG59KFRyYWNrU2lnbmFsaW5nKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFJlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdGV0cmFja3B1YmxpY2F0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgRGVmYXVsdFJlY29yZGluZ1NpZ25hbGluZyA9IHJlcXVpcmUoJy4vcmVjb3JkaW5nJyk7XG52YXIgU3RhdGVNYWNoaW5lID0gcmVxdWlyZSgnLi4vc3RhdGVtYWNoaW5lJyk7XG52YXIgRGVmYXVsdFRpbWVvdXQgPSByZXF1aXJlKCcuLi91dGlsL3RpbWVvdXQnKTtcbnZhciBidWlsZExvZ0xldmVscyA9IHJlcXVpcmUoJy4uL3V0aWwnKS5idWlsZExvZ0xldmVscztcbnZhciBERUZBVUxUX0xPR19MRVZFTCA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJykuREVGQVVMVF9MT0dfTEVWRUw7XG52YXIgTG9nID0gcmVxdWlyZSgnLi4vdXRpbC9sb2cnKTtcbnZhciBfYSA9IHJlcXVpcmUoJy4uL3V0aWwvdHdpbGlvLXZpZGVvLWVycm9ycycpLCBNZWRpYUNvbm5lY3Rpb25FcnJvciA9IF9hLk1lZGlhQ29ubmVjdGlvbkVycm9yLCBNZWRpYURUTFNUcmFuc3BvcnRGYWlsZWRFcnJvciA9IF9hLk1lZGlhRFRMU1RyYW5zcG9ydEZhaWxlZEVycm9yLCBTaWduYWxpbmdDb25uZWN0aW9uRGlzY29ubmVjdGVkRXJyb3IgPSBfYS5TaWduYWxpbmdDb25uZWN0aW9uRGlzY29ubmVjdGVkRXJyb3I7XG52YXIgbkluc3RhbmNlcyA9IDA7XG4vKlxuUm9vbVNpZ25hbGluZyBTdGF0ZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICArLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0tLS0rXG4gICAgfCAgICAgICAgICAgfCAgICAgfCAgICAgICAgICAgICAgfFxuICAgIHwgY29ubmVjdGVkIHwtLS0tPnwgZGlzY29ubmVjdGVkIHxcbiAgICB8ICAgICAgICAgICB8ICAgICB8ICAgICAgICAgICAgICB8XG4gICAgKy0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgIHwgIF4gICAgICAgICAgICAgICBeXG4gICAgICAgICAgfCAgfCAgICAgICAgICAgICAgIHxcbiAgICAgICAgICB8ICB8ICAgKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgIHwgICstLS18ICAgICAgICAgICAgICB8XG4gICAgICAgICAgfCAgICAgIHwgcmVjb25uZWN0aW5nIHxcbiAgICAgICAgICArLS0tLS0+fCAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0rXG5cbiovXG52YXIgc3RhdGVzID0ge1xuICAgIGNvbm5lY3RlZDogW1xuICAgICAgICAncmVjb25uZWN0aW5nJyxcbiAgICAgICAgJ2Rpc2Nvbm5lY3RlZCdcbiAgICBdLFxuICAgIHJlY29ubmVjdGluZzogW1xuICAgICAgICAnY29ubmVjdGVkJyxcbiAgICAgICAgJ2Rpc2Nvbm5lY3RlZCdcbiAgICBdLFxuICAgIGRpc2Nvbm5lY3RlZDogW11cbn07XG4vKipcbiAqIEEge0BsaW5rIFJvb219IGltcGxlbWVudGF0aW9uXG4gKiBAZXh0ZW5kcyBTdGF0ZU1hY2hpbmVcbiAqIEBwcm9wZXJ0eSB7UlRDUGVlckNvbm5lY3Rpb25TdGF0ZX0gY29ubmVjdGlvblN0YXRlXG4gKiBAcHJvcGVydHkgez9QYXJ0aWNpcGFudC5TSUR9IGRvbWluYW50U3BlYWtlclNpZFxuICogQHByb3BlcnR5IHtQYXJ0aWNpcGFudFNpZ25hbGluZ30gbG9jYWxQYXJ0aWNpcGFudFxuICogQHByb3BlcnR5IHtSVENJY2VDb25uZWN0aW9uU3RhdGV9IGljZUNvbm5lY3Rpb25TdGF0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7TWFwPHN0cmluZywgUmVtb3RlUGFydGljaXBhbnRTaWduYWxpbmc+fSBwYXJ0aWNpcGFudHNcbiAqIEBwcm9wZXJ0eSB7UmVjb3JkaW5nU2lnbmFsaW5nfSByZWNvcmRpbmdcbiAqIEBwcm9wZXJ0eSB7Um9vbS5TSUR9IHNpZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gXCJjb25uZWN0ZWRcIiwgXCJyZWNvbm5lY3RpbmdcIiwgb3IgXCJkaXNjb25uZWN0ZWRcIlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNpZ25hbGluZ0Nvbm5lY3Rpb25TdGF0ZSAtIFwiY29ubmVjdGVkXCIsXG4gKiAgIFwicmVjb25uZWN0aW5nXCIsIG9yIFwiZGlzY29ubmVjdGVkXCJcbiAqIEBlbWl0cyBSb29tU2lnbmFsaW5nI2Nvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcbiAqIEBlbWl0cyBSb29tU2lnbmFsaW5nI2RvbWluYW50U3BlYWtlckNoYW5nZWRcbiAqIEBlbWl0cyBSb29tU2lnbmFsaW5nI2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcbiAqIEBlbWl0cyBSb29tU2lnbmFsaW5nI3NpZ25hbGluZ0Nvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcbiAqL1xudmFyIFJvb21TaWduYWxpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21TaWduYWxpbmcsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJvb21TaWduYWxpbmd9LlxuICAgICAqIEBwYXJhbSB7UGFydGljaXBhbnRTaWduYWxpbmd9IGxvY2FsUGFydGljaXBhbnRcbiAgICAgKiBAcGFyYW0ge1Jvb20uU0lEfSBzaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gUm9vbVNpZ25hbGluZyhsb2NhbFBhcnRpY2lwYW50LCBzaWQsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgbG9nTGV2ZWw6IERFRkFVTFRfTE9HX0xFVkVMLFxuICAgICAgICAgICAgUmVjb3JkaW5nU2lnbmFsaW5nOiBEZWZhdWx0UmVjb3JkaW5nU2lnbmFsaW5nLFxuICAgICAgICAgICAgVGltZW91dDogRGVmYXVsdFRpbWVvdXRcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBsb2dMZXZlbHMgPSBidWlsZExvZ0xldmVscyhvcHRpb25zLmxvZ0xldmVsKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnY29ubmVjdGVkJywgc3RhdGVzKSB8fCB0aGlzO1xuICAgICAgICB2YXIgUmVjb3JkaW5nU2lnbmFsaW5nID0gb3B0aW9ucy5SZWNvcmRpbmdTaWduYWxpbmc7XG4gICAgICAgIHZhciBzZXNzaW9uVGltZW91dCA9IG5ldyBvcHRpb25zLlRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2Rpc2Nvbm5lY3QoX3RoaXMuX3JlY29ubmVjdGluZ0Vycm9yKTtcbiAgICAgICAgfSwgb3B0aW9ucy5zZXNzaW9uVGltZW91dCwgZmFsc2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2luc3RhbmNlSWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbkluc3RhbmNlcysrXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xvZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmxvZ1xuICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMubG9nLmNyZWF0ZUxvZygnZGVmYXVsdCcsIF90aGlzKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBMb2coJ2RlZmF1bHQnLCBfdGhpcywgbG9nTGV2ZWxzLCBvcHRpb25zLmxvZ2dlck5hbWUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21lZGlhQ29ubmVjdGlvbklzUmVjb25uZWN0aW5nOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9uc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZWNvbm5lY3RpbmdFcnJvcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3Nlc3Npb25UaW1lb3V0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHNlc3Npb25UaW1lb3V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9taW5hbnRTcGVha2VyU2lkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvY2FsUGFydGljaXBhbnQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsb2NhbFBhcnRpY2lwYW50XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJ0aWNpcGFudHM6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWNvcmRpbmc6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgUmVjb3JkaW5nU2lnbmFsaW5nKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uKCdjb25uZWN0aW9uU3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCdcbiAgICAgICAgICAgICAgICAmJiAhWydkaXNjb25uZWN0ZWQnLCAnZmFpbGVkJ10uaW5jbHVkZXMoX3RoaXMuaWNlQ29ubmVjdGlvblN0YXRlKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9kaXNjb25uZWN0KG5ldyBNZWRpYURUTFNUcmFuc3BvcnRGYWlsZWRFcnJvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uKCdpY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF5YmVVcGRhdGVTdGF0ZShfdGhpcyk7IH0pO1xuICAgICAgICBfdGhpcy5vbignc2lnbmFsaW5nQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heWJlVXBkYXRlU3RhdGUoX3RoaXMpOyB9KTtcbiAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogSW4gY2FzZSBcImljZUNvbm5lY3Rpb25TdGF0ZVwiIGlzIGFscmVhZHkgZmFpbGVkLCB1cGRhdGVcbiAgICAgICAgLy8gdGhlIFJvb21TaWduYWxpbmcgc3RhdGUuIHNldFRpbWVvdXQoKSBlbnN1cmVzIHRoYXQgdGhlIHN0YXRlIGlzIHVwZGF0ZWRcbiAgICAgICAgLy8gYWZ0ZXIgUm9vbVYyJ3MgY29uc3RydWN0b3IgaXMgZnVsbHkgZXhlY3V0ZWQsIHRoZXJlYnkgbWFraW5nIFwic2lnbmFsaW5nQ29ubmVjdGlvblN0YXRlXCJcbiAgICAgICAgLy8gYXZhaWxhYmxlIGhlcmUuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF5YmVVcGRhdGVTdGF0ZShfdGhpcyk7IH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QsIHBvc3NpYmx5IHdpdGggYW4gRXJyb3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBbZXJyb3JdXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgUm9vbVNpZ25hbGluZy5wcm90b3R5cGUuX2Rpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnByZWVtcHQoJ2Rpc2Nvbm5lY3RlZCcsIG51bGwsIFtlcnJvcl0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgUm9vbVNpZ25hbGluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltSb29tU2lnbmFsaW5nICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyBcIjogXCIgKyAodGhpcy5sb2NhbFBhcnRpY2lwYW50ID8gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCA6ICdudWxsJykgKyBcIl1cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbm5lY3Qge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nfSB0byB0aGUge0BsaW5rIFJvb21TaWduYWxpbmd9LlxuICAgICAqIEBwYXJhbSB7UmVtb3RlUGFydGljaXBhbnRTaWduYWxpbmd9IHBhcnRpY2lwYW50XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgUm9vbVNpZ25hbGluZy5wcm90b3R5cGUuY29ubmVjdFBhcnRpY2lwYW50ID0gZnVuY3Rpb24gKHBhcnRpY2lwYW50KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHBhcnRpY2lwYW50LnN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcnRpY2lwYW50cy5oYXMocGFydGljaXBhbnQuc2lkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydGljaXBhbnRzLnNldChwYXJ0aWNpcGFudC5zaWQsIHBhcnRpY2lwYW50KTtcbiAgICAgICAgcGFydGljaXBhbnQub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50LnJlbW92ZUxpc3RlbmVyKCdzdGF0ZUNoYW5nZWQnLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgICAgICAgIHNlbGYucGFydGljaXBhbnRzLmRlbGV0ZShwYXJ0aWNpcGFudC5zaWQpO1xuICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgncGFydGljaXBhbnREaXNjb25uZWN0ZWQnLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoJ3BhcnRpY2lwYW50Q29ubmVjdGVkJywgcGFydGljaXBhbnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgUm9vbVNpZ25hbGluZy5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCAob3IgdW5zZXQpIHRoZSBEb21pbmFudCBTcGVha2VyLlxuICAgICAqIEBwYXJhbSB7P1BhcnRpY2lwYW50LlNJRH0gZG9taW5hbnRTcGVha2VyU2lkXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgUm9vbVNpZ25hbGluZy5wcm90b3R5cGUuc2V0RG9taW5hbnRTcGVha2VyID0gZnVuY3Rpb24gKGRvbWluYW50U3BlYWtlclNpZCkge1xuICAgICAgICB0aGlzLmRvbWluYW50U3BlYWtlclNpZCA9IGRvbWluYW50U3BlYWtlclNpZDtcbiAgICAgICAgdGhpcy5lbWl0KCdkb21pbmFudFNwZWFrZXJDaGFuZ2VkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gUm9vbVNpZ25hbGluZztcbn0oU3RhdGVNYWNoaW5lKSk7XG4vKipcbiAqIEBldmVudCBSb29tU2lnbmFsaW5nI2V2ZW50OmNvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcbiAqL1xuLyoqXG4gKiBAZXZlbnQgUm9vbVNpZ25hbGluZyNldmVudDpkb21pbmFudFNwZWFrZXJDaGFuZ2VkXG4gKi9cbi8qKlxuICoge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nfSBjb25uZWN0ZWQgdG8gdGhlIHtAbGluayBSb29tU2lnbmFsaW5nfS5cbiAqIEBldmVudCBSb29tU2lnbmFsaW5nI2V2ZW50OnBhcnRpY2lwYW50Q29ubmVjdGVkXG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nfSBwYXJ0aWNpcGFudFNpZ25hbGluZ1xuICovXG4vKipcbiAqIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudFNpZ25hbGluZ30gZGlzY29ubmVjdGVkIGZyb20gdGhlIHtAbGluayBSb29tU2lnbmFsaW5nfS5cbiAqIEBldmVudCBSb29tU2lnbmFsaW5nI2V2ZW50OnBhcnRpY2lwYW50RGlzY29ubmVjdGVkXG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nfSBwYXJ0aWNpcGFudFNpZ25hbGluZ1xuICovXG4vKipcbiAqIEBldmVudCBSb29tU2lnbmFsaW5nI2V2ZW50OmljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcbiAqL1xuLyoqXG4gKiBAZXZlbnQgUm9vbVNpZ25hbGluZyNldmVudDpzaWduYWxpbmdDb25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gKi9cbi8qKlxuICogTWF5YmUgdXBkYXRlIHRoZSB7QGxpbmsgUm9vbVNpZ25hbGluZ30gc3RhdGUuXG4gKiBAcGFyYW0ge1Jvb21TaWduYWxpbmd9IHJvb21TaWduYWxpbmdcbiAqL1xuZnVuY3Rpb24gbWF5YmVVcGRhdGVTdGF0ZShyb29tU2lnbmFsaW5nKSB7XG4gICAgaWYgKHJvb21TaWduYWxpbmcuc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnIHx8IHJvb21TaWduYWxpbmcuc2lnbmFsaW5nQ29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICByb29tU2lnbmFsaW5nLl9zZXNzaW9uVGltZW91dC5jbGVhcigpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXdTdGF0ZTtcbiAgICBpZiAocm9vbVNpZ25hbGluZy5zaWduYWxpbmdDb25uZWN0aW9uU3RhdGUgPT09ICdyZWNvbm5lY3RpbmcnKSB7XG4gICAgICAgIG5ld1N0YXRlID0gcm9vbVNpZ25hbGluZy5zaWduYWxpbmdDb25uZWN0aW9uU3RhdGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJvb21TaWduYWxpbmcuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICByb29tU2lnbmFsaW5nLl9tZWRpYUNvbm5lY3Rpb25Jc1JlY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgIG5ld1N0YXRlID0gJ3JlY29ubmVjdGluZyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJvb21TaWduYWxpbmcuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnbmV3JyB8fCByb29tU2lnbmFsaW5nLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2NoZWNraW5nJykge1xuICAgICAgICBuZXdTdGF0ZSA9IHJvb21TaWduYWxpbmcuX21lZGlhQ29ubmVjdGlvbklzUmVjb25uZWN0aW5nID8gJ3JlY29ubmVjdGluZycgOiAnY29ubmVjdGVkJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJvb21TaWduYWxpbmcuX21lZGlhQ29ubmVjdGlvbklzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHJvb21TaWduYWxpbmcuX3JlY29ubmVjdGluZ0Vycm9yID0gbnVsbDtcbiAgICAgICAgcm9vbVNpZ25hbGluZy5fc2Vzc2lvblRpbWVvdXQuY2xlYXIoKTtcbiAgICAgICAgbmV3U3RhdGUgPSAnY29ubmVjdGVkJztcbiAgICB9XG4gICAgaWYgKG5ld1N0YXRlID09PSByb29tU2lnbmFsaW5nLnN0YXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5ld1N0YXRlID09PSAncmVjb25uZWN0aW5nJykge1xuICAgICAgICByb29tU2lnbmFsaW5nLl9yZWNvbm5lY3RpbmdFcnJvciA9IHJvb21TaWduYWxpbmcuc2lnbmFsaW5nQ29ubmVjdGlvblN0YXRlID09PSAncmVjb25uZWN0aW5nJ1xuICAgICAgICAgICAgPyBuZXcgU2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yKClcbiAgICAgICAgICAgIDogbmV3IE1lZGlhQ29ubmVjdGlvbkVycm9yKCk7XG4gICAgICAgIHJvb21TaWduYWxpbmcuX3Nlc3Npb25UaW1lb3V0LnN0YXJ0KCk7XG4gICAgICAgIHJvb21TaWduYWxpbmcucHJlZW1wdChuZXdTdGF0ZSwgbnVsbCwgW3Jvb21TaWduYWxpbmcuX3JlY29ubmVjdGluZ0Vycm9yXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByb29tU2lnbmFsaW5nLnByZWVtcHQobmV3U3RhdGUpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUm9vbVNpZ25hbGluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvb20uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4vKipcbiAqIEEge0BsaW5rIFRyYWNrfSBpbXBsZW1lbnRhdGlvblxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAcHJvcGVydHkge1RyYWNrLktpbmR9IGtpbmRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKi9cbnZhciBUcmFja1NpZ25hbGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJhY2tTaWduYWxpbmcsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFRyYWNrU2lnbmFsaW5nfS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7VHJhY2suS2luZH0ga2luZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbmFibGVkXG4gICAgICogQHBhcmFtIHtUcmFjay5Qcmlvcml0eX0gcHJpb3JpdHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFja1NpZ25hbGluZyhuYW1lLCBraW5kLCBpc0VuYWJsZWQsIHByaW9yaXR5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIHZhciBzaWQgPSBudWxsO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2Vycm9yOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaXNFbmFibGVkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGlzRW5hYmxlZCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9wcmlvcml0eToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90cmFja1RyYW5zY2VpdmVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2lkOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfc2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZCA9IF9zaWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2luZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGtpbmRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhY2tTaWduYWxpbmcucHJvdG90eXBlLCBcImVycm9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1udWxsIGlmIHB1YmxpY2F0aW9uIG9yIHN1YnNjcmlwdGlvbiBmYWlsZWQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7P0Vycm9yfSBlcnJvclxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhY2tTaWduYWxpbmcucHJvdG90eXBlLCBcImlzRW5hYmxlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB7QGxpbmsgVHJhY2tTaWduYWxpbmd9IGlzIGVuYWJsZWQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRW5hYmxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFja1NpZ25hbGluZy5wcm90b3R5cGUsIFwicHJpb3JpdHlcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHtAbGluayBUcmFja1NpZ25hbGluZ30ncyBwcmlvcml0eS5cbiAgICAgICAgICogQHByb3BlcnR5IHtUcmFjay5Qcmlvcml0eX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW9yaXR5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYWNrU2lnbmFsaW5nLnByb3RvdHlwZSwgXCJzaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHtAbGluayBUcmFja1NpZ25hbGluZ30ncyB7QGxpbmsgVHJhY2suU0lEfS5cbiAgICAgICAgICogQHByb3BlcnR5IHtUcmFjay5TSUR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhY2tTaWduYWxpbmcucHJvdG90eXBlLCBcInRyYWNrVHJhbnNjZWl2ZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHtAbGluayBUcmFja1NpZ25hbGluZ30ncyB7QGxpbmsgVHJhY2tUcmFuc2NlaXZlcn0uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VHJhY2tUcmFuc2NlaXZlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrVHJhbnNjZWl2ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIHRoZSB7QGxpbmsgVHJhY2tTaWduYWxpbmd9IGlmIGl0IGlzIG5vdCBhbHJlYWR5IGRpc2FibGVkLlxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG4gICAgVHJhY2tTaWduYWxpbmcucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuYWJsZShmYWxzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbmFibGUgKG9yIGRpc2FibGUpIHRoZSB7QGxpbmsgVHJhY2tTaWduYWxpbmd9IGlmIGl0IGlzIG5vdCBhbHJlYWR5IGVuYWJsZWRcbiAgICAgKiAob3IgZGlzYWJsZWQpLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuYWJsZWQ9dHJ1ZV1cbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuICAgIFRyYWNrU2lnbmFsaW5nLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICBlbmFibGVkID0gdHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJyA/IGVuYWJsZWQgOiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQgIT09IGVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUge0BsaW5rIFRyYWNrVHJhbnNjZWl2ZXJ9IG9uIHRoZSB7QGxpbmsgVHJhY2tTaWduYWxpbmd9LlxuICAgICAqIEBwYXJhbSB7VHJhY2tUcmFuc2NlaXZlcn0gdHJhY2tUcmFuc2NlaXZlclxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIFRyYWNrU2lnbmFsaW5nLnByb3RvdHlwZS5zZXRUcmFja1RyYW5zY2VpdmVyID0gZnVuY3Rpb24gKHRyYWNrVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgdHJhY2tUcmFuc2NlaXZlciA9IHRyYWNrVHJhbnNjZWl2ZXIgfHwgbnVsbDtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tUcmFuc2NlaXZlciAhPT0gdHJhY2tUcmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tUcmFuc2NlaXZlciA9IHRyYWNrVHJhbnNjZWl2ZXI7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgU0lEIG9uIHRoZSB7QGxpbmsgVHJhY2tTaWduYWxpbmd9IG9uY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIFRyYWNrU2lnbmFsaW5nLnByb3RvdHlwZS5zZXRTaWQgPSBmdW5jdGlvbiAoc2lkKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc2lkID0gc2lkO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhY2tTaWduYWxpbmc7XG59KEV2ZW50RW1pdHRlcikpO1xuLyoqXG4gKiBFbWl0dGVkIHdoZW5ldmVyIHRoZSB7QGxpbmsgVHJhY2tTaWduYWxpbmd9IGlzIHVwZGF0ZWRcbiAqIEBldmVudCBUcmFja1NpZ25hbGluZyN1cGRhdGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVHJhY2tTaWduYWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgQ2FuY2VsYWJsZVByb21pc2UgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NhbmNlbGFibGVwcm9taXNlJyk7XG52YXIgRGVmYXVsdFBlZXJDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vcGVlcmNvbm5lY3Rpb25tYW5hZ2VyJyk7XG52YXIgRGVmYXVsdFJvb21WMiA9IHJlcXVpcmUoJy4vcm9vbScpO1xudmFyIERlZmF1bHRSb29tVjMgPSByZXF1aXJlKCcuLi92My9yb29tJyk7XG52YXIgRGVmYXVsdFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHdpbGlvY29ubmVjdGlvbnRyYW5zcG9ydCcpO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90d2lsaW8tdmlkZW8tZXJyb3JzJyksIFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvciA9IF9hLlNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvciwgU2lnbmFsaW5nSW5jb21pbmdNZXNzYWdlSW52YWxpZEVycm9yID0gX2EuU2lnbmFsaW5nSW5jb21pbmdNZXNzYWdlSW52YWxpZEVycm9yO1xudmFyIF9iID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLCBmbGF0TWFwID0gX2IuZmxhdE1hcCwgY3JlYXRlUm9vbUNvbm5lY3RFdmVudFBheWxvYWQgPSBfYi5jcmVhdGVSb29tQ29ubmVjdEV2ZW50UGF5bG9hZDtcbmZ1bmN0aW9uIGNyZWF0ZUNhbmNlbGFibGVSb29tU2lnbmFsaW5nUHJvbWlzZSh0b2tlbiwgd3NTZXJ2ZXIsIGxvY2FsUGFydGljaXBhbnQsIGVuY29kaW5nUGFyYW1ldGVycywgcHJlZmVycmVkQ29kZWNzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBQZWVyQ29ubmVjdGlvbk1hbmFnZXI6IERlZmF1bHRQZWVyQ29ubmVjdGlvbk1hbmFnZXIsXG4gICAgICAgIFJvb21WMjogRGVmYXVsdFJvb21WMixcbiAgICAgICAgUm9vbVYzOiBEZWZhdWx0Um9vbVYzLFxuICAgICAgICBUcmFuc3BvcnQ6IERlZmF1bHRUcmFuc3BvcnRcbiAgICB9LCBvcHRpb25zKTtcbiAgICB2YXIgYWRhcHRpdmVTaW11bGNhc3QgPSBwcmVmZXJyZWRDb2RlY3MudmlkZW9bMF0gJiYgcHJlZmVycmVkQ29kZWNzLnZpZGVvWzBdLmFkYXB0aXZlU2ltdWxjYXN0ID09PSB0cnVlO1xuICAgIHZhciBQZWVyQ29ubmVjdGlvbk1hbmFnZXIgPSBvcHRpb25zLlBlZXJDb25uZWN0aW9uTWFuYWdlciwgUm9vbVYyID0gb3B0aW9ucy5Sb29tVjIsIFJvb21WMyA9IG9wdGlvbnMuUm9vbVYzLCBUcmFuc3BvcnQgPSBvcHRpb25zLlRyYW5zcG9ydCwgaWNlU2VydmVycyA9IG9wdGlvbnMuaWNlU2VydmVycywgbG9nID0gb3B0aW9ucy5sb2c7XG4gICAgdmFyIHBlZXJDb25uZWN0aW9uTWFuYWdlciA9IG5ldyBQZWVyQ29ubmVjdGlvbk1hbmFnZXIoZW5jb2RpbmdQYXJhbWV0ZXJzLCBwcmVmZXJyZWRDb2RlY3MsIG9wdGlvbnMpO1xuICAgIHZhciB0cmFja1NlbmRlcnMgPSBmbGF0TWFwKGxvY2FsUGFydGljaXBhbnQudHJhY2tzLCBmdW5jdGlvbiAodHJhY2tWMikgeyByZXR1cm4gW3RyYWNrVjIudHJhY2tUcmFuc2NlaXZlcl07IH0pO1xuICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5zZXRUcmFja1NlbmRlcnModHJhY2tTZW5kZXJzKTtcbiAgICB2YXIgY2FuY2VsbGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoJ0NhbmNlbGVkJyk7XG4gICAgdmFyIHRyYW5zcG9ydDtcbiAgICB2YXIgY2FuY2VsYWJsZVByb21pc2UgPSBuZXcgQ2FuY2VsYWJsZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgaXNDYW5jZWxlZCkge1xuICAgICAgICB2YXIgb25JY2VkID0gZnVuY3Rpb24gKGljZVNlcnZlcnMpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbmNlbGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoY2FuY2VsbGF0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjYW5jZWxsYXRpb25FcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2cuZGVidWcoJ0dvdCBJQ0Ugc2VydmVyczonLCBpY2VTZXJ2ZXJzKTtcbiAgICAgICAgICAgIG9wdGlvbnMuaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29uZmlndXJhdGlvbihvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbk1hbmFnZXIuY3JlYXRlQW5kT2ZmZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDYW5jZWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChjYW5jZWxsYXRpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNhbmNlbGxhdGlvbkVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ2NyZWF0ZUFuZE9mZmVyKCkgc3VjY2VlZGVkLicpO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFBlZXJDb25uZWN0aW9uTWFuYWdlciNjcmVhdGVBbmRPZmZlcigpIHF1ZXVlcyB0aGVcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIG9mZmVyIGluIHRoZSBldmVudCBxdWV1ZSBmb3IgdGhlICdkZXNjcmlwdGlvbicgZXZlbnQuIFNvLFxuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBkZXF1ZXVlaW5nIHRvIHByZXZlbnQgdGhlIHNwdXJpb3VzICd1cGRhdGUnIG1lc3NhZ2Ugc2VudCBieVxuICAgICAgICAgICAgICAgIC8vIHRoZSBjbGllbnQgYWZ0ZXIgY29ubmVjdGluZyB0byBhIHJvb20uXG4gICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLmRlcXVldWUoJ2Rlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoJ2NyZWF0ZUFuZE9mZmVyKCkgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhdXRvbWF0aWNTdWJzY3JpcHRpb24gPSBvcHRpb25zLmF1dG9tYXRpY1N1YnNjcmlwdGlvbiwgYmFuZHdpZHRoUHJvZmlsZSA9IG9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZSwgZG9taW5hbnRTcGVha2VyID0gb3B0aW9ucy5kb21pbmFudFNwZWFrZXIsIGVudmlyb25tZW50ID0gb3B0aW9ucy5lbnZpcm9ubWVudCwgZXZlbnRPYnNlcnZlciA9IG9wdGlvbnMuZXZlbnRPYnNlcnZlciwgbG9nZ2VyTmFtZSA9IG9wdGlvbnMubG9nZ2VyTmFtZSwgbG9nTGV2ZWwgPSBvcHRpb25zLmxvZ0xldmVsLCBuYW1lID0gb3B0aW9ucy5uYW1lLCBuZXR3b3JrTW9uaXRvciA9IG9wdGlvbnMubmV0d29ya01vbml0b3IsIG5ldHdvcmtRdWFsaXR5ID0gb3B0aW9ucy5uZXR3b3JrUXVhbGl0eSwgcmVhbG0gPSBvcHRpb25zLnJlYWxtLCBzZHBTZW1hbnRpY3MgPSBvcHRpb25zLnNkcFNlbWFudGljcztcbiAgICAgICAgLy8gZGVjaWRlIHdoaWNoIG1zcCBjaGFubmVscyB0byByZXF1ZXN0XG4gICAgICAgIC8vIGRvbWluYW50U3BlYWtlciwgbmV0d29ya1F1YWxpdHlcbiAgICAgICAgdmFyIHRyYWNrUHJpb3JpdHkgPSAhIWJhbmR3aWR0aFByb2ZpbGU7XG4gICAgICAgIHZhciB0cmFja1N3aXRjaE9mZiA9ICEhYmFuZHdpZHRoUHJvZmlsZTtcbiAgICAgICAgdmFyIHJlbmRlckhpbnRzID0gISFiYW5kd2lkdGhQcm9maWxlICYmXG4gICAgICAgICAgICAob3B0aW9ucy5jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgIT09ICdkaXNhYmxlZCcgfHwgb3B0aW9ucy5jb250ZW50UHJlZmVyZW5jZXNNb2RlICE9PSAnZGlzYWJsZWQnKTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGFkYXB0aXZlU2ltdWxjYXN0OiBhZGFwdGl2ZVNpbXVsY2FzdCxcbiAgICAgICAgICAgIGF1dG9tYXRpY1N1YnNjcmlwdGlvbjogYXV0b21hdGljU3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgZG9taW5hbnRTcGVha2VyOiBkb21pbmFudFNwZWFrZXIsXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogZW52aXJvbm1lbnQsXG4gICAgICAgICAgICBldmVudE9ic2VydmVyOiBldmVudE9ic2VydmVyLFxuICAgICAgICAgICAgbG9nZ2VyTmFtZTogbG9nZ2VyTmFtZSxcbiAgICAgICAgICAgIGxvZ0xldmVsOiBsb2dMZXZlbCxcbiAgICAgICAgICAgIG5ldHdvcmtNb25pdG9yOiBuZXR3b3JrTW9uaXRvcixcbiAgICAgICAgICAgIG5ldHdvcmtRdWFsaXR5OiBuZXR3b3JrUXVhbGl0eSxcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMsXG4gICAgICAgICAgICBvbkljZWQ6IG9uSWNlZCxcbiAgICAgICAgICAgIHJlYWxtOiByZWFsbSxcbiAgICAgICAgICAgIHJlbmRlckhpbnRzOiByZW5kZXJIaW50cyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogc2RwU2VtYW50aWNzLFxuICAgICAgICAgICAgdHJhY2tQcmlvcml0eTogdHJhY2tQcmlvcml0eSxcbiAgICAgICAgICAgIHRyYWNrU3dpdGNoT2ZmOiB0cmFja1N3aXRjaE9mZlxuICAgICAgICB9LCBiYW5kd2lkdGhQcm9maWxlID8ge1xuICAgICAgICAgICAgYmFuZHdpZHRoUHJvZmlsZTogYmFuZHdpZHRoUHJvZmlsZVxuICAgICAgICB9IDoge30pO1xuICAgICAgICB0cmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0KG5hbWUsIHRva2VuLCBsb2NhbFBhcnRpY2lwYW50LCBwZWVyQ29ubmVjdGlvbk1hbmFnZXIsIHdzU2VydmVyLCB0cmFuc3BvcnRPcHRpb25zKTtcbiAgICAgICAgdmFyIGNvbm5lY3RFdmVudFBheWxvYWQgPSBjcmVhdGVSb29tQ29ubmVjdEV2ZW50UGF5bG9hZChvcHRpb25zKTtcbiAgICAgICAgZXZlbnRPYnNlcnZlci5lbWl0KCdldmVudCcsIGNvbm5lY3RFdmVudFBheWxvYWQpO1xuICAgICAgICB0cmFuc3BvcnQub25jZSgnY29ubmVjdGVkJywgZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKCdUcmFuc3BvcnQgY29ubmVjdGVkOicsIGluaXRpYWxTdGF0ZSk7XG4gICAgICAgICAgICBpZiAoaXNDYW5jZWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGNhbmNlbGxhdGlvbkVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbG9jYWxQYXJ0aWNpcGFudFN0YXRlID0gaW5pdGlhbFN0YXRlLnBhcnRpY2lwYW50O1xuICAgICAgICAgICAgaWYgKCFsb2NhbFBhcnRpY2lwYW50U3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IFNpZ25hbGluZ0luY29taW5nTWVzc2FnZUludmFsaWRFcnJvcigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2lnbmFsaW5nUmVnaW9uID0gaW5pdGlhbFN0YXRlLm9wdGlvbnMuc2lnbmFsaW5nX3JlZ2lvbiwgdmVyc2lvbiA9IGluaXRpYWxTdGF0ZS52ZXJzaW9uO1xuICAgICAgICAgICAgbG9jYWxQYXJ0aWNpcGFudC5zZXRTaWduYWxpbmdSZWdpb24oc2lnbmFsaW5nUmVnaW9uKTtcbiAgICAgICAgICAgIHZhciBSb29tU2lnbmFsaW5nID0gdmVyc2lvbiA9PT0gMyA/IFJvb21WMyA6IFJvb21WMjtcbiAgICAgICAgICAgIHJlc29sdmUobmV3IFJvb21TaWduYWxpbmcobG9jYWxQYXJ0aWNpcGFudCwgaW5pdGlhbFN0YXRlLCB0cmFuc3BvcnQsIHBlZXJDb25uZWN0aW9uTWFuYWdlciwgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIChzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvciB8fCBuZXcgU2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKCdUcmFuc3BvcnQgc3RhdGUgY2hhbmdlZDonLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjYW5jZWxhYmxlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5jbG9zZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBjYW5jZWxhYmxlUHJvbWlzZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FuY2VsYWJsZXJvb21zaWduYWxpbmdwcm9taXNlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTWVkaWFTaWduYWxpbmcgPSByZXF1aXJlKCcuL21lZGlhc2lnbmFsaW5nJyk7XG4vKipcbiAqIEBwcm9wZXJ0eSB7P1RyYWNrLlNJRH0gbG91ZGVzdFBhcnRpY2lwYW50U2lkXG4gKiBAZW1pdHMgRG9taW5hbnRTcGVha2VyU2lnbmFsaW5nI3VwZGF0ZWRcbiAqL1xudmFyIERvbWluYW50U3BlYWtlclNpZ25hbGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRG9taW5hbnRTcGVha2VyU2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiB7QGxpbmsgRG9taW5hbnRTcGVha2VyU2lnbmFsaW5nfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEb21pbmFudFNwZWFrZXJTaWduYWxpbmcoZ2V0UmVjZWl2ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ2V0UmVjZWl2ZXIsICdhY3RpdmVfc3BlYWtlcicsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfbG91ZGVzdFBhcnRpY2lwYW50U2lkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vbigncmVhZHknLCBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FjdGl2ZV9zcGVha2VyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRMb3VkZXN0UGFydGljaXBhbnRTaWQobWVzc2FnZS5wYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9taW5hbnRTcGVha2VyU2lnbmFsaW5nLnByb3RvdHlwZSwgXCJsb3VkZXN0UGFydGljaXBhbnRTaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsb3VkZXN0IHtAbGluayBUcmFjay5TSUR9LCBpZiBrbm93bi5cbiAgICAgICAgICogQHJldHVybnMgez9UcmFjay5TSUR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb3VkZXN0UGFydGljaXBhbnRTaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7VHJhY2suU0lEfSBsb3VkZXN0UGFydGljaXBhbnRTaWRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBEb21pbmFudFNwZWFrZXJTaWduYWxpbmcucHJvdG90eXBlLl9zZXRMb3VkZXN0UGFydGljaXBhbnRTaWQgPSBmdW5jdGlvbiAobG91ZGVzdFBhcnRpY2lwYW50U2lkKSB7XG4gICAgICAgIGlmICh0aGlzLmxvdWRlc3RQYXJ0aWNpcGFudFNpZCA9PT0gbG91ZGVzdFBhcnRpY2lwYW50U2lkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG91ZGVzdFBhcnRpY2lwYW50U2lkID0gbG91ZGVzdFBhcnRpY2lwYW50U2lkO1xuICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBEb21pbmFudFNwZWFrZXJTaWduYWxpbmc7XG59KE1lZGlhU2lnbmFsaW5nKSk7XG4vKipcbiAqIEBldmVudCBEb21pbmFudFNwZWFrZXJTaWduYWxpbmcjdXBkYXRlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IERvbWluYW50U3BlYWtlclNpZ25hbGluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbWluYW50c3BlYWtlcnNpZ25hbGluZy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgRmlsdGVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9maWx0ZXInKTtcbi8qKlxuICogQW4ge0BsaW5rIEljZUJveH0gc3RvcmVzIHRyaWNrbGVkIElDRSBjYW5kaWRhdGVzLiBDYW5kaWRhdGVzIGFkZGVkIHRvIHRoZVxuICoge0BsaW5rIEljZUJveH0gdmlhIHtAbGluayBJY2VCb3gjdXBkYXRlfSBhcmUgY29tcGFyZWQgYWdhaW5zdCBwcmV2aW91c2x5XG4gKiB0cmlja2xlZCBjYW5kaWRhdGVzIGFuZCBvbmx5IG5ldyBjYW5kaWRhdGVzIHdpbGwgYmUgcmV0dXJuZWQgKGFzc3VtaW5nIHRoZXlcbiAqIG1hdGNoIHRoZSBjdXJyZW50IElDRSB1c2VybmFtZSBmcmFnbWVudCBzZXQgYnkge0BsaW5rIEljZUJveCNzZXRVZnJhZ30pLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSB1ZnJhZ1xuICovXG52YXIgSWNlQm94ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiB7QGxpbmsgSWNlQm94fS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJY2VCb3goKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIF9maWx0ZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IEZpbHRlcih7XG4gICAgICAgICAgICAgICAgICAgIGdldEtleTogZnVuY3Rpb24gZ2V0S2V5KGljZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWNlU3RhdGUudWZyYWc7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG86IGZ1bmN0aW9uIGlzTGVzc1RoYW5PckVxdWFsVG8oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEucmV2aXNpb24gPD0gYi5yZXZpc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3VmcmFnOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1ZnJhZzoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91ZnJhZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIElDRSB1c2VybmFtZSBmcmFnbWVudCBvbiB0aGUge0BsaW5rIEljZUJveH0uIFRoaXMgbWV0aG9kIHJldHVybnMgYW55XG4gICAgICogSUNFIGNhbmRpZGF0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VybmFtZSBmcmFnbWVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWZyYWdcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8UlRDSWNlQ2FuZGlkYXRlSW5pdD59XG4gICAgICovXG4gICAgSWNlQm94LnByb3RvdHlwZS5zZXRVZnJhZyA9IGZ1bmN0aW9uICh1ZnJhZykge1xuICAgICAgICB0aGlzLl91ZnJhZyA9IHVmcmFnO1xuICAgICAgICB2YXIgaWNlID0gdGhpcy5fZmlsdGVyLnRvTWFwKCkuZ2V0KHVmcmFnKTtcbiAgICAgICAgcmV0dXJuIGljZSA/IGljZS5jYW5kaWRhdGVzIDogW107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHtAbGluayBJY2VCb3h9LiBUaGlzIG1ldGhvZCByZXR1cm5zIGFueSBuZXcgSUNFIGNhbmRpZGF0ZXNcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgdXNlcm5hbWUgZnJhZ21lbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGljZVN0YXRlXG4gICAgICogQHJldHVybnMge0FycmF5PFJUQ0ljZUNhbmRpZGF0ZUluaXQ+fVxuICAgICAqL1xuICAgIEljZUJveC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGljZVN0YXRlKSB7XG4gICAgICAgIC8vIE5PVEUobXJvYmVydHMpOiBUaGUgU2VydmVyIHNvbWV0aW1lcyBkb2VzIG5vdCBzZXQgdGhlIGNhbmRpZGF0ZXMgcHJvcGVydHkuXG4gICAgICAgIGljZVN0YXRlLmNhbmRpZGF0ZXMgPSBpY2VTdGF0ZS5jYW5kaWRhdGVzIHx8IFtdO1xuICAgICAgICB2YXIgb2xkSWNlU3RhdGUgPSB0aGlzLl9maWx0ZXIudG9NYXAoKS5nZXQoaWNlU3RhdGUudWZyYWcpO1xuICAgICAgICB2YXIgb2xkQ2FuZGlkYXRlcyA9IG9sZEljZVN0YXRlID8gb2xkSWNlU3RhdGUuY2FuZGlkYXRlcyA6IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyLnVwZGF0ZShpY2VTdGF0ZSkgJiYgdGhpcy5fdWZyYWcgPT09IGljZVN0YXRlLnVmcmFnXG4gICAgICAgICAgICA/IGljZVN0YXRlLmNhbmRpZGF0ZXMuc2xpY2Uob2xkQ2FuZGlkYXRlcy5sZW5ndGgpXG4gICAgICAgICAgICA6IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIEljZUJveDtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IEljZUJveDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWljZWJveC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX2EgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbnN0YW50cycpLCBJQ0VfQUNUSVZJVFlfQ0hFQ0tfUEVSSU9EX01TID0gX2EuSUNFX0FDVElWSVRZX0NIRUNLX1BFUklPRF9NUywgSUNFX0lOQUNUSVZJVFlfVEhSRVNIT0xEX01TID0gX2EuSUNFX0lOQUNUSVZJVFlfVEhSRVNIT0xEX01TO1xuLyoqXG4gKiBNb25pdG9ycyBhIHtAbGluayBSVENQZWVyQ29ubmVjdGlvbn0ncyBzdGF0cyBhbmQgbm90aWZpZXNcbiAqIGNhbGxlciB3aGVuIGluYWN0aXZpdHkgaXMgZGV0ZWN0ZWQuXG4gKi9cbnZhciBJY2VDb25uZWN0aW9uTW9uaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4ge0BsaW5rIEljZUNvbm5lY3Rpb25Nb25pdG9yfS5cbiAgICAgKiBAcGFyYW0ge1JUQ1BlZXJDb25uZWN0aW9ufSBwZWVyQ29ubmVjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJY2VDb25uZWN0aW9uTW9uaXRvcihwZWVyQ29ubmVjdGlvbiwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBhY3Rpdml0eUNoZWNrUGVyaW9kTXM6IElDRV9BQ1RJVklUWV9DSEVDS19QRVJJT0RfTVMsXG4gICAgICAgICAgICBpbmFjdGl2aXR5VGhyZXNob2xkTXM6IElDRV9JTkFDVElWSVRZX1RIUkVTSE9MRF9NUyxcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIF9hY3Rpdml0eUNoZWNrUGVyaW9kTXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5hY3Rpdml0eUNoZWNrUGVyaW9kTXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW5hY3Rpdml0eVRocmVzaG9sZE1zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuaW5hY3Rpdml0eVRocmVzaG9sZE1zXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xhc3RBY3Rpdml0eToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3BlZXJDb25uZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBlZXJDb25uZWN0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RpbWVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBJY2VDb25uZWN0aW9uTW9uaXRvci5wcm90b3R5cGUuX2dldEFjdGl2ZVBhaXJTdGF0ID0gZnVuY3Rpb24gKHN0YXRzKSB7XG4gICAgICAgIHZhciBzdGF0c0FycmF5ID0gQXJyYXkuZnJvbShzdGF0cy52YWx1ZXMoKSk7XG4gICAgICAgIHZhciBhY3RpdmVQYWlyU3RhdHMgPSBzdGF0c0FycmF5LmZpbmQoZnVuY3Rpb24gKHN0YXQpIHsgcmV0dXJuIHN0YXQudHlwZSA9PT0gJ2NhbmRpZGF0ZS1wYWlyJyAmJiBzdGF0Lm5vbWluYXRlZDsgfSk7XG4gICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBzb21ldGltZXMgKEpTREstMjY2NykgYWZ0ZXIgZ2V0dGluZyBkaXNjb25uZWN0ZWQgd2hpbGUgc3dpdGNoaW5nIG5ldHdvcmtcbiAgICAgICAgLy8gd2UgbWF5IG5vdCBmaW5kIGFjdGl2ZSBwYWlyLiBUcmVhdCB0aGlzIGFzIDAgYnl0ZXNSZWNlaXZlZCBzbyB0aGF0IHdlIGNvdW50IGl0IHRvd2FyZHMgaW5hY3Rpdml0eS5cbiAgICAgICAgcmV0dXJuIGFjdGl2ZVBhaXJTdGF0cyB8fCB7XG4gICAgICAgICAgICBieXRlc1JlY2VpdmVkOiAwLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBNYXRoLnJvdW5kKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgSUNFIGNvbm5lY3Rpb24gc3RhdHMsIGFuZCBleHRyYWN0IHJlY2VpdmVkIGFuZCBzZW5kIGJ5dGVzLlxuICAgICAqIEByZXR1cm5zIFByb21pc2U8P1JUQ0ljZUNhbmRpZGF0ZVBhaXJTdGF0cz5cbiAgICAgKi9cbiAgICBJY2VDb25uZWN0aW9uTW9uaXRvci5wcm90b3R5cGUuX2dldEljZUNvbm5lY3Rpb25TdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uLmdldFN0YXRzKCkudGhlbihmdW5jdGlvbiAoc3RhdHMpIHsgcmV0dXJuIF90aGlzLl9nZXRBY3RpdmVQYWlyU3RhdChzdGF0cyk7IH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNjaGVkdWxlcy91bi1zY2hlZHVsZXMgaW5hY3Rpdml0eSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBJY2VDb25uZWN0aW9uTW9uaXRvci5wcm90b3R5cGUuX3NjaGVkdWxlSW5hY3Rpdml0eUNhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjYWxsYmFjayAmJiB0aGlzLl9vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGNhbGxiYWNrXG4gICAgICAgICAgICB0aGlzLl9vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9wZWVyQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghY2FsbGJhY2sgJiYgdGhpcy5fb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAvLyB1bnNjaGVkdWxlIGNhbGxiYWNrXG4gICAgICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgICAgdGhpcy5fb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnQgbW9uaXRvcmluZyB0aGUgSUNFIGNvbm5lY3Rpb24uXG4gICAgICogTW9uaXRvcnMgYnl0ZXMgcmVjZWl2ZWQgb24gYWN0aXZlIGljZSBjb25uZWN0aW9uIHBhaXIsXG4gICAgICogaW52b2tlcyBvbkljZUNvbm5lY3Rpb25JbmFjdGl2ZSB3aGVuIGluYWN0aXZpdHkgaXMgZGV0ZWN0ZWQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25JY2VDb25uZWN0aW9uSW5hY3RpdmVcbiAgICAgKi9cbiAgICBJY2VDb25uZWN0aW9uTW9uaXRvci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAob25JY2VDb25uZWN0aW9uSW5hY3RpdmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2dldEljZUNvbm5lY3Rpb25TdGF0cygpLnRoZW4oZnVuY3Rpb24gKGljZVN0YXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpY2VTdGF0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBXZSBsb29rIGF0IGJ5dGVzUmVjZWl2ZWQgb24gYWN0aXZlIGNhbmRpZGF0ZSBwYWlyIGFzIGFuIGluZGljYXRpb24gb2YgYWN0aXZlIGljZSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEFzIHBlciBzcGVjIChodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXN0YXRzLyNkb20tcnRjaWNlY2FuZGlkYXRlcGFpcnN0YXRzLWJ5dGVzcmVjZWl2ZWQpIHRoaXMgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRlcyBSVENQIHRyYWZmaWMgYW5kIGlzICt2ZSBldmVuIHdoZW4gdGhlcmUgYXJlIG5vIHRyYWNrcyBzdWJzY3JpYmVkIHRvLlxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2xhc3RBY3Rpdml0eSB8fCBfdGhpcy5fbGFzdEFjdGl2aXR5LmJ5dGVzUmVjZWl2ZWQgIT09IGljZVN0YXRzLmJ5dGVzUmVjZWl2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xhc3RBY3Rpdml0eSA9IGljZVN0YXRzO1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlY3RlZCBhY3Rpdml0eSwgY2FuY2VsIHNjaGVkdWxlZCBjYWxsYmFjayBpZiBhbnkuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zY2hlZHVsZUluYWN0aXZpdHlDYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGljZVN0YXRzLnRpbWVzdGFtcCAtIF90aGlzLl9sYXN0QWN0aXZpdHkudGltZXN0YW1wID49IF90aGlzLl9pbmFjdGl2aXR5VGhyZXNob2xkTXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZWN0ZWQgaW5hY3Rpdml0eS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9wZWVyQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkljZUNvbm5lY3Rpb25JbmFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLl9vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zY2hlZHVsZUluYWN0aXZpdHlDYWxsYmFjayhvbkljZUNvbm5lY3Rpb25JbmFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcy5fYWN0aXZpdHlDaGVja1BlcmlvZE1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3AgbW9uaXRvcmluZyB0aGUgSUNFIGNvbm5lY3Rpb24gc3RhdGUuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgSWNlQ29ubmVjdGlvbk1vbml0b3IucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlSW5hY3Rpdml0eUNhbGxiYWNrKG51bGwpO1xuICAgICAgICBpZiAodGhpcy5fdGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fdGltZXIpO1xuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbGFzdEFjdGl2aXR5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEljZUNvbm5lY3Rpb25Nb25pdG9yO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gSWNlQ29ubmVjdGlvbk1vbml0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pY2Vjb25uZWN0aW9ubW9uaXRvci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIGRlZmF1bHRDcmVhdGVDYW5jZWxhYmxlUm9vbVNpZ25hbGluZ1Byb21pc2UgPSByZXF1aXJlKCcuL2NhbmNlbGFibGVyb29tc2lnbmFsaW5ncHJvbWlzZScpO1xudmFyIExvY2FsUGFydGljaXBhbnRWMiA9IHJlcXVpcmUoJy4vbG9jYWxwYXJ0aWNpcGFudCcpO1xudmFyIFNpZ25hbGluZyA9IHJlcXVpcmUoJy4uLycpO1xuLyoqXG4gKiB7QGxpbmsgU2lnbmFsaW5nVjJ9IGltcGxlbWVudHMgdmVyc2lvbiAyIG9mIG91ciBzaWduYWxpbmcgcHJvdG9jb2wuXG4gKiBAZXh0ZW5kcyBTaWduYWxpbmdcbiAqL1xudmFyIFNpZ25hbGluZ1YyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWduYWxpbmdWMiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Qge0BsaW5rIFNpZ25hbGluZ1YyfS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd3NTZXJ2ZXJcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IFtvcHRpb25zPXt9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpZ25hbGluZ1YyKHdzU2VydmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qIGVzbGludCBuZXctY2FwOjAgKi9cbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY3JlYXRlQ2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlOiBkZWZhdWx0Q3JlYXRlQ2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfY3JlYXRlQ2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuY3JlYXRlQ2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9uc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF93c1NlcnZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB3c1NlcnZlclxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFNpZ25hbGluZ1YyLnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uIChsb2NhbFBhcnRpY2lwYW50LCB0b2tlbiwgZW5jb2RpbmdQYXJhbWV0ZXJzLCBwcmVmZXJyZWRDb2RlY3MsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQ2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlLmJpbmQobnVsbCwgdG9rZW4sIHRoaXMuX3dzU2VydmVyLCBsb2NhbFBhcnRpY2lwYW50LCBlbmNvZGluZ1BhcmFtZXRlcnMsIHByZWZlcnJlZENvZGVjcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBTaWduYWxpbmdWMi5wcm90b3R5cGUuY3JlYXRlTG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZ1BhcmFtZXRlcnMsIG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IExvY2FsUGFydGljaXBhbnRWMihlbmNvZGluZ1BhcmFtZXRlcnMsIG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbik7XG4gICAgfTtcbiAgICByZXR1cm4gU2lnbmFsaW5nVjI7XG59KFNpZ25hbGluZykpO1xubW9kdWxlLmV4cG9ydHMgPSBTaWduYWxpbmdWMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZyA9IHJlcXVpcmUoJy4uL2xvY2FscGFydGljaXBhbnQnKTtcbnZhciBMb2NhbFRyYWNrUHVibGljYXRpb25WMiA9IHJlcXVpcmUoJy4vbG9jYWx0cmFja3B1YmxpY2F0aW9uJyk7XG52YXIgREVGQVVMVF9MT0dfTEVWRUwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbnN0YW50cycpLkRFRkFVTFRfTE9HX0xFVkVMO1xudmFyIExvZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbG9nJyk7XG52YXIgX2EgPSByZXF1aXJlKCcuLi8uLi91dGlsJyksIGJ1aWxkTG9nTGV2ZWxzID0gX2EuYnVpbGRMb2dMZXZlbHMsIGlzRGVlcEVxdWFsID0gX2EuaXNEZWVwRXF1YWw7XG4vKipcbiAqIEBleHRlbmRzIFBhcnRpY2lwYW50U2lnbmFsaW5nXG4gKiBAcHJvcGVydHkge0JhbmR3aWR0aFByb2ZpbGV9IGJhbmR3aWR0aFByb2ZpbGVcbiAqIEBwcm9wZXJ0eSB7TmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uSW1wbH0gbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmV2aXNpb25cbiAqIEBlbWl0cyBMb2NhbFBhcnRpY2lwYW50VjIjdXBkYXRlZFxuICovXG52YXIgTG9jYWxQYXJ0aWNpcGFudFYyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhbFBhcnRpY2lwYW50VjIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIExvY2FsUGFydGljaXBhbnRWMn0uXG4gICAgICogQHBhcmFtIHtFbmNvZGluZ1BhcmFtZXRlcnNJbXBsfSBlbmNvZGluZ1BhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge05ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbkltcGx9IG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2NhbFBhcnRpY2lwYW50VjIoZW5jb2RpbmdQYXJhbWV0ZXJzLCBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgbG9nTGV2ZWw6IERFRkFVTFRfTE9HX0xFVkVMLFxuICAgICAgICAgICAgTG9jYWxUcmFja1B1YmxpY2F0aW9uVjI6IExvY2FsVHJhY2tQdWJsaWNhdGlvblYyXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIHZhciBsb2dMZXZlbHMgPSBidWlsZExvZ0xldmVscyhvcHRpb25zLmxvZ0xldmVsKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9iYW5kd2lkdGhQcm9maWxlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZW5jb2RpbmdQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGVuY29kaW5nUGFyYW1ldGVyc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX0xvY2FsVHJhY2tQdWJsaWNhdGlvblYyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuTG9jYWxUcmFja1B1YmxpY2F0aW9uVjJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9nOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMubG9nXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5sb2cuY3JlYXRlTG9nKCdkZWZhdWx0JywgX3RoaXMpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IExvZygnZGVmYXVsdCcsIF90aGlzLCBsb2dMZXZlbHMsIG9wdGlvbnMubG9nZ2VyTmFtZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcHVibGlzaGVkUmV2aXNpb246IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZXZpc2lvbjoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NpZ25hbGluZ1JlZ2lvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFuZHdpZHRoUHJvZmlsZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYW5kd2lkdGhQcm9maWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYW5kd2lkdGhQcm9maWxlUmV2aXNpb246IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXZpc2lvbjoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXZpc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lnbmFsaW5nUmVnaW9uOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbGluZ1JlZ2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExvY2FsUGFydGljaXBhbnRWMi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltMb2NhbFBhcnRpY2lwYW50U2lnbmFsaW5nOiBcIiArIHRoaXMuc2lkICsgXCJdXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNpZ25hbGluZ1JlZ2lvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmFsaW5nUmVnaW9uLlxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnRWMi5wcm90b3R5cGUuc2V0U2lnbmFsaW5nUmVnaW9uID0gZnVuY3Rpb24gKHNpZ25hbGluZ1JlZ2lvbikge1xuICAgICAgICBpZiAoIXRoaXMuX3NpZ25hbGluZ1JlZ2lvbikge1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsaW5nUmVnaW9uID0gc2lnbmFsaW5nUmVnaW9uO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHtAbGluayBCYW5kd2lkdGhQcm9maWxlfS5cbiAgICAgKiBAcGFyYW0ge0JhbmR3aWR0aFByb2ZpbGV9IGJhbmR3aWR0aFByb2ZpbGVcbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50VjIucHJvdG90eXBlLnNldEJhbmR3aWR0aFByb2ZpbGUgPSBmdW5jdGlvbiAoYmFuZHdpZHRoUHJvZmlsZSkge1xuICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKHRoaXMuX2JhbmR3aWR0aFByb2ZpbGUsIGJhbmR3aWR0aFByb2ZpbGUpKSB7XG4gICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBPYmplY3QuYXNzaWduKCkgY29waWVzIHRoZSB2YWx1ZXMgb2Ygb25seVxuICAgICAgICAgICAgLy8gdGhlIHRvcCBsZXZlbCBwcm9wZXJ0aWVzLiBJbiBvcmRlciB0byBkZWVwIGNvcHkgdGhlIG9iamVjdCwgd2VcbiAgICAgICAgICAgIC8vIHN0cmluZ2lmeSBhbmQgcGFyc2UgdGhlIG9iamVjdC5cbiAgICAgICAgICAgIHRoaXMuX2JhbmR3aWR0aFByb2ZpbGUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGJhbmR3aWR0aFByb2ZpbGUpKTtcbiAgICAgICAgICAgIHRoaXMuX2JhbmR3aWR0aFByb2ZpbGVSZXZpc2lvbisrO1xuICAgICAgICAgICAgdGhpcy5kaWRVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogcmV0dXJucyBjdXJyZW50IHtAbGluayBFbmNvZGluZ1BhcmFtZXRlcnNJbXBsfS5cbiAgICAgKiBAcmV0dXJucyB7RW5jb2RpbmdQYXJhbWV0ZXJzSW1wbH1cbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50VjIucHJvdG90eXBlLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHtAbGluayBFbmNvZGluZ1BhcmFtZXRlcnN9LlxuICAgICAqIEBwYXJhbSB7P0VuY29kaW5nUGFyYW1ldGVyc30gZW5jb2RpbmdQYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudFYyLnByb3RvdHlwZS5zZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKGVuY29kaW5nUGFyYW1ldGVycykge1xuICAgICAgICB0aGlzLl9lbmNvZGluZ1BhcmFtZXRlcnMudXBkYXRlKGVuY29kaW5nUGFyYW1ldGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudFYyfSB3aXRoIHRoZSBuZXcgc3RhdGUuXG4gICAgICogQHBhcmFtIHtQdWJsaXNoZWR9IHB1Ymxpc2hlZFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnRWMi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHB1Ymxpc2hlZCkge1xuICAgICAgICBpZiAodGhpcy5fcHVibGlzaGVkUmV2aXNpb24gPj0gcHVibGlzaGVkLnJldmlzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wdWJsaXNoZWRSZXZpc2lvbiA9IHB1Ymxpc2hlZC5yZXZpc2lvbjtcbiAgICAgICAgcHVibGlzaGVkLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChwdWJsaWNhdGlvblN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxUcmFja1B1YmxpY2F0aW9uVjIgPSB0aGlzLnRyYWNrcy5nZXQocHVibGljYXRpb25TdGF0ZS5pZCk7XG4gICAgICAgICAgICBpZiAobG9jYWxUcmFja1B1YmxpY2F0aW9uVjIpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFRyYWNrUHVibGljYXRpb25WMi51cGRhdGUocHVibGljYXRpb25TdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge0RhdGFUcmFja1NlbmRlcnxNZWRpYVRyYWNrU2VuZGVyfSB0cmFja1NlbmRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtUcmFjay5Qcmlvcml0eX0gcHJpb3JpdHlcbiAgICAgKiBAcmV0dXJucyB7TG9jYWxUcmFja1B1YmxpY2F0aW9uVjJ9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudFYyLnByb3RvdHlwZS5fY3JlYXRlTG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nID0gZnVuY3Rpb24gKHRyYWNrU2VuZGVyLCBuYW1lLCBwcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuX0xvY2FsVHJhY2tQdWJsaWNhdGlvblYyKHRyYWNrU2VuZGVyLCBuYW1lLCBwcmlvcml0eSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9uVjJ9IGZvciB0aGUgZ2l2ZW4ge0BsaW5rIERhdGFUcmFja1NlbmRlcn1cbiAgICAgKiBvciB7QGxpbmsgTWVkaWFUcmFja1NlbmRlcn0gdG8gdGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50VjJ9LlxuICAgICAqIEBwYXJhbSB7RGF0YVRyYWNrU2VuZGVyfE1lZGlhVHJhY2tTZW5kZXJ9IHRyYWNrU2VuZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eVxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnRWMi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiAodHJhY2tTZW5kZXIsIG5hbWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFja1NlbmRlciwgbmFtZSwgcHJpb3JpdHkpO1xuICAgICAgICB2YXIgcHVibGljYXRpb24gPSB0aGlzLmdldFB1YmxpY2F0aW9uKHRyYWNrU2VuZGVyKTtcbiAgICAgICAgdmFyIGlzRW5hYmxlZCA9IHB1YmxpY2F0aW9uLmlzRW5hYmxlZCwgdXBkYXRlZFByaW9yaXR5ID0gcHVibGljYXRpb24udXBkYXRlZFByaW9yaXR5O1xuICAgICAgICB2YXIgdXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFRoZSBMb2NhbFBhcnRpY2lwYW50VjIncyBzdGF0ZSBpcyBvbmx5IHB1Ymxpc2hlZCBpZlxuICAgICAgICAgICAgLy8gdGhlIFwidXBkYXRlZFwiIGV2ZW50IGlzIGVtaXR0ZWQgZHVlIHRvIExvY2FsVHJhY2tQdWJsaWNhdGlvblYyJ3NcbiAgICAgICAgICAgIC8vIC5pc0VuYWJsZWQgb3IgLnVwZGF0ZWRQcmlvcml0eSBiZWluZyBjaGFuZ2VkLiBXZSBkbyBub3QgcHVibGlzaCBpZiBpdCBpcyBmaXJlZCBkdWUgdG8gdGhlXG4gICAgICAgICAgICAvLyBMb2NhbFRyYWNrUHVibGljYXRpb25WMidzIC5zaWQgYmVpbmcgc2V0LlxuICAgICAgICAgICAgaWYgKGlzRW5hYmxlZCAhPT0gcHVibGljYXRpb24uaXNFbmFibGVkIHx8IHVwZGF0ZWRQcmlvcml0eSAhPT0gcHVibGljYXRpb24udXBkYXRlZFByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlkVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgaXNFbmFibGVkID0gcHVibGljYXRpb24uaXNFbmFibGVkO1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRQcmlvcml0eSA9IHB1YmxpY2F0aW9uLnVwZGF0ZWRQcmlvcml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcHVibGljYXRpb24ub24oJ3VwZGF0ZWQnLCB1cGRhdGVkKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIocHVibGljYXRpb24pO1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMuc2V0KHB1YmxpY2F0aW9uLCBmdW5jdGlvbiAoKSB7IHJldHVybiBwdWJsaWNhdGlvbi5yZW1vdmVMaXN0ZW5lcigndXBkYXRlZCcsIHVwZGF0ZWQpOyB9KTtcbiAgICAgICAgdGhpcy5kaWRVcGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TG9jYWxUcmFja1B1YmxpY2F0aW9uVjJ9IHB1YmxpY2F0aW9uXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudFYyLnByb3RvdHlwZS5fcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAocHVibGljYXRpb24pIHtcbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVyID0gdGhpcy5fcmVtb3ZlTGlzdGVuZXJzLmdldChwdWJsaWNhdGlvbik7XG4gICAgICAgIGlmIChyZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudFYyfS5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnRWMi5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXZpc2lvbjogdGhpcy5yZXZpc2lvbixcbiAgICAgICAgICAgIHRyYWNrczogQXJyYXkuZnJvbSh0aGlzLnRyYWNrcy52YWx1ZXMoKSkubWFwKGZ1bmN0aW9uICh0cmFjaykgeyByZXR1cm4gdHJhY2suZ2V0U3RhdGUoKTsgfSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluY3JlbWVudCB0aGUgcmV2aXNpb24gZm9yIHRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudFYyfS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnRWMi5wcm90b3R5cGUuZGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZXZpc2lvbisrO1xuICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvblYyfSBmb3IgdGhlIGdpdmVuIHtAbGluayBEYXRhVHJhY2tTZW5kZXJ9XG4gICAgICogb3Ige0BsaW5rIE1lZGlhVHJhY2tTZW5kZXJ9IGZyb20gdGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50VjJ9LlxuICAgICAqIEBwYXJhbSB7RGF0YVRyYWNrU2VuZGVyfE1lZGlhVHJhY2tTZW5kZXJ9IHRyYWNrU2VuZGVyXG4gICAgICogQHJldHVybnMgez9Mb2NhbFRyYWNrUHVibGljYXRpb25WMn1cbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50VjIucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gKHRyYWNrU2VuZGVyKSB7XG4gICAgICAgIHZhciBwdWJsaWNhdGlvbiA9IF9zdXBlci5wcm90b3R5cGUucmVtb3ZlVHJhY2suY2FsbCh0aGlzLCB0cmFja1NlbmRlcik7XG4gICAgICAgIGlmIChwdWJsaWNhdGlvbikge1xuICAgICAgICAgICAgdHJhY2tTZW5kZXIucmVtb3ZlQ2xvbmUocHVibGljYXRpb24udHJhY2tUcmFuc2NlaXZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcihwdWJsaWNhdGlvbik7XG4gICAgICAgICAgICB0aGlzLmRpZFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHZlcmJvc2l0eSBvZiBuZXR3b3JrIHF1YWxpdHkgaW5mb3JtYXRpb24uXG4gICAgICogQHBhcmFtIHtOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb259IG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvblxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnRWMi5wcm90b3R5cGUuc2V0TmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uID0gZnVuY3Rpb24gKG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbikge1xuICAgICAgICB0aGlzLm5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbi51cGRhdGUobmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHVwZGF0ZXMgZW5jb2RpbmdzIGZvciBzaW11bGNhc3QgbGF5ZXJzLlxuICAgICAqIEBwYXJhbSB7VHJhY2suU0lEfSB0cmFja1NpZFxuICAgICAqIEBwYXJhbSB7QXJyYXk8e2VuYWJsZWQ6IGJvb2xlYW4sIGxheWVyX2luZGV4OiBudW1iZXJ9Pn0gZW5jb2RpbmdzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gc3RyaW5nIGluZGljYXRpbmcgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb24uIGNhbiBiZSBvbmUgb2ZcbiAgICAgKiAgXCJPS1wiLCBcIklOVkFMSURfSElOVFwiLCBcIkNPVUxEX05PVF9BUFBMWV9ISU5UXCIsIFwiVU5LTk9XTl9UUkFDS1wiXG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudFYyLnByb3RvdHlwZS5zZXRQdWJsaXNoZXJIaW50ID0gZnVuY3Rpb24gKHRyYWNrU2lkLCBlbmNvZGluZ3MpIHtcbiAgICAgICAgdmFyIHRyYWNrU2lnbmFsaW5nID0gQXJyYXkuZnJvbSh0aGlzLnRyYWNrcy52YWx1ZXMoKSkuZmluZChmdW5jdGlvbiAodHJhY2tQdWIpIHsgcmV0dXJuIHRyYWNrUHViLnNpZCA9PT0gdHJhY2tTaWQ7IH0pO1xuICAgICAgICBpZiAoIXRyYWNrU2lnbmFsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcInRyYWNrOlwiICsgdHJhY2tTaWQgKyBcIiBub3QgZm91bmRcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdVTktOT1dOX1RSQUNLJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYWNrU2lnbmFsaW5nLnRyYWNrVHJhbnNjZWl2ZXIuc2V0UHVibGlzaGVySGludChlbmNvZGluZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2FsUGFydGljaXBhbnRWMjtcbn0oTG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZykpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFB1Ymxpc2hlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJldmlzaW9uXG4gKiBAcHJvcGVydHkge0FycmF5PFB1Ymxpc2hlZFRyYWNrPn0gdHJhY2tzXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge0NyZWF0ZWRUcmFja3xSZWFkeVRyYWNrfEZhaWxlZFRyYWNrfSBQdWJsaXNoZWRUcmFja1xuICovXG4vKipcbiAqIEBpbnRlcmZhY2UgQ3JlYXRlZFRyYWNrXG4gKiBAcHJvcGVydHkge1RyYWNrLklEfSBpZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gXCJjcmVhdGVkXCJcbiAqL1xuLyoqXG4gKiBAaW50ZXJmYWNlIFJlYWR5VHJhY2tcbiAqIEBwcm9wZXJ0eSB7VHJhY2suSUR9IGlkXG4gKiBAcHJvcGVydHkge1RyYWNrLlNJRH0gc2lkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBcInJlYWR5XCJcbiAqL1xuLyoqXG4gKiBAaW50ZXJmYWNlIEZhaWxlZFRyYWNrXG4gKiBAcHJvcGVydHkge1RyYWNrLklEfSBpZFxuICogQHByb3BlcnR5IHtUcmFja0Vycm9yfSBlcnJvclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gXCJmYWlsZWRcIlxuICovXG4vKipcbiAqIEBpbnRlcmZhY2UgVHJhY2tFcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbi8qKlxuICogQGV2ZW50IExvY2FsUGFydGljaXBhbnRWMiN1cGRhdGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxQYXJ0aWNpcGFudFYyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxwYXJ0aWNpcGFudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZyA9IHJlcXVpcmUoJy4uL2xvY2FsdHJhY2twdWJsaWNhdGlvbicpO1xudmFyIGNyZWF0ZVR3aWxpb0Vycm9yID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90d2lsaW8tdmlkZW8tZXJyb3JzJykuY3JlYXRlVHdpbGlvRXJyb3I7XG4vKipcbiAqIEBleHRlbmRzIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ1xuICovXG52YXIgTG9jYWxUcmFja1B1YmxpY2F0aW9uVjIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvY2FsVHJhY2tQdWJsaWNhdGlvblYyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb25WMn0uXG4gICAgICogQHBhcmFtIHtEYXRhVHJhY2tTZW5kZXJ8TWVkaWFUcmFja1NlbmRlcn0gdHJhY2tTZW5kZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5XG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9jYWxUcmFja1B1YmxpY2F0aW9uVjIodHJhY2tTZW5kZXIsIG5hbWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB0cmFja1NlbmRlciwgbmFtZSwgcHJpb3JpdHkpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvblYyI1JlcHJlc2VudGF0aW9ufSBvZiBhIGdpdmVuIHtAbGluayBUcmFja1NpZ25hbGluZ30uXG4gICAgICogQHJldHVybnMge0xvY2FsVHJhY2tQdWJsaWNhdGlvblYyI1JlcHJlc2VudGF0aW9ufSAtIHdpdGhvdXQgdGhlIFNJRFxuICAgICAqL1xuICAgIExvY2FsVHJhY2tQdWJsaWNhdGlvblYyLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMuaXNFbmFibGVkLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBwcmlvcml0eTogdGhpcy51cGRhdGVkUHJpb3JpdHlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdGhlIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb25WMn0gdG8gYSB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9uVjIjUmVwcmVzZW50YXRpb259IG9mIGl0c2VsZlxuICAgICAqIGFuZCBwZXJmb3JtIGFueSB1cGRhdGVzIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0ge1B1Ymxpc2hlZFRyYWNrfSB0cmFja1xuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBmaXJlcyBUcmFja1NpZ25hbGluZyN1cGRhdGVkXG4gICAgICovXG4gICAgTG9jYWxUcmFja1B1YmxpY2F0aW9uVjIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICBzd2l0Y2ggKHRyYWNrLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdyZWFkeSc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTaWQodHJhY2suc2lkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6IHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSB0cmFjay5lcnJvcjtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hGYWlsZWQoY3JlYXRlVHdpbGlvRXJyb3IoZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDogLy8gJ2NyZWF0ZWQnXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxUcmFja1B1YmxpY2F0aW9uVjI7XG59KExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZykpO1xuLyoqXG4gKiBUaGUgUm9vbSBTaWduYWxpbmcgUHJvdG9jb2wgKFJTUCkgcmVwcmVzZW50YXRpb24gb2YgYSB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9uVjJ9LlxuICogQHR5cGVkZWYge29iamVjdH0gTG9jYWxUcmFja1B1YmxpY2F0aW9uVjIjUmVwcmVzZW50YXRpb25cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZW5hYmxlZFxuICogQHByb3BlcnR5IHtUcmFjay5JRH0gaWRcbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqIEBwcmlvcml0eSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5XG4gKiBAcHJvcGVydHkge1RyYWNrLlNJRH0gc2lkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxUcmFja1B1YmxpY2F0aW9uVjI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbHRyYWNrcHVibGljYXRpb24uanMubWFwIiwiLyogZXNsaW50IGNhbGxiYWNrLXJldHVybjowICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xudmFyIG5JbnN0YW5jZXMgPSAwO1xudmFyIE1lZGlhU2lnbmFsaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZWRpYVNpZ25hbGluZywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTWVkaWFTaWduYWxpbmd9LlxuICAgICAqIEBwYXJhbSB7UHJvbWlzZTxEYXRhVHJhY2tSZWNlaXZlcj59IGdldFJlY2VpdmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1lZGlhU2lnbmFsaW5nKGdldFJlY2VpdmVyLCBjaGFubmVsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfaW5zdGFuY2VJZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuSW5zdGFuY2VzKytcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFubmVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoYW5uZWwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xvZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmxvZy5jcmVhdGVMb2coJ2RlZmF1bHQnLCBfdGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0UmVjZWl2ZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0UmVjZWl2ZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVjZWl2ZXJQcm9taXNlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RyYW5zcG9ydDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZWRpYVNpZ25hbGluZy5wcm90b3R5cGUsIFwiaXNTZXR1cFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fcmVjZWl2ZXJQcm9taXNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWVkaWFTaWduYWxpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbTWVkaWFTaWduYWxpbmcgI1wiICsgdGhpcy5faW5zdGFuY2VJZCArIFwiOlwiICsgdGhpcy5jaGFubmVsICsgXCJdXCI7XG4gICAgfTtcbiAgICBNZWRpYVNpZ25hbGluZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdGVhcmRvd24oKTtcbiAgICAgICAgdGhpcy5fbG9nLmluZm8oJ3NldHRpbmcgdXAgbXNwIHRyYW5zcG9ydCBmb3IgaWQ6JywgaWQpO1xuICAgICAgICB2YXIgcmVjZWl2ZXJQcm9taXNlID0gdGhpcy5fZ2V0UmVjZWl2ZXIoaWQpLnRoZW4oZnVuY3Rpb24gKHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIua2luZCAhPT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5lcnJvcignRXhwZWN0ZWQgYSBEYXRhVHJhY2tSZWNlaXZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLl9yZWNlaXZlclByb21pc2UgIT09IHJlY2VpdmVyUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RyYW5zcG9ydCA9IHJlY2VpdmVyLnRvRGF0YVRyYW5zcG9ydCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3JlYWR5JywgX3RoaXMuX3RyYW5zcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmVycm9yKFwiRmFpbGVkIHRvIHRvRGF0YVRyYW5zcG9ydDogXCIgKyBleC5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY2VpdmVyLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3RlYXJkb3duKCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXJQcm9taXNlID0gcmVjZWl2ZXJQcm9taXNlO1xuICAgIH07XG4gICAgTWVkaWFTaWduYWxpbmcucHJvdG90eXBlLl90ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmluZm8oJ1RlYXJpbmcgZG93bicpO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlY2VpdmVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3RlYXJkb3duJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZWRpYVNpZ25hbGluZztcbn0oRXZlbnRFbWl0dGVyKSk7XG5tb2R1bGUuZXhwb3J0cyA9IE1lZGlhU2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWFzaWduYWxpbmcuanMubWFwIiwiLyogZXNsaW50IGNhbGxiYWNrLXJldHVybjowICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xudmFyIFBlZXJDb25uZWN0aW9uUmVwb3J0RmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uL3N0YXRzL3BlZXJjb25uZWN0aW9ucmVwb3J0ZmFjdG9yeScpO1xuLyoqXG4gKiBAZW1pdHMgTmV0d29ya1F1YWxpdHlNb25pdG9yI3VwZGF0ZWRcbiAqL1xudmFyIE5ldHdvcmtRdWFsaXR5TW9uaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV0d29ya1F1YWxpdHlNb25pdG9yLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBOZXR3b3JrUXVhbGl0eU1vbml0b3J9LlxuICAgICAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25NYW5hZ2VyfSBtYW5hZ2VyXG4gICAgICogQHBhcmFtIHtOZXR3b3JrUXVhbGl0eVNpZ25hbGluZ30gc2lnbmFsaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gTmV0d29ya1F1YWxpdHlNb25pdG9yKG1hbmFnZXIsIHNpZ25hbGluZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2ZhY3Rvcmllczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgV2Vha01hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21hbmFnZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWFuYWdlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2lnbmFsaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzaWduYWxpbmcub24oJ3VwZGF0ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5lbWl0KCd1cGRhdGVkJyk7IH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXR3b3JrUXVhbGl0eU1vbml0b3IucHJvdG90eXBlLCBcImxldmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0sIGlmIGFueS5cbiAgICAgICAgICogQHJldHVybnMgez9OZXR3b3JrUXVhbGl0eUxldmVsfSBsZXZlbCAtIGluaXRpYWxseSBudWxsXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduYWxpbmcubGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmV0d29ya1F1YWxpdHlNb25pdG9yLnByb3RvdHlwZSwgXCJsZXZlbHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsc30sIGlmIGFueS5cbiAgICAgICAgICogQHJldHVybnMgez9OZXR3b3JrUXVhbGl0eUxldmVsc30gbGV2ZWxzIC0gaW5pdGlhbGx5IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbGluZy5sZXZlbHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmV0d29ya1F1YWxpdHlNb25pdG9yLnByb3RvdHlwZSwgXCJyZW1vdGVMZXZlbHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsc30gb2YgcmVtb3RlIHBhcnRpY2lwYW50cywgaWYgYW55LlxuICAgICAgICAgKiBAcmV0dXJucyB7TWFwPFN0cmluZywgTmV0d29ya1F1YWxpdHlMZXZlbHM+fSByZW1vdGVMZXZlbHNcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbGluZy5yZW1vdGVMZXZlbHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBtb25pdG9yaW5nLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIE5ldHdvcmtRdWFsaXR5TW9uaXRvci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl90aW1lb3V0ICE9PSB0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dChfdGhpcykudGhlbihmdW5jdGlvbiAocmVwb3J0cykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fdGltZW91dCAhPT0gdGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQocmVwb3J0cywgMSksIHJlcG9ydCA9IF9hWzBdO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2lnbmFsaW5nLnB1dChyZXBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSB0aW1lb3V0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcCBtb25pdG9yaW5nLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIE5ldHdvcmtRdWFsaXR5TW9uaXRvci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBOZXR3b3JrUXVhbGl0eU1vbml0b3I7XG59KEV2ZW50RW1pdHRlcikpO1xuLyoqXG4gKiBAcGFyYW0ge05ldHdvcmtRdWFsaXR5TW9uaXRvcn1cbiAqIEByZXR1cm5zIHtQcm9taXNlPE5ldHdvcmtRdWFsaXR5SW5wdXRzPn1cbiAqL1xuZnVuY3Rpb24gbmV4dChtb25pdG9yKSB7XG4gICAgdmFyIHBjdjJzID0gbW9uaXRvci5fbWFuYWdlci5fcGVlckNvbm5lY3Rpb25zXG4gICAgICAgID8gQXJyYXkuZnJvbShtb25pdG9yLl9tYW5hZ2VyLl9wZWVyQ29ubmVjdGlvbnMudmFsdWVzKCkpXG4gICAgICAgIDogW107XG4gICAgdmFyIHBjcyA9IHBjdjJzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHBjdjIpIHsgcmV0dXJuIHBjdjIuX3BlZXJDb25uZWN0aW9uOyB9KVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwYykgeyByZXR1cm4gcGMuc2lnbmFsaW5nU3RhdGUgIT09ICdjbG9zZWQnOyB9KTtcbiAgICB2YXIgZmFjdG9yaWVzID0gcGNzLm1hcChmdW5jdGlvbiAocGMpIHtcbiAgICAgICAgaWYgKG1vbml0b3IuX2ZhY3Rvcmllcy5oYXMocGMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9uaXRvci5fZmFjdG9yaWVzLmdldChwYyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZhY3RvcnkgPSBuZXcgUGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5KHBjKTtcbiAgICAgICAgbW9uaXRvci5fZmFjdG9yaWVzLnNldChwYywgZmFjdG9yeSk7XG4gICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgIH0pO1xuICAgIHZhciByZXBvcnRzT3JOdWxsUHJvbWlzZXMgPSBmYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChmYWN0b3J5KSB7IHJldHVybiBmYWN0b3J5Lm5leHQoKS5jYXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9KTsgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHJlcG9ydHNPck51bGxQcm9taXNlcykudGhlbihmdW5jdGlvbiAocmVwb3J0c09yTnVsbCkgeyByZXR1cm4gcmVwb3J0c09yTnVsbFxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChyZXBvcnRPck51bGwpIHsgcmV0dXJuIHJlcG9ydE9yTnVsbDsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocmVwb3J0KSB7IHJldHVybiByZXBvcnQuc3VtbWFyaXplKCk7IH0pOyB9KTtcbn1cbi8qKlxuICogVGhlIHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfSBjaGFuZ2VkLlxuICogQGV2ZW50IE5ldHdvcmtRdWFsaXR5TW9uaXRvciN1cGRhdGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya1F1YWxpdHlNb25pdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29ya3F1YWxpdHltb25pdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTWVkaWFTaWduYWxpbmcgPSByZXF1aXJlKCcuL21lZGlhc2lnbmFsaW5nJyk7XG52YXIgQXN5bmNWYXIgPSByZXF1aXJlKCcuLi8uLi91dGlsL2FzeW5jdmFyJyk7XG52YXIgVGltZW91dCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdGltZW91dCcpO1xudmFyIE5FVFdPUktfUVVBTElUWV9SRVNQT05TRV9USU1FX01TID0gNTAwMDtcbi8qKlxuICogQGludGVyZmFjZSBNZWRpYVNpZ25hbGluZ1RyYW5zcG9ydFxuICogQHByb3BlcnR5IHtmdW5jdGlvbihvYmplY3QpOiBib29sZWFufSBzZW5kXG4gKiBAZW1pdHMgTWVkaWFTaWduYWxpbmdUcmFuc3BvcnQjbWVzc2FnZVxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgTWVkaWFTaWduYWxpbmdUcmFuc3BvcnR9IHJlY2VpdmVkIGEgbWVzc2FnZS5cbiAqIEBldmVudCBNZWRpYVNpZ25hbGluZ1RyYW5zcG9ydCNtZXNzYWdlXG4gKiBAcGFyYW0ge29iamVjdH0gbWVzc2FnZVxuICovXG4vKipcbiAqIEBpbnRlcmZhY2UgTGF0ZW5jeVN0YXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaml0dGVyXG4gKiBAcHJvcGVydHkge251bWJlcn0gcnR0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbGV2ZWxcbiAqL1xuLyoqXG4gKiBAaW50ZXJmYWNlIEZyYWN0aW9uTG9zdFN0YXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gZnJhY3Rpb25Mb3N0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbGV2ZWxcbiAqL1xuLyoqXG4gKiBAaW50ZXJmYWNlIEJhbmR3aWR0aFN0YXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gYWN0dWFsXG4gKiBAcHJvcGVydHkge251bWJlcn0gYXZhaWxhYmxlXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGV2ZWxcbiAqL1xuLyoqXG4gKiBAaW50ZXJmYWNlIFNlbmRPclJlY3ZTdGF0c1xuICogQHByb3BlcnR5IHtCYW5kd2lkdGhTdGF0c30gYmFuZHdpZHRoXG4gKiBAcHJvcGVydHkge0ZyYWN0aW9uTG9zdFN0YXRzfSBmcmFjdGlvbkxvc3RcbiAqIEBwcm9wZXJ0eSB7TGF0ZW5jeVN0YXRzfSBsYXRlbmN5XG4gKi9cbi8qKlxuICogQGludGVyZmFjZSBNZWRpYUxldmVsc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHNlbmRcbiAqIEBwcm9wZXJ0eSB7U2VuZE9yUmVjdlN0YXRzfSBzZW5kU3RhdHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWN2XG4gKiBAcHJvcGVydHkge1NlbmRPclJlY3ZTdGF0c30gcmVjdlN0YXRzXG4gKi9cbi8qKlxuICogQGludGVyZmFjZSBOZXR3b3JrUXVhbGl0eUxldmVsc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVsXG4gKiBAcHJvcGVydHkge01lZGlhTGV2ZWxzfSBhdWRpb1xuICogQHByb3BlcnR5IHtNZWRpYUxldmVsc30gdmlkZW9cbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7UGVlckNvbm5lY3Rpb25TdW1tYXJ5fSBOZXR3b3JrUXVhbGl0eUlucHV0c1xuICovXG4vKipcbiAqIEBjbGFzc2Rlc2MgVGhlIHtAbGluayBOZXR3b3JrUXVhbGl0eVNpZ25hbGluZ30gY2xhc3MgYWxsb3dzIHN1Ym1pdHRpbmdcbiAqICAge0BsaW5rIE5ldHdvcmtRdWFsaXR5SW5wdXRzfSBmb3IgY29tcHV0aW5nIHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfS4gSXRcbiAqICAgZG9lcyBzbyBieSBzZW5kaW5nIGFuZCByZWNlaXZpbmcgbWVzc2FnZXMgb3ZlciBhXG4gKiAgIHtAbGluayBNZWRpYVNpZ25hbGluZ1RyYW5zcG9ydH0uIFRoZSBleGFjdCB0cmFuc3BvcnQgdXNlZCBkZXBlbmRzIG9uIHRoZVxuICogICB0b3BvbG9neSBvZiB0aGUge0BsaW5rIFJvb219IHRoYXQge0BsaW5rIE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nfSBpcyBiZWluZ1xuICogICB1c2VkIHdpdGhpbjogZm9yIFAyUCBSb29tcywgd2UgcmUtdXNlIHRoZSB7QGxpbmsgVHJhbnNwb3J0VjJ9OyBhbmQgZm9yXG4gKiAgIEdyb3VwIFJvb21zLCB3ZSB1c2UgYSB7QGxpbmsgRGF0YVRyYW5zcG9ydH0uXG4gKiBAZW1pdHMgTmV0d29ya1F1YWxpdHlTaWduYWxpbmcjdXBkYXRlZFxuICovXG52YXIgTmV0d29ya1F1YWxpdHlTaWduYWxpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBOZXR3b3JrUXVhbGl0eVNpZ25hbGluZ30uXG4gICAgICogQHBhcmFtIHtQcm9taXNlPERhdGFUcmFja1JlY2VpdmVyPn0gZ2V0UmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0ge05ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbkltcGx9IG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nKGdldFJlY2VpdmVyLCBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ2V0UmVjZWl2ZXIsICduZXR3b3JrX3F1YWxpdHknLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2xldmVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbGV2ZWxzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVtb3RlTGV2ZWxzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9uZXR3b3JrUXVhbGl0eUlucHV0czoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgQXN5bmNWYXIoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZXNlbmRUaW1lcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgVGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBzY2hlZHVsZSBuZXh0IHRpbWVyIGF0IHgxLjUgdGhlIGRlbGF5Li5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2VuZFRpbWVyLnNldERlbGF5KF90aGlzLl9yZXNlbmRUaW1lci5kZWxheSAqIDEuNSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZW5kTmV0d29ya1F1YWxpdHlJbnB1dHMoKTtcbiAgICAgICAgICAgICAgICB9LCBORVRXT1JLX1FVQUxJVFlfUkVTUE9OU0VfVElNRV9NUywgZmFsc2UpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9uZXR3b3JrUXVhbGl0eVJlcG9ydExldmVsczoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0TGV2ZWw6IG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbi5sb2NhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZVJlcG9ydExldmVsOiBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24ucmVtb3RlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMub24oJ3JlYWR5JywgZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0Lm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKCdJbmNvbWluZzogJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmV0d29ya19xdWFsaXR5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVOZXR3b3JrUXVhbGl0eU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuX3NlbmROZXR3b3JrUXVhbGl0eUlucHV0cygpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXR3b3JrUXVhbGl0eVNpZ25hbGluZy5wcm90b3R5cGUsIFwibGV2ZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfSwgaWYgYW55LlxuICAgICAgICAgKiBAcmV0dXJucyB7P05ldHdvcmtRdWFsaXR5TGV2ZWx9IGxldmVsIC0gaW5pdGlhbGx5IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nLnByb3RvdHlwZSwgXCJsZXZlbHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsc30sIGlmIGFueS5cbiAgICAgICAgICogQHJldHVybnMgez9OZXR3b3JrUXVhbGl0eUxldmVsc30gbGV2ZWxzIC0gaW5pdGlhbGx5IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xldmVscztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXR3b3JrUXVhbGl0eVNpZ25hbGluZy5wcm90b3R5cGUsIFwicmVtb3RlTGV2ZWxzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbHN9IG9mIHJlbW90ZSBwYXJ0aWNpcGFudHMsIGlmIGFueS5cbiAgICAgICAgICogQHJldHVybnMge01hcDxTdHJpbmcsIE5ldHdvcmtRdWFsaXR5TGV2ZWxzPn0gcmVtb3RlTGV2ZWxzXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVMZXZlbHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfSBpcyBuZXcsIGFuZCByYWlzZSBhblxuICAgICAqIGV2ZW50IGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtZXNzYWdlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgTmV0d29ya1F1YWxpdHlTaWduYWxpbmcucHJvdG90eXBlLl9oYW5kbGVOZXR3b3JrUXVhbGl0eU1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgbGV2ZWwgPSBudWxsO1xuICAgICAgICB2YXIgbG9jYWwgPSBtZXNzYWdlID8gbWVzc2FnZS5sb2NhbCA6IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBOT1RFKG1yb2JlcnRzKTogSW4gcHJvZCwgd2UgcGxhbiB0byBvbmx5IHNlbmQgdGhlIGxldmVsLlxuICAgICAgICAgICAgbGV2ZWwgPSBsb2NhbDtcbiAgICAgICAgICAgIHRoaXMuX2xldmVscyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvY2FsID09PSAnb2JqZWN0JyAmJiBsb2NhbCkge1xuICAgICAgICAgICAgLy8gTk9URShtcm9iZXJ0cyk6IEluIGRldiwgd2UgcGxhbiB0byBzZW5kIHRoZSBkZWNvbXBvc2VkIGxldmVscy4gQW4gZWFybHlcbiAgICAgICAgICAgIC8vIFZNUyB2ZXJzaW9uIGRvZXMgbm90IGNvbXB1dGUgYGxldmVsYCBmb3IgdXMsIHNvIHdlIGZhbGxiYWNrIHRvIHRha2luZ1xuICAgICAgICAgICAgLy8gdGhlIG1pbmltdW0gb3Vyc2VsdmVzLlxuICAgICAgICAgICAgdGhpcy5fbGV2ZWxzID0gbG9jYWw7XG4gICAgICAgICAgICBsZXZlbCA9IHR5cGVvZiBsb2NhbC5sZXZlbCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IGxvY2FsLmxldmVsXG4gICAgICAgICAgICAgICAgOiBNYXRoLm1pbihsb2NhbC5hdWRpby5zZW5kLCBsb2NhbC5hdWRpby5yZWN2LCBsb2NhbC52aWRlby5zZW5kLCBsb2NhbC52aWRlby5yZWN2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgIT09IG51bGwgJiYgdGhpcy5sZXZlbCAhPT0gbGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVMZXZlbHMgPSBtZXNzYWdlICYmIG1lc3NhZ2UucmVtb3Rlc1xuICAgICAgICAgICAgPyBtZXNzYWdlLnJlbW90ZXMucmVkdWNlKGZ1bmN0aW9uIChsZXZlbHMsIG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBvbGRPYmogPSBfdGhpcy5fcmVtb3RlTGV2ZWxzLmdldChvYmouc2lkKSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAob2xkT2JqLmxldmVsICE9PSBvYmoubGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsZXZlbHMuc2V0KG9iai5zaWQsIG9iaik7XG4gICAgICAgICAgICB9LCBuZXcgTWFwKCkpXG4gICAgICAgICAgICA6IHRoaXMuX3JlbW90ZUxldmVscztcbiAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNjb3JlIGlzIHJlY2VpdmVkLiBzbyByZXNldCB0aGUgdGltZXIgdG8gZGVmYXVsdCB0aW1lb3V0LlxuICAgICAgICB0aGlzLl9yZXNlbmRUaW1lci5zZXREZWxheShORVRXT1JLX1FVQUxJVFlfUkVTUE9OU0VfVElNRV9NUyk7XG4gICAgICAgIC8vIHRpbWVyIGlzIGNsZWFyZWQgb25seSB3aGlsZSB3ZSBhcmUgc2VuZGluZyBpbnB1dHMuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBhbHJlYWR5IHNlbmRpbmcgaW5wdXRzIGRvIG5vdCBzZW5kIHRoZW0gYWdhaW4uXG4gICAgICAgIGlmICh0aGlzLl9yZXNlbmRUaW1lci5pc1NldCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc2VuZE5ldHdvcmtRdWFsaXR5SW5wdXRzKCk7IH0sIDEwMDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBzZW5kaW5nIHtAbGluayBOZXR3b3JrUXVhbGl0eUlucHV0c30uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBOZXR3b3JrUXVhbGl0eVNpZ25hbGluZy5wcm90b3R5cGUuX3NlbmROZXR3b3JrUXVhbGl0eUlucHV0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fcmVzZW5kVGltZXIuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcmtRdWFsaXR5SW5wdXRzLnRha2UoKS50aGVuKGZ1bmN0aW9uIChuZXR3b3JrUXVhbGl0eUlucHV0cykge1xuICAgICAgICAgICAgaWYgKF90aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdHJhbnNwb3J0LnB1Ymxpc2goY3JlYXRlTmV0d29ya1F1YWxpdHlJbnB1dHNNZXNzYWdlKG5ldHdvcmtRdWFsaXR5SW5wdXRzLCBfdGhpcy5fbmV0d29ya1F1YWxpdHlSZXBvcnRMZXZlbHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVzZW5kVGltZXIuc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXQge0BsaW5rIE5ldHdvcmtRdWFsaXR5SW5wdXRzfSB0byBiZSB1c2VkIGZvciBjb21wdXRpbmdcbiAgICAgKiB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0uXG4gICAgICogQHBhcmFtIHtOZXR3b3JrUXVhbGl0eUlucHV0c30gbmV0d29ya1F1YWxpdHlJbnB1dHNcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBOZXR3b3JrUXVhbGl0eVNpZ25hbGluZy5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKG5ldHdvcmtRdWFsaXR5SW5wdXRzKSB7XG4gICAgICAgIHRoaXMuX25ldHdvcmtRdWFsaXR5SW5wdXRzLnB1dChuZXR3b3JrUXVhbGl0eUlucHV0cyk7XG4gICAgfTtcbiAgICByZXR1cm4gTmV0d29ya1F1YWxpdHlTaWduYWxpbmc7XG59KE1lZGlhU2lnbmFsaW5nKSk7XG4vKipcbiAqIFRoZSB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gY2hhbmdlZC5cbiAqIEBldmVudCBOZXR3b3JrUXVhbGl0eVNpZ25hbGluZyN1cGRhdGVkXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gTmV0d29ya1F1YWxpdHlSZXBvcnRMZXZlbHNcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXBvcnRMZXZlbFxuICogQHBhcmFtIHtudW1iZXJ9IHJlbW90ZVJlcG9ydExldmVsXG4gKi9cbi8qKlxuICogQHBhcmFtIHtOZXR3b3JrUXVhbGl0eUlucHV0c30gbmV0d29ya1F1YWxpdHlJbnB1dHNcbiAqIEBwYXJhbSB7TmV0d29ya1F1YWxpdHlSZXBvcnRMZXZlbHN9IG5ldHdvcmtRdWFsaXR5UmVwb3J0TGV2ZWxzXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5ldHdvcmtRdWFsaXR5SW5wdXRzTWVzc2FnZShuZXR3b3JrUXVhbGl0eUlucHV0cywgbmV0d29ya1F1YWxpdHlSZXBvcnRMZXZlbHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICduZXR3b3JrX3F1YWxpdHknIH0sIG5ldHdvcmtRdWFsaXR5SW5wdXRzLCBuZXR3b3JrUXVhbGl0eVJlcG9ydExldmVscyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29ya3F1YWxpdHlzaWduYWxpbmcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xuICAgIHJldHVybiB0bztcbn07XG52YXIgRGVmYXVsdEJhY2tvZmYgPSByZXF1aXJlKCdiYWNrb2ZmJyk7XG52YXIgX2EgPSByZXF1aXJlKCcuLi8uLi93ZWJydGMnKSwgRGVmYXVsdFJUQ0ljZUNhbmRpZGF0ZSA9IF9hLlJUQ0ljZUNhbmRpZGF0ZSwgRGVmYXVsdFJUQ1BlZXJDb25uZWN0aW9uID0gX2EuUlRDUGVlckNvbm5lY3Rpb24sIERlZmF1bHRSVENTZXNzaW9uRGVzY3JpcHRpb24gPSBfYS5SVENTZXNzaW9uRGVzY3JpcHRpb24sIGdldFN0YXRpc3RpY3MgPSBfYS5nZXRTdGF0cztcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vd2VicnRjL3V0aWwnKTtcbnZhciBfYiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uc3RhbnRzJyksIERFRkFVTFRfSUNFX0dBVEhFUklOR19USU1FT1VUX01TID0gX2IuREVGQVVMVF9JQ0VfR0FUSEVSSU5HX1RJTUVPVVRfTVMsIERFRkFVTFRfTE9HX0xFVkVMID0gX2IuREVGQVVMVF9MT0dfTEVWRUwsIERFRkFVTFRfU0VTU0lPTl9USU1FT1VUX1NFQyA9IF9iLkRFRkFVTFRfU0VTU0lPTl9USU1FT1VUX1NFQywgaWNlUmVzdGFydEJhY2tvZmZDb25maWcgPSBfYi5pY2VSZXN0YXJ0QmFja29mZkNvbmZpZztcbnZhciBfYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvc2RwJyksIGFkZE9yUmV3cml0ZU5ld1RyYWNrSWRzID0gX2MuYWRkT3JSZXdyaXRlTmV3VHJhY2tJZHMsIGFkZE9yUmV3cml0ZVRyYWNrSWRzID0gX2MuYWRkT3JSZXdyaXRlVHJhY2tJZHMsIGNyZWF0ZUNvZGVjTWFwRm9yTWVkaWFTZWN0aW9uID0gX2MuY3JlYXRlQ29kZWNNYXBGb3JNZWRpYVNlY3Rpb24sIGRpc2FibGVSdHggPSBfYy5kaXNhYmxlUnR4LCBlbmFibGVEdHhGb3JPcHVzID0gX2MuZW5hYmxlRHR4Rm9yT3B1cywgZmlsdGVyTG9jYWxDb2RlY3MgPSBfYy5maWx0ZXJMb2NhbENvZGVjcywgZ2V0TWVkaWFTZWN0aW9ucyA9IF9jLmdldE1lZGlhU2VjdGlvbnMsIHJlbW92ZVNTUkNBdHRyaWJ1dGVzID0gX2MucmVtb3ZlU1NSQ0F0dHJpYnV0ZXMsIHJldmVydFNpbXVsY2FzdCA9IF9jLnJldmVydFNpbXVsY2FzdCwgc2V0Q29kZWNQcmVmZXJlbmNlcyA9IF9jLnNldENvZGVjUHJlZmVyZW5jZXMsIHNldFNpbXVsY2FzdCA9IF9jLnNldFNpbXVsY2FzdDtcbnZhciBEZWZhdWx0VGltZW91dCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdGltZW91dCcpO1xudmFyIF9kID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90d2lsaW8tdmlkZW8tZXJyb3JzJyksIE1lZGlhQ2xpZW50TG9jYWxEZXNjRmFpbGVkRXJyb3IgPSBfZC5NZWRpYUNsaWVudExvY2FsRGVzY0ZhaWxlZEVycm9yLCBNZWRpYUNsaWVudFJlbW90ZURlc2NGYWlsZWRFcnJvciA9IF9kLk1lZGlhQ2xpZW50UmVtb3RlRGVzY0ZhaWxlZEVycm9yO1xudmFyIF9lID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLCBidWlsZExvZ0xldmVscyA9IF9lLmJ1aWxkTG9nTGV2ZWxzLCBnZXRQbGF0Zm9ybSA9IF9lLmdldFBsYXRmb3JtLCBpc0Nocm9tZVNjcmVlblNoYXJlVHJhY2sgPSBfZS5pc0Nocm9tZVNjcmVlblNoYXJlVHJhY2ssIG9uY2VQZXJUaWNrID0gX2Uub25jZVBlclRpY2ssIGRlZmVyID0gX2UuZGVmZXI7XG52YXIgSWNlQm94ID0gcmVxdWlyZSgnLi9pY2Vib3gnKTtcbnZhciBEZWZhdWx0SWNlQ29ubmVjdGlvbk1vbml0b3IgPSByZXF1aXJlKCcuL2ljZWNvbm5lY3Rpb25tb25pdG9yLmpzJyk7XG52YXIgRGF0YVRyYWNrUmVjZWl2ZXIgPSByZXF1aXJlKCcuLi8uLi9kYXRhL3JlY2VpdmVyJyk7XG52YXIgTWVkaWFUcmFja1JlY2VpdmVyID0gcmVxdWlyZSgnLi4vLi4vbWVkaWEvdHJhY2svcmVjZWl2ZXInKTtcbnZhciBTdGF0ZU1hY2hpbmUgPSByZXF1aXJlKCcuLi8uLi9zdGF0ZW1hY2hpbmUnKTtcbnZhciBMb2cgPSByZXF1aXJlKCcuLi8uLi91dGlsL2xvZycpO1xudmFyIFRyYWNrTWF0Y2hlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvc2RwL3RyYWNrbWF0Y2hlcicpO1xudmFyIHdvcmthcm91bmRJc3N1ZTgzMjkgPSByZXF1aXJlKCcuLi8uLi91dGlsL3NkcC9pc3N1ZTgzMjknKTtcbnZhciBndWVzcyA9IHV0aWwuZ3Vlc3NCcm93c2VyKCk7XG52YXIgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybSgpO1xudmFyIGlzQW5kcm9pZCA9IC9hbmRyb2lkLy50ZXN0KHBsYXRmb3JtKTtcbnZhciBpc0Nocm9tZSA9IGd1ZXNzID09PSAnY2hyb21lJztcbnZhciBpc0ZpcmVmb3ggPSBndWVzcyA9PT0gJ2ZpcmVmb3gnO1xudmFyIGlzU2FmYXJpID0gZ3Vlc3MgPT09ICdzYWZhcmknO1xudmFyIG5JbnN0YW5jZXMgPSAwO1xuLypcblBlZXJDb25uZWN0aW9uVjIgU3RhdGVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgKy0tLS0tLSsgICAgKy0tLS0tLS0tK1xuICAgIHwgICAgICB8ICAgIHwgICAgICAgIHxcbiAgICB8IG9wZW4gfC0tLT58IGNsb3NlZCB8XG4gICAgfCAgICAgIHwgICAgfCAgICAgICAgfFxuICAgICstLS0tLS0rICAgICstLS0tLS0tLStcbiAgICAgIHwgIF4gICAgICAgICAgXlxuICAgICAgfCAgfCAgICAgICAgICB8XG4gICAgICB8ICB8ICAgICAgICAgIHxcbiAgICAgIHYgIHwgICAgICAgICAgfFxuICArLS0tLS0tLS0tLSsgICAgICB8XG4gIHwgICAgICAgICAgfCAgICAgIHxcbiAgfCB1cGRhdGluZyB8LS0tLS0tK1xuICB8ICAgICAgICAgIHxcbiAgKy0tLS0tLS0tLS0rXG5cbiovXG52YXIgc3RhdGVzID0ge1xuICAgIG9wZW46IFtcbiAgICAgICAgJ2Nsb3NlZCcsXG4gICAgICAgICd1cGRhdGluZydcbiAgICBdLFxuICAgIHVwZGF0aW5nOiBbXG4gICAgICAgICdjbG9zZWQnLFxuICAgICAgICAnb3BlbidcbiAgICBdLFxuICAgIGNsb3NlZDogW11cbn07XG4vKipcbiAqIEBleHRlbmRzIFN0YXRlTWFjaGluZVxuICogQHByb3BlcnR5IHtpZH1cbiAqIEBlbWl0cyBQZWVyQ29ubmVjdGlvblYyI2Nvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcbiAqIEBlbWl0cyBQZWVyQ29ubmVjdGlvblYyI2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcbiAqIEBlbWl0cyBQZWVyQ29ubmVjdGlvblYyI2NhbmRpZGF0ZXNcbiAqIEBlbWl0cyBQZWVyQ29ubmVjdGlvblYyI2Rlc2NyaXB0aW9uXG4gKi9cbnZhciBQZWVyQ29ubmVjdGlvblYyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQZWVyQ29ubmVjdGlvblYyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge0VuY29kaW5nUGFyYW1ldGVyc0ltcGx9IGVuY29kaW5nUGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7UHJlZmVycmVkQ29kZWNzfSBwcmVmZXJyZWRDb2RlY3NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGVlckNvbm5lY3Rpb25WMihpZCwgZW5jb2RpbmdQYXJhbWV0ZXJzLCBwcmVmZXJyZWRDb2RlY3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ29wZW4nLCBzdGF0ZXMpIHx8IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGVuYWJsZURzY3A6IGZhbHNlLFxuICAgICAgICAgICAgZHVtbXlBdWRpb01lZGlhU3RyZWFtVHJhY2s6IG51bGwsXG4gICAgICAgICAgICBpc0Nocm9tZVNjcmVlblNoYXJlVHJhY2s6IGlzQ2hyb21lU2NyZWVuU2hhcmVUcmFjayxcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgbG9nTGV2ZWw6IERFRkFVTFRfTE9HX0xFVkVMLFxuICAgICAgICAgICAgb2ZmZXJPcHRpb25zOiB7fSxcbiAgICAgICAgICAgIHJldmVydFNpbXVsY2FzdDogcmV2ZXJ0U2ltdWxjYXN0LFxuICAgICAgICAgICAgc2Vzc2lvblRpbWVvdXQ6IERFRkFVTFRfU0VTU0lPTl9USU1FT1VUX1NFQyAqIDEwMDAsXG4gICAgICAgICAgICBzZXRDb2RlY1ByZWZlcmVuY2VzOiBzZXRDb2RlY1ByZWZlcmVuY2VzLFxuICAgICAgICAgICAgc2V0U2ltdWxjYXN0OiBzZXRTaW11bGNhc3QsXG4gICAgICAgICAgICBCYWNrb2ZmOiBEZWZhdWx0QmFja29mZixcbiAgICAgICAgICAgIEljZUNvbm5lY3Rpb25Nb25pdG9yOiBEZWZhdWx0SWNlQ29ubmVjdGlvbk1vbml0b3IsXG4gICAgICAgICAgICBSVENJY2VDYW5kaWRhdGU6IERlZmF1bHRSVENJY2VDYW5kaWRhdGUsXG4gICAgICAgICAgICBSVENQZWVyQ29ubmVjdGlvbjogRGVmYXVsdFJUQ1BlZXJDb25uZWN0aW9uLFxuICAgICAgICAgICAgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uOiBEZWZhdWx0UlRDU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgVGltZW91dDogRGVmYXVsdFRpbWVvdXRcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBjb25maWd1cmF0aW9uID0gZ2V0Q29uZmlndXJhdGlvbihvcHRpb25zKTtcbiAgICAgICAgdmFyIGxvZ0xldmVscyA9IGJ1aWxkTG9nTGV2ZWxzKG9wdGlvbnMubG9nTGV2ZWwpO1xuICAgICAgICB2YXIgUlRDUGVlckNvbm5lY3Rpb24gPSBvcHRpb25zLlJUQ1BlZXJDb25uZWN0aW9uO1xuICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVEc2NwID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNocm9tZVNwZWNpZmljQ29uc3RyYWludHMgPSBvcHRpb25zLmNocm9tZVNwZWNpZmljQ29uc3RyYWludHMgfHwge307XG4gICAgICAgICAgICBvcHRpb25zLmNocm9tZVNwZWNpZmljQ29uc3RyYWludHMub3B0aW9uYWwgPSBvcHRpb25zLmNocm9tZVNwZWNpZmljQ29uc3RyYWludHMub3B0aW9uYWwgfHwgW107XG4gICAgICAgICAgICBvcHRpb25zLmNocm9tZVNwZWNpZmljQ29uc3RyYWludHMub3B0aW9uYWwucHVzaCh7IGdvb2dEc2NwOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2cgPSBvcHRpb25zLmxvZyA/IG9wdGlvbnMubG9nLmNyZWF0ZUxvZygnd2VicnRjJywgX3RoaXMpIDogbmV3IExvZygnd2VicnRjJywgX3RoaXMsIGxvZ0xldmVscywgb3B0aW9ucy5sb2dnZXJOYW1lKTtcbiAgICAgICAgdmFyIHBlZXJDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGNvbmZpZ3VyYXRpb24sIG9wdGlvbnMuY2hyb21lU3BlY2lmaWNDb25zdHJhaW50cyk7XG4gICAgICAgIGlmIChvcHRpb25zLmR1bW15QXVkaW9NZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5hZGRUcmFjayhvcHRpb25zLmR1bW15QXVkaW9NZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2FwcGxpZWRUcmFja0lkc1RvQXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZGF0YUNoYW5uZWxzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kYXRhVHJhY2tSZWNlaXZlcnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFNldCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2Rlc2NyaXB0aW9uUmV2aXNpb246IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kaWRHZW5lcmF0ZUxvY2FsQ2FuZGlkYXRlczoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9lbmFibGVEc2NwOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuZW5hYmxlRHNjcFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9lbmNvZGluZ1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZW5jb2RpbmdQYXJhbWV0ZXJzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzQ2hyb21lU2NyZWVuU2hhcmVUcmFjazoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmlzQ2hyb21lU2NyZWVuU2hhcmVUcmFjayxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaWNlR2F0aGVyaW5nRmFpbGVkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2ljZUdhdGhlcmluZ1RpbWVvdXQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IG9wdGlvbnMuVGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faGFuZGxlSWNlR2F0aGVyaW5nVGltZW91dCgpOyB9LCBERUZBVUxUX0lDRV9HQVRIRVJJTkdfVElNRU9VVF9NUywgZmFsc2UpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2ljZVJlc3RhcnRCYWNrb2ZmOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuQmFja29mZi5leHBvbmVudGlhbChpY2VSZXN0YXJ0QmFja29mZkNvbmZpZylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW5zdGFuY2VJZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiArK25JbnN0YW5jZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaXNJY2VDb25uZWN0aW9uSW5hY3RpdmU6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaXNJY2VMaXRlOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzSWNlUmVzdGFydEJhY2tvZmZJblByb2dyZXNzOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzUmVzdGFydGluZ0ljZToge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sYXN0SWNlQ29ubmVjdGlvblN0YXRlOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbGFzdFN0YWJsZURlc2NyaXB0aW9uUmV2aXNpb246IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sb2NhbENhbmRpZGF0ZXM6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9jYWxDb2RlY3M6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFNldCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xvY2FsQ2FuZGlkYXRlc1JldmlzaW9uOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9jYWxEZXNjcmlwdGlvbldpdGhvdXRTaW11bGNhc3Q6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sb2NhbERlc2NyaXB0aW9uOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9jYWxVZnJhZzoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xvZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsb2dcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZXZlbnRPYnNlcnZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmV2ZW50T2JzZXJ2ZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVtb3RlQ29kZWNNYXBzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9ydHBTZW5kZXJzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9ydHBOZXdTZW5kZXJzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pY2VDb25uZWN0aW9uTW9uaXRvcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgb3B0aW9ucy5JY2VDb25uZWN0aW9uTW9uaXRvcihwZWVyQ29ubmVjdGlvbilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWVkaWFUcmFja1JlY2VpdmVyczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbmVlZHNBbnN3ZXI6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbmVnb3RpYXRpb25Sb2xlOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb2ZmZXJPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMub2ZmZXJPcHRpb25zXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uRW5jb2RpbmdQYXJhbWV0ZXJzQ2hhbmdlZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvbmNlUGVyVGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX25lZWRzQW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVFbmNvZGluZ1BhcmFtZXRlcnMoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcGVlckNvbm5lY3Rpb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGVlckNvbm5lY3Rpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcHJlZmVycmVkQXVkaW9Db2RlY3M6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJlZmVycmVkQ29kZWNzLmF1ZGlvXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ByZWZlcnJlZFZpZGVvQ29kZWNzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHByZWZlcnJlZENvZGVjcy52aWRlb1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaG91bGRBcHBseUR0eDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcmVmZXJyZWRDb2RlY3MuYXVkaW8uZXZlcnkoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2RlYyA9IF9hLmNvZGVjO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWMgIT09ICdvcHVzJztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB8fCBwcmVmZXJyZWRDb2RlY3MuYXVkaW8uc29tZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlYyA9IF9hLmNvZGVjLCBkdHggPSBfYS5kdHg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWMgPT09ICdvcHVzJyAmJiBkdHg7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3F1ZXVlZERlc2NyaXB0aW9uOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaWNlUmVjb25uZWN0VGltZW91dDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgb3B0aW9ucy5UaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKCdJQ0UgcmVjb25uZWN0IHRpbWVkIG91dCcpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuc2Vzc2lvblRpbWVvdXQsIGZhbHNlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZWN5Y2xlZFRyYW5zY2VpdmVyczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgdmlkZW86IFtdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZXBsYWNlVHJhY2tQcm9taXNlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVtb3RlQ2FuZGlkYXRlczoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgSWNlQm94KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2V0Q29kZWNQcmVmZXJlbmNlczoge1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFJlLW9yZGVyaW5nIHBheWxvYWQgdHlwZXMgaW4gb3JkZXIgdG8gbWFrZSBzdXJlIGEgbm9uLUgyNjRcbiAgICAgICAgICAgICAgICAvLyBwcmVmZXJyZWQgY29kZWMgaXMgc2VsZWN0ZWQgZG9lcyBub3Qgd29yayBvbiBBbmRyb2lkIEZpcmVmb3ggZHVlIHRvIHRoaXMgYmVoYXZpb3I6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTY4MzI1OC4gU28sIHdlIHdvcmsgYXJvdW5kIHRoaXMgYnlcbiAgICAgICAgICAgICAgICAvLyBub3QgYXBwbHlpbmcgYW55IG5vbi1IMjY0IHByZWZlcnJlZCB2aWRlbyBjb2RlYy5cbiAgICAgICAgICAgICAgICB2YWx1ZTogaXNGaXJlZm94ICYmIGlzQW5kcm9pZCAmJiBwcmVmZXJyZWRDb2RlY3MudmlkZW9bMF0gJiYgcHJlZmVycmVkQ29kZWNzLnZpZGVvWzBdLmNvZGVjLnRvTG93ZXJDYXNlKCkgIT09ICdoMjY0J1xuICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uIChzZHApIHsgcmV0dXJuIHNkcDsgfVxuICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbnMuc2V0Q29kZWNQcmVmZXJlbmNlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZXRTaW11bGNhc3Q6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5zZXRTaW11bGNhc3RcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmV2ZXJ0U2ltdWxjYXN0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMucmV2ZXJ0U2ltdWxjYXN0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX1JUQ0ljZUNhbmRpZGF0ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLlJUQ0ljZUNhbmRpZGF0ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9SVENQZWVyQ29ubmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLlJUQ1BlZXJDb25uZWN0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX1JUQ1Nlc3Npb25EZXNjcmlwdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLlJUQ1Nlc3Npb25EZXNjcmlwdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaG91bGRPZmZlcjoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaG91bGRSZXN0YXJ0SWNlOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RyYWNrSWRzVG9BdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90cmFja01hdGNoZXI6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9tZWRpYVRyYWNrU2VuZGVyVG9QdWJsaXNoZXJIaW50czoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMub24oJ2NoYW5nZWQnLCBfdGhpcy5fb25FbmNvZGluZ1BhcmFtZXRlcnNDaGFuZ2VkKTtcbiAgICAgICAgcGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgX3RoaXMuX2hhbmRsZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZS5iaW5kKF90aGlzKSk7XG4gICAgICAgIHBlZXJDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2RhdGFjaGFubmVsJywgX3RoaXMuX2hhbmRsZURhdGFDaGFubmVsRXZlbnQuYmluZChfdGhpcykpO1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCBfdGhpcy5faGFuZGxlSWNlQ2FuZGlkYXRlRXZlbnQuYmluZChfdGhpcykpO1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBfdGhpcy5faGFuZGxlSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgcGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCBfdGhpcy5faGFuZGxlSWNlR2F0aGVyaW5nU3RhdGVDaGFuZ2UuYmluZChfdGhpcykpO1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdzaWduYWxpbmdzdGF0ZWNoYW5nZScsIF90aGlzLl9oYW5kbGVTaWduYWxpbmdTdGF0ZUNoYW5nZS5iaW5kKF90aGlzKSk7XG4gICAgICAgIHBlZXJDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgX3RoaXMuX2hhbmRsZVRyYWNrRXZlbnQuYmluZChfdGhpcykpO1xuICAgICAgICBfdGhpcy5faWNlUmVzdGFydEJhY2tvZmYub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2luaXRpYXRlSWNlUmVzdGFydCgpOyB9KTtcbiAgICAgICAgdmFyIHNlbGYgPSBfdGhpcztcbiAgICAgICAgX3RoaXMub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3N0YXRlQ2hhbmdlZCcsIHN0YXRlQ2hhbmdlZCk7XG4gICAgICAgICAgICBzZWxmLl9kYXRhQ2hhbm5lbHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUNoYW5uZWwsIGRhdGFUcmFja1NlbmRlcikge1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlRGF0YVRyYWNrU2VuZGVyKGRhdGFUcmFja1NlbmRlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltQZWVyQ29ubmVjdGlvblYyICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyBcIjogXCIgKyB0aGlzLmlkICsgXCJdXCI7XG4gICAgfTtcbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5zZXRFZmZlY3RpdmVBZGFwdGl2ZVNpbXVsY2FzdCA9IGZ1bmN0aW9uIChlZmZlY3RpdmVBZGFwdGl2ZVNpbXVsY2FzdCkge1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ1NldHRpbmcgc2V0RWZmZWN0aXZlQWRhcHRpdmVTaW11bGNhc3Q6ICcsIGVmZmVjdGl2ZUFkYXB0aXZlU2ltdWxjYXN0KTtcbiAgICAgICAgLy8gY2xlYXIgYWRhcHRpdmUgc2ltdWxjYXN0IGZyb20gY29kZWMgcHJlZmVyZW5jZXMgaWYgaXQgd2FzIHNldC5cbiAgICAgICAgdGhpcy5fcHJlZmVycmVkVmlkZW9Db2RlY3MuZm9yRWFjaChmdW5jdGlvbiAoY3MpIHtcbiAgICAgICAgICAgIGlmICgnYWRhcHRpdmVTaW11bGNhc3QnIGluIGNzKSB7XG4gICAgICAgICAgICAgICAgY3MuYWRhcHRpdmVTaW11bGNhc3QgPSBlZmZlY3RpdmVBZGFwdGl2ZVNpbXVsY2FzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUsIFwiX3Nob3VsZEFwcGx5U2ltdWxjYXN0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWlzQ2hyb21lICYmICFpc1NhZmFyaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkYXB0aXZlU2ltdWxjYXN0IGlzIHNldCB0byBmYWxzZSBhZnRlciBjb25uZWN0ZWQgbWVzc2FnZSBpcyByZWNlaXZlZCBpZiBvdGhlciBwYXJ0eSBkb2VzIG5vdCBzdXBwb3J0IGl0LlxuICAgICAgICAgICAgdmFyIHNpbXVsY2FzdCA9IHRoaXMuX3ByZWZlcnJlZFZpZGVvQ29kZWNzLnNvbWUoZnVuY3Rpb24gKGNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNzLmNvZGVjLnRvTG93ZXJDYXNlKCkgPT09ICd2cDgnICYmIGNzLnNpbXVsY2FzdCAmJiBjcy5hZGFwdGl2ZVNpbXVsY2FzdCAhPT0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzaW11bGNhc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUsIFwiY29ubmVjdGlvblN0YXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0ncyB1bmRlcmx5aW5nIFJUQ1BlZXJDb25uZWN0aW9uJ3MgUlRDUGVlckNvbm5lY3Rpb25TdGF0ZVxuICAgICAgICAgKiBpZiBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIsIGl0cyBSVENJY2VDb25uZWN0aW9uU3RhdGUgb3RoZXJ3aXNlLlxuICAgICAgICAgKiBAcHJvcGVydHkge1JUQ1BlZXJDb25uZWN0aW9uU3RhdGV9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCdcbiAgICAgICAgICAgICAgICA/ICdmYWlsZWQnIDogKHRoaXMuX3BlZXJDb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSB8fCB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUsIFwiaWNlQ29ubmVjdGlvblN0YXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0ncyB1bmRlcmx5aW5nIFJUQ1BlZXJDb25uZWN0aW9uJ3NcbiAgICAgICAgICogUlRDSWNlQ29ubmVjdGlvblN0YXRlLlxuICAgICAgICAgKiBAcHJvcGVydHkge1JUQ0ljZUNvbm5lY3Rpb25TdGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICgodGhpcy5faXNJY2VDb25uZWN0aW9uSW5hY3RpdmUgJiYgdGhpcy5fcGVlckNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGVkJykgfHwgdGhpcy5faWNlR2F0aGVyaW5nRmFpbGVkKVxuICAgICAgICAgICAgICAgID8gJ2ZhaWxlZCcgOiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUsIFwiaXNBcHBsaWNhdGlvblNlY3Rpb25OZWdvdGlhdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfSBoYXMgbmVnb3RpYXRlZCBvciBpcyBpbiB0aGUgcHJvY2Vzc1xuICAgICAgICAgKiBvZiBuZWdvdGlhdGluZyB0aGUgYXBwbGljYXRpb24gbT0gc2VjdGlvbi5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBhY2Nlc3NpbmcgLmxvY2FsRGVzY3JpcHRpb24gaW4gJ2Nsb3NlZCcgc3RhdGUgY2F1c2VzIGl0IHRocm93IGV4Y2VwdGlvbnMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBnZXRNZWRpYVNlY3Rpb25zKHRoaXMuX3BlZXJDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb24uc2RwLCAnYXBwbGljYXRpb24nKS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZSwgXCJfaXNBZGFwdGl2ZVNpbXVsY2FzdEVuYWJsZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBhZGFwdGl2ZSBzaW11bGNhc3QgaXMgZW5hYmxlZC5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhZGFwdGl2ZVNpbXVsY2FzdEVudHJ5ID0gdGhpcy5fcHJlZmVycmVkVmlkZW9Db2RlY3MuZmluZChmdW5jdGlvbiAoY3MpIHsgcmV0dXJuICdhZGFwdGl2ZVNpbXVsY2FzdCcgaW4gY3M7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFkYXB0aXZlU2ltdWxjYXN0RW50cnkgJiYgYWRhcHRpdmVTaW11bGNhc3RFbnRyeS5hZGFwdGl2ZVNpbXVsY2FzdCA9PT0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAgICAgKiBAcGFyYW0ge0FycmF5PFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVycz59IGVuY29kaW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJhY2tSZXBsYWNlZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGVuY29kaW5ncyB3ZXJlIHVwZGF0ZWQuXG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX21heWJlVXBkYXRlRW5jb2RpbmdzID0gZnVuY3Rpb24gKHRyYWNrLCBlbmNvZGluZ3MsIHRyYWNrUmVwbGFjZWQpIHtcbiAgICAgICAgaWYgKHRyYWNrUmVwbGFjZWQgPT09IHZvaWQgMCkgeyB0cmFja1JlcGxhY2VkID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgIT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnJvd3NlciA9IHV0aWwuZ3Vlc3NCcm93c2VyKCk7XG4gICAgICAgIC8vIE5vdGUobXBhdHdhcmRoYW4pOiBhbHdheXMgY29uZmlndXJlIGVuY29kaW5ncyBmb3Igc2FmYXJpLlxuICAgICAgICAvLyBmb3IgY2hyb21lIG9ubHkgd2hlbiBhZGFwdGl2ZSBzaW11bGNhc3QgZW5hYmxlZC5cbiAgICAgICAgaWYgKGJyb3dzZXIgPT09ICdzYWZhcmknIHx8IChicm93c2VyID09PSAnY2hyb21lJyAmJiB0aGlzLl9pc0FkYXB0aXZlU2ltdWxjYXN0RW5hYmxlZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUVuY29kaW5ncyh0cmFjaywgZW5jb2RpbmdzLCB0cmFja1JlcGxhY2VkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgd2l0aCBkZWZhdWx0IGVuY29kaW5ncyBkZXBlbmRpbmcgb24gdHJhY2sgdHlwZSBhbmQgcmVzb2x1dGlvbi5cbiAgICAgKiBEZWZhdWx0IGNvbmZpZ3VyYXRpb24gc2V0cyBzb21lIGVuY29kaW5ncyB0byBkaXNhYmxlZCwgYW5kIGZvciBvdGhlcnMgc2V0IHNjYWxlUmVzb2x1dGlvbkRvd25CeVxuICAgICAqIHZhbHVlcy4gV2hlbiB0cmFja1JlcGxhY2VkIGlzIHNldCB0byB0cnVlLCBpdCB3aWxsIGNsZWFyICdhY3RpdmUnIGZvciBhbnkgZW5jb2RpbmdzIHRoYXRcbiAgICAgKiBuZWVkcyB0byBiZSBlbmFibGVkLlxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAgICAgKiBAcGFyYW0ge0FycmF5PFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVycz59IGVuY29kaW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJhY2tSZXBsYWNlZFxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl91cGRhdGVFbmNvZGluZ3MgPSBmdW5jdGlvbiAodHJhY2ssIGVuY29kaW5ncywgdHJhY2tSZXBsYWNlZCkge1xuICAgICAgICBpZiAodGhpcy5faXNDaHJvbWVTY3JlZW5TaGFyZVRyYWNrKHRyYWNrKSkge1xuICAgICAgICAgICAgdmFyIHNjcmVlblNoYXJlQWN0aXZlTGF5ZXJDb25maWdfMSA9IFtcbiAgICAgICAgICAgICAgICB7IHNjYWxlUmVzb2x1dGlvbkRvd25CeTogMSB9LFxuICAgICAgICAgICAgICAgIHsgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiAxIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBlbmNvZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZW5jb2RpbmcsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlTGF5ZXJDb25maWcgPSBzY3JlZW5TaGFyZUFjdGl2ZUxheWVyQ29uZmlnXzFbaV07XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUxheWVyQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IGFjdGl2ZUxheWVyQ29uZmlnLnNjYWxlUmVzb2x1dGlvbkRvd25CeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrUmVwbGFjZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbmNvZGluZy5hY3RpdmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9hID0gdHJhY2suZ2V0U2V0dGluZ3MoKSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IGZvciBub24tc2NyZWVuIHNoYXJlIHRyYWNrc1xuICAgICAgICAgICAgLy8gZW5hYmxlIGxheWVycyBkZXBlbmRpbmcgb24gdHJhY2sgcmVzb2x1dGlvbnNcbiAgICAgICAgICAgIHZhciBwaXhlbHNUb01heEFjdGl2ZUxheWVycyA9IFtcbiAgICAgICAgICAgICAgICB7IHBpeGVsczogOTYwICogNTQwLCBtYXhBY3RpdmVMYXllcnM6IDMgfSxcbiAgICAgICAgICAgICAgICB7IHBpeGVsczogNDgwICogMjcwLCBtYXhBY3RpdmVMYXllcnM6IDIgfSxcbiAgICAgICAgICAgICAgICB7IHBpeGVsczogMCwgbWF4QWN0aXZlTGF5ZXJzOiAxIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgdHJhY2tQaXhlbHNfMSA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGFjdGl2ZUxheWVyc0luZm8gPSBwaXhlbHNUb01heEFjdGl2ZUxheWVycy5maW5kKGZ1bmN0aW9uIChsYXllcikgeyByZXR1cm4gdHJhY2tQaXhlbHNfMSA+PSBsYXllci5waXhlbHM7IH0pO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZUxheWVyc18xID0gTWF0aC5taW4oZW5jb2RpbmdzLmxlbmd0aCwgYWN0aXZlTGF5ZXJzSW5mby5tYXhBY3RpdmVMYXllcnMpO1xuICAgICAgICAgICAgZW5jb2RpbmdzLmZvckVhY2goZnVuY3Rpb24gKGVuY29kaW5nLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuYWJsZWQgPSBpIDwgYWN0aXZlTGF5ZXJzXzE7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gMSA8PCAoYWN0aXZlTGF5ZXJzXzEgLSBpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja1JlcGxhY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ191cGRhdGVFbmNvZGluZ3M6JywgZW5jb2RpbmdzLm1hcChmdW5jdGlvbiAoX2EsIGkpIHtcbiAgICAgICAgICAgIHZhciBhY3RpdmUgPSBfYS5hY3RpdmUsIHNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IF9hLnNjYWxlUmVzb2x1dGlvbkRvd25CeTtcbiAgICAgICAgICAgIHJldHVybiBcIltcIiArIGkgKyBcIjogXCIgKyBhY3RpdmUgKyBcIiwgXCIgKyAoc2NhbGVSZXNvbHV0aW9uRG93bkJ5IHx8IDApICsgXCJdXCI7XG4gICAgICAgIH0pLmpvaW4oJywgJykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGFuIElDRSBjYW5kaWRhdGUgdG8gdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjYW5kaWRhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fYWRkSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gKGNhbmRpZGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGUgPSBuZXcgX3RoaXMuX1JUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9wZWVyQ29ubmVjdGlvbi5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBGaXJlZm94IDY4KyBub3cgZ2VuZXJhdGVzIGFuIFJUQ0ljZUNhbmRpZGF0ZSB3aXRoIGFuXG4gICAgICAgICAgICAvLyBlbXB0eSBjYW5kaWRhdGUgc3RyaW5nIHRvIHNpZ25hbCBlbmQtb2YtY2FuZGlkYXRlcywgZm9sbG93ZWQgYnkgYSBudWxsXG4gICAgICAgICAgICAvLyBjYW5kaWRhdGUuIEFzIG9mIG5vdywgQ2hyb21lIGFuZCBTYWZhcmkgcmVqZWN0IHRoaXMgUlRDSWNlQ2FuZGlkYXRlLiBTaW5jZVxuICAgICAgICAgICAgLy8gdGhpcyBkb2VzIG5vdCBhZmZlY3QgdGhlIG1lZGlhIGNvbm5lY3Rpb24gYmV0d2VlbiBGaXJlZm94IDY4KyBhbmQgQ2hyb21lL1NhZmFyaVxuICAgICAgICAgICAgLy8gaW4gUGVlci10by1QZWVyIFJvb21zLCB3ZSBzdXBwcmVzcyB0aGUgRXJyb3IgYW5kIGxvZyBhIHdhcm5pbmcgbWVzc2FnZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBDaHJvbWUgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05Nzg1ODJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBfdGhpcy5fbG9nLndhcm4oXCJGYWlsZWQgdG8gYWRkIFJUQ0ljZUNhbmRpZGF0ZSBcIiArIChjYW5kaWRhdGUgPyBcIlxcXCJcIiArIGNhbmRpZGF0ZS5jYW5kaWRhdGUgKyBcIlxcXCJcIiA6ICdudWxsJykgKyBcIjogXCJcbiAgICAgICAgICAgICAgICArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBJQ0UgY2FuZGlkYXRlcyB0byB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBjYW5kaWRhdGVzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX2FkZEljZUNhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoY2FuZGlkYXRlcykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2FuZGlkYXRlcy5tYXAodGhpcy5fYWRkSWNlQ2FuZGlkYXRlLCB0aGlzKSkudGhlbihmdW5jdGlvbiAoKSB7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgbmV3IFJUQ1J0cFRyYW5zY2VpdmVyIG9yIHVwZGF0ZSBhbiBleGlzdGluZyBSVENSdHBUcmFuc2NlaXZlciBmb3IgdGhlXG4gICAgICogZ2l2ZW4gTWVkaWFTdHJlYW1UcmFjay5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAgICAgKiBAcmV0dXJucyB7UlRDUnRwVHJhbnNjZWl2ZXJ9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX2FkZE9yVXBkYXRlVHJhbnNjZWl2ZXIgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRyYW5zY2VpdmVyID0gdGFrZVJlY3ljbGVkVHJhbnNjZWl2ZXIodGhpcywgdHJhY2sua2luZCk7XG4gICAgICAgIGlmICh0cmFuc2NlaXZlciAmJiB0cmFuc2NlaXZlci5zZW5kZXIpIHtcbiAgICAgICAgICAgIHZhciBvbGRUcmFja0lkID0gdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrID8gdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrLmlkIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChvbGRUcmFja0lkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJSZXVzaW5nIHRyYW5zY2VpdmVyOiBcIiArIHRyYW5zY2VpdmVyLm1pZCArIFwiXSBcIiArIG9sZFRyYWNrSWQgKyBcIiA9PiBcIiArIHRyYWNrLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOnJlbWVtYmVyIHRoaXMgdHJhbnNjZWl2ZXIgd2hpbGUgd2UgcmVwbGFjZSB0cmFjay5cbiAgICAgICAgICAgIC8vIHdlIHJlY3ljbGUgdHJhbnNjZWl2ZXJzIHRoYXQgYXJlIG5vdCBpbiB1c2UgYWZ0ZXIgJ25lZ290aWF0aW9uQ29tcGxldGVkJywgYnV0IHdlIHdhbnQgdG8gcHJldmVudFxuICAgICAgICAgICAgLy8gdGhpcyBvbmUgZnJvbSBnZXR0aW5nIHJlY3ljbGVkIHdoaWxlIHJlcGxhY2VUcmFjayBpcyBwZW5kaW5nLlxuICAgICAgICAgICAgdGhpcy5fcmVwbGFjZVRyYWNrUHJvbWlzZXMuc2V0KHRyYW5zY2VpdmVyLCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZHJlY3YnO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVwbGFjZVRyYWNrUHJvbWlzZXMuZGVsZXRlKHRyYW5zY2VpdmVyKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2NlaXZlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb24uYWRkVHJhbnNjZWl2ZXIodHJhY2spO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIHtAbGluayBJY2VCb3h9LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0fSBkZXNjcmlwdGlvblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9jaGVja0ljZUJveCA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICB2YXIgdWZyYWcgPSBnZXRVZnJhZyhkZXNjcmlwdGlvbik7XG4gICAgICAgIGlmICghdWZyYWcpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FuZGlkYXRlcyA9IHRoaXMuX3JlbW90ZUNhbmRpZGF0ZXMuc2V0VWZyYWcodWZyYWcpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkSWNlQ2FuZGlkYXRlcyhjYW5kaWRhdGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBhbnN3ZXIgYW5kIHNldCBpdCBvbiB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0fSBvZmZlclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9hbnN3ZXIgPSBmdW5jdGlvbiAob2ZmZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fbmVnb3RpYXRpb25Sb2xlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX25lZ290aWF0aW9uUm9sZSA9ICdhbnN3ZXJlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3NldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1lZGlhQ2xpZW50UmVtb3RlRGVzY0ZhaWxlZEVycm9yKCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoYW5zd2VyKSB7XG4gICAgICAgICAgICBpZiAoaXNGaXJlZm94KSB7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogV2Ugd29yayBhcm91bmQgQ2hyb21pdW0gYnVnIDExMDYxNTcgYnkgZGlzYWJsaW5nXG4gICAgICAgICAgICAgICAgLy8gUlRYIGluIEZpcmVmb3ggNzkrLiBGb3IgbW9yZSBkZXRhaWxzIGFib3V0IHRoZSBidWcsIHBsZWFzZSBnbyBoZXJlOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTExMDYxNTdcbiAgICAgICAgICAgICAgICBhbnN3ZXIgPSBuZXcgX3RoaXMuX1JUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHNkcDogZGlzYWJsZVJ0eChhbnN3ZXIuc2RwKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogYW5zd2VyLnR5cGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuc3dlciA9IHdvcmthcm91bmRJc3N1ZTgzMjkoYW5zd2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBVcGNvbWluZyBjaHJvbWUgdmVyc2lvbnMgYXJlIGdvaW5nIHRvIHJlbW92ZSBzc3JjIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC8vIG1zbGFiZWwgYW5kIGxhYmVsLiBTZWUgdGhpcyBidWcgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTcxMTBcbiAgICAgICAgICAgIC8vIGFuZCBQU0E6IGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyFzZWFyY2hpbi9kaXNjdXNzLXdlYnJ0Yy9QU0ElN0Nzb3J0OmRhdGUvZGlzY3Vzcy13ZWJydGMvamNaTy1XajBXdXMvazJYdlBDdm9Bd0FKXG4gICAgICAgICAgICAvLyBXZSBhcmUgbm90IHJlZmVyZW5jaW5nIHRob3NlIGF0dHJpYnV0ZXMsIGJ1dCB0aGlzIGNoYW5nZXMgZ29lcyBhaGVhZCBhbmQgcmVtb3ZlcyB0aGVtIHRvIHNlZSBpZiBpdCB3b3Jrcy5cbiAgICAgICAgICAgIC8vIHRoaXMgYWxzbyBoZWxwcyByZWR1Y2UgYnl0ZXMgb24gd2lyZXNcbiAgICAgICAgICAgIHZhciB1cGRhdGVkU2RwID0gcmVtb3ZlU1NSQ0F0dHJpYnV0ZXMoYW5zd2VyLnNkcCwgWydtc2xhYmVsJywgJ2xhYmVsJ10pO1xuICAgICAgICAgICAgaWYgKF90aGlzLl9zaG91bGRBcHBseVNpbXVsY2FzdCkge1xuICAgICAgICAgICAgICAgIHZhciBzZHBXaXRob3V0U2ltdWxjYXN0ID0gdXBkYXRlZFNkcDtcbiAgICAgICAgICAgICAgICB1cGRhdGVkU2RwID0gX3RoaXMuX3NldFNpbXVsY2FzdChzZHBXaXRob3V0U2ltdWxjYXN0LCBfdGhpcy5fdHJhY2tJZHNUb0F0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUoc3llcnJhcHJhZ2FkYSk6IFZNUyBkb2VzIG5vdCBzdXBwb3J0IEgyNjQgc2ltdWxjYXN0LiBTbyxcbiAgICAgICAgICAgICAgICAvLyB1bnNldCBzaW11bGNhc3QgZm9yIHNlY3Rpb25zIGluIGxvY2FsIG9mZmVyIHdoZXJlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgICAgICAgICAvLyBzZWN0aW9ucyBpbiBhbnN3ZXIgZG9lc24ndCBoYXZlIHZwOCBhcyBwcmVmZXJyZWQgY29kZWMgYW5kIHJlYXBwbHkgb2ZmZXIuXG4gICAgICAgICAgICAgICAgdXBkYXRlZFNkcCA9IF90aGlzLl9yZXZlcnRTaW11bGNhc3QodXBkYXRlZFNkcCwgc2RwV2l0aG91dFNpbXVsY2FzdCwgb2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFdvcmsgYXJvdW5kIENocm9taXVtIGJ1ZyAxMDc0NDIxLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTA3NDQyMVxuICAgICAgICAgICAgdXBkYXRlZFNkcCA9IHVwZGF0ZWRTZHAucmVwbGFjZSgvNDJlMDE1L2csICc0MmUwMWYnKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2V0TG9jYWxEZXNjcmlwdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogYW5zd2VyLnR5cGUsXG4gICAgICAgICAgICAgICAgc2RwOiB1cGRhdGVkU2RwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NoZWNrSWNlQm94KG9mZmVyKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3F1ZXVlZERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgJiYgX3RoaXMuX3VwZGF0ZURlc2NyaXB0aW9uKF90aGlzLl9xdWV1ZWREZXNjcmlwdGlvbik7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3F1ZXVlZERlc2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fbWF5YmVSZW9mZmVyKF90aGlzLl9wZWVyQ29ubmVjdGlvbi5sb2NhbERlc2NyaXB0aW9uKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JUb1Rocm93ID0gZXJyb3IgaW5zdGFuY2VvZiBNZWRpYUNsaWVudFJlbW90ZURlc2NGYWlsZWRFcnJvciA/IGVycm9yIDogbmV3IE1lZGlhQ2xpZW50TG9jYWxEZXNjRmFpbGVkRXJyb3IoKTtcbiAgICAgICAgICAgIF90aGlzLl9wdWJsaXNoTWVkaWFXYXJuaW5nKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIF9hbnN3ZXInLFxuICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yVG9UaHJvdy5jb2RlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvclRvVGhyb3c7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIHVuZGVybHlpbmcgUlRDUGVlckNvbm5lY3Rpb24uIFJldHVybnMgZmFsc2UgaWYgdGhlXG4gICAgICogUlRDUGVlckNvbm5lY3Rpb24gd2FzIGFscmVhZHkgY2xvc2VkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pY2VDb25uZWN0aW9uTW9uaXRvci5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnByZWVtcHQoJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgdGhpcy5fZW5jb2RpbmdQYXJhbWV0ZXJzLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2VkJywgdGhpcy5fb25FbmNvZGluZ1BhcmFtZXRlcnNDaGFuZ2VkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIFwiY29ubmVjdGlvbnN0YXRlY2hhbmdlXCIgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5faGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIFwiZGF0YWNoYW5uZWxcIiBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UlRDRGF0YUNoYW5uZWxFdmVudH0gZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5faGFuZGxlRGF0YUNoYW5uZWxFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGF0YUNoYW5uZWwgPSBldmVudC5jaGFubmVsO1xuICAgICAgICB2YXIgZGF0YVRyYWNrUmVjZWl2ZXIgPSBuZXcgRGF0YVRyYWNrUmVjZWl2ZXIoZGF0YUNoYW5uZWwpO1xuICAgICAgICB0aGlzLl9kYXRhVHJhY2tSZWNlaXZlcnMuYWRkKGRhdGFUcmFja1JlY2VpdmVyKTtcbiAgICAgICAgZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fZGF0YVRyYWNrUmVjZWl2ZXJzLmRlbGV0ZShkYXRhVHJhY2tSZWNlaXZlcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoJ3RyYWNrQWRkZWQnLCBkYXRhVHJhY2tSZWNlaXZlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYSBnbGFyZSBzY2VuYXJpbyBvbiB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0fSBvZmZlclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9oYW5kbGVHbGFyZSA9IGZ1bmN0aW9uIChvZmZlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0dsYXJlIGRldGVjdGVkOyByb2xsaW5nIGJhY2snKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzUmVzdGFydGluZ0ljZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdBbiBJQ0UgcmVzdGFydCB3YXMgaW4gcHJvZ3Jlc3M7IHdlXFwnbGwgbmVlZCB0byByZXN0YXJ0IElDRSBhZ2FpbiBhZnRlciByb2xsaW5nIGJhY2snKTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzdGFydGluZ0ljZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc2hvdWxkUmVzdGFydEljZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3RyYWNrSWRzVG9BdHRyaWJ1dGVzID0gbmV3IE1hcChfdGhpcy5fYXBwbGllZFRyYWNrSWRzVG9BdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2V0TG9jYWxEZXNjcmlwdGlvbih7IHR5cGU6ICdyb2xsYmFjaycgfSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX25lZWRzQW5zd2VyID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2Fuc3dlcihvZmZlcik7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRpZFJlb2ZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBkaWRSZW9mZmVyID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBfdGhpcy5fb2ZmZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fcHVibGlzaE1lZGlhV2FybmluZyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IF9hLm1lc3NhZ2UsIGNvZGUgPSBfYS5jb2RlLCBlcnJvciA9IF9hLmVycm9yLCBzZHAgPSBfYS5zZHA7XG4gICAgICAgIHRoaXMuX2V2ZW50T2JzZXJ2ZXIuZW1pdCgnZXZlbnQnLCB7IGxldmVsOiAnd2FybmluZycsIG5hbWU6ICdlcnJvcicsIGdyb3VwOiAnbWVkaWEnLCBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6IGVycm9yLm1lc3NhZ2UsIHNkcDogc2RwIH0pXG4gICAgICAgICAgICB9IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFuIElDRSBjYW5kaWRhdGUgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9oYW5kbGVJY2VDYW5kaWRhdGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0NsZWFyaW5nIElDRSBnYXRoZXJpbmcgdGltZW91dCcpO1xuICAgICAgICAgICAgdGhpcy5fZGlkR2VuZXJhdGVMb2NhbENhbmRpZGF0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faWNlR2F0aGVyaW5nVGltZW91dC5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxDYW5kaWRhdGVzLnB1c2goZXZlbnQuY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGVlckNvbm5lY3Rpb25TdGF0ZSA9IHtcbiAgICAgICAgICAgIGljZToge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXM6IHRoaXMuX2lzSWNlTGl0ZSA/IFtdIDogdGhpcy5fbG9jYWxDYW5kaWRhdGVzLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgdWZyYWc6IHRoaXMuX2xvY2FsVWZyYWdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWV2ZW50LmNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25TdGF0ZS5pY2UuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHRoaXMuX2lzSWNlTGl0ZSAmJiBldmVudC5jYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvblN0YXRlLmljZS5yZXZpc2lvbiA9IHRoaXMuX2xvY2FsQ2FuZGlkYXRlc1JldmlzaW9uKys7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NhbmRpZGF0ZXMnLCBwZWVyQ29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFuIElDRSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZSBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9oYW5kbGVJY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpY2VDb25uZWN0aW9uU3RhdGUgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGU7XG4gICAgICAgIHZhciBpc0ljZUNvbm5lY3RlZE9yQ29tcGxldGUgPSBbJ2Nvbm5lY3RlZCcsICdjb21wbGV0ZWQnXS5pbmNsdWRlcyhpY2VDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBsb2cuZGVidWcoXCJJQ0UgY29ubmVjdGlvbiBzdGF0ZSBpcyBcXFwiXCIgKyBpY2VDb25uZWN0aW9uU3RhdGUgKyBcIlxcXCJcIik7XG4gICAgICAgIGlmIChpc0ljZUNvbm5lY3RlZE9yQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ljZVJlY29ubmVjdFRpbWVvdXQuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2ljZVJlc3RhcnRCYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xhc3RJY2VDb25uZWN0aW9uU3RhdGUgIT09ICdmYWlsZWQnICYmIGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcgJiYgIXRoaXMuX3Nob3VsZFJlc3RhcnRJY2UgJiYgIXRoaXMuX2lzUmVzdGFydGluZ0ljZSkge1xuICAgICAgICAgICAgLy8gQ2FzZSAxOiBUcmFuc2l0aW9uIHRvIFwiZmFpbGVkXCIuXG4gICAgICAgICAgICBsb2cud2FybignSUNFIGZhaWxlZCcpO1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhdGVJY2VSZXN0YXJ0QmFja29mZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFsnZGlzY29ubmVjdGVkJywgJ2ZhaWxlZCddLmluY2x1ZGVzKHRoaXMuX2xhc3RJY2VDb25uZWN0aW9uU3RhdGUpICYmIGlzSWNlQ29ubmVjdGVkT3JDb21wbGV0ZSkge1xuICAgICAgICAgICAgLy8gQ2FzZSAyOiBUcmFuc2l0aW9uIGZyb20gXCJkaXNjb25uZWN0ZWRcIiBvciBcImZhaWxlZFwiLlxuICAgICAgICAgICAgbG9nLmRlYnVnKCdJQ0UgcmVjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGFydCBtb25pdG9yIG1lZGlhIHdoZW4gY29ubmVjdGVkLCBhbmQgY29udGludWUgdG8gbW9uaXRvciB3aGlsZSBzdGF0ZSBpcyBjb21wbGV0ZS1kaXNjb25uZWN0ZWQtY29ubmVjdGVkLlxuICAgICAgICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgdGhpcy5faXNJY2VDb25uZWN0aW9uSW5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2ljZUNvbm5lY3Rpb25Nb25pdG9yLnN0YXJ0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBub3RlOiBpY2VDb25uZWN0aW9uIG1vbml0b3Igd2FpdHMgZm9yIGljZUNvbm5lY3Rpb25TdGF0ZT1kaXNjb25uZWN0ZWQgZm9yXG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0aW5nIGluYWN0aXZpdHkuIEl0cyBwb3NzaWJsZSB0aGF0IGl0IG1heSBrbm93IGFib3V0IGRpc2Nvbm5lY3RlZCBiZWZvcmUgX2hhbmRsZUljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZVxuICAgICAgICAgICAgICAgIF90aGlzLl9pY2VDb25uZWN0aW9uTW9uaXRvci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fc2hvdWxkUmVzdGFydEljZSAmJiAhX3RoaXMuX2lzUmVzdGFydGluZ0ljZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2cud2FybignSUNFIENvbm5lY3Rpb24gTW9uaXRvciBkZXRlY3RlZCBpbmFjdGl2aXR5Jyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc0ljZUNvbm5lY3Rpb25JbmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbml0aWF0ZUljZVJlc3RhcnRCYWNrb2ZmKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnY29ubmVjdGlvblN0YXRlQ2hhbmdlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFbJ2Rpc2Nvbm5lY3RlZCcsICdjb21wbGV0ZWQnXS5pbmNsdWRlcyhpY2VDb25uZWN0aW9uU3RhdGUpKSB7IC8vIGRvbid0IHN0b3AgbW9uaXRvcmluZyBmb3IgZGlzY29ubmVjdGVkIG9yIGNvbXBsZXRlZC5cbiAgICAgICAgICAgIHRoaXMuX2ljZUNvbm5lY3Rpb25Nb25pdG9yLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuX2lzSWNlQ29ubmVjdGlvbkluYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdEljZUNvbm5lY3Rpb25TdGF0ZSA9IGljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdpY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgSUNFIGdhdGhlcmluZyB0aW1lb3V0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX2hhbmRsZUljZUdhdGhlcmluZ1RpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xvZy53YXJuKCdJQ0UgZmFpbGVkIHRvIGdhdGhlciBhbnkgbG9jYWwgY2FuZGlkYXRlcycpO1xuICAgICAgICB0aGlzLl9pY2VHYXRoZXJpbmdGYWlsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbml0aWF0ZUljZVJlc3RhcnRCYWNrb2ZmKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnaWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCcpO1xuICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbiBJQ0UgZ2F0aGVyaW5nIHN0YXRlIGNoYW5nZSBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9oYW5kbGVJY2VHYXRoZXJpbmdTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGljZUdhdGhlcmluZ1N0YXRlID0gdGhpcy5fcGVlckNvbm5lY3Rpb24uaWNlR2F0aGVyaW5nU3RhdGU7XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIGxvZy5kZWJ1ZyhcIklDRSBnYXRoZXJpbmcgc3RhdGUgaXMgXFxcIlwiICsgaWNlR2F0aGVyaW5nU3RhdGUgKyBcIlxcXCJcIik7XG4gICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFN0YXJ0IHRoZSBJQ0UgZ2F0aGVyaW5nIHRpbWVvdXQgb25seSBpZiB0aGUgUlRDUGVlckNvbm5lY3Rpb25cbiAgICAgICAgLy8gaGFzIHN0YXJ0ZWQgZ2F0aGVyaW5nIGNhbmRpZGF0ZXMgZm9yIHRoZSBmaXJzdCB0aW1lIHNpbmNlIHRoZSBpbml0aWFsIG9mZmVyL2Fuc3dlclxuICAgICAgICAvLyBvciBhbiBvZmZlci9hbnN3ZXIgd2l0aCBJQ0UgcmVzdGFydC5cbiAgICAgICAgdmFyIF9hID0gdGhpcy5faWNlR2F0aGVyaW5nVGltZW91dCwgZGVsYXkgPSBfYS5kZWxheSwgaXNTZXQgPSBfYS5pc1NldDtcbiAgICAgICAgaWYgKGljZUdhdGhlcmluZ1N0YXRlID09PSAnZ2F0aGVyaW5nJyAmJiAhdGhpcy5fZGlkR2VuZXJhdGVMb2NhbENhbmRpZGF0ZXMgJiYgIWlzU2V0KSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoXCJTdGFydGluZyBJQ0UgZ2F0aGVyaW5nIHRpbWVvdXQ6IFwiICsgZGVsYXkpO1xuICAgICAgICAgICAgdGhpcy5faWNlR2F0aGVyaW5nRmFpbGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pY2VHYXRoZXJpbmdUaW1lb3V0LnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIHNpZ25hbGluZyBzdGF0ZSBjaGFuZ2UgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5faGFuZGxlU2lnbmFsaW5nU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGxpZWRUcmFja0lkc1RvQXR0cmlidXRlcyA9IG5ldyBNYXAodGhpcy5fdHJhY2tJZHNUb0F0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYSB0cmFjayBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UlRDVHJhY2tFdmVudH0gZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5faGFuZGxlVHJhY2tFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2RwID0gdGhpcy5fcGVlckNvbm5lY3Rpb24ucmVtb3RlRGVzY3JpcHRpb25cbiAgICAgICAgICAgID8gdGhpcy5fcGVlckNvbm5lY3Rpb24ucmVtb3RlRGVzY3JpcHRpb24uc2RwXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIHRoaXMuX3RyYWNrTWF0Y2hlciA9IHRoaXMuX3RyYWNrTWF0Y2hlciB8fCBuZXcgVHJhY2tNYXRjaGVyKCk7XG4gICAgICAgIHRoaXMuX3RyYWNrTWF0Y2hlci51cGRhdGUoc2RwKTtcbiAgICAgICAgdmFyIG1lZGlhU3RyZWFtVHJhY2sgPSBldmVudC50cmFjaywgbWlkID0gZXZlbnQudHJhbnNjZWl2ZXIubWlkO1xuICAgICAgICB2YXIgc2lnbmFsZWRUcmFja0lkID0gdGhpcy5fdHJhY2tNYXRjaGVyLm1hdGNoKGV2ZW50KSB8fCBtZWRpYVN0cmVhbVRyYWNrLmlkO1xuICAgICAgICB2YXIgbWVkaWFUcmFja1JlY2VpdmVyID0gbmV3IE1lZGlhVHJhY2tSZWNlaXZlcihzaWduYWxlZFRyYWNrSWQsIG1pZCwgbWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFwiZW5kZWRcIiBpcyBub3QgZmlyZWQgb24gdGhlIHJlbW90ZSBNZWRpYVN0cmVhbVRyYWNrIHdoZW5cbiAgICAgICAgLy8gdGhlIHJlbW90ZSBwZWVyIHJlbW92ZXMgYSB0cmFjay4gU28sIHdoZW4gdGhpcyBNZWRpYVN0cmVhbVRyYWNrIGlzIHJlLXVzZWRcbiAgICAgICAgLy8gZm9yIGEgZGlmZmVyZW50IHRyYWNrIGR1ZSB0byB0aGUgcmVtb3RlIHBlZXIgY2FsbGluZyBSVENSdHBTZW5kZXIucmVwbGFjZVRyYWNrKCksXG4gICAgICAgIC8vIHdlIGRlbGV0ZSB0aGUgcHJldmlvdXMgTWVkaWFUcmFja1JlY2VpdmVyIHRoYXQgb3duZWQgdGhpcyBNZWRpYVN0cmVhbVRyYWNrXG4gICAgICAgIC8vIGJlZm9yZSBhZGRpbmcgdGhlIG5ldyBNZWRpYVRyYWNrUmVjZWl2ZXIuXG4gICAgICAgIHRoaXMuX21lZGlhVHJhY2tSZWNlaXZlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tSZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHRyYWNrUmVjZWl2ZXIudHJhY2suaWQgPT09IG1lZGlhVHJhY2tSZWNlaXZlci50cmFjay5pZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9tZWRpYVRyYWNrUmVjZWl2ZXJzLmRlbGV0ZSh0cmFja1JlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21lZGlhVHJhY2tSZWNlaXZlcnMuYWRkKG1lZGlhVHJhY2tSZWNlaXZlcik7XG4gICAgICAgIG1lZGlhU3RyZWFtVHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbWVkaWFUcmFja1JlY2VpdmVycy5kZWxldGUobWVkaWFUcmFja1JlY2VpdmVyKTsgfSk7XG4gICAgICAgIHRoaXMuZW1pdCgndHJhY2tBZGRlZCcsIG1lZGlhVHJhY2tSZWNlaXZlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSBJQ0UgUmVzdGFydC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9pbml0aWF0ZUljZVJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBsb2cud2FybignQXR0ZW1wdGluZyB0byByZXN0YXJ0IElDRScpO1xuICAgICAgICB0aGlzLl9kaWRHZW5lcmF0ZUxvY2FsQ2FuZGlkYXRlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0ljZVJlc3RhcnRCYWNrb2ZmSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zaG91bGRSZXN0YXJ0SWNlID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5faWNlUmVjb25uZWN0VGltZW91dCwgZGVsYXkgPSBfYS5kZWxheSwgaXNTZXQgPSBfYS5pc1NldDtcbiAgICAgICAgaWYgKCFpc1NldCkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwiU3RhcnRpbmcgSUNFIHJlY29ubmVjdCB0aW1lb3V0OiBcIiArIGRlbGF5KTtcbiAgICAgICAgICAgIHRoaXMuX2ljZVJlY29ubmVjdFRpbWVvdXQuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZmVyKCkuY2F0Y2goZnVuY3Rpb24gKGV4KSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoXCJvZmZlciBmYWlsZWQgaW4gX2luaXRpYXRlSWNlUmVzdGFydCB3aXRoOiBcIiArIGV4Lm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlIGFuIElDRSBSZXN0YXJ0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX2luaXRpYXRlSWNlUmVzdGFydEJhY2tvZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgdGhpcy5faXNJY2VSZXN0YXJ0QmFja29mZkluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cud2FybignQW4gSUNFIHJlc3RhcnQgaGFzIGJlZW4gc2NoZWR1bGVkJyk7XG4gICAgICAgIHRoaXMuX2lzSWNlUmVzdGFydEJhY2tvZmZJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faWNlUmVzdGFydEJhY2tvZmYuYmFja29mZigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uZGl0aW9uYWxseSByZS1vZmZlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P1JUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXR9IGxvY2FsRGVzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fbWF5YmVSZW9mZmVyID0gZnVuY3Rpb24gKGxvY2FsRGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIHNob3VsZFJlb2ZmZXIgPSB0aGlzLl9zaG91bGRPZmZlcjtcbiAgICAgICAgaWYgKGxvY2FsRGVzY3JpcHRpb24gJiYgbG9jYWxEZXNjcmlwdGlvbi5zZHApIHtcbiAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IElmIHRoZSBsb2NhbCBSVENTZXNzaW9uRGVzY3JpcHRpb24gaGFzIGZld2VyIGF1ZGlvIGFuZC9vclxuICAgICAgICAgICAgLy8gdmlkZW8gc2VuZCogbT0gbGluZXMgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBSVENSdHBTZW5kZXJzIHdpdGggbm9uLW51bGxcbiAgICAgICAgICAgIC8vIE1lZGlhU3RyZWFtVHJhY2tzLCBpdCBtZWFucyB0aGF0IHRoZSBuZXdseSBhZGRlZCBSVENSdHBTZW5kZXJzIHJlcXVpcmVcbiAgICAgICAgICAgIC8vIHJlbmVnb3RpYXRpb24uXG4gICAgICAgICAgICB2YXIgc2VuZGVyc18xID0gdGhpcy5fcGVlckNvbm5lY3Rpb24uZ2V0U2VuZGVycygpLmZpbHRlcihmdW5jdGlvbiAoc2VuZGVyKSB7IHJldHVybiBzZW5kZXIudHJhY2s7IH0pO1xuICAgICAgICAgICAgc2hvdWxkUmVvZmZlciA9IFsnYXVkaW8nLCAndmlkZW8nXS5yZWR1Y2UoZnVuY3Rpb24gKHNob3VsZE9mZmVyLCBraW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lZGlhU2VjdGlvbnMgPSBnZXRNZWRpYVNlY3Rpb25zKGxvY2FsRGVzY3JpcHRpb24uc2RwLCBraW5kLCAnKHNlbmRyZWN2fHNlbmRvbmx5KScpO1xuICAgICAgICAgICAgICAgIHZhciBzZW5kZXJzT2ZLaW5kID0gc2VuZGVyc18xLmZpbHRlcihpc1NlbmRlck9mS2luZC5iaW5kKG51bGwsIGtpbmQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkT2ZmZXIgfHwgKG1lZGlhU2VjdGlvbnMubGVuZ3RoIDwgc2VuZGVyc09mS2luZC5sZW5ndGgpO1xuICAgICAgICAgICAgfSwgc2hvdWxkUmVvZmZlcik7XG4gICAgICAgICAgICAvLyBOT1RFKG1yb2JlcnRzKTogV2UgYWxzbyBuZWVkIHRvIHJlLW9mZmVyIGlmIHdlIGhhdmUgYSBEYXRhVHJhY2sgdG8gc2hhcmVcbiAgICAgICAgICAgIC8vIGJ1dCBubyBtPSBhcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICAgICAgdmFyIGhhc0RhdGFUcmFjayA9IHRoaXMuX2RhdGFDaGFubmVscy5zaXplID4gMDtcbiAgICAgICAgICAgIHZhciBoYXNBcHBsaWNhdGlvbk1lZGlhU2VjdGlvbiA9IGdldE1lZGlhU2VjdGlvbnMobG9jYWxEZXNjcmlwdGlvbi5zZHAsICdhcHBsaWNhdGlvbicpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB2YXIgbmVlZHNBcHBsaWNhdGlvbk1lZGlhU2VjdGlvbiA9IGhhc0RhdGFUcmFjayAmJiAhaGFzQXBwbGljYXRpb25NZWRpYVNlY3Rpb247XG4gICAgICAgICAgICBzaG91bGRSZW9mZmVyID0gc2hvdWxkUmVvZmZlciB8fCBuZWVkc0FwcGxpY2F0aW9uTWVkaWFTZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9taXNlID0gc2hvdWxkUmVvZmZlciA/IHRoaXMuX29mZmVyKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBzaG91bGRSZW9mZmVyOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBvZmZlciBhbmQgc2V0IGl0IG9uIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fb2ZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvZmZlck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9vZmZlck9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9uZWVkc0Fuc3dlciA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRSZXN0YXJ0SWNlKSB7XG4gICAgICAgICAgICB0aGlzLl9zaG91bGRSZXN0YXJ0SWNlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1Jlc3RhcnRpbmdJY2UgPSB0cnVlO1xuICAgICAgICAgICAgb2ZmZXJPcHRpb25zLmljZVJlc3RhcnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLl9yZXBsYWNlVHJhY2tQcm9taXNlcy52YWx1ZXMoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3BlZXJDb25uZWN0aW9uLmNyZWF0ZU9mZmVyKG9mZmVyT3B0aW9ucyk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIGVycm9yVG9UaHJvdyA9IG5ldyBNZWRpYUNsaWVudExvY2FsRGVzY0ZhaWxlZEVycm9yKCk7XG4gICAgICAgICAgICBfdGhpcy5fcHVibGlzaE1lZGlhV2FybmluZyh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBjcmVhdGUgb2ZmZXInLFxuICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yVG9UaHJvdy5jb2RlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvclRvVGhyb3c7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKG9mZmVyKSB7XG4gICAgICAgICAgICBpZiAoaXNGaXJlZm94KSB7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogV2Ugd29yayBhcm91bmQgQ2hyb21pdW0gYnVnIDExMDYxNTcgYnkgZGlzYWJsaW5nXG4gICAgICAgICAgICAgICAgLy8gUlRYIGluIEZpcmVmb3ggNzkrLiBGb3IgbW9yZSBkZXRhaWxzIGFib3V0IHRoZSBidWcsIHBsZWFzZSBnbyBoZXJlOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTExMDYxNTdcbiAgICAgICAgICAgICAgICBvZmZlciA9IG5ldyBfdGhpcy5fUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgc2RwOiBkaXNhYmxlUnR4KG9mZmVyLnNkcCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG9mZmVyLnR5cGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZmVyID0gd29ya2Fyb3VuZElzc3VlODMyOShvZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogdXBjb21pbmcgY2hyb21lIHZlcnNpb25zIGFyZSBnb2luZyB0byByZW1vdmUgc3NyYyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBtc2xhYmVsIGFuZCBsYWJlbC4gU2VlIHRoaXMgYnVnIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD03MTEwXG4gICAgICAgICAgICAvLyBhbmQgUFNBOiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2ZvcnVtLyMhc2VhcmNoaW4vZGlzY3Vzcy13ZWJydGMvUFNBJTdDc29ydDpkYXRlL2Rpc2N1c3Mtd2VicnRjL2pjWk8tV2owV3VzL2syWHZQQ3ZvQXdBSlxuICAgICAgICAgICAgLy8gTG9va3MgbGlrZSB3ZSBhcmUgbm90IHJlZmVyZW5jaW5nIHRob3NlIGF0dHJpYnV0ZXMsIGJ1dCB0aGlzIGNoYW5nZXMgZ29lcyBhaGVhZCBhbmQgcmVtb3ZlcyB0aGVtIHRvIHNlZSBpZiBpdCB3b3Jrcy5cbiAgICAgICAgICAgIC8vIHRoaXMgYWxzbyBoZWxwcyByZWR1Y2UgYnl0ZXMgb24gd2lyZXNcbiAgICAgICAgICAgIHZhciBzZHAgPSByZW1vdmVTU1JDQXR0cmlidXRlcyhvZmZlci5zZHAsIFsnbXNsYWJlbCcsICdsYWJlbCddKTtcbiAgICAgICAgICAgIHNkcCA9IF90aGlzLl9wZWVyQ29ubmVjdGlvbi5yZW1vdGVEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgID8gZmlsdGVyTG9jYWxDb2RlY3Moc2RwLCBfdGhpcy5fcGVlckNvbm5lY3Rpb24ucmVtb3RlRGVzY3JpcHRpb24uc2RwKVxuICAgICAgICAgICAgICAgIDogc2RwO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZWRTZHAgPSBfdGhpcy5fc2V0Q29kZWNQcmVmZXJlbmNlcyhzZHAsIF90aGlzLl9wcmVmZXJyZWRBdWRpb0NvZGVjcywgX3RoaXMuX3ByZWZlcnJlZFZpZGVvQ29kZWNzKTtcbiAgICAgICAgICAgIF90aGlzLl9zaG91bGRPZmZlciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fbmVnb3RpYXRpb25Sb2xlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX25lZ290aWF0aW9uUm9sZSA9ICdvZmZlcmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5fc2hvdWxkQXBwbHlTaW11bGNhc3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9jYWxEZXNjcmlwdGlvbldpdGhvdXRTaW11bGNhc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvZmZlcicsXG4gICAgICAgICAgICAgICAgICAgIHNkcDogdXBkYXRlZFNkcFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdXBkYXRlZFNkcCA9IF90aGlzLl9zZXRTaW11bGNhc3QodXBkYXRlZFNkcCwgX3RoaXMuX3RyYWNrSWRzVG9BdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2V0TG9jYWxEZXNjcmlwdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29mZmVyJyxcbiAgICAgICAgICAgICAgICBzZHA6IHVwZGF0ZWRTZHBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgTWVkaWFUcmFja1NlbmRlciBJRCBvZiB0aGUgZ2l2ZW4gTWVkaWFTdHJlYW1UcmFjayBJRC5cbiAgICAgKiBTaW5jZSBhIE1lZGlhVHJhY2tTZW5kZXIncyB1bmRlcmx5aW5nIE1lZGlhU3RyZWFtVHJhY2sgY2FuIGJlXG4gICAgICogcmVwbGFjZWQsIHRoZSBjb3JyZXNwb25kaW5nIElEcyBjYW4gbWlzbWF0Y2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1RyYWNrLklEfSBpZFxuICAgICAqIEByZXR1cm5zIHtUcmFjay5JRH1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fZ2V0TWVkaWFUcmFja1NlbmRlcklkID0gZnVuY3Rpb24gKHRyYWNrSWQpIHtcbiAgICAgICAgdmFyIG1lZGlhVHJhY2tTZW5kZXIgPSBBcnJheS5mcm9tKHRoaXMuX3J0cFNlbmRlcnMua2V5cygpKS5maW5kKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGlkID0gX2EudHJhY2suaWQ7XG4gICAgICAgICAgICByZXR1cm4gaWQgPT09IHRyYWNrSWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVkaWFUcmFja1NlbmRlciA/IG1lZGlhVHJhY2tTZW5kZXIuaWQgOiB0cmFja0lkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIG9yIHJld3JpdGUgbG9jYWwgTWVkaWFTdHJlYW1UcmFjayBJRHMgaW4gdGhlIGdpdmVuIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UlRDU2Vzc2lvbkRlc2NyaXB0aW9ufSBkZXNjcmlwdGlvblxuICAgICAqIEByZXR1cm4ge1JUQ1Nlc3Npb25EZXNjcmlwdGlvbn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fYWRkT3JSZXdyaXRlTG9jYWxUcmFja0lkcyA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdHJhbnNjZWl2ZXJzID0gdGhpcy5fcGVlckNvbm5lY3Rpb24uZ2V0VHJhbnNjZWl2ZXJzKCk7XG4gICAgICAgIHZhciBhY3RpdmVUcmFuc2NlaXZlcnMgPSB0cmFuc2NlaXZlcnMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHNlbmRlciA9IF9hLnNlbmRlciwgc3RvcHBlZCA9IF9hLnN0b3BwZWQ7XG4gICAgICAgICAgICByZXR1cm4gIXN0b3BwZWQgJiYgc2VuZGVyICYmIHNlbmRlci50cmFjaztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IE1lZGlhU3RyZWFtVHJhY2sgSURzIHdpbGwgYmUgcHJlc2VudCBpblxuICAgICAgICAvLyBTRFBzLCBhbmQgZXZlbiBpZiB0aGV5IGFyZSwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhleSB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZVxuICAgICAgICAvLyBhY3R1YWwgTWVkaWFTdHJlYW1UcmFjayBJRHMuIFNvLCB3ZSBhZGQgb3IgcmUtd3JpdGUgdGhlIGFjdHVhbCBNZWRpYVN0cmVhbVRyYWNrIElEc1xuICAgICAgICAvLyB0byB0aGUgYXNzaWduZWQgbT0gc2VjdGlvbnMgaGVyZS5cbiAgICAgICAgdmFyIGFzc2lnbmVkVHJhbnNjZWl2ZXJzID0gYWN0aXZlVHJhbnNjZWl2ZXJzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBtaWQgPSBfYS5taWQ7XG4gICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1pZHNUb1RyYWNrSWRzID0gbmV3IE1hcChhc3NpZ25lZFRyYW5zY2VpdmVycy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gX2EubWlkLCBzZW5kZXIgPSBfYS5zZW5kZXI7XG4gICAgICAgICAgICByZXR1cm4gW21pZCwgX3RoaXMuX2dldE1lZGlhVHJhY2tTZW5kZXJJZChzZW5kZXIudHJhY2suaWQpXTtcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgc2RwMSA9IGFkZE9yUmV3cml0ZVRyYWNrSWRzKGRlc2NyaXB0aW9uLnNkcCwgbWlkc1RvVHJhY2tJZHMpO1xuICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBDaHJvbWUgYW5kIFNhZmFyaSBkbyBub3QgYXBwbHkgdGhlIG9mZmVyIHVudGlsIHRoZXkgZ2V0IGFuIGFuc3dlci5cbiAgICAgICAgLy8gU28sIHdlIGFkZCBvciByZS13cml0ZSB0aGUgYWN0dWFsIE1lZGlhU3RyZWFtVHJhY2sgSURzIHRvIHRoZSB1bmFzc2lnbmVkIG09IHNlY3Rpb25zIGhlcmUuXG4gICAgICAgIHZhciB1bmFzc2lnbmVkVHJhbnNjZWl2ZXJzID0gYWN0aXZlVHJhbnNjZWl2ZXJzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBtaWQgPSBfYS5taWQ7XG4gICAgICAgICAgICByZXR1cm4gIW1pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuZXdUcmFja0lkc0J5S2luZCA9IG5ldyBNYXAoWydhdWRpbycsICd2aWRlbyddLm1hcChmdW5jdGlvbiAoa2luZCkgeyByZXR1cm4gW1xuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIHVuYXNzaWduZWRUcmFuc2NlaXZlcnMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBzZW5kZXIgPSBfYS5zZW5kZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRlci50cmFjay5raW5kID09PSBraW5kO1xuICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBzZW5kZXIgPSBfYS5zZW5kZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9nZXRNZWRpYVRyYWNrU2VuZGVySWQoc2VuZGVyLnRyYWNrLmlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF07IH0pKTtcbiAgICAgICAgdmFyIHNkcDIgPSBhZGRPclJld3JpdGVOZXdUcmFja0lkcyhzZHAxLCBtaWRzVG9UcmFja0lkcywgbmV3VHJhY2tJZHNCeUtpbmQpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuX1JUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgICBzZHA6IHNkcDIsXG4gICAgICAgICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUm9sbGJhY2sgYW5kIGFwcGx5IHRoZSBnaXZlbiBvZmZlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdH0gb2ZmZXJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fcm9sbGJhY2tBbmRBcHBseU9mZmVyID0gZnVuY3Rpb24gKG9mZmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXRMb2NhbERlc2NyaXB0aW9uKHsgdHlwZTogJ3JvbGxiYWNrJyB9KS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgYSBsb2NhbCBkZXNjcmlwdGlvbiBvbiB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSVENTZXNzaW9uRGVzY3JpcHRpb258UlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdH0gZGVzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSAhPT0gJ3JvbGxiYWNrJyAmJiB0aGlzLl9zaG91bGRBcHBseUR0eCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBuZXcgdGhpcy5fUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgICAgICBzZHA6IGVuYWJsZUR0eEZvck9wdXMoZGVzY3JpcHRpb24uc2RwKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihkZXNjcmlwdGlvbikuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5fbG9nLndhcm4oXCJDYWxsaW5nIHNldExvY2FsRGVzY3JpcHRpb24gd2l0aCBhbiBSVENTZXNzaW9uRGVzY3JpcHRpb24gb2YgdHlwZSBcXFwiXCIgKyBkZXNjcmlwdGlvbi50eXBlICsgXCJcXFwiIGZhaWxlZCB3aXRoIHRoZSBlcnJvciBcXFwiXCIgKyBlcnJvci5tZXNzYWdlICsgXCJcXFwiLlwiLCBlcnJvcik7XG4gICAgICAgICAgICB2YXIgZXJyb3JUb1Rocm93ID0gbmV3IE1lZGlhQ2xpZW50TG9jYWxEZXNjRmFpbGVkRXJyb3IoKTtcbiAgICAgICAgICAgIHZhciBwdWJsaXNoV2FybmluZyA9IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNhbGxpbmcgc2V0TG9jYWxEZXNjcmlwdGlvbiB3aXRoIGFuIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBvZiB0eXBlIFxcXCJcIiArIGRlc2NyaXB0aW9uLnR5cGUgKyBcIlxcXCIgZmFpbGVkXCIsXG4gICAgICAgICAgICAgICAgY29kZTogZXJyb3JUb1Rocm93LmNvZGUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9sb2cud2FybihcIlRoZSBTRFAgd2FzIFwiICsgZGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgICAgICAgICBwdWJsaXNoV2FybmluZy5zZHAgPSBkZXNjcmlwdGlvbi5zZHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fcHVibGlzaE1lZGlhV2FybmluZyhwdWJsaXNoV2FybmluZyk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvclRvVGhyb3c7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgIT09ICdyb2xsYmFjaycpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9jYWxEZXNjcmlwdGlvbiA9IF90aGlzLl9hZGRPclJld3JpdGVMb2NhbFRyYWNrSWRzKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBJbiBvcmRlciBmb3IgdGhpcyBmZWF0dXJlIHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUgd2l0aCBvbGRlclxuICAgICAgICAgICAgICAgIC8vIFNESyB2ZXJzaW9ucyB3aGljaCB0byBub3Qgc3VwcG9ydCBvcHVzIERUWCwgd2UgYXBwZW5kIFwidXNlZHR4PTFcIiB0byB0aGUgbG9jYWwgU0RQXG4gICAgICAgICAgICAgICAgLy8gb25seSB3aGlsZSBhcHBseWluZyBpdC4gV2Ugd2lsbCBub3Qgc2VuZCBpdCBvdmVyIHRoZSB3aXJlIHRvIHByZXZlbnQgaW5hZHZlcnRlbnRcbiAgICAgICAgICAgICAgICAvLyBlbmFibGluZyBvZiBvcHVzIERUWCBpbiBvbGRlciBTREtzLiBOZXdlciBTREtzIHdpbGwgYXBwZW5kIFwidXNlZHR4PTFcIiBieSB0aGVtc2VsdmVzXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGRldmVsb3BlciBoYXMgcmVxdWVzdGVkIG9wdXMgRFRYIHRvIGJlIGVuYWJsZWQuIChKU0RLLTMwNjMpXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9zaG91bGRBcHBseUR0eCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9jYWxEZXNjcmlwdGlvbiA9IG5ldyBfdGhpcy5fUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNkcDogZW5hYmxlRHR4Rm9yT3B1cyhfdGhpcy5fbG9jYWxEZXNjcmlwdGlvbi5zZHAsIFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF90aGlzLl9sb2NhbERlc2NyaXB0aW9uLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2NhbENhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGVzY3JpcHRpb25SZXZpc2lvbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbGFzdFN0YWJsZURlc2NyaXB0aW9uUmV2aXNpb24gPSBfdGhpcy5fZGVzY3JpcHRpb25SZXZpc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgbmVnb3RpYXRpb25Db21wbGV0ZWQoX3RoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9jYWxVZnJhZyA9IGdldFVmcmFnKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdkZXNjcmlwdGlvbicsIF90aGlzLmdldFN0YXRlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIHJlbW90ZSBSVENTZXNzaW9uRGVzY3JpcHRpb24gb24gdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdH0gZGVzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24uc2RwID0gdGhpcy5fc2V0Q29kZWNQcmVmZXJlbmNlcyhkZXNjcmlwdGlvbi5zZHAsIHRoaXMuX3ByZWZlcnJlZEF1ZGlvQ29kZWNzLCB0aGlzLl9wcmVmZXJyZWRWaWRlb0NvZGVjcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkQXBwbHlEdHgpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5zZHAgPSBlbmFibGVEdHhGb3JPcHVzKGRlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBSZW1vdmUgXCJ1c2VkdHg9MVwiIGZyb20gb3B1cydzIGZtdHAgbGluZSBpZiBwcmVzZW50XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgRFRYIGlzIGRpc2FibGVkLlxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLnNkcCA9IGVuYWJsZUR0eEZvck9wdXMoZGVzY3JpcHRpb24uc2RwLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNGaXJlZm94KSB7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtcm9iZXJ0cyk6IERvIHRoaXMgdG8gcmVkdWNlIG91ciBNZWRpYVN0cmVhbSBjb3VudCBpbiBGaXJlZm94LiBCeVxuICAgICAgICAgICAgICAgIC8vIG1hcHBpbmcgTWVkaWFTdHJlYW0gSURzIGluIHRoZSBTRFAgdG8gXCItXCIsIHdlIGVuc3VyZSB0aGUgXCJ0cmFja1wiIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gZG9lc24ndCBpbmNsdWRlIGFueSBuZXcgTWVkaWFTdHJlYW1zIGluIEZpcmVmb3guIEl0cyBgc3RyZWFtc2AgbWVtYmVyXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBhbHdheXMgYmUgdGhlIGVtcHR5IEFycmF5LlxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLnNkcCA9IGZpbHRlck91dE1lZGlhU3RyZWFtSWRzKGRlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BlZXJDb25uZWN0aW9uLnJlbW90ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNJY2VMaXRlID0gL2E9aWNlLWxpdGUvLnRlc3QoZGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXNjcmlwdGlvbiA9IG5ldyB0aGlzLl9SVENTZXNzaW9uRGVzY3JpcHRpb24oZGVzY3JpcHRpb24pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gTk9URShzeWVycmFwcmFnYWRhKTogVk1TIGRvZXMgbm90IHN1cHBvcnQgSDI2NCBzaW11bGNhc3QuIFNvLFxuICAgICAgICAgICAgLy8gdW5zZXQgc2ltdWxjYXN0IGZvciBzZWN0aW9ucyBpbiBsb2NhbCBvZmZlciB3aGVyZSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAgICAvLyBzZWN0aW9ucyBpbiBhbnN3ZXIgZG9lc24ndCBoYXZlIHZwOCBhcyBwcmVmZXJyZWQgY29kZWMgYW5kIHJlYXBwbHkgb2ZmZXIuXG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ2Fuc3dlcicgJiYgX3RoaXMuX2xvY2FsRGVzY3JpcHRpb25XaXRob3V0U2ltdWxjYXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6aWYgd2Ugd2VyZSB1c2luZyBhZGFwdGl2ZSBzaW11bGNhc3QsIGFuZCBpZiBpdHMgbm90IHN1cHBvcnRlZCBieSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAvLyByZXZlcnQgc2ltdWxjYXN0IGV2ZW4gZm9yIHZwOC5cbiAgICAgICAgICAgICAgICB2YXIgYWRhcHRpdmVTaW11bGNhc3RFbnRyeSA9IF90aGlzLl9wcmVmZXJyZWRWaWRlb0NvZGVjcy5maW5kKGZ1bmN0aW9uIChjcykgeyByZXR1cm4gJ2FkYXB0aXZlU2ltdWxjYXN0JyBpbiBjczsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHJldmVydEZvckFsbCA9ICEhYWRhcHRpdmVTaW11bGNhc3RFbnRyeSAmJiBhZGFwdGl2ZVNpbXVsY2FzdEVudHJ5LmFkYXB0aXZlU2ltdWxjYXN0ID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgc2RwV2l0aG91dFNpbXVsY2FzdEZvck5vblZQOE1lZGlhU2VjdGlvbnMgPSBfdGhpcy5fcmV2ZXJ0U2ltdWxjYXN0KF90aGlzLl9sb2NhbERlc2NyaXB0aW9uLnNkcCwgX3RoaXMuX2xvY2FsRGVzY3JpcHRpb25XaXRob3V0U2ltdWxjYXN0LnNkcCwgZGVzY3JpcHRpb24uc2RwLCByZXZlcnRGb3JBbGwpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9sb2NhbERlc2NyaXB0aW9uV2l0aG91dFNpbXVsY2FzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNkcFdpdGhvdXRTaW11bGNhc3RGb3JOb25WUDhNZWRpYVNlY3Rpb25zICE9PSBfdGhpcy5fbG9jYWxEZXNjcmlwdGlvbi5zZHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yb2xsYmFja0FuZEFwcGx5T2ZmZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX3RoaXMuX2xvY2FsRGVzY3JpcHRpb24udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNkcDogc2RwV2l0aG91dFNpbXVsY2FzdEZvck5vblZQOE1lZGlhU2VjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjcmlwdGlvbik7IH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pc1Jlc3RhcnRpbmdJY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZygnQW4gSUNFIHJlc3RhcnQgd2FzIGluLXByb2dyZXNzIGFuZCBpcyBub3cgY29tcGxldGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc1Jlc3RhcnRpbmdJY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmVnb3RpYXRpb25Db21wbGV0ZWQoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2cud2FybihcIkNhbGxpbmcgc2V0UmVtb3RlRGVzY3JpcHRpb24gd2l0aCBhbiBSVENTZXNzaW9uRGVzY3JpcHRpb24gb2YgdHlwZSBcXFwiXCIgKyBkZXNjcmlwdGlvbi50eXBlICsgXCJcXFwiIGZhaWxlZCB3aXRoIHRoZSBlcnJvciBcXFwiXCIgKyBlcnJvci5tZXNzYWdlICsgXCJcXFwiLlwiLCBlcnJvcik7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24uc2RwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy53YXJuKFwiVGhlIFNEUCB3YXMgXCIgKyBkZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0ncyBkZXNjcmlwdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdH0gZGVzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fdXBkYXRlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3dpdGNoIChkZXNjcmlwdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhbnN3ZXInOlxuICAgICAgICAgICAgY2FzZSAncHJhbnN3ZXInOlxuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbi5yZXZpc2lvbiAhPT0gdGhpcy5fZGVzY3JpcHRpb25SZXZpc2lvblxuICAgICAgICAgICAgICAgICAgICB8fCB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSAhPT0gJ2hhdmUtbG9jYWwtb2ZmZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzY3JpcHRpb25SZXZpc2lvbiA9IGRlc2NyaXB0aW9uLnJldmlzaW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZSgpO1xuICAgICAgICAgICAgY2FzZSAnY3JlYXRlLW9mZmVyJzpcbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24ucmV2aXNpb24gPD0gdGhpcy5fbGFzdFN0YWJsZURlc2NyaXB0aW9uUmV2aXNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9uZWVkc0Fuc3dlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZWREZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uUmV2aXNpb24gPSBkZXNjcmlwdGlvbi5yZXZpc2lvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb2ZmZXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ29mZmVyJzpcbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24ucmV2aXNpb24gPD0gdGhpcy5fbGFzdFN0YWJsZURlc2NyaXB0aW9uUmV2aXNpb25cbiAgICAgICAgICAgICAgICAgICAgfHwgdGhpcy5fcGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1sb2NhbC1vZmZlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IEZvciBhIHBlZXIgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyAxKSBjcmVhdGVPZmZlciBhbHdheXMgZ2VuZXJhdGUgU0RQIHdpdGggYHNldHVwOmFjdHBhc3NgXG4gICAgICAgICAgICAgICAgICAgIC8vIDIpIHdoZW4gcmVtb3RlIGRlc2NyaXB0aW9uIGlzIHNldCBgc2V0dXA6YWN0aXZlYCAgLSB0aGUgYW5zd2VyIGdlbmVyYXRlZCBzZWxlY3RzIHRoZSBkdGxzIHJvbGUgb2Ygc2V0dXA6cGFzc2l2ZVxuICAgICAgICAgICAgICAgICAgICAvLyAzKSB3aGVuIHJlbW90ZSBkZXNjcmlwdGlvbiBpcyBzZXQgYHNldHVwOnBhc3NpdmVgIC0gdGhlIGFuc3dlciBnZW5lcmF0ZWQgc2VsZWN0cyB0aGUgZHRscyByb2xlIG9mIHNldHVwOmFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAvLyA0KSB3aGVuIHJlbW90ZSBkZXNjcmlwdGlvbiBpcyBzZXQgYHNldHVwOmFjdHBhc3NgIC0gdGhlIGFuc3dlciBnZW5lcmF0ZWQgdXNlcyB0aGUgcHJldmlvdXNseSBuZWdvdGlhdGVkIHJvbGUgKGlmIG5vdCBuZWdvdGlhdGVkIHByZXZpb3VzbHkgc2V0dXA6YWN0aXZlIGlzIHVzZWQpXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgdGVzdCBzaG93cyB0aGUgIGJlaGF2aW9yOiBodHRwczovL2dpdGh1Yi5jb20vdHdpbGlvL3R3aWxpby13ZWJydGMuanMvYmxvYi9tYXN0ZXIvdGVzdC9pbnRlZ3JhdGlvbi9zcGVjL3J0Y3BlZXJjb25uZWN0aW9uLmpzI0w5MzZcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBnbGFyZSBoYW5kbGluZyAoaWYgZHRscyByb2xlIHdhcyBub3QgbmVnb3RpYXRlZCBiZWZvcmUgKSB0aGUgZ2VuZXJhdGVkIGFuc3dlciB3aWxsIHNldCBzZXR1cDphY3RpdmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRoYXQuIGxldHMgd2FpdCBmb3IgXCJpbml0aWFsIG5lZ290aWF0aW9uXCIgYmVmb3JlIGF0dGVtcHRpbmcgZ2xhcmUgaGFuZGxpbmcuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZWVkc0Fuc3dlciAmJiB0aGlzLl9sYXN0U3RhYmxlRGVzY3JpcHRpb25SZXZpc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWVkRGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXNjcmlwdGlvblJldmlzaW9uID0gZGVzY3JpcHRpb24ucmV2aXNpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVHbGFyZShkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uUmV2aXNpb24gPSBkZXNjcmlwdGlvbi5yZXZpc2lvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5zd2VyKGRlc2NyaXB0aW9uKS50aGVuKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYW5zd2VyIG9yIHByYW5zd2VyLlxuICAgICAgICB2YXIgcmV2aXNpb24gPSBkZXNjcmlwdGlvbi5yZXZpc2lvbjtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9zZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjcmlwdGlvbik7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIGVycm9yVG9UaHJvdyA9IG5ldyBNZWRpYUNsaWVudFJlbW90ZURlc2NGYWlsZWRFcnJvcigpO1xuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hNZWRpYVdhcm5pbmcoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ2FsbGluZyBzZXRSZW1vdGVEZXNjcmlwdGlvbiB3aXRoIGFuIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBvZiB0eXBlIFxcXCJcIiArIGRlc2NyaXB0aW9uLnR5cGUgKyBcIlxcXCIgZmFpbGVkXCIsXG4gICAgICAgICAgICAgICAgY29kZTogZXJyb3JUb1Rocm93LmNvZGUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIHNkcDogZGVzY3JpcHRpb24uc2RwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IGVycm9yVG9UaHJvdztcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbGFzdFN0YWJsZURlc2NyaXB0aW9uUmV2aXNpb24gPSByZXZpc2lvbjtcbiAgICAgICAgICAgIF90aGlzLl9uZWVkc0Fuc3dlciA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jaGVja0ljZUJveChkZXNjcmlwdGlvbik7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9xdWV1ZWREZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICYmIF90aGlzLl91cGRhdGVEZXNjcmlwdGlvbihfdGhpcy5fcXVldWVkRGVzY3JpcHRpb24pO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9xdWV1ZWREZXNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX21heWJlUmVvZmZlcihfdGhpcy5fcGVlckNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbikudGhlbihmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9J3MgSUNFIGNhbmRpZGF0ZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaWNlU3RhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fdXBkYXRlSWNlID0gZnVuY3Rpb24gKGljZVN0YXRlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGVzID0gdGhpcy5fcmVtb3RlQ2FuZGlkYXRlcy51cGRhdGUoaWNlU3RhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkSWNlQ2FuZGlkYXRlcyhjYW5kaWRhdGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIHtAbGluayBEYXRhVHJhY2tTZW5kZXJ9IHRvIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0uXG4gICAgICogQHBhcmFtIHtEYXRhVHJhY2tTZW5kZXJ9IGRhdGFUcmFja1NlbmRlclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLmFkZERhdGFUcmFja1NlbmRlciA9IGZ1bmN0aW9uIChkYXRhVHJhY2tTZW5kZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGFDaGFubmVscy5oYXMoZGF0YVRyYWNrU2VuZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZGF0YUNoYW5uZWxEaWN0ID0ge1xuICAgICAgICAgICAgICAgIG9yZGVyZWQ6IGRhdGFUcmFja1NlbmRlci5vcmRlcmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGRhdGFUcmFja1NlbmRlci5tYXhQYWNrZXRMaWZlVGltZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGFDaGFubmVsRGljdC5tYXhQYWNrZXRMaWZlVGltZSA9IGRhdGFUcmFja1NlbmRlci5tYXhQYWNrZXRMaWZlVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhVHJhY2tTZW5kZXIubWF4UmV0cmFuc21pdHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbERpY3QubWF4UmV0cmFuc21pdHMgPSBkYXRhVHJhY2tTZW5kZXIubWF4UmV0cmFuc21pdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF0YUNoYW5uZWwgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVEYXRhQ2hhbm5lbChkYXRhVHJhY2tTZW5kZXIuaWQsIGRhdGFDaGFubmVsRGljdCk7XG4gICAgICAgICAgICBkYXRhVHJhY2tTZW5kZXIuYWRkRGF0YUNoYW5uZWwoZGF0YUNoYW5uZWwpO1xuICAgICAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWxzLnNldChkYXRhVHJhY2tTZW5kZXIsIGRhdGFDaGFubmVsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiRXJyb3IgY3JlYXRpbmcgYW4gUlRDRGF0YUNoYW5uZWwgZm9yIERhdGFUcmFjayBcXFwiXCIgKyBkYXRhVHJhY2tTZW5kZXIuaWQgKyBcIlxcXCI6IFwiICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9oYW5kbGVRdWV1ZWRQdWJsaXNoZXJIaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFUcmFja1NlbmRlclRvUHVibGlzaGVySGludHMuZm9yRWFjaChmdW5jdGlvbiAoX2EsIG1lZGlhVHJhY2tTZW5kZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSBfYS5kZWZlcnJlZCwgZW5jb2RpbmdzID0gX2EuZW5jb2RpbmdzO1xuICAgICAgICAgICAgICAgIF90aGlzLl9tZWRpYVRyYWNrU2VuZGVyVG9QdWJsaXNoZXJIaW50cy5kZWxldGUobWVkaWFUcmFja1NlbmRlcik7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldFB1Ymxpc2hlckhpbnQobWVkaWFUcmFja1NlbmRlciwgZW5jb2RpbmdzKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGRlZmVycmVkLnJlamVjdChlcnJvcik7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHVwZGF0ZXMgZW5jb2RpbmdzIGZvciBzaW11bGNhc3QgbGF5ZXJzIG9mIGdpdmVuIHNlbmRlci5cbiAgICAgKiBAcGFyYW0ge1JUQ1J0cFNlbmRlcn0gc2VuZGVyXG4gICAgICogQHBhcmFtIHtBcnJheTx7ZW5hYmxlZDogYm9vbGVhbiwgbGF5ZXJfaW5kZXg6IG51bWJlcn0+fG51bGx9IGVuY29kaW5nc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IHN0cmluZyBpbmRpY2F0aW5nIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uLiBjYW4gYmUgb25lIG9mXG4gICAgICogIFwiT0tcIiwgXCJJTlZBTElEX0hJTlRcIiwgXCJDT1VMRF9OT1RfQVBQTFlfSElOVFwiLCBcIlVOS05PV05fVFJBQ0tcIlxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9zZXRQdWJsaXNoZXJIaW50ID0gZnVuY3Rpb24gKG1lZGlhVHJhY2tTZW5kZXIsIGVuY29kaW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaXNGaXJlZm94KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdDT1VMRF9OT1RfQVBQTFlfSElOVCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tZWRpYVRyYWNrU2VuZGVyVG9QdWJsaXNoZXJIaW50cy5oYXMobWVkaWFUcmFja1NlbmRlcikpIHtcbiAgICAgICAgICAgIC8vIHNraXAgYW55IHN0YWxlIGhpbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZWRpYVRyYWNrU2VuZGVyLlxuICAgICAgICAgICAgdmFyIHF1ZXVlZEhpbnQgPSB0aGlzLl9tZWRpYVRyYWNrU2VuZGVyVG9QdWJsaXNoZXJIaW50cy5nZXQobWVkaWFUcmFja1NlbmRlcik7XG4gICAgICAgICAgICBxdWV1ZWRIaW50LmRlZmVycmVkLnJlc29sdmUoJ1JFUVVFU1RfU0tJUFBFRCcpO1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFUcmFja1NlbmRlclRvUHVibGlzaGVySGludHMuZGVsZXRlKG1lZGlhVHJhY2tTZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZW5kZXIgPSB0aGlzLl9ydHBTZW5kZXJzLmdldChtZWRpYVRyYWNrU2VuZGVyKTtcbiAgICAgICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdDb3VsZCBub3QgYXBwbHkgcHVibGlzaGVyIGhpbnQgYmVjYXVzZSBSVENSdHBTZW5kZXIgd2FzIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnVU5LTk9XTl9UUkFDSycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdDb3VsZCBub3QgYXBwbHkgcHVibGlzaGVyIGhpbnQgYmVjYXVzZSBzaWduYWxpbmdTdGF0ZSB3YXMgXCJjbG9zZWRcIicpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnQ09VTERfTk9UX0FQUExZX0hJTlQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09ICdzdGFibGUnKSB7XG4gICAgICAgICAgICAvLyBlbnF1ZXVlIHRoaXMgaGludCB0byBiZSBhcHBsaWVkIHdoZW4gcGMgYmVjb21lcyBzdGFibGUuXG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ1F1ZXVpbmcgdXAgcHVibGlzaGVyIGhpbnQgYmVjYXVzZSBzaWduYWxpbmdTdGF0ZTonLCB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSk7XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFUcmFja1NlbmRlclRvUHVibGlzaGVySGludHMuc2V0KG1lZGlhVHJhY2tTZW5kZXIsIHsgZGVmZXJyZWQ6IGRlZmVycmVkLCBlbmNvZGluZ3M6IGVuY29kaW5ncyB9KTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZW5jb2RpbmdzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuYWJsZWQgPSBfYS5lbmFibGVkLCBsYXllckluZGV4ID0gX2EubGF5ZXJfaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IGxheWVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZyhcImxheWVyOlwiICsgbGF5ZXJJbmRleCArIFwiLCBhY3RpdmU6XCIgKyBwYXJhbWV0ZXJzLmVuY29kaW5nc1tsYXllckluZGV4XS5hY3RpdmUgKyBcIiA9PiBcIiArIGVuYWJsZWQpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5nc1tsYXllckluZGV4XS5hY3RpdmUgPSBlbmFibGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy53YXJuKFwiaW52YWxpZCBsYXllcjpcIiArIGxheWVySW5kZXggKyBcIiwgYWN0aXZlOlwiICsgZW5hYmxlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZShtcGF0d2FyZGhhbik6IGFmdGVyIHB1Ymxpc2hlciBoaW50cyBhcmUgYXBwbGllZCwgb3ZlcndyaXRlIHdpdGggZGVmYXVsdCBlbmNvZGluZ3NcbiAgICAgICAgLy8gdG8gZGlzYWJsZSBhbnkgZW5jb2RpbmcgdGhhdCBzaG91bGRuJ3QgaGF2ZSBiZWVuIGVuYWJsZWQgYnkgcHVibGlzaGVyX2hpbnRzLlxuICAgICAgICAvLyBXaGVuIGVuY29kaW5ncz09PW51bGwgKHRoYXQgaXMgd2UgYXJlIGFza2VkIHRvIHJlc2V0IGVuY29kaW5ncyBmb3IgcmVwbGFjZVRyYWNrKVxuICAgICAgICAvLyBhbG9uZyB3aXRoIGRpc2FibGluZyBlbmNvZGluZ3MsIGNsZWFyIGFjdGl2ZSBmbGFnIGZvciBlbmNvZGluZ3MgdGhhdCBzaG91bGQgbm90IGJlIGRpc2FibGVkXG4gICAgICAgIHRoaXMuX21heWJlVXBkYXRlRW5jb2RpbmdzKHNlbmRlci50cmFjaywgcGFyYW1ldGVycy5lbmNvZGluZ3MsIGVuY29kaW5ncyA9PT0gbnVsbCAvKiB0cmFja1JlcGxhY2VkICovKTtcbiAgICAgICAgcmV0dXJuIHNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gJ09LJzsgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5fbG9nLmVycm9yKCdGYWlsZWQgdG8gYXBwbHkgcHVibGlzaGVyIGhpbnRzOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiAnQ09VTERfTk9UX0FQUExZX0hJTlQnO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUge0BsaW5rIE1lZGlhVHJhY2tTZW5kZXJ9IHRvIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0uXG4gICAgICogQHBhcmFtIHtNZWRpYVRyYWNrU2VuZGVyfSBtZWRpYVRyYWNrU2VuZGVyXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuYWRkTWVkaWFUcmFja1NlbmRlciA9IGZ1bmN0aW9uIChtZWRpYVRyYWNrU2VuZGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgdGhpcy5fcnRwU2VuZGVycy5oYXMobWVkaWFUcmFja1NlbmRlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhbnNjZWl2ZXIgPSB0aGlzLl9hZGRPclVwZGF0ZVRyYW5zY2VpdmVyKG1lZGlhVHJhY2tTZW5kZXIudHJhY2spO1xuICAgICAgICB2YXIgc2VuZGVyID0gdHJhbnNjZWl2ZXIuc2VuZGVyO1xuICAgICAgICBtZWRpYVRyYWNrU2VuZGVyLmFkZFNlbmRlcihzZW5kZXIsIGZ1bmN0aW9uIChlbmNvZGluZ3MpIHsgcmV0dXJuIF90aGlzLl9zZXRQdWJsaXNoZXJIaW50KG1lZGlhVHJhY2tTZW5kZXIsIGVuY29kaW5ncyk7IH0pO1xuICAgICAgICB0aGlzLl9ydHBOZXdTZW5kZXJzLmFkZChzZW5kZXIpO1xuICAgICAgICB0aGlzLl9ydHBTZW5kZXJzLnNldChtZWRpYVRyYWNrU2VuZGVyLCBzZW5kZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uUmV2aXNpb24rKztcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsRGVzY3JpcHRpb24gPSB7IHR5cGU6ICdjbG9zZScgfTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVzY3JpcHRpb24nLCB0aGlzLmdldFN0YXRlKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHtAbGluayBEYXRhVHJhY2tSZWNlaXZlcn1zIGFuZCB0aGUge0BsaW5rIE1lZGlhVHJhY2tSZWNlaXZlcn1zIG9uIHRoZVxuICAgICAqIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8RGF0YVRyYWNrUmVjZWl2ZXJ8TWVkaWFUcmFja1JlY2VpdmVyPn0gdHJhY2tSZWNlaXZlcnNcbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5nZXRUcmFja1JlY2VpdmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fZGF0YVRyYWNrUmVjZWl2ZXJzKS5jb25jYXQoQXJyYXkuZnJvbSh0aGlzLl9tZWRpYVRyYWNrUmVjZWl2ZXJzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfSdzIHN0YXRlIChzcGVjaWZpY2FsbHksIGl0cyBkZXNjcmlwdGlvbikuXG4gICAgICogQHJldHVybnMgez9vYmplY3R9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9jYWxEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IFJldHVybiBtb3N0IHJlY2VudCBsb2NhbERlc2NyaXB0aW9uLiBJZiB0aGUgbW9zdCByZWNlbnQgbG9jYWwgZGVzY3JpcHRpb24gaXMgYW5cbiAgICAgICAgLy8gYW5zd2VyLCBhbmQgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGZvciBzZW5kaW5nIGEgXCJzeW5jXCIgbWVzc2FnZSB3aGlsZSB0aGUgbmV4dCByZW1vdGUgb2ZmZXIgaXMgYmVpbmcgcHJvY2Vzc2VkLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHNlbmQgdGhlIG1vc3QgcmVjZW50IHN0YWJsZSBkZXNjcmlwdGlvbiByZXZpc2lvbiBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IGRlc2NyaXB0aW9uIHJldmlzaW9uLFxuICAgICAgICAvLyB3aGljaCBpcyBzdXBwb3NlZCB0byBiZSBmb3IgdGhlIG5leHQgbG9jYWwgYW5zd2VyLlxuICAgICAgICB2YXIgbG9jYWxEZXNjcmlwdGlvblJldmlzaW9uID0gdGhpcy5fbG9jYWxEZXNjcmlwdGlvbi50eXBlID09PSAnYW5zd2VyJyA/IHRoaXMuX2xhc3RTdGFibGVEZXNjcmlwdGlvblJldmlzaW9uIDogdGhpcy5fZGVzY3JpcHRpb25SZXZpc2lvbjtcbiAgICAgICAgdmFyIGxvY2FsRGVzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLl9sb2NhbERlc2NyaXB0aW9uLnR5cGUsXG4gICAgICAgICAgICByZXZpc2lvbjogbG9jYWxEZXNjcmlwdGlvblJldmlzaW9uXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9sb2NhbERlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgICAgICAgbG9jYWxEZXNjcmlwdGlvbi5zZHAgPSB0aGlzLl9sb2NhbERlc2NyaXB0aW9uLnNkcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IGxvY2FsRGVzY3JpcHRpb24sXG4gICAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIG9mZmVyIGFuZCBzZXQgaXQgb24gdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5vZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX25lZWRzQW5zd2VyIHx8IHRoaXMuX2lzUmVzdGFydGluZ0ljZSkge1xuICAgICAgICAgICAgdGhpcy5fc2hvdWxkT2ZmZXIgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJyYWNrZXQoJ29mZmVyaW5nJywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgX3RoaXMudHJhbnNpdGlvbigndXBkYXRpbmcnLCBrZXkpO1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBfdGhpcy5fbmVlZHNBbnN3ZXIgfHwgX3RoaXMuX2lzUmVzdGFydGluZ0ljZSA/IFByb21pc2UucmVzb2x2ZSgpIDogX3RoaXMuX29mZmVyKCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50cnlUcmFuc2l0aW9uKCdvcGVuJywga2V5KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnRyeVRyYW5zaXRpb24oJ29wZW4nLCBrZXkpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEge0BsaW5rIERhdGFUcmFja1NlbmRlcn0gZnJvbSB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEBwYXJhbSB7RGF0YVRyYWNrU2VuZGVyfSBkYXRhVHJhY2tTZW5kZXJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5yZW1vdmVEYXRhVHJhY2tTZW5kZXIgPSBmdW5jdGlvbiAoZGF0YVRyYWNrU2VuZGVyKSB7XG4gICAgICAgIHZhciBkYXRhQ2hhbm5lbCA9IHRoaXMuX2RhdGFDaGFubmVscy5nZXQoZGF0YVRyYWNrU2VuZGVyKTtcbiAgICAgICAgaWYgKGRhdGFDaGFubmVsKSB7XG4gICAgICAgICAgICBkYXRhVHJhY2tTZW5kZXIucmVtb3ZlRGF0YUNoYW5uZWwoZGF0YUNoYW5uZWwpO1xuICAgICAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWxzLmRlbGV0ZShkYXRhVHJhY2tTZW5kZXIpO1xuICAgICAgICAgICAgZGF0YUNoYW5uZWwuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSB7QGxpbmsgTWVkaWFUcmFja1NlbmRlcn0gZnJvbSB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEBwYXJhbSB7TWVkaWFUcmFja1NlbmRlcn0gbWVkaWFUcmFja1NlbmRlclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLnJlbW92ZU1lZGlhVHJhY2tTZW5kZXIgPSBmdW5jdGlvbiAobWVkaWFUcmFja1NlbmRlcikge1xuICAgICAgICB2YXIgc2VuZGVyID0gdGhpcy5fcnRwU2VuZGVycy5nZXQobWVkaWFUcmFja1NlbmRlcik7XG4gICAgICAgIGlmICghc2VuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24ucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBtZWRpYVRyYWNrU2VuZGVyLnJlbW92ZVNlbmRlcihzZW5kZXIpO1xuICAgICAgICAvLyBjbGVhbiB1cCBhbnkgcGVuZGluZyBwdWJsaXNoZXIgaGludHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWVkaWFUcmFja1NlbmRlci5cbiAgICAgICAgaWYgKHRoaXMuX21lZGlhVHJhY2tTZW5kZXJUb1B1Ymxpc2hlckhpbnRzLmhhcyhtZWRpYVRyYWNrU2VuZGVyKSkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlZEhpbnQgPSB0aGlzLl9tZWRpYVRyYWNrU2VuZGVyVG9QdWJsaXNoZXJIaW50cy5nZXQobWVkaWFUcmFja1NlbmRlcik7XG4gICAgICAgICAgICBxdWV1ZWRIaW50LmRlZmVycmVkLnJlc29sdmUoJ1VOS05PV05fVFJBQ0snKTtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhVHJhY2tTZW5kZXJUb1B1Ymxpc2hlckhpbnRzLmRlbGV0ZShtZWRpYVRyYWNrU2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ydHBOZXdTZW5kZXJzLmRlbGV0ZShzZW5kZXIpO1xuICAgICAgICB0aGlzLl9ydHBTZW5kZXJzLmRlbGV0ZShtZWRpYVRyYWNrU2VuZGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgUlRDQ29uZmlndXJhdGlvbiBvbiB0aGUgdW5kZXJseWluZyBSVENQZWVyQ29ubmVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge1JUQ0NvbmZpZ3VyYXRpb259IGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5zZXRDb25maWd1cmF0aW9uID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRDb25maWd1cmF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRDb25maWd1cmF0aW9uKGdldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIElDRSByZWNvbm5lY3QgdGltZW91dCBwZXJpb2QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBlcmlvZCAtIFBlcmlvZCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuc2V0SWNlUmVjb25uZWN0VGltZW91dCA9IGZ1bmN0aW9uIChwZXJpb2QpIHtcbiAgICAgICAgdGhpcy5faWNlUmVjb25uZWN0VGltZW91dC5zZXREZWxheShwZXJpb2QpO1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ1VwZGF0ZWQgSUNFIHJlY29ubmVjdGlvbiB0aW1lb3V0IHBlcmlvZDonLCB0aGlzLl9pY2VSZWNvbm5lY3RUaW1lb3V0LmRlbGF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGVlckNvbm5lY3Rpb25TdGF0ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChwZWVyQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmJyYWNrZXQoJ3VwZGF0aW5nJywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnRyYW5zaXRpb24oJ3VwZGF0aW5nJywga2V5KTtcbiAgICAgICAgICAgIHZhciB1cGRhdGVzID0gW107XG4gICAgICAgICAgICBpZiAocGVlckNvbm5lY3Rpb25TdGF0ZS5pY2UpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goX3RoaXMuX3VwZGF0ZUljZShwZWVyQ29ubmVjdGlvblN0YXRlLmljZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBlZXJDb25uZWN0aW9uU3RhdGUuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goX3RoaXMuX3VwZGF0ZURlc2NyaXB0aW9uKHBlZXJDb25uZWN0aW9uU3RhdGUuZGVzY3JpcHRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh1cGRhdGVzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50cnlUcmFuc2l0aW9uKCdvcGVuJywga2V5KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnRyeVRyYW5zaXRpb24oJ29wZW4nLCBrZXkpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0ncyBtZWRpYSBzdGF0aXN0aWNzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN0YW5kYXJkaXplZFN0YXRzUmVzcG9uc2U+fVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZ2V0U3RhdGlzdGljcyh0aGlzLl9wZWVyQ29ubmVjdGlvbikudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIHJld3JpdGVUcmFja0lkcyhfdGhpcywgcmVzcG9uc2UpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQZWVyQ29ubmVjdGlvblYyO1xufShTdGF0ZU1hY2hpbmUpKTtcbmZ1bmN0aW9uIHJld3JpdGVMb2NhbFRyYWNrSWQocGN2Miwgc3RhdHMpIHtcbiAgICB2YXIgdHJhY2tJZCA9IHBjdjIuX2dldE1lZGlhVHJhY2tTZW5kZXJJZChzdGF0cy50cmFja0lkKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdGF0cywgeyB0cmFja0lkOiB0cmFja0lkIH0pO1xufVxuZnVuY3Rpb24gcmV3cml0ZVRyYWNrSWQocGN2Miwgc3RhdHMpIHtcbiAgICB2YXIgcmVjZWl2ZXIgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocGN2Mi5fbWVkaWFUcmFja1JlY2VpdmVycykpLmZpbmQoZnVuY3Rpb24gKHJlY2VpdmVyKSB7IHJldHVybiByZWNlaXZlci50cmFjay5pZCA9PT0gc3RhdHMudHJhY2tJZDsgfSk7XG4gICAgdmFyIHRyYWNrSWQgPSByZWNlaXZlciA/IHJlY2VpdmVyLmlkIDogbnVsbDtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdGF0cywgeyB0cmFja0lkOiB0cmFja0lkIH0pO1xufVxuZnVuY3Rpb24gcmV3cml0ZVRyYWNrSWRzKHBjdjIsIHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocmVzcG9uc2UsIHtcbiAgICAgICAgcmVtb3RlQXVkaW9UcmFja1N0YXRzOiByZXNwb25zZS5yZW1vdGVBdWRpb1RyYWNrU3RhdHMubWFwKGZ1bmN0aW9uIChzdGF0cykgeyByZXR1cm4gcmV3cml0ZVRyYWNrSWQocGN2Miwgc3RhdHMpOyB9KSxcbiAgICAgICAgcmVtb3RlVmlkZW9UcmFja1N0YXRzOiByZXNwb25zZS5yZW1vdGVWaWRlb1RyYWNrU3RhdHMubWFwKGZ1bmN0aW9uIChzdGF0cykgeyByZXR1cm4gcmV3cml0ZVRyYWNrSWQocGN2Miwgc3RhdHMpOyB9KSxcbiAgICAgICAgbG9jYWxBdWRpb1RyYWNrU3RhdHM6IHJlc3BvbnNlLmxvY2FsQXVkaW9UcmFja1N0YXRzLm1hcChmdW5jdGlvbiAoc3RhdHMpIHsgcmV0dXJuIHJld3JpdGVMb2NhbFRyYWNrSWQocGN2Miwgc3RhdHMpOyB9KSxcbiAgICAgICAgbG9jYWxWaWRlb1RyYWNrU3RhdHM6IHJlc3BvbnNlLmxvY2FsVmlkZW9UcmFja1N0YXRzLm1hcChmdW5jdGlvbiAoc3RhdHMpIHsgcmV0dXJuIHJld3JpdGVMb2NhbFRyYWNrSWQocGN2Miwgc3RhdHMpOyB9KSxcbiAgICB9KTtcbn1cbi8qKlxuICogQGV2ZW50IFBlZXJDb25uZWN0aW9uVjIjY2FuZGlkYXRlc1xuICogQHBhcmFtIHtvYmplY3R9IGNhbmRpZGF0ZXNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgUGVlckNvbm5lY3Rpb25WMiNjb25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gKi9cbi8qKlxuICogQGV2ZW50IFBlZXJDb25uZWN0aW9uVjIjZGVzY3JpcHRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBkZXNjcmlwdGlvblxuICovXG4vKipcbiAqIEBldmVudCBQZWVyQ29ubmVjdGlvblYyI2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcbiAqL1xuLyoqXG4gKiBAZXZlbnQgUGVlckNvbm5lY3Rpb25WMiN0cmFja0FkZGVkXG4gKiBAcGFyYW0ge0RhdGFUcmFja1JlY2VpdmVyfE1lZGlhVHJhY2tSZWNlaXZlcn0gdHJhY2tSZWNlaXZlclxuICovXG5mdW5jdGlvbiBnZXRVZnJhZyhkZXNjcmlwdGlvbikge1xuICAgIGlmIChkZXNjcmlwdGlvbi5zZHApIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZGVzY3JpcHRpb24uc2RwLm1hdGNoKC9eYT1pY2UtdWZyYWc6KFthLXpBLVowLTkrL10rKS9tKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZSdcbiAgICB9LCBjb25maWd1cmF0aW9uKTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgTWVkaWFTdHJlYW1UcmFjayBvZiB0aGUgZ2l2ZW4gUlRDUlRQU2VuZGVyIGlzIGEgbm9uLWVuZGVkXG4gKiBNZWRpYVN0cmVhbVRyYWNrIG9mIGEgZ2l2ZW4ga2luZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICogQHBhcmFtIHtSVENSdHBTZW5kZXJ9IHNlbmRlclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTZW5kZXJPZktpbmQoa2luZCwgc2VuZGVyKSB7XG4gICAgdmFyIHRyYWNrID0gc2VuZGVyLnRyYWNrO1xuICAgIHJldHVybiB0cmFjayAmJiB0cmFjay5raW5kID09PSBraW5kICYmIHRyYWNrLnJlYWR5U3RhdGUgIT09ICdlbmRlZCc7XG59XG4vKipcbiAqIFByZWZlcnJlZCBjb2RlY3MuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQcmVmZXJyZWRDb2RlY3NcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8QXVkaW9Db2RlYz59IGF1ZGlvXG4gKiBAcHJvcGVydHkge0FycmF5PFZpZGVvQ29kZWM+fSB2aWRlb1xuICovXG5mdW5jdGlvbiBmaWx0ZXJPdXRNZWRpYVN0cmVhbUlkcyhzZHApIHtcbiAgICByZXR1cm4gc2RwLnJlcGxhY2UoL2E9bXNpZDpbXiBdKyAvZywgJ2E9bXNpZDotICcpO1xufVxuLyoqXG4gKiBXaGV0aGVyIGFuIFJUQ1J0cFRyYW5zY2VpdmVyIGNhbiBiZSByZWN5Y2xlZC5cbiAqIEBwYXJhbSB7UlRDUnRwVHJhbnNjZWl2ZXJ9IHRyYW5zY2VpdmVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc2hvdWxkUmVjeWNsZVRyYW5zY2VpdmVyKHRyYW5zY2VpdmVyLCBwY3YyKSB7XG4gICAgcmV0dXJuICF0cmFuc2NlaXZlci5zdG9wcGVkXG4gICAgICAgICYmICFwY3YyLl9yZXBsYWNlVHJhY2tQcm9taXNlcy5oYXModHJhbnNjZWl2ZXIpXG4gICAgICAgICYmIFsnaW5hY3RpdmUnLCAncmVjdm9ubHknXS5pbmNsdWRlcyh0cmFuc2NlaXZlci5kaXJlY3Rpb24pO1xufVxuLyoqXG4gKiBUYWtlIGEgcmVjeWNsZWQgUlRDUnRwVHJhbnNjZWl2ZXIgaWYgYXZhaWxhYmxlLlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvblYyfSBwY3YyXG4gKiBAcGFyYW0ge1RyYWNrLktpbmR9IGtpbmRcbiAqIEByZXR1cm5zIHs/UlRDUnRwVHJhbnNjZWl2ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRha2VSZWN5Y2xlZFRyYW5zY2VpdmVyKHBjdjIsIGtpbmQpIHtcbiAgICB2YXIgcHJlZmVycmVkQ29kZWNzID0ge1xuICAgICAgICBhdWRpbzogcGN2Mi5fcHJlZmVycmVkQXVkaW9Db2RlY3MubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGNvZGVjID0gX2EuY29kZWM7XG4gICAgICAgICAgICByZXR1cm4gY29kZWMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSksXG4gICAgICAgIHZpZGVvOiBwY3YyLl9wcmVmZXJyZWRWaWRlb0NvZGVjcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgY29kZWMgPSBfYS5jb2RlYztcbiAgICAgICAgICAgIHJldHVybiBjb2RlYy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KVxuICAgIH1ba2luZF07XG4gICAgdmFyIHJlY3ljbGVkVHJhbnNjZWl2ZXJzID0gcGN2Mi5fcmVjeWNsZWRUcmFuc2NlaXZlcnNba2luZF07XG4gICAgdmFyIGxvY2FsQ29kZWMgPSBwcmVmZXJyZWRDb2RlY3MuZmluZChmdW5jdGlvbiAoY29kZWMpIHsgcmV0dXJuIHBjdjIuX2xvY2FsQ29kZWNzLmhhcyhjb2RlYyk7IH0pO1xuICAgIGlmICghbG9jYWxDb2RlYykge1xuICAgICAgICByZXR1cm4gcmVjeWNsZWRUcmFuc2NlaXZlcnMuc2hpZnQoKTtcbiAgICB9XG4gICAgdmFyIHRyYW5zY2VpdmVyID0gcmVjeWNsZWRUcmFuc2NlaXZlcnMuZmluZChmdW5jdGlvbiAodHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgdmFyIHJlbW90ZUNvZGVjTWFwID0gcGN2Mi5fcmVtb3RlQ29kZWNNYXBzLmdldCh0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICByZXR1cm4gcmVtb3RlQ29kZWNNYXAgJiYgcmVtb3RlQ29kZWNNYXAuaGFzKGxvY2FsQ29kZWMpO1xuICAgIH0pO1xuICAgIGlmICh0cmFuc2NlaXZlcikge1xuICAgICAgICByZWN5Y2xlZFRyYW5zY2VpdmVycy5zcGxpY2UocmVjeWNsZWRUcmFuc2NlaXZlcnMuaW5kZXhPZih0cmFuc2NlaXZlciksIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNjZWl2ZXI7XG59XG4vKipcbiAqIFVwZGF0ZSB0aGUgc2V0IG9mIGxvY2FsbHkgc3VwcG9ydGVkIHtAbGluayBDb2RlY31zLlxuICogQHBhcmFtIHBjdjJcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGVMb2NhbENvZGVjcyhwY3YyKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gcGN2Mi5fcGVlckNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbjtcbiAgICBpZiAoIWRlc2NyaXB0aW9uIHx8ICFkZXNjcmlwdGlvbi5zZHApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBnZXRNZWRpYVNlY3Rpb25zKGRlc2NyaXB0aW9uLnNkcCkuZm9yRWFjaChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICB2YXIgY29kZWNNYXAgPSBjcmVhdGVDb2RlY01hcEZvck1lZGlhU2VjdGlvbihzZWN0aW9uKTtcbiAgICAgICAgY29kZWNNYXAuZm9yRWFjaChmdW5jdGlvbiAocHRzLCBjb2RlYykgeyByZXR1cm4gcGN2Mi5fbG9jYWxDb2RlY3MuYWRkKGNvZGVjKTsgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFVwZGF0ZSB0aGUge0BsaW5rIENvZGVjfSBtYXBzIGZvciBhbGwgbT0gc2VjdGlvbnMgaW4gdGhlIHJlbW90ZSB7QGxpbmsgUlRDU2Vzc2lvbkRlc2NyaXB0aW9ufXMuXG4gKiBAcGFyYW0ge1BlZXJDb25uZWN0aW9uVjJ9IHBjdjJcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGVSZW1vdGVDb2RlY01hcHMocGN2Mikge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHBjdjIuX3BlZXJDb25uZWN0aW9uLnJlbW90ZURlc2NyaXB0aW9uO1xuICAgIGlmICghZGVzY3JpcHRpb24gfHwgIWRlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGdldE1lZGlhU2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gc2VjdGlvbi5tYXRjaCgvXmE9bWlkOiguKykkL20pO1xuICAgICAgICBpZiAoIW1hdGNoZWQgfHwgIW1hdGNoZWRbMV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWlkID0gbWF0Y2hlZFsxXTtcbiAgICAgICAgdmFyIGNvZGVjTWFwID0gY3JlYXRlQ29kZWNNYXBGb3JNZWRpYVNlY3Rpb24oc2VjdGlvbik7XG4gICAgICAgIHBjdjIuX3JlbW90ZUNvZGVjTWFwcy5zZXQobWlkLCBjb2RlY01hcCk7XG4gICAgfSk7XG59XG4vKipcbiAqIFVwZGF0ZSB0aGUgbGlzdCBvZiByZWN5Y2xlZCBSVENSdHBUcmFuc2NlaXZlcnMuXG4gKiBAcGFyYW0ge1BlZXJDb25uZWN0aW9uVjJ9IHBjdjJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlUmVjeWNsZWRUcmFuc2NlaXZlcnMocGN2Mikge1xuICAgIHBjdjIuX3JlY3ljbGVkVHJhbnNjZWl2ZXJzLmF1ZGlvID0gW107XG4gICAgcGN2Mi5fcmVjeWNsZWRUcmFuc2NlaXZlcnMudmlkZW8gPSBbXTtcbiAgICBwY3YyLl9wZWVyQ29ubmVjdGlvbi5nZXRUcmFuc2NlaXZlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc2NlaXZlcikge1xuICAgICAgICBpZiAoc2hvdWxkUmVjeWNsZVRyYW5zY2VpdmVyKHRyYW5zY2VpdmVyLCBwY3YyKSkge1xuICAgICAgICAgICAgdmFyIHRyYWNrID0gdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2s7XG4gICAgICAgICAgICBwY3YyLl9yZWN5Y2xlZFRyYW5zY2VpdmVyc1t0cmFjay5raW5kXS5wdXNoKHRyYW5zY2VpdmVyKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBQZXJmb3JtIGNlcnRhaW4gdXBkYXRlcyBhZnRlciBhbiBTRFAgbmVnb3RpYXRpb24gaXMgY29tcGxldGVkLlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvblYyfSBwY3YyXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gbmVnb3RpYXRpb25Db21wbGV0ZWQocGN2Mikge1xuICAgIHVwZGF0ZVJlY3ljbGVkVHJhbnNjZWl2ZXJzKHBjdjIpO1xuICAgIHVwZGF0ZUxvY2FsQ29kZWNzKHBjdjIpO1xuICAgIHVwZGF0ZVJlbW90ZUNvZGVjTWFwcyhwY3YyKTtcbiAgICB1cGRhdGVFbmNvZGluZ1BhcmFtZXRlcnMocGN2MikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGFueSBhbnkgcHVibGlzaGVyIGhpbnRzIHF1ZXVlZCwgYXBwbHkgdGhlbSBub3cuXG4gICAgICAgIHBjdjIuX2hhbmRsZVF1ZXVlZFB1Ymxpc2hlckhpbnRzKCk7XG4gICAgfSk7XG59XG4vKipcbiAqIFVwZGF0ZSB0aGUgUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzIG9mIGFsbCBhY3RpdmUgUlRDUnRwU2VuZGVycy5cbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25WMn0gcGN2MlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUVuY29kaW5nUGFyYW1ldGVycyhwY3YyKSB7XG4gICAgdmFyIF9hID0gcGN2Mi5fZW5jb2RpbmdQYXJhbWV0ZXJzLCBtYXhBdWRpb0JpdHJhdGUgPSBfYS5tYXhBdWRpb0JpdHJhdGUsIG1heFZpZGVvQml0cmF0ZSA9IF9hLm1heFZpZGVvQml0cmF0ZTtcbiAgICB2YXIgbWF4Qml0cmF0ZXMgPSBuZXcgTWFwKFtcbiAgICAgICAgWydhdWRpbycsIG1heEF1ZGlvQml0cmF0ZV0sXG4gICAgICAgIFsndmlkZW8nLCBtYXhWaWRlb0JpdHJhdGVdXG4gICAgXSk7XG4gICAgdmFyIHByb21pc2VzID0gW107XG4gICAgcGN2Mi5fcGVlckNvbm5lY3Rpb24uZ2V0U2VuZGVycygpLmZpbHRlcihmdW5jdGlvbiAoc2VuZGVyKSB7IHJldHVybiBzZW5kZXIudHJhY2s7IH0pLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgICB2YXIgbWF4Qml0cmF0ZSA9IG1heEJpdHJhdGVzLmdldChzZW5kZXIudHJhY2sua2luZCk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBpZiAobWF4Qml0cmF0ZSA9PT0gbnVsbCB8fCBtYXhCaXRyYXRlID09PSAwKSB7XG4gICAgICAgICAgICByZW1vdmVNYXhCaXRyYXRlKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGN2Mi5faXNDaHJvbWVTY3JlZW5TaGFyZVRyYWNrKHNlbmRlci50cmFjaykpIHtcbiAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBTb21ldGltZXMgKEpTREstMjU1NykgY2hyb21lIGRvZXMgbm90IHNlbmQgYW55IGJ5dGVzIG9uIHNjcmVlbiB0cmFjayBpZiBNYXhCaXRSYXRlIGlzIHNldCBvbiBpdCB2aWEgc2V0UGFyYW1ldGVycyxcbiAgICAgICAgICAgIC8vIFRvIHdvcmthcm91bmQgdGhpcyBpc3N1ZSB3ZSB3aWxsIG5vdCBhcHBseSBtYXhCaXRyYXRlIGlmIHRoZSB0cmFjayBhcHBlYXJzIHRvIGJlIGEgc2NyZWVuIHNoYXJlIHRyYWNrIGNyZWF0ZWQgYnkgY2hyb21lXG4gICAgICAgICAgICBwY3YyLl9sb2cud2FybihcIk5vdCBzZXR0aW5nIG1heEJpdHJhdGUgZm9yIFwiICsgc2VuZGVyLnRyYWNrLmtpbmQgKyBcIiBUcmFjayBcIiArIHNlbmRlci50cmFjay5pZCArIFwiIGJlY2F1c2UgaXQgYXBwZWFycyB0byBiZSBzY3JlZW4gc2hhcmUgdHJhY2s6IFwiICsgc2VuZGVyLnRyYWNrLmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldE1heEJpdHJhdGUocGFyYW1zLCBtYXhCaXRyYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRmlyZWZveCAmJiBwY3YyLl9lbmFibGVEc2NwICYmIHBhcmFtcy5lbmNvZGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogXCJuZXR3b3JrUHJpb3JpdHlcIiBpcyBhIHBlci1zZW5kZXIgcHJvcGVydHkgYW5kIG5vdFxuICAgICAgICAgICAgLy8gYSBwZXItZW5jb2RpbmctbGF5ZXIgcHJvcGVydHkuIFNvLCB3ZSBzZXQgdGhlIHZhbHVlIG9ubHkgb24gdGhlIGZpcnN0XG4gICAgICAgICAgICAvLyBlbmNvZGluZyBsYXllci4gQW55IGF0dGVtcHQgdG8gc2V0IHRoZSB2YWx1ZSBvbiBzdWJzZXF1ZW50IGVuY29kaW5nXG4gICAgICAgICAgICAvLyBsYXllcnMgKGluIHRoZSBjYXNlIG9mIHNpbXVsY2FzdCkgd2lsbCByZXN1bHQgaW4gdGhlIFByb21pc2UgcmV0dXJuZWRcbiAgICAgICAgICAgIC8vIGJ5IFJUQ1J0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKCkgYmVpbmcgcmVqZWN0ZWQuXG4gICAgICAgICAgICBwYXJhbXMuZW5jb2RpbmdzWzBdLm5ldHdvcmtQcmlvcml0eSA9ICdoaWdoJztcbiAgICAgICAgfVxuICAgICAgICAvLyB3aGVuIGEgc2VuZGVyIGlzIHJldXNlZCwgZGVsZXRlIGFueSBhY3RpdmUgZW5jb2RpbmdzIHNldCBieSBzZXJ2ZXIuXG4gICAgICAgIHZhciB0cmFja1JlcGxhY2VkID0gcGN2Mi5fcnRwTmV3U2VuZGVycy5oYXMoc2VuZGVyKTtcbiAgICAgICAgcGN2Mi5fbWF5YmVVcGRhdGVFbmNvZGluZ3Moc2VuZGVyLnRyYWNrLCBwYXJhbXMuZW5jb2RpbmdzLCB0cmFja1JlcGxhY2VkKTtcbiAgICAgICAgcGN2Mi5fcnRwTmV3U2VuZGVycy5kZWxldGUoc2VuZGVyKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSBzZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcGN2Mi5fbG9nLndhcm4oXCJFcnJvciB3aGlsZSBzZXR0aW5nIGVuY29kaW5ncyBwYXJhbWV0ZXJzIGZvciBcIiArIHNlbmRlci50cmFjay5raW5kICsgXCIgVHJhY2sgXCIgKyBzZW5kZXIudHJhY2suaWQgKyBcIjogXCIgKyAoZXJyb3IubWVzc2FnZSB8fCBlcnJvci5uYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59XG4vKipcbiAqIFJlbW92ZSBtYXhCaXRyYXRlIGZyb20gdGhlIFJUQ1J0cFNlbmRQYXJhbWV0ZXJzJyBlbmNvZGluZ3MuXG4gKiBAcGFyYW0ge1JUQ1J0cFNlbmRQYXJhbWV0ZXJzfSBwYXJhbXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiByZW1vdmVNYXhCaXRyYXRlKHBhcmFtcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcy5lbmNvZGluZ3MpKSB7XG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZW5jb2RpbmcpIHsgcmV0dXJuIGRlbGV0ZSBlbmNvZGluZy5tYXhCaXRyYXRlOyB9KTtcbiAgICB9XG59XG4vKipcbiAqIFNldCB0aGUgZ2l2ZW4gbWF4Qml0cmF0ZSBpbiB0aGUgUlRDUnRwU2VuZFBhcmFtZXRlcnMnIGVuY29kaW5ncy5cbiAqIEBwYXJhbSB7UlRDUnRwU2VuZFBhcmFtZXRlcnN9IHBhcmFtc1xuICogQHBhcmFtIHtudW1iZXJ9IG1heEJpdHJhdGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBzZXRNYXhCaXRyYXRlKHBhcmFtcywgbWF4Qml0cmF0ZSkge1xuICAgIGlmIChpc0ZpcmVmb3gpIHtcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IFt7IG1heEJpdHJhdGU6IG1heEJpdHJhdGUgfV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzLmZvckVhY2goZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gbWF4Qml0cmF0ZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBQZWVyQ29ubmVjdGlvblYyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVlcmNvbm5lY3Rpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xuICAgIHJldHVybiB0bztcbn07XG52YXIgZ3Vlc3NCcm93c2VyID0gcmVxdWlyZSgnLi4vLi4vd2VicnRjL3V0aWwnKS5ndWVzc0Jyb3dzZXI7XG52YXIgUGVlckNvbm5lY3Rpb25WMiA9IHJlcXVpcmUoJy4vcGVlcmNvbm5lY3Rpb24nKTtcbnZhciBNZWRpYVRyYWNrU2VuZGVyID0gcmVxdWlyZSgnLi4vLi4vbWVkaWEvdHJhY2svc2VuZGVyJyk7XG52YXIgUXVldWVpbmdFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuLi8uLi9xdWV1ZWluZ2V2ZW50ZW1pdHRlcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgTWVkaWFDb25uZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi91dGlsL3R3aWxpby12aWRlby1lcnJvcnMnKS5NZWRpYUNvbm5lY3Rpb25FcnJvcjtcbnZhciBpc0ZpcmVmb3ggPSBndWVzc0Jyb3dzZXIoKSA9PT0gJ2ZpcmVmb3gnO1xuLyoqXG4gKiB7QGxpbmsgUGVlckNvbm5lY3Rpb25NYW5hZ2VyfSBtYW5hZ2VzIG11bHRpcGxlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfXMuXG4gKiBAZXh0ZW5kcyBRdWV1ZWluZ0V2ZW50RW1pdHRlclxuICogQGVtaXRzIFBlZXJDb25uZWN0aW9uTWFuYWdlciNjYW5kaWRhdGVzXG4gKiBAZW1pdHMgUGVlckNvbm5lY3Rpb25NYW5hZ2VyI2Nvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcbiAqIEBlbWl0cyBQZWVyQ29ubmVjdGlvbk1hbmFnZXIjZGVzY3JpcHRpb25cbiAqIEBlbWl0cyBQZWVyQ29ubmVjdGlvbk1hbmFnZXIjaWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFxuICogQGVtaXRzIFBlZXJDb25uZWN0aW9uTWFuYWdlciN0cmFja0FkZGVkXG4gKi9cbnZhciBQZWVyQ29ubmVjdGlvbk1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBlZXJDb25uZWN0aW9uTWFuYWdlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Qge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0uXG4gICAgICogQHBhcmFtIHtFbmNvZGluZ1BhcmFtZXRlcnNJbXBsfSBlbmNvZGluZ1BhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge1ByZWZlcnJlZENvZGVjc30gcHJlZmVycmVkQ29kZWNzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQZWVyQ29ubmVjdGlvbk1hbmFnZXIoZW5jb2RpbmdQYXJhbWV0ZXJzLCBwcmVmZXJyZWRDb2RlY3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgYXVkaW9Db250ZXh0RmFjdG9yeTogaXNGaXJlZm94XG4gICAgICAgICAgICAgICAgPyByZXF1aXJlKCcuLi8uLi93ZWJhdWRpby9hdWRpb2NvbnRleHQnKVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIFBlZXJDb25uZWN0aW9uVjI6IFBlZXJDb25uZWN0aW9uVjJcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBhdWRpb0NvbnRleHQgPSBvcHRpb25zLmF1ZGlvQ29udGV4dEZhY3RvcnlcbiAgICAgICAgICAgID8gb3B0aW9ucy5hdWRpb0NvbnRleHRGYWN0b3J5LmdldE9yQ3JlYXRlKF90aGlzKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAvLyBOT1RFKG1yb2JlcnRzKTogSWYgd2UncmUgdXNpbmcgYW4gQXVkaW9Db250ZXh0LCB3ZSBkb24ndCBuZWVkIHRvIHNwZWNpZnlcbiAgICAgICAgLy8gYG9mZmVyVG9SZWNlaXZlQXVkaW9gIGluIFJUQ09mZmVyT3B0aW9ucy5cbiAgICAgICAgdmFyIG9mZmVyT3B0aW9ucyA9IGF1ZGlvQ29udGV4dFxuICAgICAgICAgICAgPyB7IG9mZmVyVG9SZWNlaXZlVmlkZW86IHRydWUgfVxuICAgICAgICAgICAgOiB7IG9mZmVyVG9SZWNlaXZlQXVkaW86IHRydWUsIG9mZmVyVG9SZWNlaXZlVmlkZW86IHRydWUgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9hdWRpb0NvbnRleHRGYWN0b3J5OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuYXVkaW9Db250ZXh0RmFjdG9yeVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jbG9zZWRQZWVyQ29ubmVjdGlvbklkczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NvbmZpZ3VyYXRpb25EZWZlcnJlZDoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1dGlsLmRlZmVyKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY29ubmVjdGlvblN0YXRlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICduZXcnLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2R1bW15QXVkaW9UcmFja1NlbmRlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBhdWRpb0NvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgTWVkaWFUcmFja1NlbmRlcihjcmVhdGVEdW1teUF1ZGlvTWVkaWFTdHJlYW1UcmFjayhhdWRpb0NvbnRleHQpKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZW5jb2RpbmdQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGVuY29kaW5nUGFyYW1ldGVyc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pY2VDb25uZWN0aW9uU3RhdGU6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ25ldydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZGF0YVRyYWNrU2VuZGVyczoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbGFzdENvbm5lY3Rpb25TdGF0ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnbmV3JyxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sYXN0SWNlQ29ubmVjdGlvblN0YXRlOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICduZXcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21lZGlhVHJhY2tTZW5kZXJzOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vZmZlck9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb2ZmZXJPcHRpb25zXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3BlZXJDb25uZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcHJlZmVycmVkQ29kZWNzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHByZWZlcnJlZENvZGVjc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZXNzaW9uVGltZW91dDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX1BlZXJDb25uZWN0aW9uVjI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5QZWVyQ29ubmVjdGlvblYyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBlZXJDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0RWZmZWN0aXZlQWRhcHRpdmVTaW11bGNhc3QgPSBmdW5jdGlvbiAoZWZmZWN0aXZlQWRhcHRpdmVTaW11bGNhc3QpIHtcbiAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHBjKSB7IHJldHVybiBwYy5zZXRFZmZlY3RpdmVBZGFwdGl2ZVNpbXVsY2FzdChlZmZlY3RpdmVBZGFwdGl2ZVNpbXVsY2FzdCk7IH0pO1xuICAgICAgICB0aGlzLl9wcmVmZXJyZWRDb2RlY3MudmlkZW8uZm9yRWFjaChmdW5jdGlvbiAoY3MpIHtcbiAgICAgICAgICAgIGlmICgnYWRhcHRpdmVTaW11bGNhc3QnIGluIGNzKSB7XG4gICAgICAgICAgICAgICAgY3MuYWRhcHRpdmVTaW11bGNhc3QgPSBlZmZlY3RpdmVBZGFwdGl2ZVNpbXVsY2FzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZSwgXCJjb25uZWN0aW9uU3RhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdW1tYXJpemVkIFJUQ1BlZXJDb25uZWN0aW9uU3RhdGUgYWNyb3NzIGFsbCB0aGVcbiAgICAgICAgICoge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0ncyB1bmRlcmx5aW5nIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfXMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7UlRDUGVlckNvbm5lY3Rpb25TdGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQZWVyQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLCBcImljZUNvbm5lY3Rpb25TdGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN1bW1hcml6ZWQgUlRDSWNlQ29ubmVjdGlvblN0YXRlIGFjcm9zcyBhbGwgdGhlXG4gICAgICAgICAqIHtAbGluayBQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9J3MgdW5kZXJseWluZyB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn1zLlxuICAgICAgICAgKiBAcHJvcGVydHkge1JUQ0ljZUNvbm5lY3Rpb25TdGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn1zIHdoaWNoIGFyZSBubyBsb25nZXIgcmVsZXZhbnQuXG4gICAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBwZWVyQ29ubmVjdGlvblN0YXRlc1xuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuX2Nsb3NlQWJzZW50UGVlckNvbm5lY3Rpb25zID0gZnVuY3Rpb24gKHBlZXJDb25uZWN0aW9uU3RhdGVzKSB7XG4gICAgICAgIHZhciBwZWVyQ29ubmVjdGlvbklkcyA9IG5ldyBTZXQocGVlckNvbm5lY3Rpb25TdGF0ZXMubWFwKGZ1bmN0aW9uIChwZWVyQ29ubmVjdGlvblN0YXRlKSB7IHJldHVybiBwZWVyQ29ubmVjdGlvblN0YXRlLmlkOyB9KSk7XG4gICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwZWVyQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgaWYgKCFwZWVyQ29ubmVjdGlvbklkcy5oYXMocGVlckNvbm5lY3Rpb24uaWQpKSB7XG4gICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24uX2Nsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0ncyBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9nZXRDb25maWd1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlndXJhdGlvbkRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgb3IgY3JlYXRlIGEge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb25maWd1cmF0aW9uXVxuICAgICAqIEByZXR1cm5zIHtQZWVyQ29ubmVjdGlvblYyfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuX2dldE9yQ3JlYXRlID0gZnVuY3Rpb24gKGlkLCBjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBlZXJDb25uZWN0aW9uID0gdGhpcy5fcGVlckNvbm5lY3Rpb25zLmdldChpZCk7XG4gICAgICAgIGlmICghcGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBQZWVyQ29ubmVjdGlvblYyXzEgPSB0aGlzLl9QZWVyQ29ubmVjdGlvblYyO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBkdW1teUF1ZGlvTWVkaWFTdHJlYW1UcmFjazogdGhpcy5fZHVtbXlBdWRpb1RyYWNrU2VuZGVyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5fZHVtbXlBdWRpb1RyYWNrU2VuZGVyLnRyYWNrXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBvZmZlck9wdGlvbnM6IHRoaXMuX29mZmVyT3B0aW9uc1xuICAgICAgICAgICAgfSwgdGhpcy5fc2Vzc2lvblRpbWVvdXQgPyB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvblRpbWVvdXQ6IHRoaXMuX3Nlc3Npb25UaW1lb3V0XG4gICAgICAgICAgICB9IDoge30sIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwZWVyQ29ubmVjdGlvbiA9IG5ldyBQZWVyQ29ubmVjdGlvblYyXzEoaWQsIHRoaXMuX2VuY29kaW5nUGFyYW1ldGVycywgdGhpcy5fcHJlZmVycmVkQ29kZWNzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1lZGlhQ29ubmVjdGlvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbnMuc2V0KHBlZXJDb25uZWN0aW9uLmlkLCBwZWVyQ29ubmVjdGlvbik7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbignY2FuZGlkYXRlcycsIHRoaXMucXVldWUuYmluZCh0aGlzLCAnY2FuZGlkYXRlcycpKTtcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLm9uKCdkZXNjcmlwdGlvbicsIHRoaXMucXVldWUuYmluZCh0aGlzLCAnZGVzY3JpcHRpb24nKSk7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbigndHJhY2tBZGRlZCcsIHRoaXMucXVldWUuYmluZCh0aGlzLCAndHJhY2tBZGRlZCcpKTtcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBzdGF0ZUNoYW5nZWQoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdzdGF0ZUNoYW5nZWQnLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kYXRhVHJhY2tTZW5kZXJzLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlcikgeyByZXR1cm4gcGVlckNvbm5lY3Rpb24ucmVtb3ZlRGF0YVRyYWNrU2VuZGVyKHNlbmRlcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9tZWRpYVRyYWNrU2VuZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzZW5kZXIpIHsgcmV0dXJuIHBlZXJDb25uZWN0aW9uLnJlbW92ZU1lZGlhVHJhY2tTZW5kZXIoc2VuZGVyKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3BlZXJDb25uZWN0aW9ucy5kZWxldGUocGVlckNvbm5lY3Rpb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jbG9zZWRQZWVyQ29ubmVjdGlvbklkcy5hZGQocGVlckNvbm5lY3Rpb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uU3RhdGUoc2VsZik7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUljZUNvbm5lY3Rpb25TdGF0ZShzZWxmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLm9uKCdjb25uZWN0aW9uU3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlQ29ubmVjdGlvblN0YXRlKF90aGlzKTsgfSk7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbignaWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVwZGF0ZUljZUNvbm5lY3Rpb25TdGF0ZShfdGhpcyk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fZGF0YVRyYWNrU2VuZGVycy5mb3JFYWNoKHBlZXJDb25uZWN0aW9uLmFkZERhdGFUcmFja1NlbmRlciwgcGVlckNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFUcmFja1NlbmRlcnMuZm9yRWFjaChwZWVyQ29ubmVjdGlvbi5hZGRNZWRpYVRyYWNrU2VuZGVyLCBwZWVyQ29ubmVjdGlvbik7XG4gICAgICAgICAgICB1cGRhdGVJY2VDb25uZWN0aW9uU3RhdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlZXJDb25uZWN0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgYWxsIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn1zIGluIHRoaXMge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0uXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2R1bW15QXVkaW9UcmFja1NlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5fZHVtbXlBdWRpb1RyYWNrU2VuZGVyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYXVkaW9Db250ZXh0RmFjdG9yeSkge1xuICAgICAgICAgICAgdGhpcy5fYXVkaW9Db250ZXh0RmFjdG9yeS5yZWxlYXNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUljZUNvbm5lY3Rpb25TdGF0ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9IG9uIHRoaXMge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0uXG4gICAgICogVGhlbiwgY3JlYXRlIGEgbmV3IG9mZmVyIHdpdGggdGhlIG5ld2x5LWNyZWF0ZWQge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dGhpcz59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVBbmRPZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvbmZpZ3VyYXRpb24oKS50aGVuKGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaWQ7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWQgPSB1dGlsLm1ha2VVVUlEKCk7XG4gICAgICAgICAgICB9IHdoaWxlIChfdGhpcy5fcGVlckNvbm5lY3Rpb25zLmhhcyhpZCkpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9nZXRPckNyZWF0ZShpZCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcGVlckNvbm5lY3Rpb24ub2ZmZXIoKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB7QGxpbmsgRGF0YVRyYWNrUmVjZWl2ZXJ9cyBhbmQge0BsaW5rIE1lZGlhVHJhY2tSZWNlaXZlcn1zIG9mIGFsbFxuICAgICAqIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn1zLlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxEYXRhVHJhY2tSZWNlaXZlcnxNZWRpYVRyYWNrUmVjZWl2ZXI+fSB0cmFja1JlY2VpdmVyc1xuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHJhY2tSZWNlaXZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmZsYXRNYXAodGhpcy5fcGVlckNvbm5lY3Rpb25zLCBmdW5jdGlvbiAocGVlckNvbm5lY3Rpb24pIHsgcmV0dXJuIHBlZXJDb25uZWN0aW9uLmdldFRyYWNrUmVjZWl2ZXJzKCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGF0ZXMgb2YgYWxsIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfXMuXG4gICAgICogQHJldHVybnMge0FycmF5PG9iamVjdD59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRTdGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwZWVyQ29ubmVjdGlvblN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBwZWVyQ29ubmVjdGlvblN0YXRlID0gcGVlckNvbm5lY3Rpb24uZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChwZWVyQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25TdGF0ZXMucHVzaChwZWVyQ29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvblN0YXRlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0ncyBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRDb25maWd1cmF0aW9uID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZ3VyYXRpb25EZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwZWVyQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgdGhpcy5fY29uZmlndXJhdGlvbkRlZmVycmVkLnJlc29sdmUoY29uZmlndXJhdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBJQ0UgcmVjb25uZWN0IHRpbWVvdXQgcGVyaW9kIGZvciBhbGwge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGVyaW9kIC0gUGVyaW9kIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldEljZVJlY29ubmVjdFRpbWVvdXQgPSBmdW5jdGlvbiAocGVyaW9kKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXNzaW9uVGltZW91dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24uc2V0SWNlUmVjb25uZWN0VGltZW91dChwZXJpb2QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9zZXNzaW9uVGltZW91dCA9IHBlcmlvZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUge0BsaW5rIERhdGFUcmFja1NlbmRlcn1zIGFuZCB7QGxpbmsgTWVkaWFUcmFja1NlbmRlcn1zIG9uIHRoZVxuICAgICAqIHtAbGluayBQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9J3MgdW5kZXJseWluZyB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn1zLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8RGF0YVRyYWNrU2VuZGVyfE1lZGlhVHJhY2tTZW5kZXI+fSB0cmFja1NlbmRlcnNcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldFRyYWNrU2VuZGVycyA9IGZ1bmN0aW9uICh0cmFja1NlbmRlcnMpIHtcbiAgICAgICAgdmFyIGRhdGFUcmFja1NlbmRlcnMgPSBuZXcgU2V0KHRyYWNrU2VuZGVycy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrU2VuZGVyKSB7IHJldHVybiB0cmFja1NlbmRlci5raW5kID09PSAnZGF0YSc7IH0pKTtcbiAgICAgICAgdmFyIG1lZGlhVHJhY2tTZW5kZXJzID0gbmV3IFNldCh0cmFja1NlbmRlcnNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrU2VuZGVyKSB7IHJldHVybiB0cmFja1NlbmRlciAmJiAodHJhY2tTZW5kZXIua2luZCA9PT0gJ2F1ZGlvJyB8fCB0cmFja1NlbmRlci5raW5kID09PSAndmlkZW8nKTsgfSkpO1xuICAgICAgICB2YXIgY2hhbmdlcyA9IGdldFRyYWNrU2VuZGVyQ2hhbmdlcyh0aGlzLCBkYXRhVHJhY2tTZW5kZXJzLCBtZWRpYVRyYWNrU2VuZGVycyk7XG4gICAgICAgIHRoaXMuX2RhdGFUcmFja1NlbmRlcnMgPSBkYXRhVHJhY2tTZW5kZXJzO1xuICAgICAgICB0aGlzLl9tZWRpYVRyYWNrU2VuZGVycyA9IG1lZGlhVHJhY2tTZW5kZXJzO1xuICAgICAgICBhcHBseVRyYWNrU2VuZGVyQ2hhbmdlcyh0aGlzLCBjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gcGVlckNvbm5lY3Rpb25TdGF0ZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzeW5jZWQ9ZmFsc2VdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dGhpcz59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAocGVlckNvbm5lY3Rpb25TdGF0ZXMsIHN5bmNlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoc3luY2VkID09PSB2b2lkIDApIHsgc3luY2VkID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHN5bmNlZCkge1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VBYnNlbnRQZWVyQ29ubmVjdGlvbnMocGVlckNvbm5lY3Rpb25TdGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDb25maWd1cmF0aW9uKCkudGhlbihmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBlZXJDb25uZWN0aW9uU3RhdGVzLm1hcChmdW5jdGlvbiAocGVlckNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fY2xvc2VkUGVlckNvbm5lY3Rpb25JZHMuaGFzKHBlZXJDb25uZWN0aW9uU3RhdGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGVlckNvbm5lY3Rpb24gPSBfdGhpcy5fZ2V0T3JDcmVhdGUocGVlckNvbm5lY3Rpb25TdGF0ZS5pZCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlZXJDb25uZWN0aW9uLnVwZGF0ZShwZWVyQ29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25NYW5hZ2VyfSdzIG1lZGlhIHN0YXRpc3RpY3MuXG4gICAgICogQHJldHVybnMge1Byb21pc2UuPE1hcDxQZWVyQ29ubmVjdGlvblYyI2lkLCBTdGFuZGFyZGl6ZWRTdGF0c1Jlc3BvbnNlPj59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBlZXJDb25uZWN0aW9ucyA9IEFycmF5LmZyb20odGhpcy5fcGVlckNvbm5lY3Rpb25zLnZhbHVlcygpKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBlZXJDb25uZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHBlZXJDb25uZWN0aW9uKSB7IHJldHVybiBwZWVyQ29ubmVjdGlvbi5nZXRTdGF0cygpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBbXG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5pZCxcbiAgICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgIF07IH0pOyB9KSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VzKSB7IHJldHVybiBuZXcgTWFwKHJlc3BvbnNlcyk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFBlZXJDb25uZWN0aW9uTWFuYWdlcjtcbn0oUXVldWVpbmdFdmVudEVtaXR0ZXIpKTtcbi8qKlxuICogQ3JlYXRlIGEgZHVtbXkgYXVkaW8gTWVkaWFTdHJlYW1UcmFjayB3aXRoIHRoZSBnaXZlbiBBdWRpb0NvbnRleHQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGF1ZGlvQ29udGV4dFxuICogQHJldHVybiB7TWVkaWFTdHJlYW1UcmFja31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRHVtbXlBdWRpb01lZGlhU3RyZWFtVHJhY2soYXVkaW9Db250ZXh0KSB7XG4gICAgdmFyIG1lZGlhU3RyZWFtRGVzdGluYXRpb24gPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpO1xuICAgIHJldHVybiBtZWRpYVN0cmVhbURlc3RpbmF0aW9uLnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdO1xufVxuLyoqXG4gKiBAZXZlbnQge1BlZXJDb25uZWN0aW9uTWFuYWdlciNjYW5kaWRhdGVzfVxuICogQHBhcmFtIHtvYmplY3R9IGNhbmRpZGF0ZXNcbiAqL1xuLyoqXG4gKiBAZXZlbnQge1BlZXJDb25uZWN0aW9uTWFuYWdlciNjb25uZWN0aW9uU3RhdGVDaGFuZ2VkfVxuICovXG4vKipcbiAqIEBldmVudCB7UGVlckNvbm5lY3Rpb25NYW5hZ2VyI2Rlc2NyaXB0aW9ufVxuICogQHBhcmFtIHtvYmplY3R9IGRlc2NyaXB0aW9uXG4gKi9cbi8qKlxuICogQGV2ZW50IHtQZWVyQ29ubmVjdGlvbk1hbmFnZXIjaWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlZH1cbiAqL1xuLyoqXG4gKiBAZXZlbnQge1BlZXJDb25uZWN0aW9uTWFuYWdlciN0cmFja0FkZGVkfVxuICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfERhdGFUcmFja1JlY2VpdmVyfSBtZWRpYVN0cmVhbVRyYWNrT3JEYXRhVHJhY2tSZWNlaXZlclxuICovXG4vKipcbiAqIEFwcGx5IHtAbGluayBUcmFja1NlbmRlckNoYW5nZXN9LlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9IHBlZXJDb25uZWN0aW9uTWFuYWdlclxuICogQHBhcmFtIHtUcmFja1NlbmRlckNoYW5nZXN9IGNoYW5nZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBhcHBseVRyYWNrU2VuZGVyQ2hhbmdlcyhwZWVyQ29ubmVjdGlvbk1hbmFnZXIsIGNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcy5kYXRhLmFkZC5zaXplXG4gICAgICAgIHx8IGNoYW5nZXMuZGF0YS5yZW1vdmUuc2l6ZVxuICAgICAgICB8fCBjaGFuZ2VzLm1lZGlhLmFkZC5zaXplXG4gICAgICAgIHx8IGNoYW5nZXMubWVkaWEucmVtb3ZlLnNpemUpIHtcbiAgICAgICAgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLl9wZWVyQ29ubmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIGNoYW5nZXMuZGF0YS5yZW1vdmUuZm9yRWFjaChwZWVyQ29ubmVjdGlvbi5yZW1vdmVEYXRhVHJhY2tTZW5kZXIsIHBlZXJDb25uZWN0aW9uKTtcbiAgICAgICAgICAgIGNoYW5nZXMubWVkaWEucmVtb3ZlLmZvckVhY2gocGVlckNvbm5lY3Rpb24ucmVtb3ZlTWVkaWFUcmFja1NlbmRlciwgcGVlckNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgY2hhbmdlcy5kYXRhLmFkZC5mb3JFYWNoKHBlZXJDb25uZWN0aW9uLmFkZERhdGFUcmFja1NlbmRlciwgcGVlckNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgY2hhbmdlcy5tZWRpYS5hZGQuZm9yRWFjaChwZWVyQ29ubmVjdGlvbi5hZGRNZWRpYVRyYWNrU2VuZGVyLCBwZWVyQ29ubmVjdGlvbik7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5tZWRpYS5hZGQuc2l6ZVxuICAgICAgICAgICAgICAgIHx8IGNoYW5nZXMubWVkaWEucmVtb3ZlLnNpemVcbiAgICAgICAgICAgICAgICB8fCAoY2hhbmdlcy5kYXRhLmFkZC5zaXplICYmICFwZWVyQ29ubmVjdGlvbi5pc0FwcGxpY2F0aW9uU2VjdGlvbk5lZ290aWF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24ub2ZmZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJmYWNlIERhdGFUcmFja1NlbmRlckNoYW5nZXNcbiAqIEBwcm9wZXJ0eSB7U2V0PERhdGFUcmFja1NlbmRlcj59IGFkZFxuICogQHByb3BlcnR5IHtTZXQ8RGF0YVRyYWNrU2VuZGVyPn0gcmVtb3ZlXG4gKi9cbi8qKlxuICogR2V0IHRoZSB7QExpbmsgRGF0YVRyYWNrU2VuZGVyfSBjaGFuZ2VzLlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9IHBlZXJDb25uZWN0aW9uTWFuYWdlclxuICogQHBhcmFtIHtBcnJheTxEYXRhVHJhY2tTZW5kZXI+fSBkYXRhVHJhY2tTZW5kZXJzXG4gKiBAcmV0dXJucyB7RGF0YVRyYWNrU2VuZGVyQ2hhbmdlc30gY2hhbmdlc1xuICovXG5mdW5jdGlvbiBnZXREYXRhVHJhY2tTZW5kZXJDaGFuZ2VzKHBlZXJDb25uZWN0aW9uTWFuYWdlciwgZGF0YVRyYWNrU2VuZGVycykge1xuICAgIHZhciBkYXRhVHJhY2tTZW5kZXJzVG9BZGQgPSB1dGlsLmRpZmZlcmVuY2UoZGF0YVRyYWNrU2VuZGVycywgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLl9kYXRhVHJhY2tTZW5kZXJzKTtcbiAgICB2YXIgZGF0YVRyYWNrU2VuZGVyc1RvUmVtb3ZlID0gdXRpbC5kaWZmZXJlbmNlKHBlZXJDb25uZWN0aW9uTWFuYWdlci5fZGF0YVRyYWNrU2VuZGVycywgZGF0YVRyYWNrU2VuZGVycyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiBkYXRhVHJhY2tTZW5kZXJzVG9BZGQsXG4gICAgICAgIHJlbW92ZTogZGF0YVRyYWNrU2VuZGVyc1RvUmVtb3ZlXG4gICAgfTtcbn1cbi8qKlxuICogQGludGVyZmFjZSBUcmFja1NlbmRlckNoYW5nZXNcbiAqIEBwcm9wZXJ0eSB7RGF0YVRyYWNrU2VuZGVyQ2hhbmdlc30gZGF0YVxuICogQHByb3BlcnR5IHtNZWRpYVRyYWNrU2VuZGVyQ2hhbmdlc30gbWVkaWFcbiAqL1xuLyoqXG4gKiBHZXQge0BsaW5rIERhdGFUcmFja1NlbmRlcn0gYW5kIHtAbGluayBNZWRpYVRyYWNrU2VuZGVyfSBjaGFuZ2VzLlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9IHBlZXJDb25uZWN0aW9uTWFuYWdlclxuICogQHBhcmFtIHtBcnJheTxEYXRhVHJhY2tTZW5kZXI+fSBkYXRhVHJhY2tTZW5kZXJzXG4gKiBAcGFyYW0ge0FycmF5PE1lZGlhVHJhY2tTZW5kZXI+fSBtZWRpYVRyYWNrU2VuZGVyc1xuICogQHJldHVybnMge1RyYWNrU2VuZGVyQ2hhbmdlc30gY2hhbmdlc1xuICovXG5mdW5jdGlvbiBnZXRUcmFja1NlbmRlckNoYW5nZXMocGVlckNvbm5lY3Rpb25NYW5hZ2VyLCBkYXRhVHJhY2tTZW5kZXJzLCBtZWRpYVRyYWNrU2VuZGVycykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGdldERhdGFUcmFja1NlbmRlckNoYW5nZXMocGVlckNvbm5lY3Rpb25NYW5hZ2VyLCBkYXRhVHJhY2tTZW5kZXJzKSxcbiAgICAgICAgbWVkaWE6IGdldE1lZGlhVHJhY2tTZW5kZXJDaGFuZ2VzKHBlZXJDb25uZWN0aW9uTWFuYWdlciwgbWVkaWFUcmFja1NlbmRlcnMpXG4gICAgfTtcbn1cbi8qKlxuICogQGludGVyZmFjZSBNZWRpYVRyYWNrU2VuZGVyQ2hhbmdlc1xuICogQHByb3BlcnR5IHtTZXQ8TWVkaWFUcmFja1NlbmRlcj59IGFkZFxuICogQHByb3BlcnR5IHtTZXQ8TWVkaWFUcmFja1NlbmRlcj59IHJlbW92ZVxuICovXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIE1lZGlhVHJhY2tTZW5kZXJ9IGNoYW5nZXMuXG4gKiBAcGFyYW0ge1BlZXJDb25uZWN0aW9uTWFuYWdlcn0gcGVlckNvbm5lY3Rpb25NYW5hZ2VyXG4gKiBAcGFyYW0ge0FycmF5PE1lZGlhVHJhY2tTZW5kZXI+fSBtZWRpYVRyYWNrU2VuZGVyc1xuICogQHJldHVybnMge01lZGlhVHJhY2tTZW5kZXJDaGFuZ2VzfSBjaGFuZ2VzXG4gKi9cbmZ1bmN0aW9uIGdldE1lZGlhVHJhY2tTZW5kZXJDaGFuZ2VzKHBlZXJDb25uZWN0aW9uTWFuYWdlciwgbWVkaWFUcmFja1NlbmRlcnMpIHtcbiAgICB2YXIgbWVkaWFUcmFja1NlbmRlcnNUb0FkZCA9IHV0aWwuZGlmZmVyZW5jZShtZWRpYVRyYWNrU2VuZGVycywgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLl9tZWRpYVRyYWNrU2VuZGVycyk7XG4gICAgdmFyIG1lZGlhVHJhY2tTZW5kZXJzVG9SZW1vdmUgPSB1dGlsLmRpZmZlcmVuY2UocGVlckNvbm5lY3Rpb25NYW5hZ2VyLl9tZWRpYVRyYWNrU2VuZGVycywgbWVkaWFUcmFja1NlbmRlcnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogbWVkaWFUcmFja1NlbmRlcnNUb0FkZCxcbiAgICAgICAgcmVtb3ZlOiBtZWRpYVRyYWNrU2VuZGVyc1RvUmVtb3ZlXG4gICAgfTtcbn1cbi8qKlxuICogVGhpcyBvYmplY3QgbWFwcyBSVENJY2VDb25uZWN0aW9uU3RhdGUgYW5kIFJUQ1BlZXJDb25uZWN0aW9uU3RhdGUgdmFsdWVzIHRvIGEgXCJyYW5rXCIuXG4gKi9cbnZhciB0b1JhbmsgPSB7XG4gICAgbmV3OiAwLFxuICAgIGNoZWNraW5nOiAxLFxuICAgIGNvbm5lY3Rpbmc6IDIsXG4gICAgY29ubmVjdGVkOiAzLFxuICAgIGNvbXBsZXRlZDogNCxcbiAgICBkaXNjb25uZWN0ZWQ6IC0xLFxuICAgIGZhaWxlZDogLTIsXG4gICAgY2xvc2VkOiAtM1xufTtcbi8qKlxuICogVGhpcyBvYmplY3QgbWFwcyBcInJhbmtcIiBiYWNrIHRvIFJUQ0ljZUNvbm5lY3Rpb25TdGF0ZSBvciBSVENQZWVyQ29ubmVjdGlvblN0YXRlIHZhbHVlcy5cbiAqL1xudmFyIGZyb21SYW5rO1xuLyoqXG4gKiBgT2JqZWN0LmtleXNgIGlzIG5vdCBzdXBwb3J0ZWQgaW4gb2xkZXIgYnJvd3NlcnMsIHNvIHdlIGNhbid0IGp1c3RcbiAqIHN5bmNocm9ub3VzbHkgY2FsbCBpdCBpbiB0aGlzIG1vZHVsZTsgd2UgbmVlZCB0byBkZWZlciBpbnZva2luZyBpdCB1bnRpbCB3ZVxuICoga25vdyB3ZSdyZSBpbiBhIG1vZGVybiBlbnZpcm9ubWVudCAoaS5lLiwgYW55dGhpbmcgdGhhdCBzdXBwb3J0cyBXZWJSVEMpLlxuICogQHJldHVybnMge29iamVjdH0gZnJvbVJhbmtcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRnJvbVJhbmsoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRvUmFuaykucmVkdWNlKGZ1bmN0aW9uIChmcm9tUmFuaywgc3RhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihmcm9tUmFuaywgKF9hID0ge30sIF9hW3RvUmFua1tzdGF0ZV1dID0gc3RhdGUsIF9hKSk7XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiBTdW1tYXJpemUgUlRDSWNlQ29ubmVjdGlvblN0YXRlcyBvciBSVENQZWVyQ29ubmVjdGlvblN0YXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8UlRDSWNlQ29ubmVjdGlvblN0YXRlPnxBcnJheTxSVENQZWVyQ29ubmVjdGlvblN0YXRlPn0gc3RhdGVzXG4gKiBAcmV0dXJucyB7UlRDSWNlQ29ubmVjdGlvblN0YXRlfFJUQ1BlZXJDb25uZWN0aW9uU3RhdGV9IHN1bW1hcnlcbiAqL1xuZnVuY3Rpb24gc3VtbWFyaXplSWNlT3JQZWVyQ29ubmVjdGlvblN0YXRlcyhzdGF0ZXMpIHtcbiAgICBpZiAoIXN0YXRlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICduZXcnO1xuICAgIH1cbiAgICBmcm9tUmFuayA9IGZyb21SYW5rIHx8IGNyZWF0ZUZyb21SYW5rKCk7XG4gICAgcmV0dXJuIHN0YXRlcy5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlMSwgc3RhdGUyKSB7XG4gICAgICAgIHJldHVybiBmcm9tUmFua1tNYXRoLm1heCh0b1Jhbmtbc3RhdGUxXSwgdG9SYW5rW3N0YXRlMl0pXTtcbiAgICB9KTtcbn1cbi8qKlxuICogVXBkYXRlIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25NYW5hZ2VyfSdzIGBpY2VDb25uZWN0aW9uU3RhdGVgLCBhbmQgZW1pdCBhblxuICogXCJpY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkXCIgZXZlbnQsIGlmIG5lY2Vzc2FyeS5cbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25NYW5hZ2VyfSBwY21cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGVJY2VDb25uZWN0aW9uU3RhdGUocGNtKSB7XG4gICAgcGNtLl9sYXN0SWNlQ29ubmVjdGlvblN0YXRlID0gcGNtLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICBwY20uX2ljZUNvbm5lY3Rpb25TdGF0ZSA9IHN1bW1hcml6ZUljZU9yUGVlckNvbm5lY3Rpb25TdGF0ZXMoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHBjbS5fcGVlckNvbm5lY3Rpb25zLnZhbHVlcygpKSkubWFwKGZ1bmN0aW9uIChwY3YyKSB7IHJldHVybiBwY3YyLmljZUNvbm5lY3Rpb25TdGF0ZTsgfSkpO1xuICAgIGlmIChwY20uaWNlQ29ubmVjdGlvblN0YXRlICE9PSBwY20uX2xhc3RJY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgcGNtLmVtaXQoJ2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnKTtcbiAgICB9XG59XG4vKipcbiAqIFVwZGF0ZSB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0ncyBgY29ubmVjdGlvblN0YXRlYCwgYW5kIGVtaXQgYVxuICogXCJjb25uZWN0aW9uU3RhdGVDaGFuZ2VkXCIgZXZlbnQsIGlmIG5lY2Vzc2FyeS5cbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25NYW5hZ2VyfSBwY21cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGVDb25uZWN0aW9uU3RhdGUocGNtKSB7XG4gICAgcGNtLl9sYXN0Q29ubmVjdGlvblN0YXRlID0gcGNtLmNvbm5lY3Rpb25TdGF0ZTtcbiAgICBwY20uX2Nvbm5lY3Rpb25TdGF0ZSA9IHN1bW1hcml6ZUljZU9yUGVlckNvbm5lY3Rpb25TdGF0ZXMoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHBjbS5fcGVlckNvbm5lY3Rpb25zLnZhbHVlcygpKSkubWFwKGZ1bmN0aW9uIChwY3YyKSB7IHJldHVybiBwY3YyLmNvbm5lY3Rpb25TdGF0ZTsgfSkpO1xuICAgIGlmIChwY20uY29ubmVjdGlvblN0YXRlICE9PSBwY20uX2xhc3RDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgcGNtLmVtaXQoJ2Nvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnKTtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFBlZXJDb25uZWN0aW9uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlZXJjb25uZWN0aW9ubWFuYWdlci5qcy5tYXAiLCIvKiBlc2xpbnQgY2FsbGJhY2stcmV0dXJuOjAgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTWVkaWFTaWduYWxpbmcgPSByZXF1aXJlKCcuL21lZGlhc2lnbmFsaW5nJyk7XG52YXIgbWVzc2FnZUlkID0gMTtcbnZhciBQdWJsaXNoZXJIaW50c1NpZ25hbGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHVibGlzaGVySGludHNTaWduYWxpbmcsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJlbmRlckhpbnRzU2lnbmFsaW5nfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQdWJsaXNoZXJIaW50c1NpZ25hbGluZyhnZXRSZWNlaXZlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBnZXRSZWNlaXZlciwgJ3B1Ymxpc2hlcl9oaW50cycsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9uKCdyZWFkeScsIGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoJ3B1Ymxpc2hlcl9oaW50cyB0cmFuc3BvcnQgcmVhZHk6JywgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZygnSW5jb21pbmc6ICcsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1Ymxpc2hlcl9oaW50cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5wdWJsaXNoZXIgJiYgbWVzc2FnZS5wdWJsaXNoZXIuaGludHMgJiYgbWVzc2FnZS5wdWJsaXNoZXIuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvY2Vzc1B1Ymxpc2hlckhpbnRzKG1lc3NhZ2UucHVibGlzaGVyLmhpbnRzLCBtZXNzYWdlLnB1Ymxpc2hlci5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cud2FybignVW5rbm93biBtZXNzYWdlIHR5cGU6ICcsIG1lc3NhZ2UudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUHVibGlzaGVySGludHNTaWduYWxpbmcucHJvdG90eXBlLnNlbmRUcmFja1JlcGxhY2VkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0cmFja1NpZCA9IF9hLnRyYWNrU2lkO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXlMb2FkID0ge1xuICAgICAgICAgICAgdHlwZTogJ2NsaWVudF9yZXNldCcsXG4gICAgICAgICAgICB0cmFjazogdHJhY2tTaWQsXG4gICAgICAgICAgICBpZDogbWVzc2FnZUlkKytcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdPdXRnb2luZzogJywgcGF5TG9hZCk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5wdWJsaXNoKHBheUxvYWQpO1xuICAgIH07XG4gICAgUHVibGlzaGVySGludHNTaWduYWxpbmcucHJvdG90eXBlLnNlbmRIaW50UmVzcG9uc2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGlkID0gX2EuaWQsIGhpbnRzID0gX2EuaGludHM7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBheUxvYWQgPSB7XG4gICAgICAgICAgICB0eXBlOiAncHVibGlzaGVyX2hpbnRzJyxcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGhpbnRzOiBoaW50c1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ091dGdvaW5nOiAnLCBwYXlMb2FkKTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnB1Ymxpc2gocGF5TG9hZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFB1Ymxpc2hlckhpbnRzU2lnbmFsaW5nLnByb3RvdHlwZS5fcHJvY2Vzc1B1Ymxpc2hlckhpbnRzID0gZnVuY3Rpb24gKGhpbnRzLCBpZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJywgaGludHMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcignZXJyb3IgcHJvY2Vzc2luZyBoaW50czonLCBleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQdWJsaXNoZXJIaW50c1NpZ25hbGluZztcbn0oTWVkaWFTaWduYWxpbmcpKTtcbm1vZHVsZS5leHBvcnRzID0gUHVibGlzaGVySGludHNTaWduYWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaXNoZXJoaW50c2lnbmFsaW5nLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgUmVjb3JkaW5nU2lnbmFsaW5nID0gcmVxdWlyZSgnLi4vcmVjb3JkaW5nJyk7XG4vKipcbiAqIEBleHRlbmRzIFJlY29yZGluZ1NpZ25hbGluZ1xuICovXG52YXIgUmVjb3JkaW5nVjIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlY29yZGluZ1YyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSZWNvcmRpbmdWMn0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVjb3JkaW5nVjIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfcmV2aXNpb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHRoZSB7QGxpbmsgUmVjb3JkaW5nVjJ9IHRvIGEge0BsaW5rIFJlY29yZGluZ1YyI1JlcHJlc2VudGF0aW9ufVxuICAgICAqIG9mIGl0c2VsZiBhbmQgcGVyZm9ybSBhbnkgdXBkYXRlcyBuZWNlc3NhcnkuXG4gICAgICogQHBhcmFtIHtSZWNvcmRpbmdWMiNSZXByZXNlbnRhdGlvbn0gcmVjb3JkaW5nXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGZpcmVzIFJlY29yZGluZ1NpZ25hbGluZyN1cGRhdGVkXG4gICAgICovXG4gICAgUmVjb3JkaW5nVjIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChyZWNvcmRpbmcpIHtcbiAgICAgICAgaWYgKHJlY29yZGluZy5yZXZpc2lvbiA8IHRoaXMuX3JldmlzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXZpc2lvbiA9IHJlY29yZGluZy5yZXZpc2lvbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlKHJlY29yZGluZy5pc19yZWNvcmRpbmcpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY29yZGluZ1YyO1xufShSZWNvcmRpbmdTaWduYWxpbmcpKTtcbi8qKlxuICogVGhlIFJvb20gU2lnbmFsaW5nIFByb3RvY29sIChSU1ApIHJlcHJlc2VudGF0aW9uIG9mIGEge0BsaW5rIFJlY29yZGluZ1YyfVxuICogQHR5cGVkZWYge29iamVjdH0gUmVjb3JkaW5nVjIjUmVwcmVzZW50YXRpb25cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZW5hYmxlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJldmlzaW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVjb3JkaW5nVjI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNvcmRpbmcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBSZW1vdGVQYXJ0aWNpcGFudFNpZ25hbGluZyA9IHJlcXVpcmUoJy4uL3JlbW90ZXBhcnRpY2lwYW50Jyk7XG52YXIgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYyID0gcmVxdWlyZSgnLi9yZW1vdGV0cmFja3B1YmxpY2F0aW9uJyk7XG4vKipcbiAqIEBleHRlbmRzIFJlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IHJldmlzaW9uXG4gKi9cbnZhciBSZW1vdGVQYXJ0aWNpcGFudFYyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW1vdGVQYXJ0aWNpcGFudFYyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudFYyfS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGljaXBhbnRTdGF0ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhY2suU0lEKTogYm9vbGVhbn0gZ2V0SW5pdGlhbFRyYWNrU3dpdGNoT2ZmU3RhdGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFRyYWNrLlNJRCwgVHJhY2suUHJpb3JpdHkpOiBib29sZWFufSBzZXRQcmlvcml0eVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhY2suU0lELCBDbGllbnRSZW5kZXJIaW50KTogUHJvbWlzZTx2b2lkPn0gc2V0UmVuZGVySGludFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhY2suU0lEKTogdm9pZH0gY2xlYXJUcmFja0hpbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVtb3RlUGFydGljaXBhbnRWMihwYXJ0aWNpcGFudFN0YXRlLCBnZXRJbml0aWFsVHJhY2tTd2l0Y2hPZmZTdGF0ZSwgc2V0UHJpb3JpdHksIHNldFJlbmRlckhpbnQsIGNsZWFyVHJhY2tIaW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcnRpY2lwYW50U3RhdGUuc2lkLCBwYXJ0aWNpcGFudFN0YXRlLmlkZW50aXR5KSB8fCB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjIsXG4gICAgICAgICAgICBnZXRQZW5kaW5nVHJhY2tSZWNlaXZlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9yZXZpc2lvbjoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX1JlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5SZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldEluaXRpYWxUcmFja1N3aXRjaE9mZlN0YXRlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGdldEluaXRpYWxUcmFja1N3aXRjaE9mZlN0YXRlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldFBlbmRpbmdUcmFja1JlY2VpdmVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuZ2V0UGVuZGluZ1RyYWNrUmVjZWl2ZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVTdWJzY3JpYmVyVHJhY2tQcmlvcml0eToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodHJhY2tTaWQsIHByaW9yaXR5KSB7IHJldHVybiBzZXRQcmlvcml0eSh0cmFja1NpZCwgcHJpb3JpdHkpOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlVHJhY2tSZW5kZXJIaW50OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0cmFja1NpZCwgcmVuZGVySGludCkgeyByZXR1cm4gc2V0UmVuZGVySGludCh0cmFja1NpZCwgcmVuZGVySGludCk7IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhclRyYWNrSGludDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodHJhY2tTaWQpIHsgcmV0dXJuIGNsZWFyVHJhY2tIaW50KHRyYWNrU2lkKTsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldmlzaW9uOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldmlzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLnVwZGF0ZShwYXJ0aWNpcGFudFN0YXRlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlbW90ZVBhcnRpY2lwYW50VjIucHJvdG90eXBlLl9nZXRPckNyZWF0ZVRyYWNrID0gZnVuY3Rpb24gKHRyYWNrU3RhdGUpIHtcbiAgICAgICAgdmFyIFJlbW90ZVRyYWNrUHVibGljYXRpb25WMiA9IHRoaXMuX1JlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmc7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMudHJhY2tzLmdldCh0cmFja1N0YXRlLnNpZCk7XG4gICAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc1N3aXRjaGVkT2ZmID0gdGhpcy5fZ2V0SW5pdGlhbFRyYWNrU3dpdGNoT2ZmU3RhdGUodHJhY2tTdGF0ZS5zaWQpO1xuICAgICAgICAgICAgdHJhY2sgPSBuZXcgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYyKHRyYWNrU3RhdGUsIGlzU3dpdGNoZWRPZmYpO1xuICAgICAgICAgICAgdGhpcy5hZGRUcmFjayh0cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnRWMn0gd2l0aCB0aGUgbmV3IHN0YXRlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWNpcGFudFN0YXRlXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgUmVtb3RlUGFydGljaXBhbnRWMi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHBhcnRpY2lwYW50U3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMucmV2aXNpb24gIT09IG51bGwgJiYgcGFydGljaXBhbnRTdGF0ZS5yZXZpc2lvbiA8PSB0aGlzLnJldmlzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXZpc2lvbiA9IHBhcnRpY2lwYW50U3RhdGUucmV2aXNpb247XG4gICAgICAgIHZhciB0cmFja3NUb0tlZXAgPSBuZXcgU2V0KCk7XG4gICAgICAgIHBhcnRpY2lwYW50U3RhdGUudHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrU3RhdGUpIHtcbiAgICAgICAgICAgIHZhciB0cmFjayA9IF90aGlzLl9nZXRPckNyZWF0ZVRyYWNrKHRyYWNrU3RhdGUpO1xuICAgICAgICAgICAgdHJhY2sudXBkYXRlKHRyYWNrU3RhdGUpO1xuICAgICAgICAgICAgdHJhY2tzVG9LZWVwLmFkZCh0cmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgaWYgKCF0cmFja3NUb0tlZXAuaGFzKHRyYWNrKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXRjaCAocGFydGljaXBhbnRTdGF0ZS5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlY29ubmVjdGluZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMuc2lkLCB0aGlzLmlkZW50aXR5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBSZW1vdGVQYXJ0aWNpcGFudFYyO1xufShSZW1vdGVQYXJ0aWNpcGFudFNpZ25hbGluZykpO1xubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVQYXJ0aWNpcGFudFYyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RlcGFydGljaXBhbnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nID0gcmVxdWlyZSgnLi4vcmVtb3RldHJhY2twdWJsaWNhdGlvbicpO1xuLyoqXG4gKiBAZXh0ZW5kcyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nXG4gKi9cbnZhciBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbW90ZVRyYWNrUHVibGljYXRpb25WMiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYyfS5cbiAgICAgKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb25WMiNSZXByZXNlbnRhdGlvbn0gdHJhY2tcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3dpdGNoZWRPZmZcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbW90ZVRyYWNrUHVibGljYXRpb25WMih0cmFjaywgaXNTd2l0Y2hlZE9mZikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdHJhY2suc2lkLCB0cmFjay5uYW1lLCB0cmFjay5raW5kLCB0cmFjay5lbmFibGVkLCB0cmFjay5wcmlvcml0eSwgaXNTd2l0Y2hlZE9mZiwgMikgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbW90ZVRyYWNrUHVibGljYXRpb25WMi5wcm90b3R5cGUsIFwiaXNTdWJzY3JpYmVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjJ9IGlzIHN1YnNjcmliZWQgdG8uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy50cmFja1RyYW5zY2VpdmVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0aGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb25WMn0gdG8gYVxuICAgICAqIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjIjUmVwcmVzZW50YXRpb259IG9mIGl0c2VsZiBhbmQgcGVyZm9ybSBhbnlcbiAgICAgKiB1cGRhdGVzIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb25WMiNSZXByZXNlbnRhdGlvbn0gdHJhY2tcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAZmlyZXMgVHJhY2tTaWduYWxpbmcjdXBkYXRlZFxuICAgICAqL1xuICAgIFJlbW90ZVRyYWNrUHVibGljYXRpb25WMi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlKHRyYWNrLmVuYWJsZWQpO1xuICAgICAgICB0aGlzLnNldFByaW9yaXR5KHRyYWNrLnByaW9yaXR5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYyO1xufShSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nKSk7XG4vKipcbiAqIFRoZSBSb29tIFNpZ25hbGluZyBQcm90b2NvbCAoUlNQKSByZXByZXNlbnRhdGlvbiBvZiBhIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjJ9LlxuICogQHR5cGVkZWYge0xvY2FsVHJhY2tQdWJsaWNhdGlvblYyI1JlcHJlc2VudGF0aW9ufSBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjIjUmVwcmVzZW50YXRpb25cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3Vic2NyaWJlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW90ZVRyYWNrUHVibGljYXRpb25WMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW90ZXRyYWNrcHVibGljYXRpb24uanMubWFwIiwiLyogZXNsaW50IGNhbGxiYWNrLXJldHVybjowICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIE1lZGlhU2lnbmFsaW5nID0gcmVxdWlyZSgnLi9tZWRpYXNpZ25hbGluZycpO1xudmFyIFRpbWVvdXQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3RpbWVvdXQnKTtcbnZhciBpc0RlZXBFcXVhbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKS5pc0RlZXBFcXVhbDtcbnZhciBSRU5ERVJfSElOVF9SRVNQT05TRV9USU1FX01TID0gMjAwMDsgLy8gdGltZSB0byB3YWl0IGZvciBzZXJ2ZXIgcmVzcG9uc2UgKGJlZm9yZSByZXNlbmRpbmcgYWxsIGhpbnRzLilcbnZhciBtZXNzYWdlSWQgPSAxO1xudmFyIFJlbmRlckhpbnRzU2lnbmFsaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJIaW50c1NpZ25hbGluZywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUmVuZGVySGludHNTaWduYWxpbmd9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbmRlckhpbnRzU2lnbmFsaW5nKGdldFJlY2VpdmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdldFJlY2VpdmVyLCAncmVuZGVyX2hpbnRzJywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF90cmFja1NpZHNUb1JlbmRlckhpbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZXNwb25zZVRpbWVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NlbmRBbGxIaW50cygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmNlIHRpbWVyIGZpcmVzLCBmb3IgbmV4dCByb3VuZCBkb3VibGUgdGhlIGRlbGF5LlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzcG9uc2VUaW1lci5zZXREZWxheShfdGhpcy5fcmVzcG9uc2VUaW1lci5kZWxheSAqIDIpO1xuICAgICAgICAgICAgICAgIH0sIFJFTkRFUl9ISU5UX1JFU1BPTlNFX1RJTUVfTVMsIGZhbHNlKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uKCdyZWFkeScsIGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZygnSW5jb21pbmc6ICcsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlbmRlcl9oaW50cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvY2Vzc0hpbnRSZXN1bHRzKChtZXNzYWdlICYmIG1lc3NhZ2Uuc3Vic2NyaWJlciAmJiBtZXNzYWdlLnN1YnNjcmliZXIuaGludHMpIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy53YXJuKCdVbmtub3duIG1lc3NhZ2UgdHlwZTogJywgbWVzc2FnZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IFdoZW4gdHJhbnNwb3J0IGlzIHNldCAoZWl0aGVyIDFzdCB0aW1lIG9mIGFmdGVyIHZtcyBmYWlsb3ZlcilcbiAgICAgICAgICAgIC8vIHJlc2VuZCBhbGwgdHJhY2sgc3RhdGVzLlxuICAgICAgICAgICAgX3RoaXMuX3NlbmRBbGxIaW50cygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZW5kZXJIaW50c1NpZ25hbGluZy5wcm90b3R5cGUuX3NlbmRBbGxIaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gdG8gZm9yY2Ugc2VuZGluZyBhbGwgaGludHMgc2ltcGx5IG1hcmsgYWxsIHRyYWNrcyBhcyBkaXJ0eS5cbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl90cmFja1NpZHNUb1JlbmRlckhpbnRzLmtleXMoKSkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tTaWQpIHtcbiAgICAgICAgICAgIHZhciB0cmFja1N0YXRlID0gX3RoaXMuX3RyYWNrU2lkc1RvUmVuZGVySGludHMuZ2V0KHRyYWNrU2lkKTtcbiAgICAgICAgICAgIGlmICh0cmFja1N0YXRlLnJlbmRlckRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICB0cmFja1N0YXRlLmlzRGltZW5zaW9uRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdlbmFibGVkJyBpbiB0cmFja1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tTdGF0ZS5pc0VuYWJsZWREaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZW5kSGludHMoKTtcbiAgICB9O1xuICAgIFJlbmRlckhpbnRzU2lnbmFsaW5nLnByb3RvdHlwZS5fcHJvY2Vzc0hpbnRSZXN1bHRzID0gZnVuY3Rpb24gKGhpbnRSZXN1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlVGltZXIuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VUaW1lci5zZXREZWxheShSRU5ERVJfSElOVF9SRVNQT05TRV9USU1FX01TKTtcbiAgICAgICAgaGludFJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAoaGludFJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGhpbnRSZXN1bHQucmVzdWx0ICE9PSAnT0snKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZygnU2VydmVyIGVycm9yIHByb2Nlc3NpbmcgaGludDonLCBoaW50UmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRIaW50cygpO1xuICAgIH07XG4gICAgUmVuZGVySGludHNTaWduYWxpbmcucHJvdG90eXBlLl9zZW5kSGludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0IHx8IHRoaXMuX3Jlc3BvbnNlVGltZXIuaXNTZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGludHMgPSBbXTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl90cmFja1NpZHNUb1JlbmRlckhpbnRzLmtleXMoKSkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tTaWQpIHtcbiAgICAgICAgICAgIHZhciB0cmFja1N0YXRlID0gX3RoaXMuX3RyYWNrU2lkc1RvUmVuZGVySGludHMuZ2V0KHRyYWNrU2lkKTtcbiAgICAgICAgICAgIGlmICh0cmFja1N0YXRlLmlzRW5hYmxlZERpcnR5IHx8IHRyYWNrU3RhdGUuaXNEaW1lbnNpb25EaXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBtc3BIaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAndHJhY2snOiB0cmFja1NpZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0cmFja1N0YXRlLmlzRW5hYmxlZERpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1zcEhpbnQuZW5hYmxlZCA9IHRyYWNrU3RhdGUuZW5hYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tTdGF0ZS5pc0VuYWJsZWREaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJhY2tTdGF0ZS5pc0RpbWVuc2lvbkRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgICAgICAgICAgICAgbXNwSGludC5yZW5kZXJfZGltZW5zaW9ucyA9IHRyYWNrU3RhdGUucmVuZGVyRGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tTdGF0ZS5pc0RpbWVuc2lvbkRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhpbnRzLnB1c2gobXNwSGludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHBheUxvYWQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlbmRlcl9oaW50cycsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcjoge1xuICAgICAgICAgICAgICAgICAgICBpZDogbWVzc2FnZUlkKyssXG4gICAgICAgICAgICAgICAgICAgIGhpbnRzOiBoaW50c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ091dGdvaW5nOiAnLCBwYXlMb2FkKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydC5wdWJsaXNoKHBheUxvYWQpO1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VUaW1lci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyYWNrLlNJRH0gdHJhY2tTaWRcbiAgICAgKiBAcGFyYW0ge0NsaWVudFJlbmRlckhpbnR9IHJlbmRlckhpbnRcbiAgICAgKi9cbiAgICBSZW5kZXJIaW50c1NpZ25hbGluZy5wcm90b3R5cGUuc2V0VHJhY2tIaW50ID0gZnVuY3Rpb24gKHRyYWNrU2lkLCByZW5kZXJIaW50KSB7XG4gICAgICAgIHZhciB0cmFja1N0YXRlID0gdGhpcy5fdHJhY2tTaWRzVG9SZW5kZXJIaW50cy5nZXQodHJhY2tTaWQpIHx8IHsgaXNFbmFibGVkRGlydHk6IGZhbHNlLCBpc0RpbWVuc2lvbkRpcnR5OiBmYWxzZSB9O1xuICAgICAgICBpZiAoJ2VuYWJsZWQnIGluIHJlbmRlckhpbnQgJiYgdHJhY2tTdGF0ZS5lbmFibGVkICE9PSByZW5kZXJIaW50LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRyYWNrU3RhdGUuZW5hYmxlZCA9ICEhcmVuZGVySGludC5lbmFibGVkO1xuICAgICAgICAgICAgdHJhY2tTdGF0ZS5pc0VuYWJsZWREaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbmRlckhpbnQucmVuZGVyRGltZW5zaW9ucyAmJiAhaXNEZWVwRXF1YWwocmVuZGVySGludC5yZW5kZXJEaW1lbnNpb25zLCB0cmFja1N0YXRlLnJlbmRlckRpbWVuc2lvbnMpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICAgICB0cmFja1N0YXRlLnJlbmRlckRpbWVuc2lvbnMgPSByZW5kZXJIaW50LnJlbmRlckRpbWVuc2lvbnM7XG4gICAgICAgICAgICB0cmFja1N0YXRlLmlzRGltZW5zaW9uRGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYWNrU2lkc1RvUmVuZGVySGludHMuc2V0KHRyYWNrU2lkLCB0cmFja1N0YXRlKTtcbiAgICAgICAgdGhpcy5fc2VuZEhpbnRzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBtdXN0IGJlIGNhbGxlZCB3aGVuIHRyYWNrIGlzIHVuc3Vic2NyaWJlZC5cbiAgICAgKiBAcGFyYW0ge1RyYWNrLlNJRH0gdHJhY2tTaWRcbiAgICAgKi9cbiAgICBSZW5kZXJIaW50c1NpZ25hbGluZy5wcm90b3R5cGUuY2xlYXJUcmFja0hpbnQgPSBmdW5jdGlvbiAodHJhY2tTaWQpIHtcbiAgICAgICAgdGhpcy5fdHJhY2tTaWRzVG9SZW5kZXJIaW50cy5kZWxldGUodHJhY2tTaWQpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbmRlckhpbnRzU2lnbmFsaW5nO1xufShNZWRpYVNpZ25hbGluZykpO1xubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJIaW50c1NpZ25hbGluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlcmhpbnRzc2lnbmFsaW5nLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgRG9taW5hbnRTcGVha2VyU2lnbmFsaW5nID0gcmVxdWlyZSgnLi9kb21pbmFudHNwZWFrZXJzaWduYWxpbmcnKTtcbnZhciBOZXR3b3JrUXVhbGl0eU1vbml0b3IgPSByZXF1aXJlKCcuL25ldHdvcmtxdWFsaXR5bW9uaXRvcicpO1xudmFyIE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nID0gcmVxdWlyZSgnLi9uZXR3b3JrcXVhbGl0eXNpZ25hbGluZycpO1xudmFyIFJlY29yZGluZ1YyID0gcmVxdWlyZSgnLi9yZWNvcmRpbmcnKTtcbnZhciBSb29tU2lnbmFsaW5nID0gcmVxdWlyZSgnLi4vcm9vbScpO1xudmFyIFJlbW90ZVBhcnRpY2lwYW50VjIgPSByZXF1aXJlKCcuL3JlbW90ZXBhcnRpY2lwYW50Jyk7XG52YXIgU3RhdHNSZXBvcnQgPSByZXF1aXJlKCcuLi8uLi9zdGF0cy9zdGF0c3JlcG9ydCcpO1xudmFyIFRyYWNrUHJpb3JpdHlTaWduYWxpbmcgPSByZXF1aXJlKCcuL3RyYWNrcHJpb3JpdHlzaWduYWxpbmcnKTtcbnZhciBUcmFja1N3aXRjaE9mZlNpZ25hbGluZyA9IHJlcXVpcmUoJy4vdHJhY2tzd2l0Y2hvZmZzaWduYWxpbmcnKTtcbnZhciBSZW5kZXJIaW50c1NpZ25hbGluZyA9IHJlcXVpcmUoJy4vcmVuZGVyaGludHNzaWduYWxpbmcnKTtcbnZhciBQdWJsaXNoZXJIaW50c1NpZ25hbGluZyA9IHJlcXVpcmUoJy4vcHVibGlzaGVyaGludHNpZ25hbGluZy5qcycpO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLCBERUZBVUxUX1NFU1NJT05fVElNRU9VVF9TRUMgPSBfYS5jb25zdGFudHMuREVGQVVMVF9TRVNTSU9OX1RJTUVPVVRfU0VDLCBjcmVhdGVCYW5kd2lkdGhQcm9maWxlUGF5bG9hZCA9IF9hLmNyZWF0ZUJhbmR3aWR0aFByb2ZpbGVQYXlsb2FkLCBkZWZlciA9IF9hLmRlZmVyLCBkaWZmZXJlbmNlID0gX2EuZGlmZmVyZW5jZSwgZmlsdGVyT2JqZWN0ID0gX2EuZmlsdGVyT2JqZWN0LCBmbGF0TWFwID0gX2EuZmxhdE1hcCwgb25jZVBlclRpY2sgPSBfYS5vbmNlUGVyVGljaztcbnZhciBNb3ZpbmdBdmVyYWdlRGVsdGEgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vdmluZ2F2ZXJhZ2VkZWx0YScpO1xudmFyIGNyZWF0ZVR3aWxpb0Vycm9yID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90d2lsaW8tdmlkZW8tZXJyb3JzJykuY3JlYXRlVHdpbGlvRXJyb3I7XG52YXIgU1RBVFNfUFVCTElTSF9JTlRFUlZBTF9NUyA9IDEwMDAwO1xuLyoqXG4gKiBAZXh0ZW5kcyBSb29tU2lnbmFsaW5nXG4gKi9cbnZhciBSb29tVjIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21WMiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tVjIobG9jYWxQYXJ0aWNpcGFudCwgaW5pdGlhbFN0YXRlLCB0cmFuc3BvcnQsIHBlZXJDb25uZWN0aW9uTWFuYWdlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpbml0aWFsU3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgc2Vzc2lvbl90aW1lb3V0OiBERUZBVUxUX1NFU1NJT05fVElNRU9VVF9TRUNcbiAgICAgICAgfSwgaW5pdGlhbFN0YXRlLm9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBEb21pbmFudFNwZWFrZXJTaWduYWxpbmc6IERvbWluYW50U3BlYWtlclNpZ25hbGluZyxcbiAgICAgICAgICAgIE5ldHdvcmtRdWFsaXR5TW9uaXRvcjogTmV0d29ya1F1YWxpdHlNb25pdG9yLFxuICAgICAgICAgICAgTmV0d29ya1F1YWxpdHlTaWduYWxpbmc6IE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nLFxuICAgICAgICAgICAgUmVjb3JkaW5nU2lnbmFsaW5nOiBSZWNvcmRpbmdWMixcbiAgICAgICAgICAgIFJlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nOiBSZW1vdGVQYXJ0aWNpcGFudFYyLFxuICAgICAgICAgICAgVHJhY2tQcmlvcml0eVNpZ25hbGluZzogVHJhY2tQcmlvcml0eVNpZ25hbGluZyxcbiAgICAgICAgICAgIFRyYWNrU3dpdGNoT2ZmU2lnbmFsaW5nOiBUcmFja1N3aXRjaE9mZlNpZ25hbGluZyxcbiAgICAgICAgICAgIGJhbmR3aWR0aFByb2ZpbGU6IG51bGwsXG4gICAgICAgICAgICBvdGhlck1lZGlhU2lnbmFsaW5nczogW10sXG4gICAgICAgICAgICBzZXNzaW9uVGltZW91dDogaW5pdGlhbFN0YXRlLm9wdGlvbnMuc2Vzc2lvbl90aW1lb3V0ICogMTAwMCxcbiAgICAgICAgICAgIHN0YXRzUHVibGlzaEludGVydmFsTXM6IFNUQVRTX1BVQkxJU0hfSU5URVJWQUxfTVNcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIGxvY2FsUGFydGljaXBhbnQuc2V0QmFuZHdpZHRoUHJvZmlsZShvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGUpO1xuICAgICAgICBwZWVyQ29ubmVjdGlvbk1hbmFnZXIuc2V0SWNlUmVjb25uZWN0VGltZW91dChvcHRpb25zLnNlc3Npb25UaW1lb3V0KTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsb2NhbFBhcnRpY2lwYW50LCBpbml0aWFsU3RhdGUuc2lkLCBpbml0aWFsU3RhdGUubmFtZSwgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgdmFyIGdldFRyYWNrUmVjZWl2ZXIgPSBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIF90aGlzLl9nZXRUcmFja1JlY2VpdmVyKGlkKTsgfTtcbiAgICAgICAgdmFyIGxvZyA9IF90aGlzLl9sb2c7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfZGlzY29ubmVjdGVkUGFydGljaXBhbnRSZXZpc2lvbnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX05ldHdvcmtRdWFsaXR5TW9uaXRvcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLk5ldHdvcmtRdWFsaXR5TW9uaXRvclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sYXN0QmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGxvY2FsUGFydGljaXBhbnQuYmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX25ldHdvcmtRdWFsaXR5TW9uaXRvcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX25ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsb2NhbFBhcnRpY2lwYW50Lm5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9wZWVyQ29ubmVjdGlvbk1hbmFnZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGVlckNvbm5lY3Rpb25NYW5hZ2VyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3B1Ymxpc2hlZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcHVibGlzaGVkUmV2aXNpb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9SZW1vdGVQYXJ0aWNpcGFudFNpZ25hbGluZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLlJlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3N1YnNjcmliZWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3N1YnNjcmliZWRSZXZpc2lvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3N1YnNjcmlwdGlvbkZhaWx1cmVzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kb21pbmFudFNwZWFrZXJTaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IG9wdGlvbnMuRG9taW5hbnRTcGVha2VyU2lnbmFsaW5nKGdldFRyYWNrUmVjZWl2ZXIsIHsgbG9nOiBsb2cgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbmV0d29ya1F1YWxpdHlTaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IG9wdGlvbnMuTmV0d29ya1F1YWxpdHlTaWduYWxpbmcoZ2V0VHJhY2tSZWNlaXZlciwgbG9jYWxQYXJ0aWNpcGFudC5uZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24sIHsgbG9nOiBsb2cgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVuZGVySGludHNTaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFJlbmRlckhpbnRzU2lnbmFsaW5nKGdldFRyYWNrUmVjZWl2ZXIsIHsgbG9nOiBsb2cgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3B1Ymxpc2hlckhpbnRzU2lnbmFsaW5nOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBQdWJsaXNoZXJIaW50c1NpZ25hbGluZyhnZXRUcmFja1JlY2VpdmVyLCB7IGxvZzogbG9nIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90cmFja1ByaW9yaXR5U2lnbmFsaW5nOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBvcHRpb25zLlRyYWNrUHJpb3JpdHlTaWduYWxpbmcoZ2V0VHJhY2tSZWNlaXZlciwgeyBsb2c6IGxvZyB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdHJhY2tTd2l0Y2hPZmZTaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IG9wdGlvbnMuVHJhY2tTd2l0Y2hPZmZTaWduYWxpbmcoZ2V0VHJhY2tSZWNlaXZlciwgeyBsb2c6IGxvZyB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcGVuZGluZ1N3aXRjaE9mZlN0YXRlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdHJhbnNwb3J0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRyYW5zcG9ydFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90cmFja1JlY2VpdmVyRGVmZXJyZWRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lZGlhUmVnaW9uOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5pdGlhbFN0YXRlLm9wdGlvbnMubWVkaWFfcmVnaW9uIHx8IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLl9pbml0KGxvY2FsUGFydGljaXBhbnQsIHBlZXJDb25uZWN0aW9uTWFuYWdlciwgdHJhbnNwb3J0LCBvcHRpb25zLCBpbml0aWFsU3RhdGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb29tVjIucHJvdG90eXBlLCBcImNvbm5lY3Rpb25TdGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgUGVlckNvbm5lY3Rpb24gc3RhdGUuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7UlRDUGVlckNvbm5lY3Rpb25TdGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uU3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm9vbVYyLnByb3RvdHlwZSwgXCJzaWduYWxpbmdDb25uZWN0aW9uU3RhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFNpZ25hbGluZyBDb25uZWN0aW9uIFN0YXRlLlxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gLSBcImNvbm5lY3RlZFwiLCBcInJlY29ubmVjdGluZ1wiLCBcImRpc2Nvbm5lY3RlZFwiXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc3RhdGUgPT09ICdzeW5jaW5nJ1xuICAgICAgICAgICAgICAgID8gJ3JlY29ubmVjdGluZydcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3RyYW5zcG9ydC5zdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb29tVjIucHJvdG90eXBlLCBcImljZUNvbm5lY3Rpb25TdGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSWNlIENvbm5lY3Rpb24gU3RhdGUuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7UlRDSWNlQ29ubmVjdGlvblN0YXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb25NYW5hZ2VyLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUm9vbVYyLnByb3RvdHlwZS5fZGVsZXRlVHJhY2tSZWNlaXZlckRlZmVycmVkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja1JlY2VpdmVyRGVmZXJyZWRzLmRlbGV0ZShpZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX2dldE9yQ3JlYXRlVHJhY2tSZWNlaXZlckRlZmVycmVkID0gZnVuY3Rpb24gKGlkLCBpZE9yTWlkKSB7XG4gICAgICAgIGlmIChpZE9yTWlkID09PSB2b2lkIDApIHsgaWRPck1pZCA9ICdpZCc7IH1cbiAgICAgICAgdmFyIGRlZmVycmVkID0gdGhpcy5fdHJhY2tSZWNlaXZlckRlZmVycmVkcy5nZXQoaWQpIHx8IGRlZmVyKCk7XG4gICAgICAgIHZhciB0cmFja1JlY2VpdmVycyA9IHRoaXMuX3BlZXJDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFja1JlY2VpdmVycygpO1xuICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBJbiBGaXJlZm94LCB0aGVyZSBjYW4gYmUgaW5zdGFuY2VzIHdoZXJlIGEgTWVkaWFTdHJlYW1UcmFja1xuICAgICAgICAvLyBmb3IgdGhlIGdpdmVuIFRyYWNrIElEIGFscmVhZHkgZXhpc3RzLCBmb3IgZXhhbXBsZSwgd2hlbiBhIFRyYWNrIGlzIHJlbW92ZWRcbiAgICAgICAgLy8gYW5kIGFkZGVkIGJhY2suIElmIHRoYXQgaXMgdGhlIGNhc2UsIHRoZW4gd2Ugc2hvdWxkIHJlc29sdmUgJ2RlZmVycmVkJy5cbiAgICAgICAgdmFyIHRyYWNrUmVjZWl2ZXIgPSB0cmFja1JlY2VpdmVycy5maW5kKGZ1bmN0aW9uICh0cmFja1JlY2VpdmVyKSB7IHJldHVybiB0cmFja1JlY2VpdmVyW2lkT3JNaWRdID09PSBpZCAmJiB0cmFja1JlY2VpdmVyLnJlYWR5U3RhdGUgIT09ICdlbmRlZCc7IH0pO1xuICAgICAgICBpZiAodHJhY2tSZWNlaXZlcikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0cmFja1JlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IE9ubHkgYWRkIHRoZSAnZGVmZXJyZWQnIHRvIHRoZSBtYXAgaWYgaXQncyBub3RcbiAgICAgICAgICAgIC8vIHJlc29sdmVkLiBUaGlzIHdpbGwgcHJldmVudCBvbGQgY29waWVzIG9mIHRoZSBNZWRpYVN0cmVhbVRyYWNrIGZyb21cbiAgICAgICAgICAgIC8vIGJlaW5nIHVzZWQgd2hlbiB0aGUgcmVtb3RlIHBlZXIgcmVtb3ZlcyBhbmQgcmUtYWRkcyBhIE1lZGlhU3RyZWFtVHJhY2suXG4gICAgICAgICAgICB0aGlzLl90cmFja1JlY2VpdmVyRGVmZXJyZWRzLnNldChpZCwgZGVmZXJyZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUm9vbVYyLnByb3RvdHlwZS5fYWRkVHJhY2tSZWNlaXZlciA9IGZ1bmN0aW9uICh0cmFja1JlY2VpdmVyKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IHRoaXMuX2dldE9yQ3JlYXRlVHJhY2tSZWNlaXZlckRlZmVycmVkKHRyYWNrUmVjZWl2ZXIuaWQpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHRyYWNrUmVjZWl2ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUm9vbVYyLnByb3RvdHlwZS5fY3JlYXRlUmVtb3RlUGFydGljaXBhbnQgPSBmdW5jdGlvbiAocGFydGljaXBhbnRTdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgUmVtb3RlUGFydGljaXBhbnRWMiA9IHRoaXMuX1JlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW90ZVBhcnRpY2lwYW50VjIocGFydGljaXBhbnRTdGF0ZSwgZnVuY3Rpb24gKHRyYWNrU2lkKSB7IHJldHVybiBfdGhpcy5fZ2V0SW5pdGlhbFRyYWNrU3dpdGNoT2ZmU3RhdGUodHJhY2tTaWQpOyB9LCBmdW5jdGlvbiAodHJhY2tTaWQsIHByaW9yaXR5KSB7IHJldHVybiBfdGhpcy5fdHJhY2tQcmlvcml0eVNpZ25hbGluZy5zZW5kVHJhY2tQcmlvcml0eVVwZGF0ZSh0cmFja1NpZCwgJ3N1YnNjcmliZScsIHByaW9yaXR5KTsgfSwgZnVuY3Rpb24gKHRyYWNrU2lkLCBoaW50KSB7IHJldHVybiBfdGhpcy5fcmVuZGVySGludHNTaWduYWxpbmcuc2V0VHJhY2tIaW50KHRyYWNrU2lkLCBoaW50KTsgfSwgZnVuY3Rpb24gKHRyYWNrU2lkKSB7IHJldHVybiBfdGhpcy5fcmVuZGVySGludHNTaWduYWxpbmcuY2xlYXJUcmFja0hpbnQodHJhY2tTaWQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUm9vbVYyLnByb3RvdHlwZS5fZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB2YXIgZGlkRGlzY29ubmVjdCA9IF9zdXBlci5wcm90b3R5cGUuX2Rpc2Nvbm5lY3QuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgIGlmIChkaWREaXNjb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl90ZWFyZG93bk5ldHdvcmtRdWFsaXR5TW9uaXRvcigpO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uTWFuYWdlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgIHRyYWNrLnB1Ymxpc2hGYWlsZWQoZXJyb3IgfHwgbmV3IEVycm9yKCdMb2NhbFBhcnRpY2lwYW50IGRpc2Nvbm5lY3RlZCcpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkaWREaXNjb25uZWN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSb29tVjIucHJvdG90eXBlLl9nZXRUcmFja1JlY2VpdmVyID0gZnVuY3Rpb24gKGlkLCBpZE9yTWlkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpZE9yTWlkID09PSB2b2lkIDApIHsgaWRPck1pZCA9ICdpZCc7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlVHJhY2tSZWNlaXZlckRlZmVycmVkKGlkLCBpZE9yTWlkKS5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKHRyYWNrUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9kZWxldGVUcmFja1JlY2VpdmVyRGVmZXJyZWQoaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrUmVjZWl2ZXI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSb29tVjIucHJvdG90eXBlLl9nZXRJbml0aWFsVHJhY2tTd2l0Y2hPZmZTdGF0ZSA9IGZ1bmN0aW9uICh0cmFja1NpZCkge1xuICAgICAgICB2YXIgaW5pdGlhbGx5U3dpdGNoZWRPZmYgPSB0aGlzLl9wZW5kaW5nU3dpdGNoT2ZmU3RhdGVzLmdldCh0cmFja1NpZCkgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdTd2l0Y2hPZmZTdGF0ZXMuZGVsZXRlKHRyYWNrU2lkKTtcbiAgICAgICAgaWYgKGluaXRpYWxseVN3aXRjaGVkT2ZmKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIltcIiArIHRyYWNrU2lkICsgXCJdIHdhcyBpbml0aWFsbHkgc3dpdGNoZWQgb2ZmISBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluaXRpYWxseVN3aXRjaGVkT2ZmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSb29tVjIucHJvdG90eXBlLl9nZXRUcmFja1NpZHNUb1RyYWNrU2lnbmFsaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyYWNrU2lkc1RvVHJhY2tTaWduYWxpbmdzID0gZmxhdE1hcCh0aGlzLnBhcnRpY2lwYW50cywgZnVuY3Rpb24gKHBhcnRpY2lwYW50KSB7IHJldHVybiBBcnJheS5mcm9tKHBhcnRpY2lwYW50LnRyYWNrcyk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IE1hcCh0cmFja1NpZHNUb1RyYWNrU2lnbmFsaW5ncyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX2dldE9yQ3JlYXRlUmVtb3RlUGFydGljaXBhbnQgPSBmdW5jdGlvbiAocGFydGljaXBhbnRTdGF0ZSkge1xuICAgICAgICB2YXIgcGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQocGFydGljaXBhbnRTdGF0ZS5zaWQpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIHBhcnRpY2lwYW50ID0gdGhpcy5fY3JlYXRlUmVtb3RlUGFydGljaXBhbnQocGFydGljaXBhbnRTdGF0ZSk7XG4gICAgICAgICAgICBwYXJ0aWNpcGFudC5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gc3RhdGVDaGFuZ2VkKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudC5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJ0aWNpcGFudHMuZGVsZXRlKHBhcnRpY2lwYW50LnNpZCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2Rpc2Nvbm5lY3RlZFBhcnRpY2lwYW50UmV2aXNpb25zLnNldChwYXJ0aWNpcGFudC5zaWQsIHBhcnRpY2lwYW50LnJldmlzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFBhcnRpY2lwYW50KHBhcnRpY2lwYW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydGljaXBhbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX2dldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFydGljaXBhbnQ6IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5nZXRTdGF0ZSgpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAobG9jYWxQYXJ0aWNpcGFudCwgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLCB0cmFuc3BvcnQsIG9wdGlvbnMsIGluaXRpYWxTdGF0ZSkge1xuICAgICAgICB0aGlzLl9pbml0VHJhY2tTd2l0Y2hPZmZTaWduYWxpbmcoKTtcbiAgICAgICAgdGhpcy5faW5pdERvbWluYW50U3BlYWtlclNpZ25hbGluZygpO1xuICAgICAgICB0aGlzLl9pbml0TmV0d29ya1F1YWxpdHlNb25pdG9yU2lnbmFsaW5nKCk7XG4gICAgICAgIHRoaXMuX2luaXRQdWJsaXNoZXJIaW50U2lnbmFsaW5nKCk7XG4gICAgICAgIGhhbmRsZUxvY2FsUGFydGljaXBhbnRFdmVudHModGhpcywgbG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgICAgIGhhbmRsZVBlZXJDb25uZWN0aW9uRXZlbnRzKHRoaXMsIHBlZXJDb25uZWN0aW9uTWFuYWdlcik7XG4gICAgICAgIGhhbmRsZVRyYW5zcG9ydEV2ZW50cyh0aGlzLCB0cmFuc3BvcnQpO1xuICAgICAgICBwZXJpb2RpY2FsbHlQdWJsaXNoU3RhdHModGhpcywgdHJhbnNwb3J0LCBvcHRpb25zLnN0YXRzUHVibGlzaEludGVydmFsTXMpO1xuICAgICAgICB0aGlzLl91cGRhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbikgYWZ0ZXIgaW5pdGlhbCBzdGF0ZSB3ZSBjYW4gZmluZCBvdXQgaWYgd2UgYXJlIGNvbm5lY3RlZCB0byBhIFAyUCBvciBncm91cCByb29tIGJ5IGNoZWNraW5nIGlmIHRoZXJlIGlzIGEgbWVkaWFSZWdpb24uXG4gICAgICAgIC8vIGlmIHdlIGFyZSBub3QgY29ubmVjdGVkIHRvIGdyb3VwIHJvb20sIHR1cm4gb2ZmIGFkYXB0aXZlIHNpbXVsY2FzdC5cbiAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb25NYW5hZ2VyLnNldEVmZmVjdGl2ZUFkYXB0aXZlU2ltdWxjYXN0KCEhdGhpcy5tZWRpYVJlZ2lvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX21heWJlQWRkQmFuZHdpZHRoUHJvZmlsZSA9IGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LCBiYW5kd2lkdGhQcm9maWxlID0gX2EuYmFuZHdpZHRoUHJvZmlsZSwgYmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uID0gX2EuYmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uO1xuICAgICAgICBpZiAoYmFuZHdpZHRoUHJvZmlsZSAmJiB0aGlzLl9sYXN0QmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uIDwgYmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0QmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uID0gYmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIGJhbmR3aWR0aF9wcm9maWxlOiBjcmVhdGVCYW5kd2lkdGhQcm9maWxlUGF5bG9hZChiYW5kd2lkdGhQcm9maWxlKVxuICAgICAgICAgICAgfSwgdXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSb29tVjIucHJvdG90eXBlLl9wdWJsaXNoTmV3TG9jYWxQYXJ0aWNpcGFudFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQucHVibGlzaCh0aGlzLl9tYXliZUFkZEJhbmR3aWR0aFByb2ZpbGUodGhpcy5fZ2V0U3RhdGUoKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSb29tVjIucHJvdG90eXBlLl9wdWJsaXNoUGVlckNvbm5lY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChwZWVyQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgIC8qIGVzbGludCBjYW1lbGNhc2U6MCAqL1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQucHVibGlzaChPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHBlZXJfY29ubmVjdGlvbnM6IFtwZWVyQ29ubmVjdGlvblN0YXRlXVxuICAgICAgICB9LCB0aGlzLl9nZXRTdGF0ZSgpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChyb29tU3RhdGUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSByb29tU3RhdGUudHlwZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3Vic2NyaWJlZChyb29tU3RhdGUpO1xuICAgICAgICB0aGlzLl91cGRhdGVQYXJ0aWNpcGFudHMocm9vbVN0YXRlLCB0eXBlKTtcbiAgICAgICAgdGhpcy5faGFuZGxlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICB0aGlzLl91cGRhdGVQZWVyQ29ubmVjdGlvbnMocm9vbVN0YXRlLCB0eXBlKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlUmVjb3JkaW5nKHJvb21TdGF0ZSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVB1Ymxpc2hlZChyb29tU3RhdGUpO1xuICAgICAgICB0aGlzLl9jb25uZWN0TG9jYWxQYXJ0aWNpcGFudChyb29tU3RhdGUpO1xuICAgICAgICB0aGlzLl9zZXR1cE1lZGlhU2lnbmFsaW5ncyhyb29tU3RhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUm9vbVYyLnByb3RvdHlwZS5fY29ubmVjdExvY2FsUGFydGljaXBhbnQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHBhcnRpY2lwYW50ID0gX2EucGFydGljaXBhbnQ7XG4gICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2lkID0gcGFydGljaXBhbnQuc2lkLCBpZGVudGl0eSA9IHBhcnRpY2lwYW50LmlkZW50aXR5O1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuY29ubmVjdChzaWQsIGlkZW50aXR5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUm9vbVYyLnByb3RvdHlwZS5faGFuZGxlU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRyYWNrU2lkc1RvVHJhY2tTaWduYWxpbmdzID0gdGhpcy5fZ2V0VHJhY2tTaWRzVG9UcmFja1NpZ25hbGluZ3MoKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uRmFpbHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IsIHRyYWNrU2lkKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tTaWduYWxpbmcgPSB0cmFja1NpZHNUb1RyYWNrU2lnbmFsaW5ncy5nZXQodHJhY2tTaWQpO1xuICAgICAgICAgICAgaWYgKHRyYWNrU2lnbmFsaW5nKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvbkZhaWx1cmVzLmRlbGV0ZSh0cmFja1NpZCk7XG4gICAgICAgICAgICAgICAgdHJhY2tTaWduYWxpbmcuc3Vic2NyaWJlRmFpbGVkKGNyZWF0ZVR3aWxpb0Vycm9yKGVycm9yLmNvZGUsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRyYWNrU2lkc1RvVHJhY2tTaWduYWxpbmdzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrU2lnbmFsaW5nKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tJZCA9IF90aGlzLl9zdWJzY3JpYmVkLmdldCh0cmFja1NpZ25hbGluZy5zaWQpO1xuICAgICAgICAgICAgaWYgKCF0cmFja0lkIHx8ICh0cmFja1NpZ25hbGluZy5pc1N1YnNjcmliZWQgJiYgdHJhY2tTaWduYWxpbmcudHJhY2tUcmFuc2NlaXZlci5pZCAhPT0gdHJhY2tJZCkpIHtcbiAgICAgICAgICAgICAgICB0cmFja1NpZ25hbGluZy5zZXRUcmFja1RyYW5zY2VpdmVyKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYWNrSWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZ2V0VHJhY2tSZWNlaXZlcih0cmFja0lkKS50aGVuKGZ1bmN0aW9uICh0cmFja1JlY2VpdmVyKSB7IHJldHVybiB0cmFja1NpZ25hbGluZy5zZXRUcmFja1RyYW5zY2VpdmVyKHRyYWNrUmVjZWl2ZXIpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX3NldHVwTWVkaWFTaWduYWxpbmdzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBtZWRpYVNpZ25hbGluZ3MgPSBfYS5tZWRpYV9zaWduYWxpbmc7XG4gICAgICAgIHZhciBvdGhlck1lZGlhU2lnbmFsaW5ncyA9IHRoaXMuX3RyYWNrU3Vic2NyaXB0aW9uc1NpZ25hbGluZ1xuICAgICAgICAgICAgPyBbdGhpcy5fdHJhY2tTdWJzY3JpcHRpb25zU2lnbmFsaW5nXVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgW1xuICAgICAgICAgICAgdGhpcy5fZG9taW5hbnRTcGVha2VyU2lnbmFsaW5nLFxuICAgICAgICAgICAgdGhpcy5fbmV0d29ya1F1YWxpdHlTaWduYWxpbmcsXG4gICAgICAgICAgICB0aGlzLl90cmFja1ByaW9yaXR5U2lnbmFsaW5nLFxuICAgICAgICAgICAgdGhpcy5fdHJhY2tTd2l0Y2hPZmZTaWduYWxpbmcsXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJIaW50c1NpZ25hbGluZyxcbiAgICAgICAgICAgIHRoaXMuX3B1Ymxpc2hlckhpbnRzU2lnbmFsaW5nLFxuICAgICAgICBdLmNvbmNhdChvdGhlck1lZGlhU2lnbmFsaW5ncykuZm9yRWFjaChmdW5jdGlvbiAobWVkaWFTaWduYWxpbmcpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gbWVkaWFTaWduYWxpbmcuY2hhbm5lbDtcbiAgICAgICAgICAgIGlmICghbWVkaWFTaWduYWxpbmcuaXNTZXR1cFxuICAgICAgICAgICAgICAgICYmIG1lZGlhU2lnbmFsaW5nc1xuICAgICAgICAgICAgICAgICYmIG1lZGlhU2lnbmFsaW5nc1tjaGFubmVsXVxuICAgICAgICAgICAgICAgICYmIG1lZGlhU2lnbmFsaW5nc1tjaGFubmVsXS50cmFuc3BvcnRcbiAgICAgICAgICAgICAgICAmJiBtZWRpYVNpZ25hbGluZ3NbY2hhbm5lbF0udHJhbnNwb3J0LnR5cGUgPT09ICdkYXRhLWNoYW5uZWwnKSB7XG4gICAgICAgICAgICAgICAgbWVkaWFTaWduYWxpbmcuc2V0dXAobWVkaWFTaWduYWxpbmdzW2NoYW5uZWxdLnRyYW5zcG9ydC5sYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSb29tVjIucHJvdG90eXBlLl91cGRhdGVQYXJ0aWNpcGFudHMgPSBmdW5jdGlvbiAoX2EsIHJvb21TdGF0ZVR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9iID0gX2EucGFydGljaXBhbnRzLCBwYXJ0aWNpcGFudHMgPSBfYiA9PT0gdm9pZCAwID8gW10gOiBfYjtcbiAgICAgICAgdmFyIHBhcnRpY2lwYW50c1RvS2VlcCA9IG5ldyBTZXQoKTtcbiAgICAgICAgcGFydGljaXBhbnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnRpY2lwYW50U3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0aWNpcGFudFN0YXRlLnNpZCA9PT0gX3RoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBJZiB0aGUgaW5jb21pbmcgcmV2aXNpb24gZm9yIGEgZGlzY29ubmVjdGVkIFBhcnRpY2lwYW50IGlzIGxlc3MgdGhhbiBvclxuICAgICAgICAgICAgLy8gZXF1YWwgdG8gdGhlIHJldmlzaW9uIHdoZW4gaXQgd2FzIGRpc2Nvbm5lY3RlZCwgdGhlbiB0aGUgc3RhdGUgaXMgb2xkIGFuZCBjYW4gYmUgaWdub3JlZC5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIFBhcnRpY2lwYW50IHdhcyBtb3N0IGxpa2VseSBkaXNjb25uZWN0ZWQgaW4gYSBMYXJnZSBHcm91cCBSb29tIHdoZW4gaXRcbiAgICAgICAgICAgIC8vIHN0b3BwZWQgcHVibGlzaGluZyBtZWRpYSwgYW5kIGhlbmNlIG5lZWRzIHRvIGJlIHJlLWFkZGVkLlxuICAgICAgICAgICAgdmFyIGRpc2Nvbm5lY3RlZFBhcnRpY2lwYW50UmV2aXNpb24gPSBfdGhpcy5fZGlzY29ubmVjdGVkUGFydGljaXBhbnRSZXZpc2lvbnMuZ2V0KHBhcnRpY2lwYW50U3RhdGUuc2lkKTtcbiAgICAgICAgICAgIGlmIChkaXNjb25uZWN0ZWRQYXJ0aWNpcGFudFJldmlzaW9uICYmIHBhcnRpY2lwYW50U3RhdGUucmV2aXNpb24gPD0gZGlzY29ubmVjdGVkUGFydGljaXBhbnRSZXZpc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXNjb25uZWN0ZWRQYXJ0aWNpcGFudFJldmlzaW9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2Rpc2Nvbm5lY3RlZFBhcnRpY2lwYW50UmV2aXNpb25zLmRlbGV0ZShwYXJ0aWNpcGFudFN0YXRlLnNpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFydGljaXBhbnQgPSBfdGhpcy5fZ2V0T3JDcmVhdGVSZW1vdGVQYXJ0aWNpcGFudChwYXJ0aWNpcGFudFN0YXRlKTtcbiAgICAgICAgICAgIHBhcnRpY2lwYW50LnVwZGF0ZShwYXJ0aWNpcGFudFN0YXRlKTtcbiAgICAgICAgICAgIHBhcnRpY2lwYW50c1RvS2VlcC5hZGQocGFydGljaXBhbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJvb21TdGF0ZVR5cGUgPT09ICdzeW5jZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2lwYW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgICAgIGlmICghcGFydGljaXBhbnRzVG9LZWVwLmhhcyhwYXJ0aWNpcGFudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX3VwZGF0ZVBlZXJDb25uZWN0aW9ucyA9IGZ1bmN0aW9uIChfYSwgcm9vbVN0YXRlVHlwZSkge1xuICAgICAgICB2YXIgcGVlckNvbm5lY3Rpb25zID0gX2EucGVlcl9jb25uZWN0aW9ucztcbiAgICAgICAgaWYgKHBlZXJDb25uZWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb25NYW5hZ2VyLnVwZGF0ZShwZWVyQ29ubmVjdGlvbnMsIHJvb21TdGF0ZVR5cGUgPT09ICdzeW5jZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSb29tVjIucHJvdG90eXBlLl91cGRhdGVSZWNvcmRpbmcgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHJlY29yZGluZyA9IF9hLnJlY29yZGluZztcbiAgICAgICAgaWYgKHJlY29yZGluZykge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRpbmcudXBkYXRlKHJlY29yZGluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUm9vbVYyLnByb3RvdHlwZS5fdXBkYXRlUHVibGlzaGVkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwdWJsaXNoZWQgPSBfYS5wdWJsaXNoZWQ7XG4gICAgICAgIGlmICghcHVibGlzaGVkIHx8IHB1Ymxpc2hlZC5yZXZpc2lvbiA8PSB0aGlzLl9wdWJsaXNoZWRSZXZpc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3B1Ymxpc2hlZFJldmlzaW9uID0gcHVibGlzaGVkLnJldmlzaW9uO1xuICAgICAgICBwdWJsaXNoZWQudHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICBpZiAodHJhY2suc2lkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlZC5zZXQodHJhY2suaWQsIHRyYWNrLnNpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlKHB1Ymxpc2hlZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX3VwZGF0ZVN1YnNjcmliZWQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN1YnNjcmliZWQgPSBfYS5zdWJzY3JpYmVkO1xuICAgICAgICBpZiAoIXN1YnNjcmliZWQgfHwgc3Vic2NyaWJlZC5yZXZpc2lvbiA8PSB0aGlzLl9zdWJzY3JpYmVkUmV2aXNpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdWJzY3JpYmVkUmV2aXNpb24gPSBzdWJzY3JpYmVkLnJldmlzaW9uO1xuICAgICAgICBzdWJzY3JpYmVkLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja1N0YXRlKSB7XG4gICAgICAgICAgICBpZiAodHJhY2tTdGF0ZS5pZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25GYWlsdXJlcy5kZWxldGUodHJhY2tTdGF0ZS5zaWQpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpYmVkLnNldCh0cmFja1N0YXRlLnNpZCwgdHJhY2tTdGF0ZS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0cmFja1N0YXRlLmVycm9yICYmICFfdGhpcy5fc3Vic2NyaXB0aW9uRmFpbHVyZXMuaGFzKHRyYWNrU3RhdGUuc2lkKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25GYWlsdXJlcy5zZXQodHJhY2tTdGF0ZS5zaWQsIHRyYWNrU3RhdGUuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN1YnNjcmliZWRUcmFja1NpZHMgPSBuZXcgU2V0KHN1YnNjcmliZWQudHJhY2tzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh0cmFja1N0YXRlKSB7IHJldHVybiAhIXRyYWNrU3RhdGUuaWQ7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0cmFja1N0YXRlKSB7IHJldHVybiB0cmFja1N0YXRlLnNpZDsgfSkpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVkLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrSWQsIHRyYWNrU2lkKSB7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmliZWRUcmFja1NpZHMuaGFzKHRyYWNrU2lkKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpYmVkLmRlbGV0ZSh0cmFja1NpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUm9vbVYyLnByb3RvdHlwZS5faW5pdFB1Ymxpc2hlckhpbnRTaWduYWxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3B1Ymxpc2hlckhpbnRzU2lnbmFsaW5nLm9uKCd1cGRhdGVkJywgZnVuY3Rpb24gKGhpbnRzLCBpZCkge1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwoaGludHMubWFwKGZ1bmN0aW9uIChoaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0UHVibGlzaGVySGludChoaW50LnRyYWNrLCBoaW50LmVuY29kaW5ncykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHRyYWNrOiBoaW50LnRyYWNrLCByZXN1bHQ6IHJlc3VsdCB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKGhpbnRSZXNwb25zZXMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHVibGlzaGVySGludHNTaWduYWxpbmcuc2VuZEhpbnRSZXNwb25zZSh7IGlkOiBpZCwgaGludHM6IGhpbnRSZXNwb25zZXMgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBoYW5kbGVSZXBsYWNlZCA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgICAgICB0cmFjay50cmFja1RyYW5zY2VpdmVyLm9uKCdyZXBsYWNlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlckhpbnRzU2lnbmFsaW5nLnNlbmRUcmFja1JlcGxhY2VkKHsgdHJhY2tTaWQ6IHRyYWNrLnNpZCB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gaG9vayB1cCBmb3IgYW55IGV4aXN0aW5nIGFuZCBuZXcgdHJhY2tzIGdldHRpbmcgcmVwbGFjZWQuXG4gICAgICAgIEFycmF5LmZyb20odGhpcy5sb2NhbFBhcnRpY2lwYW50LnRyYWNrcy52YWx1ZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHsgcmV0dXJuIGhhbmRsZVJlcGxhY2VkKHRyYWNrKTsgfSk7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5vbigndHJhY2tBZGRlZCcsIGZ1bmN0aW9uICh0cmFjaykgeyByZXR1cm4gaGFuZGxlUmVwbGFjZWQodHJhY2spOyB9KTtcbiAgICB9O1xuICAgIFJvb21WMi5wcm90b3R5cGUuX2luaXRUcmFja1N3aXRjaE9mZlNpZ25hbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdHJhY2tTd2l0Y2hPZmZTaWduYWxpbmcub24oJ3VwZGF0ZWQnLCBmdW5jdGlvbiAodHJhY2tzT2ZmLCB0cmFja3NPbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKCdyZWNlaXZlZCB0cmFja1N3aXRjaDogJywgeyB0cmFja3NPbjogdHJhY2tzT24sIHRyYWNrc09mZjogdHJhY2tzT2ZmIH0pO1xuICAgICAgICAgICAgICAgIHZhciB0cmFja1VwZGF0ZXNfMSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB0cmFja3NPbi5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja1NpZCkgeyByZXR1cm4gdHJhY2tVcGRhdGVzXzEuc2V0KHRyYWNrU2lkLCB0cnVlKTsgfSk7XG4gICAgICAgICAgICAgICAgdHJhY2tzT2ZmLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrU2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja1VwZGF0ZXNfMS5nZXQodHJhY2tTaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogVGhpcyBtZWFucyB0aGF0IFZJREVPLTM3NjIgaGFzIGJlZW4gcmVwcm9kdWNlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cud2Fybih0cmFja1NpZCArIFwiIGlzIERVUExJQ0FURUQgaW4gYm90aCB0cmFja3NPZmYgYW5kIHRyYWNrc09uIGxpc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJhY2tVcGRhdGVzXzEuc2V0KHRyYWNrU2lkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMucGFydGljaXBhbnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50LnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzT24gPSB0cmFja1VwZGF0ZXNfMS5nZXQodHJhY2suc2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXNPbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5zZXRTd2l0Y2hlZE9mZighaXNPbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tVcGRhdGVzXzEuZGVsZXRlKHRyYWNrLnNpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBDYWNoZSBhbnkgbm90aWZpY2F0aW9uIGFib3V0IHRoZSB0cmFja3MgdGhhdCB3ZSBkbyBub3QgeWV0IGtub3cgYWJvdXQuXG4gICAgICAgICAgICAgICAgdHJhY2tVcGRhdGVzXzEuZm9yRWFjaChmdW5jdGlvbiAoaXNPbiwgdHJhY2tTaWQpIHsgcmV0dXJuIF90aGlzLl9wZW5kaW5nU3dpdGNoT2ZmU3RhdGVzLnNldCh0cmFja1NpZCwgIWlzT24pOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZXJyb3IoJ2Vycm9yIHByb2Nlc3NpbmcgdHJhY2sgc3dpdGNoIG9mZjonLCBleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUm9vbVYyLnByb3RvdHlwZS5faW5pdERvbWluYW50U3BlYWtlclNpZ25hbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZG9taW5hbnRTcGVha2VyU2lnbmFsaW5nLm9uKCd1cGRhdGVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2V0RG9taW5hbnRTcGVha2VyKF90aGlzLl9kb21pbmFudFNwZWFrZXJTaWduYWxpbmcubG91ZGVzdFBhcnRpY2lwYW50U2lkKTsgfSk7XG4gICAgfTtcbiAgICBSb29tVjIucHJvdG90eXBlLl9pbml0TmV0d29ya1F1YWxpdHlNb25pdG9yU2lnbmFsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9uZXR3b3JrUXVhbGl0eVNpZ25hbGluZy5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV0d29ya1F1YWxpdHlNb25pdG9yID0gbmV3IF90aGlzLl9OZXR3b3JrUXVhbGl0eU1vbml0b3IoX3RoaXMuX3BlZXJDb25uZWN0aW9uTWFuYWdlciwgX3RoaXMuX25ldHdvcmtRdWFsaXR5U2lnbmFsaW5nKTtcbiAgICAgICAgICAgIF90aGlzLl9uZXR3b3JrUXVhbGl0eU1vbml0b3IgPSBuZXR3b3JrUXVhbGl0eU1vbml0b3I7XG4gICAgICAgICAgICBuZXR3b3JrUXVhbGl0eU1vbml0b3Iub24oJ3VwZGF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldE5ldHdvcmtRdWFsaXR5TGV2ZWwobmV0d29ya1F1YWxpdHlNb25pdG9yLmxldmVsLCBuZXR3b3JrUXVhbGl0eU1vbml0b3IubGV2ZWxzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJ0aWNpcGFudHMuZm9yRWFjaChmdW5jdGlvbiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxldmVscyA9IG5ldHdvcmtRdWFsaXR5TW9uaXRvci5yZW1vdGVMZXZlbHMuZ2V0KHBhcnRpY2lwYW50LnNpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZXZlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50LnNldE5ldHdvcmtRdWFsaXR5TGV2ZWwobGV2ZWxzLmxldmVsLCBsZXZlbHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5ldHdvcmtRdWFsaXR5TW9uaXRvci5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbmV0d29ya1F1YWxpdHlTaWduYWxpbmcub24oJ3RlYXJkb3duJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3RlYXJkb3duTmV0d29ya1F1YWxpdHlNb25pdG9yKCk7IH0pO1xuICAgIH07XG4gICAgUm9vbVYyLnByb3RvdHlwZS5fdGVhcmRvd25OZXR3b3JrUXVhbGl0eU1vbml0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9uZXR3b3JrUXVhbGl0eU1vbml0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX25ldHdvcmtRdWFsaXR5TW9uaXRvci5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9uZXR3b3JrUXVhbGl0eU1vbml0b3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHtAbGluayBSb29tVjJ9J3MgbWVkaWEgc3RhdGlzdGljcy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48TWFwPFBlZXJDb25uZWN0aW9uVjIjaWQsIFN0YW5kYXJkaXplZFN0YXRzUmVzcG9uc2U+Pn1cbiAgICAgKi9cbiAgICBSb29tVjIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb25NYW5hZ2VyLmdldFN0YXRzKCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcChBcnJheS5mcm9tKHJlc3BvbnNlcykubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIGlkID0gX2JbMF0sIHJlc3BvbnNlID0gX2JbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtpZCwgT2JqZWN0LmFzc2lnbih7fSwgcmVzcG9uc2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQXVkaW9UcmFja1N0YXRzOiBmaWx0ZXJBbmRBZGRMb2NhbFRyYWNrU2lkcyhfdGhpcywgcmVzcG9uc2UubG9jYWxBdWRpb1RyYWNrU3RhdHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxWaWRlb1RyYWNrU3RhdHM6IGZpbHRlckFuZEFkZExvY2FsVHJhY2tTaWRzKF90aGlzLCByZXNwb25zZS5sb2NhbFZpZGVvVHJhY2tTdGF0cyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVBdWRpb1RyYWNrU3RhdHM6IGZpbHRlckFuZEFkZFJlbW90ZVRyYWNrU2lkcyhfdGhpcywgcmVzcG9uc2UucmVtb3RlQXVkaW9UcmFja1N0YXRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZVZpZGVvVHJhY2tTdGF0czogZmlsdGVyQW5kQWRkUmVtb3RlVHJhY2tTaWRzKF90aGlzLCByZXNwb25zZS5yZW1vdGVWaWRlb1RyYWNrU3RhdHMpXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUm9vbVYyO1xufShSb29tU2lnbmFsaW5nKSk7XG4vKipcbiAqIEZpbHRlciBvdXQge0BsaW5rIFRyYWNrU3RhdHN9IHRoYXQgYXJlbid0IGluIHRoZSBjb2xsZWN0aW9uIHdoaWxlIGFsc29cbiAqIHN0YW1waW5nIHRoZWlyIFRyYWNrIFNJRHMuXG4gKiBAcGFyYW0ge01hcDxJRCwgU0lEPn0gaWRUb1NpZFxuICogQHBhcmFtIHtBcnJheTxUcmFja1N0YXRzPn0gdHJhY2tTdGF0c1xuICogQHJldHVybnMge0FycmF5PFRyYWNrU3RhdHM+fVxuICovXG5mdW5jdGlvbiBmaWx0ZXJBbmRBZGRUcmFja1NpZHMoaWRUb1NpZCwgdHJhY2tTdGF0cykge1xuICAgIHJldHVybiB0cmFja1N0YXRzLnJlZHVjZShmdW5jdGlvbiAodHJhY2tTdGF0cywgdHJhY2tTdGF0KSB7XG4gICAgICAgIHZhciB0cmFja1NpZCA9IGlkVG9TaWQuZ2V0KHRyYWNrU3RhdC50cmFja0lkKTtcbiAgICAgICAgcmV0dXJuIHRyYWNrU2lkXG4gICAgICAgICAgICA/IFtPYmplY3QuYXNzaWduKHt9LCB0cmFja1N0YXQsIHsgdHJhY2tTaWQ6IHRyYWNrU2lkIH0pXS5jb25jYXQodHJhY2tTdGF0cylcbiAgICAgICAgICAgIDogdHJhY2tTdGF0cztcbiAgICB9LCBbXSk7XG59XG4vKipcbiAqIEZpbHRlciBvdXQge0BsaW5rIExvY2FsVHJhY2tTdGF0c30gdGhhdCBhcmVuJ3QgY3VycmVudGx5IHB1Ymxpc2hlZCB3aGlsZSBhbHNvXG4gKiBzdGFtcGluZyB0aGVpciBUcmFjayBTSURzLlxuICogQHBhcmFtIHtSb29tVjJ9IHJvb21WMlxuICogQHBhcmFtIHtBcnJheTxMb2NhbFRyYWNrU3RhdHM+fSBsb2NhbFRyYWNrU3RhdHNcbiAqIEByZXR1cm5zIHtBcnJheTxMb2NhbFRyYWNrU3RhdHM+fVxuICovXG5mdW5jdGlvbiBmaWx0ZXJBbmRBZGRMb2NhbFRyYWNrU2lkcyhyb29tVjIsIGxvY2FsVHJhY2tTdGF0cykge1xuICAgIHJldHVybiBmaWx0ZXJBbmRBZGRUcmFja1NpZHMocm9vbVYyLl9wdWJsaXNoZWQsIGxvY2FsVHJhY2tTdGF0cyk7XG59XG4vKipcbiAqIEZpbHRlciBvdXQge0BsaW5rIFJlbW90ZVRyYWNrU3RhdHN9IHRoYXQgYXJlbid0IGN1cnJlbnRseSBzdWJzY3JpYmVkIHdoaWxlXG4gKiBhbHNvIHN0YW1waW5nIHRoZWlyIFRyYWNrIFNJRHMuXG4gKiBAcGFyYW0ge1Jvb21WMn0gcm9vbVYyXG4gKiBAcGFyYW0ge0FycmF5PFJlbW90ZVRyYWNrU3RhdHM+fSByZW1vdGVUcmFja1N0YXRzXG4gKiBAcmV0dXJucyB7QXJyYXk8UmVtb3RlVHJhY2tTdGF0cz59XG4gKi9cbmZ1bmN0aW9uIGZpbHRlckFuZEFkZFJlbW90ZVRyYWNrU2lkcyhyb29tVjIsIHJlbW90ZVRyYWNrU3RhdHMpIHtcbiAgICB2YXIgaWRUb1NpZCA9IG5ldyBNYXAoQXJyYXkuZnJvbShyb29tVjIuX3N1YnNjcmliZWQuZW50cmllcygpKS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHNpZCA9IF9iWzBdLCBpZCA9IF9iWzFdO1xuICAgICAgICByZXR1cm4gW2lkLCBzaWRdO1xuICAgIH0pKTtcbiAgICByZXR1cm4gZmlsdGVyQW5kQWRkVHJhY2tTaWRzKGlkVG9TaWQsIHJlbW90ZVRyYWNrU3RhdHMpO1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBSb29tVjIjUmVwcmVzZW50YXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge0xvY2FsUGFydGljaXBhbnRWMiNSZXByZXNlbnRhdGlvbn0gcGFydGljaXBhbnRcbiAqIEBwcm9wZXJ0eSB7P0FycmF5PFJlbW90ZVBhcnRpY2lwYW50VjIjUmVwcmVzZW50YXRpb24+fSBwYXJ0aWNpcGFudHNcbiAqIEBwcm9wZXJ0eSB7P0FycmF5PFBlZXJDb25uZWN0aW9uVjIjUmVwcmVzZW50YXRpb24+fSBwZWVyX2Nvbm5lY3Rpb25zXG4gKiBAcHJvcGVydHkgez9SZWNvcmRpbmdWMiNSZXByZXNlbnRhdGlvbn0gcmVjb3JkaW5nXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2lkXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUxvY2FsUGFydGljaXBhbnRFdmVudHMocm9vbVYyLCBsb2NhbFBhcnRpY2lwYW50KSB7XG4gICAgdmFyIGxvY2FsUGFydGljaXBhbnRVcGRhdGVkID0gb25jZVBlclRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICByb29tVjIuX3B1Ymxpc2hOZXdMb2NhbFBhcnRpY2lwYW50U3RhdGUoKTtcbiAgICB9KTtcbiAgICB2YXIgcmVuZWdvdGlhdGUgPSBvbmNlUGVyVGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmFja1NlbmRlcnMgPSBmbGF0TWFwKGxvY2FsUGFydGljaXBhbnQudHJhY2tzLCBmdW5jdGlvbiAodHJhY2tWMikgeyByZXR1cm4gdHJhY2tWMi50cmFja1RyYW5zY2VpdmVyOyB9KTtcbiAgICAgICAgcm9vbVYyLl9wZWVyQ29ubmVjdGlvbk1hbmFnZXIuc2V0VHJhY2tTZW5kZXJzKHRyYWNrU2VuZGVycyk7XG4gICAgfSk7XG4gICAgbG9jYWxQYXJ0aWNpcGFudC5vbigndHJhY2tBZGRlZCcsIHJlbmVnb3RpYXRlKTtcbiAgICBsb2NhbFBhcnRpY2lwYW50Lm9uKCd0cmFja1JlbW92ZWQnLCByZW5lZ290aWF0ZSk7XG4gICAgbG9jYWxQYXJ0aWNpcGFudC5vbigndXBkYXRlZCcsIGxvY2FsUGFydGljaXBhbnRVcGRhdGVkKTtcbiAgICByb29tVjIub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICBsb2NhbFBhcnRpY2lwYW50LnJlbW92ZUxpc3RlbmVyKCd0cmFja0FkZGVkJywgcmVuZWdvdGlhdGUpO1xuICAgICAgICAgICAgbG9jYWxQYXJ0aWNpcGFudC5yZW1vdmVMaXN0ZW5lcigndHJhY2tSZW1vdmVkJywgcmVuZWdvdGlhdGUpO1xuICAgICAgICAgICAgbG9jYWxQYXJ0aWNpcGFudC5yZW1vdmVMaXN0ZW5lcigndXBkYXRlZCcsIGxvY2FsUGFydGljaXBhbnRVcGRhdGVkKTtcbiAgICAgICAgICAgIHJvb21WMi5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgICAgIGxvY2FsUGFydGljaXBhbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcm9vbVYyLm9uKCdzaWduYWxpbmdDb25uZWN0aW9uU3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9jYWxQYXJ0aWNpcGFudCA9IHJvb21WMi5sb2NhbFBhcnRpY2lwYW50LCBzaWduYWxpbmdDb25uZWN0aW9uU3RhdGUgPSByb29tVjIuc2lnbmFsaW5nQ29ubmVjdGlvblN0YXRlO1xuICAgICAgICB2YXIgaWRlbnRpdHkgPSBsb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5LCBzaWQgPSBsb2NhbFBhcnRpY2lwYW50LnNpZDtcbiAgICAgICAgc3dpdGNoIChzaWduYWxpbmdDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgbG9jYWxQYXJ0aWNpcGFudC5jb25uZWN0KHNpZCwgaWRlbnRpdHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICBsb2NhbFBhcnRpY2lwYW50LnJlY29ubmVjdGluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVQZWVyQ29ubmVjdGlvbkV2ZW50cyhyb29tVjIsIHBlZXJDb25uZWN0aW9uTWFuYWdlcikge1xuICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5vbignZGVzY3JpcHRpb24nLCBmdW5jdGlvbiBvbkRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJvb21WMi5fcHVibGlzaFBlZXJDb25uZWN0aW9uU3RhdGUoZGVzY3JpcHRpb24pO1xuICAgIH0pO1xuICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5kZXF1ZXVlKCdkZXNjcmlwdGlvbicpO1xuICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5vbignY2FuZGlkYXRlcycsIGZ1bmN0aW9uIG9uQ2FuZGlkYXRlcyhjYW5kaWRhdGVzKSB7XG4gICAgICAgIHJvb21WMi5fcHVibGlzaFBlZXJDb25uZWN0aW9uU3RhdGUoY2FuZGlkYXRlcyk7XG4gICAgfSk7XG4gICAgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLmRlcXVldWUoJ2NhbmRpZGF0ZXMnKTtcbiAgICBwZWVyQ29ubmVjdGlvbk1hbmFnZXIub24oJ3RyYWNrQWRkZWQnLCByb29tVjIuX2FkZFRyYWNrUmVjZWl2ZXIuYmluZChyb29tVjIpKTtcbiAgICBwZWVyQ29ubmVjdGlvbk1hbmFnZXIuZGVxdWV1ZSgndHJhY2tBZGRlZCcpO1xuICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFja1JlY2VpdmVycygpLmZvckVhY2gocm9vbVYyLl9hZGRUcmFja1JlY2VpdmVyLCByb29tVjIpO1xuICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5vbignY29ubmVjdGlvblN0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vbVYyLmVtaXQoJ2Nvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnKTtcbiAgICB9KTtcbiAgICBwZWVyQ29ubmVjdGlvbk1hbmFnZXIub24oJ2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb21WMi5lbWl0KCdpY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkJyk7XG4gICAgICAgIGlmIChyb29tVjIuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgaWYgKHJvb21WMi5sb2NhbFBhcnRpY2lwYW50Lm5ldHdvcmtRdWFsaXR5TGV2ZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByb29tVjIubG9jYWxQYXJ0aWNpcGFudC5zZXROZXR3b3JrUXVhbGl0eUxldmVsKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vbVYyLnBhcnRpY2lwYW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWNpcGFudC5uZXR3b3JrUXVhbGl0eUxldmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50LnNldE5ldHdvcmtRdWFsaXR5TGV2ZWwoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVRyYW5zcG9ydEV2ZW50cyhyb29tVjIsIHRyYW5zcG9ydCkge1xuICAgIHRyYW5zcG9ydC5vbignbWVzc2FnZScsIHJvb21WMi5fdXBkYXRlLmJpbmQocm9vbVYyKSk7XG4gICAgdHJhbnNwb3J0Lm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBzdGF0ZUNoYW5nZWQoc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIGlmIChyb29tVjIuc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgcm9vbVYyLl9kaXNjb25uZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgfVxuICAgICAgICByb29tVjIuZW1pdCgnc2lnbmFsaW5nQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCcpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBQZXJpb2RpY2FsbHkgcHVibGlzaCB7QGxpbmsgU3RhdHNSZXBvcnR9cy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1Jvb21WMn0gcm9vbVYyXG4gKiBAcGFyYW0ge1RyYW5zcG9ydH0gdHJhbnNwb3J0XG4gKiBAcGFyYW0ge051bWJlcn0gaW50ZXJ2YWxNc1xuICovXG5mdW5jdGlvbiBwZXJpb2RpY2FsbHlQdWJsaXNoU3RhdHMocm9vbVYyLCB0cmFuc3BvcnQsIGludGVydmFsTXMpIHtcbiAgICB2YXIgbW92aW5nQXZlcmFnZURlbHRhcyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgb2RkUHVibGlzaENvdW50ID0gZmFsc2U7XG4gICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICByb29tVjIuZ2V0U3RhdHMoKS50aGVuKGZ1bmN0aW9uIChzdGF0cykge1xuICAgICAgICAgICAgb2RkUHVibGlzaENvdW50ID0gIW9kZFB1Ymxpc2hDb3VudDtcbiAgICAgICAgICAgIHN0YXRzLmZvckVhY2goZnVuY3Rpb24gKHJlc3BvbnNlLCBpZCkge1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IEEgU3RhdHNSZXBvcnQgaXMgdXNlZCB0byBwdWJsaXNoIGEgXCJzdGF0cy1yZXBvcnRcIlxuICAgICAgICAgICAgICAgIC8vIGV2ZW50IGluc3RlYWQgb2YgdXNpbmcgU3RhbmRhcmRpemVkU3RhdHNSZXNwb25zZSBkaXJlY3RseSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gU3RhdHNSZXBvcnQgd2lsbCBhZGQgemVyb3MgdG8gcHJvcGVydGllcyB0aGF0IGRvIG5vdCBleGlzdC5cbiAgICAgICAgICAgICAgICB2YXIgcmVwb3J0ID0gbmV3IFN0YXRzUmVwb3J0KGlkLCByZXNwb25zZSwgdHJ1ZSAvKiBwcmVwYXJlRm9ySW5zaWdodHMgKi8pO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFNpbmNlIEEvViBzeW5jIG1ldHJpY3MgYXJlIG5vdCBwYXJ0IG9mIHRoZSBTdGF0c1JlcG9ydCBjbGFzcyxcbiAgICAgICAgICAgICAgICAvLyB3ZSBhZGQgdGhlbSB0byB0aGUgaW5zaWdodHMgcGF5bG9hZCBoZXJlLlxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5wdWJsaXNoRXZlbnQoJ3F1YWxpdHknLCAnc3RhdHMtcmVwb3J0JywgJ2luZm8nLCB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2tTdGF0czogcmVwb3J0LnJlbW90ZUF1ZGlvVHJhY2tTdGF0cy5tYXAoZnVuY3Rpb24gKHRyYWNrU3RhdCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZEFWU3luY01ldHJpY3NUb1JlbW90ZVRyYWNrU3RhdHModHJhY2tTdGF0LCByZXNwb25zZS5yZW1vdGVBdWRpb1RyYWNrU3RhdHNbaV0sIG1vdmluZ0F2ZXJhZ2VEZWx0YXMpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxBdWRpb1RyYWNrU3RhdHM6IHJlcG9ydC5sb2NhbEF1ZGlvVHJhY2tTdGF0cy5tYXAoZnVuY3Rpb24gKHRyYWNrU3RhdCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZEFWU3luY01ldHJpY3NUb0xvY2FsVHJhY2tTdGF0cyh0cmFja1N0YXQsIHJlc3BvbnNlLmxvY2FsQXVkaW9UcmFja1N0YXRzW2ldLCBtb3ZpbmdBdmVyYWdlRGVsdGFzKTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsVmlkZW9UcmFja1N0YXRzOiByZXBvcnQubG9jYWxWaWRlb1RyYWNrU3RhdHMubWFwKGZ1bmN0aW9uICh0cmFja1N0YXQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRBVlN5bmNNZXRyaWNzVG9Mb2NhbFRyYWNrU3RhdHModHJhY2tTdGF0LCByZXNwb25zZS5sb2NhbFZpZGVvVHJhY2tTdGF0c1tpXSwgbW92aW5nQXZlcmFnZURlbHRhcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBwZWVyQ29ubmVjdGlvbklkOiByZXBvcnQucGVlckNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9UcmFja1N0YXRzOiByZXBvcnQucmVtb3RlVmlkZW9UcmFja1N0YXRzLm1hcChmdW5jdGlvbiAodHJhY2tTdGF0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkQVZTeW5jTWV0cmljc1RvUmVtb3RlVHJhY2tTdGF0cyh0cmFja1N0YXQsIHJlc3BvbnNlLnJlbW90ZVZpZGVvVHJhY2tTdGF0c1tpXSwgbW92aW5nQXZlcmFnZURlbHRhcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IENsZWFuIHVwIGVudHJpZXMgZm9yIFRyYWNrcyB0aGF0IGFyZSBubyBsb25nZXIgcHVibGlzaGVkIG9yIHN1YnNjcmliZWQgdG8uXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBmbGF0TWFwKFtcbiAgICAgICAgICAgICAgICAgICAgJ2xvY2FsQXVkaW9UcmFja1N0YXRzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2xvY2FsVmlkZW9UcmFja1N0YXRzJyxcbiAgICAgICAgICAgICAgICAgICAgJ3JlbW90ZUF1ZGlvVHJhY2tTdGF0cycsXG4gICAgICAgICAgICAgICAgICAgICdyZW1vdGVWaWRlb1RyYWNrU3RhdHMnXG4gICAgICAgICAgICAgICAgXSwgZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHJlcG9ydFtwcm9wXS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzc3JjID0gX2Euc3NyYywgdHJhY2tTaWQgPSBfYS50cmFja1NpZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNrU2lkICsgXCIrXCIgKyBzc3JjO1xuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbW92aW5nQXZlcmFnZURlbHRhS2V5c1RvQmVSZW1vdmVkID0gZGlmZmVyZW5jZShBcnJheS5mcm9tKG1vdmluZ0F2ZXJhZ2VEZWx0YXMua2V5cygpKSwga2V5cyk7XG4gICAgICAgICAgICAgICAgbW92aW5nQXZlcmFnZURlbHRhS2V5c1RvQmVSZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbW92aW5nQXZlcmFnZURlbHRhcy5kZWxldGUoa2V5KTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG9kZFB1Ymxpc2hDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBudWxsIHByb3BlcnRpZXMgb2YgdGhlIFwiYWN0aXZlLWljZS1jYW5kaWRhdGUtcGFpclwiXG4gICAgICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgYXJlIGFzc2lnbmVkIGRlZmF1bHQgdmFsdWVzIHVudGlsIHRoZSBJbnNpZ2h0cyBnYXRld2F5XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY2VwdHMgbnVsbCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVJY2VDYW5kaWRhdGVQYWlyID0gcmVwbGFjZU51bGxzV2l0aERlZmF1bHRzKHJlc3BvbnNlLmFjdGl2ZUljZUNhbmRpZGF0ZVBhaXIsIHJlcG9ydC5wZWVyQ29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnB1Ymxpc2hFdmVudCgncXVhbGl0eScsICdhY3RpdmUtaWNlLWNhbmRpZGF0ZS1wYWlyJywgJ2luZm8nLCBhY3RpdmVJY2VDYW5kaWRhdGVQYWlyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgfSk7XG4gICAgfSwgaW50ZXJ2YWxNcyk7XG4gICAgcm9vbVYyLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBvblN0YXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgIHJvb21WMi5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgb25TdGF0ZUNoYW5nZWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIE5PVEUobW1hbGF2YWxsaSk6IFNpbmNlIEEvViBzeW5jIG1ldHJpY3MgYXJlIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgU3RhdHNSZXBvcnQgY2xhc3MsIHdlIGFkZCB0aGVtXG4gKiBvbmx5IGZvciByZXBvcnRpbmcgcHVycG9zZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRBVlN5bmNNZXRyaWNzVG9Mb2NhbFRyYWNrU3RhdHModHJhY2tTdGF0cywgdHJhY2tSZXNwb25zZSwgbW92aW5nQXZlcmFnZURlbHRhcykge1xuICAgIHZhciBmcmFtZXNFbmNvZGVkID0gdHJhY2tSZXNwb25zZS5mcmFtZXNFbmNvZGVkLCBwYWNrZXRzU2VudCA9IHRyYWNrUmVzcG9uc2UucGFja2V0c1NlbnQsIHRvdGFsRW5jb2RlVGltZSA9IHRyYWNrUmVzcG9uc2UudG90YWxFbmNvZGVUaW1lLCB0b3RhbFBhY2tldFNlbmREZWxheSA9IHRyYWNrUmVzcG9uc2UudG90YWxQYWNrZXRTZW5kRGVsYXk7XG4gICAgdmFyIGF1Z21lbnRlZFRyYWNrU3RhdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0cmFja1N0YXRzKTtcbiAgICB2YXIga2V5ID0gdHJhY2tTdGF0cy50cmFja1NpZCArIFwiK1wiICsgdHJhY2tTdGF0cy5zc3JjO1xuICAgIHZhciB0cmFja01vdmluZ0F2ZXJhZ2VEZWx0YXMgPSBtb3ZpbmdBdmVyYWdlRGVsdGFzLmdldChrZXkpIHx8IG5ldyBNYXAoKTtcbiAgICBpZiAodHlwZW9mIHRvdGFsRW5jb2RlVGltZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGZyYW1lc0VuY29kZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciB0cmFja0F2Z0VuY29kZURlbGF5TW92aW5nQXZlcmFnZURlbHRhID0gdHJhY2tNb3ZpbmdBdmVyYWdlRGVsdGFzLmdldCgnYXZnRW5jb2RlRGVsYXknKVxuICAgICAgICAgICAgfHwgbmV3IE1vdmluZ0F2ZXJhZ2VEZWx0YSgpO1xuICAgICAgICB0cmFja0F2Z0VuY29kZURlbGF5TW92aW5nQXZlcmFnZURlbHRhLnB1dFNhbXBsZSh0b3RhbEVuY29kZVRpbWUgKiAxMDAwLCBmcmFtZXNFbmNvZGVkKTtcbiAgICAgICAgYXVnbWVudGVkVHJhY2tTdGF0cy5hdmdFbmNvZGVEZWxheSA9IE1hdGgucm91bmQodHJhY2tBdmdFbmNvZGVEZWxheU1vdmluZ0F2ZXJhZ2VEZWx0YS5nZXQoKSk7XG4gICAgICAgIHRyYWNrTW92aW5nQXZlcmFnZURlbHRhcy5zZXQoJ2F2Z0VuY29kZURlbGF5JywgdHJhY2tBdmdFbmNvZGVEZWxheU1vdmluZ0F2ZXJhZ2VEZWx0YSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdG90YWxQYWNrZXRTZW5kRGVsYXkgPT09ICdudW1iZXInICYmIHR5cGVvZiBwYWNrZXRzU2VudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHRyYWNrQXZnUGFja2V0U2VuZERlbGF5TW92aW5nQXZlcmFnZURlbHRhID0gdHJhY2tNb3ZpbmdBdmVyYWdlRGVsdGFzLmdldCgnYXZnUGFja2V0U2VuZERlbGF5JylcbiAgICAgICAgICAgIHx8IG5ldyBNb3ZpbmdBdmVyYWdlRGVsdGEoKTtcbiAgICAgICAgdHJhY2tBdmdQYWNrZXRTZW5kRGVsYXlNb3ZpbmdBdmVyYWdlRGVsdGEucHV0U2FtcGxlKHRvdGFsUGFja2V0U2VuZERlbGF5ICogMTAwMCwgcGFja2V0c1NlbnQpO1xuICAgICAgICBhdWdtZW50ZWRUcmFja1N0YXRzLmF2Z1BhY2tldFNlbmREZWxheSA9IE1hdGgucm91bmQodHJhY2tBdmdQYWNrZXRTZW5kRGVsYXlNb3ZpbmdBdmVyYWdlRGVsdGEuZ2V0KCkpO1xuICAgICAgICB0cmFja01vdmluZ0F2ZXJhZ2VEZWx0YXMuc2V0KCdhdmdQYWNrZXRTZW5kRGVsYXknLCB0cmFja0F2Z1BhY2tldFNlbmREZWxheU1vdmluZ0F2ZXJhZ2VEZWx0YSk7XG4gICAgfVxuICAgIG1vdmluZ0F2ZXJhZ2VEZWx0YXMuc2V0KGtleSwgdHJhY2tNb3ZpbmdBdmVyYWdlRGVsdGFzKTtcbiAgICByZXR1cm4gYXVnbWVudGVkVHJhY2tTdGF0cztcbn1cbi8qKlxuICogTk9URShtbWFsYXZhbGxpKTogU2luY2UgQS9WIHN5bmMgbWV0cmljcyBhcmUgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBTdGF0c1JlcG9ydCBjbGFzcywgd2UgYWRkIHRoZW1cbiAqIG9ubHkgZm9yIHJlcG9ydGluZyBwdXJwb3Nlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZEFWU3luY01ldHJpY3NUb1JlbW90ZVRyYWNrU3RhdHModHJhY2tTdGF0cywgdHJhY2tSZXNwb25zZSwgbW92aW5nQXZlcmFnZURlbHRhcykge1xuICAgIHZhciBlc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wID0gdHJhY2tSZXNwb25zZS5lc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wLCBmcmFtZXNEZWNvZGVkID0gdHJhY2tSZXNwb25zZS5mcmFtZXNEZWNvZGVkLCBqaXR0ZXJCdWZmZXJEZWxheSA9IHRyYWNrUmVzcG9uc2Uuaml0dGVyQnVmZmVyRGVsYXksIGppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudCA9IHRyYWNrUmVzcG9uc2Uuaml0dGVyQnVmZmVyRW1pdHRlZENvdW50LCB0b3RhbERlY29kZVRpbWUgPSB0cmFja1Jlc3BvbnNlLnRvdGFsRGVjb2RlVGltZTtcbiAgICB2YXIgYXVnbWVudGVkVHJhY2tTdGF0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRyYWNrU3RhdHMpO1xuICAgIHZhciBrZXkgPSB0cmFja1N0YXRzLnRyYWNrU2lkICsgXCIrXCIgKyB0cmFja1N0YXRzLnNzcmM7XG4gICAgdmFyIHRyYWNrTW92aW5nQXZlcmFnZURlbHRhcyA9IG1vdmluZ0F2ZXJhZ2VEZWx0YXMuZ2V0KGtleSkgfHwgbmV3IE1hcCgpO1xuICAgIGlmICh0eXBlb2YgZXN0aW1hdGVkUGxheW91dFRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYXVnbWVudGVkVHJhY2tTdGF0cy5lc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wID0gZXN0aW1hdGVkUGxheW91dFRpbWVzdGFtcDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmcmFtZXNEZWNvZGVkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdG90YWxEZWNvZGVUaW1lID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgdHJhY2tBdmdEZWNvZGVEZWxheU1vdmluZ0F2ZXJhZ2VEZWx0YSA9IHRyYWNrTW92aW5nQXZlcmFnZURlbHRhcy5nZXQoJ2F2Z0RlY29kZURlbGF5JylcbiAgICAgICAgICAgIHx8IG5ldyBNb3ZpbmdBdmVyYWdlRGVsdGEoKTtcbiAgICAgICAgdHJhY2tBdmdEZWNvZGVEZWxheU1vdmluZ0F2ZXJhZ2VEZWx0YS5wdXRTYW1wbGUodG90YWxEZWNvZGVUaW1lICogMTAwMCwgZnJhbWVzRGVjb2RlZCk7XG4gICAgICAgIGF1Z21lbnRlZFRyYWNrU3RhdHMuYXZnRGVjb2RlRGVsYXkgPSBNYXRoLnJvdW5kKHRyYWNrQXZnRGVjb2RlRGVsYXlNb3ZpbmdBdmVyYWdlRGVsdGEuZ2V0KCkpO1xuICAgICAgICB0cmFja01vdmluZ0F2ZXJhZ2VEZWx0YXMuc2V0KCdhdmdEZWNvZGVEZWxheScsIHRyYWNrQXZnRGVjb2RlRGVsYXlNb3ZpbmdBdmVyYWdlRGVsdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGppdHRlckJ1ZmZlckRlbGF5ID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygaml0dGVyQnVmZmVyRW1pdHRlZENvdW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgdHJhY2tBdmdKaXR0ZXJCdWZmZXJEZWxheU1vdmluZ0F2ZXJhZ2VEZWx0YSA9IHRyYWNrTW92aW5nQXZlcmFnZURlbHRhcy5nZXQoJ2F2Z0ppdHRlckJ1ZmZlckRlbGF5JylcbiAgICAgICAgICAgIHx8IG5ldyBNb3ZpbmdBdmVyYWdlRGVsdGEoKTtcbiAgICAgICAgdHJhY2tBdmdKaXR0ZXJCdWZmZXJEZWxheU1vdmluZ0F2ZXJhZ2VEZWx0YS5wdXRTYW1wbGUoaml0dGVyQnVmZmVyRGVsYXkgKiAxMDAwLCBqaXR0ZXJCdWZmZXJFbWl0dGVkQ291bnQpO1xuICAgICAgICBhdWdtZW50ZWRUcmFja1N0YXRzLmF2Z0ppdHRlckJ1ZmZlckRlbGF5ID0gTWF0aC5yb3VuZCh0cmFja0F2Z0ppdHRlckJ1ZmZlckRlbGF5TW92aW5nQXZlcmFnZURlbHRhLmdldCgpKTtcbiAgICAgICAgdHJhY2tNb3ZpbmdBdmVyYWdlRGVsdGFzLnNldCgnYXZnSml0dGVyQnVmZmVyRGVsYXknLCB0cmFja0F2Z0ppdHRlckJ1ZmZlckRlbGF5TW92aW5nQXZlcmFnZURlbHRhKTtcbiAgICB9XG4gICAgbW92aW5nQXZlcmFnZURlbHRhcy5zZXQoa2V5LCB0cmFja01vdmluZ0F2ZXJhZ2VEZWx0YXMpO1xuICAgIHJldHVybiBhdWdtZW50ZWRUcmFja1N0YXRzO1xufVxuZnVuY3Rpb24gcmVwbGFjZU51bGxzV2l0aERlZmF1bHRzKGFjdGl2ZUljZUNhbmRpZGF0ZVBhaXIsIHBlZXJDb25uZWN0aW9uSWQpIHtcbiAgICBhY3RpdmVJY2VDYW5kaWRhdGVQYWlyID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGF2YWlsYWJsZUluY29taW5nQml0cmF0ZTogMCxcbiAgICAgICAgYXZhaWxhYmxlT3V0Z29pbmdCaXRyYXRlOiAwLFxuICAgICAgICBieXRlc1JlY2VpdmVkOiAwLFxuICAgICAgICBieXRlc1NlbnQ6IDAsXG4gICAgICAgIGNvbnNlbnRSZXF1ZXN0c1NlbnQ6IDAsXG4gICAgICAgIGN1cnJlbnRSb3VuZFRyaXBUaW1lOiAwLFxuICAgICAgICBsYXN0UGFja2V0UmVjZWl2ZWRUaW1lc3RhbXA6IDAsXG4gICAgICAgIGxhc3RQYWNrZXRTZW50VGltZXN0YW1wOiAwLFxuICAgICAgICBub21pbmF0ZWQ6IGZhbHNlLFxuICAgICAgICBwZWVyQ29ubmVjdGlvbklkOiBwZWVyQ29ubmVjdGlvbklkLFxuICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgcmVhZGFibGU6IGZhbHNlLFxuICAgICAgICByZXF1ZXN0c1JlY2VpdmVkOiAwLFxuICAgICAgICByZXF1ZXN0c1NlbnQ6IDAsXG4gICAgICAgIHJlc3BvbnNlc1JlY2VpdmVkOiAwLFxuICAgICAgICByZXNwb25zZXNTZW50OiAwLFxuICAgICAgICByZXRyYW5zbWlzc2lvbnNSZWNlaXZlZDogMCxcbiAgICAgICAgcmV0cmFuc21pc3Npb25zU2VudDogMCxcbiAgICAgICAgc3RhdGU6ICdmYWlsZWQnLFxuICAgICAgICB0b3RhbFJvdW5kVHJpcFRpbWU6IDAsXG4gICAgICAgIHRyYW5zcG9ydElkOiAnJyxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSwgZmlsdGVyT2JqZWN0KGFjdGl2ZUljZUNhbmRpZGF0ZVBhaXIgfHwge30sIG51bGwpKTtcbiAgICBhY3RpdmVJY2VDYW5kaWRhdGVQYWlyLmxvY2FsQ2FuZGlkYXRlID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNhbmRpZGF0ZVR5cGU6ICdob3N0JyxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIGlwOiAnJyxcbiAgICAgICAgcG9ydDogMCxcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIHByb3RvY29sOiAndWRwJyxcbiAgICAgICAgdXJsOiAnJ1xuICAgIH0sIGZpbHRlck9iamVjdChhY3RpdmVJY2VDYW5kaWRhdGVQYWlyLmxvY2FsQ2FuZGlkYXRlIHx8IHt9LCBudWxsKSk7XG4gICAgYWN0aXZlSWNlQ2FuZGlkYXRlUGFpci5yZW1vdGVDYW5kaWRhdGUgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2FuZGlkYXRlVHlwZTogJ2hvc3QnLFxuICAgICAgICBpcDogJycsXG4gICAgICAgIHBvcnQ6IDAsXG4gICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICBwcm90b2NvbDogJ3VkcCcsXG4gICAgICAgIHVybDogJydcbiAgICB9LCBmaWx0ZXJPYmplY3QoYWN0aXZlSWNlQ2FuZGlkYXRlUGFpci5yZW1vdGVDYW5kaWRhdGUgfHwge30sIG51bGwpKTtcbiAgICByZXR1cm4gYWN0aXZlSWNlQ2FuZGlkYXRlUGFpcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gUm9vbVYyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm9vbS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIE1lZGlhU2lnbmFsaW5nID0gcmVxdWlyZSgnLi9tZWRpYXNpZ25hbGluZycpO1xudmFyIFRyYWNrUHJpb3JpdHlTaWduYWxpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYWNrUHJpb3JpdHlTaWduYWxpbmcsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFRyYWNrUHJpb3JpdHlTaWduYWxpbmd9LlxuICAgICAqIEBwYXJhbSB7UHJvbWlzZTxEYXRhVHJhY2tSZWNlaXZlcj59IGdldFJlY2VpdmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhY2tQcmlvcml0eVNpZ25hbGluZyhnZXRSZWNlaXZlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBnZXRSZWNlaXZlciwgJ3RyYWNrX3ByaW9yaXR5Jywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9lbnF1ZXVlZFByaW9yaXR5VXBkYXRlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vbigncmVhZHknLCBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKF90aGlzLl9lbnF1ZXVlZFByaW9yaXR5VXBkYXRlcy5rZXlzKCkpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrU2lkKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndHJhY2tfcHJpb3JpdHknLFxuICAgICAgICAgICAgICAgICAgICB0cmFjazogdHJhY2tTaWQsXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZTogX3RoaXMuX2VucXVldWVkUHJpb3JpdHlVcGRhdGVzLmdldCh0cmFja1NpZClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKS0gd2UgZG8gbm90IGNsZWFyIF9lbnF1ZXVlZFByaW9yaXR5VXBkYXRlcyBpbnRlbnRpb25hbGx5LFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FjaGUgd2lsbCBpcyB1c2VkIHRvIHJlLXNlbmQgdGhlIHByaW9yaXRpZXMgaW4gY2FzZSBvZiBWTVMtRmFpbE92ZXIuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmFjay5TSUR9IHRyYWNrU2lkXG4gICAgICogQHBhcmFtIHsncHVibGlzaCd8J3N1YnNjcmliZSd9IHB1Ymxpc2hPclN1YnNjcmliZVxuICAgICAqIEBwYXJhbSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5XG4gICAgICovXG4gICAgVHJhY2tQcmlvcml0eVNpZ25hbGluZy5wcm90b3R5cGUuc2VuZFRyYWNrUHJpb3JpdHlVcGRhdGUgPSBmdW5jdGlvbiAodHJhY2tTaWQsIHB1Ymxpc2hPclN1YnNjcmliZSwgcHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKHB1Ymxpc2hPclN1YnNjcmliZSAhPT0gJ3N1YnNjcmliZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb25seSBzdWJzY3JpYmUgcHJpb3JpdGllcyBhcmUgc3VwcG9ydGVkLCBmb3VuZDogJyArIHB1Ymxpc2hPclN1YnNjcmliZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5xdWV1ZWRQcmlvcml0eVVwZGF0ZXMuc2V0KHRyYWNrU2lkLCBwcmlvcml0eSk7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydC5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndHJhY2tfcHJpb3JpdHknLFxuICAgICAgICAgICAgICAgIHRyYWNrOiB0cmFja1NpZCxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IHByaW9yaXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRyYWNrUHJpb3JpdHlTaWduYWxpbmc7XG59KE1lZGlhU2lnbmFsaW5nKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFRyYWNrUHJpb3JpdHlTaWduYWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFja3ByaW9yaXR5c2lnbmFsaW5nLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTWVkaWFTaWduYWxpbmcgPSByZXF1aXJlKCcuL21lZGlhc2lnbmFsaW5nJyk7XG4vKipcbiAqIEBlbWl0cyBUcmFja1N3aXRjaE9mZlNpZ25hbGluZ2luZyN1cGRhdGVkXG4gKi9cbnZhciBUcmFja1N3aXRjaE9mZlNpZ25hbGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJhY2tTd2l0Y2hPZmZTaWduYWxpbmcsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFRyYWNrU3dpdGNoT2ZmU2lnbmFsaW5nfS5cbiAgICAgKiBAcGFyYW0ge1Byb21pc2U8RGF0YVRyYWNrUmVjZWl2ZXI+fSBnZXRSZWNlaXZlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYWNrU3dpdGNoT2ZmU2lnbmFsaW5nKGdldFJlY2VpdmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdldFJlY2VpdmVyLCAndHJhY2tfc3dpdGNoX29mZicsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9uKCdyZWFkeScsIGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJhY2tfc3dpdGNoX29mZic6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0VHJhY2tTd2l0Y2hPZmZVcGRhdGVzKG1lc3NhZ2Uub2ZmIHx8IFtdLCBtZXNzYWdlLm9uIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtbVHJhY2suU0lEXX0gdHJhY2tzU3dpdGNoZWRPZmZcbiAgICAgKiBAcGFyYW0ge1tUcmFjay5TSURdfSB0cmFja3NTd2l0Y2hlZE9uXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgVHJhY2tTd2l0Y2hPZmZTaWduYWxpbmcucHJvdG90eXBlLl9zZXRUcmFja1N3aXRjaE9mZlVwZGF0ZXMgPSBmdW5jdGlvbiAodHJhY2tzU3dpdGNoZWRPZmYsIHRyYWNrc1N3aXRjaGVkT24pIHtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJywgdHJhY2tzU3dpdGNoZWRPZmYsIHRyYWNrc1N3aXRjaGVkT24pO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYWNrU3dpdGNoT2ZmU2lnbmFsaW5nO1xufShNZWRpYVNpZ25hbGluZykpO1xuLyoqXG4gKiBAZXZlbnQgVHJhY2tTd2l0Y2hPZmZTaWduYWxpbmcjdXBkYXRlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFRyYWNrU3dpdGNoT2ZmU2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2tzd2l0Y2hvZmZzaWduYWxpbmcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBTdGF0ZU1hY2hpbmUgPSByZXF1aXJlKCcuLi8uLi9zdGF0ZW1hY2hpbmUnKTtcbnZhciBUd2lsaW9Db25uZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHdpbGlvY29ubmVjdGlvbicpO1xudmFyIERlZmF1bHRCYWNrb2ZmID0gcmVxdWlyZSgnYmFja29mZicpO1xudmFyIHJlY29ubmVjdEJhY2tvZmZDb25maWcgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbnN0YW50cycpLnJlY29ubmVjdEJhY2tvZmZDb25maWc7XG52YXIgVGltZW91dCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdGltZW91dCcpO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25zdGFudHMnKSwgU0RLX05BTUUgPSBfYS5TREtfTkFNRSwgU0RLX1ZFUlNJT04gPSBfYS5TREtfVkVSU0lPTiwgU0RQX0ZPUk1BVCA9IF9hLlNEUF9GT1JNQVQ7XG52YXIgX2IgPSByZXF1aXJlKCcuLi8uLi91dGlsJyksIGNyZWF0ZUJhbmR3aWR0aFByb2ZpbGVQYXlsb2FkID0gX2IuY3JlYXRlQmFuZHdpZHRoUHJvZmlsZVBheWxvYWQsIGNyZWF0ZU1lZGlhU2lnbmFsaW5nUGF5bG9hZCA9IF9iLmNyZWF0ZU1lZGlhU2lnbmFsaW5nUGF5bG9hZCwgY3JlYXRlU3Vic2NyaWJlUGF5bG9hZCA9IF9iLmNyZWF0ZVN1YnNjcmliZVBheWxvYWQsIGdldFVzZXJBZ2VudCA9IF9iLmdldFVzZXJBZ2VudCwgaXNOb25BcnJheU9iamVjdCA9IF9iLmlzTm9uQXJyYXlPYmplY3Q7XG52YXIgX2MgPSByZXF1aXJlKCcuLi8uLi91dGlsL3R3aWxpby12aWRlby1lcnJvcnMnKSwgY3JlYXRlVHdpbGlvRXJyb3IgPSBfYy5jcmVhdGVUd2lsaW9FcnJvciwgUm9vbUNvbXBsZXRlZEVycm9yID0gX2MuUm9vbUNvbXBsZXRlZEVycm9yLCBTaWduYWxpbmdDb25uZWN0aW9uRXJyb3IgPSBfYy5TaWduYWxpbmdDb25uZWN0aW9uRXJyb3IsIFNpZ25hbGluZ1NlcnZlckJ1c3lFcnJvciA9IF9jLlNpZ25hbGluZ1NlcnZlckJ1c3lFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby13YXJuaW5nLWNvbW1lbnRzXG4vLyBUT0RPKG1tYWxhdmFsbGkpOiBSZW1vdmUgSUNFIHZlcnNpb24gYW5kIHVzZSBSU1BfVkVSU0lPTiBiZWZvcmUgTGFyZ2UgUm9vbXMgR0EuXG52YXIgSUNFX1ZFUlNJT04gPSAxO1xudmFyIFJTUF9WRVJTSU9OID0gMztcbi8qXG5Ud2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0IFN0YXRlc1xuLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICB8ICBzeW5jaW5nICB8LS0tLS0tLS0tK1xuICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tKyAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICBeICAgICB8ICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgdiAgICAgICAgICAgIHZcbiAgICArLS0tLS0tLS0tLS0tKyAgICArLS0tLS0tLS0tLS0rICAgICstLS0tLS0tLS0tLS0tLStcbiAgICB8ICAgICAgICAgICAgfCAgICB8ICAgICAgICAgICB8ICAgIHwgICAgICAgICAgICAgIHxcbiAgICB8IGNvbm5lY3RpbmcgfC0tLT58IGNvbm5lY3RlZCB8LS0tPnwgZGlzY29ubmVjdGVkIHxcbiAgICB8ICAgICAgICAgICAgfCAgICB8ICAgICAgICAgICB8ICAgIHwgICAgICAgICAgICAgIHxcbiAgICArLS0tLS0tLS0tLS0tKyAgICArLS0tLS0tLS0tLS0rICAgICstLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXlxuICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuXG4qL1xudmFyIHN0YXRlcyA9IHtcbiAgICBjb25uZWN0aW5nOiBbXG4gICAgICAgICdjb25uZWN0ZWQnLFxuICAgICAgICAnZGlzY29ubmVjdGVkJ1xuICAgIF0sXG4gICAgY29ubmVjdGVkOiBbXG4gICAgICAgICdkaXNjb25uZWN0ZWQnLFxuICAgICAgICAnc3luY2luZydcbiAgICBdLFxuICAgIHN5bmNpbmc6IFtcbiAgICAgICAgJ2Nvbm5lY3RlZCcsXG4gICAgICAgICdkaXNjb25uZWN0ZWQnXG4gICAgXSxcbiAgICBkaXNjb25uZWN0ZWQ6IFtdXG59O1xuLyoqXG4gKiBBIHtAbGluayBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0fSBzdXBwb3J0cyBzZW5kaW5nIGFuZCByZWNlaXZpbmcgUm9vbSBTaWduYWxpbmcgUHJvdG9jb2xcbiAqIChSU1ApIG1lc3NhZ2VzLiBJdCBhbHNvIHN1cHBvcnRzIFJTUCByZXF1ZXN0cywgc3VjaCBhcyBTeW5jIGFuZCBEaXNjb25uZWN0LlxuICogQGV4dGVuZHMgU3RhdGVNYWNoaW5lXG4gKiBAZW1pdHMgVHdpbGlvQ29ubmVjdGlvblRyYW5zcG9ydCNjb25uZWN0ZWRcbiAqIEBlbWl0cyBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0I21lc3NhZ2VcbiAqL1xudmFyIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnR9LlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlblxuICAgICAqIEBwYXJhbSB7UGFydGljaXBhbnRTaWduYWxpbmd9IGxvY2FsUGFydGljaXBhbnRcbiAgICAgKiBAcGFyYW0ge1BlZXJDb25uZWN0aW9uTWFuYWdlcn0gcGVlckNvbm5lY3Rpb25NYW5hZ2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdzU2VydmVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQobmFtZSwgYWNjZXNzVG9rZW4sIGxvY2FsUGFydGljaXBhbnQsIHBlZXJDb25uZWN0aW9uTWFuYWdlciwgd3NTZXJ2ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgQmFja29mZjogRGVmYXVsdEJhY2tvZmYsXG4gICAgICAgICAgICBUd2lsaW9Db25uZWN0aW9uOiBUd2lsaW9Db25uZWN0aW9uLFxuICAgICAgICAgICAgaWNlU2VydmVyczogbnVsbCxcbiAgICAgICAgICAgIHRyYWNrUHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgICB0cmFja1N3aXRjaE9mZjogdHJ1ZSxcbiAgICAgICAgICAgIHJlbmRlckhpbnRzOiB0cnVlLFxuICAgICAgICAgICAgdXNlckFnZW50OiBnZXRVc2VyQWdlbnQoKVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnY29ubmVjdGluZycsIHN0YXRlcykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9hY2Nlc3NUb2tlbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBhY2Nlc3NUb2tlblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hdXRvbWF0aWNTdWJzY3JpcHRpb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5hdXRvbWF0aWNTdWJzY3JpcHRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYmFuZHdpZHRoUHJvZmlsZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZG9taW5hbnRTcGVha2VyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuZG9taW5hbnRTcGVha2VyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2FkYXB0aXZlU2ltdWxjYXN0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuYWRhcHRpdmVTaW11bGNhc3RcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZXZlbnRPYnNlcnZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmV2ZW50T2JzZXJ2ZXIsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlbmRlckhpbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMucmVuZGVySGludHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaWNlU2VydmVyc1N0YXR1czoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBBcnJheS5pc0FycmF5KG9wdGlvbnMuaWNlU2VydmVycylcbiAgICAgICAgICAgICAgICAgICAgPyAnb3ZlcnJvZGUnXG4gICAgICAgICAgICAgICAgICAgIDogJ2FjcXVpcmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xvY2FsUGFydGljaXBhbnQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbG9jYWxQYXJ0aWNpcGFudFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX25ldHdvcmtRdWFsaXR5OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGlzTm9uQXJyYXlPYmplY3Qob3B0aW9ucy5uZXR3b3JrUXVhbGl0eSkgfHwgb3B0aW9ucy5uZXR3b3JrUXVhbGl0eVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcGVlckNvbm5lY3Rpb25NYW5hZ2VyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBlZXJDb25uZWN0aW9uTWFuYWdlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZXNzaW9uVGltZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZXNzaW9uVGltZW91dE1TOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVjb25uZWN0QmFja29mZjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLkJhY2tvZmYuZXhwb25lbnRpYWwocmVjb25uZWN0QmFja29mZkNvbmZpZylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2Vzc2lvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RyYWNrUHJpb3JpdHk6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy50cmFja1ByaW9yaXR5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RyYWNrU3dpdGNoT2ZmOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMudHJhY2tTd2l0Y2hPZmZcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdHdpbGlvQ29ubmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3VwZGF0ZXNSZWNlaXZlZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF91cGRhdGVzVG9TZW5kOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3VzZXJBZ2VudDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnVzZXJBZ2VudFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF93c1NlcnZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB3c1NlcnZlclxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0dXBUcmFuc3BvcnQoX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIENvbm5lY3QsIFN5bmMgb3IgRGlzY29ubmVjdCBSU1AgbWVzc2FnZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHs/b2JqZWN0fVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQucHJvdG90eXBlLl9jcmVhdGVDb25uZWN0T3JTeW5jT3JEaXNjb25uZWN0TWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbjogdGhpcy5fc2Vzc2lvbixcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGlzY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogUlNQX1ZFUlNJT05cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSB7XG4gICAgICAgICAgICBjb25uZWN0aW5nOiAnY29ubmVjdCcsXG4gICAgICAgICAgICBzeW5jaW5nOiAnc3luYydcbiAgICAgICAgfVt0aGlzLnN0YXRlXTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLl9uYW1lLFxuICAgICAgICAgICAgcGFydGljaXBhbnQ6IHRoaXMuX2xvY2FsUGFydGljaXBhbnQuZ2V0U3RhdGUoKSxcbiAgICAgICAgICAgIHBlZXJfY29ubmVjdGlvbnM6IHRoaXMuX3BlZXJDb25uZWN0aW9uTWFuYWdlci5nZXRTdGF0ZXMoKSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiBSU1BfVkVSU0lPTlxuICAgICAgICB9O1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSAnY29ubmVjdCcpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuaWNlX3NlcnZlcnMgPSB0aGlzLl9pY2VTZXJ2ZXJzU3RhdHVzO1xuICAgICAgICAgICAgbWVzc2FnZS5wdWJsaXNoZXIgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogU0RLX05BTUUsXG4gICAgICAgICAgICAgICAgc2RrX3ZlcnNpb246IFNES19WRVJTSU9OLFxuICAgICAgICAgICAgICAgIHVzZXJfYWdlbnQ6IHRoaXMuX3VzZXJBZ2VudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9iYW5kd2lkdGhQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5iYW5kd2lkdGhfcHJvZmlsZSA9IGNyZWF0ZUJhbmR3aWR0aFByb2ZpbGVQYXlsb2FkKHRoaXMuX2JhbmR3aWR0aFByb2ZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZS5tZWRpYV9zaWduYWxpbmcgPSBjcmVhdGVNZWRpYVNpZ25hbGluZ1BheWxvYWQodGhpcy5fZG9taW5hbnRTcGVha2VyLCB0aGlzLl9uZXR3b3JrUXVhbGl0eSwgdGhpcy5fdHJhY2tQcmlvcml0eSwgdGhpcy5fdHJhY2tTd2l0Y2hPZmYsIHRoaXMuX2FkYXB0aXZlU2ltdWxjYXN0LCB0aGlzLl9yZW5kZXJIaW50cyk7XG4gICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmliZSA9IGNyZWF0ZVN1YnNjcmliZVBheWxvYWQodGhpcy5fYXV0b21hdGljU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuZm9ybWF0ID0gU0RQX0ZPUk1BVDtcbiAgICAgICAgICAgIG1lc3NhZ2UudG9rZW4gPSB0aGlzLl9hY2Nlc3NUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICdzeW5jJykge1xuICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uID0gdGhpcy5fc2Vzc2lvbjtcbiAgICAgICAgICAgIG1lc3NhZ2UudG9rZW4gPSB0aGlzLl9hY2Nlc3NUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNlc3Npb24gPSB0aGlzLl9zZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIFwiaWNlXCIgbWVzc2FnZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQucHJvdG90eXBlLl9jcmVhdGVJY2VNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWRnZTogJ3JvYW1pbmcnLFxuICAgICAgICAgICAgdG9rZW46IHRoaXMuX2FjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgdHlwZTogJ2ljZScsXG4gICAgICAgICAgICB2ZXJzaW9uOiBJQ0VfVkVSU0lPTlxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIENvbm5lY3QsIFN5bmMgb3IgRGlzY29ubmVjdCBSU1AgbWVzc2FnZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQucHJvdG90eXBlLl9zZW5kQ29ubmVjdE9yU3luY09yRGlzY29ubmVjdE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fY3JlYXRlQ29ubmVjdE9yU3luY09yRGlzY29ubmVjdE1lc3NhZ2UoKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3R3aWxpb0Nvbm5lY3Rpb24uc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgdGhlIHtAbGluayBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0fS4gUmV0dXJucyB0cnVlIGlmIGNhbGxpbmcgdGhlIG1ldGhvZCByZXN1bHRlZFxuICAgICAqIGluIGRpc2Nvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIHtUd2lsaW9FcnJvcn0gW2Vycm9yXVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnByZWVtcHQoJ2Rpc2Nvbm5lY3RlZCcsIG51bGwsIFtlcnJvcl0pO1xuICAgICAgICAgICAgdGhpcy5fc2VuZENvbm5lY3RPclN5bmNPckRpc2Nvbm5lY3RNZXNzYWdlKCk7XG4gICAgICAgICAgICB0aGlzLl90d2lsaW9Db25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGFuIFJTUCBVcGRhdGUuIFJldHVybnMgdHJ1ZSBpZiBjYWxsaW5nIHRoZSBtZXRob2QgcmVzdWx0ZWQgaW5cbiAgICAgKiBwdWJsaXNoaW5nIChvciBldmVudHVhbGx5IHB1Ymxpc2hpbmcpIHRoZSB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHVwZGF0ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLl90d2lsaW9Db25uZWN0aW9uLnNlbmRNZXNzYWdlKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uOiB0aGlzLl9zZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogUlNQX1ZFUlNJT05cbiAgICAgICAgICAgICAgICB9LCB1cGRhdGUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RpbmcnOlxuICAgICAgICAgICAgY2FzZSAnc3luY2luZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlc1RvU2VuZC5wdXNoKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggKG9yIHF1ZXVlKSBhbiBldmVudCB0byB0aGUgSW5zaWdodHMgZ2F0ZXdheS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXAgLSBFdmVudCBncm91cCBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBFdmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxldmVsIC0gRXZlbnQgbGV2ZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGF5bG9hZCAtIEV2ZW50IHBheWxvYWRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0LnByb3RvdHlwZS5wdWJsaXNoRXZlbnQgPSBmdW5jdGlvbiAoZ3JvdXAsIG5hbWUsIGxldmVsLCBwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50T2JzZXJ2ZXIuZW1pdCgnZXZlbnQnLCB7IGdyb3VwOiBncm91cCwgbmFtZTogbmFtZSwgbGV2ZWw6IGxldmVsLCBwYXlsb2FkOiBwYXlsb2FkIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3luYyB0aGUge0BsaW5rIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnR9LiBSZXR1cm5zIHRydWUgaWYgY2FsbGluZyB0aGUgbWV0aG9kIHJlc3VsdGVkIGluXG4gICAgICogc3luY2luZy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0LnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHRoaXMucHJlZW1wdCgnc3luY2luZycpO1xuICAgICAgICAgICAgdGhpcy5fc2VuZENvbm5lY3RPclN5bmNPckRpc2Nvbm5lY3RNZXNzYWdlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQucHJvdG90eXBlLl9zZXRTZXNzaW9uID0gZnVuY3Rpb24gKHNlc3Npb24sIHNlc3Npb25UaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuX3Nlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLl9zZXNzaW9uVGltZW91dE1TID0gc2Vzc2lvblRpbWVvdXQgKiAxMDAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB3ZSBzaG91bGQgYXR0ZW1wdCByZWNvbm5lY3QuXG4gICAgICogcmV0dXJucyBhIFByb21pc2UgdG8gd2FpdCBvbiBiZWZvcmUgYXR0ZW1wdGluZyB0b1xuICAgICAqIHJlY29ubmVjdC4gcmV0dXJucyBudWxsIGlmIGl0cyBub3Qgb2theSB0byByZWNvbm5lY3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0LnByb3RvdHlwZS5fZ2V0UmVjb25uZWN0VGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9zZXNzaW9uVGltZW91dE1TID09PSAwKSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIGVpdGhlciB3ZSBoYXZlIG5ldmVyIGNvbm5lY3RlZC5cbiAgICAgICAgICAgIC8vIG9yIHdlIHRpbWVkIG91dCB3aGlsZSB0cnlpbmcgdG8gcmVjb25uZWN0XG4gICAgICAgICAgICAvLyBJbiBlaXRoZXIgY2FzZSB3ZSBkbyBub3Qgd2FudCB0byByZWNvbm5lY3QuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGFydCBzZXNzaW9uIHRpbWVyXG4gICAgICAgIGlmICghdGhpcy5fc2Vzc2lvblRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXNzaW9uVGltZXIgPSBuZXcgVGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgX2NsZWFyUmVjb25uZWN0VGltZXIgd2Fzbid0XG4gICAgICAgICAgICAgICAgLy8gY2FsbGVkIHdoaWxlIHdlIHdlcmUgd2FpdGluZy5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3Nlc3Npb25UaW1lcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgYW55IG1vcmUgcmVjb25uZWN0IGF0dGVtcHRzLlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2Vzc2lvblRpbWVvdXRNUyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy5fc2Vzc2lvblRpbWVvdXRNUyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIHByb21pc2UgdGhhdCB3YWl0cyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmYuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgX3RoaXMuX3JlY29ubmVjdEJhY2tvZmYub25jZSgncmVhZHknLCByZXNvbHZlKTtcbiAgICAgICAgICAgIF90aGlzLl9yZWNvbm5lY3RCYWNrb2ZmLmJhY2tvZmYoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjbGVhcnMgdGhlIHNlc3Npb24gcmVjb25uZWN0IHRpbWVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0LnByb3RvdHlwZS5fY2xlYXJSZWNvbm5lY3RUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0QmFja29mZi5yZXNldCgpO1xuICAgICAgICBpZiAodGhpcy5fc2Vzc2lvblRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXNzaW9uVGltZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3Nlc3Npb25UaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0O1xufShTdGF0ZU1hY2hpbmUpKTtcbi8qKlxuICogQGV2ZW50IFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQjY29ubmVjdGVkXG4gKiBAcGFyYW0ge29iamVjdH0gaW5pdGlhbFN0YXRlXG4gKi9cbi8qKlxuICogQGV2ZW50IFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQjbWVzc2FnZVxuICogQHBhcmFtIHtvYmplY3R9IHBlZXJDb25uZWN0aW9uc1xuICovXG5mdW5jdGlvbiByZWR1Y2VQZWVyQ29ubmVjdGlvbnMocGVlckNvbm5lY3Rpb25zKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocGVlckNvbm5lY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAocGVlckNvbm5lY3Rpb25zQnlJZCwgdXBkYXRlKSB7XG4gICAgICAgIHZhciByZWR1Y2VkID0gcGVlckNvbm5lY3Rpb25zQnlJZC5nZXQodXBkYXRlLmlkKSB8fCB1cGRhdGU7XG4gICAgICAgIC8vIEZpcnN0LCByZWR1Y2UgdGhlIHRvcC1sZXZlbCBgZGVzY3JpcHRpb25gIHByb3BlcnR5LlxuICAgICAgICBpZiAoIXJlZHVjZWQuZGVzY3JpcHRpb24gJiYgdXBkYXRlLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZWR1Y2VkLmRlc2NyaXB0aW9uID0gdXBkYXRlLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZHVjZWQuZGVzY3JpcHRpb24gJiYgdXBkYXRlLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRlc2NyaXB0aW9uLnJldmlzaW9uID4gcmVkdWNlZC5kZXNjcmlwdGlvbi5yZXZpc2lvbikge1xuICAgICAgICAgICAgICAgIHJlZHVjZWQuZGVzY3JpcHRpb24gPSB1cGRhdGUuZGVzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlbiwgcmVkdWNlIHRoZSB0b3AtbGV2ZWwgYGljZWAgcHJvcGVydHkuXG4gICAgICAgIGlmICghcmVkdWNlZC5pY2UgJiYgdXBkYXRlLmljZSkge1xuICAgICAgICAgICAgcmVkdWNlZC5pY2UgPSB1cGRhdGUuaWNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZHVjZWQuaWNlICYmIHVwZGF0ZS5pY2UpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuaWNlLnJldmlzaW9uID4gcmVkdWNlZC5pY2UucmV2aXNpb24pIHtcbiAgICAgICAgICAgICAgICByZWR1Y2VkLmljZSA9IHVwZGF0ZS5pY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluYWxseSwgdXBkYXRlIHRoZSBtYXAuXG4gICAgICAgIHBlZXJDb25uZWN0aW9uc0J5SWQuc2V0KHJlZHVjZWQuaWQsIHJlZHVjZWQpO1xuICAgICAgICByZXR1cm4gcGVlckNvbm5lY3Rpb25zQnlJZDtcbiAgICB9LCBuZXcgTWFwKCkpLnZhbHVlcygpKTtcbn1cbmZ1bmN0aW9uIHJlZHVjZVVwZGF0ZXModXBkYXRlcykge1xuICAgIHJldHVybiB1cGRhdGVzLnJlZHVjZShmdW5jdGlvbiAocmVkdWNlZCwgdXBkYXRlKSB7XG4gICAgICAgIC8vIEZpcnN0LCByZWR1Y2UgdGhlIHRvcC1sZXZlbCBgcGFydGljaXBhbnRgIHByb3BlcnR5LlxuICAgICAgICBpZiAoIXJlZHVjZWQucGFydGljaXBhbnQgJiYgdXBkYXRlLnBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICByZWR1Y2VkLnBhcnRpY2lwYW50ID0gdXBkYXRlLnBhcnRpY2lwYW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZHVjZWQucGFydGljaXBhbnQgJiYgdXBkYXRlLnBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLnBhcnRpY2lwYW50LnJldmlzaW9uID4gcmVkdWNlZC5wYXJ0aWNpcGFudC5yZXZpc2lvbikge1xuICAgICAgICAgICAgICAgIHJlZHVjZWQucGFydGljaXBhbnQgPSB1cGRhdGUucGFydGljaXBhbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlbiwgcmVkdWNlIHRoZSB0b3AtbGV2ZWwgYHBlZXJfY29ubmVjdGlvbnNgIHByb3BlcnR5LlxuICAgICAgICAvKiBlc2xpbnQgY2FtZWxjYXNlOjAgKi9cbiAgICAgICAgaWYgKCFyZWR1Y2VkLnBlZXJfY29ubmVjdGlvbnMgJiYgdXBkYXRlLnBlZXJfY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIHJlZHVjZWQucGVlcl9jb25uZWN0aW9ucyA9IHJlZHVjZVBlZXJDb25uZWN0aW9ucyh1cGRhdGUucGVlcl9jb25uZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVkdWNlZC5wZWVyX2Nvbm5lY3Rpb25zICYmIHVwZGF0ZS5wZWVyX2Nvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICByZWR1Y2VkLnBlZXJfY29ubmVjdGlvbnMgPSByZWR1Y2VQZWVyQ29ubmVjdGlvbnMocmVkdWNlZC5wZWVyX2Nvbm5lY3Rpb25zLmNvbmNhdCh1cGRhdGUucGVlcl9jb25uZWN0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHNldHVwVHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU9yUmVzZXRUd2lsaW9Db25uZWN0aW9uKCkge1xuICAgICAgICBpZiAodHJhbnNwb3J0LnN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc3BvcnQuX3R3aWxpb0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5fdHdpbGlvQ29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfaWNlU2VydmVyc1N0YXR1cyA9IHRyYW5zcG9ydC5faWNlU2VydmVyc1N0YXR1cywgX29wdGlvbnMgPSB0cmFuc3BvcnQuX29wdGlvbnMsIF93c1NlcnZlciA9IHRyYW5zcG9ydC5fd3NTZXJ2ZXIsIHN0YXRlID0gdHJhbnNwb3J0LnN0YXRlO1xuICAgICAgICB2YXIgVHdpbGlvQ29ubmVjdGlvbiA9IF9vcHRpb25zLlR3aWxpb0Nvbm5lY3Rpb247XG4gICAgICAgIHZhciB0d2lsaW9Db25uZWN0aW9uID0gbmV3IFR3aWxpb0Nvbm5lY3Rpb24oX3dzU2VydmVyLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGhlbGxvQm9keTogc3RhdGUgPT09ICdjb25uZWN0aW5nJyAmJiBfaWNlU2VydmVyc1N0YXR1cyA9PT0gJ2FjcXVpcmUnXG4gICAgICAgICAgICAgICAgPyB0cmFuc3BvcnQuX2NyZWF0ZUljZU1lc3NhZ2UoKVxuICAgICAgICAgICAgICAgIDogdHJhbnNwb3J0Ll9jcmVhdGVDb25uZWN0T3JTeW5jT3JEaXNjb25uZWN0TWVzc2FnZSgpXG4gICAgICAgIH0sIF9vcHRpb25zKSk7XG4gICAgICAgIHR3aWxpb0Nvbm5lY3Rpb24ub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICBpZiAocmVhc29uID09PSBUd2lsaW9Db25uZWN0aW9uLkNsb3NlUmVhc29uLkxPQ0FMKSB7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0d2lsaW9Db25uZWN0aW9uLm9uKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgIHRyYW5zcG9ydC5fdHdpbGlvQ29ubmVjdGlvbiA9IHR3aWxpb0Nvbm5lY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2Nvbm5lY3QoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRyYW5zcG9ydC5zdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWNvbm5lY3RUaW1lciA9IHRyYW5zcG9ydC5fZ2V0UmVjb25uZWN0VGltZXIoKTtcbiAgICAgICAgaWYgKCFyZWNvbm5lY3RUaW1lcikge1xuICAgICAgICAgICAgdmFyIHR3aWxpb0Vycm9yID0gZXJyb3IubWVzc2FnZSA9PT0gVHdpbGlvQ29ubmVjdGlvbi5DbG9zZVJlYXNvbi5CVVNZXG4gICAgICAgICAgICAgICAgPyBuZXcgU2lnbmFsaW5nU2VydmVyQnVzeUVycm9yKClcbiAgICAgICAgICAgICAgICA6IG5ldyBTaWduYWxpbmdDb25uZWN0aW9uRXJyb3IoKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KHR3aWxpb0Vycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNwb3J0LnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgdHJhbnNwb3J0LnByZWVtcHQoJ3N5bmNpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICByZWNvbm5lY3RUaW1lci50aGVuKGNyZWF0ZU9yUmVzZXRUd2lsaW9Db25uZWN0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFuc3BvcnQuc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoY3JlYXRlVHdpbGlvRXJyb3IobWVzc2FnZS5jb2RlLCBtZXNzYWdlLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRyYW5zcG9ydC5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzeW5jZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KG1lc3NhZ2Uuc3RhdHVzID09PSAnY29tcGxldGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IFJvb21Db21wbGV0ZWRFcnJvcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29ubmVjdGluZyc6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaWNlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuX29wdGlvbnMub25JY2VkKG1lc3NhZ2UuaWNlX3NlcnZlcnMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5fc2VuZENvbm5lY3RPclN5bmNPckRpc2Nvbm5lY3RNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5fc2V0U2Vzc2lvbihtZXNzYWdlLnNlc3Npb24sIG1lc3NhZ2Uub3B0aW9ucy5zZXNzaW9uX3RpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmVtaXQoJ2Nvbm5lY3RlZCcsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnByZWVtcHQoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzeW5jZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0Ll91cGRhdGVzUmVjZWl2ZWQucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KG1lc3NhZ2Uuc3RhdHVzID09PSAnY29tcGxldGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IFJvb21Db21wbGV0ZWRFcnJvcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3luY2luZyc6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndXBkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5fdXBkYXRlc1JlY2VpdmVkLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N5bmNlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuX2NsZWFyUmVjb25uZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQucHJlZW1wdCgnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdChtZXNzYWdlLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBSb29tQ29tcGxldGVkRXJyb3IoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gSW1wb3NzaWJsZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc3BvcnQub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOiB7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZXMgPSB0cmFuc3BvcnQuX3VwZGF0ZXNUb1NlbmQuc3BsaWNlKDApO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQucHVibGlzaChyZWR1Y2VVcGRhdGVzKHVwZGF0ZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0Ll91cGRhdGVzUmVjZWl2ZWQuc3BsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZSkgeyByZXR1cm4gdHJhbnNwb3J0LmVtaXQoJ21lc3NhZ2UnLCB1cGRhdGUpOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5fdHdpbGlvQ29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzeW5jaW5nJzpcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gSW1wb3NzaWJsZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBfb3B0aW9ucyA9IHRyYW5zcG9ydC5fb3B0aW9ucywgX2ljZVNlcnZlcnNTdGF0dXMgPSB0cmFuc3BvcnQuX2ljZVNlcnZlcnNTdGF0dXM7XG4gICAgdmFyIGljZVNlcnZlcnMgPSBfb3B0aW9ucy5pY2VTZXJ2ZXJzLCBvbkljZWQgPSBfb3B0aW9ucy5vbkljZWQ7XG4gICAgaWYgKF9pY2VTZXJ2ZXJzU3RhdHVzID09PSAnb3ZlcnJvZGUnKSB7XG4gICAgICAgIG9uSWNlZChpY2VTZXJ2ZXJzKS50aGVuKGNyZWF0ZU9yUmVzZXRUd2lsaW9Db25uZWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNyZWF0ZU9yUmVzZXRUd2lsaW9Db25uZWN0aW9uKCk7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHdpbGlvY29ubmVjdGlvbnRyYW5zcG9ydC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFJlbW90ZVBhcnRpY2lwYW50VjIgPSByZXF1aXJlKCcuLi92Mi9yZW1vdGVwYXJ0aWNpcGFudCcpO1xudmFyIFJlbW90ZVRyYWNrUHVibGljYXRpb25WMyA9IHJlcXVpcmUoJy4vcmVtb3RldHJhY2twdWJsaWNhdGlvbicpO1xuLyoqXG4gKiBAZXh0ZW5kcyBSZW1vdGVQYXJ0aWNpcGFudFYyXG4gKi9cbnZhciBSZW1vdGVQYXJ0aWNpcGFudFYzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW1vdGVQYXJ0aWNpcGFudFYzLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudFYyfS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGljaXBhbnRTdGF0ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhY2suU0lEKTogUHJvbWlzZTxNZWRpYVRyYWNrUmVjZWl2ZXI+fSBnZXRQZW5kaW5nVHJhY2tSZWNlaXZlclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhY2suU0lEKTogYm9vbGVhbn0gZ2V0SW5pdGlhbFRyYWNrU3dpdGNoT2ZmU3RhdGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFRyYWNrLlNJRCwgVHJhY2suUHJpb3JpdHkpOiBib29sZWFufSBzZXRQcmlvcml0eVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhY2suU0lELCBDbGllbnRSZW5kZXJIaW50KTogUHJvbWlzZTx2b2lkPn0gc2V0UmVuZGVySGludFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhY2suU0lEKTogdm9pZH0gY2xlYXJUcmFja0hpbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVtb3RlUGFydGljaXBhbnRWMyhwYXJ0aWNpcGFudFN0YXRlLCBnZXRQZW5kaW5nVHJhY2tSZWNlaXZlciwgZ2V0SW5pdGlhbFRyYWNrU3dpdGNoT2ZmU3RhdGUsIHNldFByaW9yaXR5LCBzZXRSZW5kZXJIaW50LCBjbGVhclRyYWNrSGludCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjMsXG4gICAgICAgICAgICBnZXRQZW5kaW5nVHJhY2tSZWNlaXZlcjogZ2V0UGVuZGluZ1RyYWNrUmVjZWl2ZXJcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFydGljaXBhbnRTdGF0ZSwgZ2V0SW5pdGlhbFRyYWNrU3dpdGNoT2ZmU3RhdGUsIHNldFByaW9yaXR5LCBzZXRSZW5kZXJIaW50LCBjbGVhclRyYWNrSGludCwgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlbW90ZVBhcnRpY2lwYW50VjMucHJvdG90eXBlLl9nZXRPckNyZWF0ZVRyYWNrID0gZnVuY3Rpb24gKHRyYWNrU3RhdGUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzID0gX2EuX1JlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmcsIGdldFBlbmRpbmdUcmFja1JlY2VpdmVyID0gX2EuX2dldFBlbmRpbmdUcmFja1JlY2VpdmVyO1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrcy5nZXQodHJhY2tTdGF0ZS5zaWQpO1xuICAgICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSB0aGlzLmtpbmQgPT09ICdkYXRhJ1xuICAgICAgICAgICAgICAgID8geyBzdGF0ZTogJ09OJywgc3dpdGNoT2ZmUmVhc29uOiBudWxsIH1cbiAgICAgICAgICAgICAgICA6IHRoaXMuX2dldEluaXRpYWxUcmFja1N3aXRjaE9mZlN0YXRlKHRyYWNrU3RhdGUuc2lkKSwgc3RhdGUgPSBfYi5zdGF0ZSwgc3dpdGNoT2ZmUmVhc29uID0gX2Iuc3dpdGNoT2ZmUmVhc29uO1xuICAgICAgICAgICAgdHJhY2sgPSBuZXcgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzKHRyYWNrU3RhdGUsIHN0YXRlID09PSAnT0ZGJywgc3dpdGNoT2ZmUmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuYWRkVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgZ2V0UGVuZGluZ1RyYWNrUmVjZWl2ZXIodHJhY2suc2lkKS50aGVuKGZ1bmN0aW9uICh0cmFja1JlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogRGF0YVRyYWNrcyBhcmUgc3Vic2NyaWJlZCB0byBvbmx5IGlmIGNvcnJlc3BvbmRpbmcgRGF0YVRyYWNrUmVjZWl2ZXJzXG4gICAgICAgICAgICAgICAgLy8gYXJlIGF2YWlsYWJsZSwgd2hlcmVhcyBNZWRpYVRyYWNrcyBjYW4gYmUgc3Vic2NyaWJlZCB0byBpcnJlc3BlY3RpdmUgb2Ygd2hldGhlciBjb3JyZXNwb25kaW5nXG4gICAgICAgICAgICAgICAgLy8gTWVkaWFUcmFja1JlY2VpdmVycyBhcmUgYXZhaWxhYmxlLiBNZWRpYVRyYWNrcyB3aXRob3V0IE1lZGlhVHJhY2tSZWNlaXZlcnMgYXJlIGNvbnNpZGVyZWRcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hlZCBvZmYuXG4gICAgICAgICAgICAgICAgdHJhY2suc2V0VHJhY2tUcmFuc2NlaXZlcih0cmFja1JlY2VpdmVyLCB0cmFjay5raW5kICE9PSAnZGF0YScgfHwgISF0cmFja1JlY2VpdmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFjaztcbiAgICB9O1xuICAgIHJldHVybiBSZW1vdGVQYXJ0aWNpcGFudFYzO1xufShSZW1vdGVQYXJ0aWNpcGFudFYyKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFJlbW90ZVBhcnRpY2lwYW50VjM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdGVwYXJ0aWNpcGFudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFJlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmcgPSByZXF1aXJlKCcuLi9yZW1vdGV0cmFja3B1YmxpY2F0aW9uJyk7XG4vKipcbiAqIEBleHRlbmRzIFJlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmdcbiAqL1xudmFyIFJlbW90ZVRyYWNrUHVibGljYXRpb25WMyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjN9LlxuICAgICAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzI1JlcHJlc2VudGF0aW9ufSB0cmFja1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTd2l0Y2hlZE9mZlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gc3dpdGNoT2ZmUmVhc29uXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzKHRyYWNrLCBpc1N3aXRjaGVkT2ZmLCBzd2l0Y2hPZmZSZWFzb24pIHtcbiAgICAgICAgaWYgKHN3aXRjaE9mZlJlYXNvbiA9PT0gdm9pZCAwKSB7IHN3aXRjaE9mZlJlYXNvbiA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3dpdGNoT2ZmUmVhc29uID0gaXNTd2l0Y2hlZE9mZiA/IHN3aXRjaE9mZlJlYXNvbiA6IG51bGw7XG4gICAgICAgIHZhciBlbmFibGVkID0gaXNFbmFibGVkKGlzU3dpdGNoZWRPZmYsIHN3aXRjaE9mZlJlYXNvbik7XG4gICAgICAgIHZhciBraW5kID0gdHJhY2sua2luZCwgbmFtZSA9IHRyYWNrLm5hbWUsIHByaW9yaXR5ID0gdHJhY2sucHJpb3JpdHksIHNpZCA9IHRyYWNrLnNpZDtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzaWQsIG5hbWUsIGtpbmQsIGVuYWJsZWQsIHByaW9yaXR5LCBpc1N3aXRjaGVkT2ZmLCAzKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2lzU3Vic2NyaWJlZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zd2l0Y2hPZmZSZWFzb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3dpdGNoT2ZmUmVhc29uLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjMucHJvdG90eXBlLCBcImlzU3Vic2NyaWJlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzfSBpcyBzdWJzY3JpYmVkIHRvLlxuICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1N1YnNjcmliZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzLnByb3RvdHlwZSwgXCJzd2l0Y2hPZmZSZWFzb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlYXNvbiBmb3IgdGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjN9IGJlaW5nIHN3aXRjaGVkIG9mZi5cbiAgICAgICAgICogQHJldHVybnMgez9zdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zd2l0Y2hPZmZSZWFzb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRyYWNrIHN3aXRjaCBvbi9vZmYgc3RhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1N3aXRjaGVkT2ZmXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBzd2l0Y2hPZmZSZWFzb25cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjMucHJvdG90eXBlLnNldFN3aXRjaGVkT2ZmID0gZnVuY3Rpb24gKGlzU3dpdGNoZWRPZmYsIHN3aXRjaE9mZlJlYXNvbikge1xuICAgICAgICBzd2l0Y2hPZmZSZWFzb24gPSBpc1N3aXRjaGVkT2ZmID8gc3dpdGNoT2ZmUmVhc29uIDogbnVsbDtcbiAgICAgICAgdmFyIHNob3VsZEVtaXRVcGRhdGVkID0gaXNTd2l0Y2hlZE9mZiAhPT0gdGhpcy5pc1N3aXRjaGVkT2ZmXG4gICAgICAgICAgICB8fCBzd2l0Y2hPZmZSZWFzb24gIT09IHRoaXMuc3dpdGNoT2ZmUmVhc29uO1xuICAgICAgICB0aGlzLl9pc1N3aXRjaGVkT2ZmID0gaXNTd2l0Y2hlZE9mZjtcbiAgICAgICAgdGhpcy5fc3dpdGNoT2ZmUmVhc29uID0gc3dpdGNoT2ZmUmVhc29uO1xuICAgICAgICBpZiAoc2hvdWxkRW1pdFVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuYWJsZShpc0VuYWJsZWQoaXNTd2l0Y2hlZE9mZiwgc3dpdGNoT2ZmUmVhc29uKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHtAbGluayBNZWRpYVRyYWNrUmVjZWl2ZXJ9IG9uIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzfS5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge01lZGlhVHJhY2tSZWNlaXZlcn0gdHJhY2tSZWNlaXZlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdWJzY3JpYmVkXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzLnByb3RvdHlwZS5zZXRUcmFja1RyYW5zY2VpdmVyID0gZnVuY3Rpb24gKHRyYWNrUmVjZWl2ZXIsIGlzU3Vic2NyaWJlZCkge1xuICAgICAgICBpc1N1YnNjcmliZWQgPSAhIXRyYWNrUmVjZWl2ZXIgfHwgaXNTdWJzY3JpYmVkO1xuICAgICAgICB2YXIgc2hvdWxkRW1pdFVwZGF0ZWQgPSB0cmFja1JlY2VpdmVyICE9PSB0aGlzLnRyYWNrVHJhbnNjZWl2ZXIgfHwgaXNTdWJzY3JpYmVkICE9PSB0aGlzLmlzU3Vic2NyaWJlZDtcbiAgICAgICAgdGhpcy5fdHJhY2tUcmFuc2NlaXZlciA9IHRyYWNrUmVjZWl2ZXI7XG4gICAgICAgIHRoaXMuX2lzU3Vic2NyaWJlZCA9IGlzU3Vic2NyaWJlZDtcbiAgICAgICAgaWYgKHNob3VsZEVtaXRVcGRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjN9IHRvIGFcbiAgICAgKiB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzI1JlcHJlc2VudGF0aW9ufSBvZiBpdHNlbGYgYW5kIHBlcmZvcm0gYW55XG4gICAgICogdXBkYXRlcyBuZWNlc3NhcnkuXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjMjUmVwcmVzZW50YXRpb259IHRyYWNrXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGZpcmVzIFRyYWNrU2lnbmFsaW5nI3VwZGF0ZWRcbiAgICAgKi9cbiAgICBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB0aGlzLnNldFByaW9yaXR5KHRyYWNrLnByaW9yaXR5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzO1xufShSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nKSk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3dpdGNoZWRPZmZcbiAqIEBwYXJhbSB7P3N0cmluZ30gc3dpdGNoT2ZmUmVhc29uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFbmFibGVkKGlzU3dpdGNoZWRPZmYsIHN3aXRjaE9mZlJlYXNvbikge1xuICAgIHJldHVybiAhKGlzU3dpdGNoZWRPZmYgJiYgc3dpdGNoT2ZmUmVhc29uID09PSAnRElTQUJMRURfQllfUFVCTElTSEVSJyk7XG59XG4vKipcbiAqIFRoZSBSb29tIFNpZ25hbGluZyBQcm90b2NvbCAoUlNQKSByZXByZXNlbnRhdGlvbiBvZiBhIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjN9LlxuICogQHR5cGVkZWYge29iamVjdH0gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzI1JlcHJlc2VudGF0aW9uXG4gKiBAcHJvcGVydHkge1RyYWNrLktpbmR9IGtpbmRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJpb3JpdHkge1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eVxuICogQHByb3BlcnR5IHtUcmFjay5TSUR9IHNpZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW90ZVRyYWNrUHVibGljYXRpb25WMztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW90ZXRyYWNrcHVibGljYXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBjcmVhdGVUd2lsaW9FcnJvciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdHdpbGlvLXZpZGVvLWVycm9ycycpLmNyZWF0ZVR3aWxpb0Vycm9yO1xudmFyIFJvb21WMiA9IHJlcXVpcmUoJy4uL3YyL3Jvb20nKTtcbnZhciBSZW1vdGVQYXJ0aWNpcGFudFYzID0gcmVxdWlyZSgnLi4vdjMvcmVtb3RlcGFydGljaXBhbnQnKTtcbnZhciBUcmFja1N1YnNjcmlwdGlvbnNTaWduYWxpbmcgPSByZXF1aXJlKCcuL3RyYWNrc3Vic2NyaXB0aW9uc3NpZ25hbGluZycpO1xuLyoqXG4gKiBAZXh0ZW5kcyBSb29tVjJcbiAqL1xudmFyIFJvb21WMyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbVYzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21WMyhsb2NhbFBhcnRpY2lwYW50LCBpbml0aWFsU3RhdGUsIHRyYW5zcG9ydCwgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIFJlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nOiBSZW1vdGVQYXJ0aWNpcGFudFYzLFxuICAgICAgICAgICAgVHJhY2tTdWJzY3JpcHRpb25zU2lnbmFsaW5nOiBUcmFja1N1YnNjcmlwdGlvbnNTaWduYWxpbmdcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbG9jYWxQYXJ0aWNpcGFudCwgaW5pdGlhbFN0YXRlLCB0cmFuc3BvcnQsIHBlZXJDb25uZWN0aW9uTWFuYWdlciwgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIFJvb21WMy5wcm90b3R5cGUuX2FkZFRyYWNrUmVjZWl2ZXIgPSBmdW5jdGlvbiAodHJhY2tSZWNlaXZlcikge1xuICAgICAgICB2YXIgaWRUeXBlID0gdHJhY2tSZWNlaXZlci5raW5kID09PSAnZGF0YScgPyAnaWQnIDogJ21pZCc7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IHRoaXMuX2dldE9yQ3JlYXRlVHJhY2tSZWNlaXZlckRlZmVycmVkKHRyYWNrUmVjZWl2ZXJbaWRUeXBlXSwgaWRUeXBlKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0cmFja1JlY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIFJvb21WMy5wcm90b3R5cGUuX2NyZWF0ZVJlbW90ZVBhcnRpY2lwYW50ID0gZnVuY3Rpb24gKHBhcnRpY2lwYW50U3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIFJlbW90ZVBhcnRpY2lwYW50VjMgPSB0aGlzLl9SZW1vdGVQYXJ0aWNpcGFudFNpZ25hbGluZztcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdGVQYXJ0aWNpcGFudFYzKHBhcnRpY2lwYW50U3RhdGUsIGZ1bmN0aW9uICh0cmFja1NpZCkgeyByZXR1cm4gX3RoaXMuX2dldFBlbmRpbmdUcmFja1JlY2VpdmVyKHRyYWNrU2lkKTsgfSwgZnVuY3Rpb24gKHRyYWNrU2lkKSB7IHJldHVybiBfdGhpcy5fZ2V0SW5pdGlhbFRyYWNrU3dpdGNoT2ZmU3RhdGUodHJhY2tTaWQpOyB9LCBmdW5jdGlvbiAodHJhY2tTaWQsIHByaW9yaXR5KSB7IHJldHVybiBfdGhpcy5fdHJhY2tQcmlvcml0eVNpZ25hbGluZy5zZW5kVHJhY2tQcmlvcml0eVVwZGF0ZSh0cmFja1NpZCwgJ3N1YnNjcmliZScsIHByaW9yaXR5KTsgfSwgZnVuY3Rpb24gKHRyYWNrU2lkLCBoaW50KSB7IHJldHVybiBfdGhpcy5fcmVuZGVySGludHNTaWduYWxpbmcuc2V0VHJhY2tIaW50KHRyYWNrU2lkLCBoaW50KTsgfSwgZnVuY3Rpb24gKHRyYWNrU2lkKSB7IHJldHVybiBfdGhpcy5fcmVuZGVySGludHNTaWduYWxpbmcuY2xlYXJUcmFja0hpbnQodHJhY2tTaWQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgUm9vbVYzLnByb3RvdHlwZS5fZ2V0SW5pdGlhbFRyYWNrU3dpdGNoT2ZmU3RhdGUgPSBmdW5jdGlvbiAodHJhY2tTaWQpIHtcbiAgICAgICAgdmFyIHN3aXRjaE9mZlN0YXRlID0gdGhpcy5fcGVuZGluZ1N3aXRjaE9mZlN0YXRlcy5nZXQodHJhY2tTaWQpXG4gICAgICAgICAgICB8fCB7IHN0YXRlOiAnT0ZGJywgc3dpdGNoT2ZmUmVhc29uOiAnRElTQUJMRURfQllfU1VCU0NSSUJFUicgfTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1N3aXRjaE9mZlN0YXRlcy5kZWxldGUodHJhY2tTaWQpO1xuICAgICAgICBpZiAoc3dpdGNoT2ZmU3RhdGUuc3RhdGUgPT09ICdPRkYnKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIltcIiArIHRyYWNrU2lkICsgXCJdIHdhcyBpbml0aWFsbHkgc3dpdGNoZWQgb2ZmISBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN3aXRjaE9mZlN0YXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSb29tVjMucHJvdG90eXBlLl9nZXRQZW5kaW5nVHJhY2tSZWNlaXZlciA9IGZ1bmN0aW9uICh0cmFja1NpZCkge1xuICAgICAgICB2YXIgZGF0YUNoYW5uZWxMYWJlbCA9IHRoaXMuX3BlbmRpbmdEYXRhQ2hhbm5lbExhYmVscy5nZXQodHJhY2tTaWQpO1xuICAgICAgICB2YXIgbWlkID0gdGhpcy5fcGVuZGluZ1RyYWNrTWlkcy5nZXQodHJhY2tTaWQpO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgaWYgKGRhdGFDaGFubmVsTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdEYXRhQ2hhbm5lbExhYmVscy5kZWxldGUodHJhY2tTaWQpO1xuICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMuX2dldFRyYWNrUmVjZWl2ZXIoZGF0YUNoYW5uZWxMYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWlkKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nVHJhY2tNaWRzLmRlbGV0ZSh0cmFja1NpZCk7XG4gICAgICAgICAgICBwcm9taXNlID0gdGhpcy5fZ2V0VHJhY2tSZWNlaXZlcihtaWQsICdtaWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgUm9vbVYzLnByb3RvdHlwZS5faGFuZGxlU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogRG8gbm90aGluZyBzaW5jZSBSU1AgdjMgbWVzc2FnZXMgd2lsbCBub3QgY29udGFpbiB0aGUgXCJzdWJzY3JpYmVkXCIgcHJvcGVydHkuICovXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIFJvb21WMy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAobG9jYWxQYXJ0aWNpcGFudCwgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLCB0cmFuc3BvcnQsIG9wdGlvbnMsIGluaXRpYWxTdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZ2V0VHJhY2tSZWNlaXZlciA9IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gX3RoaXMuX2dldFRyYWNrUmVjZWl2ZXIoaWQpOyB9O1xuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBfcGVuZGluZ0RhdGFDaGFubmVsTGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9wZW5kaW5nVHJhY2tNaWRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90cmFja1N1YnNjcmlwdGlvbnNTaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IG9wdGlvbnMuVHJhY2tTdWJzY3JpcHRpb25zU2lnbmFsaW5nKGdldFRyYWNrUmVjZWl2ZXIsIHsgbG9nOiBsb2cgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2luaXRUcmFja1N1YnNjcmlwdGlvbnNTaWduYWxpbmcoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5faW5pdC5jYWxsKHRoaXMsIGxvY2FsUGFydGljaXBhbnQsIHBlZXJDb25uZWN0aW9uTWFuYWdlciwgdHJhbnNwb3J0LCBvcHRpb25zLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSb29tVjMucHJvdG90eXBlLl9pbml0VHJhY2tTdWJzY3JpcHRpb25zU2lnbmFsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl90cmFja1N1YnNjcmlwdGlvbnNTaWduYWxpbmcub24oJ3VwZGF0ZWQnLCBmdW5jdGlvbiAobWVkaWEsIGRhdGEsIGVycm9ycykge1xuICAgICAgICAgICAgdmFyIHRyYWNrU2lkc1RvVHJhY2tTaWduYWxpbmdzID0gX3RoaXMuX2dldFRyYWNrU2lkc1RvVHJhY2tTaWduYWxpbmdzKCk7XG4gICAgICAgICAgICB2YXIgZGF0YVRyYWNrU2lkc1RvVHJhY2tTdGF0ZXMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGRhdGEpKTtcbiAgICAgICAgICAgIHZhciBtZWRpYVRyYWNrU2lkc1RvVHJhY2tTdGF0ZXMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKG1lZGlhKSk7XG4gICAgICAgICAgICB2YXIgdHJhY2tTaWRzVG9FcnJvcnMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGVycm9ycykpO1xuICAgICAgICAgICAgbWVkaWFUcmFja1NpZHNUb1RyYWNrU3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKF9hLCBzaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWlkID0gX2EubWlkLCBfYiA9IF9hLm9mZl9yZWFzb24sIHN3aXRjaE9mZlJlYXNvbiA9IF9iID09PSB2b2lkIDAgPyBudWxsIDogX2IsIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrU2lnbmFsaW5nID0gdHJhY2tTaWRzVG9UcmFja1NpZ25hbGluZ3MuZ2V0KHNpZCk7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrU3RhdGUgPSB7IHN0YXRlOiBzdGF0ZSwgc3dpdGNoT2ZmUmVhc29uOiBzd2l0Y2hPZmZSZWFzb24gfTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYWNrU2lnbmFsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9wZW5kaW5nU3dpdGNoT2ZmU3RhdGVzLnNldChzaWQsIHRyYWNrU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcGVuZGluZ1RyYWNrTWlkcy5zZXQoc2lkLCBtaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpc1N3aXRjaGVkT2ZmID0gc3RhdGUgPT09ICdPRkYnO1xuICAgICAgICAgICAgICAgIGlmIChpc1N3aXRjaGVkT2ZmIHx8ICh0cmFja1NpZ25hbGluZy50cmFja1RyYW5zY2VpdmVyICYmIHRyYWNrU2lnbmFsaW5nLnRyYWNrVHJhbnNjZWl2ZXIubWlkICE9PSBtaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IElmIGEgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYzJ3MgTUlEIGNoYW5nZXMsIHRoZW4gd2UgbmVlZCB0byB1bnN1YnNjcmliZVxuICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBSZW1vdGVUcmFjayBiZWZvcmUgc3Vic2NyaWJpbmcgdG8gaXQgYWdhaW4gd2l0aCB0aGUgTWVkaWFUcmFja1JlY2VpdmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbmV3XG4gICAgICAgICAgICAgICAgICAgIC8vIE1JRC4gSWYgYSBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjMncyBSZW1vdGVUcmFjayBpcyBzd2l0Y2hlZCBvZmYsIHRoZW4gd2Ugc2hvdWxkIHN0aWxsIGJlIHN1YnNjcmliZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gaXQsIGV2ZW4gdGhvdWdoIGl0IG5vIGxvbmdlciBoYXMgYW4gTUlEIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgICAgICAgICAgICAgICAgdHJhY2tTaWduYWxpbmcuc2V0VHJhY2tUcmFuc2NlaXZlcihudWxsLCBpc1N3aXRjaGVkT2ZmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc1N3aXRjaGVkT2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9nZXRUcmFja1JlY2VpdmVyKG1pZCwgJ21pZCcpLnRoZW4oZnVuY3Rpb24gKHRyYWNrUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrU2lnbmFsaW5nLnNldFRyYWNrVHJhbnNjZWl2ZXIodHJhY2tSZWNlaXZlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogd2hlbiB0cmFjayBpcyBzd2l0Y2hlZCBvbiwgc2VuZCB0aGUgc3dpdGNoT24gbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBhZnRlciB0cmFjayByZWNlaXZlciBpcyBzZXQgc28gdGhhdCBhcHBsaWNhdGlvbiBjYW4gYWNjZXNzIChuZXcpIG1lZGlhU3RyZWFtVHJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrU2lnbmFsaW5nLnNldFN3aXRjaGVkT2ZmKGlzU3dpdGNoZWRPZmYsIHN3aXRjaE9mZlJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tTaWduYWxpbmcuc2V0U3dpdGNoZWRPZmYoaXNTd2l0Y2hlZE9mZiwgc3dpdGNoT2ZmUmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRhdGFUcmFja1NpZHNUb1RyYWNrU3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKF9hLCBzaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBfYS5sYWJlbDtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tTaWduYWxpbmcgPSB0cmFja1NpZHNUb1RyYWNrU2lnbmFsaW5ncy5nZXQoc2lkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYWNrU2lnbmFsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9wZW5kaW5nRGF0YUNoYW5uZWxMYWJlbHMuc2V0KHNpZCwgbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9nZXRUcmFja1JlY2VpdmVyKGxhYmVsKS50aGVuKGZ1bmN0aW9uICh0cmFja1JlY2VpdmVyKSB7IHJldHVybiB0cmFja1NpZ25hbGluZy5zZXRUcmFja1RyYW5zY2VpdmVyKHRyYWNrUmVjZWl2ZXIsIHRydWUpOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJhY2tTaWRzVG9FcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoX2EsIHNpZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gX2EuY29kZSwgbWVzc2FnZSA9IF9hLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrU2lnbmFsaW5nID0gdHJhY2tTaWRzVG9UcmFja1NpZ25hbGluZ3MuZ2V0KHNpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrU2lnbmFsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrU2lnbmFsaW5nLnN1YnNjcmliZUZhaWxlZChjcmVhdGVUd2lsaW9FcnJvcihjb2RlLCBtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cmFja1NpZHNUb1RyYWNrU2lnbmFsaW5ncy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja1NpZ25hbGluZykge1xuICAgICAgICAgICAgICAgIHZhciBzaWQgPSB0cmFja1NpZ25hbGluZy5zaWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFtZWRpYVRyYWNrU2lkc1RvVHJhY2tTdGF0ZXMuaGFzKHNpZCkgJiYgIWRhdGFUcmFja1NpZHNUb1RyYWNrU3RhdGVzLmhhcyhzaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9wZW5kaW5nU3dpdGNoT2ZmU3RhdGVzLmRlbGV0ZShzaWQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcGVuZGluZ1RyYWNrTWlkcy5kZWxldGUoc2lkKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tTaWduYWxpbmcuc2V0VHJhY2tUcmFuc2NlaXZlcihudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBSb29tVjMucHJvdG90eXBlLl91cGRhdGVTdWJzY3JpYmVkID0gZnVuY3Rpb24gKHJvb21TdGF0ZSkge1xuICAgICAgICAvKiBEbyBub3RoaW5nIHNpbmNlIFJTUCB2MyBtZXNzYWdlcyB3aWxsIG5vdCBjb250YWluIHRoZSBcInN1YnNjcmliZWRcIiBwcm9wZXJ0eS4gKi9cbiAgICB9O1xuICAgIHJldHVybiBSb29tVjM7XG59KFJvb21WMikpO1xubW9kdWxlLmV4cG9ydHMgPSBSb29tVjM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb29tLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTWVkaWFTaWduYWxpbmcgPSByZXF1aXJlKCcuLi92Mi9tZWRpYXNpZ25hbGluZycpO1xudmFyIFRyYWNrU3Vic2NyaXB0aW9uc1NpZ25hbGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJhY2tTdWJzY3JpcHRpb25zU2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBUcmFja1N1YnNjcmlwdGlvbnNTaWduYWxpbmd9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYWNrU3Vic2NyaXB0aW9uc1NpZ25hbGluZyhnZXRSZWNlaXZlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBnZXRSZWNlaXZlciwgJ3RyYWNrX3N1YnNjcmlwdGlvbnMnLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2N1cnJlbnRSZXZpc2lvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbG9nID0gX3RoaXMuX2xvZztcbiAgICAgICAgX3RoaXMub24oJ3JlYWR5JywgZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKF90aGlzLmNoYW5uZWwgKyBcIiB0cmFuc3BvcnQgcmVhZHlcIik7XG4gICAgICAgICAgICB0cmFuc3BvcnQub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgX3RoaXMuY2hhbm5lbDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVJbmNvbWluZ01lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiVW5rbm93biBcIiArIF90aGlzLmNoYW5uZWwgKyBcIiBNU1AgbWVzc2FnZSB0eXBlOlwiLCBtZXNzYWdlLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogd2UgcmVjZWl2ZSByZWFkeSBtZXNzYWdlIGV2ZXJ5IHRpbWVcbiAgICAgICAgICAgIC8vIE1TUCBjaGFubmVsIGlzIGVzdGFibGlzaGVkLiBUaGF0IG1lYW5zIGF0IHN0YXJ0dXAgYW5kIGF0IGV2ZXJ5IFZNUy1mYWlsb3Zlci5cbiAgICAgICAgICAgIGlmIChfdGhpcy5fY3VycmVudFJldmlzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4oJ3Jlc2V0dGluZyBjdXJyZW50IHZlcnNpb24gYWZ0ZXIgVk1TIGZhaWxvdmVyJywgX3RoaXMuX2N1cnJlbnRSZXZpc2lvbik7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2N1cnJlbnRSZXZpc2lvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHJhY2tTdWJzY3JpcHRpb25zU2lnbmFsaW5nLnByb3RvdHlwZS5faGFuZGxlSW5jb21pbmdNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgbG9nID0gX2EuX2xvZywgY3VycmVudFJldmlzaW9uID0gX2EuX2N1cnJlbnRSZXZpc2lvbjtcbiAgICAgICAgdmFyIF9iID0gbWVzc2FnZS5kYXRhLCBkYXRhID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2IsIF9jID0gbWVzc2FnZS5lcnJvcnMsIGVycm9ycyA9IF9jID09PSB2b2lkIDAgPyB7fSA6IF9jLCBfZCA9IG1lc3NhZ2UubWVkaWEsIG1lZGlhID0gX2QgPT09IHZvaWQgMCA/IHt9IDogX2QsIHJldmlzaW9uID0gbWVzc2FnZS5yZXZpc2lvbjtcbiAgICAgICAgLy8gVE9ETyhtbWFsYXZhbGxpKTogUmVtb3ZlIHRoaXMgb25jZSBTRlUgc2VuZHMgcmV2aXNpb24gYXMgaW50ZWdlciBpbnN0ZWFkIG9mIHN0cmluZy5cbiAgICAgICAgdmFyIHJldmlzaW9uTnVtYmVyID0gTnVtYmVyKHJldmlzaW9uKTtcbiAgICAgICAgaWYgKGN1cnJlbnRSZXZpc2lvbiAhPT0gbnVsbCAmJiBjdXJyZW50UmV2aXNpb24gPj0gcmV2aXNpb25OdW1iZXIpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiSWdub3JpbmcgaW5jb21pbmcgXCIgKyB0aGlzLmNoYW5uZWwgKyBcIiBtZXNzYWdlIGFzIFwiICsgY3VycmVudFJldmlzaW9uICsgXCIgKGN1cnJlbnQgcmV2aXNpb24pID49IFwiICsgcmV2aXNpb24gKyBcIiAoaW5jb21pbmcgcmV2aXNpb24pXCIpO1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwiSWdub3JlZCBpbmNvbWluZyBcIiArIHRoaXMuY2hhbm5lbCArIFwiIG1lc3NhZ2U6XCIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZy5kZWJ1ZyhcIkluY29taW5nIFwiICsgdGhpcy5jaGFubmVsICsgXCIgTVNQIG1lc3NhZ2U6XCIsIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9jdXJyZW50UmV2aXNpb24gPSByZXZpc2lvbk51bWJlcjtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJywgbWVkaWEsIGRhdGEsIGVycm9ycyk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhY2tTdWJzY3JpcHRpb25zU2lnbmFsaW5nO1xufShNZWRpYVNpZ25hbGluZykpO1xubW9kdWxlLmV4cG9ydHMgPSBUcmFja1N1YnNjcmlwdGlvbnNTaWduYWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFja3N1YnNjcmlwdGlvbnNzaWduYWxpbmcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xuICAgIHJldHVybiB0bztcbn07XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbi8qKlxuICoge0BsaW5rIFN0YXRlTWFjaGluZX0gcmVwcmVzZW50cyBhIHN0YXRlIG1hY2hpbmUuIFRoZSBzdGF0ZSBtYWNoaW5lIHN1cHBvcnRzIGFcbiAqIHJlZW50cmFudCBsb2NraW5nIG1lY2hhbmlzbSB0byBhbGxvdyBhc3luY2hyb25vdXMgc3RhdGUgdHJhbnNpdGlvbnMgdG8gZW5zdXJlXG4gKiB0aGV5IGhhdmUgbm90IGJlZW4gcHJlZW1wdGVkLiBDYWxscyB0byB7QGxpbmsgU3RhdGVNYWNoaW5lI3Rha2VMb2NrfSBhcmVcbiAqIGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaW4gRklGTyBvcmRlci5cbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0xvY2tlZCAtIHdoZXRoZXIgb3Igbm90IHRoZSB7QGxpbmsgU3RhdGVNYWNoaW5lfSBpc1xuICogICBsb2NrZWQgcGVyZm9ybWluZyBhc3luY2hyb25vdXMgc3RhdGUgdHJhbnNpdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gdGhlIGN1cnJlbnQgc3RhdGVcbiAqIEBlbWl0cyB7QGxpbmsgU3RhdGVNYWNoaW5lI3N0YXRlQ2hhbmdlZH1cbiAqL1xudmFyIFN0YXRlTWFjaGluZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RhdGVNYWNoaW5lLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBTdGF0ZU1hY2hpbmV9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbml0aWFsU3RhdGUgLSB0aGUgaW50aWlhbCBzdGF0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGF0ZU1hY2hpbmUoaW5pdGlhbFN0YXRlLCBzdGF0ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgdmFyIGxvY2sgPSBudWxsO1xuICAgICAgICB2YXIgc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgIHN0YXRlcyA9IHRyYW5zZm9ybVN0YXRlcyhzdGF0ZXMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2xvY2s6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2s7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBsb2NrID0gX2xvY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZWFjaGFibGVTdGF0ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVhY2hhYmxlKHN0YXRlcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc3RhdGU6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gX3N0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc3RhdGVzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0YXRlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF93aGVuRGVmZXJyZWRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzTG9ja2VkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2sgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIF90aGlzLl93aGVuRGVmZXJyZWRzLmZvckVhY2goZnVuY3Rpb24gKGRlZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQud2hlbihzdGF0ZSwgZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB3aG9zZSBleGVjdXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCBzdGF0ZSBjaGFuZ2UuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihzdGF0ZTogc3RyaW5nLCByZXNvbHZlOiBmdW5jdGlvbiwgcmVqZWN0OiBmdW5jdGlvbik6IHZvaWR9IHdoZW5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48Kj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTdGF0ZU1hY2hpbmUucHJvdG90eXBlLl93aGVuUHJvbWlzZSA9IGZ1bmN0aW9uICh3aGVuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygd2hlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignd2hlbigpIGV4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbicpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG4gICAgICAgIGRlZmVycmVkLndoZW4gPSB3aGVuO1xuICAgICAgICB0aGlzLl93aGVuRGVmZXJyZWRzLmFkZChkZWZlcnJlZCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIF90aGlzLl93aGVuRGVmZXJyZWRzLmRlbGV0ZShkZWZlcnJlZCk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5fd2hlbkRlZmVycmVkcy5kZWxldGUoZGVmZXJyZWQpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdGFrZXMgYSBsb2NrIGFuZCBwYXNzZXMgdGhlIHtAbGluayBTdGF0ZU1hY2hpbmUjS2V5fSB0byB5b3VyXG4gICAgICogdHJhbnNpdGlvbiBmdW5jdGlvbi4gWW91IG1heSBwZXJmb3JtIHplcm8gb3IgbW9yZSBzdGF0ZSB0cmFuc2l0aW9ucyBpbiB5b3VyXG4gICAgICogdHJhbnNpdGlvbiBmdW5jdGlvbiwgYnV0IHlvdSBzaG91bGQgY2hlY2sgZm9yIHByZWVtcHRpb24gaW4gZWFjaCB0aWNrLiBZb3VcbiAgICAgKiBtYXkgYWxzbyByZWVudGVyIHRoZSBsb2NrLiBPbmNlIHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IHlvdXIgdHJhbnNpdGlvblxuICAgICAqIGZ1bmN0aW9uIHJlc29sdmVzIG9yIHJlamVjdHMsIHRoaXMgbWV0aG9kIHJlbGVhc2VzIHRoZSBsb2NrIGl0IGFjcXVpcmVkIGZvclxuICAgICAqIHlvdS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIGEgbmFtZSBmb3IgdGhlIGxvY2tcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFN0YXRlTWFjaGluZSNLZXkpOiBQcm9taXNlfSB0cmFuc2l0aW9uRnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICAvLyBOT1RFKG1yb2JlcnRzKTogVGhpcyBtZXRob2QgaXMgbmFtZWQgYWZ0ZXIgYSBIYXNrZWxsIGZ1bmN0aW9uOlxuICAgIC8vIGh0dHBzOi8vaGFja2FnZS5oYXNrZWxsLm9yZy9wYWNrYWdlL2Jhc2UtNC44LjIuMC9kb2NzL0NvbnRyb2wtRXhjZXB0aW9uLmh0bWwjdjpicmFja2V0XG4gICAgU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5icmFja2V0ID0gZnVuY3Rpb24gKG5hbWUsIHRyYW5zaXRpb25GdW5jdGlvbikge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGZ1bmN0aW9uIHJlbGVhc2VMb2NrKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5oYXNMb2NrKGtleSkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbGVhc2VMb2NrQ29tcGxldGVseShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGFrZUxvY2sobmFtZSkudGhlbihmdW5jdGlvbiBnb3RLZXkoX2tleSkge1xuICAgICAgICAgICAga2V5ID0gX2tleTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9uRnVuY3Rpb24oa2V5KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiBzdWNjZXNzKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sIHJlbGVhc2VMb2NrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgb3Igbm90IGEge0BsaW5rIFN0YXRlTWFjaGluZSNLZXl9IG1hdGNoZXMgdGhlIGxvY2suXG4gICAgICogQHBhcmFtIHtTdGF0ZU1hY2hpbmUjS2V5fSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBTdGF0ZU1hY2hpbmUucHJvdG90eXBlLmhhc0xvY2sgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NrID09PSBrZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcmVlbXB0IGFueSBwZW5kaW5nIHN0YXRlIHRyYW5zaXRpb25zIGFuZCBpbW1lZGlhdGVseSB0cmFuc2l0aW9uIHRvIHRoZSBuZXdcbiAgICAgKiBzdGF0ZS4gSWYgYSBsb2NrIG5hbWUgaXMgc3BlY2lmaWVkLCB0YWtlIHRoZSBsb2NrIGFuZCByZXR1cm4gdGhlXG4gICAgICoge0BsaW5rIFN0YXRlTWFjaGluZSNLZXl9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdTdGF0ZVxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gW25hbWU9bnVsbF0gLSBhIG5hbWUgZm9yIHRoZSBsb2NrXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gW3BheWxvYWQ9W11dXG4gICAgICogQHJldHVybnMgez9TdGF0ZU1hY2hpbmUjS2V5fVxuICAgICAqL1xuICAgIFN0YXRlTWFjaGluZS5wcm90b3R5cGUucHJlZW1wdCA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwgbmFtZSwgcGF5bG9hZCkge1xuICAgICAgICAvLyAxLiBDaGVjayB0aGF0IHRoZSBuZXcgc3RhdGUgaXMgdmFsaWQuXG4gICAgICAgIGlmICghaXNWYWxpZFRyYW5zaXRpb24odGhpcy5fc3RhdGVzLCB0aGlzLnN0YXRlLCBuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0cmFuc2l0aW9uIGZyb20gXFxcIlwiICsgdGhpcy5zdGF0ZSArIFwiXFxcIiB0byBcXFwiXCIgKyBuZXdTdGF0ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAyLiBSZWxlYXNlIHRoZSBvbGQgbG9jaywgaWYgYW55LlxuICAgICAgICB2YXIgb2xkTG9jaztcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIG9sZExvY2sgPSB0aGlzLl9sb2NrO1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gVGFrZSB0aGUgbG9jaywgaWYgcmVxdWVzdGVkLlxuICAgICAgICB2YXIga2V5ID0gbnVsbDtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGtleSA9IHRoaXMudGFrZUxvY2tTeW5jKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDQuIElmIGEgbG9jayB3YXNuJ3QgcmVxdWVzdGVkLCB0YWtlIGEgXCJwcmVlbXB0aW9uXCIgbG9jayBpbiBvcmRlciB0b1xuICAgICAgICAvLyBtYWludGFpbiBGSUZPIG9yZGVyIG9mIHRob3NlIHRha2luZyBsb2Nrcy5cbiAgICAgICAgdmFyIHByZWVtcHRpb25LZXkgPSBrZXkgPyBudWxsIDogdGhpcy50YWtlTG9ja1N5bmMoJ3ByZWVtcHRpb24nKTtcbiAgICAgICAgLy8gNS4gVHJhbnNpdGlvbi5cbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKG5ld1N0YXRlLCBrZXkgfHwgcHJlZW1wdGlvbktleSwgcGF5bG9hZCk7XG4gICAgICAgIC8vIDYuIFByZWVtcHQgYW55b25lIGJsb2NrZWQgb24gdGhlIG9sZCBsb2NrLlxuICAgICAgICBpZiAob2xkTG9jaykge1xuICAgICAgICAgICAgb2xkTG9jay5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4gUmVsZWFzZSB0aGUgXCJwcmVlbXB0aW9uXCIgbG9jaywgaWYgd2UgdG9vayBpdC5cbiAgICAgICAgaWYgKHByZWVtcHRpb25LZXkpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZUxvY2socHJlZW1wdGlvbktleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgYSBsb2NrLiBUaGlzIG1ldGhvZCBzdWNjZWVkcyBvbmx5IGlmIHRoZSB7QGxpbmsgU3RhdGVNYWNoaW5lfSBpc1xuICAgICAqIHN0aWxsIGxvY2tlZCBhbmQgaGFzIG5vdCBiZWVuIHByZWVtcHRlZC5cbiAgICAgKiBAcGFyYW0ge1N0YXRlTWFjaGluZSNLZXl9IGtleVxuICAgICAqIEB0aHJvd3MgRXJyb3JcbiAgICAgKi9cbiAgICBTdGF0ZU1hY2hpbmUucHJvdG90eXBlLnJlbGVhc2VMb2NrID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZWxlYXNlIHRoZSBsb2NrIGZvciBcIiArIGtleS5uYW1lICsgXCIgYmVjYXVzZSB0aGUgU3RhdGVNYWNoaW5lIGlzIG5vdCBsb2NrZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGFzTG9jayhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVsZWFzZSB0aGUgbG9jayBmb3IgXCIgKyBrZXkubmFtZSArIFwiIGJlY2F1c2UgXCIgKyB0aGlzLl9sb2NrLm5hbWUgKyBcIiBoYXMgdGhlIGxvY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleS5kZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IG51bGw7XG4gICAgICAgICAgICBrZXkucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5LmRlcHRoLS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgYSBsb2NrIGNvbXBsZXRlbHksIGV2ZW4gaWYgaXQgaGFzIGJlZW4gcmVlbnRlcmVkLiBUaGlzIG1ldGhvZFxuICAgICAqIHN1Y2NlZWRzIG9ubHkgaWYgdGhlIHtAbGluayBTdGF0ZU1hY2hpbmV9IGlzIHN0aWxsIGxvY2tlZCBhbmQgaGFzIG5vdCBiZWVuXG4gICAgICogcHJlZW1wdGVkLlxuICAgICAqIEBwYXJhbSB7U3RhdGVNYWNoaW5lI0tleX0ga2V5XG4gICAgICogQHRocm93cyBFcnJvclxuICAgICAqL1xuICAgIFN0YXRlTWFjaGluZS5wcm90b3R5cGUucmVsZWFzZUxvY2tDb21wbGV0ZWx5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZWxlYXNlIHRoZSBsb2NrIGZvciBcIiArIGtleS5uYW1lICsgXCIgYmVjYXVzZSB0aGUgU3RhdGVNYWNoaW5lIGlzIG5vdCBsb2NrZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGFzTG9jayhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVsZWFzZSB0aGUgbG9jayBmb3IgXCIgKyBrZXkubmFtZSArIFwiIGJlY2F1c2UgXCIgKyB0aGlzLl9sb2NrLm5hbWUgKyBcIiBoYXMgdGhlIGxvY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAga2V5LmRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5fbG9jayA9IG51bGw7XG4gICAgICAgIGtleS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUYWtlIGEgbG9jaywgcmV0dXJuaW5nIGEgUHJvbWlzZSBmb3IgdGhlIHtAbGluayBTdGF0ZU1hY2hpbmUjS2V5fS4gWW91IHNob3VsZFxuICAgICAqIHRha2UgYSBsb2NrIGFueXRpbWUgeW91IGludGVuZCB0byBwZXJmb3JtIGFzeW5jaHJvbm91cyB0cmFuc2l0aW9ucy4gQ2FsbHMgdG9cbiAgICAgKiB0aGlzIG1ldGhvZCBhcmUgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBpbiBGSUZPIG9yZGVyLiBZb3UgbWF5IHJlZW50ZXJcbiAgICAgKiBhIGxvY2sgYnkgcGFzc2luZyBpdHMge0BsaW5rIFN0YXRlTWFjaGluZSNLZXl9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFN0YXRlTWFjaGluZSNLZXl9IG5hbWVPcktleSAtIGEgbmFtZSBmb3IgdGhlIGxvY2sgb3IgYW5cbiAgICAgKiBleGlzdGluZyB7QGxpbmsgU3RhdGVNYWNoaW5lI0tleX1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fVxuICAgICAqL1xuICAgIFN0YXRlTWFjaGluZS5wcm90b3R5cGUudGFrZUxvY2sgPSBmdW5jdGlvbiAobmFtZU9yS2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFJlZW50cmFudCBsb2NrXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZU9yS2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFyIGtleV8xID0gbmFtZU9yS2V5O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy50YWtlTG9ja1N5bmMoa2V5XzEpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5ldyBsb2NrXG4gICAgICAgIHZhciBuYW1lID0gbmFtZU9yS2V5O1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdmFyIHRha2VMb2NrID0gdGhpcy50YWtlTG9jay5iaW5kKHRoaXMsIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2sucHJvbWlzZS50aGVuKHRha2VMb2NrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudGFrZUxvY2tTeW5jKG5hbWUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRha2UgYSBsb2NrLCByZXR1cm5pbmcgdGhlIHtATGluayBTdGF0ZU1hY2hpbmUjS2V5fS4gVGhpcyBtZXRob2QgdGhyb3dzIGlmXG4gICAgICogdGhlIHtAbGluayBTdGF0ZU1hY2hpbmV9IGlzIGxvY2tlZCBvciB0aGUgd3Jvbmcge0BsaW5rIFN0YXRlTWFjaGluZSNLZXl9IGlzXG4gICAgICogcHJvdmlkZWQuIFlvdSBtYXkgcmVlbnRlciBhIGxvY2sgYnkgcGFzc2luZyBpdHMge0BsaW5rIFN0YXRlTWFjaGluZSNLZXl9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFN0YXRlTWFjaGluZSNLZXl9IG5hbWVPcktleSAtIGEgbmFtZSBmb3IgdGhlIGxvY2sgb3IgYW5cbiAgICAgKiBleGlzdGluZyB7QGxpbmsgU3RhdGVNYWNoaW5lI0tleX1cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEB0aHJvd3MgRXJyb3JcbiAgICAgKi9cbiAgICBTdGF0ZU1hY2hpbmUucHJvdG90eXBlLnRha2VMb2NrU3luYyA9IGZ1bmN0aW9uIChuYW1lT3JLZXkpIHtcbiAgICAgICAgdmFyIGtleSA9IHR5cGVvZiBuYW1lT3JLZXkgPT09ICdzdHJpbmcnID8gbnVsbCA6IG5hbWVPcktleTtcbiAgICAgICAgdmFyIG5hbWUgPSBrZXkgPyBrZXkubmFtZSA6IG5hbWVPcktleTtcbiAgICAgICAgaWYgKGtleSAmJiAhdGhpcy5oYXNMb2NrKGtleSkgfHwgIWtleSAmJiB0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgdGFrZSB0aGUgbG9jayBmb3IgXCIgKyBuYW1lICsgXCIgYmVjYXVzZSB0aGUgbG9jayBmb3IgXCIgKyB0aGlzLl9sb2NrLm5hbWUgKyBcIiB3YXMgbm90IHJlbGVhc2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlZW50cmFudCBsb2NrXG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGtleS5kZXB0aCsrO1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZXcgbG9ja1xuICAgICAgICB2YXIgbG9jayA9IG1ha2VMb2NrKG5hbWUpO1xuICAgICAgICB0aGlzLl9sb2NrID0gbG9jaztcbiAgICAgICAgcmV0dXJuIGxvY2s7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9uIHRvIGEgbmV3IHN0YXRlLiBJZiB0aGUge0BsaW5rIFN0YXRlTWFjaGluZX0gaXMgbG9ja2VkLCB5b3UgbXVzdFxuICAgICAqIHByb3ZpZGUgdGhlIHtAbGluayBTdGF0ZU1hY2hpbmUjS2V5fS4gQW4gaW52YWxpZCBzdGF0ZSBvciB0aGUgd3JvbmdcbiAgICAgKiB7QGxpbmsgU3RhdGVNYWNoaW5lI0tleX0gd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3U3RhdGVcbiAgICAgKiBAcGFyYW0gez9TdGF0ZU1hY2hpbmUjS2V5fSBba2V5PW51bGxdXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gW3BheWxvYWQ9W11dXG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICovXG4gICAgU3RhdGVNYWNoaW5lLnByb3RvdHlwZS50cmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlLCBrZXksIHBheWxvYWQpIHtcbiAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQgfHwgW107XG4gICAgICAgIC8vIDEuIElmIHdlJ3JlIGxvY2tlZCwgcmVxdWlyZWQgdGhlIGtleS5cbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIHRoZSBrZXkgaW4gb3JkZXIgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICd0cmFuc2l0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5oYXNMb2NrKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgdHJhbnNpdGlvbiB1c2luZyB0aGUga2V5IGZvciBcIiArIGtleS5uYW1lICsgXCIgYmVjYXVzZSBcIiArIHRoaXMuX2xvY2submFtZSArIFwiIGhhcyB0aGUgbG9ja1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBwcm92aWRlZCBmb3IgXCIgKyBrZXkubmFtZSArIFwiLCBidXQgdGhlIFN0YXRlTWFjaGluZSB3YXMgbm90IGxvY2tlZCAocG9zc2libHkgZHVlIHRvIHByZWVtcHRpb24pXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDIuIENoZWNrIHRoYXQgdGhlIG5ldyBzdGF0ZSBpcyB2YWxpZC5cbiAgICAgICAgaWYgKCFpc1ZhbGlkVHJhbnNpdGlvbih0aGlzLl9zdGF0ZXMsIHRoaXMuc3RhdGUsIG5ld1N0YXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRyYW5zaXRpb24gZnJvbSBcXFwiXCIgKyB0aGlzLnN0YXRlICsgXCJcXFwiIHRvIFxcXCJcIiArIG5ld1N0YXRlICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuIFVwZGF0ZSB0aGUgc3RhdGUgYW5kIGVtaXQgYW4gZXZlbnQuXG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoWydzdGF0ZUNoYW5nZWQnLCBuZXdTdGF0ZV0uY29uY2F0KHBheWxvYWQpKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byB0cmFuc2l0aW9uIHRvIGEgbmV3IHN0YXRlLiBVbmxpa2Uge0BsaW5rIFN0YXRlTWFjaGluZSN0cmFuc2l0aW9ufSxcbiAgICAgKiB0aGlzIG1ldGhvZCBkb2VzIG5vdCB0aHJvdy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3U3RhdGVcbiAgICAgKiBAcGFyYW0gez9TdGF0ZU1hY2hpbmUjS2V5fSBba2V5PW51bGxdXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gW3BheWxvYWQ9W11dXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgU3RhdGVNYWNoaW5lLnByb3RvdHlwZS50cnlUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlLCBrZXksIHBheWxvYWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbihuZXdTdGF0ZSwga2V5LCBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSB7QGxpbmsgU3RhdGVNYWNoaW5lfSB0cmFuc2l0aW9ucyB0b1xuICAgICAqIHRoZSBzcGVjaWZpZWQgc3RhdGUuIElmIHRoZSB7QGxpbmsgU3RhdGVNYWNoaW5lfSB0cmFuc2l0aW9ucyBzdWNoIHRoYXQgdGhlXG4gICAgICogcmVxdWVzdGVkIHN0YXRlIGJlY29tZXMgdW5yZWFjaGFibGUsIHRoZSBQcm9taXNlIHJlamVjdHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dGhpcz59XG4gICAgICovXG4gICAgU3RhdGVNYWNoaW5lLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNWYWxpZFRyYW5zaXRpb24odGhpcy5fcmVhY2hhYmxlU3RhdGVzLCB0aGlzLnN0YXRlLCBzdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjcmVhdGVVbnJlYWNoYWJsZUVycm9yKHRoaXMuc3RhdGUsIHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3doZW5Qcm9taXNlKGZ1bmN0aW9uIChuZXdTdGF0ZSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNWYWxpZFRyYW5zaXRpb24oX3RoaXMuX3JlYWNoYWJsZVN0YXRlcywgbmV3U3RhdGUsIHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChjcmVhdGVVbnJlYWNoYWJsZUVycm9yKG5ld1N0YXRlLCBzdGF0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZU1hY2hpbmU7XG59KEV2ZW50RW1pdHRlcikpO1xuLyoqXG4gKiBAZXZlbnQgU3RhdGVNYWNoaW5lI3N0YXRlQ2hhbmdlZFxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1N0YXRlXG4gKi9cbi8qKlxuICogQ2hlY2sgaWYgYSB0cmFuc2l0aW9uIGlzIHZhbGlkLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TWFwPCosIFNldDwqPj59IGdyYXBoXG4gKiBAcGFyYW0geyp9IGZyb21cbiAqIEBwYXJhbSB7Kn0gdG9cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkVHJhbnNpdGlvbihncmFwaCwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gZ3JhcGguZ2V0KGZyb20pLmhhcyh0byk7XG59XG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFN0YXRlTWFjaGluZSNLZXlcbiAqL1xuZnVuY3Rpb24gbWFrZUxvY2sobmFtZSkge1xuICAgIHZhciBsb2NrID0gdXRpbC5kZWZlcigpO1xuICAgIGxvY2submFtZSA9IG5hbWU7XG4gICAgbG9jay5kZXB0aCA9IDA7XG4gICAgcmV0dXJuIGxvY2s7XG59XG4vKipcbiAqIENvbXB1dGUgdGhlIHRyYW5zaXRpdmUgY2xvc3VyZSBvZiBhIGdyYXBoIChpLmUuIHdoYXQgbm9kZXMgYXJlIHJlYWNoYWJsZSBmcm9tXG4gKiB3aGVyZSkuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtNYXA8KiwgU2V0PCo+Pn0gZ3JhcGhcbiAqIEByZXR1cm5zIHtNYXA8KiwgU2V0PCo+Pn1cbiAqL1xuZnVuY3Rpb24gcmVhY2hhYmxlKGdyYXBoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZ3JhcGgua2V5cygpKS5yZWR1Y2UoZnVuY3Rpb24gKG5ld0dyYXBoLCBmcm9tKSB7IHJldHVybiBuZXdHcmFwaC5zZXQoZnJvbSwgcmVhY2hhYmxlRnJvbShncmFwaCwgZnJvbSkpOyB9LCBuZXcgTWFwKCkpO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBTZXQgb2Ygbm9kZSByZWFjaGFibGUgZnJvbSBhIHBhcnRpY3VsYXIgbm9kZSBpbiB0aGUgZ3JhcGguXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtNYXA8KiwgU2V0PCo+Pn0gZ3JhcGhcbiAqIEBwYXJhbSB7Kn0gZnJvbVxuICogQHBhcmFtIHtTZXQ8Kj59IFt0b11cbiAqIEByZXR1cm5zIHtTZXQ8Kj59XG4gKi9cbmZ1bmN0aW9uIHJlYWNoYWJsZUZyb20oZ3JhcGgsIGZyb20sIHRvKSB7XG4gICAgdG8gPSB0byB8fCBuZXcgU2V0KCk7XG4gICAgZ3JhcGguZ2V0KGZyb20pLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCF0by5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgIHRvLmFkZChub2RlKTtcbiAgICAgICAgICAgIHJlYWNoYWJsZUZyb20oZ3JhcGgsIG5vZGUsIHRvKS5mb3JFYWNoKHRvLmFkZCwgdG8pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGVzKHN0YXRlcykge1xuICAgIHZhciBuZXdTdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yICh2YXIga2V5IGluIHN0YXRlcykge1xuICAgICAgICBuZXdTdGF0ZXMuc2V0KGtleSwgbmV3IFNldChzdGF0ZXNba2V5XSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3U3RhdGVzO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gXCJ1bnJlYWNoYWJsZSBzdGF0ZVwiIEVycm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGhlcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGVyZVxuICogQHJldHVybnMge0Vycm9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVVbnJlYWNoYWJsZUVycm9yKGhlcmUsIHRoZXJlKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIlxcXCJcIiArIHRoZXJlICsgXCJcXFwiIGNhbm5vdCBiZSByZWFjaGVkIGZyb20gXFxcIlwiICsgaGVyZSArIFwiXFxcIlwiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVNYWNoaW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVtYWNoaW5lLmpzLm1hcCIsIi8qIGVzbGludCBuby11bmRlZmluZWQ6MCAqL1xuJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcnx1bmRlZmluZWQ+fSB4c1xuICogQHJldHVybnMge251bWJlcnx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGF2ZXJhZ2UoeHMpIHtcbiAgICB4cyA9IHhzLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInOyB9KTtcbiAgICByZXR1cm4geHMubGVuZ3RoIDwgMSA/IHVuZGVmaW5lZCA6IHhzLnJlZHVjZShmdW5jdGlvbiAoeSwgeCkgeyByZXR1cm4geCArIHk7IH0pIC8geHMubGVuZ3RoO1xufVxubW9kdWxlLmV4cG9ydHMgPSBhdmVyYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXZlcmFnZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYXZhaWxhYmxlU2VuZF0gLSBicHMgKHVuZGVmaW5lZCBpbiBGaXJlZm94KVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlY3YgLSBicHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcnR0XSAtIHMgKHVuZGVmaW5lZCBpbiBGaXJlZm94KVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNlbmQgLSBicHNcbiAqL1xudmFyIEljZVJlcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4ge0BsaW5rIEljZVJlcG9ydH0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNlbmQgLSBicHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVjdiAtIGJwc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcnR0XSAtIHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2F2YWlsYWJsZVNlbmRdIC0gYnBzXG4gICAgICovXG4gICAgZnVuY3Rpb24gSWNlUmVwb3J0KHNlbmQsIHJlY3YsIGF2YWlsYWJsZVNlbmQsIHJ0dCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBhdmFpbGFibGVTZW5kOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXZhaWxhYmxlU2VuZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY3Y6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZWN2XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnR0OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcnR0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VuZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHNlbmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UlRDU3RhdHN9IG9sZGVyU3RhdHNcbiAgICAgKiBAcGFyYW0ge1JUQ1N0YXRzfSBuZXdlclN0YXRzXG4gICAgICogQHJldHVybnMge0ljZVJlcG9ydH1cbiAgICAgKi9cbiAgICBJY2VSZXBvcnQub2YgPSBmdW5jdGlvbiAob2xkZXJTdGF0cywgbmV3ZXJTdGF0cykge1xuICAgICAgICB2YXIgc2Vjb25kc0VsYXBzZWQgPSAobmV3ZXJTdGF0cy50aW1lc3RhbXAgLSBvbGRlclN0YXRzLnRpbWVzdGFtcCkgLyAxMDAwO1xuICAgICAgICB2YXIgZGVsdGFCeXRlc1NlbnQgPSBuZXdlclN0YXRzLmJ5dGVzU2VudCAtIG9sZGVyU3RhdHMuYnl0ZXNTZW50O1xuICAgICAgICB2YXIgZGVsdGFCeXRlc1JlY2VpdmVkID0gbmV3ZXJTdGF0cy5ieXRlc1JlY2VpdmVkIC0gb2xkZXJTdGF0cy5ieXRlc1JlY2VpdmVkO1xuICAgICAgICB2YXIgc2VuZCA9IHNlY29uZHNFbGFwc2VkID4gMFxuICAgICAgICAgICAgPyAoZGVsdGFCeXRlc1NlbnQgLyBzZWNvbmRzRWxhcHNlZCkgKiA4XG4gICAgICAgICAgICA6IDA7XG4gICAgICAgIHZhciByZWN2ID0gc2Vjb25kc0VsYXBzZWQgPiAwXG4gICAgICAgICAgICA/IChkZWx0YUJ5dGVzUmVjZWl2ZWQgLyBzZWNvbmRzRWxhcHNlZCkgKiA4XG4gICAgICAgICAgICA6IDA7XG4gICAgICAgIHZhciBhdmFpbGFibGVTZW5kID0gbmV3ZXJTdGF0cy5hdmFpbGFibGVPdXRnb2luZ0JpdHJhdGUsIHJ0dCA9IG5ld2VyU3RhdHMuY3VycmVudFJvdW5kVHJpcFRpbWU7XG4gICAgICAgIHJldHVybiBuZXcgSWNlUmVwb3J0KHNlbmQsIHJlY3YsIGF2YWlsYWJsZVNlbmQsIHJ0dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSWNlUmVwb3J0O1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gSWNlUmVwb3J0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWNlcmVwb3J0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBJY2VSZXBvcnQgPSByZXF1aXJlKCcuL2ljZXJlcG9ydCcpO1xuLyoqXG4gKiBAcHJvcGVydHkge0ljZVJlcG9ydH0gbGFzdFJlcG9ydFxuICogQHByb3BlcnR5IHs/UlRDU3RhdHN9IGxhc3RTdGF0c1xuICovXG52YXIgSWNlUmVwb3J0RmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4ge0BsaW5rIEljZVJlcG9ydEZhY3Rvcnl9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEljZVJlcG9ydEZhY3RvcnkoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGxhc3RSZXBvcnQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgSWNlUmVwb3J0KDAsIDApLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdFN0YXRzOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIHtAbGluayBJY2VSZXBvcnR9LlxuICAgICAqIEBwYXJhbSB7UlRDU3RhdHN9IG5ld2VyU3RhdHM7XG4gICAgICogQHJldHVybnMge0ljZVJlcG9ydH1cbiAgICAgKi9cbiAgICBJY2VSZXBvcnRGYWN0b3J5LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKG5ld2VyU3RhdHMpIHtcbiAgICAgICAgdmFyIG9sZGVyU3RhdHMgPSB0aGlzLmxhc3RTdGF0cztcbiAgICAgICAgdGhpcy5sYXN0U3RhdHMgPSBuZXdlclN0YXRzO1xuICAgICAgICBpZiAob2xkZXJTdGF0cykge1xuICAgICAgICAgICAgdmFyIHJlcG9ydCA9IG9sZGVyU3RhdHMuaWQgPT09IG5ld2VyU3RhdHMuaWRcbiAgICAgICAgICAgICAgICA/IEljZVJlcG9ydC5vZihvbGRlclN0YXRzLCBuZXdlclN0YXRzKVxuICAgICAgICAgICAgICAgIDogbmV3IEljZVJlcG9ydCgwLCAwKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlcG9ydCA9IHJlcG9ydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0UmVwb3J0O1xuICAgIH07XG4gICAgcmV0dXJuIEljZVJlcG9ydEZhY3Rvcnk7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBJY2VSZXBvcnRGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWNlcmVwb3J0ZmFjdG9yeS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIExvY2FsVHJhY2tTdGF0cyA9IHJlcXVpcmUoJy4vbG9jYWx0cmFja3N0YXRzJyk7XG4vKipcbiAqIFN0YXRpc3RpY3MgZm9yIGEge0BsaW5rIExvY2FsQXVkaW9UcmFja30uXG4gKiBAZXh0ZW5kcyBMb2NhbFRyYWNrU3RhdHNcbiAqIEBwcm9wZXJ0eSB7P0F1ZGlvTGV2ZWx9IGF1ZGlvTGV2ZWwgLSBJbnB1dCB7QGxpbmsgQXVkaW9MZXZlbH1cbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gaml0dGVyIC0gQXVkaW8gaml0dGVyIGluIG1pbGxpc2Vjb25kc1xuICovXG52YXIgTG9jYWxBdWRpb1RyYWNrU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvY2FsQXVkaW9UcmFja1N0YXRzLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFja0lkIC0ge0BsaW5rIExvY2FsQXVkaW9UcmFja30gSURcbiAgICAgKiBAcGFyYW0ge1N0YW5kYXJkaXplZFRyYWNrU3RhdHNSZXBvcnR9IHN0YXRzUmVwb3J0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBwcmVwYXJlRm9ySW5zaWdodHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2NhbEF1ZGlvVHJhY2tTdGF0cyh0cmFja0lkLCBzdGF0c1JlcG9ydCwgcHJlcGFyZUZvckluc2lnaHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYWNrSWQsIHN0YXRzUmVwb3J0LCBwcmVwYXJlRm9ySW5zaWdodHMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBhdWRpb0xldmVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHR5cGVvZiBzdGF0c1JlcG9ydC5hdWRpb0lucHV0TGV2ZWwgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdHNSZXBvcnQuYXVkaW9JbnB1dExldmVsXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaml0dGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHR5cGVvZiBzdGF0c1JlcG9ydC5qaXR0ZXIgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdHNSZXBvcnQuaml0dGVyXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMb2NhbEF1ZGlvVHJhY2tTdGF0cztcbn0oTG9jYWxUcmFja1N0YXRzKSk7XG4vKipcbiAqIFRoZSBtYXhpbXVtIGFic29sdXRlIGFtcGxpdHVkZSBvZiBhIHNldCBvZiBhdWRpbyBzYW1wbGVzIGluIHRoZVxuICogcmFuZ2Ugb2YgMCB0byAzMjc2NyBpbmNsdXNpdmUuXG4gKiBAdHlwZWRlZiB7bnVtYmVyfSBBdWRpb0xldmVsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxBdWRpb1RyYWNrU3RhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbGF1ZGlvdHJhY2tzdGF0cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFRyYWNrU3RhdHMgPSByZXF1aXJlKCcuL3RyYWNrc3RhdHMnKTtcbi8qKlxuICogU3RhdGlzdGljcyBmb3IgYSB7QGxpbmsgTG9jYWxUcmFja30uXG4gKiBAZXh0ZW5kcyBUcmFja1N0YXRzXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IGJ5dGVzU2VudCAtIE51bWJlciBvZiBieXRlcyBzZW50XG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IHBhY2tldHNTZW50IC0gTnVtYmVyIG9mIHBhY2tldHMgc2VudFxuICogQHByb3BlcnR5IHs/bnVtYmVyfSByb3VuZFRyaXBUaW1lIC0gUm91bmQgdHJpcCB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICovXG52YXIgTG9jYWxUcmFja1N0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhbFRyYWNrU3RhdHMsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWNrSWQgLSB7QGxpbmsgTG9jYWxUcmFja30gSURcbiAgICAgKiBAcGFyYW0ge1N0YW5kYXJkaXplZFRyYWNrU3RhdHNSZXBvcnR9IHN0YXRzUmVwb3J0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBwcmVwYXJlRm9ySW5zaWdodHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2NhbFRyYWNrU3RhdHModHJhY2tJZCwgc3RhdHNSZXBvcnQsIHByZXBhcmVGb3JJbnNpZ2h0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0cmFja0lkLCBzdGF0c1JlcG9ydCkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIGJ5dGVzU2VudDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlb2Ygc3RhdHNSZXBvcnQuYnl0ZXNTZW50ID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICA/IHN0YXRzUmVwb3J0LmJ5dGVzU2VudFxuICAgICAgICAgICAgICAgICAgICA6IHByZXBhcmVGb3JJbnNpZ2h0cyA/IDAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYWNrZXRzU2VudDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlb2Ygc3RhdHNSZXBvcnQucGFja2V0c1NlbnQgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdHNSZXBvcnQucGFja2V0c1NlbnRcbiAgICAgICAgICAgICAgICAgICAgOiBwcmVwYXJlRm9ySW5zaWdodHMgPyAwIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm91bmRUcmlwVGltZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlb2Ygc3RhdHNSZXBvcnQucm91bmRUcmlwVGltZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBzdGF0c1JlcG9ydC5yb3VuZFRyaXBUaW1lXG4gICAgICAgICAgICAgICAgICAgIDogcHJlcGFyZUZvckluc2lnaHRzID8gMCA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTG9jYWxUcmFja1N0YXRzO1xufShUcmFja1N0YXRzKSk7XG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsVHJhY2tTdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsdHJhY2tzdGF0cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIExvY2FsVHJhY2tTdGF0cyA9IHJlcXVpcmUoJy4vbG9jYWx0cmFja3N0YXRzJyk7XG4vKipcbiAqIFN0YXRpc3RpY3MgZm9yIGEge0BsaW5rIExvY2FsVmlkZW9UcmFja30uXG4gKiBAZXh0ZW5kcyBMb2NhbFRyYWNrU3RhdHNcbiAqIEBwcm9wZXJ0eSB7P1ZpZGVvVHJhY2sjRGltZW5zaW9uc30gY2FwdHVyZURpbWVuc2lvbnMgLSBWaWRlbyBjYXB0dXJlIHJlc29sdXRpb25cbiAqIEBwcm9wZXJ0eSB7P1ZpZGVvVHJhY2sjRGltZW5zaW9uc30gZGltZW5zaW9ucyAtIFZpZGVvIGVuY29kaW5nIHJlc29sdXRpb25cbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gY2FwdHVyZUZyYW1lUmF0ZSAtIFZpZGVvIGNhcHR1cmUgZnJhbWUgcmF0ZVxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBmcmFtZVJhdGUgLSBWaWRlbyBlbmNvZGluZyBmcmFtZSByYXRlXG4gKi9cbnZhciBMb2NhbFZpZGVvVHJhY2tTdGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9jYWxWaWRlb1RyYWNrU3RhdHMsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWNrSWQgLSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSBJRFxuICAgICAqIEBwYXJhbSB7U3RhbmRhcmRpemVkVHJhY2tTdGF0c1JlcG9ydH0gc3RhdHNSZXBvcnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXBhcmVGb3JJbnNpZ2h0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvY2FsVmlkZW9UcmFja1N0YXRzKHRyYWNrSWQsIHN0YXRzUmVwb3J0LCBwcmVwYXJlRm9ySW5zaWdodHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhY2tJZCwgc3RhdHNSZXBvcnQsIHByZXBhcmVGb3JJbnNpZ2h0cykgfHwgdGhpcztcbiAgICAgICAgdmFyIGNhcHR1cmVEaW1lbnNpb25zID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0c1JlcG9ydC5mcmFtZVdpZHRoSW5wdXQgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICB0eXBlb2Ygc3RhdHNSZXBvcnQuZnJhbWVIZWlnaHRJbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNhcHR1cmVEaW1lbnNpb25zID0ge307XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYXB0dXJlRGltZW5zaW9ucywge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdGF0c1JlcG9ydC5mcmFtZVdpZHRoSW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlaWdodDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RhdHNSZXBvcnQuZnJhbWVIZWlnaHRJbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0c1JlcG9ydC5mcmFtZVdpZHRoU2VudCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzdGF0c1JlcG9ydC5mcmFtZUhlaWdodFNlbnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zID0ge307XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhkaW1lbnNpb25zLCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0YXRzUmVwb3J0LmZyYW1lV2lkdGhTZW50LFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0YXRzUmVwb3J0LmZyYW1lSGVpZ2h0U2VudCxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBjYXB0dXJlRGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjYXB0dXJlRGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXB0dXJlRnJhbWVSYXRlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHR5cGVvZiBzdGF0c1JlcG9ydC5mcmFtZVJhdGVJbnB1dCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBzdGF0c1JlcG9ydC5mcmFtZVJhdGVJbnB1dFxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyYW1lUmF0ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlb2Ygc3RhdHNSZXBvcnQuZnJhbWVSYXRlU2VudCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBzdGF0c1JlcG9ydC5mcmFtZVJhdGVTZW50XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMb2NhbFZpZGVvVHJhY2tTdGF0cztcbn0oTG9jYWxUcmFja1N0YXRzKSk7XG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsVmlkZW9UcmFja1N0YXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWx2aWRlb3RyYWNrc3RhdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBOZXR3b3JrUXVhbGl0eU1lZGlhU3RhdHMgPSByZXF1aXJlKCcuL25ldHdvcmtxdWFsaXR5bWVkaWFzdGF0cycpO1xuLyoqXG4gKiB7QGxpbmsgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzfSBmb3IgYSB7QGxpbmsgUGFydGljaXBhbnR9J3MgYXVkaW8uXG4gKi9cbnZhciBOZXR3b3JrUXVhbGl0eUF1ZGlvU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5ldHdvcmtRdWFsaXR5QXVkaW9TdGF0cywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTmV0d29ya1F1YWxpdHlBdWRpb1N0YXRzfS5cbiAgICAgKiBAcGFyYW0ge01lZGlhTGV2ZWxzfSBtZWRpYUxldmVsc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5ldHdvcmtRdWFsaXR5QXVkaW9TdGF0cyhtZWRpYUxldmVscykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbWVkaWFMZXZlbHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBOZXR3b3JrUXVhbGl0eUF1ZGlvU3RhdHM7XG59KE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0cykpO1xubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrUXVhbGl0eUF1ZGlvU3RhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrcXVhbGl0eWF1ZGlvc3RhdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBCYW5kd2lkdGggbmV0d29yayBxdWFsaXR5IHN0YXRpc3RpY3MuXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IGFjdHVhbCAtIHRoZSBhY3R1YWwgYmFuZHdpZHRoIHVzZWQsIGluIGJpdHMgcGVyIHNlY29uZFxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBhdmFpbGFibGUgLSBhbiBlc3RpbWF0ZSBvZiBhdmFpbGFibGUgdXNlYWJsZSBiYW5kd2lkdGgsIGluIGJpdHMgcGVyIHNlY29uZFxuICogQHByb3BlcnR5IHs/TmV0d29ya1F1YWxpdHlMZXZlbH0gbGV2ZWwgLSB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gZm9yIGJhbmR3aWR0aFxuICovXG52YXIgTmV0d29ya1F1YWxpdHlCYW5kd2lkdGhTdGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTmV0d29ya1F1YWxpdHlCYW5kd2lkdGhTdGF0c30uXG4gICAgICogQHBhcmFtIHtCYW5kd2lkdGhTdGF0c30gYmFuZHdpZHRoU3RhdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZXR3b3JrUXVhbGl0eUJhbmR3aWR0aFN0YXRzKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hLmFjdHVhbCwgYWN0dWFsID0gX2IgPT09IHZvaWQgMCA/IG51bGwgOiBfYiwgX2MgPSBfYS5hdmFpbGFibGUsIGF2YWlsYWJsZSA9IF9jID09PSB2b2lkIDAgPyBudWxsIDogX2MsIF9kID0gX2EubGV2ZWwsIGxldmVsID0gX2QgPT09IHZvaWQgMCA/IG51bGwgOiBfZDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgYWN0dWFsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGFjdHVhbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXZhaWxhYmxlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGF2YWlsYWJsZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGV2ZWw6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGV2ZWwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE5ldHdvcmtRdWFsaXR5QmFuZHdpZHRoU3RhdHM7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrUXVhbGl0eUJhbmR3aWR0aFN0YXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29ya3F1YWxpdHliYW5kd2lkdGhzdGF0cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEZyYWN0aW9uIGxvc3QgbmV0d29yayBxdWFsaXR5IHN0YXRpc3RpY3MuXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IGZyYWN0aW9uTG9zdCAtIHBhY2tldHMgbG9zdFxuICogQHByb3BlcnR5IHs/TmV0d29ya1F1YWxpdHlMZXZlbH0gbGV2ZWwgLSB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gZm9yIGZyYWN0aW9uIGxvc3RcbiAqL1xudmFyIE5ldHdvcmtRdWFsaXR5RnJhY3Rpb25Mb3N0U3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIE5ldHdvcmtRdWFsaXR5RnJhY3Rpb25Mb3N0U3RhdHN9LlxuICAgICAqIEBwYXJhbSB7RnJhY3Rpb25Mb3N0U3RhdHN9IGZyYWN0aW9uTG9zdFN0YXRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTmV0d29ya1F1YWxpdHlGcmFjdGlvbkxvc3RTdGF0cyhfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYS5mcmFjdGlvbkxvc3QsIGZyYWN0aW9uTG9zdCA9IF9iID09PSB2b2lkIDAgPyBudWxsIDogX2IsIF9jID0gX2EubGV2ZWwsIGxldmVsID0gX2MgPT09IHZvaWQgMCA/IG51bGwgOiBfYztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhY3Rpb25Mb3N0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZyYWN0aW9uTG9zdCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGV2ZWw6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGV2ZWwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE5ldHdvcmtRdWFsaXR5RnJhY3Rpb25Mb3N0U3RhdHM7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrUXVhbGl0eUZyYWN0aW9uTG9zdFN0YXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29ya3F1YWxpdHlmcmFjdGlvbmxvc3RzdGF0cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIExhdGVuY3kgbmV0d29yayBxdWFsaXR5IHN0YXRpc3RpY3MuXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IGppdHRlciAtIG1lZGlhIGppdHRlciBpbiBzZWNvbmRzXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IHJ0dCAtIHJvdW5kIHRyaXAgdGltZSBpbiBzZWNvbmRzXG4gKiBAcHJvcGVydHkgez9OZXR3b3JrUXVhbGl0eUxldmVsfSBsZXZlbCAtIHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfSBmb3IgbGF0ZW5jeVxuICovXG52YXIgTmV0d29ya1F1YWxpdHlMYXRlbmN5U3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIE5ldHdvcmtRdWFsaXR5TGF0ZW5jeVN0YXRzfS5cbiAgICAgKiBAcGFyYW0ge0xhdGVuY3lTdGF0c30gbGF0ZW5jeVN0YXRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTmV0d29ya1F1YWxpdHlMYXRlbmN5U3RhdHMoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2Euaml0dGVyLCBqaXR0ZXIgPSBfYiA9PT0gdm9pZCAwID8gbnVsbCA6IF9iLCBfYyA9IF9hLnJ0dCwgcnR0ID0gX2MgPT09IHZvaWQgMCA/IG51bGwgOiBfYywgX2QgPSBfYS5sZXZlbCwgbGV2ZWwgPSBfZCA9PT0gdm9pZCAwID8gbnVsbCA6IF9kO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBqaXR0ZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaml0dGVyLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydHQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcnR0LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZXZlbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsZXZlbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gTmV0d29ya1F1YWxpdHlMYXRlbmN5U3RhdHM7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrUXVhbGl0eUxhdGVuY3lTdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmtxdWFsaXR5bGF0ZW5jeXN0YXRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBOZXR3b3JrUXVhbGl0eVNlbmRTdGF0cyA9IHJlcXVpcmUoJy4vbmV0d29ya3F1YWxpdHlzZW5kc3RhdHMnKTtcbnZhciBOZXR3b3JrUXVhbGl0eVJlY3ZTdGF0cyA9IHJlcXVpcmUoJy4vbmV0d29ya3F1YWxpdHlyZWN2c3RhdHMnKTtcbi8qKlxuICogTmV0d29yayBxdWFsaXR5IHN0YXRpc3RpY3Mgc2hhcmVkIGJldHdlZW4gYSB7QGxpbmsgUGFydGljaXBhbnR9J3MgYXVkaW8gb3IgdmlkZW8uXG4gKiBAcHJvcGVydHkge05ldHdvcmtRdWFsaXR5TGV2ZWx9IHNlbmQgLSB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gb2YgdGhlXG4gKiAge0BsaW5rIFBhcnRpY2lwYW50fSdzIHB1Ymxpc2hlZCBhdWRpbyBvciB2aWRlb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlY3YgLSB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gb2YgdGhlXG4gKiAge0BsaW5rIFBhcnRpY2lwYW50fSdzIHN1YnNjcmliZWQgYXVkaW8gb3IgdmlkZW9cbiAqIEBwcm9wZXJ0eSB7P05ldHdvcmtRdWFsaXR5U2VuZE9yUmVjdlN0YXRzfSBzZW5kU3RhdHMgLSB7QGxpbmsgTmV0d29ya1F1YWxpdHlTZW5kT3JSZWN2U3RhdHN9XG4gKiAgIGJhc2VkIG9uIHdoaWNoIHtAbGluayBOZXR3b3JrUXVhbGl0eU1lZGlhU3RhdHN9PGNvZGUgc3R5bGU9XCJwYWRkaW5nOjAgMFwiPiNzZW5kPC9jb2RlPlxuICogICBpcyBjYWxjdWxhdGVkXG4gKiBAcHJvcGVydHkgez9OZXR3b3JrUXVhbGl0eVNlbmRPclJlY3ZTdGF0c30gcmVjdlN0YXRzIC0ge0BsaW5rIE5ldHdvcmtRdWFsaXR5U2VuZE9yUmVjdlN0YXRzfVxuICogICBiYXNlZCBvbiB3aGljaCB7QGxpbmsgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzfTxjb2RlIHN0eWxlPVwicGFkZGluZzowIDBcIj4jcmVjdjwvY29kZT5cbiAqICAgaXMgY2FsY3VsYXRlZFxuICovXG52YXIgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBOZXR3b3JrUXVhbGl0eU1lZGlhU3RhdHN9LlxuICAgICAqIEBwYXJhbSB7TWVkaWFMZXZlbHN9IG1lZGlhTGV2ZWxzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzKF9hKSB7XG4gICAgICAgIHZhciBzZW5kID0gX2Euc2VuZCwgcmVjdiA9IF9hLnJlY3YsIF9iID0gX2Euc2VuZFN0YXRzLCBzZW5kU3RhdHMgPSBfYiA9PT0gdm9pZCAwID8gbnVsbCA6IF9iLCBfYyA9IF9hLnJlY3ZTdGF0cywgcmVjdlN0YXRzID0gX2MgPT09IHZvaWQgMCA/IG51bGwgOiBfYztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgc2VuZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzZW5kLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWN2OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlY3YsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbmRTdGF0czoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzZW5kU3RhdHMgPyBuZXcgTmV0d29ya1F1YWxpdHlTZW5kU3RhdHMoc2VuZFN0YXRzKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY3ZTdGF0czoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiByZWN2U3RhdHMgPyBuZXcgTmV0d29ya1F1YWxpdHlSZWN2U3RhdHMocmVjdlN0YXRzKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0cztcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmtxdWFsaXR5bWVkaWFzdGF0cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIE5ldHdvcmtRdWFsaXR5U2VuZE9yUmVjdlN0YXRzID0gcmVxdWlyZSgnLi9uZXR3b3JrcXVhbGl0eXNlbmRvcnJlY3ZzdGF0cycpO1xuLyoqXG4gKiB7QGxpbmsgTmV0d29ya1F1YWxpdHlTZW5kT3JSZWN2U3RhdHN9IGJhc2VkIG9uIHdoaWNoIGEge0BsaW5rIFBhcnRpY2lwYW50fSdzXG4gKiB7QGxpbmsgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzfTxjb2RlIHN0eWxlPVwicGFkZGluZzowIDBcIj4jcmVjdjwvY29kZT4gaXMgY2FsY3VsYXRlZC5cbiAqL1xudmFyIE5ldHdvcmtRdWFsaXR5UmVjdlN0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXR3b3JrUXVhbGl0eVJlY3ZTdGF0cywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTmV0d29ya1F1YWxpdHlSZWN2U3RhdHN9LlxuICAgICAqIEBwYXJhbSB7U2VuZE9yUmVjdlN0YXRzfSBzZW5kT3JSZWN2U3RhdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZXR3b3JrUXVhbGl0eVJlY3ZTdGF0cyhzZW5kT3JSZWN2U3RhdHMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNlbmRPclJlY3ZTdGF0cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE5ldHdvcmtRdWFsaXR5UmVjdlN0YXRzO1xufShOZXR3b3JrUXVhbGl0eVNlbmRPclJlY3ZTdGF0cykpO1xubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrUXVhbGl0eVJlY3ZTdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmtxdWFsaXR5cmVjdnN0YXRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBOZXR3b3JrUXVhbGl0eUJhbmR3aWR0aFN0YXRzID0gcmVxdWlyZSgnLi9uZXR3b3JrcXVhbGl0eWJhbmR3aWR0aHN0YXRzJyk7XG52YXIgTmV0d29ya1F1YWxpdHlGcmFjdGlvbkxvc3RTdGF0cyA9IHJlcXVpcmUoJy4vbmV0d29ya3F1YWxpdHlmcmFjdGlvbmxvc3RzdGF0cycpO1xudmFyIE5ldHdvcmtRdWFsaXR5TGF0ZW5jeVN0YXRzID0gcmVxdWlyZSgnLi9uZXR3b3JrcXVhbGl0eWxhdGVuY3lzdGF0cycpO1xuLyoqXG4gKiBOZXR3b3JrIHF1YWxpdHkgc3RhdGlzdGljcyBzaGFyZWQgYmV0d2VlbiB7QGxpbmsgTmV0d29ya1F1YWxpdHlTZW5kU3RhdHN9IGFuZFxuICoge0BsaW5rIE5ldHdvcmtRdWFsaXR5UmVjdlN0YXRzfSBiYXNlZCBvbiB3aGljaCBhIHtAbGluayBQYXJ0aWNpcGFudH0nc1xuICoge0BsaW5rIE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0c308Y29kZSBzdHlsZT1cInBhZGRpbmc6MCAwXCI+I3NlbmQ8L2NvZGU+IG9yXG4gKiB7QGxpbmsgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzfTxjb2RlIHN0eWxlPVwicGFkZGluZzowIDBcIj4jcmVjdjwvY29kZT4gaXMgY2FsY3VsYXRlZC5cbiAqIEBwcm9wZXJ0eSB7P05ldHdvcmtRdWFsaXR5QmFuZHdpZHRoU3RhdHN9IGJhbmR3aWR0aCAtIGJhbmR3aWR0aCBzdGF0aXN0aWNzXG4gKiBAcHJvcGVydHkgez9OZXR3b3JrUXVhbGl0eUxhdGVuY3lTdGF0c30gbGF0ZW5jeSAtIGxhdGVuY3kgc3RhdGlzdGljc1xuICogQHByb3BlcnR5IHs/TmV0d29ya1F1YWxpdHlGcmFjdGlvbkxvc3RTdGF0c30gZnJhY3Rpb25Mb3N0IC0gZnJhY3Rpb24gbG9zdCBzdGF0aXN0aWNzXG4gKi9cbnZhciBOZXR3b3JrUXVhbGl0eVNlbmRPclJlY3ZTdGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTmV0d29ya1F1YWxpdHlTZW5kT3JSZWN2U3RhdHN9LlxuICAgICAqIEBwYXJhbSB7U2VuZE9yUmVjdlN0YXRzfSBzZW5kT3JSZWN2U3RhdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZXR3b3JrUXVhbGl0eVNlbmRPclJlY3ZTdGF0cyhfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYS5iYW5kd2lkdGgsIGJhbmR3aWR0aCA9IF9iID09PSB2b2lkIDAgPyBudWxsIDogX2IsIF9jID0gX2EuZnJhY3Rpb25Mb3N0LCBmcmFjdGlvbkxvc3QgPSBfYyA9PT0gdm9pZCAwID8gbnVsbCA6IF9jLCBfZCA9IF9hLmxhdGVuY3ksIGxhdGVuY3kgPSBfZCA9PT0gdm9pZCAwID8gbnVsbCA6IF9kO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBiYW5kd2lkdGg6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogYmFuZHdpZHRoID8gbmV3IE5ldHdvcmtRdWFsaXR5QmFuZHdpZHRoU3RhdHMoYmFuZHdpZHRoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyYWN0aW9uTG9zdDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmcmFjdGlvbkxvc3QgPyBuZXcgTmV0d29ya1F1YWxpdHlGcmFjdGlvbkxvc3RTdGF0cyhmcmFjdGlvbkxvc3QpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGF0ZW5jeToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsYXRlbmN5ID8gbmV3IE5ldHdvcmtRdWFsaXR5TGF0ZW5jeVN0YXRzKGxhdGVuY3kpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gTmV0d29ya1F1YWxpdHlTZW5kT3JSZWN2U3RhdHM7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrUXVhbGl0eVNlbmRPclJlY3ZTdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmtxdWFsaXR5c2VuZG9ycmVjdnN0YXRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTmV0d29ya1F1YWxpdHlTZW5kT3JSZWN2U3RhdHMgPSByZXF1aXJlKCcuL25ldHdvcmtxdWFsaXR5c2VuZG9ycmVjdnN0YXRzJyk7XG4vKipcbiAqIHtAbGluayBOZXR3b3JrUXVhbGl0eVNlbmRPclJlY3ZTdGF0c30gYmFzZWQgb24gd2hpY2ggYSB7QGxpbmsgUGFydGljaXBhbnR9J3NcbiAqIHtAbGluayBOZXR3b3JrUXVhbGl0eU1lZGlhU3RhdHN9PGNvZGUgc3R5bGU9XCJwYWRkaW5nOjAgMFwiPiNzZW5kPC9jb2RlPiBpcyBjYWxjdWxhdGVkLlxuICovXG52YXIgTmV0d29ya1F1YWxpdHlTZW5kU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5ldHdvcmtRdWFsaXR5U2VuZFN0YXRzLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBOZXR3b3JrUXVhbGl0eVNlbmRTdGF0c30uXG4gICAgICogQHBhcmFtIHtTZW5kT3JSZWN2U3RhdHN9IHNlbmRPclJlY3ZTdGF0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5ldHdvcmtRdWFsaXR5U2VuZFN0YXRzKHNlbmRPclJlY3ZTdGF0cykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc2VuZE9yUmVjdlN0YXRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTmV0d29ya1F1YWxpdHlTZW5kU3RhdHM7XG59KE5ldHdvcmtRdWFsaXR5U2VuZE9yUmVjdlN0YXRzKSk7XG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtRdWFsaXR5U2VuZFN0YXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29ya3F1YWxpdHlzZW5kc3RhdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE5ldHdvcmtRdWFsaXR5QXVkaW9TdGF0cyA9IHJlcXVpcmUoJy4vbmV0d29ya3F1YWxpdHlhdWRpb3N0YXRzJyk7XG52YXIgTmV0d29ya1F1YWxpdHlWaWRlb1N0YXRzID0gcmVxdWlyZSgnLi9uZXR3b3JrcXVhbGl0eXZpZGVvc3RhdHMnKTtcbi8qKlxuICogTmV0d29yayBxdWFsaXR5IHN0YXRpc3RpY3MgZm9yIGEge0BsaW5rIFBhcnRpY2lwYW50fS5cbiAqIEBwcm9wZXJ0eSB7TmV0d29ya1F1YWxpdHlMZXZlbH0gbGV2ZWwgLSB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gb2YgdGhlIHtAbGluayBQYXJ0aWNpcGFudH1cbiAqIEBwcm9wZXJ0eSB7P05ldHdvcmtRdWFsaXR5QXVkaW9TdGF0c30gYXVkaW8gLSB7QGxpbmsgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzfVxuICogICBmb3IgYXVkaW87IDxjb2RlPm51bGw8L2NvZGU+IGlmIHtAbGluayBOZXR3b3JrUXVhbGl0eVZlcmJvc2l0eX0gaXMge0BsaW5rIE5ldHdvcmtRdWFsaXR5VmVyYm9zaXR5fTxjb2RlIHN0eWxlPVwicGFkZGluZzowIDBcIj4jbWluaW1hbDwvY29kZT5cbiAqICAgb3IgYmVsb3dcbiAqIEBwcm9wZXJ0eSB7P05ldHdvcmtRdWFsaXR5VmlkZW9TdGF0c30gdmlkZW8gLSB7QGxpbmsgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzfVxuICogICBmb3IgdmlkZW87IDxjb2RlPm51bGw8L2NvZGU+IGlmIHtAbGluayBOZXR3b3JrUXVhbGl0eVZlcmJvc2l0eX0gaXMge0BsaW5rIE5ldHdvcmtRdWFsaXR5VmVyYm9zaXR5fTxjb2RlIHN0eWxlPVwicGFkZGluZzowIDBcIj4jbWluaW1hbDwvY29kZT5cbiAqICAgb3IgYmVsb3dcbiAqL1xudmFyIE5ldHdvcmtRdWFsaXR5U3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIE5ldHdvcmtRdWFsaXR5U3RhdHN9LlxuICAgICAqIEBwYXJhbSB7TmV0d29ya1F1YWxpdHlMZXZlbHN9IG5ldHdvcmtRdWFsaXR5TGV2ZWxzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTmV0d29ya1F1YWxpdHlTdGF0cyhfYSkge1xuICAgICAgICB2YXIgbGV2ZWwgPSBfYS5sZXZlbCwgYXVkaW8gPSBfYS5hdWRpbywgdmlkZW8gPSBfYS52aWRlbztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgbGV2ZWw6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGV2ZWwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF1ZGlvOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGF1ZGlvID8gbmV3IE5ldHdvcmtRdWFsaXR5QXVkaW9TdGF0cyhhdWRpbykgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aWRlbzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2aWRlbyA/IG5ldyBOZXR3b3JrUXVhbGl0eVZpZGVvU3RhdHModmlkZW8pIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gTmV0d29ya1F1YWxpdHlTdGF0cztcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtRdWFsaXR5U3RhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrcXVhbGl0eXN0YXRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzID0gcmVxdWlyZSgnLi9uZXR3b3JrcXVhbGl0eW1lZGlhc3RhdHMnKTtcbi8qKlxuICoge0BsaW5rIE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0c30gZm9yIGEge0BsaW5rIFBhcnRpY2lwYW50fSdzIHZpZGVvLlxuICovXG52YXIgTmV0d29ya1F1YWxpdHlWaWRlb1N0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXR3b3JrUXVhbGl0eVZpZGVvU3RhdHMsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIE5ldHdvcmtRdWFsaXR5VmlkZW9TdGF0c30uXG4gICAgICogQHBhcmFtIHtNZWRpYUxldmVsc30gbWVkaWFMZXZlbHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZXR3b3JrUXVhbGl0eVZpZGVvU3RhdHMobWVkaWFMZXZlbHMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG1lZGlhTGV2ZWxzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTmV0d29ya1F1YWxpdHlWaWRlb1N0YXRzO1xufShOZXR3b3JrUXVhbGl0eU1lZGlhU3RhdHMpKTtcbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya1F1YWxpdHlWaWRlb1N0YXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29ya3F1YWxpdHl2aWRlb3N0YXRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBSZWNlaXZlclJlcG9ydCA9IHJlcXVpcmUoJy4vcmVjZWl2ZXJyZXBvcnQnKTtcbnZhciBTZW5kZXJSZXBvcnQgPSByZXF1aXJlKCcuL3NlbmRlcnJlcG9ydCcpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFNlbmRlckFuZFJlY2VpdmVyUmVwb3J0c1xuICogQHByb3BlcnR5IHtBcnJheTxTZW5kZXJSZXBvcnQ+fSBzZW5kXG4gKiBAcHJvcGVydHkge0FycmF5PFJlY2VpdmVyUmVwb3J0Pn0gcmVjdlxuICovXG4vKipcbiAqIEBpbnRlcmZhY2UgU2VuZGVyQW5kUmVjZWl2ZXJTdW1tYXJ5XG4gKiBAcHJvcGVydHkge1NlbmRlclN1bW1hcnl9IHNlbmRcbiAqIEBwcm9wZXJ0eSB7UmVjZWl2ZXJTdW1tYXJ5fSByZWN2XG4gKi9cbi8qKlxuICogQGludGVyZmFjZSBQZWVyQ29ubmVjdGlvblN1bW1hcnlcbiAqIEBwcm9wZXJ0eSB7SWNlUmVwb3J0fSBpY2VcbiAqIEBwcm9wZXJ0eSB7U2VuZGVyU3VtbWFyeX0gc2VuZFxuICogQHByb3BlcnR5IHtSZWNlaXZlclN1bW1hcnl9IHJlY3ZcbiAqIEBwcm9wZXJ0eSB7U2VuZGVyQW5kUmVjZWl2ZXJTdW1tYXJ5fSBhdWRpb1xuICogQHByb3BlcnR5IHtTZW5kZXJBbmRSZWNlaXZlclN1bW1hcnl9IHZpZGVvXG4gKi9cbi8qKlxuICogQHByb3BlcnR5IHtJY2VSZXBvcnR9IGljZVxuICogQHJvcGVydHkge1NlbmRlckFuZFJlY2VpdmVyUmVwb3J0c30gYXVkaW9cbiAqIEByb3BlcnR5IHtTZW5kZXJBbmRSZWNlaXZlclJlcG9ydHN9IHZpZGVvXG4gKi9cbnZhciBQZWVyQ29ubmVjdGlvblJlcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUGVlckNvbm5lY3Rpb25SZXBvcnR9LlxuICAgICAqIEBwYXJhbSB7SWNlUmVwb3J0fSBpY2VcbiAgICAgKiBAcGFyYW0ge1NlbmRlckFuZFJlY2VpdmVyUmVwb3J0c30gYXVkaW9cbiAgICAgKiBAcGFyYW0ge1NlbmRlckFuZFJlY2VpdmVyUmVwb3J0c30gdmlkZW9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQZWVyQ29ubmVjdGlvblJlcG9ydChpY2UsIGF1ZGlvLCB2aWRlbykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBpY2U6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpY2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdWRpbzoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGF1ZGlvXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2aWRlb1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VtbWFyaXplIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25SZXBvcnR9IGJ5IHN1bW1hcml6aW5nIGl0c1xuICAgICAqIHtAbGluayBTZW5kZXJSZXBvcnR9cyBhbmQge0BsaW5rIFJlY2VpdmVyUmVwb3J0fXMuXG4gICAgICogQHJldHVybnMge1BlZXJDb25uZWN0aW9uU3VtbWFyeX1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblJlcG9ydC5wcm90b3R5cGUuc3VtbWFyaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VuZGVyUmVwb3J0cyA9IHRoaXMuYXVkaW8uc2VuZC5jb25jYXQodGhpcy52aWRlby5zZW5kKTtcbiAgICAgICAgdmFyIHNlbmQgPSBTZW5kZXJSZXBvcnQuc3VtbWFyaXplKHNlbmRlclJlcG9ydHMpO1xuICAgICAgICB2YXIgcmVjZWl2ZXJSZXBvcnRzID0gdGhpcy5hdWRpby5yZWN2LmNvbmNhdCh0aGlzLnZpZGVvLnJlY3YpO1xuICAgICAgICB2YXIgcmVjdiA9IFJlY2VpdmVyUmVwb3J0LnN1bW1hcml6ZShyZWNlaXZlclJlcG9ydHMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWNlOiB0aGlzLmljZSxcbiAgICAgICAgICAgIHNlbmQ6IHNlbmQsXG4gICAgICAgICAgICByZWN2OiByZWN2LFxuICAgICAgICAgICAgYXVkaW86IHtcbiAgICAgICAgICAgICAgICBzZW5kOiBTZW5kZXJSZXBvcnQuc3VtbWFyaXplKHRoaXMuYXVkaW8uc2VuZCksXG4gICAgICAgICAgICAgICAgcmVjdjogUmVjZWl2ZXJSZXBvcnQuc3VtbWFyaXplKHRoaXMuYXVkaW8ucmVjdilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aWRlbzoge1xuICAgICAgICAgICAgICAgIHNlbmQ6IFNlbmRlclJlcG9ydC5zdW1tYXJpemUodGhpcy52aWRlby5zZW5kKSxcbiAgICAgICAgICAgICAgICByZWN2OiBSZWNlaXZlclJlcG9ydC5zdW1tYXJpemUodGhpcy52aWRlby5yZWN2KVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFBlZXJDb25uZWN0aW9uUmVwb3J0O1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gUGVlckNvbm5lY3Rpb25SZXBvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZWVyY29ubmVjdGlvbnJlcG9ydC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICByZXR1cm4gdG87XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIGd1ZXNzQnJvd3NlciA9IHJlcXVpcmUoJy4uL3dlYnJ0Yy91dGlsJykuZ3Vlc3NCcm93c2VyO1xudmFyIEljZVJlcG9ydEZhY3RvcnkgPSByZXF1aXJlKCcuL2ljZXJlcG9ydGZhY3RvcnknKTtcbnZhciBQZWVyQ29ubmVjdGlvblJlcG9ydCA9IHJlcXVpcmUoJy4vcGVlcmNvbm5lY3Rpb25yZXBvcnQnKTtcbnZhciBSZWNlaXZlclJlcG9ydEZhY3RvcnkgPSByZXF1aXJlKCcuL3JlY2VpdmVycmVwb3J0ZmFjdG9yeScpO1xudmFyIFNlbmRlclJlcG9ydEZhY3RvcnkgPSByZXF1aXJlKCcuL3NlbmRlcnJlcG9ydGZhY3RvcnknKTtcbi8qKlxuICogQHR5cGVkZWYge3N0cmluZ30gVHJhY2tJZFxuICovXG4vKipcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IFN0YXRzSWRcbiAqL1xuLyoqXG4gKiBAaW50ZXJmYWNlIFNlbmRlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlXG4gKiBAcHJvcGVydHkge01hcDxTdGF0c0lkLCBTZW5kZXJSZXBvcnRGYWN0b3J5Pn0gYXVkaW9cbiAqIEBwcm9wZXJ0eSB7TWFwPFN0YXRzSWQsIFNlbmRlclJlcG9ydEZhY3Rvcnk+fSB2aWRlb1xuICovXG4vKipcbiAqIEBpbnRlcmZhY2UgUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZVxuICogQHByb3BlcnR5IHtNYXA8U3RhdHNJZCwgUmVjZWl2ZXJSZXBvcnRGYWN0b3J5Pn0gYXVkaW9cbiAqIEBwcm9wZXJ0eSB7TWFwPFN0YXRzSWQsIFJlY2VpdmVyUmVwb3J0RmFjdG9yeT59IHZpZGVvXG4gKi9cbi8qKlxuICogQGludGVyZmFjZSBTZW5kZXJBbmRSZWNlaXZlclJlcG9ydEZhY3Rvcmllc1xuICogQHByb3BlcnR5IHtNYXA8U3RhdHNJZCwgU2VuZGVyUmVwb3J0RmFjdG9yaWVzPn0gc2VuZFxuICogQHByb3BlcnR5IHtNYXA8U3RhdHNJZCwgUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXM+fSByZWN2XG4gKi9cbi8qKlxuICogQGludGVyZmFjZSB7U3RhdHNJZHNCeU1lZGlhVHlwZX1cbiAqIEBwcm9wZXJ0eSB7U2V0PFN0YXRzSWQ+fSBhdWRpb1xuICogQHByb3BlcnR5IHtTZXQ8U3RhdHNJZD59IHZpZGVvXG4gKi9cbi8qKlxuICogQHByb3BlcnR5IHtSVENQZWVyQ29ubmVjdGlvbn0gcGNcbiAqIEBwcm9wZXJ0eSB7SWNlUmVwb3J0RmFjdG9yeX0gaWNlUmVwb3J0RmFjdG9yeVxuICogQHByb3BlcnR5IHtTZW5kZXJBbmRSZWNlaXZlclJlcG9ydEZhY3Rvcmllc30gYXVkaW9cbiAqIEBwcm9wZXJ0eSB7U2VuZGVyQW5kUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXN9IHZpZGVvXG4gKiBAcHJvcGVydHkgez9QZWVyQ29ubmVjdGlvblJlcG9ydH0gbGFzdFJlcG9ydFxuICovXG52YXIgUGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBQZWVyQ29ubmVjdGlvblJlcG9ydEZhY3Rvcnl9LlxuICAgICAqIEBwYXJhbSB7UlRDUGVlckNvbm5lY3Rpb259IHBjXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5KHBjKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHBjOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpY2U6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgSWNlUmVwb3J0RmFjdG9yeSgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXVkaW86IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgcmVjdjogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBzZW5kOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIHJlY3Y6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0UmVwb3J0OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEge0BsaW5rIFBlZXJDb25uZWN0aW9uUmVwb3J0fS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQZWVyQ29ubmVjdGlvblJlcG9ydD59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdXBkYXRlUHJvbWlzZSA9IGd1ZXNzQnJvd3NlcigpID09PSAnZmlyZWZveCdcbiAgICAgICAgICAgID8gdXBkYXRlRmlyZWZveCh0aGlzKVxuICAgICAgICAgICAgOiB1cGRhdGVDaHJvbWUodGhpcyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF1ZGlvU2VuZGVyUmVwb3J0RmFjdG9yaWVzID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKF90aGlzLmF1ZGlvLnNlbmQudmFsdWVzKCkpKTtcbiAgICAgICAgICAgIHZhciB2aWRlb1NlbmRlclJlcG9ydEZhY3RvcmllcyA9IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChfdGhpcy52aWRlby5zZW5kLnZhbHVlcygpKSk7XG4gICAgICAgICAgICB2YXIgYXVkaW9SZWNlaXZlclJlcG9ydEZhY3RvcmllcyA9IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChfdGhpcy5hdWRpby5yZWN2LnZhbHVlcygpKSk7XG4gICAgICAgICAgICB2YXIgdmlkZW9SZWNlaXZlclJlcG9ydEZhY3RvcmllcyA9IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChfdGhpcy52aWRlby5yZWN2LnZhbHVlcygpKSk7XG4gICAgICAgICAgICB2YXIgcmVwb3J0ID0gbmV3IFBlZXJDb25uZWN0aW9uUmVwb3J0KF90aGlzLmljZS5sYXN0UmVwb3J0LCB7XG4gICAgICAgICAgICAgICAgc2VuZDogYXVkaW9TZW5kZXJSZXBvcnRGYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChmYWN0b3J5KSB7IHJldHVybiBmYWN0b3J5Lmxhc3RSZXBvcnQ7IH0pLmZpbHRlcihmdW5jdGlvbiAocmVwb3J0KSB7IHJldHVybiByZXBvcnQ7IH0pLFxuICAgICAgICAgICAgICAgIHJlY3Y6IGF1ZGlvUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChmYWN0b3J5KSB7IHJldHVybiBmYWN0b3J5Lmxhc3RSZXBvcnQ7IH0pLmZpbHRlcihmdW5jdGlvbiAocmVwb3J0KSB7IHJldHVybiByZXBvcnQ7IH0pXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgc2VuZDogdmlkZW9TZW5kZXJSZXBvcnRGYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChmYWN0b3J5KSB7IHJldHVybiBmYWN0b3J5Lmxhc3RSZXBvcnQ7IH0pLmZpbHRlcihmdW5jdGlvbiAocmVwb3J0KSB7IHJldHVybiByZXBvcnQ7IH0pLFxuICAgICAgICAgICAgICAgIHJlY3Y6IHZpZGVvUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChmYWN0b3J5KSB7IHJldHVybiBmYWN0b3J5Lmxhc3RSZXBvcnQ7IH0pLmZpbHRlcihmdW5jdGlvbiAocmVwb3J0KSB7IHJldHVybiByZXBvcnQ7IH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLmxhc3RSZXBvcnQgPSByZXBvcnQ7XG4gICAgICAgICAgICByZXR1cm4gcmVwb3J0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQZWVyQ29ubmVjdGlvblJlcG9ydEZhY3Rvcnk7XG59KCkpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYSBNYXAgZnJvbSBNZWRpYVN0cmVhbVRyYWNrIElkcyB0byBSVENTdGF0c1JlcG9ydHMuXG4gKiBAcGFyYW0ge0FycmF5PFJUQ1J0cFNlbmRlcj58QXJyYXk8UlRDUnRwUmVjZWl2ZXI+fSBzZW5kZXJzT3JSZWNlaXZlcnMgLSBlYWNoXG4gKiAgIFJUQ1J0cFNlbmRlciBzaG91bGQgaGF2ZSBhIG5vbi1udWxsIHRyYWNrXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNYXA8VHJhY2tJZCwgUlRDU3RhdHM+Pn1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VuZGVyT3JSZWNlaXZlclJlcG9ydHMoc2VuZGVyc09yUmVjZWl2ZXJzKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHNlbmRlcnNPclJlY2VpdmVycy5tYXAoZnVuY3Rpb24gKHNlbmRlck9yUmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIHRyYWNrSWQgPSBzZW5kZXJPclJlY2VpdmVyLnRyYWNrLmlkO1xuICAgICAgICByZXR1cm4gc2VuZGVyT3JSZWNlaXZlci5nZXRTdGF0cygpLnRoZW4oZnVuY3Rpb24gKHJlcG9ydCkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobXJvYmVydHMpOiBXZSBoYXZlIHRvIHJld3JpdGUgSWRzIGR1ZSB0byB0aGlzIGJ1ZzpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQ2MzQzMFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhyZXBvcnQudmFsdWVzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0cyA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHMudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMuaWQgPSB0cmFja0lkICsgXCItXCIgKyBzdGF0cy5pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbdHJhY2tJZCwgcmVwb3J0XTtcbiAgICAgICAgfSk7XG4gICAgfSkpLnRoZW4oZnVuY3Rpb24gKHBhaXJzKSB7IHJldHVybiBuZXcgTWFwKHBhaXJzKTsgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7U2VuZGVyUmVwb3J0RmFjdG9yeS5jb25zdHJ1Y3Rvcn0gU2VuZGVyUmVwb3J0RmFjdG9yeVxuICogQHBhcmFtIHtTZW5kZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZX0gc2VuZGVyc0J5TWVkaWFUeXBlXG4gKiBAcGFyYW0ge1JUQ1N0YXRzUmVwb3J0fSByZXBvcnRcbiAqIEBwYXJhbSB7UlRDU3RhdHN9IHN0YXRzXG4gKiBAcGFyYW0ge1RyYWNrSWR9IFt0cmFja0lkXVxuICogQHJldHVybnMgez9TZW5kZXJSZXBvcnRGYWN0b3J5fVxuICovIC8qKlxuKiBAcGFyYW0ge1JlY2VpdmVyUmVwb3J0RmFjdG9yeS5jb25zdHJ1Y3Rvcn0gUmVjZWl2ZXJSZXBvcnRGYWN0b3J5XG4qIEBwYXJhbSB7UmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZX0gcmVjZWl2ZXJzQnlNZWRpYVR5cGVcbiogQHBhcmFtIHtSVENTdGF0c1JlcG9ydH0gcmVwb3J0XG4qIEBwYXJhbSB7UlRDU3RhdHN9IHN0YXRzXG4qIEBwYXJhbSB7VHJhY2tJZH0gW3RyYWNrSWRdXG4qIEByZXR1cm5zIHs/UmVjZWl2ZXJSZXBvcnRGYWN0b3J5fVxuKi9cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcnkoU2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcnksIHNlbmRlcnNPclJlY2VpdmVyc0J5TWVkaWFUeXBlLCByZXBvcnQsIHN0YXRzLCB0cmFja0lkKSB7XG4gICAgdmFyIHNlbmRlcnNPclJlY2VpdmVycyA9IHNlbmRlcnNPclJlY2VpdmVyc0J5TWVkaWFUeXBlW3N0YXRzLm1lZGlhVHlwZV07XG4gICAgaWYgKCF0cmFja0lkKSB7XG4gICAgICAgIHZhciB0cmFja1N0YXRzID0gcmVwb3J0LmdldChzdGF0cy50cmFja0lkKTtcbiAgICAgICAgaWYgKHRyYWNrU3RhdHMpIHtcbiAgICAgICAgICAgIHRyYWNrSWQgPSB0cmFja1N0YXRzLnRyYWNrSWRlbnRpZmllcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VuZGVyc09yUmVjZWl2ZXJzICYmIHRyYWNrSWQpIHtcbiAgICAgICAgaWYgKHNlbmRlcnNPclJlY2VpdmVycy5oYXMoc3RhdHMuaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VuZGVyc09yUmVjZWl2ZXJzLmdldChzdGF0cy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbmRlck9yUmVjZWl2ZXJGYWN0b3J5ID0gbmV3IFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5KHRyYWNrSWQsIHN0YXRzKTtcbiAgICAgICAgc2VuZGVyc09yUmVjZWl2ZXJzLnNldChzdGF0cy5pZCwgc2VuZGVyT3JSZWNlaXZlckZhY3RvcnkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvblJlcG9ydEZhY3Rvcnl9IGZhY3RvcnlcbiAqIEByZXR1cm5zIHtTZW5kZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VuZGVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGUoZmFjdG9yeSkge1xuICAgIHJldHVybiB7IGF1ZGlvOiBmYWN0b3J5LmF1ZGlvLnNlbmQsIHZpZGVvOiBmYWN0b3J5LnZpZGVvLnNlbmQgfTtcbn1cbi8qKlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvblJlcG9ydEZhY3Rvcnl9IGZhY3RvcnlcbiAqIEByZXR1cm5zIHtSZWNlaXZlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlfVxuICovXG5mdW5jdGlvbiBnZXRSZWNlaXZlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlKGZhY3RvcnkpIHtcbiAgICByZXR1cm4geyBhdWRpbzogZmFjdG9yeS5hdWRpby5yZWN2LCB2aWRlbzogZmFjdG9yeS52aWRlby5yZWN2IH07XG59XG4vKipcbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5fSBmYWN0b3J5XG4gKiBAcGFyYW0ge1JUQ1N0YXRzUmVwb3J0fSByZXBvcnRcbiAqIEBwYXJhbSB7UlRDU3RhdHN9IHN0YXRzXG4gKiBAcGFyYW0ge1RyYWNrSWR9IFt0cmFja0lkXVxuICogQHJldHVybnMgez9TZW5kZXJSZXBvcnRGYWN0b3J5fVxuICovXG5mdW5jdGlvbiBnZXRPckNyZWF0ZVNlbmRlclJlcG9ydEZhY3RvcnkoZmFjdG9yeSwgcmVwb3J0LCBzdGF0cywgdHJhY2tJZCkge1xuICAgIHJldHVybiBnZXRPckNyZWF0ZVNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5KFNlbmRlclJlcG9ydEZhY3RvcnksIGdldFNlbmRlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlKGZhY3RvcnkpLCByZXBvcnQsIHN0YXRzLCB0cmFja0lkKTtcbn1cbi8qKlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvblJlcG9ydEZhY3Rvcnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7UlRDU3RhdHNSZXBvcnR9IHJlcG9ydFxuICogQHBhcmFtIHtSVENTdGF0c30gc3RhdHNcbiAqIEBwYXJhbSB7VHJhY2tJZH0gW3RyYWNrSWRdXG4gKiBAcmV0dXJucyB7P1JlY2VpdmVyUmVwb3J0RmFjdG9yeX1cbiAqL1xuZnVuY3Rpb24gZ2V0T3JDcmVhdGVSZWNlaXZlclJlcG9ydEZhY3RvcnkoZmFjdG9yeSwgcmVwb3J0LCBzdGF0cywgdHJhY2tJZCkge1xuICAgIHJldHVybiBnZXRPckNyZWF0ZVNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5KFJlY2VpdmVyUmVwb3J0RmFjdG9yeSwgZ2V0UmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZShmYWN0b3J5KSwgcmVwb3J0LCBzdGF0cywgdHJhY2tJZCk7XG59XG4vKipcbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5fSBmYWN0b3J5XG4gKiBAcmV0dW5zIHtTdGF0c0lkc0J5TWVkaWFUeXBlfVxuICovXG5mdW5jdGlvbiBnZXRTZW5kZXJSZXBvcnRGYWN0b3J5SWRzQnlNZWRpYVR5cGUoZmFjdG9yeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGF1ZGlvOiBuZXcgU2V0KGZhY3RvcnkuYXVkaW8uc2VuZC5rZXlzKCkpLFxuICAgICAgICB2aWRlbzogbmV3IFNldChmYWN0b3J5LnZpZGVvLnNlbmQua2V5cygpKVxuICAgIH07XG59XG4vKipcbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5fSBmYWN0b3J5XG4gKiBAcmV0dW5zIHtTdGF0c0lkc0J5TWVkaWFUeXBlfVxuICovXG5mdW5jdGlvbiBnZXRSZWNlaXZlclJlcG9ydEZhY3RvcnlJZHNCeU1lZGlhVHlwZShmYWN0b3J5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXVkaW86IG5ldyBTZXQoZmFjdG9yeS5hdWRpby5yZWN2LmtleXMoKSksXG4gICAgICAgIHZpZGVvOiBuZXcgU2V0KGZhY3RvcnkudmlkZW8ucmVjdi5rZXlzKCkpXG4gICAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvblJlcG9ydEZhY3Rvcnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7UlRDU3RhdHNSZXBvcnR9IHJlcG9ydFxuICogQHBhcmFtIHtTdGF0c0lkc0J5TWVkaWFUeXBlfSBzZW5kZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGVCeU1lZGlhVHlwZVxuICogQHBhcmFtIHtUcmFja0lkfSBbdHJhY2tJZF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGVTZW5kZXJSZXBvcnRzKGZhY3RvcnksIHJlcG9ydCwgc2VuZGVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGUsIHRyYWNrSWQpIHtcbiAgICB2YXIgZV8yLCBfYTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHJlcG9ydC52YWx1ZXMoKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBzdGF0cyA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHN0YXRzLnR5cGUgPT09ICdvdXRib3VuZC1ydHAnICYmICFzdGF0cy5pc1JlbW90ZSkge1xuICAgICAgICAgICAgICAgIGlmIChndWVzc0Jyb3dzZXIoKSAhPT0gJ2ZpcmVmb3gnICYmICFzdGF0cy50cmFja0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2VuZGVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlID0gc2VuZGVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGVbc3RhdHMubWVkaWFUeXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoc2VuZGVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZS5kZWxldGUoc3RhdHMuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2VuZGVyUmVwb3J0RmFjdG9yeSA9IGdldE9yQ3JlYXRlU2VuZGVyUmVwb3J0RmFjdG9yeShmYWN0b3J5LCByZXBvcnQsIHN0YXRzLCB0cmFja0lkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VuZGVyUmVwb3J0RmFjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3RlSW5ib3VuZFN0YXRzID0gcmVwb3J0LmdldChzdGF0cy5yZW1vdGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRlclJlcG9ydEZhY3RvcnkubmV4dCh0cmFja0lkIHx8IHNlbmRlclJlcG9ydEZhY3RvcnkudHJhY2tJZCwgc3RhdHMsIHJlbW90ZUluYm91bmRTdGF0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvblJlcG9ydEZhY3Rvcnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7UlRDU3RhdHNSZXBvcnR9IHJlcG9ydFxuICogQHBhcmFtIHtTdGF0c0lkc0J5TWVkaWFUeXBlfSByZWNlaXZlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZUJ5TWVkaWFUeXBlXG4gKiBAcGFyYW0ge1RyYWNrSWR9IFt0cmFja0lkXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVJlY2VpdmVyUmVwb3J0cyhmYWN0b3J5LCByZXBvcnQsIHJlY2VpdmVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGUsIHRyYWNrSWQpIHtcbiAgICB2YXIgZV8zLCBfYTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHJlcG9ydC52YWx1ZXMoKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBzdGF0cyA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHN0YXRzLnR5cGUgPT09ICdpbmJvdW5kLXJ0cCcgJiYgIXN0YXRzLmlzUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlID0gcmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGVCeU1lZGlhVHlwZVtzdGF0cy5tZWRpYVR5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZS5kZWxldGUoc3RhdHMuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVjZWl2ZXJSZXBvcnRGYWN0b3J5ID0gZ2V0T3JDcmVhdGVSZWNlaXZlclJlcG9ydEZhY3RvcnkoZmFjdG9yeSwgcmVwb3J0LCBzdGF0cywgdHJhY2tJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVyUmVwb3J0RmFjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlclJlcG9ydEZhY3RvcnkubmV4dCh0cmFja0lkIHx8IHJlY2VpdmVyUmVwb3J0RmFjdG9yeS50cmFja0lkLCBzdGF0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHtTZW5kZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZXxSZWNlaXZlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlfSBzZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGVcbiAqIEBwYXJhbSB7U3RhdHNJZHNCeU1lZGlhVHlwZX0gc2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcnlJZHNCeU1lZGlhVHlwZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZVNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXMoc2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlLCBzZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeUlkc0J5TWVkaWFUeXBlKSB7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAobWVkaWFUeXBlKSB7XG4gICAgICAgIHZhciBzZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzID0gc2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlW21lZGlhVHlwZV07XG4gICAgICAgIHZhciBzZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeUlkcyA9IHNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzQnlNZWRpYVR5cGVbbWVkaWFUeXBlXTtcbiAgICAgICAgc2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAoc2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcnlJZCkgeyByZXR1cm4gc2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3Rvcmllcy5kZWxldGUoc2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcnlJZCk7IH0pO1xuICAgIH07XG4gICAgZm9yICh2YXIgbWVkaWFUeXBlIGluIHNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzQnlNZWRpYVR5cGUpIHtcbiAgICAgICAgX2xvb3BfMShtZWRpYVR5cGUpO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHtJY2VSZXBvcnRGYWN0b3J5fSBpY2VcbiAqIEBwYXJhbSB7UlRDU3RhdHNSZXBvcnR9IHJlcG9ydFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUljZVJlcG9ydChpY2UsIHJlcG9ydCkge1xuICAgIHZhciBlXzQsIF9hLCBlXzUsIF9iO1xuICAgIHZhciBzZWxlY3RlZENhbmRpZGF0ZVBhaXI7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhyZXBvcnQudmFsdWVzKCkpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgc3RhdHMgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChzdGF0cy50eXBlID09PSAndHJhbnNwb3J0Jykge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkQ2FuZGlkYXRlUGFpciA9IHJlcG9ydC5nZXQoc3RhdHMuc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0ZWRDYW5kaWRhdGVQYWlyKSB7XG4gICAgICAgIGljZS5uZXh0KHNlbGVjdGVkQ2FuZGlkYXRlUGFpcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2UgPSBfX3ZhbHVlcyhyZXBvcnQudmFsdWVzKCkpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgc3RhdHMgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgIGlmIChzdGF0cy50eXBlID09PSAnY2FuZGlkYXRlLXBhaXInXG4gICAgICAgICAgICAgICAgJiYgc3RhdHMubm9taW5hdGVkXG4gICAgICAgICAgICAgICAgJiYgKCdzZWxlY3RlZCcgaW4gc3RhdHMgPyBzdGF0cy5zZWxlY3RlZCA6IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgaWNlLm5leHQoc3RhdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2YgJiYgIV9mLmRvbmUgJiYgKF9iID0gX2UucmV0dXJuKSkgX2IuY2FsbChfZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjsgfVxuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvblJlcG9ydEZhY3Rvcnl9IGZhY3RvcnlcbiAqIEByZXR1cm5zIHtQcm9taXNlPFBlZXJDb25uZWN0aW9uUmVwb3J0Pn1cbiAqL1xuZnVuY3Rpb24gdXBkYXRlRmlyZWZveChmYWN0b3J5KSB7XG4gICAgdmFyIHNlbmRlcnMgPSBmYWN0b3J5LnBjLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHRyYW5zY2VpdmVyKSB7IHJldHVybiB0cmFuc2NlaXZlci5jdXJyZW50RGlyZWN0aW9uICYmIHRyYW5zY2VpdmVyLmN1cnJlbnREaXJlY3Rpb24ubWF0Y2goL3NlbmQvKSAmJiB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2s7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHRyYW5zY2VpdmVyKSB7IHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXI7IH0pO1xuICAgIHZhciByZWNlaXZlcnMgPSBmYWN0b3J5LnBjLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHRyYW5zY2VpdmVyKSB7IHJldHVybiB0cmFuc2NlaXZlci5jdXJyZW50RGlyZWN0aW9uICYmIHRyYW5zY2VpdmVyLmN1cnJlbnREaXJlY3Rpb24ubWF0Y2goL3JlY3YvKTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodHJhbnNjZWl2ZXIpIHsgcmV0dXJuIHRyYW5zY2VpdmVyLnJlY2VpdmVyOyB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZXRTZW5kZXJPclJlY2VpdmVyUmVwb3J0cyhzZW5kZXJzKSxcbiAgICAgICAgZ2V0U2VuZGVyT3JSZWNlaXZlclJlcG9ydHMocmVjZWl2ZXJzKSxcbiAgICAgICAgZmFjdG9yeS5wYy5nZXRTdGF0cygpXG4gICAgXSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAzKSwgc2VuZGVyUmVwb3J0cyA9IF9iWzBdLCByZWNlaXZlclJlcG9ydHMgPSBfYlsxXSwgcGNSZXBvcnQgPSBfYlsyXTtcbiAgICAgICAgdmFyIHNlbmRlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlID0gZ2V0U2VuZGVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGUoZmFjdG9yeSk7XG4gICAgICAgIHZhciBzZW5kZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGVCeU1lZGlhVHlwZSA9IGdldFNlbmRlclJlcG9ydEZhY3RvcnlJZHNCeU1lZGlhVHlwZShmYWN0b3J5KTtcbiAgICAgICAgc2VuZGVyUmVwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXBvcnQsIHRyYWNrSWQpIHsgcmV0dXJuIHVwZGF0ZVNlbmRlclJlcG9ydHMoZmFjdG9yeSwgcmVwb3J0LCBzZW5kZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGVCeU1lZGlhVHlwZSwgdHJhY2tJZCk7IH0pO1xuICAgICAgICBkZWxldGVTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzKHNlbmRlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlLCBzZW5kZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGVCeU1lZGlhVHlwZSk7XG4gICAgICAgIHZhciByZWNlaXZlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlID0gZ2V0UmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZShmYWN0b3J5KTtcbiAgICAgICAgdmFyIHJlY2VpdmVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGUgPSBnZXRSZWNlaXZlclJlcG9ydEZhY3RvcnlJZHNCeU1lZGlhVHlwZShmYWN0b3J5KTtcbiAgICAgICAgcmVjZWl2ZXJSZXBvcnRzLmZvckVhY2goZnVuY3Rpb24gKHJlcG9ydCwgdHJhY2tJZCkgeyByZXR1cm4gdXBkYXRlUmVjZWl2ZXJSZXBvcnRzKGZhY3RvcnksIHJlcG9ydCwgcmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGVCeU1lZGlhVHlwZSwgdHJhY2tJZCk7IH0pO1xuICAgICAgICBkZWxldGVTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzKHJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGUsIHJlY2VpdmVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGUpO1xuICAgICAgICB1cGRhdGVJY2VSZXBvcnQoZmFjdG9yeS5pY2UsIHBjUmVwb3J0KTtcbiAgICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvblJlcG9ydEZhY3Rvcnl9IGZhY3RvcnlcbiAqIEByZXR1cm5zIHtQcm9taXNlPFBlZXJDb25uZWN0aW9uUmVwb3J0Pn1cbiAqL1xuZnVuY3Rpb24gdXBkYXRlQ2hyb21lKGZhY3RvcnkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5wYy5nZXRTdGF0cygpLnRoZW4oZnVuY3Rpb24gKHJlcG9ydCkge1xuICAgICAgICB2YXIgc2VuZGVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGUgPSBnZXRTZW5kZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZShmYWN0b3J5KTtcbiAgICAgICAgdmFyIHNlbmRlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZUJ5TWVkaWFUeXBlID0gZ2V0U2VuZGVyUmVwb3J0RmFjdG9yeUlkc0J5TWVkaWFUeXBlKGZhY3RvcnkpO1xuICAgICAgICB1cGRhdGVTZW5kZXJSZXBvcnRzKGZhY3RvcnksIHJlcG9ydCwgc2VuZGVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGUpO1xuICAgICAgICBkZWxldGVTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzKHNlbmRlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlLCBzZW5kZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGVCeU1lZGlhVHlwZSk7XG4gICAgICAgIHZhciByZWNlaXZlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlID0gZ2V0UmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZShmYWN0b3J5KTtcbiAgICAgICAgdmFyIHJlY2VpdmVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGUgPSBnZXRSZWNlaXZlclJlcG9ydEZhY3RvcnlJZHNCeU1lZGlhVHlwZShmYWN0b3J5KTtcbiAgICAgICAgdXBkYXRlUmVjZWl2ZXJSZXBvcnRzKGZhY3RvcnksIHJlcG9ydCwgcmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGVCeU1lZGlhVHlwZSk7XG4gICAgICAgIGRlbGV0ZVNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXMocmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZSwgcmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGVCeU1lZGlhVHlwZSk7XG4gICAgICAgIHVwZGF0ZUljZVJlcG9ydChmYWN0b3J5LmljZSwgcmVwb3J0KTtcbiAgICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gUGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVlcmNvbm5lY3Rpb25yZXBvcnRmYWN0b3J5LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgYXZlcmFnZSA9IHJlcXVpcmUoJy4vYXZlcmFnZScpO1xudmFyIFNlbmRlck9yUmVjZWl2ZXJSZXBvcnQgPSByZXF1aXJlKCcuL3NlbmRlcm9ycmVjZWl2ZXJyZXBvcnQnKTtcbnZhciBzdW0gPSByZXF1aXJlKCcuL3N1bScpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFJlY2VpdmVyU3VtbWFyeVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJpdHJhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcmFjdGlvbkxvc3QgLSAw4oCTMVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtqaXR0ZXJdIC0gcyAodW5kZWZpbmVkIGZvciB2aWRlbyB0cmFja3MgaW4gQ2hyb21lKVxuICovXG4vKipcbiAqIEBleHRlbmRzIFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWx0YVBhY2tldHNMb3N0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVsdGFQYWNrZXRzUmVjZWl2ZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZnJhY3Rpb25Mb3N0XSAtIDDigJMxICh1bmRlZmluZWQgaW4gRmlyZWZveClcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaml0dGVyXSAtIHMgKHVuZGVmaW5lZCBmb3IgdmlkZW8gdHJhY2tzIGluIENocm9tZSlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaG9ueVBhY2tldHNMb3N0IC0gMOKAkzFcbiAqL1xudmFyIFJlY2VpdmVyUmVwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWNlaXZlclJlcG9ydCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0YXRzSWR9IGlkXG4gICAgICogQHBhcmFtIHtUcmFja0lkfSB0cmFja0lkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdHJhdGUgLSBicHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFQYWNrZXRzTG9zdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVBhY2tldHNSZWNlaXZlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJhY3Rpb25Mb3N0XSAtIDDigJMxICh1bmRlZmluZWQgaW4gRmlyZWZveClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2ppdHRlcl0gLSBzICh1bmRlZmluZWQgZm9yIHZpZGVvIHRyYWNrcyBpbiBDaHJvbWUpXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVjZWl2ZXJSZXBvcnQoaWQsIHRyYWNrSWQsIGJpdHJhdGUsIGRlbHRhUGFja2V0c0xvc3QsIGRlbHRhUGFja2V0c1JlY2VpdmVkLCBmcmFjdGlvbkxvc3QsIGppdHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgdHJhY2tJZCwgYml0cmF0ZSkgfHwgdGhpcztcbiAgICAgICAgdmFyIHBob255RnJhY3Rpb25Mb3N0ID0gZGVsdGFQYWNrZXRzUmVjZWl2ZWQgPiAwXG4gICAgICAgICAgICA/IGRlbHRhUGFja2V0c0xvc3QgLyBkZWx0YVBhY2tldHNSZWNlaXZlZFxuICAgICAgICAgICAgOiAwO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgZGVsdGFQYWNrZXRzTG9zdDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlbHRhUGFja2V0c0xvc3RcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWx0YVBhY2tldHNSZWNlaXZlZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlbHRhUGFja2V0c1JlY2VpdmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJhY3Rpb25Mb3N0OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnJhY3Rpb25Mb3N0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaml0dGVyOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaml0dGVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGhvbnlGcmFjdGlvbkxvc3Q6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwaG9ueUZyYWN0aW9uTG9zdFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB7QGxpbmsgUmVjZWl2ZXJSZXBvcnR9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFja0lkXG4gICAgICogQHBhcmFtIHtSVENTdGF0c30gb2xkZXJTdGF0c1xuICAgICAqIEBwYXJhbSB7UlRDU3RhdHN9IG5ld2VyU3RhdHNcbiAgICAgKiBAcmV0dXJucyB7UmVjZWl2ZXJSZXBvcnR9XG4gICAgICovXG4gICAgUmVjZWl2ZXJSZXBvcnQub2YgPSBmdW5jdGlvbiAodHJhY2tJZCwgb2xkZXJTdGF0cywgbmV3ZXJTdGF0cykge1xuICAgICAgICBpZiAob2xkZXJTdGF0cy5pZCAhPT0gbmV3ZXJTdGF0cy5pZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSVENTdGF0cyBJRHMgbXVzdCBtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWNvbmRzRWxhcHNlZCA9IChuZXdlclN0YXRzLnRpbWVzdGFtcCAtIG9sZGVyU3RhdHMudGltZXN0YW1wKSAvIDEwMDA7XG4gICAgICAgIHZhciBkZWx0YUJ5dGVzUmVjZWl2ZWQgPSBuZXdlclN0YXRzLmJ5dGVzUmVjZWl2ZWQgLSBvbGRlclN0YXRzLmJ5dGVzUmVjZWl2ZWQ7XG4gICAgICAgIHZhciBiaXRyYXRlID0gc2Vjb25kc0VsYXBzZWQgPiAwXG4gICAgICAgICAgICA/IChkZWx0YUJ5dGVzUmVjZWl2ZWQgLyBzZWNvbmRzRWxhcHNlZCkgKiA4XG4gICAgICAgICAgICA6IDA7XG4gICAgICAgIHZhciBkZWx0YVBhY2tldHNMb3N0ID0gTWF0aC5tYXgobmV3ZXJTdGF0cy5wYWNrZXRzTG9zdCAtIG9sZGVyU3RhdHMucGFja2V0c0xvc3QsIDApO1xuICAgICAgICB2YXIgZGVsdGFQYWNrZXRzUmVjZWl2ZWQgPSBuZXdlclN0YXRzLnBhY2tldHNSZWNlaXZlZCAtIG9sZGVyU3RhdHMucGFja2V0c1JlY2VpdmVkO1xuICAgICAgICB2YXIgZnJhY3Rpb25Mb3N0ID0gbmV3ZXJTdGF0cy5mcmFjdGlvbkxvc3QsIGppdHRlciA9IG5ld2VyU3RhdHMuaml0dGVyO1xuICAgICAgICByZXR1cm4gbmV3IFJlY2VpdmVyUmVwb3J0KG9sZGVyU3RhdHMuaWQsIHRyYWNrSWQsIGJpdHJhdGUsIGRlbHRhUGFja2V0c0xvc3QsIGRlbHRhUGFja2V0c1JlY2VpdmVkLCBmcmFjdGlvbkxvc3QsIGppdHRlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdW1tYXJpemUge0BsaW5rIFJlY2VpdmVyUmVwb3J0fXMgYnkgc3VtbWluZyBhbmQgYXZlcmFnaW5nIHRoZWlyIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5PFJlY2VpdmVyUmVwb3J0Pn0gcmVwb3J0c1xuICAgICAqIEByZXR1cm5zIHtSZWNlaXZlclN1bW1hcnl9XG4gICAgICovXG4gICAgUmVjZWl2ZXJSZXBvcnQuc3VtbWFyaXplID0gZnVuY3Rpb24gKHJlcG9ydHMpIHtcbiAgICAgICAgdmFyIHN1bW1hcmllcyA9IHJlcG9ydHMubWFwKGZ1bmN0aW9uIChyZXBvcnQpIHsgcmV0dXJuIHJlcG9ydC5zdW1tYXJpemUoKTsgfSk7XG4gICAgICAgIHZhciBiaXRyYXRlID0gc3VtKHN1bW1hcmllcy5tYXAoZnVuY3Rpb24gKHN1bW1hcnkpIHsgcmV0dXJuIHN1bW1hcnkuYml0cmF0ZTsgfSkpO1xuICAgICAgICB2YXIgZnJhY3Rpb25Mb3N0ID0gYXZlcmFnZShzdW1tYXJpZXMubWFwKGZ1bmN0aW9uIChzdW1tYXJ5KSB7IHJldHVybiBzdW1tYXJ5LmZyYWN0aW9uTG9zdDsgfSkpO1xuICAgICAgICB2YXIgaml0dGVyID0gYXZlcmFnZShzdW1tYXJpZXMubWFwKGZ1bmN0aW9uIChzdW1tYXJ5KSB7IHJldHVybiBzdW1tYXJ5LmppdHRlcjsgfSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYml0cmF0ZTogYml0cmF0ZSxcbiAgICAgICAgICAgIGZyYWN0aW9uTG9zdDogZnJhY3Rpb25Mb3N0LFxuICAgICAgICAgICAgaml0dGVyOiBqaXR0ZXJcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1bW1hcml6ZSB0aGUge0BsaW5rIFJlY2VpdmVSZXBvcnR9LlxuICAgICAqIEByZXR1cm5zIHtSZWNlaXZlclN1bW1hcnl9XG4gICAgICovXG4gICAgUmVjZWl2ZXJSZXBvcnQucHJvdG90eXBlLnN1bW1hcml6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJpdHJhdGU6IHRoaXMuYml0cmF0ZSxcbiAgICAgICAgICAgIGZyYWN0aW9uTG9zdDogdHlwZW9mIHRoaXMuZnJhY3Rpb25Mb3N0ID09PSAnbnVtYmVyJyA/IHRoaXMuZnJhY3Rpb25Mb3N0IDogdGhpcy5waG9ueUZyYWN0aW9uTG9zdCxcbiAgICAgICAgICAgIGppdHRlcjogdGhpcy5qaXR0ZXJcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBSZWNlaXZlclJlcG9ydDtcbn0oU2VuZGVyT3JSZWNlaXZlclJlcG9ydCkpO1xubW9kdWxlLmV4cG9ydHMgPSBSZWNlaXZlclJlcG9ydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY2VpdmVycmVwb3J0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgUmVjZWl2ZXJSZXBvcnQgPSByZXF1aXJlKCcuL3JlY2VpdmVycmVwb3J0Jyk7XG52YXIgU2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcnkgPSByZXF1aXJlKCcuL3NlbmRlcm9ycmVjZWl2ZXJyZXBvcnRmYWN0b3J5Jyk7XG4vKipcbiAqIEBleHRlbmRzIFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5XG4gKiBAcGFyYW0gez9SZWNlaXZlclJlcG9ydH0gbGFzdFJlcG9ydFxuICovXG52YXIgUmVjZWl2ZXJSZXBvcnRGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWNlaXZlclJlcG9ydEZhY3RvcnksIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJlY2VpdmVyUmVwb3J0RmFjdG9yeX0uXG4gICAgICogQHBhcmFtIHtUcmFja0lkfSB0cmFja0lkXG4gICAgICogQHBhcmFtIHtSVENTdGF0c30gaW5pdGlhbFN0YXRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVjZWl2ZXJSZXBvcnRGYWN0b3J5KHRyYWNrSWQsIGluaXRpYWxTdGF0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsU3RhdHMuaWQsIHRyYWNrSWQsIGluaXRpYWxTdGF0cykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIGxhc3RSZXBvcnQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHtAbGluayBSZWNlaXZlclJlcG9ydH0uXG4gICAgICogQHBhcmFtIHtUcmFja0lkfSB0cmFja0lkXG4gICAgICogQHBhcmFtIHtSVENTdGF0c30gbmV3ZXJTdGF0c1xuICAgICAqIEByZXR1cm5zIHtSZWNlaXZlclJlcG9ydH1cbiAgICAgKi9cbiAgICBSZWNlaXZlclJlcG9ydEZhY3RvcnkucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodHJhY2tJZCwgbmV3ZXJTdGF0cykge1xuICAgICAgICB2YXIgb2xkZXJTdGF0cyA9IHRoaXMubGFzdFN0YXRzO1xuICAgICAgICB0aGlzLmxhc3RTdGF0cyA9IG5ld2VyU3RhdHM7XG4gICAgICAgIHRoaXMudHJhY2tJZCA9IHRyYWNrSWQ7XG4gICAgICAgIHZhciByZXBvcnQgPSBSZWNlaXZlclJlcG9ydC5vZih0cmFja0lkLCBvbGRlclN0YXRzLCBuZXdlclN0YXRzKTtcbiAgICAgICAgdGhpcy5sYXN0UmVwb3J0ID0gcmVwb3J0O1xuICAgICAgICByZXR1cm4gcmVwb3J0O1xuICAgIH07XG4gICAgcmV0dXJuIFJlY2VpdmVyUmVwb3J0RmFjdG9yeTtcbn0oU2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcnkpKTtcbm1vZHVsZS5leHBvcnRzID0gUmVjZWl2ZXJSZXBvcnRGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjZWl2ZXJyZXBvcnRmYWN0b3J5LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgUmVtb3RlVHJhY2tTdGF0cyA9IHJlcXVpcmUoJy4vcmVtb3RldHJhY2tzdGF0cycpO1xuLyoqXG4gKiBTdGF0aXN0aWNzIGZvciBhbiB7QGxpbmsgQXVkaW9UcmFja30uXG4gKiBAZXh0ZW5kcyBSZW1vdGVUcmFja1N0YXRzXG4gKiBAcHJvcGVydHkgez9BdWRpb0xldmVsfSBhdWRpb0xldmVsIC0gT3V0cHV0IHtAbGluayBBdWRpb0xldmVsfVxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBqaXR0ZXIgLSBBdWRpbyBqaXR0ZXIgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbnZhciBSZW1vdGVBdWRpb1RyYWNrU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbW90ZUF1ZGlvVHJhY2tTdGF0cywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhY2tJZCAtIHtAbGluayBBdWRpb1RyYWNrfSBJRFxuICAgICAqIEBwYXJhbSB7U3RhbmRhcmRpemVkVHJhY2tTdGF0c1JlcG9ydH0gc3RhdHNSZXBvcnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZW1vdGVBdWRpb1RyYWNrU3RhdHModHJhY2tJZCwgc3RhdHNSZXBvcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhY2tJZCwgc3RhdHNSZXBvcnQpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBhdWRpb0xldmVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHR5cGVvZiBzdGF0c1JlcG9ydC5hdWRpb091dHB1dExldmVsID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICA/IHN0YXRzUmVwb3J0LmF1ZGlvT3V0cHV0TGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBqaXR0ZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHN0YXRzUmVwb3J0LmppdHRlciA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBzdGF0c1JlcG9ydC5qaXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlbW90ZUF1ZGlvVHJhY2tTdGF0cztcbn0oUmVtb3RlVHJhY2tTdGF0cykpO1xubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVBdWRpb1RyYWNrU3RhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdGVhdWRpb3RyYWNrc3RhdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBUcmFja1N0YXRzID0gcmVxdWlyZSgnLi90cmFja3N0YXRzJyk7XG4vKipcbiAqIFN0YXRpc3RpY3MgZm9yIGEgcmVtb3RlIHtAbGluayBUcmFja30uXG4gKiBAZXh0ZW5kcyBUcmFja1N0YXRzXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IGJ5dGVzUmVjZWl2ZWQgLSBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWRcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gcGFja2V0c1JlY2VpdmVkIC0gTnVtYmVyIG9mIHBhY2tldHMgcmVjZWl2ZWRcbiAqL1xudmFyIFJlbW90ZVRyYWNrU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbW90ZVRyYWNrU3RhdHMsIF9zdXBlcik7XG4gICAgLypcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhY2tJZCAtIHtAbGluayBUcmFja30gSURcbiAgICAgKiBAcGFyYW0ge1N0YW5kYXJkaXplZFRyYWNrU3RhdHNSZXBvcnR9IHN0YXRzUmVwb3J0XG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVtb3RlVHJhY2tTdGF0cyh0cmFja0lkLCBzdGF0c1JlcG9ydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0cmFja0lkLCBzdGF0c1JlcG9ydCkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHN0YXRzUmVwb3J0LmJ5dGVzUmVjZWl2ZWQgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdHNSZXBvcnQuYnl0ZXNSZWNlaXZlZFxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhY2tldHNSZWNlaXZlZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlb2Ygc3RhdHNSZXBvcnQucGFja2V0c1JlY2VpdmVkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICA/IHN0YXRzUmVwb3J0LnBhY2tldHNSZWNlaXZlZFxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVtb3RlVHJhY2tTdGF0cztcbn0oVHJhY2tTdGF0cykpO1xubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVUcmFja1N0YXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RldHJhY2tzdGF0cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFJlbW90ZVRyYWNrU3RhdHMgPSByZXF1aXJlKCcuL3JlbW90ZXRyYWNrc3RhdHMnKTtcbi8qKlxuICogU3RhdGlzdGljcyBmb3IgYSB7QGxpbmsgVmlkZW9UcmFja30uXG4gKiBAZXh0ZW5kcyBSZW1vdGVUcmFja1N0YXRzXG4gKiBAcHJvcGVydHkgez9WaWRlb1RyYWNrI0RpbWVuc2lvbnN9IGRpbWVuc2lvbnMgLSBSZWNlaXZlZCB2aWRlbyByZXNvbHV0aW9uXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IGZyYW1lUmF0ZSAtIFJlY2VpdmVkIHZpZGVvIGZyYW1lIHJhdGVcbiAqL1xudmFyIFJlbW90ZVZpZGVvVHJhY2tTdGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVtb3RlVmlkZW9UcmFja1N0YXRzLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFja0lkIC0ge0BsaW5rIFZpZGVvVHJhY2t9IElEXG4gICAgICogQHBhcmFtIHtTdGFuZGFyZGl6ZWRUcmFja1N0YXRzUmVwb3J0fSBzdGF0c1JlcG9ydFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbW90ZVZpZGVvVHJhY2tTdGF0cyh0cmFja0lkLCBzdGF0c1JlcG9ydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0cmFja0lkLCBzdGF0c1JlcG9ydCkgfHwgdGhpcztcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRzUmVwb3J0LmZyYW1lV2lkdGhSZWNlaXZlZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzdGF0c1JlcG9ydC5mcmFtZUhlaWdodFJlY2VpdmVkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGltZW5zaW9ucywge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdGF0c1JlcG9ydC5mcmFtZVdpZHRoUmVjZWl2ZWQsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlaWdodDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RhdHNSZXBvcnQuZnJhbWVIZWlnaHRSZWNlaXZlZCxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyYW1lUmF0ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlb2Ygc3RhdHNSZXBvcnQuZnJhbWVSYXRlUmVjZWl2ZWQgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdHNSZXBvcnQuZnJhbWVSYXRlUmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlbW90ZVZpZGVvVHJhY2tTdGF0cztcbn0oUmVtb3RlVHJhY2tTdGF0cykpO1xubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVWaWRlb1RyYWNrU3RhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdGV2aWRlb3RyYWNrc3RhdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAcHJvcGVydHkge1N0YXRzSWR9IGlkXG4gKiBAcHJvcGVydHkge1RyYWNrSWR9IHRyYWNrSWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiaXRyYXRlIC0gYnBzXG4gKi9cbnZhciBTZW5kZXJPclJlY2VpdmVyUmVwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBTZW5kZXJPclJlY2VpdmVyUmVwb3J0fS5cbiAgICAgKiBAcGFyYW0ge1N0YXRzSWR9IGlkXG4gICAgICogQHBhcmFtIHtUcmFja0lkfSB0cmFja0lkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdHJhdGUgLSBicHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZW5kZXJPclJlY2VpdmVyUmVwb3J0KGlkLCB0cmFja0lkLCBiaXRyYXRlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFja0lkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhY2tJZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJpdHJhdGU6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBiaXRyYXRlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gU2VuZGVyT3JSZWNlaXZlclJlcG9ydDtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlck9yUmVjZWl2ZXJSZXBvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW5kZXJvcnJlY2VpdmVycmVwb3J0LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQHByb3BlcnR5IHtTdGF0c0lkfSBpZFxuICogQHByb3BlcnR5IHtUcmFja0lkfSB0cmFja0lkXG4gKiBAcHJvcGVydHkge1JUQ1N0YXRzfSBsYXN0U3RhdHNcbiAqL1xudmFyIFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RhdHNJZH0gaWRcbiAgICAgKiBAcGFyYW0ge1RyYWNrSWR9IHRyYWNrSWRcbiAgICAgKiBAcGFyYW0ge1JUQ1N0YXRzfSBpbml0aWFsU3RhdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeShpZCwgdHJhY2tJZCwgaW5pdGlhbFN0YXRzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaWQsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFja0lkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhY2tJZCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3RTdGF0czoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGluaXRpYWxTdGF0cyxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5O1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW5kZXJvcnJlY2VpdmVycmVwb3J0ZmFjdG9yeS5qcy5tYXAiLCIvKiBlc2xpbnQgbm8tdW5kZWZpbmVkOjAgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgYXZlcmFnZSA9IHJlcXVpcmUoJy4vYXZlcmFnZScpO1xudmFyIFNlbmRlck9yUmVjZWl2ZXJSZXBvcnQgPSByZXF1aXJlKCcuL3NlbmRlcm9ycmVjZWl2ZXJyZXBvcnQnKTtcbnZhciBzdW0gPSByZXF1aXJlKCcuL3N1bScpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFNlbmRlclN1bW1hcnlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiaXRyYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3J0dF0gLSBzICh1bmRlZmluZWQgaW4gQ2hyb21lKVxuICovXG4vKipcbiAqIEBleHRlbmRzIFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcnR0XSAtIHMgKHVuZGVmaW5lZCBpbiBDaHJvbWUpXG4gKi9cbnZhciBTZW5kZXJSZXBvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlbmRlclJlcG9ydCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgU2VuZGVyUmVwb3J0fS5cbiAgICAgKiBAcGFyYW0ge1N0YXRzSWR9IGlkXG4gICAgICogQHBhcmFtIHtUcmFja0lkfSB0cmFja0lkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdHJhdGUgLSBicHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3J0dF0gLSBzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VuZGVyUmVwb3J0KGlkLCB0cmFja0lkLCBiaXRyYXRlLCBydHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaWQsIHRyYWNrSWQsIGJpdHJhdGUpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBydHQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBydHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEge0BsaW5rIFNlbmRlclJlcG9ydH0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWNrSWRcbiAgICAgKiBAcGFyYW0ge1JUQ1N0YXRzfSBvbGRlclN0YXRzXG4gICAgICogQHBhcmFtIHtSVENTdGF0c30gbmV3ZXJTdGF0c1xuICAgICAqIEBwYXJhbSB7UlRDUmVtb3RlSW5ib3VuZFJ0cFN0cmVhbVN0YXRzfSBbbmV3ZXJSZW1vdGVTdGF0c11cbiAgICAgKiBAcmV0dXJucyB7U2VuZGVyUmVwb3J0fVxuICAgICAqL1xuICAgIFNlbmRlclJlcG9ydC5vZiA9IGZ1bmN0aW9uICh0cmFja0lkLCBvbGRlclN0YXRzLCBuZXdlclN0YXRzLCBuZXdlclJlbW90ZVN0YXRzKSB7XG4gICAgICAgIGlmIChvbGRlclN0YXRzLmlkICE9PSBuZXdlclN0YXRzLmlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JUQ1N0YXRzIElEcyBtdXN0IG1hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlY29uZHNFbGFwc2VkID0gKG5ld2VyU3RhdHMudGltZXN0YW1wIC0gb2xkZXJTdGF0cy50aW1lc3RhbXApIC8gMTAwMDtcbiAgICAgICAgdmFyIGRlbHRhQnl0ZXNTZW50ID0gbmV3ZXJTdGF0cy5ieXRlc1NlbnQgLSBvbGRlclN0YXRzLmJ5dGVzU2VudDtcbiAgICAgICAgdmFyIGJpdHJhdGUgPSBzZWNvbmRzRWxhcHNlZCA+IDBcbiAgICAgICAgICAgID8gKGRlbHRhQnl0ZXNTZW50IC8gc2Vjb25kc0VsYXBzZWQpICogOFxuICAgICAgICAgICAgOiAwO1xuICAgICAgICB2YXIgcnR0ID0gbmV3ZXJSZW1vdGVTdGF0cyAmJiB0eXBlb2YgbmV3ZXJSZW1vdGVTdGF0cy5yb3VuZFRyaXBUaW1lID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyBuZXdlclJlbW90ZVN0YXRzLnJvdW5kVHJpcFRpbWUgLyAxMDAwXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG5ldyBTZW5kZXJSZXBvcnQob2xkZXJTdGF0cy5pZCwgdHJhY2tJZCwgYml0cmF0ZSwgcnR0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1bW1hcml6ZSB7QGxpbmsgU2VuZGVyUmVwb3J0fXMgYnkgc3VtbWluZyBhbmQgYXZlcmFnaW5nIHRoZWlyIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5PFNlbmRlclJlcG9ydD59IHJlcG9ydHNcbiAgICAgKiBAcmV0dXJucyB7U2VuZGVyU3VtbWFyeX1cbiAgICAgKi9cbiAgICBTZW5kZXJSZXBvcnQuc3VtbWFyaXplID0gZnVuY3Rpb24gKHJlcG9ydHMpIHtcbiAgICAgICAgdmFyIGJpdHJhdGUgPSBzdW0ocmVwb3J0cy5tYXAoZnVuY3Rpb24gKHJlcG9ydCkgeyByZXR1cm4gcmVwb3J0LmJpdHJhdGU7IH0pKTtcbiAgICAgICAgdmFyIHJ0dCA9IGF2ZXJhZ2UocmVwb3J0cy5tYXAoZnVuY3Rpb24gKHJlcG9ydCkgeyByZXR1cm4gcmVwb3J0LnJ0dDsgfSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYml0cmF0ZTogYml0cmF0ZSxcbiAgICAgICAgICAgIHJ0dDogcnR0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gU2VuZGVyUmVwb3J0O1xufShTZW5kZXJPclJlY2VpdmVyUmVwb3J0KSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlclJlcG9ydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbmRlcnJlcG9ydC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5ID0gcmVxdWlyZSgnLi9zZW5kZXJvcnJlY2VpdmVycmVwb3J0ZmFjdG9yeScpO1xudmFyIFNlbmRlclJlcG9ydCA9IHJlcXVpcmUoJy4vc2VuZGVycmVwb3J0Jyk7XG4vKipcbiAqIEBleHRlbmRzIHtTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeX1cbiAqIEBwcm9wZXJ0eSB7P1NlbmRlclJlcG9ydH0gbGFzdFJlcG9ydFxuICovXG52YXIgU2VuZGVyUmVwb3J0RmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VuZGVyUmVwb3J0RmFjdG9yeSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgU2VuZGVyUmVwb3J0RmFjdG9yeX0uXG4gICAgICogQHBhcmFtIHtUcmFja0lkfSB0cmFja0lkXG4gICAgICogQHBhcmFtIHtSVENTdGF0c30gaW5pdGlhbFN0YXRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VuZGVyUmVwb3J0RmFjdG9yeSh0cmFja0lkLCBpbml0aWFsU3RhdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbFN0YXRzLmlkLCB0cmFja0lkLCBpbml0aWFsU3RhdHMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBsYXN0UmVwb3J0OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyYWNrSWR9IHRyYWNrSWRcbiAgICAgKiBAcGFyYW0ge1JUQ1N0YXRzfSBuZXdlclN0YXRzXG4gICAgICogQHBhcmFtIHtSVENSZW1vdGVJbmJvdW5kUnRwU3RyZWFtU3RhdHN9IFtuZXdlclJlbW90ZVN0YXRzXVxuICAgICAqIEByZXR1cm5zIHtTZW5kZXJSZXBvcnR9XG4gICAgICovXG4gICAgU2VuZGVyUmVwb3J0RmFjdG9yeS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh0cmFja0lkLCBuZXdlclN0YXRzLCBuZXdlclJlbW90ZVN0YXRzKSB7XG4gICAgICAgIHZhciBvbGRlclN0YXRzID0gdGhpcy5sYXN0U3RhdHM7XG4gICAgICAgIHRoaXMubGFzdFN0YXRzID0gbmV3ZXJTdGF0cztcbiAgICAgICAgdGhpcy50cmFja0lkID0gdHJhY2tJZDtcbiAgICAgICAgdmFyIHJlcG9ydCA9IFNlbmRlclJlcG9ydC5vZih0cmFja0lkLCBvbGRlclN0YXRzLCBuZXdlclN0YXRzLCBuZXdlclJlbW90ZVN0YXRzKTtcbiAgICAgICAgdGhpcy5sYXN0UmVwb3J0ID0gcmVwb3J0O1xuICAgICAgICByZXR1cm4gcmVwb3J0O1xuICAgIH07XG4gICAgcmV0dXJuIFNlbmRlclJlcG9ydEZhY3Rvcnk7XG59KFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5KSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlclJlcG9ydEZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW5kZXJyZXBvcnRmYWN0b3J5LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBMb2NhbEF1ZGlvVHJhY2tTdGF0cyA9IHJlcXVpcmUoJy4vbG9jYWxhdWRpb3RyYWNrc3RhdHMnKTtcbnZhciBMb2NhbFZpZGVvVHJhY2tTdGF0cyA9IHJlcXVpcmUoJy4vbG9jYWx2aWRlb3RyYWNrc3RhdHMnKTtcbnZhciBSZW1vdGVBdWRpb1RyYWNrU3RhdHMgPSByZXF1aXJlKCcuL3JlbW90ZWF1ZGlvdHJhY2tzdGF0cycpO1xudmFyIFJlbW90ZVZpZGVvVHJhY2tTdGF0cyA9IHJlcXVpcmUoJy4vcmVtb3RldmlkZW90cmFja3N0YXRzJyk7XG4vKipcbiAqIFN0YXRpc3RpY3MgcmVwb3J0IGZvciBhbiBSVENQZWVyQ29ubmVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwZWVyQ29ubmVjdGlvbklkIC0gSUQgb2YgdGhlIFJUQ1BlZXJDb25uZWN0aW9uXG4gKiBAcHJvcGVydHkge0FycmF5PExvY2FsQXVkaW9UcmFja1N0YXRzPn0gbG9jYWxBdWRpb1RyYWNrU3RhdHMgLSBMaXN0IG9mIHtAbGluayBMb2NhbEF1ZGlvVHJhY2tTdGF0c31cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8TG9jYWxWaWRlb1RyYWNrU3RhdHM+fSBsb2NhbFZpZGVvVHJhY2tTdGF0cyAtIExpc3Qgb2Yge0BsaW5rIExvY2FsVmlkZW9UcmFja1N0YXRzfVxuICogQHByb3BlcnR5IHtBcnJheTxSZW1vdGVBdWRpb1RyYWNrU3RhdHM+fSByZW1vdGVBdWRpb1RyYWNrU3RhdHMgLSBMaXN0IG9mIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrU3RhdHN9XG4gKiBAcHJvcGVydHkge0FycmF5PFJlbW90ZVZpZGVvVHJhY2tTdGF0cz59IHJlbW90ZVZpZGVvVHJhY2tTdGF0cyAtIExpc3Qgb2Yge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2tTdGF0c31cbiAqL1xudmFyIFN0YXRzUmVwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwZWVyQ29ubmVjdGlvbklkIC0gUlRDUGVlckNvbm5lY3Rpb24gSURcbiAgICAgKiBAcGFyYW0ge1N0YW5kYXJkaXplZFN0YXRzUmVzcG9uc2V9IHN0YXRzUmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXBhcmVGb3JJbnNpZ2h0cyAtIGlmIHJlcG9ydCBpcyBiZWluZyBwcmVwYXJlZCB0byBzZW5kIHRvIGluc2lnaHRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YXRzUmVwb3J0KHBlZXJDb25uZWN0aW9uSWQsIHN0YXRzUmVzcG9uc2UsIHByZXBhcmVGb3JJbnNpZ2h0cykge1xuICAgICAgICBpZiAodHlwZW9mIHBlZXJDb25uZWN0aW9uSWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JUQ1BlZXJDb25uZWN0aW9uIGlkIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbklkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBlZXJDb25uZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvY2FsQXVkaW9UcmFja1N0YXRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0YXRzUmVzcG9uc2UubG9jYWxBdWRpb1RyYWNrU3RhdHMubWFwKGZ1bmN0aW9uIChyZXBvcnQpIHsgcmV0dXJuIG5ldyBMb2NhbEF1ZGlvVHJhY2tTdGF0cyhyZXBvcnQudHJhY2tJZCwgcmVwb3J0LCBwcmVwYXJlRm9ySW5zaWdodHMpOyB9KSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9jYWxWaWRlb1RyYWNrU3RhdHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RhdHNSZXNwb25zZS5sb2NhbFZpZGVvVHJhY2tTdGF0cy5tYXAoZnVuY3Rpb24gKHJlcG9ydCkgeyByZXR1cm4gbmV3IExvY2FsVmlkZW9UcmFja1N0YXRzKHJlcG9ydC50cmFja0lkLCByZXBvcnQsIHByZXBhcmVGb3JJbnNpZ2h0cyk7IH0pLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdGVBdWRpb1RyYWNrU3RhdHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RhdHNSZXNwb25zZS5yZW1vdGVBdWRpb1RyYWNrU3RhdHMubWFwKGZ1bmN0aW9uIChyZXBvcnQpIHsgcmV0dXJuIG5ldyBSZW1vdGVBdWRpb1RyYWNrU3RhdHMocmVwb3J0LnRyYWNrSWQsIHJlcG9ydCk7IH0pLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdGVWaWRlb1RyYWNrU3RhdHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RhdHNSZXNwb25zZS5yZW1vdGVWaWRlb1RyYWNrU3RhdHMubWFwKGZ1bmN0aW9uIChyZXBvcnQpIHsgcmV0dXJuIG5ldyBSZW1vdGVWaWRlb1RyYWNrU3RhdHMocmVwb3J0LnRyYWNrSWQsIHJlcG9ydCk7IH0pLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBTdGF0c1JlcG9ydDtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRzUmVwb3J0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdHNyZXBvcnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcnx1bmRlZmluZWQ+fSB4c1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc3VtKHhzKSB7XG4gICAgcmV0dXJuIHhzLnJlZHVjZShmdW5jdGlvbiAoeSwgeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInID8geCArIHkgOiB5OyB9LCAwKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gc3VtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3VtLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogU3RhdGlzdGljcyBmb3IgYSB7QGxpbmsgVHJhY2t9LlxuICogQHByb3BlcnR5IHtUcmFjay5JRH0gdHJhY2tJZCAtIFRoZSB7QGxpbmsgVHJhY2t9IElEXG4gKiBAcHJvcGVydHkge1RyYWNrLlNJRH0gdHJhY2tTaWQgLSBUaGUge0BsaW5rIFRyYWNrfSdzIFNJRCB3aGVuIHB1Ymxpc2hlZCBpblxuICogIGluIGEge0BsaW5rIFJvb219XG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZXN0YW1wIC0gQSBVbml4IHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHMgaW5kaWNhdGluZ1xuICogICB3aGVuIHRoZSB7QGxpbmsgVHJhY2tTdGF0c30gd2VyZSBnYXRoZXJlZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNzcmMgLSBUaGUge0BsaW5rIFRyYWNrfSdzIFNTUkMgd2hlbiB0cmFuc21pdHRlZCBvdmVyIHRoZVxuICogICBSVENQZWVyQ29ubmVjdGlvblxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBwYWNrZXRzTG9zdCAtIFRoZSBudW1iZXIgb2YgcGFja2V0cyBsb3N0XG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IGNvZGVjIC0gVGhlIG5hbWUgb2YgdGhlIGNvZGVjIHVzZWQgdG8gZW5jb2RlIHRoZVxuICogICB7QGxpbmsgVHJhY2t9J3MgbWVkaWFcbiAqL1xudmFyIFRyYWNrU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWNrSWQgLSB7QGxpbmsgVHJhY2t9IElEXG4gICAgICogQHBhcmFtIHtTdGFuZGFyZGl6ZWRUcmFja1N0YXRzUmVwb3J0fSBzdGF0c1JlcG9ydFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYWNrU3RhdHModHJhY2tJZCwgc3RhdHNSZXBvcnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFja0lkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFjayBpZCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgdHJhY2tJZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0cmFja0lkLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFja1NpZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzdGF0c1JlcG9ydC50cmFja1NpZCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZXN0YW1wOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0YXRzUmVwb3J0LnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3NyYzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzdGF0c1JlcG9ydC5zc3JjLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYWNrZXRzTG9zdDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlb2Ygc3RhdHNSZXBvcnQucGFja2V0c0xvc3QgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdHNSZXBvcnQucGFja2V0c0xvc3RcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2RlYzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlb2Ygc3RhdHNSZXBvcnQuY29kZWNOYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHN0YXRzUmVwb3J0LmNvZGVjTmFtZVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFRyYWNrU3RhdHM7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBUcmFja1N0YXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2tzdGF0cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbi8qKlxuICogQSB7QGxpbmsgVHJhY2tUcmFuc2NlaXZlcn0gcmVwcmVzZW50cyBlaXRoZXIgb25lIG9yIG1vcmUgbG9jYWwgUlRDUnRwU2VuZGVyc1xuICogb3IgUlRDRGF0YUNoYW5uZWxzLCBvciBhIHNpbmdsZSBSVENSdHBSZWNlaXZlciBvciByZW1vdGUgUlRDRGF0YUNoYW5uZWwuXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBwcm9wZXJ0eSB7VHJhY2suSUR9IGlkXG4gKiBAcHJvcGVydHkge1RyYWNrLmtpbmR9IGtpbmRcbiAqL1xudmFyIFRyYWNrVHJhbnNjZWl2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYWNrVHJhbnNjZWl2ZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFRyYWNrVHJhbnNjZWl2ZXJ9LlxuICAgICAqIEBwYXJhbSB7VHJhY2suSUR9IGlkXG4gICAgICogQHBhcmFtIHtUcmFjay5raW5kfSBraW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhY2tUcmFuc2NlaXZlcihpZCwga2luZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtpbmQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBraW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIHtAbGluayBUcmFja1RyYW5zY2VpdmVyfS5cbiAgICAgKiAjZW1pdHMgVHJhY2tUcmFuc2NlaXZlciNzdG9wcGVkXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgVHJhY2tUcmFuc2NlaXZlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdzdG9wcGVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhY2tUcmFuc2NlaXZlcjtcbn0oRXZlbnRFbWl0dGVyKSk7XG4vKipcbiAqIFRoZSB7QGxpbmsgVHJhY2tUcmFuc2NlaXZlcn0gd2FzIHN0b3BwZWQuXG4gKiBAZXZlbnQgVHJhY2tUcmFuc2NlaXZlciNzdG9wcGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVHJhY2tUcmFuc2NlaXZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zY2VpdmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICByZXR1cm4gdG87XG59O1xudmFyIFN0YXRlTWFjaGluZSA9IHJlcXVpcmUoJy4vc3RhdGVtYWNoaW5lJyk7XG52YXIgX2EgPSByZXF1aXJlKCcuL3V0aWwnKSwgYnVpbGRMb2dMZXZlbHMgPSBfYS5idWlsZExvZ0xldmVscywgbWFrZVVVSUQgPSBfYS5tYWtlVVVJRDtcbnZhciBMb2cgPSByZXF1aXJlKCcuL3V0aWwvbG9nJyk7XG52YXIgTmV0d29ya01vbml0b3IgPSByZXF1aXJlKCcuL3V0aWwvbmV0d29ya21vbml0b3InKTtcbnZhciBUaW1lb3V0ID0gcmVxdWlyZSgnLi91dGlsL3RpbWVvdXQnKTtcbnZhciBuSW5zdGFuY2VzID0gMDtcbi8qXG4gIFR3aWxpb0Nvbm5lY3Rpb24gc3RhdGVzXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZcbiAgKy0tLS0tLS0tLSsgICAgICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICArLS0tLS0tLS0tLStcbiAgfCAgZWFybHkgIHwgLS0tLT4gfCAgY29ubmVjdGluZyAgfCAtLS0tPiB8ICBjbG9zZWQgIHxcbiAgKy0tLS0tLS0tLSsgICAgICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICArLS0tLS0tLS0tLStcbiAgICBeICAgICAgICAgICAgICAgICAgICAgfCBeIHwgICAgICAgICAgICAgICAgIF4gXlxuICAgIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgfCAgICAgICAgICAgICAgICAgfCB8XG4gICAgfCB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8ICAgICAgICAgICAgICAgICB8IHxcbiAgICB8IHwgfCAtLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0gfFxuICAgIHwgdiB8IHwgICAgICAgICAgICAgICAgICAgdiAgICAgICAgICAgICAgICAgICB8XG4gICstLS0tLS0tLS0tKyAgICAgICAgICAgKy0tLS0tLS0tKyAgICAgICAgICAgICAgIHxcbiAgfCB3YWl0aW5nICB8IC0tLS0tLS0tPiB8ICBvcGVuICB8IC0tLS0tLS0tLS0tLS0tLVxuICArLS0tLS0tLS0tLSsgICAgICAgICAgICstLS0tLS0tLStcbiAqL1xudmFyIHN0YXRlcyA9IHtcbiAgICBjbG9zZWQ6IFtdLFxuICAgIGNvbm5lY3Rpbmc6IFsnY2xvc2VkJywgJ29wZW4nLCAnd2FpdGluZyddLFxuICAgIGVhcmx5OiBbJ2Nsb3NlZCcsICdjb25uZWN0aW5nJ10sXG4gICAgb3BlbjogWydjbG9zZWQnXSxcbiAgICB3YWl0aW5nOiBbJ2Nsb3NlZCcsICdjb25uZWN0aW5nJywgJ2Vhcmx5JywgJ29wZW4nXVxufTtcbnZhciBldmVudHMgPSB7XG4gICAgY2xvc2VkOiAnY2xvc2UnLFxuICAgIG9wZW46ICdvcGVuJyxcbiAgICB3YWl0aW5nOiAnd2FpdGluZydcbn07XG52YXIgVENNUF9WRVJTSU9OID0gMjtcbnZhciBERUZBVUxUX01BWF9DT05TRUNVVElWRV9NSVNTRURfSEVBUlRCRUFUUyA9IDM7XG52YXIgREVGQVVMVF9NQVhfQ09OU0VDVVRJVkVfRkFJTEVEX0hFTExPUyA9IDM7XG52YXIgREVGQVVMVF9NQVhfUkVRVUVTVEVEX0hFQVJUQkVBVF9USU1FT1VUID0gNTAwMDtcbnZhciBERUZBVUxUX09QRU5fVElNRU9VVCA9IDE1MDAwO1xudmFyIERFRkFVTFRfV0VMQ09NRV9USU1FT1VUID0gNTAwMDtcbnZhciBPVVRHT0lOR19IRUFSVEJFQVRfT0ZGU0VUID0gMjAwO1xudmFyIFdTX0NMT1NFX05PUk1BTCA9IDEwMDA7XG52YXIgV1NfQ0xPU0VfV0VMQ09NRV9USU1FT1VUID0gMzAwMDtcbnZhciBXU19DTE9TRV9IRUFSVEJFQVRTX01JU1NFRCA9IDMwMDE7XG52YXIgV1NfQ0xPU0VfSEVMTE9fRkFJTEVEID0gMzAwMjtcbnZhciBXU19DTE9TRV9TRU5EX0ZBSUxFRCA9IDMwMDM7XG52YXIgV1NfQ0xPU0VfTkVUV09SS19DSEFOR0VEID0gMzAwNDtcbnZhciBXU19DTE9TRV9CVVNZX1dBSVQgPSAzMDA1O1xudmFyIFdTX0NMT1NFX1NFUlZFUl9CVVNZID0gMzAwNjtcbnZhciBXU19DTE9TRV9PUEVOX1RJTUVPVVQgPSAzMDA3O1xudmFyIHRvcGxldmVsID0gZ2xvYmFsLndpbmRvdyB8fCBnbG9iYWw7XG52YXIgV2ViU29ja2V0ID0gdG9wbGV2ZWwuV2ViU29ja2V0ID8gdG9wbGV2ZWwuV2ViU29ja2V0IDogcmVxdWlyZSgnd3MnKTtcbnZhciBDbG9zZVJlYXNvbiA9IHtcbiAgICBCVVNZOiAnYnVzeScsXG4gICAgRkFJTEVEOiAnZmFpbGVkJyxcbiAgICBMT0NBTDogJ2xvY2FsJyxcbiAgICBSRU1PVEU6ICdyZW1vdGUnLFxuICAgIFRJTUVPVVQ6ICd0aW1lb3V0J1xufTtcbnZhciB3c0Nsb3NlQ29kZXNUb0Nsb3NlUmVhc29ucyA9IG5ldyBNYXAoW1xuICAgIFtXU19DTE9TRV9XRUxDT01FX1RJTUVPVVQsIENsb3NlUmVhc29uLlRJTUVPVVRdLFxuICAgIFtXU19DTE9TRV9IRUFSVEJFQVRTX01JU1NFRCwgQ2xvc2VSZWFzb24uVElNRU9VVF0sXG4gICAgW1dTX0NMT1NFX0hFTExPX0ZBSUxFRCwgQ2xvc2VSZWFzb24uRkFJTEVEXSxcbiAgICBbV1NfQ0xPU0VfU0VORF9GQUlMRUQsIENsb3NlUmVhc29uLkZBSUxFRF0sXG4gICAgW1dTX0NMT1NFX05FVFdPUktfQ0hBTkdFRCwgQ2xvc2VSZWFzb24uVElNRU9VVF0sXG4gICAgW1dTX0NMT1NFX1NFUlZFUl9CVVNZLCBDbG9zZVJlYXNvbi5CVVNZXSxcbiAgICBbV1NfQ0xPU0VfT1BFTl9USU1FT1VULCBDbG9zZVJlYXNvbi5USU1FT1VUXVxuXSk7XG4vKipcbiAqIEEge0BsaW5rIFR3aWxpb0Nvbm5lY3Rpb259IHJlcHJlc2VudHMgYSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICogdG8gYSBUd2lsaW8gQ29ubmVjdGlvbnMgTWVzc2FnaW5nIFByb3RvY29sIChUQ01QKSBzZXJ2ZXIuXG4gKiBAZmlyZXMgVHdpbGlvQ29ubmVjdGlvbiNjbG9zZVxuICogQGZpcmVzIFR3aWxpb0Nvbm5lY3Rpb24jZXJyb3JcbiAqIEBmaXJlcyBUd2lsaW9Db25uZWN0aW9uI21lc3NhZ2VcbiAqIEBmaXJlcyBUd2lsaW9Db25uZWN0aW9uI29wZW5cbiAqIEBmaXJlcyBUd2lsaW9Db25uZWN0aW9uI3dhaXRpbmdcbiAqL1xudmFyIFR3aWxpb0Nvbm5lY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFR3aWxpb0Nvbm5lY3Rpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFR3aWxpb0Nvbm5lY3Rpb259LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJVcmwgLSBUQ01QIHNlcnZlciB1cmxcbiAgICAgKiBAcGFyYW0ge1R3aWxpb0Nvbm5lY3Rpb25PcHRpb25zfSBvcHRpb25zIC0ge0BsaW5rIFR3aWxpb0Nvbm5lY3Rpb259IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUd2lsaW9Db25uZWN0aW9uKHNlcnZlclVybCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnZWFybHknLCBzdGF0ZXMpIHx8IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGhlbGxvQm9keTogbnVsbCxcbiAgICAgICAgICAgIG1heENvbnNlY3V0aXZlRmFpbGVkSGVsbG9zOiBERUZBVUxUX01BWF9DT05TRUNVVElWRV9GQUlMRURfSEVMTE9TLFxuICAgICAgICAgICAgbWF4Q29uc2VjdXRpdmVNaXNzZWRIZWFydGJlYXRzOiBERUZBVUxUX01BWF9DT05TRUNVVElWRV9NSVNTRURfSEVBUlRCRUFUUyxcbiAgICAgICAgICAgIHJlcXVlc3RlZEhlYXJ0YmVhdFRpbWVvdXQ6IERFRkFVTFRfTUFYX1JFUVVFU1RFRF9IRUFSVEJFQVRfVElNRU9VVCxcbiAgICAgICAgICAgIG9wZW5UaW1lb3V0OiBERUZBVUxUX09QRU5fVElNRU9VVCxcbiAgICAgICAgICAgIHdlbGNvbWVUaW1lb3V0OiBERUZBVUxUX1dFTENPTUVfVElNRU9VVCxcbiAgICAgICAgICAgIExvZzogTG9nLFxuICAgICAgICAgICAgV2ViU29ja2V0OiBXZWJTb2NrZXRcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBsb2dMZXZlbHMgPSBidWlsZExvZ0xldmVscyhvcHRpb25zLmxvZ0xldmVsKTtcbiAgICAgICAgdmFyIGxvZyA9IG5ldyBvcHRpb25zLkxvZygnZGVmYXVsdCcsIF90aGlzLCBsb2dMZXZlbHMsIG9wdGlvbnMubG9nZ2VyTmFtZSk7XG4gICAgICAgIHZhciBuZXR3b3JrTW9uaXRvciA9IG9wdGlvbnMubmV0d29ya01vbml0b3IgPyBuZXcgTmV0d29ya01vbml0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBuZXR3b3JrTW9uaXRvci50eXBlO1xuICAgICAgICAgICAgdmFyIHJlYXNvbiA9IFwiTmV0d29yayBjaGFuZ2VkXCIgKyAodHlwZSA/IFwiIHRvIFwiICsgdHlwZSA6ICcnKTtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhyZWFzb24pO1xuICAgICAgICAgICAgX3RoaXMuX2Nsb3NlKHsgY29kZTogV1NfQ0xPU0VfTkVUV09SS19DSEFOR0VELCByZWFzb246IHJlYXNvbiB9KTtcbiAgICAgICAgfSkgOiBudWxsO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2J1c3lXYWl0VGltZW91dDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NvbnNlY3V0aXZlSGVhcnRiZWF0c01pc3NlZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2Nvb2tpZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2V2ZW50T2JzZXJ2ZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5ldmVudE9ic2VydmVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2hlYXJ0YmVhdFRpbWVvdXQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9oZWxsb3NMZWZ0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMubWF4Q29uc2VjdXRpdmVGYWlsZWRIZWxsb3MsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW5zdGFuY2VJZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiArK25JbnN0YW5jZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9nOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGxvZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9tZXNzYWdlUXVldWU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbmV0d29ya01vbml0b3I6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV0d29ya01vbml0b3JcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29wZW5UaW1lb3V0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2VuZEhlYXJ0YmVhdFRpbWVvdXQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZXJ2ZXJVcmw6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2VydmVyVXJsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3dlbGNvbWVUaW1lb3V0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfd3M6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGV2ZW50c1RvTGV2ZWxzID0ge1xuICAgICAgICAgICAgY29ubmVjdGluZzogJ2luZm8nLFxuICAgICAgICAgICAgZWFybHk6ICdpbmZvJyxcbiAgICAgICAgICAgIG9wZW46ICdpbmZvJyxcbiAgICAgICAgICAgIHdhaXRpbmc6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgIGNsb3NlZDogJ2luZm8nXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdC5hcHBseShfdGhpcywgX19zcHJlYWRBcnJheShbZXZlbnRzW3N0YXRlXV0sIF9fcmVhZChhcmdzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV2ZW50ID0geyBuYW1lOiBzdGF0ZSwgZ3JvdXA6ICdzaWduYWxpbmcnLCBsZXZlbDogZXZlbnRzVG9MZXZlbHNbX3RoaXMuc3RhdGVdIH07XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKGFyZ3MsIDEpLCByZWFzb24gPSBfYVswXTtcbiAgICAgICAgICAgICAgICBldmVudC5wYXlsb2FkID0geyByZWFzb246IHJlYXNvbiB9O1xuICAgICAgICAgICAgICAgIGV2ZW50LmxldmVsID0gcmVhc29uID09PSBDbG9zZVJlYXNvbi5MT0NBTCA/ICdpbmZvJyA6ICdlcnJvcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fZXZlbnRPYnNlcnZlci5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLl9ldmVudE9ic2VydmVyLmVtaXQoJ2V2ZW50JywgeyBuYW1lOiBfdGhpcy5zdGF0ZSwgZ3JvdXA6ICdzaWduYWxpbmcnLCBsZXZlbDogZXZlbnRzVG9MZXZlbHNbX3RoaXMuc3RhdGVdIH0pO1xuICAgICAgICBfdGhpcy5fY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFR3aWxpb0Nvbm5lY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbVHdpbGlvQ29ubmVjdGlvbiAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgdGhpcy5fd3MudXJsICsgXCJdXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUge0BsaW5rIFR3aWxpb0Nvbm5lY3Rpb259LlxuICAgICAqIEBwYXJhbSB7e2NvZGU6IG51bWJlciwgcmVhc29uOiBzdHJpbmd9fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHdpbGlvQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjb2RlID0gX2EuY29kZSwgcmVhc29uID0gX2EucmVhc29uO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3BlblRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX29wZW5UaW1lb3V0LmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3dlbGNvbWVUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLl93ZWxjb21lVGltZW91dC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRUaW1lb3V0LmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NlbmRIZWFydGJlYXRUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kSGVhcnRiZWF0VGltZW91dC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9uZXR3b3JrTW9uaXRvcikge1xuICAgICAgICAgICAgdGhpcy5fbmV0d29ya01vbml0b3Iuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9idXN5V2FpdFRpbWVvdXQgJiYgY29kZSAhPT0gV1NfQ0xPU0VfQlVTWV9XQUlUKSB7XG4gICAgICAgICAgICB0aGlzLl9idXN5V2FpdFRpbWVvdXQuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZXNzYWdlUXVldWUuc3BsaWNlKDApO1xuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBpZiAoY29kZSA9PT0gV1NfQ0xPU0VfTk9STUFMKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoJ0Nsb3NlZCcpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uKCdjbG9zZWQnLCBudWxsLCBbQ2xvc2VSZWFzb24uTE9DQUxdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiQ2xvc2VkOiBcIiArIGNvZGUgKyBcIiAtIFwiICsgcmVhc29uKTtcbiAgICAgICAgICAgIGlmIChjb2RlICE9PSBXU19DTE9TRV9CVVNZX1dBSVQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oJ2Nsb3NlZCcsIG51bGwsIFtcbiAgICAgICAgICAgICAgICAgICAgd3NDbG9zZUNvZGVzVG9DbG9zZVJlYXNvbnMuZ2V0KGNvZGUpIHx8IENsb3NlUmVhc29uLlJFTU9URVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWFkeVN0YXRlID0gdGhpcy5fd3MucmVhZHlTdGF0ZTtcbiAgICAgICAgdmFyIFdlYlNvY2tldCA9IHRoaXMuX29wdGlvbnMuV2ViU29ja2V0O1xuICAgICAgICBpZiAocmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNMT1NJTkcgJiYgcmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgICAgICAgdGhpcy5fd3MuY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgVENNUCBzZXJ2ZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uLnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvZyA9IHRoaXMuX2xvZztcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICd3YWl0aW5nJykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uKCdlYXJseScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgIT09ICdlYXJseScpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiVW5leHBlY3RlZCBzdGF0ZSBcXFwiXCIgKyB0aGlzLnN0YXRlICsgXCJcXFwiIGZvciBjb25uZWN0aW5nIHRvIHRoZVwiXG4gICAgICAgICAgICAgICAgKyAnIFRDTVAgc2VydmVyLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dzID0gbmV3IHRoaXMuX29wdGlvbnMuV2ViU29ja2V0KHRoaXMuX3NlcnZlclVybCk7XG4gICAgICAgIHZhciB3cyA9IHRoaXMuX3dzO1xuICAgICAgICBsb2cuZGVidWcoJ0NyZWF0ZWQgYSBuZXcgV2ViU29ja2V0OicsIHdzKTtcbiAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLl9jbG9zZShldmVudCk7IH0pO1xuICAgICAgICB2YXIgb3BlblRpbWVvdXQgPSB0aGlzLl9vcHRpb25zLm9wZW5UaW1lb3V0O1xuICAgICAgICAvLyBBZGQgYSB0aW1lb3V0IGZvciBnZXR0aW5nIHRoZSBvbm9wZW4gZXZlbnQgb24gdGhlIFdlYlNvY2tldCAoMTUgc2VjKS4gQWZ0ZXIgdGhhdCwgYXR0ZW1wdCB0byByZWNvbm5lY3Qgb25seSBpZiB0aGlzIGlzIG5vdCB0aGUgZmlyc3QgYXR0ZW1wdC5cbiAgICAgICAgdGhpcy5fb3BlblRpbWVvdXQgPSBuZXcgVGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVhc29uID0gXCJGYWlsZWQgdG8gb3BlbiBpbiBcIiArIG9wZW5UaW1lb3V0ICsgXCIgbXNcIjtcbiAgICAgICAgICAgIF90aGlzLl9jbG9zZSh7IGNvZGU6IFdTX0NMT1NFX09QRU5fVElNRU9VVCwgcmVhc29uOiByZWFzb24gfSk7XG4gICAgICAgIH0sIG9wZW5UaW1lb3V0KTtcbiAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZygnV2ViU29ja2V0IG9wZW5lZDonLCB3cyk7XG4gICAgICAgICAgICBfdGhpcy5fb3BlblRpbWVvdXQuY2xlYXIoKTtcbiAgICAgICAgICAgIF90aGlzLl9zdGFydEhhbmRzaGFrZSgpO1xuICAgICAgICAgICAgaWYgKF90aGlzLl9uZXR3b3JrTW9uaXRvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9uZXR3b3JrTW9uaXRvci5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoXCJJbmNvbWluZzogXCIgKyBtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdiYWQnOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlQmFkKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdidXN5JzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUJ1c3kobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2J5ZSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21zZyc6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBFYWNoIGluY29taW5nIG1lc3NhZ2Ugc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYW4gaW5jb21pbmdcbiAgICAgICAgICAgICAgICAvLyBoZWFydGJlYXQgaW50ZW50aW9uYWxseSBmYWxsaW5nIHRocm91Z2ggdG8gJ2hlYXJ0YmVhdCcgY2FzZS5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlICdoZWFydGJlYXQnOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlSGVhcnRiZWF0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlbGNvbWUnOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlV2VsY29tZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZyhcIlVua25vd24gbWVzc2FnZSB0eXBlOiBcIiArIG1lc3NhZ2UudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKFwiVW5rbm93biBtZXNzYWdlIHR5cGU6IFwiICsgbWVzc2FnZS50eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbiBpbmNvbWluZyBcImJhZFwiIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHt7cmVhc29uOiBzdHJpbmd9fSBtZXNzYWdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uLnByb3RvdHlwZS5faGFuZGxlQmFkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciByZWFzb24gPSBfYS5yZWFzb247XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIGlmICghWydjb25uZWN0aW5nJywgJ29wZW4nXS5pbmNsdWRlcyh0aGlzLnN0YXRlKSkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJVbmV4cGVjdGVkIHN0YXRlIFxcXCJcIiArIHRoaXMuc3RhdGUgKyBcIlxcXCIgZm9yIGhhbmRsaW5nIGEgXFxcImJhZFxcXCIgbWVzc2FnZVwiXG4gICAgICAgICAgICAgICAgKyAnIGZyb20gdGhlIFRDTVAgc2VydmVyLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiQ2xvc2luZzogXCIgKyBXU19DTE9TRV9IRUxMT19GQUlMRUQgKyBcIiAtIFwiICsgcmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlKHsgY29kZTogV1NfQ0xPU0VfSEVMTE9fRkFJTEVELCByZWFzb246IHJlYXNvbiB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2cuZGVidWcoXCJFcnJvcjogXCIgKyByZWFzb24pO1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKHJlYXNvbikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFuIGluY29taW5nIFwiYnVzeVwiIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHt7Y29va2llOiA/c3RyaW5nLCBrZWVwQWxpdmU6IGJvb2xlYW4sIHJldHJ5QWZ0ZXI6IG51bWJlcn19IG1lc3NhZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb24ucHJvdG90eXBlLl9oYW5kbGVCdXN5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb29raWUgPSBfYS5jb29raWUsIGtlZXBBbGl2ZSA9IF9hLmtlZXBBbGl2ZSwgcmV0cnlBZnRlciA9IF9hLnJldHJ5QWZ0ZXI7XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIGlmICghWydjb25uZWN0aW5nJywgJ3dhaXRpbmcnXS5pbmNsdWRlcyh0aGlzLnN0YXRlKSkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJVbmV4cGVjdGVkIHN0YXRlIFxcXCJcIiArIHRoaXMuc3RhdGUgKyBcIlxcXCIgZm9yIGhhbmRsaW5nIGEgXFxcImJ1c3lcXFwiIG1lc3NhZ2VcIlxuICAgICAgICAgICAgICAgICsgJyBmcm9tIHRoZSBUQ01QIHNlcnZlci4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYnVzeVdhaXRUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLl9idXN5V2FpdFRpbWVvdXQuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fd2VsY29tZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlbGNvbWVUaW1lb3V0LmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlYXNvbiA9IHJldHJ5QWZ0ZXIgPCAwXG4gICAgICAgICAgICA/ICdSZWNlaXZlZCB0ZXJtaW5hbCBcImJ1c3lcIiBtZXNzYWdlJ1xuICAgICAgICAgICAgOiBcIlJlY2VpdmVkIFxcXCJidXN5XFxcIiBtZXNzYWdlLCByZXRyeWluZyBhZnRlciBcIiArIHJldHJ5QWZ0ZXIgKyBcIiBtc1wiO1xuICAgICAgICBpZiAocmV0cnlBZnRlciA8IDApIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiQ2xvc2luZzogXCIgKyBXU19DTE9TRV9TRVJWRVJfQlVTWSArIFwiIC0gXCIgKyByZWFzb24pO1xuICAgICAgICAgICAgdGhpcy5fY2xvc2UoeyBjb2RlOiBXU19DTE9TRV9TRVJWRVJfQlVTWSwgcmVhc29uOiByZWFzb24gfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heENvbnNlY3V0aXZlRmFpbGVkSGVsbG9zID0gdGhpcy5fb3B0aW9ucy5tYXhDb25zZWN1dGl2ZUZhaWxlZEhlbGxvcztcbiAgICAgICAgdGhpcy5faGVsbG9zTGVmdCA9IG1heENvbnNlY3V0aXZlRmFpbGVkSGVsbG9zO1xuICAgICAgICB0aGlzLl9jb29raWUgPSBjb29raWUgfHwgbnVsbDtcbiAgICAgICAgaWYgKGtlZXBBbGl2ZSkge1xuICAgICAgICAgICAgbG9nLndhcm4ocmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuX2J1c3lXYWl0VGltZW91dCA9IG5ldyBUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9zdGFydEhhbmRzaGFrZSgpOyB9LCByZXRyeUFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiQ2xvc2luZzogXCIgKyBXU19DTE9TRV9CVVNZX1dBSVQgKyBcIiAtIFwiICsgcmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlKHsgY29kZTogV1NfQ0xPU0VfQlVTWV9XQUlULCByZWFzb246IHJlYXNvbiB9KTtcbiAgICAgICAgICAgIHRoaXMuX2J1c3lXYWl0VGltZW91dCA9IG5ldyBUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9jb25uZWN0KCk7IH0sIHJldHJ5QWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbignd2FpdGluZycsIG51bGwsIFtrZWVwQWxpdmUsIHJldHJ5QWZ0ZXJdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbiBpbmNvbWluZyBcImhlYXJ0YmVhdFwiIG1lc3NhZ2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uLnByb3RvdHlwZS5faGFuZGxlSGVhcnRiZWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIlVuZXhwZWN0ZWQgc3RhdGUgXFxcIlwiICsgdGhpcy5zdGF0ZSArIFwiXFxcIiBmb3IgaGFuZGxpbmcgYSBcXFwiaGVhcnRiZWF0XFxcIlwiXG4gICAgICAgICAgICAgICAgKyAnIG1lc3NhZ2UgZnJvbSB0aGUgVENNUCBzZXJ2ZXIuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhcnRiZWF0VGltZW91dC5yZXNldCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEgbWlzc2VkIFwiaGVhcnRiZWF0XCIgbWVzc2FnZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb24ucHJvdG90eXBlLl9oYW5kbGVIZWFydGJlYXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZyA9IHRoaXMuX2xvZztcbiAgICAgICAgdmFyIG1heENvbnNlY3V0aXZlTWlzc2VkSGVhcnRiZWF0cyA9IHRoaXMuX29wdGlvbnMubWF4Q29uc2VjdXRpdmVNaXNzZWRIZWFydGJlYXRzO1xuICAgICAgICBsb2cuZGVidWcoXCJDb25zZWN1dGl2ZSBoZWFydGJlYXRzIG1pc3NlZDogXCIgKyBtYXhDb25zZWN1dGl2ZU1pc3NlZEhlYXJ0YmVhdHMpO1xuICAgICAgICB2YXIgcmVhc29uID0gXCJNaXNzZWQgXCIgKyBtYXhDb25zZWN1dGl2ZU1pc3NlZEhlYXJ0YmVhdHMgKyBcIiBcXFwiaGVhcnRiZWF0XFxcIiBtZXNzYWdlc1wiO1xuICAgICAgICBsb2cud2FybihcIkNsb3Npbmc6IFwiICsgV1NfQ0xPU0VfSEVBUlRCRUFUU19NSVNTRUQgKyBcIiAtIFwiICsgcmVhc29uKTtcbiAgICAgICAgdGhpcy5fY2xvc2UoeyBjb2RlOiBXU19DTE9TRV9IRUFSVEJFQVRTX01JU1NFRCwgcmVhc29uOiByZWFzb24gfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW4gaW5jb21pbmcgXCJtc2dcIiBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7e2JvZHk6IG9iamVjdH19IG1lc3NhZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb24ucHJvdG90eXBlLl9oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBib2R5ID0gX2EuYm9keTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJVbmV4cGVjdGVkIHN0YXRlIFxcXCJcIiArIHRoaXMuc3RhdGUgKyBcIlxcXCIgZm9yIGhhbmRsaW5nIGEgXFxcIm1zZ1xcXCIgbWVzc2FnZVwiXG4gICAgICAgICAgICAgICAgKyAnIGZyb20gdGhlIFRDTVAgc2VydmVyLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJvZHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFuIGluY29taW5nIFwid2VsY29tZVwiIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHt7IG5lZ290aWF0ZWRUaW1lb3V0OiBudW1iZXIgfX0gbWVzc2FnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHdpbGlvQ29ubmVjdGlvbi5wcm90b3R5cGUuX2hhbmRsZVdlbGNvbWUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5lZ290aWF0ZWRUaW1lb3V0ID0gX2EubmVnb3RpYXRlZFRpbWVvdXQ7XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIGlmICghWydjb25uZWN0aW5nJywgJ3dhaXRpbmcnXS5pbmNsdWRlcyh0aGlzLnN0YXRlKSkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJVbmV4cGVjdGVkIHN0YXRlIFxcXCJcIiArIHRoaXMuc3RhdGUgKyBcIlxcXCIgZm9yIGhhbmRsaW5nIGEgXFxcIndlbGNvbWVcXFwiXCJcbiAgICAgICAgICAgICAgICArICcgbWVzc2FnZSBmcm9tIHRoZSBUQ01QIHNlcnZlci4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3dhaXRpbmcnKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoJ1JlY2VpdmVkIFwid2VsY29tZVwiIG1lc3NhZ2UsIG5vIG5lZWQgdG8gcmV0cnkgY29ubmVjdGlvbi4nKTtcbiAgICAgICAgICAgIHRoaXMuX2J1c3lXYWl0VGltZW91dC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhDb25zZWN1dGl2ZU1pc3NlZEhlYXJ0YmVhdHMgPSB0aGlzLl9vcHRpb25zLm1heENvbnNlY3V0aXZlTWlzc2VkSGVhcnRiZWF0cztcbiAgICAgICAgdmFyIGhlYXJ0YmVhdFRpbWVvdXQgPSBuZWdvdGlhdGVkVGltZW91dCAqIG1heENvbnNlY3V0aXZlTWlzc2VkSGVhcnRiZWF0cztcbiAgICAgICAgdmFyIG91dGdvaW5nSGVhcnRiZWF0VGltZW91dCA9IG5lZ290aWF0ZWRUaW1lb3V0IC0gT1VUR09JTkdfSEVBUlRCRUFUX09GRlNFVDtcbiAgICAgICAgdGhpcy5fd2VsY29tZVRpbWVvdXQuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0VGltZW91dCA9IG5ldyBUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9oYW5kbGVIZWFydGJlYXRUaW1lb3V0KCk7IH0sIGhlYXJ0YmVhdFRpbWVvdXQpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlUXVldWUuc3BsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIF90aGlzLl9zZW5kKG1lc3NhZ2UpOyB9KTtcbiAgICAgICAgdGhpcy5fc2VuZEhlYXJ0YmVhdFRpbWVvdXQgPSBuZXcgVGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc2VuZEhlYXJ0YmVhdCgpOyB9LCBvdXRnb2luZ0hlYXJ0YmVhdFRpbWVvdXQpO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24oJ29wZW4nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIG1pc3NlZCBcIndlbGNvbWVcIiBtZXNzYWdlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHdpbGlvQ29ubmVjdGlvbi5wcm90b3R5cGUuX2hhbmRsZVdlbGNvbWVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZyA9IHRoaXMuX2xvZztcbiAgICAgICAgaWYgKHRoaXMuX2hlbGxvc0xlZnQgPD0gMCkge1xuICAgICAgICAgICAgdmFyIHJlYXNvbiA9ICdBbGwgaGFuZHNoYWtlIGF0dGVtcHRzIGZhaWxlZCc7XG4gICAgICAgICAgICBsb2cud2FybihcIkNsb3Npbmc6IFwiICsgV1NfQ0xPU0VfV0VMQ09NRV9USU1FT1VUICsgXCIgLSBcIiArIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZSh7IGNvZGU6IFdTX0NMT1NFX1dFTENPTUVfVElNRU9VVCwgcmVhc29uOiByZWFzb24gfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heENvbnNlY3V0aXZlRmFpbGVkSGVsbG9zID0gdGhpcy5fb3B0aW9ucy5tYXhDb25zZWN1dGl2ZUZhaWxlZEhlbGxvcztcbiAgICAgICAgbG9nLndhcm4oXCJIYW5kc2hha2UgYXR0ZW1wdCBcIiArIChtYXhDb25zZWN1dGl2ZUZhaWxlZEhlbGxvcyAtIHRoaXMuX2hlbGxvc0xlZnQpICsgXCIgZmFpbGVkXCIpO1xuICAgICAgICB0aGlzLl9zdGFydEhhbmRzaGFrZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIFRDTVAgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7Kn0gbWVzc2FnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHdpbGlvQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgcmVhZHlTdGF0ZSA9IHRoaXMuX3dzLnJlYWR5U3RhdGU7XG4gICAgICAgIHZhciBXZWJTb2NrZXQgPSB0aGlzLl9vcHRpb25zLldlYlNvY2tldDtcbiAgICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiT3V0Z29pbmc6IFwiICsgZGF0YSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dzLnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlbmRIZWFydGJlYXRUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggb3V0Z29pbmcgbWVzc2FnZSBpcyB0byBiZSB0cmVhdGVkIGFzIGFuIG91dGdvaW5nIGhlYXJ0YmVhdC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VuZEhlYXJ0YmVhdFRpbWVvdXQucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhc29uID0gJ0ZhaWxlZCB0byBzZW5kIG1lc3NhZ2UnO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiQ2xvc2luZzogXCIgKyBXU19DTE9TRV9TRU5EX0ZBSUxFRCArIFwiIC0gXCIgKyByZWFzb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlKHsgY29kZTogV1NfQ0xPU0VfU0VORF9GQUlMRUQsIHJlYXNvbjogcmVhc29uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIGEgXCJoZWFydGJlYXRcIiBtZXNzYWdlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHdpbGlvQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NlbmRIZWFydGJlYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlbmQoeyB0eXBlOiAnaGVhcnRiZWF0JyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgYSBcImhlbGxvXCIgbWVzc2FnZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb24ucHJvdG90eXBlLl9zZW5kSGVsbG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX29wdGlvbnMsIGhlbGxvQm9keSA9IF9hLmhlbGxvQm9keSwgdGltZW91dCA9IF9hLnJlcXVlc3RlZEhlYXJ0YmVhdFRpbWVvdXQ7XG4gICAgICAgIHZhciBoZWxsbyA9IHtcbiAgICAgICAgICAgIGlkOiBtYWtlVVVJRCgpLFxuICAgICAgICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgICAgICAgIHR5cGU6ICdoZWxsbycsXG4gICAgICAgICAgICB2ZXJzaW9uOiBUQ01QX1ZFUlNJT05cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2Nvb2tpZSkge1xuICAgICAgICAgICAgaGVsbG8uY29va2llID0gdGhpcy5fY29va2llO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWxsb0JvZHkpIHtcbiAgICAgICAgICAgIGhlbGxvLmJvZHkgPSBoZWxsb0JvZHk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VuZChoZWxsbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIG9yIGVucXVldWUgYSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7Kn0gbWVzc2FnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHdpbGlvQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NlbmRPckVucXVldWUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VuZE9yRW5xdWV1ZSA9IHRoaXMuc3RhdGUgPT09ICdvcGVuJ1xuICAgICAgICAgICAgPyBmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gX3RoaXMuX3NlbmQobWVzc2FnZSk7IH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIF90aGlzLl9tZXNzYWdlUXVldWUucHVzaChtZXNzYWdlKTsgfTtcbiAgICAgICAgc2VuZE9yRW5xdWV1ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBUQ01QIGhhbmRzaGFrZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb24ucHJvdG90eXBlLl9zdGFydEhhbmRzaGFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKFsnZWFybHknLCAnd2FpdGluZyddLmluY2x1ZGVzKHRoaXMuc3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVsbG9zTGVmdC0tO1xuICAgICAgICB0aGlzLl9zZW5kSGVsbG8oKTtcbiAgICAgICAgdmFyIHdlbGNvbWVUaW1lb3V0ID0gdGhpcy5fb3B0aW9ucy53ZWxjb21lVGltZW91dDtcbiAgICAgICAgdGhpcy5fd2VsY29tZVRpbWVvdXQgPSBuZXcgVGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faGFuZGxlV2VsY29tZVRpbWVvdXQoKTsgfSwgd2VsY29tZVRpbWVvdXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIHtAbGluayBUd2lsaW9Db25uZWN0aW9ufS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VuZE9yRW5xdWV1ZSh7IHR5cGU6ICdieWUnIH0pO1xuICAgICAgICB0aGlzLl9jbG9zZSh7IGNvZGU6IFdTX0NMT1NFX05PUk1BTCwgcmVhc29uOiAnTm9ybWFsJyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgYSBcIm1zZ1wiIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHsqfSBib2R5XG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgVHdpbGlvQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICB0aGlzLl9zZW5kT3JFbnF1ZXVlKHsgYm9keTogYm9keSwgdHlwZTogJ21zZycgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVHdpbGlvQ29ubmVjdGlvbjtcbn0oU3RhdGVNYWNoaW5lKSk7XG4vKipcbiAqIEEgdW5pcXVlIHN0cmluZyBkZXBpY3RpbmcgdGhlIHJlYXNvbiBmb3IgdGhlIHtAbGluayBUd2lsaW9Db25uZWN0aW9ufSBiZWluZyBjbG9zZWQuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5Ud2lsaW9Db25uZWN0aW9uLkNsb3NlUmVhc29uID0gQ2xvc2VSZWFzb247XG4vKipcbiAqIEEge0BsaW5rIFR3aWxpb0Nvbm5lY3Rpb259IHdhcyBjbG9zZWQuXG4gKiBAZXZlbnQgVHdpbGlvQ29ubmVjdGlvbiNjbG9zZVxuICogQHBhcmFtIHtDbG9zZVJlYXNvbn0gcmVhc29uIC0gVGhlIHJlYXNvbiBmb3IgdGhlIHtAbGluayBUd2lsaW9Db25uZWN0aW9ufSBiZWluZyBjbG9zZWRcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBUd2lsaW9Db25uZWN0aW9ufSByZWNlaXZlZCBhbiBlcnJvciBmcm9tIHRoZSBUQ01QIHNlcnZlci5cbiAqIEBldmVudCBUd2lsaW9Db25uZWN0aW9uI2Vycm9yXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciAtIFRoZSBUQ01QIHNlcnZlciBlcnJvclxuICovXG4vKipcbiAqIEEge0BsaW5rIFR3aWxpb0Nvbm5lY3Rpb259IHJlY2VpdmVkIGEgbWVzc2FnZSBmcm9tIHRoZSBUQ01QIHNlcnZlci5cbiAqIEBldmVudCBUd2lsaW9Db25uZWN0aW9uI21lc3NhZ2VcbiAqIEBwYXJhbSB7Kn0gYm9keSAtIE1lc3NhZ2UgYm9keVxuICovXG4vKipcbiAqIEEge0BsaW5rIFR3aWxpb0Nvbm5lY3Rpb259IGNvbXBsZXRlZCBhIGhlbGxvL3dlbGNvbWUgaGFuZHNoYWtlIHdpdGggdGhlIFRDTVAgc2VydmVyLlxuICogQGV2ZW50IFR3aWxpb0Nvbm5lY3Rpb24jb3BlblxuICovXG4vKipcbiAqIEEge0BsaW5rIFR3aWxpb0Nvbm5lY3Rpb259IHJlY2VpdmVkIGEgXCJidXN5XCIgbWVzc2FnZSBmcm9tIHRoZSBUQ01QIHNlcnZlci5cbiAqIEBldmVudCBUd2lsaW9Db25uZWN0aW9uI3dhaXRpbmdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcEFsaXZlIC0gdHJ1ZSBpZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgcmV0YWluZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXRyeUFmdGVyIC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIGEgcmV0cnkgaXMgYXR0ZW1wdGVkXG4gKi9cbi8qKlxuICoge0BsaW5rIFR3aWxpb0Nvbm5lY3Rpb259IG9wdGlvbnNcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFR3aWxpb0Nvbm5lY3Rpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge0V2ZW50T2JzZXJ2ZXJ9IFtldmVudE9ic2VydmVyXSAtIE9wdGlvbmFsIGV2ZW50IG9ic2VydmVyXG4gKiBAcHJvcGVydHkgeyp9IFtoZWxsb0JvZHk9bnVsbF0gLSBPcHRpb25hbCBib2R5IGZvciBcImhlbGxvXCIgbWVzc2FnZVxuICogQHByb3BlcnR5IHtMb2dMZXZlbH0gW2xvZ0xldmVsPXdhcm5dIC0gTG9nIGxldmVsIG9mIHRoZSB7QGxpbmsgVHdpbGlvQ29ubmVjdGlvbn1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Q29uc2VjdXRpdmVGYWlsZWRIZWxsb3M9M10gLSBNYXguIG51bWJlciBvZiBjb25zZWN1dGl2ZSBmYWlsZWQgXCJoZWxsb1wic1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhDb25zZWN1dGl2ZU1pc3NlZEhlYXJ0YmVhdHM9M10gLSBNYXguIG51bWJlciBvZiAoZWZmZWN0aXZlKSBjb25zZWN1dGl2ZSBcImhlYXJ0YmVhdFwiIG1lc3NhZ2VzIHRoYXQgY2FuIGJlIG1pc3NlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXF1ZXN0ZWRIZWFydGJlYXRUaW1lb3V0PTUwMDBdIC0gXCJoZWFydGJlYXRcIiB0aW1lb3V0IChtcykgcmVxdWVzdGVkIGJ5IHRoZSB7QGxpbmsgVHdpbGlvQ29ubmVjdGlvbn1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd2VsY29tZVRpbWVvdXQ9NTAwMF0gLSBUaW1lIChtcykgdG8gd2FpdCBmb3IgdGhlIFwid2VsY29tZVwiIG1lc3NhZ2UgYWZ0ZXIgc2VuZGluZyB0aGUgXCJoZWxsb1wiIG1lc3NhZ2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBUd2lsaW9Db25uZWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHdpbGlvY29ubmVjdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgZGVmZXIgPSByZXF1aXJlKCcuLycpLmRlZmVyO1xuLyoqXG4gKiBBbiB7QGxpbmsgQXN5bmNWYXJ9IGlzIGFuIFwiYXN5bmNocm9ub3VzIHZhcmlhYmxlXCIgd2hpY2ggbWF5IG9yIG1heSBub3RcbiAqIGNvbnRhaW4gYSB2YWx1ZSBvZiBzb21lIHR5cGUgVC4gWW91IGNhbiBwdXQgYSB2YWx1ZSBpbnRvIHRoZSB7QGxpbmsgQXN5bmNWYXJ9XG4gKiB3aXRoIHtAbGluayBBc3luY1ZhciNwdXR9LiBDYWxsZXJzIGNhbiB0YWtlIGEgdmFsdWUgb3V0IG9mIHRoZVxuICoge0BsaW5rIEFzeW5jVmFyfSBieSBxdWV1ZWluZyB1cCB3aXRoIHtAbGluayBBc3luY1ZhciN0YWtlfS4gTiBjYWxscyB0b1xuICoge0BsaW5rIEFzeW5jVmFyI3Rha2V9IHJlcXVpcmUgTiBjYWxscyB0byB7QGxpbmsgQXN5bmNWYXIjcHV0fSB0byByZXNvbHZlLCBhbmRcbiAqIHRoZXkgcmVzb2x2ZSBpbiBvcmRlci5cbiAqL1xudmFyIEFzeW5jVmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiB7QGxpbmsgQXN5bmNWYXJ9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jVmFyKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBfZGVmZXJyZWRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2hhc1ZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1dCBhIHZhbHVlIGludG8gdGhlIHtAbGluayBBc3luY1Zhcn0uXG4gICAgICogQHBhcmFtIHtUfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIEFzeW5jVmFyLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSB0aGlzLl9kZWZlcnJlZHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGRlZmVycmVkKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRha2UgdGhlIHZhbHVlIG91dCBvZiB0aGUge0BsaW5rIEFzeW5jVmFyfS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUPn1cbiAgICAgKi9cbiAgICBBc3luY1Zhci5wcm90b3R5cGUudGFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2hhc1ZhbHVlICYmICF0aGlzLl9kZWZlcnJlZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgdGhpcy5fZGVmZXJyZWRzLnB1c2goZGVmZXJyZWQpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgX3RoaXMuX2hhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jVmFyO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gQXN5bmNWYXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luY3Zhci5qcy5tYXAiLCIvKiBnbG9iYWxzIGNocm9tZSwgbmF2aWdhdG9yICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBpcyBhbiBBbmRyb2lkIGRldmljZS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0FuZHJvaWQoKSB7XG4gICAgcmV0dXJuIC9BbmRyb2lkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgYW4gaU9TIGRldmljZS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0lPUygpIHtcbiAgICByZXR1cm4gL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBpcyBhIG1vYmlsZSBicm93c2VyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gICAgcmV0dXJuIC9Nb2JpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgbm9uLUNocm9taXVtIEVkZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gYnJvd3NlclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTm9uQ2hyb21pdW1FZGdlKGJyb3dzZXIpIHtcbiAgICByZXR1cm4gYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgL0VkZ2UvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgKHR5cGVvZiBjaHJvbWUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBjaHJvbWUucnVudGltZSA9PT0gJ3VuZGVmaW5lZCcpO1xufVxuLyoqXG4gKiBHZXQgdGhlIG5hbWUgb2YgdGhlIHJlYnJhbmRlZCBDaHJvbWl1bSBicm93c2VyLCBpZiBhbnkuIFJlLWJyYW5kZWQgQ2hyb21lJ3MgdXNlclxuICogYWdlbnQgaGFzIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuICogPHNvdXJjZT4vPHZlcnNpb24+ICg8b3M+KSA8ZW5naW5lPi88dmVyc2lvbj4gKDxlbmdpbmVfbmFtZT4pIENocm9tZS88dmVyc2lvbj4gW01vYmlsZV0gU2FmYXJpLzx2ZXJzaW9uPlxuICogQHBhcmFtIGJyb3dzZXJcbiAqIEByZXR1cm5zIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSByZWJyYW5kZWQgQ2hyb21lIGJyb3dzZXIsIG9yIG51bGwgaWYgdGhlIGJyb3dzZXJcbiAqICAgaXMgZWl0aGVyIG5vdCBDaHJvbWUgb3IgdmFuaWxsYSBDaHJvbWUuXG4gKi9cbmZ1bmN0aW9uIHJlYnJhbmRlZENocm9tZUJyb3dzZXIoYnJvd3Nlcikge1xuICAgIC8vIElmIHRoZSBicm93c2VyIGlzIG5vdCBDaHJvbWUgYmFzZWQsIHRoZW4gaXQgaXMgbm90IGEgcmVicmFuZGVkIENocm9tZSBicm93c2VyLlxuICAgIGlmIChicm93c2VyICE9PSAnY2hyb21lJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTGF0ZXN0IGRlc2t0b3AgQnJhdmUgYnJvd3NlciBoYXMgYSBcImJyYXZlXCIgcHJvcGVydHkgaW4gbmF2aWdhdG9yLlxuICAgIGlmICgnYnJhdmUnIGluIG5hdmlnYXRvcikge1xuICAgICAgICByZXR1cm4gJ2JyYXZlJztcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBcIiguKylcIiBlbnRyaWVzIGZyb20gdGhlIHVzZXIgYWdlbnQgdGhlcmVieSByZXRhaW5pbmcgb25seSB0aGVcbiAgICAvLyA8bmFtZT5bLzx2ZXJzaW9uPl0gZW50cmllcy5cbiAgICB2YXIgcGFyZW50aGVzaXplZFN1YnN0cmluZ3MgPSBnZXRQYXJlbnRoZXNpemVkU3Vic3RyaW5ncyhuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgbmFtZUFuZFZlcnNpb25zID0gcGFyZW50aGVzaXplZFN1YnN0cmluZ3MucmVkdWNlKGZ1bmN0aW9uICh1c2VyQWdlbnQsIHN1YnN0cmluZykgeyByZXR1cm4gdXNlckFnZW50LnJlcGxhY2Uoc3Vic3RyaW5nLCAnJyk7IH0sIG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIC8vIEV4dHJhY3QgdGhlIHBvdGVudGlhbCBicm93c2VyIDxuYW1lPnMgYnkgaWdub3JpbmcgdGhlIGZpcnN0IHR3byBuYW1lcywgd2hpY2hcbiAgICAvLyBwb2ludCB0byA8c291cmNlPiBhbmQgPGVuZ2luZT4uXG4gICAgdmFyIG1hdGNoZXMgPSBuYW1lQW5kVmVyc2lvbnMubWF0Y2goL1teXFxzXSsvZykgfHwgW107XG4gICAgdmFyIF9hID0gX19yZWFkKG1hdGNoZXMubWFwKGZ1bmN0aW9uIChuYW1lQW5kVmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmFtZUFuZFZlcnNpb24uc3BsaXQoJy8nKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgIH0pKSwgYnJvd3Nlck5hbWVzID0gX2Euc2xpY2UoMik7XG4gICAgLy8gRXh0cmFjdCB0aGUgPG5hbWU+IHRoYXQgaXMgbm90IGV4cGVjdGVkIHRvIGJlIHByZXNlbnQgaW4gdGhlIHZhbmlsbGEgQ2hyb21lXG4gICAgLy8gYnJvd3Nlciwgd2hpY2ggaW5kaWNhdGVzIHRoZSByZWJyYW5kZWQgbmFtZSAoZXg6IFwiZWRnW2VdXCIsIFwiZWxlY3Ryb25cIikuIElmIG51bGwsXG4gICAgLy8gdGhlbiB0aGlzIGlzIGEgdmFuaWxsYSBDaHJvbWUgYnJvd3Nlci5cbiAgICByZXR1cm4gYnJvd3Nlck5hbWVzLmZpbmQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICFbJ2Nocm9tZScsICdtb2JpbGUnLCAnc2FmYXJpJ10uaW5jbHVkZXMobmFtZSk7XG4gICAgfSkgfHwgbnVsbDtcbn1cbi8qKlxuICogR2V0IHRoZSBuYW1lIG9mIHRoZSBtb2JpbGUgd2Via2l0IGJhc2VkIGJyb3dzZXIsIGlmIGFueS5cbiAqIEBwYXJhbSBicm93c2VyXG4gKiBAcmV0dXJucyB7P3N0cmluZ30gTmFtZSBvZiB0aGUgbW9iaWxlIHdlYmtpdCBiYXNlZCBicm93c2VyLCBvciBudWxsIGlmIHRoZSBicm93c2VyXG4gKiAgIGlzIGVpdGhlciBub3Qgd2Via2l0IGJhc2VkIG9yIG1vYmlsZSBzYWZhcmkuXG4gKi9cbmZ1bmN0aW9uIG1vYmlsZVdlYktpdEJyb3dzZXIoYnJvd3Nlcikge1xuICAgIGlmIChicm93c2VyICE9PSAnc2FmYXJpJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCdicmF2ZScgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAgIHJldHVybiAnYnJhdmUnO1xuICAgIH1cbiAgICByZXR1cm4gWydlZGdlJywgJ2VkZyddLmZpbmQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhuYW1lKTtcbiAgICB9KSB8fCBudWxsO1xufVxuLyoqXG4gKiBHZXQgdGhlIHRvcCBsZXZlbCBwYXJlbnRoZXNpemVkIHN1YnN0cmluZ3Mgd2l0aGluIGEgZ2l2ZW4gc3RyaW5nLiBVbm1hdGNoZWRcbiAqIHBhcmVudGhlc2VzIGFyZSBpZ25vcmVkLlxuICogRXg6IFwiYWJjKSAoZGVmKSBnaChpaikgKGtsIChtbilvKSAocHFyXCIgPT4gW1wiKGRlZilcIiwgXCIoaWopXCIsIFwiKGtsIChtbilvKVwiXVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ1tdfVxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRoZXNpemVkU3Vic3RyaW5ncyhzdHJpbmcpIHtcbiAgICB2YXIgb3BlblBhcmVudGhlc2lzUG9zaXRpb25zID0gW107XG4gICAgdmFyIHN1YnN0cmluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RyaW5nW2ldID09PSAnKCcpIHtcbiAgICAgICAgICAgIG9wZW5QYXJlbnRoZXNpc1Bvc2l0aW9ucy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0cmluZ1tpXSA9PT0gJyknICYmIG9wZW5QYXJlbnRoZXNpc1Bvc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgb3BlblBhcmVudGhlc2lzUG9zaXRpb24gPSBvcGVuUGFyZW50aGVzaXNQb3NpdGlvbnMucG9wKCk7XG4gICAgICAgICAgICBpZiAob3BlblBhcmVudGhlc2lzUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN1YnN0cmluZ3MucHVzaChzdHJpbmcuc3Vic3RyaW5nKG9wZW5QYXJlbnRoZXNpc1Bvc2l0aW9uLCBpICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzdHJpbmdzO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNBbmRyb2lkOiBpc0FuZHJvaWQsXG4gICAgaXNJT1M6IGlzSU9TLFxuICAgIGlzTW9iaWxlOiBpc01vYmlsZSxcbiAgICBpc05vbkNocm9taXVtRWRnZTogaXNOb25DaHJvbWl1bUVkZ2UsXG4gICAgbW9iaWxlV2ViS2l0QnJvd3NlcjogbW9iaWxlV2ViS2l0QnJvd3NlcixcbiAgICByZWJyYW5kZWRDaHJvbWVCcm93c2VyOiByZWJyYW5kZWRDaHJvbWVCcm93c2VyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3NlcmRldGVjdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICByZXR1cm4gdG87XG59O1xuLyoqXG4gKiBBIFByb21pc2UgdGhhdCBjYW4gYmUgY2FuY2VsZWQgd2l0aCB7QGxpbmsgQ2FuY2VsYWJsZVByb21pc2UjY2FuY2VsfS5cbiAqIEBleHRlbmRzIFByb21pc2VcbiovXG52YXIgQ2FuY2VsYWJsZVByb21pc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IHtAbGluayBDYW5jZWxhYmxlUHJvbWlzZX0uXG4gICAgICogQHBhcmFtIHtDYW5jZWxhYmxlUHJvbWlzZS5PbkNyZWF0ZX0gb25DcmVhdGVcbiAgICAgKiBAcGFyYW0ge0NhbmNlbGFibGVQcm9taXNlLk9uQ2FuY2VsfSBvbkNhbmNlbFxuICAgICovIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIHtAbGluayBDYW5jZWxhYmxlUHJvbWlzZX0gY3JlYXRpb25cbiAgICAgKiBAdHlwZWRlZiB7ZnVuY3Rpb259IENhbmNlbGFibGVQcm9taXNlLk9uQ3JlYXRlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigqKX0gcmVzb2x2ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IHJlamVjdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogYm9vbGVhbn0gaXNDYW5jZWxlZFxuICAgICovIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4ge0BsaW5rIENhbmNlbGFibGVQcm9taXNlI2NhbmNlbH0gaXMgY2FsbGVkXG4gICAgICogQHR5cGVkZWYge2Z1bmN0aW9ufSBDYW5jZWxhYmxlUHJvbWlzZS5PbkNhbmNlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENhbmNlbGFibGVQcm9taXNlKG9uQ3JlYXRlLCBvbkNhbmNlbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBfaXNDYW5jZWxhYmxlOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaXNDYW5jZWxlZDoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkNhbmNlbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvbkNhbmNlbFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfcHJvbWlzZScsIHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgb25DcmVhdGUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc0NhbmNlbGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNDYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9pc0NhbmNlbGVkOyB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzeW5jaHJvbm91c2x5LXJlamVjdGVkIHtAbGluayBDYW5jZWxhYmxlUHJvbWlzZX0uXG4gICAgICogQHBhcmFtIHsqfSByZWFzb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICBDYW5jZWxhYmxlUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FuY2VsYWJsZVByb21pc2UoZnVuY3Rpb24gcmVqZWN0ZWQocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gb25DYW5jZWwoKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHN5bmNocm9ub3VzbHktcmVzb2x2ZWQge0BsaW5rIENhbmNlbGFibGVQcm9taXNlfS5cbiAgICAgKiBAcGFyYW0geyp8UHJvbWlzZTwqPnxUaGVuYWJsZTwqPn0gcmVzdWx0XG4gICAgICogQHJldHVybnMge0NhbmNlbGFibGVQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIENhbmNlbGFibGVQcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FuY2VsYWJsZVByb21pc2UoZnVuY3Rpb24gcmVzb2x2ZWQocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbiBvbkNhbmNlbCgpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBjYW5jZWwgdGhlIHtAbGluayBDYW5jZWxhYmxlUHJvbWlzZX0uXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgQ2FuY2VsYWJsZVByb21pc2UucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5faXNDYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9vbkNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25SZWplY3RlZFxuICAgICAqIEByZXR1cm5zIHtDYW5jZWxhYmxlUHJvbWlzZX1cbiAgICAgKi9cbiAgICBDYW5jZWxhYmxlUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2U7XG4gICAgICAgIHJldHVybiBuZXcgQ2FuY2VsYWJsZVByb21pc2UoZnVuY3Rpb24gb25DcmVhdGUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBwcm9taXNlLmNhdGNoLmFwcGx5KHByb21pc2UsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSkpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSwgdGhpcy5fb25DYW5jZWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb259IG9uUmVzb2x2ZWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb25SZWplY3RlZF1cbiAgICAgKiBAcmV0dXJucyB7Q2FuY2VsYWJsZVByb21pc2V9XG4gICAgICovXG4gICAgQ2FuY2VsYWJsZVByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2U7XG4gICAgICAgIHJldHVybiBuZXcgQ2FuY2VsYWJsZVByb21pc2UoZnVuY3Rpb24gb25DcmVhdGUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4uYXBwbHkocHJvbWlzZSwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpKSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9LCB0aGlzLl9vbkNhbmNlbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IG9uRmluYWxseVxuICAgKiBAcmV0dXJucyB7Q2FuY2VsYWJsZVByb21pc2V9XG4gICAqL1xuICAgIENhbmNlbGFibGVQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlO1xuICAgICAgICByZXR1cm4gbmV3IENhbmNlbGFibGVQcm9taXNlKGZ1bmN0aW9uIG9uQ3JlYXRlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcHJvbWlzZS5maW5hbGx5LmFwcGx5KHByb21pc2UsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSkpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSwgdGhpcy5fb25DYW5jZWwpO1xuICAgIH07XG4gICAgcmV0dXJuIENhbmNlbGFibGVQcm9taXNlO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsYWJsZVByb21pc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYW5jZWxhYmxlcHJvbWlzZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgcGFja2FnZUluZm8gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKTtcbm1vZHVsZS5leHBvcnRzLlNES19OQU1FID0gcGFja2FnZUluZm8ubmFtZSArIFwiLmpzXCI7XG5tb2R1bGUuZXhwb3J0cy5TREtfVkVSU0lPTiA9IHBhY2thZ2VJbmZvLnZlcnNpb247XG5tb2R1bGUuZXhwb3J0cy5TRFBfRk9STUFUID0gJ3VuaWZpZWQnO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9FTlZJUk9OTUVOVCA9ICdwcm9kJztcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfUkVBTE0gPSAndXMxJztcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfUkVHSU9OID0gJ2dsbCc7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX0xPR19MRVZFTCA9ICd3YXJuJztcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfTE9HR0VSX05BTUUgPSAndHdpbGlvLXZpZGVvJztcbm1vZHVsZS5leHBvcnRzLldTX1NFUlZFUiA9IGZ1bmN0aW9uIChlbnZpcm9ubWVudCwgcmVnaW9uKSB7XG4gICAgcmVnaW9uID0gcmVnaW9uID09PSAnZ2xsJyA/ICdnbG9iYWwnIDogZW5jb2RlVVJJQ29tcG9uZW50KHJlZ2lvbik7XG4gICAgcmV0dXJuIGVudmlyb25tZW50ID09PSAncHJvZCdcbiAgICAgICAgPyBcIndzczovL1wiICsgcmVnaW9uICsgXCIudnNzLnR3aWxpby5jb20vc2lnbmFsaW5nXCJcbiAgICAgICAgOiBcIndzczovL1wiICsgcmVnaW9uICsgXCIudnNzLlwiICsgZW52aXJvbm1lbnQgKyBcIi50d2lsaW8uY29tL3NpZ25hbGluZ1wiO1xufTtcbm1vZHVsZS5leHBvcnRzLlBVQkxJU0hfTUFYX0FUVEVNUFRTID0gNTtcbm1vZHVsZS5leHBvcnRzLlBVQkxJU0hfQkFDS09GRl9KSVRURVIgPSAxMDtcbm1vZHVsZS5leHBvcnRzLlBVQkxJU0hfQkFDS09GRl9NUyA9IDIwO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcHByb3ByaWF0ZSBpbmRlZmluaXRlIGFydGljbGUgKFwiYVwiIHwgXCJhblwiKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB3b3JkIC0gVGhlIHdvcmQgd2hpY2ggZGV0ZXJtaW5lcyB3aGV0aGVyIFwiYVwiIHwgXCJhblwiIGlzIHJldHVybmVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBcImFcIiBpZiB3b3JkJ3MgZmlyc3QgbGV0dGVyIGlzIGEgdm93ZWwsIFwiYW5cIiBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gYXJ0aWNsZSh3b3JkKSB7XG4gICAgLy8gTk9URShtbWFsYXZhbGxpKTogVGhpcyB3aWxsIG5vdCBiZSBhY2N1cmF0ZSBmb3Igd29yZHMgbGlrZSBcImhvdXJcIixcbiAgICAvLyB3aGljaCBoYXZlIGNvbnNvbmFudHMgYXMgdGhlaXIgZmlyc3QgY2hhcmFjdGVyLCBidXQgYXJlIHByb25vdW5jZWQgbGlrZVxuICAgIC8vIHZvd2Vscy4gV2UgY2FuIGFkZHJlc3MgdGhpcyBpc3N1ZSBpZiB0aGUgbmVlZCBhcmlzZXMuXG4gICAgcmV0dXJuIFsnYScsICdlJywgJ2knLCAnbycsICd1J10uaW5jbHVkZXMod29yZC50b0xvd2VyQ2FzZSgpWzBdKSA/ICdhbicgOiAnYSc7XG59XG5tb2R1bGUuZXhwb3J0cy50eXBlRXJyb3JzID0ge1xuICAgIElMTEVHQUxfSU5WT0tFOiBmdW5jdGlvbiAobmFtZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgY2FsbCB0byBcIiArIG5hbWUgKyBcIjogXCIgKyBjb250ZXh0KTtcbiAgICB9LFxuICAgIElOVkFMSURfVFlQRTogZnVuY3Rpb24gKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IobmFtZSArIFwiIG11c3QgYmUgXCIgKyBhcnRpY2xlKHR5cGUpICsgXCIgXCIgKyB0eXBlKTtcbiAgICB9LFxuICAgIElOVkFMSURfVkFMVUU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKG5hbWUgKyBcIiBtdXN0IGJlIG9uZSBvZiBcIiArIHZhbHVlcy5qb2luKCcsICcpKTtcbiAgICB9LFxuICAgIFJFUVVJUkVEX0FSR1VNRU5UOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihuYW1lICsgXCIgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfRlJBTUVfUkFURSA9IDI0O1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9WSURFT19QUk9DRVNTT1JfU1RBVFNfSU5URVJWQUxfTVMgPSAxMDAwMDtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfSUNFX0dBVEhFUklOR19USU1FT1VUX01TID0gMTUwMDA7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX1NFU1NJT05fVElNRU9VVF9TRUMgPSAzMDtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfTlFfTEVWRUxfTE9DQUwgPSAxO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9OUV9MRVZFTF9SRU1PVEUgPSAwO1xubW9kdWxlLmV4cG9ydHMuTUFYX05RX0xFVkVMID0gMztcbm1vZHVsZS5leHBvcnRzLklDRV9BQ1RJVklUWV9DSEVDS19QRVJJT0RfTVMgPSAxMDAwO1xubW9kdWxlLmV4cG9ydHMuSUNFX0lOQUNUSVZJVFlfVEhSRVNIT0xEX01TID0gMzAwMDtcbm1vZHVsZS5leHBvcnRzLmljZVJlc3RhcnRCYWNrb2ZmQ29uZmlnID0ge1xuICAgIGZhY3RvcjogMS4xLFxuICAgIGluaXRpYWxEZWxheTogMSxcbiAgICBtYXhEZWxheTogbW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TRVNTSU9OX1RJTUVPVVRfU0VDICogMTAwMCxcbiAgICByYW5kb21pc2F0aW9uRmFjdG9yOiAwLjVcbn07XG5tb2R1bGUuZXhwb3J0cy5yZWNvbm5lY3RCYWNrb2ZmQ29uZmlnID0ge1xuICAgIGZhY3RvcjogMS41LFxuICAgIGluaXRpYWxEZWxheTogODAsXG4gICAgcmFuZG9taXNhdGlvbkZhY3RvcjogMC41XG59O1xubW9kdWxlLmV4cG9ydHMuc3Vic2NyaXB0aW9uTW9kZSA9IHtcbiAgICBNT0RFX0NPTExBQk9SQVRJT046ICdjb2xsYWJvcmF0aW9uJyxcbiAgICBNT0RFX0dSSUQ6ICdncmlkJyxcbiAgICBNT0RFX1BSRVNFTlRBVElPTjogJ3ByZXNlbnRhdGlvbidcbn07XG5tb2R1bGUuZXhwb3J0cy50cmFja1N3aXRjaE9mZk1vZGUgPSB7XG4gICAgTU9ERV9ESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBNT0RFX0RFVEVDVEVEOiAnZGV0ZWN0ZWQnLFxuICAgIE1PREVfUFJFRElDVEVEOiAncHJlZGljdGVkJ1xufTtcbm1vZHVsZS5leHBvcnRzLnRyYWNrU3dpdGNoT2ZmUmVhc29uID0ge1xuICAgIERJU0FCTEVEX0JZX1BVQkxJU0hFUjogJ2Rpc2FibGVkLWJ5LXB1Ymxpc2hlcicsXG4gICAgRElTQUJMRURfQllfU1VCU0NSSUJFUjogJ2Rpc2FibGVkLWJ5LXN1YnNjcmliZXInLFxuICAgIE1BWF9CQU5EV0lEVEhfUkVBQ0hFRDogJ21heC1iYW5kd2lkdGgtcmVhY2hlZCcsXG4gICAgTUFYX1RSQUNLU19TV0lUQ0hFRF9PTjogJ21heC10cmFja3Mtc3dpdGNoZWQtb24nLFxuICAgIE5FVFdPUktfQ09OR0VTVElPTjogJ25ldHdvcmstY29uZ2VzdGlvbidcbn07XG5tb2R1bGUuZXhwb3J0cy50cmFja1ByaW9yaXR5ID0ge1xuICAgIFBSSU9SSVRZX0hJR0g6ICdoaWdoJyxcbiAgICBQUklPUklUWV9MT1c6ICdsb3cnLFxuICAgIFBSSU9SSVRZX1NUQU5EQVJEOiAnc3RhbmRhcmQnXG59O1xubW9kdWxlLmV4cG9ydHMuY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sID0ge1xuICAgIE1PREVfQVVUTzogJ2F1dG8nLFxuICAgIE1PREVfTUFOVUFMOiAnbWFudWFsJ1xufTtcbm1vZHVsZS5leHBvcnRzLnZpZGVvQ29udGVudFByZWZlcmVuY2VzTW9kZSA9IHtcbiAgICBNT0RFX0FVVE86ICdhdXRvJyxcbiAgICBNT0RFX01BTlVBTDogJ21hbnVhbCdcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRldGVjdFNpbGVuY2UgPSByZXF1aXJlKCcuLi93ZWJhdWRpby9kZXRlY3RzaWxlbmNlJyk7XG52YXIgTl9BVFRFTVBUUyA9IDM7XG52YXIgQVRURU1QVF9EVVJBVElPTl9NUyA9IDI1MDtcbi8qKlxuICogRGV0ZWN0IHdoZXRoZXIgdGhlIGF1ZGlvIHN0cmVhbSByZW5kZXJlZCBieSB0aGUgZ2l2ZW4gSFRNTFZpZGVvRWxlbWVudCBpcyBzaWxlbnQuXG4gKiBAcGFyYW0ge0hUTUxBdWRpb0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gdHJ1ZSBpZiBzaWxlbnQsIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0U2lsZW50QXVkaW8oZWwpIHtcbiAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBXZSBoYXZlIHRvIGRlbGF5IHJlcXVpcmUtaW5nIEF1ZGlvQ29udGV4dEZhY3RvcnksIGJlY2F1c2VcbiAgICAvLyBpdCBleHBvcnRzIGEgZGVmYXVsdCBpbnN0YW5jZSB3aG9zZSBjb25zdHJ1Y3RvciBjYWxscyBPYmplY3QuYXNzaWduLlxuICAgIHZhciBBdWRpb0NvbnRleHRGYWN0b3J5ID0gcmVxdWlyZSgnLi4vd2ViYXVkaW8vYXVkaW9jb250ZXh0Jyk7XG4gICAgdmFyIGhvbGRlciA9IHt9O1xuICAgIHZhciBhdWRpb0NvbnRleHQgPSBBdWRpb0NvbnRleHRGYWN0b3J5LmdldE9yQ3JlYXRlKGhvbGRlcik7XG4gICAgdmFyIGF0dGVtcHRzTGVmdCA9IE5fQVRURU1QVFM7XG4gICAgZnVuY3Rpb24gZG9DaGVja1NpbGVuY2UoKSB7XG4gICAgICAgIGF0dGVtcHRzTGVmdC0tO1xuICAgICAgICByZXR1cm4gZGV0ZWN0U2lsZW5jZShhdWRpb0NvbnRleHQsIGVsLnNyY09iamVjdCwgQVRURU1QVF9EVVJBVElPTl9NUykudGhlbihmdW5jdGlvbiAoaXNTaWxlbnQpIHtcbiAgICAgICAgICAgIGlmICghaXNTaWxlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdHNMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb0NoZWNrU2lsZW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IElmIGFuIGVycm9yIGlzIHRocm93biB3aGlsZSBkZXRlY3Qgc2lsZW5jZSwgdGhlIGF1ZGlvXG4gICAgICAgICAgICAvLyBzdHJlYW0gaXMgYXNzdW1lZCB0byBiZSBzaWxlbnQuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFJlc29sdmUgdGhlIHJldHVybmVkIFByb21pc2Ugd2l0aCB0cnVlIGlmIDMgY29uc2VjdXRpdmUgYXR0ZW1wdHNcbiAgICAvLyB0byBkZXRlY3Qgc2lsZW50IGF1ZGlvIGFyZSBzdWNjZXNzZnVsLlxuICAgIHJldHVybiBkb0NoZWNrU2lsZW5jZSgpLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBBdWRpb0NvbnRleHRGYWN0b3J5LnJlbGVhc2UoaG9sZGVyKTtcbiAgICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZGV0ZWN0U2lsZW50QXVkaW87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3RzaWxlbnRhdWRpby5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG4vLyBDYWNoZWQgY29weSBvZiB0aGUgPGNhbnZhcz4gdXNlZCB0byBjaGVjayBzaWxlbnQgdmlkZW8gZnJhbWVzLlxudmFyIGNhbnZhcyA9IG51bGw7XG52YXIgTl9TQU1QTEVTID0gMztcbnZhciBTQU1QTEVfSEVJR0hUID0gNTA7XG52YXIgU0FNUExFX0lOVEVSVkFMX01TID0gMjUwO1xudmFyIFNBTVBMRV9XSURUSCA9IDUwO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50IHZpZGVvIGZyYW1lIGlzIHNpbGVudCBieSBzZWxlY3RpbmcgYSA1MHg1MFxuICogc2FtcGxlIGFuZCBjYWxjdWxhdGluZyB0aGUgbWF4IHZhbHVlIG9mIHRoZSBwaXhlbCBkYXRhLiBJZiBpdCBpcyAwLCB0aGVuXG4gKiB0aGUgZnJhbWUgaXMgY29uc2lkZXJlZCB0byBiZSBzaWxlbnQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSBlbFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgc2lsZW50LCBmYWxzZSBpZiBub3RcbiAqL1xuZnVuY3Rpb24gY2hlY2tTaWxlbmNlKGVsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoZWwsIDAsIDAsIFNBTVBMRV9XSURUSCwgU0FNUExFX0hFSUdIVCk7XG4gICAgICAgIHZhciBmcmFtZSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIFNBTVBMRV9XSURUSCwgU0FNUExFX0hFSUdIVCk7XG4gICAgICAgIHZhciBmcmFtZURhdGFXaXRob3V0QWxwaGEgPSBmcmFtZS5kYXRhLmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaSkgeyByZXR1cm4gKGkgKyAxKSAlIDQ7IH0pO1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZnJhbWVEYXRhV2l0aG91dEFscGhhKTtcbiAgICAgICAgcmV0dXJuIG1heCA9PT0gMDtcbiAgICB9XG4gICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBjaGVja2luZyBzaWxlbmNlOiAnLCBleCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIERldGVjdCB3aGV0aGVyIHRoZSB2aWRlbyBzdHJlYW0gcmVuZGVyZWQgYnkgdGhlIGdpdmVuIEhUTUxWaWRlb0VsZW1lbnQgaXMgc2lsZW50LlxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSBlbFxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHRydWUgaWYgc2lsZW50LCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdFNpbGVudFZpZGVvKGVsKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBjYW52YXMgd2hlbiBkZXRlY3RTaWxlbnRWaWRlbygpIGlzIGNhbGxlZCBmb3IgdGhlXG4gICAgLy8gZmlyc3QgdGltZS5cbiAgICBjYW52YXMgPSBjYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgLy8gUmVzb2x2ZSB0aGUgcmV0dXJuZWQgUHJvbWlzZSB3aXRoIHRydWUgaWYgMyBjb25zZWN1dGl2ZSBzYW1wbGVcbiAgICAvLyBmcmFtZXMgZnJvbSB0aGUgdmlkZW8gYmVpbmcgcGxheWVkIGJ5IHRoZSBIVE1MVmlkZW9FbGVtZW50IGFyZVxuICAgIC8vIHNpbGVudC5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIHNhbXBsZXNMZWZ0ID0gTl9TQU1QTEVTO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIGRvQ2hlY2tTaWxlbmNlKCkge1xuICAgICAgICAgICAgc2FtcGxlc0xlZnQtLTtcbiAgICAgICAgICAgIGlmICghY2hlY2tTaWxlbmNlKGVsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzYW1wbGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChkb0NoZWNrU2lsZW5jZSwgU0FNUExFX0lOVEVSVkFMX01TKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpO1xuICAgICAgICB9LCBTQU1QTEVfSU5URVJWQUxfTVMpO1xuICAgIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBkZXRlY3RTaWxlbnRWaWRlbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdHNpbGVudHZpZGVvLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogVGhlIHtAbGluayBEb2N1bWVudFZpc2liaWxpdHlNb25pdG9yfSBtb25pdG9ycyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgRE9NXG4gKiBhbmQgZXhlY3V0ZXMgdGhlIGF0dGFjaGVkIGxpc3RlbmVycyBpbiBwaGFzZSBvcmRlciB3aGVuIHRoZSBET00gaXMgdmlzaWJsZS5cbiAqL1xudmFyIERvY3VtZW50VmlzaWJpbGl0eU1vbml0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuUGhhc2VzPTFdIC0gdGhlIG51bWJlciBvZiBwaGFzZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEb2N1bWVudFZpc2liaWxpdHlNb25pdG9yKG5QaGFzZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG5QaGFzZXMgPT09IHZvaWQgMCkgeyBuUGhhc2VzID0gMTsgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBfbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uVmlzaWJpbGl0eUNoYW5nZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9lbWl0VmlzaWJsZShkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGhhc2VzOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKFtdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBjbGVhcnMgdGhlIHN0YXRlLlxuICAgICAqL1xuICAgIERvY3VtZW50VmlzaWJpbGl0eU1vbml0b3IucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgblBoYXNlcyA9IHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBoYXNlczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbaV0gPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvci5wcm90b3R5cGUuX2xpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMucmVkdWNlKGZ1bmN0aW9uIChjb3VudCwgcGhhc2VMaXN0ZW5lcnMpIHsgcmV0dXJuIGNvdW50ICsgcGhhc2VMaXN0ZW5lcnMubGVuZ3RoOyB9LCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGwgYWxsIHRoZSBsaXN0ZW5lcnMuIE1ha2VzIHN1cmUgdGhhdCBhbGwgbGlzdGVuZXJzIGZvciBhIGdpdmVuIHBoYXNlXG4gICAgICogYXJlIGV4ZWN1dGVkIGJlZm9yZSBjYWxsaW5nIHRoZSBsaXN0ZW5lcnMgb2YgdGhlIG5leHQgcGhhc2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEb2N1bWVudFZpc2liaWxpdHlNb25pdG9yLnByb3RvdHlwZS5fZW1pdFZpc2libGUgPSBmdW5jdGlvbiAoaXNWaXNpYmxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHBoYXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9lbWl0VmlzaWJsZVBoYXNlKHBoYXNlLCBpc1Zpc2libGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgcGhhc2UgPSAxOyBwaGFzZSA8PSB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoOyBwaGFzZSsrKSB7XG4gICAgICAgICAgICBfbG9vcF8xKHBoYXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGwgYWxsIHRoZSBsaXN0ZW5lcnMgZm9yIGEgZ2l2ZW4gcGhhc2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEb2N1bWVudFZpc2liaWxpdHlNb25pdG9yLnByb3RvdHlwZS5fZW1pdFZpc2libGVQaGFzZSA9IGZ1bmN0aW9uIChwaGFzZSwgaXNWaXNpYmxlKSB7XG4gICAgICAgIHZhciBwaGFzZUxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1twaGFzZSAtIDFdO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocGhhc2VMaXN0ZW5lcnMubWFwKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgdmFyIHJldCA9IGxpc3RlbmVyKGlzVmlzaWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0IGluc3RhbmNlb2YgUHJvbWlzZSA/IHJldCA6IFByb21pc2UucmVzb2x2ZShyZXQpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBsaXN0ZW5pbmcgdG8gdGhlIERPTSB2aXNpYmlsaXR5IHN0YXRlIGNoYW5nZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERvY3VtZW50VmlzaWJpbGl0eU1vbml0b3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9wIGxpc3RlbmluZyB0byB0aGUgRE9NIHZpc2liaWxpdHkgc3RhdGUgY2hhbmdlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGlzdGVuIGZvciB0aGUgRE9NIHZpc2liaWxpdHkgY2hhbmdlcyBhdCB0aGUgZ2l2ZW4gcGhhc2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBoYXNlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBEb2N1bWVudFZpc2liaWxpdHlNb25pdG9yLnByb3RvdHlwZS5vblZpc2liaWxpdHlDaGFuZ2UgPSBmdW5jdGlvbiAocGhhc2UsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGhhc2UgIT09ICdudW1iZXInIHx8IHBoYXNlIDw9IDAgfHwgcGhhc2UgPiB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGhhc2U6ICcsIHBoYXNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGhhc2VMaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbcGhhc2UgLSAxXTtcbiAgICAgICAgcGhhc2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lckNvdW50KCkgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9wIGxpc3RlbmluZyBmb3IgdGhlIERPTSB2aXNpYmlsaXR5IGNoYW5nZSBhdCB0aGUgZ2l2ZW4gcGhhc2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBoYXNlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBEb2N1bWVudFZpc2liaWxpdHlNb25pdG9yLnByb3RvdHlwZS5vZmZWaXNpYmlsaXR5Q2hhbmdlID0gZnVuY3Rpb24gKHBoYXNlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodHlwZW9mIHBoYXNlICE9PSAnbnVtYmVyJyB8fCBwaGFzZSA8PSAwIHx8IHBoYXNlID4gdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBoYXNlOiAnLCBwaGFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBoYXNlTGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3BoYXNlIC0gMV07XG4gICAgICAgIHZhciBpbmRleCA9IHBoYXNlTGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBwaGFzZUxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyQ291bnQoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBEb2N1bWVudFZpc2liaWxpdHlNb25pdG9yO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gbmV3IERvY3VtZW50VmlzaWJpbGl0eU1vbml0b3IoMik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb2N1bWVudHZpc2liaWxpdHltb25pdG9yLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFZBTElEX0dST1VQUyA9IFtcbiAgICAnc2lnbmFsaW5nJyxcbiAgICAncm9vbScsXG4gICAgJ21lZGlhJyxcbiAgICAncXVhbGl0eScsXG4gICAgJ3ZpZGVvLXByb2Nlc3NvcicsXG4gICAgJ3ByZWZsaWdodCdcbl07XG52YXIgVkFMSURfTEVWRUxTID0gW1xuICAgICdkZWJ1ZycsXG4gICAgJ2Vycm9yJyxcbiAgICAnaW5mbycsXG4gICAgJ3dhcm5pbmcnXG5dO1xuLyoqXG4gKiBFdmVudE9ic2VydmVyIGxpc3RlbnMgdG8gU0RLIGV2ZW50cyBhbmQgcmUtZW1pdHMgdGhlbSBvbiB0aGVcbiAqIEBsaW5rIEV2ZW50TGlzdGVuZXJ9IHdpdGggc29tZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAZW1pdHMgRXZlbnRPYnNlcnZlciNldmVudFxuICovXG52YXIgRXZlbnRPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXZlbnRPYnNlcnZlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0ge0luc2lnaHRzUHVibGlzaGVyfSBwdWJsaXNoZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29ubmVjdFRpbWVzdGFtcFxuICAgICAqIEBwYXJhbSB7TG9nfSBsb2dcbiAgICAgKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJ9IFtldmVudExpc3RlbmVyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV2ZW50T2JzZXJ2ZXIocHVibGlzaGVyLCBjb25uZWN0VGltZXN0YW1wLCBsb2csIGV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50TGlzdGVuZXIgPT09IHZvaWQgMCkgeyBldmVudExpc3RlbmVyID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vbignZXZlbnQnLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgZ3JvdXAgPSBfYS5ncm91cCwgbGV2ZWwgPSBfYS5sZXZlbCwgcGF5bG9hZCA9IF9hLnBheWxvYWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKCdVbmV4cGVjdGVkIG5hbWU6ICcsIG5hbWUpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBuYW1lOiAnLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghVkFMSURfR1JPVVBTLmluY2x1ZGVzKGdyb3VwKSkge1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcignVW5leHBlY3RlZCBncm91cDogJywgZ3JvdXApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBncm91cDogJywgZ3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFWQUxJRF9MRVZFTFMuaW5jbHVkZXMobGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKCdVbmV4cGVjdGVkIGxldmVsOiAnLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGxldmVsOiAnLCBsZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHZhciBlbGFwc2VkVGltZSA9IHRpbWVzdGFtcCAtIGNvbm5lY3RUaW1lc3RhbXA7XG4gICAgICAgICAgICB2YXIgcHVibGlzaGVyUGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oeyBlbGFwc2VkVGltZTogZWxhcHNlZFRpbWUsIGxldmVsOiBsZXZlbCB9LCBwYXlsb2FkID8gcGF5bG9hZCA6IHt9KTtcbiAgICAgICAgICAgIHB1Ymxpc2hlci5wdWJsaXNoKGdyb3VwLCBuYW1lLCBwdWJsaXNoZXJQYXlsb2FkKTtcbiAgICAgICAgICAgIHZhciBldmVudCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIGVsYXBzZWRUaW1lOiBlbGFwc2VkVGltZSxcbiAgICAgICAgICAgICAgICBncm91cDogZ3JvdXAsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgICAgICAgICAgIH0sIHBheWxvYWQgPyB7IHBheWxvYWQ6IHBheWxvYWQgfSA6IHt9KTtcbiAgICAgICAgICAgIHZhciBsb2dMZXZlbCA9IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZzogJ2RlYnVnJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBpbmZvOiAnaW5mbycsXG4gICAgICAgICAgICAgICAgd2FybmluZzogJ3dhcm4nLFxuICAgICAgICAgICAgfVtsZXZlbF07XG4gICAgICAgICAgICBsb2dbbG9nTGV2ZWxdKCdldmVudCcsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChldmVudExpc3RlbmVyICYmIGdyb3VwID09PSAnc2lnbmFsaW5nJykge1xuICAgICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXIuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBFdmVudE9ic2VydmVyO1xufShFdmVudEVtaXR0ZXIpKTtcbi8qKlxuICogQW4gU0RLIGV2ZW50LlxuICogQGV2ZW50IEV2ZW50T2JzZXJ2ZXIjZXZlbnRcbiAqIEBwYXJhbSB7e25hbWU6IHN0cmluZywgcGF5bG9hZDogKn19IGV2ZW50XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRPYnNlcnZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50b2JzZXJ2ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEZpbHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWx0ZXIob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBnZXRLZXk6IGZ1bmN0aW9uIGRlZmF1bHRHZXRLZXkoYSkgeyByZXR1cm4gYTsgfSxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0R2V0VmFsdWUoYSkgeyByZXR1cm4gYTsgfSxcbiAgICAgICAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG86IGZ1bmN0aW9uIGRlZmF1bHRJc0xlc3NUaGFuT3JFcXVhbFRvKGEsIGIpIHsgcmV0dXJuIGEgPD0gYjsgfVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgX2dldEtleToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmdldEtleVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRWYWx1ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmdldFZhbHVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzTGVzc1RoYW5PckVxdWFsVG86IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5pc0xlc3NUaGFuT3JFcXVhbFRvXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21hcDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIEZpbHRlci5wcm90b3R5cGUudG9NYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKHRoaXMuX21hcCk7XG4gICAgfTtcbiAgICBGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZUFuZEZpbHRlciA9IGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgIHJldHVybiBlbnRyaWVzLmZpbHRlcih0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgfTtcbiAgICBGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5fZ2V0S2V5KGVudHJ5KTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0VmFsdWUoZW50cnkpO1xuICAgICAgICBpZiAodGhpcy5fbWFwLmhhcyhrZXkpICYmXG4gICAgICAgICAgICB0aGlzLl9pc0xlc3NUaGFuT3JFcXVhbFRvKHZhbHVlLCB0aGlzLl9tYXAuZ2V0KGtleSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICByZXR1cm4gdG87XG59O1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG52YXIgRSA9IGNvbnN0YW50cy50eXBlRXJyb3JzLCB0cmFja1ByaW9yaXR5ID0gY29uc3RhbnRzLnRyYWNrUHJpb3JpdHk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3dlYnJ0Yy91dGlsJyk7XG52YXIgc2Vzc2lvblNJRCA9IHJlcXVpcmUoJy4vc2lkJykuc2Vzc2lvblNJRDtcbi8qKlxuICogUmV0dXJuIHRoZSBnaXZlbiB7QGxpbmsgTG9jYWxUcmFja30gb3IgYSBuZXcge0BsaW5rIExvY2FsVHJhY2t9IGZvciB0aGVcbiAqIGdpdmVuIE1lZGlhU3RyZWFtVHJhY2suXG4gKiBAcGFyYW0ge0xvY2FsVHJhY2t8TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7TG9jYWxUcmFja31cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqL1xuZnVuY3Rpb24gYXNMb2NhbFRyYWNrKHRyYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKHRyYWNrIGluc3RhbmNlb2Ygb3B0aW9ucy5Mb2NhbEF1ZGlvVHJhY2tcbiAgICAgICAgfHwgdHJhY2sgaW5zdGFuY2VvZiBvcHRpb25zLkxvY2FsVmlkZW9UcmFja1xuICAgICAgICB8fCB0cmFjayBpbnN0YW5jZW9mIG9wdGlvbnMuTG9jYWxEYXRhVHJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH1cbiAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBvcHRpb25zLk1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrLmtpbmQgPT09ICdhdWRpbydcbiAgICAgICAgICAgID8gbmV3IG9wdGlvbnMuTG9jYWxBdWRpb1RyYWNrKHRyYWNrLCBvcHRpb25zKVxuICAgICAgICAgICAgOiBuZXcgb3B0aW9ucy5Mb2NhbFZpZGVvVHJhY2sodHJhY2ssIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiBlc2xpbnQgbmV3LWNhcDowICovXG4gICAgdGhyb3cgRS5JTlZBTElEX1RZUEUoJ3RyYWNrJywgJ0xvY2FsQXVkaW9UcmFjaywgTG9jYWxWaWRlb1RyYWNrLCBMb2NhbERhdGFUcmFjaywgb3IgTWVkaWFTdHJlYW1UcmFjaycpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn0gZm9yIHRoZSBnaXZlbiB7QGxpbmsgTG9jYWxUcmFja30uXG4gKiBAcGFyYW0ge0xvY2FsVHJhY2t9IHRyYWNrXG4gKiBAcGFyYW0ge0xvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ30gc2lnbmFsaW5nXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRyYWNrOiBMb2NhbFRyYWNrUHVibGljYXRpb24pOiB2b2lkfSB1bnB1Ymxpc2hcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGFzTG9jYWxUcmFja1B1YmxpY2F0aW9uKHRyYWNrLCBzaWduYWxpbmcsIHVucHVibGlzaCwgb3B0aW9ucykge1xuICAgIHZhciBMb2NhbFRyYWNrUHVibGljYXRpb24gPSB7XG4gICAgICAgIGF1ZGlvOiBvcHRpb25zLkxvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9uLFxuICAgICAgICB2aWRlbzogb3B0aW9ucy5Mb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvbixcbiAgICAgICAgZGF0YTogb3B0aW9ucy5Mb2NhbERhdGFUcmFja1B1YmxpY2F0aW9uXG4gICAgfVt0cmFjay5raW5kXTtcbiAgICByZXR1cm4gbmV3IExvY2FsVHJhY2tQdWJsaWNhdGlvbihzaWduYWxpbmcsIHRyYWNrLCB1bnB1Ymxpc2gsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDYXBpdGFsaXplIGEgd29yZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB3b3JkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBjYXBpdGFsaXplZFxuICovXG5mdW5jdGlvbiBjYXBpdGFsaXplKHdvcmQpIHtcbiAgICByZXR1cm4gd29yZFswXS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKTtcbn1cbi8qKlxuICogTG9nIGRlcHJlY2F0aW9uIHdhcm5pbmdzIGZvciB0aGUgZ2l2ZW4gZXZlbnRzIG9mIGFuIEV2ZW50RW1pdHRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlclxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBzdHJpbmc+fSBldmVudHNcbiAqIEBwYXJhbSB7TG9nfSBsb2dcbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlRXZlbnRzKG5hbWUsIGVtaXR0ZXIsIGV2ZW50cywgbG9nKSB7XG4gICAgdmFyIHdhcm5pbmdzU2hvd24gPSBuZXcgU2V0KCk7XG4gICAgZW1pdHRlci5vbignbmV3TGlzdGVuZXInLCBmdW5jdGlvbiBuZXdMaXN0ZW5lcihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnRzLmhhcyhldmVudCkgJiYgIXdhcm5pbmdzU2hvd24uaGFzKGV2ZW50KSkge1xuICAgICAgICAgICAgbG9nLmRlcHJlY2F0ZWQobmFtZSArIFwiI1wiICsgZXZlbnQgKyBcIiBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCBzY2hlZHVsZWQgZm9yIHJlbW92YWwuXCIgKyAoZXZlbnRzLmdldChldmVudClcbiAgICAgICAgICAgICAgICA/IFwiIFVzZSBcIiArIG5hbWUgKyBcIiNcIiArIGV2ZW50cy5nZXQoZXZlbnQpICsgXCIgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICAgIDogJycpKTtcbiAgICAgICAgICAgIHdhcm5pbmdzU2hvd24uYWRkKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2FybmluZ3NTaG93bi5zaXplID49IGV2ZW50cy5zaXplKSB7XG4gICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCduZXdMaXN0ZW5lcicsIG5ld0xpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBGaW5kcyB0aGUgaXRlbXMgaW4gbGlzdDEgdGhhdCBhcmUgbm90IGluIGxpc3QyLlxuICogQHBhcmFtIHtBcnJheTwqPnxNYXA8Kj58U2V0PCo+fSBsaXN0MVxuICogQHBhcmFtIHtBcnJheTwqPnxNYXA8Kj58U2V0PCo+fSBsaXN0MlxuICogQHJldHVybnMge1NldH1cbiAqL1xuZnVuY3Rpb24gZGlmZmVyZW5jZShsaXN0MSwgbGlzdDIpIHtcbiAgICBsaXN0MSA9IEFycmF5LmlzQXJyYXkobGlzdDEpID8gbmV3IFNldChsaXN0MSkgOiBuZXcgU2V0KGxpc3QxLnZhbHVlcygpKTtcbiAgICBsaXN0MiA9IEFycmF5LmlzQXJyYXkobGlzdDIpID8gbmV3IFNldChsaXN0MikgOiBuZXcgU2V0KGxpc3QyLnZhbHVlcygpKTtcbiAgICB2YXIgZGlmZmVyZW5jZSA9IG5ldyBTZXQoKTtcbiAgICBsaXN0MS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghbGlzdDIuaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgICBkaWZmZXJlbmNlLmFkZChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkaWZmZXJlbmNlO1xufVxuLyoqXG4gKiBGaWx0ZXIgb3V0IHRoZSBrZXlzIGluIGFuIG9iamVjdCB3aXRoIGEgZ2l2ZW4gdmFsdWUuXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IC0gT2JqZWN0IHRvIGJlIGZpbHRlcmVkXG4gKiBAcGFyYW0geyp9IFtmaWx0ZXJWYWx1ZV0gLSBWYWx1ZSB0byBiZSBmaWx0ZXJlZCBvdXQ7IElmIG5vdCBzcGVjaWZpZWQsIHRoZW5cbiAqICAgZmlsdGVycyBvdXQgYWxsIGtleXMgd2hpY2ggaGF2ZSBhbiBleHBsaWNpdCB2YWx1ZSBvZiBcInVuZGVmaW5lZFwiXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIEZpbHRlcmVkIG9iamVjdFxuICovXG5mdW5jdGlvbiBmaWx0ZXJPYmplY3Qob2JqZWN0LCBmaWx0ZXJWYWx1ZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLnJlZHVjZShmdW5jdGlvbiAoZmlsdGVyZWQsIGtleSkge1xuICAgICAgICBpZiAob2JqZWN0W2tleV0gIT09IGZpbHRlclZhbHVlKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogTWFwIGEgbGlzdCB0byBhbiBhcnJheSBvZiBhcnJheXMsIGFuZCByZXR1cm4gdGhlIGZsYXR0ZW5lZCByZXN1bHQuXG4gKiBAcGFyYW0ge0FycmF5PCo+fFNldDwqPnxNYXA8Kj59IGxpc3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKik6IEFycmF5PCo+fSBbbWFwRm5dXG4gKiBAcmV0dXJucyBBcnJheTwqPlxuICovXG5mdW5jdGlvbiBmbGF0TWFwKGxpc3QsIG1hcEZuKSB7XG4gICAgdmFyIGxpc3RBcnJheSA9IGxpc3QgaW5zdGFuY2VvZiBNYXAgfHwgbGlzdCBpbnN0YW5jZW9mIFNldFxuICAgICAgICA/IEFycmF5LmZyb20obGlzdC52YWx1ZXMoKSlcbiAgICAgICAgOiBsaXN0O1xuICAgIG1hcEZuID0gbWFwRm4gfHwgZnVuY3Rpb24gbWFwRm4oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuICAgIHJldHVybiBsaXN0QXJyYXkucmVkdWNlKGZ1bmN0aW9uIChmbGF0dGVuZWQsIGl0ZW0pIHtcbiAgICAgICAgdmFyIG1hcHBlZCA9IG1hcEZuKGl0ZW0pO1xuICAgICAgICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChtYXBwZWQpO1xuICAgIH0sIFtdKTtcbn1cbi8qKlxuICogR2V0IHRoZSB1c2VyIGFnZW50IHN0cmluZywgb3IgcmV0dXJuIFwiVW5rbm93blwiLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50XG4gICAgICAgID8gbmF2aWdhdG9yLnVzZXJBZ2VudFxuICAgICAgICA6ICdVbmtub3duJztcbn1cbi8qKlxuICogR2V0IHRoZSBwbGF0Zm9ybSBjb21wb25lbnQgb2YgdGhlIHVzZXIgYWdlbnQgc3RyaW5nLlxuICogRXhhbXBsZTpcbiAqICAgSW5wdXQgLSBNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBJbnRlbCBNYWMgT1MgWCAxMF8xNF82KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvODkuMC40Mzg5LjgyIFNhZmFyaS81MzcuMzZcbiAqICAgT3V0cHV0IC0gbWFjaW50b3NoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRQbGF0Zm9ybSgpIHtcbiAgICB2YXIgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gICAgdmFyIF9hID0gX19yZWFkKHVzZXJBZ2VudC5tYXRjaCgvXFwoKFteKV0rKVxcKS8pIHx8IFtdLCAyKSwgX2IgPSBfYVsxXSwgbWF0Y2ggPSBfYiA9PT0gdm9pZCAwID8gJ3Vua25vd24nIDogX2I7XG4gICAgdmFyIF9jID0gX19yZWFkKG1hdGNoLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkudHJpbSgpOyB9KSwgMSksIHBsYXRmb3JtID0gX2NbMF07XG4gICAgcmV0dXJuIHBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbWFrZVVVSUQoKSB7XG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwO1xuICAgICAgICB2YXIgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgdGhlIGdpdmVuIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIHBlciB0aWNrLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBGdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuICogQHJldHVybnMge2Z1bmN0aW9ufSAtIFNjaGVkdWxlcyB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIHRoZSBuZXh0IHRpY2tcbiAqL1xuZnVuY3Rpb24gb25jZVBlclRpY2soZm4pIHtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgZnVuY3Rpb24gbmV4dFRpY2soKSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBmbigpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gc2NoZWR1bGVOZXh0VGljaygpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChuZXh0VGljayk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHByb21pc2VGcm9tRXZlbnRzKG9wZXJhdGlvbiwgZXZlbnRFbWl0dGVyLCBzdWNjZXNzRXZlbnQsIGZhaWx1cmVFdmVudCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIG9uU3VjY2VzcygpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKGZhaWx1cmVFdmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lcihmYWlsdXJlRXZlbnQsIG9uRmFpbHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBldmVudEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoc3VjY2Vzc0V2ZW50LCBvblN1Y2Nlc3MpO1xuICAgICAgICAgICAgcmVqZWN0LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRFbWl0dGVyLm9uY2Uoc3VjY2Vzc0V2ZW50LCBvblN1Y2Nlc3MpO1xuICAgICAgICBpZiAoZmFpbHVyZUV2ZW50KSB7XG4gICAgICAgICAgICBldmVudEVtaXR0ZXIub25jZShmYWlsdXJlRXZlbnQsIG9uRmFpbHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BlcmF0aW9uKCk7XG4gICAgfSk7XG59XG4vKipcbiAqIFRyYXZlcnNlIGRvd24gbXVsdGlwbGUgbm9kZXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm4gbnVsbCBpZlxuICogYW55IGxpbmsgaW4gdGhlIHBhdGggaXMgdW5hdmFpbGFibGUuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0IHRvIHRyYXZlcnNlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIFBhdGggdG8gdHJhdmVyc2UuIFBlcmlvZC1zZXBhcmF0ZWQuXG4gKiBAcmV0dXJucyB7QW55fG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldE9yTnVsbChvYmosIHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5zcGxpdCgnLicpLnJlZHVjZShmdW5jdGlvbiAob3V0cHV0LCBzdGVwKSB7XG4gICAgICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0W3N0ZXBdO1xuICAgIH0sIG9iaik7XG59XG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IERlZmVycmVkXG4gKiBAcHJvcGVydHkge1Byb21pc2V9IHByb21pc2VcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHJlamVjdFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcmVzb2x2ZVxuICovXG4vKipcbiAqIENyZWF0ZSBhIHtAbGluayBEZWZlcnJlZH0uXG4gKiBAcmV0dXJucyB7RGVmZXJyZWR9XG4gKi9cbmZ1bmN0aW9uIGRlZmVyKCkge1xuICAgIHZhciBkZWZlcnJlZCA9IHt9O1xuICAgIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xufVxuLyoqXG4gKiBDb3B5IGEgbWV0aG9kIGZyb20gYSBgc291cmNlYCBwcm90b3R5cGUgb250byBhIGB3cmFwcGVyYCBwcm90b3R5cGUuIEludm9raW5nXG4gKiB0aGUgbWV0aG9kIG9uIHRoZSBgd3JhcHBlcmAgcHJvdG90eXBlIHdpbGwgaW52b2tlIHRoZSBjb3JyZXNwb25kaW5nIG1ldGhvZFxuICogb24gYW4gaW5zdGFuY2UgYWNjZXNzZWQgYnkgYHRhcmdldGAuXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlXG4gKiBAcGFyYW0ge29iamVjdH0gd3JhcHBlclxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGRlbGVnYXRlTWV0aG9kKHNvdXJjZSwgd3JhcHBlciwgdGFyZ2V0LCBtZXRob2ROYW1lKSB7XG4gICAgaWYgKG1ldGhvZE5hbWUgaW4gd3JhcHBlcikge1xuICAgICAgICAvLyBTa2lwIGFueSBtZXRob2RzIGFscmVhZHkgc2V0LlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGhvZE5hbWUubWF0Y2goL15vblthLXpdKyQvKSkge1xuICAgICAgICAvLyBTa2lwIEV2ZW50SGFuZGxlcnMgKHRoZXNlIGFyZSBoYW5kbGVkIGluIHRoZSBjb25zdHJ1Y3RvcikuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHR5cGU7XG4gICAgdHJ5IHtcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBOT1RFKG1yb2JlcnRzKTogQXR0ZW1wdGluZyB0byBjaGVjayB0aGUgdHlwZSBvZiBub24tZnVuY3Rpb24gbWVtYmVyc1xuICAgICAgICAvLyBvbiB0aGUgcHJvdG90eXBlIHRocm93cyBhbiBlcnJvciBmb3Igc29tZSB0eXBlcy5cbiAgICB9XG4gICAgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gU2tpcCBub24tZnVuY3Rpb24gbWVtYmVycy5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBlc2xpbnQgbm8tbG9vcC1mdW5jOjAgKi9cbiAgICB3cmFwcGVyW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXNbdGFyZ2V0XSlbbWV0aG9kTmFtZV0uYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSkpO1xuICAgIH07XG59XG4vKipcbiAqIENvcHkgbWV0aG9kcyBmcm9tIGEgYHNvdXJjZWAgcHJvdG90eXBlIG9udG8gYSBgd3JhcHBlcmAgcHJvdG90eXBlLiBJbnZva2luZ1xuICogdGhlIG1ldGhvZHMgb24gdGhlIGB3cmFwcGVyYCBwcm90b3R5cGUgd2lsbCBpbnZva2UgdGhlIGNvcnJlc3BvbmRpbmcgbWV0aG9kXG4gKiBvbiBhbiBpbnN0YW5jZSBhY2Nlc3NlZCBieSBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSB3cmFwcGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBkZWxlZ2F0ZU1ldGhvZHMoc291cmNlLCB3cmFwcGVyLCB0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIHNvdXJjZSkge1xuICAgICAgICBkZWxlZ2F0ZU1ldGhvZChzb3VyY2UsIHdyYXBwZXIsIHRhcmdldCwgbWV0aG9kTmFtZSk7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0d28gdmFsdWVzIGFyZSBkZWVwbHkgZXF1YWwuXG4gKiBAcGFyYW0geyp9IHZhbDFcbiAqIEBwYXJhbSB7Kn0gdmFsMlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRGVlcEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgICBpZiAodmFsMSA9PT0gdmFsMikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWwxICE9PSB0eXBlb2YgdmFsMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWwxID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWwyID09PSBudWxsO1xuICAgIH1cbiAgICBpZiAodmFsMiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbDEpKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbDIpXG4gICAgICAgICAgICAmJiB2YWwxLmxlbmd0aCA9PT0gdmFsMi5sZW5ndGhcbiAgICAgICAgICAgICYmIHZhbDEuZXZlcnkoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gaXNEZWVwRXF1YWwodmFsLCB2YWwyW2ldKTsgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsMSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIHZhbDFLZXlzID0gT2JqZWN0LmtleXModmFsMSkuc29ydCgpO1xuICAgICAgICB2YXIgdmFsMktleXMgPSBPYmplY3Qua2V5cyh2YWwyKS5zb3J0KCk7XG4gICAgICAgIHJldHVybiAhQXJyYXkuaXNBcnJheSh2YWwyKVxuICAgICAgICAgICAgJiYgaXNEZWVwRXF1YWwodmFsMUtleXMsIHZhbDJLZXlzKVxuICAgICAgICAgICAgJiYgdmFsMUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gaXNEZWVwRXF1YWwodmFsMVtrZXldLCB2YWwyW2tleV0pOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBnaXZlbiBhcmd1bWVudCBpcyBhIG5vbi1hcnJheSBvYmplY3QuXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOb25BcnJheU9iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqZWN0KTtcbn1cbi8qKlxuICogRm9yIGVhY2ggcHJvcGVydHkgbmFtZSBvbiB0aGUgYHNvdXJjZWAgcHJvdG90eXBlLCBhZGQgZ2V0dGVycyBhbmQvb3Igc2V0dGVyc1xuICogdG8gYHdyYXBwZXJgIHRoYXQgcHJveHkgdG8gYHRhcmdldGAuXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlXG4gKiBAcGFyYW0ge29iamVjdH0gd3JhcHBlclxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gcHJveHlQcm9wZXJ0aWVzKHNvdXJjZSwgd3JhcHBlciwgdGFyZ2V0KSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgcHJveHlQcm9wZXJ0eShzb3VyY2UsIHdyYXBwZXIsIHRhcmdldCwgcHJvcGVydHlOYW1lKTtcbiAgICB9KTtcbn1cbi8qKlxuICogRm9yIHRoZSBwcm9wZXJ0eSBuYW1lIG9uIHRoZSBgc291cmNlYCBwcm90b3R5cGUsIGFkZCBhIGdldHRlciBhbmQvb3Igc2V0dGVyXG4gKiB0byBgd3JhcHBlcmAgdGhhdCBwcm94aWVzIHRvIGB0YXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZVxuICogQHBhcmFtIHtvYmplY3R9IHdyYXBwZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHByb3h5UHJvcGVydHkoc291cmNlLCB3cmFwcGVyLCB0YXJnZXQsIHByb3BlcnR5TmFtZSkge1xuICAgIGlmIChwcm9wZXJ0eU5hbWUgaW4gd3JhcHBlcikge1xuICAgICAgICAvLyBTa2lwIGFueSBwcm9wZXJ0aWVzIGFscmVhZHkgc2V0LlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3BlcnR5TmFtZS5tYXRjaCgvXm9uW2Etel0rJC8pKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cmFwcGVyLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHByb3BlcnR5TmFtZS5zbGljZSgyKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JhcHBlci5kaXNwYXRjaEV2ZW50LmFwcGx5KHdyYXBwZXIsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod3JhcHBlciwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFRoaXMgaXMgYSBmdW5jdGlvbiBmb3IgdHVybmluZyBhIFByb21pc2UgaW50byB0aGUga2luZCByZWZlcmVuY2VkIGluIHRoZVxuICogTGVnYWN5IEludGVyZmFjZSBFeHRlbnNpb25zIHNlY3Rpb24gb2YgdGhlIFdlYlJUQyBzcGVjLlxuICogQHBhcmFtIHtQcm9taXNlPCo+fSBwcm9taXNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uPCo+fSBvblN1Y2Nlc3NcbiAqIEBwYXJhbSB7ZnVuY3Rpb248RXJyb3I+fSBvbkZhaWx1cmVcbiAqIEByZXR1cm5zIHtQcm9taXNlPHVuZGVmaW5lZD59XG4gKi9cbmZ1bmN0aW9uIGxlZ2FjeVByb21pc2UocHJvbWlzZSwgb25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgICBpZiAob25TdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgb25TdWNjZXNzKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgb25GYWlsdXJlKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xufVxuLyoqXG4gKiBCdWlsZCB0aGUge0BsaW5rIExvZ0xldmVsc30gb2JqZWN0LlxuICogQHBhcmFtIHtTdHJpbmd8TG9nTGV2ZWx9IGxvZ0xldmVsIC0gTG9nIGxldmVsIG5hbWUgb3Igb2JqZWN0XG4gKiBAcmV0dXJucyB7TG9nTGV2ZWxzfVxuICovXG5mdW5jdGlvbiBidWlsZExvZ0xldmVscyhsb2dMZXZlbCkge1xuICAgIGlmICh0eXBlb2YgbG9nTGV2ZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBsb2dMZXZlbCxcbiAgICAgICAgICAgIG1lZGlhOiBsb2dMZXZlbCxcbiAgICAgICAgICAgIHNpZ25hbGluZzogbG9nTGV2ZWwsXG4gICAgICAgICAgICB3ZWJydGM6IGxvZ0xldmVsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBsb2dMZXZlbDtcbn1cbi8qKlxuICogR2V0IHRoZSB7QGxpbmsgVHJhY2t9J3MgZGVyaXZlZCBjbGFzcyBuYW1lXG4gKiBAcGFyYW0ge1RyYWNrfSB0cmFja1xuICogQHBhcmFtIHs/Ym9vbGVhbn0gW2xvY2FsPXVuZGVmaW5lZF1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRyYWNrQ2xhc3ModHJhY2ssIGxvY2FsKSB7XG4gICAgbG9jYWwgPSBsb2NhbCA/ICdMb2NhbCcgOiAnJztcbiAgICByZXR1cm4gbG9jYWwgKyAodHJhY2sua2luZCB8fCAnJykucmVwbGFjZSgvXFx3ezF9LywgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0udG9VcHBlckNhc2UoKTsgfSkgKyBcIlRyYWNrXCI7XG59XG4vKipcbiAqIEdldCB0aGUge0BsaW5rIFRyYWNrUHVibGljYXRpb259J3MgZGVyaXZlZCBjbGFzcyBuYW1lXG4gKiBAcGFyYW0ge1RyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uXG4gKiBAcGFyYW0gez9ib29sZWFufSBbbG9jYWw9dW5kZWZpbmVkXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdHJhY2tQdWJsaWNhdGlvbkNsYXNzKHB1YmxpY2F0aW9uLCBsb2NhbCkge1xuICAgIGxvY2FsID0gbG9jYWwgPyAnTG9jYWwnIDogJyc7XG4gICAgcmV0dXJuIGxvY2FsICsgKHB1YmxpY2F0aW9uLmtpbmQgfHwgJycpLnJlcGxhY2UoL1xcd3sxfS8sIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnRvVXBwZXJDYXNlKCk7IH0pICsgXCJUcmFja1B1YmxpY2F0aW9uXCI7XG59XG4vKipcbiAqIFNldHMgYWxsIHVuZGVyc2NvcmUtcHJlZml4ZWQgcHJvcGVydGllcyBvbiBgb2JqZWN0YCBub24tZW51bWVyYWJsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBoaWRlUHJpdmF0ZVByb3BlcnRpZXMob2JqZWN0KSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ18nKSkge1xuICAgICAgICAgICAgaGlkZVByb3BlcnR5KG9iamVjdCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzdWJjbGFzcyB3aGljaCwgaW4gdGhlIGNvbnN0cnVjdG9yLCBzZXRzIGFsbCB1bmRlcnNjb3JlLXByZWZpeGVkXG4gKiBwcm9wZXJ0aWVzIGFuZCB0aGUgZ2l2ZW4gcHVibGljIHByb3BlcnRpZXMgbm9uLWVudW1lcmFibGUuIFRoaXMgaXMgdXNlZnVsIGZvclxuICogcGF0Y2hpbmcgdXAgY2xhc3NlcyBsaWtlIEV2ZW50RW1pdHRlciB3aGljaCBtYXkgc2V0IHByb3BlcnRpZXMgbGlrZSBgX2V2ZW50c2BcbiAqIGFuZCBgZG9tYWluYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtsYXNzXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHByb3BzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHN1YmNsYXNzXG4gKi9cbmZ1bmN0aW9uIGhpZGVQcml2YXRlQW5kQ2VydGFpblB1YmxpY1Byb3BlcnRpZXNJbkNsYXNzKGtsYXNzLCBwcm9wcykge1xuICAgIC8vIE5PVEUobXJvYmVydHMpOiBXZSBkbyB0aGlzIHRvIGF2b2lkIGdpdmluZyB0aGUgY2xhc3MgYSBuYW1lLlxuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSkpIHx8IHRoaXM7XG4gICAgICAgICAgICBoaWRlUHJpdmF0ZVByb3BlcnRpZXMoX3RoaXMpO1xuICAgICAgICAgICAgaGlkZVB1YmxpY1Byb3BlcnRpZXMoX3RoaXMsIHByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICB9KGtsYXNzKSk7XG59XG4vKipcbiAqIEhpZGUgYSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBoaWRlUHJvcGVydHkob2JqZWN0LCBuYW1lKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgbmFtZSk7XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgZGVzY3JpcHRvcik7XG59XG4vKipcbiAqIEhpZGUgdGhlIGdpdmVuIHB1YmxpYyBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3Byb3BzPVtdXVxuICovXG5mdW5jdGlvbiBoaWRlUHVibGljUHJvcGVydGllcyhvYmplY3QsIHByb3BzKSB7XG4gICAgaWYgKHByb3BzID09PSB2b2lkIDApIHsgcHJvcHMgPSBbXTsgfVxuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICBoaWRlUHJvcGVydHkob2JqZWN0LCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5IG9mIHZhbHVlcyB0byBhbiBBcnJheSBvZiBKU09OIHZhbHVlcyBieSBjYWxsaW5nXG4gKiBgdmFsdWVUb0pTT05gIG9uIGVhY2ggdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnJheVxuICogQHJldHVybnMge0FycmF5PCo+fVxuICovXG5mdW5jdGlvbiBhcnJheVRvSlNPTihhcnJheSkge1xuICAgIHJldHVybiBhcnJheS5tYXAodmFsdWVUb0pTT04pO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgU2V0IG9mIHZhbHVlcyB0byBhbiBBcnJheSBvZiBKU09OIHZhbHVlcyBieSBjYWxsaW5nIGB2YWx1ZVRvSlNPTmBcbiAqIG9uIGVhY2ggdmFsdWUuXG4gKiBAcGFyYW0ge1NldDwqPn0gc2V0XG4gKiBAcmV0dXJucyB7QXJyYXk8Kj59XG4gKi9cbmZ1bmN0aW9uIHNldFRvSlNPTihzZXQpIHtcbiAgICByZXR1cm4gYXJyYXlUb0pTT04oX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHNldCkpKTtcbn1cbi8qKlxuICogQ29udmVydCBhIE1hcCBmcm9tIHN0cmluZ3MgdG8gdmFsdWVzIHRvIGFuIG9iamVjdCBvZiBKU09OIHZhbHVlcyBieSBjYWxsaW5nXG4gKiBgdmFsdWVUb0pTT05gIG9uIGVhY2ggdmFsdWUuXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsICo+fSBtYXBcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1hcFRvSlNPTihtYXApIHtcbiAgICByZXR1cm4gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKG1hcC5lbnRyaWVzKCkpKS5yZWR1Y2UoZnVuY3Rpb24gKGpzb24sIF9hKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIF9jID0gX19yZWFkKF9hLCAyKSwga2V5ID0gX2NbMF0sIHZhbHVlID0gX2NbMV07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKChfYiA9IHt9LCBfYltrZXldID0gdmFsdWVUb0pTT04odmFsdWUpLCBfYiksIGpzb24pO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgdG8gYSBKU09OIHZhbHVlIGJ5IGNhbGxpbmcgYHZhbHVlVG9KU09OYCBvbiBpdHMgZW51bWVyYWJsZVxuICoga2V5cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvSlNPTihvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqZWN0KS5yZWR1Y2UoZnVuY3Rpb24gKGpzb24sIF9hKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIF9jID0gX19yZWFkKF9hLCAyKSwga2V5ID0gX2NbMF0sIHZhbHVlID0gX2NbMV07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKChfYiA9IHt9LCBfYltrZXldID0gdmFsdWVUb0pTT04odmFsdWUpLCBfYiksIGpzb24pO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gYSBKU09OIHZhbHVlLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIHZhbHVlVG9KU09OKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhcnJheVRvSlNPTih2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiBzZXRUb0pTT04odmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICByZXR1cm4gbWFwVG9KU09OKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gb2JqZWN0VG9KU09OKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbUNvbm5lY3RFdmVudFBheWxvYWQoY29ubmVjdE9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBib29sVG9TdHJpbmcodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIH1cbiAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgc2Vzc2lvblNJRDogc2Vzc2lvblNJRCxcbiAgICAgICAgLy8gYXJyYXlzIHByb3BzIGNvbnZlcnRlZCB0byBsZW5ndGhzLlxuICAgICAgICBpY2VTZXJ2ZXJzOiAoY29ubmVjdE9wdGlvbnMuaWNlU2VydmVycyB8fCBbXSkubGVuZ3RoLFxuICAgICAgICBhdWRpb1RyYWNrczogKGNvbm5lY3RPcHRpb25zLnRyYWNrcyB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uICh0cmFjaykgeyByZXR1cm4gdHJhY2sua2luZCA9PT0gJ2F1ZGlvJzsgfSkubGVuZ3RoLFxuICAgICAgICB2aWRlb1RyYWNrczogKGNvbm5lY3RPcHRpb25zLnRyYWNrcyB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uICh0cmFjaykgeyByZXR1cm4gdHJhY2sua2luZCA9PT0gJ3ZpZGVvJzsgfSkubGVuZ3RoLFxuICAgICAgICBkYXRhVHJhY2tzOiAoY29ubmVjdE9wdGlvbnMudHJhY2tzIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7IHJldHVybiB0cmFjay5raW5kID09PSAnZGF0YSc7IH0pLmxlbmd0aCxcbiAgICB9O1xuICAgIC8vIGJvb2xlYW4gcHJvcGVydGllcy5cbiAgICBbWydhdWRpbyddLCBbJ2F1dG9tYXRpY1N1YnNjcmlwdGlvbiddLCBbJ2VuYWJsZURzY3AnXSwgWydldmVudExpc3RlbmVyJ10sIFsncHJlZmxpZ2h0J10sIFsndmlkZW8nXSwgWydkb21pbmFudFNwZWFrZXInLCAnZW5hYmxlRG9taW5hbnRTcGVha2VyJ11dLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHByb3AgPSBfYlswXSwgZXZlbnRQcm9wID0gX2JbMV07XG4gICAgICAgIGV2ZW50UHJvcCA9IGV2ZW50UHJvcCB8fCBwcm9wO1xuICAgICAgICBwYXlsb2FkW2V2ZW50UHJvcF0gPSBib29sVG9TdHJpbmcoISFjb25uZWN0T3B0aW9uc1twcm9wXSk7XG4gICAgfSk7XG4gICAgLy8gbnVtYmVycyBwcm9wZXJ0aWVzLlxuICAgIFtbJ21heFZpZGVvQml0cmF0ZSddLCBbJ21heEF1ZGlvQml0cmF0ZSddXS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBwcm9wID0gX2JbMF0sIGV2ZW50UHJvcCA9IF9iWzFdO1xuICAgICAgICBldmVudFByb3AgPSBldmVudFByb3AgfHwgcHJvcDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25uZWN0T3B0aW9uc1twcm9wXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHBheWxvYWRbZXZlbnRQcm9wXSA9IGNvbm5lY3RPcHRpb25zW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc05hTihOdW1iZXIoY29ubmVjdE9wdGlvbnNbcHJvcF0pKSkge1xuICAgICAgICAgICAgcGF5bG9hZFtldmVudFByb3BdID0gTnVtYmVyKGNvbm5lY3RPcHRpb25zW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHN0cmluZyBwcm9wZXJ0aWVzLlxuICAgIFtbJ2ljZVRyYW5zcG9ydFBvbGljeSddLCBbJ3JlZ2lvbiddLCBbJ25hbWUnLCAncm9vbU5hbWUnXV0uZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgcHJvcCA9IF9iWzBdLCBldmVudFByb3AgPSBfYlsxXTtcbiAgICAgICAgZXZlbnRQcm9wID0gZXZlbnRQcm9wIHx8IHByb3A7XG4gICAgICAgIGlmICh0eXBlb2YgY29ubmVjdE9wdGlvbnNbcHJvcF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXlsb2FkW2V2ZW50UHJvcF0gPSBjb25uZWN0T3B0aW9uc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29ubmVjdE9wdGlvbnNbcHJvcF0gPT09ICdudW1iZXInICYmIHByb3AgPT09ICduYW1lJykge1xuICAgICAgICAgICAgcGF5bG9hZFtldmVudFByb3BdID0gY29ubmVjdE9wdGlvbnNbcHJvcF0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGFycmF5IHByb3BzIHN0cmluZ2lmaWVkLlxuICAgIFsncHJlZmVycmVkQXVkaW9Db2RlY3MnLCAncHJlZmVycmVkVmlkZW9Db2RlY3MnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wIGluIGNvbm5lY3RPcHRpb25zKSB7XG4gICAgICAgICAgICBwYXlsb2FkW3Byb3BdID0gSlNPTi5zdHJpbmdpZnkoY29ubmVjdE9wdGlvbnNbcHJvcF0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCduZXR3b3JrUXVhbGl0eScgaW4gY29ubmVjdE9wdGlvbnMpIHtcbiAgICAgICAgcGF5bG9hZC5uZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGlzTm9uQXJyYXlPYmplY3QoY29ubmVjdE9wdGlvbnMubmV0d29ya1F1YWxpdHkpKSB7XG4gICAgICAgICAgICBbJ2xvY2FsJywgJ3JlbW90ZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3RPcHRpb25zLm5ldHdvcmtRdWFsaXR5W3Byb3BdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLm5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbltwcm9wXSA9IGNvbm5lY3RPcHRpb25zLm5ldHdvcmtRdWFsaXR5W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF5bG9hZC5uZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24ucmVtb3RlID0gMDtcbiAgICAgICAgICAgIHBheWxvYWQubmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uLmxvY2FsID0gY29ubmVjdE9wdGlvbnMubmV0d29ya1F1YWxpdHkgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29ubmVjdE9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZSAmJiBjb25uZWN0T3B0aW9ucy5iYW5kd2lkdGhQcm9maWxlLnZpZGVvKSB7XG4gICAgICAgIHZhciB2aWRlb0JQT3B0aW9uc18xID0gY29ubmVjdE9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlbyB8fCB7fTtcbiAgICAgICAgcGF5bG9hZC5iYW5kd2lkdGhQcm9maWxlT3B0aW9ucyA9IHt9O1xuICAgICAgICBbJ21vZGUnLCBbJ21heFN3aXRjaGVkT25UcmFja3MnLCAnbWF4VmlkZW9UcmFja3MnXSwgJ3RyYWNrU3dpdGNoT2ZmTW9kZScsICdkb21pbmFudFNwZWFrZXJQcmlvcml0eScsICdtYXhTdWJzY3JpcHRpb25CaXRyYXRlJywgJ3JlbmRlckRpbWVuc2lvbnMnLCAnY29udGVudFByZWZlcmVuY2VzTW9kZScsICdjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgZGVzdFByb3AgPSBBcnJheS5pc0FycmF5KHByb3ApID8gcHJvcFsxXSA6IHByb3A7XG4gICAgICAgICAgICB2YXIgc3JjUHJvcCA9IEFycmF5LmlzQXJyYXkocHJvcCkgPyBwcm9wWzBdIDogcHJvcDtcbiAgICAgICAgICAgIHZhciBzcmNQcm9wVmFsdWUgPSB2aWRlb0JQT3B0aW9uc18xW3NyY1Byb3BdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmNQcm9wVmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiBzcmNQcm9wVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5iYW5kd2lkdGhQcm9maWxlT3B0aW9uc1tkZXN0UHJvcF0gPSBzcmNQcm9wVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3JjUHJvcFZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmJhbmR3aWR0aFByb2ZpbGVPcHRpb25zW2Rlc3RQcm9wXSA9IGJvb2xUb1N0cmluZyhzcmNQcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZpZGVvQlBPcHRpb25zXzFbZGVzdFByb3BdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuYmFuZHdpZHRoUHJvZmlsZU9wdGlvbnNbZGVzdFByb3BdID0gSlNPTi5zdHJpbmdpZnkoc3JjUHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhdWRpb0JQT3B0aW9uc18xID0gY29ubmVjdE9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS5hdWRpbyB8fCB7fTtcbiAgICAgICAgW1snbWF4U3dpdGNoZWRPblRyYWNrcycsICdtYXhBdWRpb1RyYWNrcyddXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgZGVzdFByb3AgPSBBcnJheS5pc0FycmF5KHByb3ApID8gcHJvcFsxXSA6IHByb3A7XG4gICAgICAgICAgICB2YXIgc3JjUHJvcCA9IEFycmF5LmlzQXJyYXkocHJvcCkgPyBwcm9wWzBdIDogcHJvcDtcbiAgICAgICAgICAgIHZhciBzcmNQcm9wVmFsdWUgPSBhdWRpb0JQT3B0aW9uc18xW3NyY1Byb3BdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmNQcm9wVmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiBzcmNQcm9wVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5iYW5kd2lkdGhQcm9maWxlT3B0aW9uc1tkZXN0UHJvcF0gPSBzcmNQcm9wVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3JjUHJvcFZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmJhbmR3aWR0aFByb2ZpbGVPcHRpb25zW2Rlc3RQcm9wXSA9IGJvb2xUb1N0cmluZyhzcmNQcm9wVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZpZGVvQlBPcHRpb25zXzFbZGVzdFByb3BdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuYmFuZHdpZHRoUHJvZmlsZU9wdGlvbnNbZGVzdFByb3BdID0gSlNPTi5zdHJpbmdpZnkoc3JjUHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGdyb3VwOiAncm9vbScsXG4gICAgICAgIG5hbWU6ICdjb25uZWN0JyxcbiAgICAgICAgbGV2ZWw6ICdpbmZvJyxcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgYmFuZHdpZHRoIHByb2ZpbGUgcGF5bG9hZCBpbmNsdWRlZCBpbiBhbiBSU1AgY29ubmVjdCBtZXNzYWdlLlxuICogQHBhcmFtIHtCYW5kd2lkdGhQcm9maWxlfSBiYW5kd2lkdGhQcm9maWxlXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVCYW5kd2lkdGhQcm9maWxlUGF5bG9hZChiYW5kd2lkdGhQcm9maWxlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJTUFBheWxvYWQoYmFuZHdpZHRoUHJvZmlsZSwgW1xuICAgICAgICB7IHByb3A6ICd2aWRlbycsIHR5cGU6ICdvYmplY3QnLCB0cmFuc2Zvcm06IGNyZWF0ZUJhbmR3aWR0aFByb2ZpbGVWaWRlb1BheWxvYWQgfSxcbiAgICAgICAgeyBwcm9wOiAnYXVkaW8nLCB0eXBlOiAnb2JqZWN0JywgdHJhbnNmb3JtOiBjcmVhdGVCYW5kd2lkdGhQcm9maWxlQXVkaW9QYXlsb2FkIH1cbiAgICBdKTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBiYW5kd2lkdGggcHJvZmlsZSBhdWRpbyBwYXlsb2FkIGluY2x1ZGVkIGluIGFuIFJTUCBjb25uZWN0IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0F1ZGlvQmFuZHdpZHRoUHJvZmlsZX0gYmFuZHdpZHRoUHJvZmlsZUF1ZGlvXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVCYW5kd2lkdGhQcm9maWxlQXVkaW9QYXlsb2FkKGJhbmR3aWR0aFByb2ZpbGVBdWRpbykge1xuICAgIHJldHVybiBjcmVhdGVSU1BQYXlsb2FkKGJhbmR3aWR0aFByb2ZpbGVBdWRpbywgW1xuICAgICAgICB7IHByb3A6ICdtYXhTd2l0Y2hlZE9uVHJhY2tzJywgdHlwZTogJ251bWJlcicsIHBheWxvYWRQcm9wOiAnbWF4X3RyYWNrcycgfVxuICAgIF0pO1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIGJhbmR3aWR0aCBwcm9maWxlIHZpZGVvIHBheWxvYWQgaW5jbHVkZWQgaW4gYW4gUlNQIGNvbm5lY3QgbWVzc2FnZS5cbiAqIEBwYXJhbSB7VmlkZW9CYW5kd2lkdGhQcm9maWxlfSBiYW5kd2lkdGhQcm9maWxlVmlkZW9cbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhbmR3aWR0aFByb2ZpbGVWaWRlb1BheWxvYWQoYmFuZHdpZHRoUHJvZmlsZVZpZGVvKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJTUFBheWxvYWQoYmFuZHdpZHRoUHJvZmlsZVZpZGVvLCBbXG4gICAgICAgIHsgcHJvcDogJ2RvbWluYW50U3BlYWtlclByaW9yaXR5JywgdHlwZTogJ3N0cmluZycsIHBheWxvYWRQcm9wOiAnYWN0aXZlX3NwZWFrZXJfcHJpb3JpdHknIH0sXG4gICAgICAgIHsgcHJvcDogJ21heFN1YnNjcmlwdGlvbkJpdHJhdGUnLCB0eXBlOiAnbnVtYmVyJywgcGF5bG9hZFByb3A6ICdtYXhfc3Vic2NyaXB0aW9uX2JhbmR3aWR0aCcgfSxcbiAgICAgICAgeyBwcm9wOiAnbWF4U3dpdGNoZWRPblRyYWNrcycsIHR5cGU6ICdudW1iZXInLCBwYXlsb2FkUHJvcDogJ21heF90cmFja3MnIH0sXG4gICAgICAgIHsgcHJvcDogJ21vZGUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IHByb3A6ICdyZW5kZXJEaW1lbnNpb25zJywgdHlwZTogJ29iamVjdCcsIHBheWxvYWRQcm9wOiAncmVuZGVyX2RpbWVuc2lvbnMnLCB0cmFuc2Zvcm06IGNyZWF0ZVJlbmRlckRpbWVuc2lvbnNQYXlsb2FkIH0sXG4gICAgICAgIHsgcHJvcDogJ3RyYWNrU3dpdGNoT2ZmTW9kZScsIHR5cGU6ICdzdHJpbmcnLCBwYXlsb2FkUHJvcDogJ3RyYWNrX3N3aXRjaF9vZmYnIH1cbiAgICBdKTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBNZWRpYSBTaWduYWxpbmcgcGF5bG9hZCBpbmNsdWRlZCBpbiBhbiBSU1AgY29ubmVjdCBtZXNzYWdlLlxuICogQHBhcmFtIHtib29sZWFufSBkb21pbmFudFNwZWFrZXIgLSB3aGV0aGVyIHRvIGVuYWJsZSB0aGUgRG9taW5hbnQgU3BlYWtlclxuICogICBwcm90b2NvbCBvciBub3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbmV0d29ya1F1YWxpdHkgLSB3aGV0aGVyIHRvIGVuYWJsZSB0aGUgTmV0d29yayBRdWFsaXR5XG4gKiAgIHByb3RvY29sIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSB0cmFja1ByaW9yaXR5IC0gd2hldGhlciB0byBlbmFibGUgdGhlIFRyYWNrIFByaW9yaXR5XG4gKiAgIHByb3RvY29sIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSB0cmFja1N3aXRjaE9mZiAtIHdoZXRoZXIgdG8gZW5hYmxlIHRoZSBUcmFjayBTd2l0Y2gtT2ZmXG4gKiAgIHByb3RvY29sIG9yIG5vdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVySGludHMgLSB3aGV0aGVyIHRvIGVuYWJsZSB0aGUgcmVuZGVySGludHNcbiAqICAgcHJvdG9jb2wgb3Igbm90LlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVkaWFTaWduYWxpbmdQYXlsb2FkKGRvbWluYW50U3BlYWtlciwgbmV0d29ya1F1YWxpdHksIHRyYWNrUHJpb3JpdHksIHRyYWNrU3dpdGNoT2ZmLCBhZGFwdGl2ZVNpbXVsY2FzdCwgcmVuZGVySGludHMpIHtcbiAgICB2YXIgdHJhbnNwb3J0cyA9IHsgdHJhbnNwb3J0czogW3sgdHlwZTogJ2RhdGEtY2hhbm5lbCcgfV0gfTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkb21pbmFudFNwZWFrZXJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgID8geyBhY3RpdmVfc3BlYWtlcjogdHJhbnNwb3J0cyB9XG4gICAgICAgIDoge30sIG5ldHdvcmtRdWFsaXR5XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICA/IHsgbmV0d29ya19xdWFsaXR5OiB0cmFuc3BvcnRzIH1cbiAgICAgICAgOiB7fSwgcmVuZGVySGludHNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgID8geyByZW5kZXJfaGludHM6IHRyYW5zcG9ydHMgfVxuICAgICAgICA6IHt9LCBhZGFwdGl2ZVNpbXVsY2FzdFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgPyB7IHB1Ymxpc2hlcl9oaW50czogdHJhbnNwb3J0cyB9XG4gICAgICAgIDoge30sIHRyYWNrUHJpb3JpdHlcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgID8geyB0cmFja19wcmlvcml0eTogdHJhbnNwb3J0cyB9XG4gICAgICAgIDoge30sIHRyYWNrU3dpdGNoT2ZmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICA/IHsgdHJhY2tfc3dpdGNoX29mZjogdHJhbnNwb3J0cyB9XG4gICAgICAgIDoge30sIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHsgdHJhY2tfc3Vic2NyaXB0aW9uczogdHJhbnNwb3J0cyB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIHtAbGluayBWaWRlb1RyYWNrLkRpbWVuc2lvbnN9IFJTUCBwYXlsb2FkLlxuICogQHBhcmFtIHtWaWRlb1RyYWNrLkRpbWVuc2lvbnN9IFtkaW1lbnNpb25zXVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGltZW5zaW9uc1BheWxvYWQoZGltZW5zaW9ucykge1xuICAgIHJldHVybiBjcmVhdGVSU1BQYXlsb2FkKGRpbWVuc2lvbnMsIFtcbiAgICAgICAgeyBwcm9wOiAnaGVpZ2h0JywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBwcm9wOiAnd2lkdGgnLCB0eXBlOiAnbnVtYmVyJyB9XG4gICAgXSk7XG59XG4vKipcbiAqIENyZWF0ZSB7QGxpbmsgVmlkZW9SZW5kZXJEaW1lbnNpb25zfSBSU1AgcGF5bG9hZC5cbiAqIEBwYXJhbSByZW5kZXJEaW1lbnNpb25zXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJEaW1lbnNpb25zUGF5bG9hZChyZW5kZXJEaW1lbnNpb25zKSB7XG4gICAgdmFyIFBSSU9SSVRZX0hJR0ggPSB0cmFja1ByaW9yaXR5LlBSSU9SSVRZX0hJR0gsIFBSSU9SSVRZX0xPVyA9IHRyYWNrUHJpb3JpdHkuUFJJT1JJVFlfTE9XLCBQUklPUklUWV9TVEFOREFSRCA9IHRyYWNrUHJpb3JpdHkuUFJJT1JJVFlfU1RBTkRBUkQ7XG4gICAgcmV0dXJuIGNyZWF0ZVJTUFBheWxvYWQocmVuZGVyRGltZW5zaW9ucywgW1xuICAgICAgICB7IHByb3A6IFBSSU9SSVRZX0hJR0gsIHR5cGU6ICdvYmplY3QnLCB0cmFuc2Zvcm06IGNyZWF0ZURpbWVuc2lvbnNQYXlsb2FkIH0sXG4gICAgICAgIHsgcHJvcDogUFJJT1JJVFlfTE9XLCB0eXBlOiAnb2JqZWN0JywgdHJhbnNmb3JtOiBjcmVhdGVEaW1lbnNpb25zUGF5bG9hZCB9LFxuICAgICAgICB7IHByb3A6IFBSSU9SSVRZX1NUQU5EQVJELCB0eXBlOiAnb2JqZWN0JywgdHJhbnNmb3JtOiBjcmVhdGVEaW1lbnNpb25zUGF5bG9hZCB9XG4gICAgXSk7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBSU1AgcGF5bG9hZCBmb3IgdGhlIGdpdmVuIG9iamVjdC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgLSBvYmplY3QgZm9yIHdoaWNoIFJTUCBwYXlsb2FkIGlzIHRvIGJlIGdlbmVyYXRlZFxuICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBwcm9wQ29udmVyc2lvbnMgLSBjb252ZXJzaW9uIHJ1bGVzIGZvciBvYmplY3QgcHJvcGVydGllcztcbiAqICAgdGhleSBzcGVjaWZ5IGhvdyBvYmplY3QgcHJvcGVydGllcyBzaG91bGQgYmUgY29udmVydGVkIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqICAgUlNQIHBheWxvYWQgcHJvcGVydGllc1xuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUlNQUGF5bG9hZChvYmplY3QsIHByb3BDb252ZXJzaW9ucykge1xuICAgIHJldHVybiBwcm9wQ29udmVyc2lvbnMucmVkdWNlKGZ1bmN0aW9uIChwYXlsb2FkLCBfYSkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciBwcm9wID0gX2EucHJvcCwgdHlwZSA9IF9hLnR5cGUsIF9jID0gX2EucGF5bG9hZFByb3AsIHBheWxvYWRQcm9wID0gX2MgPT09IHZvaWQgMCA/IHByb3AgOiBfYywgX2QgPSBfYS50cmFuc2Zvcm0sIHRyYW5zZm9ybSA9IF9kID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9kO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iamVjdFtwcm9wXSA9PT0gdHlwZVxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKChfYiA9IHt9LCBfYltwYXlsb2FkUHJvcF0gPSB0cmFuc2Zvcm0ob2JqZWN0W3Byb3BdKSwgX2IpLCBwYXlsb2FkKVxuICAgICAgICAgICAgOiBwYXlsb2FkO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBzdWJzY3JpYmUgcGF5bG9hZCBpbmNsdWRlZCBpbiBhbiBSU1AgY29ubmVjdC91cGRhdGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b21hdGljU3Vic2NyaXB0aW9uIC0gd2hldGhlciB0byBzdWJzY3JpYmUgdG8gYWxsIFJlbW90ZVRyYWNrc1xuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3Vic2NyaWJlUGF5bG9hZChhdXRvbWF0aWNTdWJzY3JpcHRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBydWxlczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBhdXRvbWF0aWNTdWJzY3JpcHRpb24gPyAnaW5jbHVkZScgOiAnZXhjbHVkZScsXG4gICAgICAgICAgICAgICAgYWxsOiB0cnVlXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgcmV2aXNpb246IDFcbiAgICB9O1xufVxuLyoqXG4gKiBBZGQgcmFuZG9tIGppdHRlciB0byBhIGdpdmVuIHZhbHVlIGluIHRoZSByYW5nZSBbLWppdHRlciwgaml0dGVyXS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBqaXR0ZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlICsgcmFuZG9tKC1qaXR0ZXIsICtqaXR0ZXIpXG4gKi9cbmZ1bmN0aW9uIHdpdGhKaXR0ZXIodmFsdWUsIGppdHRlcikge1xuICAgIHZhciByYW5kID0gTWF0aC5yYW5kb20oKTtcbiAgICByZXR1cm4gdmFsdWUgLSBqaXR0ZXIgKyBNYXRoLmZsb29yKDIgKiBqaXR0ZXIgKiByYW5kICsgMC41KTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhIG51bWJlciBpcyBpbiB0aGUgcmFuZ2UgW21pbiwgbWF4XS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bX0gbnVtXG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpblJhbmdlKG51bSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gbWluIDw9IG51bSAmJiBudW0gPD0gbWF4O1xufVxuLyoqXG4gKiByZXR1cm5zIHRydWUgaWYgZ2l2ZW4gTWVkaWFTdHJlYW1UcmFjayBpcyBhIHNjcmVlbiBzaGFyZSB0cmFja1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Nocm9tZVNjcmVlblNoYXJlVHJhY2sodHJhY2spIHtcbiAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogQ2hyb21lIGNyZWF0ZXMgc2NyZWVuIHNoYXJlIHRyYWNrcyB3aXRoIGxhYmVsIGxpa2U6IFwic2NyZWVuOjY5NzM0MjcyKlwiXG4gICAgLy8gd2Ugd2lsbCBjaGVjayBmb3IgbGFiZWwgdGhhdCBzdGFydHMgd2l0aCBcInNjcmVlbjpEXCIgd2hlcmUgRCBiZWluZyBhIGRpZ2l0LlxuICAgIHJldHVybiB1dGlsLmd1ZXNzQnJvd3NlcigpID09PSAnY2hyb21lJyAmJiB0cmFjay5raW5kID09PSAndmlkZW8nICYmICdkaXNwbGF5U3VyZmFjZScgaW4gdHJhY2suZ2V0U2V0dGluZ3MoKTtcbn1cbi8qKlxuICogcmV0dXJucyB0cnVlIGlmIGdpdmVuIE1lZGlhU3RyZWFtVHJhY2sgaXMgYSB1c2VyIG1lZGlhIHRyYWNrXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVXNlck1lZGlhVHJhY2sodHJhY2spIHtcbiAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogdHJhY2tzIG9idGFpbmVkIGZyb20gZ2V0VXNlck1lZGlhIGhhdmUgYSBkZXZpY2VJZCBpbiBpdHMgc2V0dGluZ3MuXG4gICAgcmV0dXJuIHR5cGVvZiB0cmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkID09PSAnc3RyaW5nJztcbn1cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlIGFmdGVyIHRpbWVvdXRNUyBoYXZlIHBhc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TVMgLSB0aW1lIHRvIHdhaXQgaW4gbWlsbGlzZWNvbmRzLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmZ1bmN0aW9uIHdhaXRGb3JTb21ldGltZSh0aW1lb3V0TVMpIHtcbiAgICBpZiAodGltZW91dE1TID09PSB2b2lkIDApIHsgdGltZW91dE1TID0gMTA7IH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dE1TKTsgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZSBhZnRlciBldmVudCBpcyByZWNlaXZlZFxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmZ1bmN0aW9uIHdhaXRGb3JFdmVudChldmVudFRhcmdldCwgZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuY3Rpb24gb25ldmVudChlKSB7XG4gICAgICAgICAgICBldmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbmV2ZW50KTtcbiAgICAgICAgICAgIHJlc29sdmUoZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZS1lbWl0IHtAbGluayBUcmFja1B1YmxpY2F0aW9ufSBldmVudHMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQYXJ0aWNpcGFudH0gcGFydGljaXBhbnRcbiAqIEBwYXJhbSB7VHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb25cbiAqL1xuZnVuY3Rpb24gcmVlbWl0VHJhY2tQdWJsaWNhdGlvbkV2ZW50cyhwYXJ0aWNpcGFudCwgcHVibGljYXRpb24pIHtcbiAgICB2YXIgcHVibGljYXRpb25FdmVudFJlZW1pdHRlcnMgPSBuZXcgTWFwKCk7XG4gICAgaWYgKHBhcnRpY2lwYW50LnN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhcnRpY2lwYW50Ll9nZXRUcmFja1B1YmxpY2F0aW9uRXZlbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgcHVibGljYXRpb25FdmVudCA9IF9iWzBdLCBwYXJ0aWNpcGFudEV2ZW50ID0gX2JbMV07XG4gICAgICAgIHB1YmxpY2F0aW9uRXZlbnRSZWVtaXR0ZXJzLnNldChwdWJsaWNhdGlvbkV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHVibGljYXRpb25FdmVudCA9PT0gJ3RyYWNrU3dpdGNoZWRPZmYnKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKGFyZ3MsIDIpLCB0cmFjayA9IF9hWzBdLCBzd2l0Y2hPZmZSZWFzb24gPSBfYVsxXTtcbiAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudC5lbWl0KHBhcnRpY2lwYW50RXZlbnQsIHRyYWNrLCBwdWJsaWNhdGlvbiwgc3dpdGNoT2ZmUmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50LmVtaXQuYXBwbHkocGFydGljaXBhbnQsIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbcGFydGljaXBhbnRFdmVudF0sIF9fcmVhZChhcmdzKSksIFtwdWJsaWNhdGlvbl0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHB1YmxpY2F0aW9uLm9uKHB1YmxpY2F0aW9uRXZlbnQsIHB1YmxpY2F0aW9uRXZlbnRSZWVtaXR0ZXJzLmdldChwdWJsaWNhdGlvbkV2ZW50KSk7XG4gICAgfSk7XG4gICAgcGFydGljaXBhbnQuX3RyYWNrUHVibGljYXRpb25FdmVudFJlZW1pdHRlcnMuc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbkV2ZW50UmVlbWl0dGVycyk7XG59XG5leHBvcnRzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbmV4cG9ydHMuY3JlYXRlQmFuZHdpZHRoUHJvZmlsZVBheWxvYWQgPSBjcmVhdGVCYW5kd2lkdGhQcm9maWxlUGF5bG9hZDtcbmV4cG9ydHMuY3JlYXRlTWVkaWFTaWduYWxpbmdQYXlsb2FkID0gY3JlYXRlTWVkaWFTaWduYWxpbmdQYXlsb2FkO1xuZXhwb3J0cy5jcmVhdGVSb29tQ29ubmVjdEV2ZW50UGF5bG9hZCA9IGNyZWF0ZVJvb21Db25uZWN0RXZlbnRQYXlsb2FkO1xuZXhwb3J0cy5jcmVhdGVTdWJzY3JpYmVQYXlsb2FkID0gY3JlYXRlU3Vic2NyaWJlUGF5bG9hZDtcbmV4cG9ydHMuYXNMb2NhbFRyYWNrID0gYXNMb2NhbFRyYWNrO1xuZXhwb3J0cy5hc0xvY2FsVHJhY2tQdWJsaWNhdGlvbiA9IGFzTG9jYWxUcmFja1B1YmxpY2F0aW9uO1xuZXhwb3J0cy5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbmV4cG9ydHMuZGVwcmVjYXRlRXZlbnRzID0gZGVwcmVjYXRlRXZlbnRzO1xuZXhwb3J0cy5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbmV4cG9ydHMuZmlsdGVyT2JqZWN0ID0gZmlsdGVyT2JqZWN0O1xuZXhwb3J0cy5mbGF0TWFwID0gZmxhdE1hcDtcbmV4cG9ydHMuZ2V0UGxhdGZvcm0gPSBnZXRQbGF0Zm9ybTtcbmV4cG9ydHMuZ2V0VXNlckFnZW50ID0gZ2V0VXNlckFnZW50O1xuZXhwb3J0cy5oaWRlUHJpdmF0ZVByb3BlcnRpZXMgPSBoaWRlUHJpdmF0ZVByb3BlcnRpZXM7XG5leHBvcnRzLmhpZGVQcml2YXRlQW5kQ2VydGFpblB1YmxpY1Byb3BlcnRpZXNJbkNsYXNzID0gaGlkZVByaXZhdGVBbmRDZXJ0YWluUHVibGljUHJvcGVydGllc0luQ2xhc3M7XG5leHBvcnRzLmlzRGVlcEVxdWFsID0gaXNEZWVwRXF1YWw7XG5leHBvcnRzLmlzTm9uQXJyYXlPYmplY3QgPSBpc05vbkFycmF5T2JqZWN0O1xuZXhwb3J0cy5pblJhbmdlID0gaW5SYW5nZTtcbmV4cG9ydHMubWFrZVVVSUQgPSBtYWtlVVVJRDtcbmV4cG9ydHMub25jZVBlclRpY2sgPSBvbmNlUGVyVGljaztcbmV4cG9ydHMucHJvbWlzZUZyb21FdmVudHMgPSBwcm9taXNlRnJvbUV2ZW50cztcbmV4cG9ydHMuZ2V0T3JOdWxsID0gZ2V0T3JOdWxsO1xuZXhwb3J0cy5kZWZlciA9IGRlZmVyO1xuZXhwb3J0cy5kZWxlZ2F0ZU1ldGhvZHMgPSBkZWxlZ2F0ZU1ldGhvZHM7XG5leHBvcnRzLnByb3h5UHJvcGVydGllcyA9IHByb3h5UHJvcGVydGllcztcbmV4cG9ydHMubGVnYWN5UHJvbWlzZSA9IGxlZ2FjeVByb21pc2U7XG5leHBvcnRzLmJ1aWxkTG9nTGV2ZWxzID0gYnVpbGRMb2dMZXZlbHM7XG5leHBvcnRzLnRyYWNrQ2xhc3MgPSB0cmFja0NsYXNzO1xuZXhwb3J0cy50cmFja1B1YmxpY2F0aW9uQ2xhc3MgPSB0cmFja1B1YmxpY2F0aW9uQ2xhc3M7XG5leHBvcnRzLnZhbHVlVG9KU09OID0gdmFsdWVUb0pTT047XG5leHBvcnRzLndpdGhKaXR0ZXIgPSB3aXRoSml0dGVyO1xuZXhwb3J0cy5pc0Nocm9tZVNjcmVlblNoYXJlVHJhY2sgPSBpc0Nocm9tZVNjcmVlblNoYXJlVHJhY2s7XG5leHBvcnRzLmlzVXNlck1lZGlhVHJhY2sgPSBpc1VzZXJNZWRpYVRyYWNrO1xuZXhwb3J0cy53YWl0Rm9yU29tZXRpbWUgPSB3YWl0Rm9yU29tZXRpbWU7XG5leHBvcnRzLndhaXRGb3JFdmVudCA9IHdhaXRGb3JFdmVudDtcbmV4cG9ydHMucmVlbWl0VHJhY2tQdWJsaWNhdGlvbkV2ZW50cyA9IHJlZW1pdFRyYWNrUHVibGljYXRpb25FdmVudHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBnZXRVc2VyQWdlbnQgPSByZXF1aXJlKCcuLicpLmdldFVzZXJBZ2VudDtcbnZhciBNQVhfUkVDT05ORUNUX0FUVEVNUFRTID0gNTtcbnZhciBSRUNPTk5FQ1RfSU5URVJWQUxfTVMgPSA1MDtcbnZhciBXU19DTE9TRV9OT1JNQUwgPSAxMDAwO1xudmFyIHRvcGxldmVsID0gZ2xvYmFsLndpbmRvdyB8fCBnbG9iYWw7XG52YXIgV2ViU29ja2V0ID0gdG9wbGV2ZWwuV2ViU29ja2V0ID8gdG9wbGV2ZWwuV2ViU29ja2V0IDogcmVxdWlyZSgnd3MnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuLyoqXG4gKiBQdWJsaXNoIGV2ZW50cyB0byB0aGUgSW5zaWdodHMgZ2F0ZXdheS5cbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQGVtaXRzIEluc2lnaHRzUHVibGlzaGVyI2Nvbm5lY3RlZFxuICogQGVtaXRzIEluc2lnaHRzUHVibGlzaGVyI2Rpc2Nvbm5lY3RlZFxuICogQGVtaXRzIEluc2lnaHRzUHVibGlzaGVyI3JlY29ubmVjdGluZ1xuICovXG52YXIgSW5zaWdodHNQdWJsaXNoZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluc2lnaHRzUHVibGlzaGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIEluc2lnaHRzIGdhdGV3YXkgdG9rZW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2RrTmFtZSAtIE5hbWUgb2YgdGhlIFNESyB1c2luZyB0aGUge0BsaW5rIEluc2lnaHRzUHVibGlzaGVyfVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZGtWZXJzaW9uIC0gVmVyc2lvbiBvZiB0aGUgU0RLIHVzaW5nIHRoZSB7QGxpbmsgSW5zaWdodHNQdWJsaXNoZXJ9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVudmlyb25tZW50IC0gT25lIG9mICdkZXYnLCAnc3RhZ2UnIG9yICdwcm9kJ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWFsbSAtIFJlZ2lvbiBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtJbnNpZ2h0c1B1Ymxpc2hlck9wdGlvbnN9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5zaWdodHNQdWJsaXNoZXIodG9rZW4sIHNka05hbWUsIHNka1ZlcnNpb24sIGVudmlyb25tZW50LCByZWFsbSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBnYXRld2F5OiBjcmVhdGVHYXRld2F5KGVudmlyb25tZW50LCByZWFsbSkgKyBcIi92MS9WaWRlb0V2ZW50c1wiLFxuICAgICAgICAgICAgbWF4UmVjb25uZWN0QXR0ZW1wdHM6IE1BWF9SRUNPTk5FQ1RfQVRURU1QVFMsXG4gICAgICAgICAgICByZWNvbm5lY3RJbnRlcnZhbE1zOiBSRUNPTk5FQ1RfSU5URVJWQUxfTVMsXG4gICAgICAgICAgICB1c2VyQWdlbnQ6IGdldFVzZXJBZ2VudCgpLFxuICAgICAgICAgICAgV2ViU29ja2V0OiBXZWJTb2NrZXRcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfY29ubmVjdFRpbWVzdGFtcDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2V2ZW50UXVldWU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVhZHlUb0Nvbm5lY3Q6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdXRpbC5kZWZlcigpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlY29ubmVjdEF0dGVtcHRzTGVmdDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLm1heFJlY29ubmVjdEF0dGVtcHRzLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3dzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfV2ViU29ja2V0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuV2ViU29ja2V0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5fcmVhZHlUb0Nvbm5lY3QucHJvbWlzZS50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHJvb21TaWQgPSBfYS5yb29tU2lkLCBwYXJ0aWNpcGFudFNpZCA9IF9hLnBhcnRpY2lwYW50U2lkO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBfdGhpcztcbiAgICAgICAgICAgIF90aGlzLm9uKCdkaXNjb25uZWN0ZWQnLCBmdW5jdGlvbiBtYXliZVJlY29ubmVjdChlcnJvcikge1xuICAgICAgICAgICAgICAgIHNlbGYuX3Nlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciAmJiBzZWxmLl9yZWNvbm5lY3RBdHRlbXB0c0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgncmVjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlY29ubmVjdChzZWxmLCB0b2tlbiwgc2RrTmFtZSwgc2RrVmVyc2lvbiwgcm9vbVNpZCwgcGFydGljaXBhbnRTaWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Rpc2Nvbm5lY3RlZCcsIG1heWJlUmVjb25uZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29ubmVjdChfdGhpcywgdG9rZW4sIHNka05hbWUsIHNka1ZlcnNpb24sIHJvb21TaWQsIHBhcnRpY2lwYW50U2lkLCBvcHRpb25zKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gaWdub3JlIGZhaWx1cmVzIHRvIGNvbm5lY3RcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgY29ubmVjdGluZyB0byB0aGUgSW5zaWdodHMgZ2F0ZXdheS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vbVNpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJ0aWNpcGFudFNpZFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIEluc2lnaHRzUHVibGlzaGVyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHJvb21TaWQsIHBhcnRpY2lwYW50U2lkKSB7XG4gICAgICAgIHRoaXMuX3JlYWR5VG9Db25uZWN0LnJlc29sdmUoeyByb29tU2lkOiByb29tU2lkLCBwYXJ0aWNpcGFudFNpZDogcGFydGljaXBhbnRTaWQgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGFuIGV2ZW50IHRvIHRoZSBJbnNpZ2h0cyBnYXRld2F5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBldmVudFxuICAgICAqL1xuICAgIEluc2lnaHRzUHVibGlzaGVyLnByb3RvdHlwZS5fcHVibGlzaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5zZXNzaW9uID0gdGhpcy5fc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5fd3Muc2VuZChKU09OLnN0cmluZ2lmeShldmVudCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBmcm9tIHRoZSBJbnNpZ2h0cyBnYXRld2F5LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGNhbGxlZCB3aGVuIGNvbm5lY3Rpbmcvb3BlbiwgZmFsc2UgaWYgbm90XG4gICAgICovXG4gICAgSW5zaWdodHNQdWJsaXNoZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93cyA9PT0gbnVsbFxuICAgICAgICAgICAgfHwgdGhpcy5fd3MucmVhZHlTdGF0ZSA9PT0gdGhpcy5fV2ViU29ja2V0LkNMT1NJTkdcbiAgICAgICAgICAgIHx8IHRoaXMuX3dzLnJlYWR5U3RhdGUgPT09IHRoaXMuX1dlYlNvY2tldC5DTE9TRUQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fd3MuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIChvciBxdWV1ZSwgaWYgbm90IGNvbm5lY3RlZCkgYW4gZXZlbnQgdG8gdGhlIEluc2lnaHRzIGdhdGV3YXkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwTmFtZSAtIEV2ZW50IGdyb3VwIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gRXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXlsb2FkIC0gRXZlbnQgcGF5bG9hZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHF1ZXVlZCBvciBwdWJsaXNoZWQsIGZhbHNlIGlmIGRpc2Nvbm5lY3QoKSBjYWxsZWRcbiAgICAgKi9cbiAgICBJbnNpZ2h0c1B1Ymxpc2hlci5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uIChncm91cE5hbWUsIGV2ZW50TmFtZSwgcGF5bG9hZCkge1xuICAgICAgICBpZiAodGhpcy5fd3MgIT09IG51bGxcbiAgICAgICAgICAgICYmICh0aGlzLl93cy5yZWFkeVN0YXRlID09PSB0aGlzLl9XZWJTb2NrZXQuQ0xPU0lOR1xuICAgICAgICAgICAgICAgIHx8IHRoaXMuX3dzLnJlYWR5U3RhdGUgPT09IHRoaXMuX1dlYlNvY2tldC5DTE9TRUQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHB1Ymxpc2hPckVucXVldWUgPSB0eXBlb2YgdGhpcy5fc2Vzc2lvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gdGhpcy5fcHVibGlzaC5iaW5kKHRoaXMpXG4gICAgICAgICAgICA6IHRoaXMuX2V2ZW50UXVldWUucHVzaC5iaW5kKHRoaXMuX2V2ZW50UXVldWUpO1xuICAgICAgICBwdWJsaXNoT3JFbnF1ZXVlKHtcbiAgICAgICAgICAgIGdyb3VwOiBncm91cE5hbWUsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdHlwZTogJ2V2ZW50JyxcbiAgICAgICAgICAgIHZlcnNpb246IDFcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIEluc2lnaHRzUHVibGlzaGVyO1xufShFdmVudEVtaXR0ZXIpKTtcbi8qKlxuICogU3RhcnQgY29ubmVjdGluZyB0byB0aGUgSW5zaWdodHMgZ2F0ZXdheS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0luc2lnaHRzUHVibGlzaGVyfSBwdWJsaXNoZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZGtOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RrVmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21TaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJ0aWNpcGFudFNpZFxuICogQHBhcmFtIHtJbnNpZ2h0c1B1Ymxpc2hlck9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY29ubmVjdChwdWJsaXNoZXIsIHRva2VuLCBzZGtOYW1lLCBzZGtWZXJzaW9uLCByb29tU2lkLCBwYXJ0aWNpcGFudFNpZCwgb3B0aW9ucykge1xuICAgIHB1Ymxpc2hlci5fY29ubmVjdFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgcHVibGlzaGVyLl9yZWNvbm5lY3RBdHRlbXB0c0xlZnQtLTtcbiAgICBwdWJsaXNoZXIuX3dzID0gbmV3IG9wdGlvbnMuV2ViU29ja2V0KG9wdGlvbnMuZ2F0ZXdheSk7XG4gICAgdmFyIHdzID0gcHVibGlzaGVyLl93cztcbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuY29kZSA9PT0gV1NfQ0xPU0VfTk9STUFMKSB7XG4gICAgICAgICAgICBwdWJsaXNoZXIuZW1pdCgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHVibGlzaGVyLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcsIG5ldyBFcnJvcihcIldlYlNvY2tldCBFcnJvciBcIiArIGV2ZW50LmNvZGUgKyBcIjogXCIgKyBldmVudC5yZWFzb24pKTtcbiAgICB9KTtcbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaGFuZGxlQ29ubmVjdFJlc3BvbnNlKHB1Ymxpc2hlciwgSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubmVjdFJlcXVlc3QgPSB7XG4gICAgICAgICAgICB0eXBlOiAnY29ubmVjdCcsXG4gICAgICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgICAgICB2ZXJzaW9uOiAxXG4gICAgICAgIH07XG4gICAgICAgIGNvbm5lY3RSZXF1ZXN0LnB1Ymxpc2hlciA9IHtcbiAgICAgICAgICAgIG5hbWU6IHNka05hbWUsXG4gICAgICAgICAgICBzZGtWZXJzaW9uOiBzZGtWZXJzaW9uLFxuICAgICAgICAgICAgdXNlckFnZW50OiBvcHRpb25zLnVzZXJBZ2VudCxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50U2lkOiBwYXJ0aWNpcGFudFNpZCxcbiAgICAgICAgICAgIHJvb21TaWQ6IHJvb21TaWQsXG4gICAgICAgIH07XG4gICAgICAgIHdzLnNlbmQoSlNPTi5zdHJpbmdpZnkoY29ubmVjdFJlcXVlc3QpKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBJbnNpZ2h0cyBXZWJzb2NrZXQgZ2F0ZXdheSBVUkwuXG4gKiBAcGFyYW0ge3N0cmluZ30gZW52aXJvbm1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWFsbVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlR2F0ZXdheShlbnZpcm9ubWVudCwgcmVhbG0pIHtcbiAgICByZXR1cm4gZW52aXJvbm1lbnQgPT09ICdwcm9kJyA/IFwid3NzOi8vc2RrZ3cuXCIgKyByZWFsbSArIFwiLnR3aWxpby5jb21cIlxuICAgICAgICA6IFwid3NzOi8vc2RrZ3cuXCIgKyBlbnZpcm9ubWVudCArIFwiLVwiICsgcmVhbG0gKyBcIi50d2lsaW8uY29tXCI7XG59XG4vKipcbiAqIEhhbmRsZSBjb25uZWN0IHJlc3BvbnNlIGZyb20gdGhlIEluc2lnaHRzIGdhdGV3YXkuXG4gKiBAcGFyYW0ge0luc2lnaHRzUHVibGlzaGVyfSBwdWJsaXNoZXJcbiAqIEBwYXJhbSB7Kn0gcmVzcG9uc2VcbiAqIEBwYXJhbSB7SW5zaWdodHNQdWJsaXNoZXJPcHRpb25zfSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUNvbm5lY3RSZXNwb25zZShwdWJsaXNoZXIsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgc3dpdGNoIChyZXNwb25zZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICBwdWJsaXNoZXIuX3Nlc3Npb24gPSByZXNwb25zZS5zZXNzaW9uO1xuICAgICAgICAgICAgcHVibGlzaGVyLl9yZWNvbm5lY3RBdHRlbXB0c0xlZnQgPSBvcHRpb25zLm1heFJlY29ubmVjdEF0dGVtcHRzO1xuICAgICAgICAgICAgcHVibGlzaGVyLl9ldmVudFF1ZXVlLnNwbGljZSgwKS5mb3JFYWNoKHB1Ymxpc2hlci5fcHVibGlzaCwgcHVibGlzaGVyKTtcbiAgICAgICAgICAgIHB1Ymxpc2hlci5lbWl0KCdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICBwdWJsaXNoZXIuX3dzLmNsb3NlKCk7XG4gICAgICAgICAgICBwdWJsaXNoZXIuZW1pdCgnZGlzY29ubmVjdGVkJywgbmV3IEVycm9yKHJlc3BvbnNlLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbi8qKlxuICogU3RhcnQgcmUtY29ubmVjdGluZyB0byB0aGUgSW5zaWdodHMgZ2F0ZXdheSB3aXRoIGFuIGFwcHJvcHJpYXRlIGRlbGF5IGJhc2VkXG4gKiBvbiBJbnNpZ2h0c1B1Ymxpc2hlck9wdGlvbnMjcmVjb25uZWN0SW50ZXJ2YWxNcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0luc2lnaHRzUHVibGlzaGVyfSBwdWJsaXNoZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHNka05hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZGtWZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVNpZFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcnRpY2lwYW50U2lkXG4gKiBAcGFyYW0ge0luc2lnaHRzUHVibGlzaGVyT3B0aW9uc30gb3B0aW9uc1xuICovXG5mdW5jdGlvbiByZWNvbm5lY3QocHVibGlzaGVyLCB0b2tlbiwgc2RrTmFtZSwgc2RrVmVyc2lvbiwgcm9vbVNpZCwgcGFydGljaXBhbnRTaWQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29ubmVjdEludGVydmFsID0gRGF0ZS5ub3coKSAtIHB1Ymxpc2hlci5fY29ubmVjdFRpbWVzdGFtcDtcbiAgICB2YXIgdGltZVRvV2FpdCA9IG9wdGlvbnMucmVjb25uZWN0SW50ZXJ2YWxNcyAtIGNvbm5lY3RJbnRlcnZhbDtcbiAgICBpZiAodGltZVRvV2FpdCA+IDApIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25uZWN0KHB1Ymxpc2hlciwgdG9rZW4sIHNka05hbWUsIHNka1ZlcnNpb24sIHJvb21TaWQsIHBhcnRpY2lwYW50U2lkLCBvcHRpb25zKTtcbiAgICAgICAgfSwgdGltZVRvV2FpdCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29ubmVjdChwdWJsaXNoZXIsIHRva2VuLCBzZGtOYW1lLCBzZGtWZXJzaW9uLCByb29tU2lkLCBwYXJ0aWNpcGFudFNpZCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIFRoZSB7QGxpbmsgSW5zaWdodHNQdWJsaXNoZXJ9IGlzIGNvbm5lY3RlZCB0byB0aGUgZ2F0ZXdheS5cbiAqIEBldmVudCBJbnNpZ2h0c1B1Ymxpc2hlciNjb25uZWN0ZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIEluc2lnaHRzUHVibGlzaGVyfSBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgZ2F0ZXdheS5cbiAqIEBldmVudCBJbnNpZ2h0c1B1Ymxpc2hlciNkaXNjb25uZWN0ZWRcbiAqIEBwYXJhbSB7RXJyb3J9IFtlcnJvcl0gLSBPcHRpb25hbCBlcnJvciBpZiBkaXNjb25uZWN0ZWQgdW5pbnRlbnRpb25hbGx5XG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBJbnNpZ2h0c1B1Ymxpc2hlcn0gaXMgcmUtY29ubmVjdGluZyB0byB0aGUgZ2F0ZXdheS5cbiAqIEBldmVudCBJbnNpZ2h0c1B1Ymxpc2hlciNyZWNvbm5lY3RpbmdcbiAqL1xuLyoqXG4gKiB7QGxpbmsgSW5zaWdodHNQdWJsaXNoZXJ9IG9wdGlvbnMuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBJbnNpZ2h0c1B1Ymxpc2hlck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ2F0ZXdheT1zZGtndy57ZW52aXJvbm1lbnR9LXtyZWFsbX0udHdpbGlvLmNvbV0gLSBJbnNpZ2h0cyBXZWJTb2NrZXQgZ2F0ZXdheSB1cmxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVjb25uZWN0QXR0ZW1wdHM9NV0gLSBNYXggcmUtY29ubmVjdCBhdHRlbXB0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZWNvbm5lY3RJbnRlcnZhbE1zPTUwXSAtIFJlLWNvbm5lY3QgaW50ZXJ2YWwgaW4gbXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBJbnNpZ2h0c1B1Ymxpc2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby13YXJuaW5nLWNvbW1lbnRzXG4vLyBUT0RPKG1yb2JlcnRzKTogVGhpcyBzaG91bGQgYmUgZGVzY3JpYmVkIGFzIGltcGxlbWVudGluZyBzb21lXG4vLyBJbnNpZ2h0c1B1Ymxpc2hlciBpbnRlcmZhY2UuXG4ndXNlIHN0cmljdCc7XG4vKipcbiAqIE51bGwgSW5zaWdodHMgcHVibGlzaGVyLlxuICovXG52YXIgSW5zaWdodHNQdWJsaXNoZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5zaWdodHNQdWJsaXNoZXIoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIF9jb25uZWN0ZWQ6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIEluc2lnaHRzUHVibGlzaGVyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBJbnNpZ2h0c1B1Ymxpc2hlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdWJsaXNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIEluc2lnaHRzUHVibGlzaGVyLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGVkO1xuICAgIH07XG4gICAgcmV0dXJuIEluc2lnaHRzUHVibGlzaGVyO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gSW5zaWdodHNQdWJsaXNoZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZlciA9IHJlcXVpcmUoJy4vJykuZGVmZXI7XG4vKipcbiAqIFRoaXMgaXMgYSBwYWlyIG9mIERlZmVycmVkcyB0aGF0IGFyZSBzZXQgd2hlbmV2ZXIgbG9jYWwgbWVkaWEgaXMgbXV0ZWQgYW5kXG4gKiByZXNvbHZlZCB3aGVuZXZlciBsb2NhbCBtZWRpYSBpcyB1bm11dGVkL2VuZGVkIGFuZCByZXN0YXJ0ZWQgaWYgbmVjZXNzYXJ5LlxuICovXG52YXIgTG9jYWxNZWRpYVJlc3RhcnREZWZlcnJlZHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9jYWxNZWRpYVJlc3RhcnREZWZlcnJlZHMoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIF9hdWRpbzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkZWZlcigpLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ZpZGVvOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlZmVyKCksXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluaXRpYWxseSwgcmVzb2x2ZSBib3RoIHRoZSBEZWZlcnJlZHMuXG4gICAgICAgIHRoaXMuX2F1ZGlvLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5fdmlkZW8ucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIHRoZSBEZWZlcnJlZCBmb3IgYXVkaW8gb3IgdmlkZW8uXG4gICAgICogQHBhcmFtIHsnYXVkaW8nfCd2aWRlbyd9IGtpbmRcbiAgICAgKi9cbiAgICBMb2NhbE1lZGlhUmVzdGFydERlZmVycmVkcy5wcm90b3R5cGUucmVzb2x2ZURlZmVycmVkID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIERlZmVycmVkIGZvciBhdWRpbyBvciB2aWRlby5cbiAgICAgKiBAcGFyYW0geydhdWRpbycgfCAndmlkZW8nfSBraW5kXG4gICAgICovXG4gICAgTG9jYWxNZWRpYVJlc3RhcnREZWZlcnJlZHMucHJvdG90eXBlLnN0YXJ0RGVmZXJyZWQgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgICAgICBpZiAoa2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgdGhpcy5fYXVkaW8gPSBkZWZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdmlkZW8gPSBkZWZlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXYWl0IHVudGlsIHRoZSBEZWZlcnJlZCBmb3IgYXVkaW8gb3IgdmlkZW8gaXMgcmVzb2x2ZWQuXG4gICAgICogQHBhcmFtIHsnYXVkaW8nfCd2aWRlbyd9IGtpbmRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBMb2NhbE1lZGlhUmVzdGFydERlZmVycmVkcy5wcm90b3R5cGUud2hlblJlc29sdmVkID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09ICdhdWRpbycgPyB0aGlzLl9hdWRpby5wcm9taXNlIDogdGhpcy5fdmlkZW8ucHJvbWlzZTtcbiAgICB9O1xuICAgIHJldHVybiBMb2NhbE1lZGlhUmVzdGFydERlZmVycmVkcztcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBMb2NhbE1lZGlhUmVzdGFydERlZmVycmVkcygpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxtZWRpYXJlc3RhcnRkZWZlcnJlZHMuanMubWFwIiwiLyogZXNsaW50IG5ldy1jYXA6MCAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgICAgICB0b1tqXSA9IGZyb21baV07XG4gICAgcmV0dXJuIHRvO1xufTtcbnZhciBkZWZhdWx0R2V0TG9nZ2VyID0gcmVxdWlyZSgnLi4vdmVuZG9yL2xvZ2xldmVsJykuZ2V0TG9nZ2VyO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG52YXIgREVGQVVMVF9MT0dfTEVWRUwgPSBjb25zdGFudHMuREVGQVVMVF9MT0dfTEVWRUwsIERFRkFVTFRfTE9HR0VSX05BTUUgPSBjb25zdGFudHMuREVGQVVMVF9MT0dHRVJfTkFNRTtcbnZhciBFID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKS50eXBlRXJyb3JzO1xudmFyIGRlcHJlY2F0aW9uV2FybmluZ3NCeUNvbXBvbmVudENvbnN0cnVjdG9yO1xuZnVuY3Rpb24gZ2V0RGVwcmVjYXRpb25XYXJuaW5ncyhjb21wb25lbnRDb25zdHJ1Y3Rvcikge1xuICAgIGRlcHJlY2F0aW9uV2FybmluZ3NCeUNvbXBvbmVudENvbnN0cnVjdG9yID0gZGVwcmVjYXRpb25XYXJuaW5nc0J5Q29tcG9uZW50Q29uc3RydWN0b3IgfHwgbmV3IE1hcCgpO1xuICAgIGlmIChkZXByZWNhdGlvbldhcm5pbmdzQnlDb21wb25lbnRDb25zdHJ1Y3Rvci5oYXMoY29tcG9uZW50Q29uc3RydWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBkZXByZWNhdGlvbldhcm5pbmdzQnlDb21wb25lbnRDb25zdHJ1Y3Rvci5nZXQoY29tcG9uZW50Q29uc3RydWN0b3IpO1xuICAgIH1cbiAgICB2YXIgZGVwcmVjYXRpb25XYXJuaW5ncyA9IG5ldyBTZXQoKTtcbiAgICBkZXByZWNhdGlvbldhcm5pbmdzQnlDb21wb25lbnRDb25zdHJ1Y3Rvci5zZXQoY29tcG9uZW50Q29uc3RydWN0b3IsIGRlcHJlY2F0aW9uV2FybmluZ3MpO1xuICAgIHJldHVybiBkZXByZWNhdGlvbldhcm5pbmdzO1xufVxuLyoqXG4gKiBTZWxlY3RpdmVseSBvdXRwdXRzIG1lc3NhZ2VzIHRvIGNvbnNvbGUgYmFzZWQgb24gc3BlY2lmaWVkIG1pbmltdW0gbW9kdWxlXG4gKiBzcGVjaWZpYyBsb2cgbGV2ZWxzLlxuICpcbiAqIE5PVEU6IFRoZSB2YWx1ZXMgaW4gdGhlIGxvZ0xldmVscyBvYmplY3QgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciBpcyBjaGFuZ2VkXG4gKiAgICAgICBieSBzdWJzZXF1ZW50IGNhbGxzIHRvIHtAbGluayBMb2cjc2V0TGV2ZWxzfS5cbiAqL1xudmFyIExvZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcge0BsaW5rIExvZ30gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGVOYW1lIC0gTmFtZSBvZiB0aGUgbG9nZ2luZyBtb2R1bGUgKHdlYnJ0Yy9tZWRpYS9zaWduYWxpbmcpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCAtIENvbXBvbmVudCBvd25pbmcgdGhpcyBpbnN0YW5jZSBvZiB7QGxpbmsgTG9nfVxuICAgICAqIEBwYXJhbSB7TG9nTGV2ZWxzfSBsb2dMZXZlbHMgLSBMb2dnaW5nIGxldmVscy4gU2VlIHtAbGluayBMb2dMZXZlbHN9XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxvZ2dlck5hbWUgLSBOYW1lIG9mIHRoZSBsb2dnZXIgaW5zdGFuY2UuIFVzZWQgd2hlbiBjYWxsaW5nIGdldExvZ2dlciBmcm9tIGxvZ2xldmVsIG1vZHVsZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZXRMb2dnZXJdIC0gb3B0aW9uYWwgbWV0aG9kIHVzZWQgaW50ZXJuYWxseS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2cobW9kdWxlTmFtZSwgY29tcG9uZW50LCBsb2dMZXZlbHMsIGxvZ2dlck5hbWUsIGdldExvZ2dlcikge1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZU5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBFLklOVkFMSURfVFlQRSgnbW9kdWxlTmFtZScsICdzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhyb3cgRS5SRVFVSVJFRF9BUkdVTUVOVCgnY29tcG9uZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsb2dMZXZlbHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBsb2dMZXZlbHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBnZXRMb2dnZXIgPSBnZXRMb2dnZXIgfHwgZGVmYXVsdEdldExvZ2dlcjtcbiAgICAgICAgdmFsaWRhdGVMb2dMZXZlbHMobG9nTGV2ZWxzKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgX2NvbXBvbmVudDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjb21wb25lbnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9nTGV2ZWxzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGxvZ0xldmVsc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF93YXJuaW5nczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9nZ2VyTmFtZToge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGxvZ2dlck5hbWUgJiYgdHlwZW9mIGxvZ2dlck5hbWUgPT09ICdzdHJpbmcnID8gbG9nZ2VyTmFtZSA6IERFRkFVTFRfTE9HR0VSX05BTUU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbG9nTGV2ZWxzRXF1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lICsgXCItXCIgKyBtb2R1bGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9nZ2VyOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2dnZXIgPSBnZXRMb2dnZXIodGhpcy5fbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IHRoaXMuX2xvZ0xldmVsc1ttb2R1bGVOYW1lXSB8fCBERUZBVUxUX0xPR19MRVZFTDtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gJ29mZicgaW4gdGhlIGxvZ2dlciBtb2R1bGUuIEl0IHVzZXMgJ3NpbGVudCcgaW5zdGVhZFxuICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IGxldmVsID09PSAnb2ZmJyA/ICdzaWxlbnQnIDogbGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5zZXREZWZhdWx0TGV2ZWwobGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9nTGV2ZWxzRXF1YWw6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ1ZSBpZiBhbGwgbGV2ZWxzIGFyZSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBTZXQoT2JqZWN0LnZhbHVlcyh0aGlzLl9sb2dMZXZlbHMpKS5zaXplKSA9PT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9nTGV2ZWw6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIExvZy5nZXRMZXZlbEJ5TmFtZShsb2dMZXZlbHNbbW9kdWxlTmFtZV0gfHwgREVGQVVMVF9MT0dfTEVWRUwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiB7IGdldDogY29tcG9uZW50LnRvU3RyaW5nLmJpbmQoY29tcG9uZW50KSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxvZyBsZXZlbCAobnVtYmVyKSBieSBpdHMgbmFtZSAoc3RyaW5nKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbG9nIGxldmVsXG4gICAgICogQHJldHVybnMge051bWJlcn0gUmVxdWVzdGVkIGxvZyBsZXZlbFxuICAgICAqIEB0aHJvd3Mge1R3aWxpb0Vycm9yfSBJTlZBTElEX0xPR19MRVZFTCAoMzIwNTYpXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIExvZy5nZXRMZXZlbEJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICghaXNOYU4obmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChuYW1lLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFsaWRhdGVMb2dMZXZlbChuYW1lKTtcbiAgICAgICAgcmV0dXJuIExvZ1tuYW1lXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNoaWxkIHtAbGluayBMb2d9IGluc3RhbmNlIHdpdGggdGhpcy5fbG9nTGV2ZWxzXG4gICAgICogQHBhcmFtIG1vZHVsZU5hbWUgLSBOYW1lIG9mIHRoZSBsb2dnaW5nIG1vZHVsZVxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgLSBDb21wb25lbnQgb3duaW5nIHRoaXMgaW5zdGFuY2Ugb2Yge0BsaW5rIExvZ31cbiAgICAgKiBAcmV0dXJucyB7TG9nfSB0aGlzXG4gICAgICovXG4gICAgTG9nLnByb3RvdHlwZS5jcmVhdGVMb2cgPSBmdW5jdGlvbiAobW9kdWxlTmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5fbG9nZ2VyTmFtZTtcbiAgICAgICAgLy8gR3JhYiB0aGUgb3JpZ2luYWwgbG9nZ2VyIG5hbWVcbiAgICAgICAgaWYgKCF0aGlzLl9sb2dMZXZlbHNFcXVhbCkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGFzdEluZGV4T2YoJy0nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMb2cobW9kdWxlTmFtZSwgY29tcG9uZW50LCB0aGlzLl9sb2dMZXZlbHMsIG5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IG5ldyBsb2cgbGV2ZWxzLlxuICAgICAqIFRoaXMgY2hhbmdlcyB0aGUgbGV2ZWxzIGZvciBhbGwgaXRzIGFuY2VzdG9ycyxcbiAgICAgKiBzaWJsaW5ncywgYW5kIGNoaWxkcmVuIGFuZCBkZXNjZW5kYW50cyBpbnN0YW5jZXMgb2Yge0BsaW5rIExvZ30uXG4gICAgICogQHBhcmFtIHtMb2dMZXZlbHN9IGxldmVscyAtIE5ldyBsb2cgbGV2ZWxzXG4gICAgICogQHRocm93cyB7VHdpbGlvRXJyb3J9IElOVkFMSURfQVJHVU1FTlRcbiAgICAgKiBAcmV0dXJucyB7TG9nfSB0aGlzXG4gICAgICovXG4gICAgTG9nLnByb3RvdHlwZS5zZXRMZXZlbHMgPSBmdW5jdGlvbiAobGV2ZWxzKSB7XG4gICAgICAgIHZhbGlkYXRlTG9nTGV2ZWxzKGxldmVscyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fbG9nTGV2ZWxzLCBsZXZlbHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZyBhIG1lc3NhZ2UgdXNpbmcgdGhlIGxvZ2dlciBtZXRob2QgYXBwcm9wcmlhdGUgZm9yIHRoZSBzcGVjaWZpZWQgbG9nTGV2ZWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbG9nTGV2ZWwgLSBMb2cgbGV2ZWwgb2YgdGhlIG1lc3NhZ2UgYmVpbmcgbG9nZ2VkXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWVzc2FnZXMgLSBNZXNzYWdlKHMpIHRvIGxvZ1xuICAgICAqIEByZXR1cm5zIHtMb2d9IFRoaXMgaW5zdGFuY2Ugb2Yge0BsaW5rIExvZ31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTG9nLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobG9nTGV2ZWwsIG1lc3NhZ2VzKSB7XG4gICAgICAgIHZhciBuYW1lID0gTG9nLl9sZXZlbHNbbG9nTGV2ZWxdO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBFLklOVkFMSURfVkFMVUUoJ2xvZ0xldmVsJywgTE9HX0xFVkVMX1ZBTFVFUyk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIHByZWZpeCA9IFtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksIG5hbWUsIHRoaXMubmFtZV07XG4gICAgICAgICh0aGlzLl9sb2dnZXJbbmFtZV0gfHwgZnVuY3Rpb24gbm9vcCgpIHsgfSkuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocHJlZml4LmNvbmNhdChtZXNzYWdlcykpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIGEgZGVidWcgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBtZXNzYWdlcyAtIE1lc3NhZ2UocykgdG8gcGFzcyB0byB0aGUgbG9nZ2VyXG4gICAgICogQHJldHVybnMge0xvZ30gVGhpcyBpbnN0YW5jZSBvZiB7QGxpbmsgTG9nfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBMb2cucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2coTG9nLkRFQlVHLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIGEgZGVwcmVjYXRpb24gd2FybmluZy4gRGVwcmVjYXRpb24gd2FybmluZ3MgYXJlIGxvZ2dlZCBhcyB3YXJuaW5ncyBhbmRcbiAgICAgKiB0aGV5IGFyZSBvbmx5IGV2ZXIgbG9nZ2VkIG9uY2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlcHJlY2F0aW9uV2FybmluZyAtIFRoZSBkZXByZWNhdGlvbiB3YXJuaW5nXG4gICAgICogQHJldHVybnMge0xvZ30gVGhpcyBpbnN0YW5jZSBvZiB7QGxpbmsgTG9nfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBMb2cucHJvdG90eXBlLmRlcHJlY2F0ZWQgPSBmdW5jdGlvbiAoZGVwcmVjYXRpb25XYXJuaW5nKSB7XG4gICAgICAgIHZhciBkZXByZWNhdGlvbldhcm5pbmdzID0gZ2V0RGVwcmVjYXRpb25XYXJuaW5ncyh0aGlzLl9jb21wb25lbnQuY29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoZGVwcmVjYXRpb25XYXJuaW5ncy5oYXMoZGVwcmVjYXRpb25XYXJuaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5ncy5hZGQoZGVwcmVjYXRpb25XYXJuaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2FybihkZXByZWNhdGlvbldhcm5pbmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIGFuIGluZm8gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBtZXNzYWdlcyAtIE1lc3NhZ2UocykgdG8gcGFzcyB0byB0aGUgbG9nZ2VyXG4gICAgICogQHJldHVybnMge0xvZ30gVGhpcyBpbnN0YW5jZSBvZiB7QGxpbmsgTG9nfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBMb2cucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZyhMb2cuSU5GTywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZyBhIHdhcm4gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBtZXNzYWdlcyAtIE1lc3NhZ2UocykgdG8gcGFzcyB0byB0aGUgbG9nZ2VyXG4gICAgICogQHJldHVybnMge0xvZ30gVGhpcyBpbnN0YW5jZSBvZiB7QGxpbmsgTG9nfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBMb2cucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZyhMb2cuV0FSTiwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZyBhIHdhcm5pbmcgb25jZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd2FybmluZ1xuICAgICAqIEByZXR1cm5zIHtMb2d9IFRoaXMgaW5zdGFuY2Ugb2Yge0BsaW5rIExvZ31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTG9nLnByb3RvdHlwZS53YXJuT25jZSA9IGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgICAgIGlmICh0aGlzLl93YXJuaW5ncy5oYXMod2FybmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dhcm5pbmdzLmFkZCh3YXJuaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Fybih3YXJuaW5nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZyBhbiBlcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIHsuLi5TdHJpbmd9IG1lc3NhZ2VzIC0gTWVzc2FnZShzKSB0byBwYXNzIHRvIHRoZSBsb2dnZXJcbiAgICAgKiBAcmV0dXJucyB7TG9nfSBUaGlzIGluc3RhbmNlIG9mIHtAbGluayBMb2d9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIExvZy5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZyhMb2cuRVJST1IsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2cgYW4gZXJyb3IgbWVzc2FnZSBhbmQgdGhyb3cgYW4gZXhjZXB0aW9uXG4gICAgICogQHBhcmFtIHtUd2lsaW9FcnJvcn0gZXJyb3IgLSBFcnJvciB0byB0aHJvd1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjdXN0b21NZXNzYWdlIC0gQ3VzdG9tIG1lc3NhZ2UgZm9yIHRoZSBlcnJvclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBMb2cucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24gKGVycm9yLCBjdXN0b21NZXNzYWdlKSB7XG4gICAgICAgIGlmIChlcnJvci5jbG9uZSkge1xuICAgICAgICAgICAgZXJyb3IgPSBlcnJvci5jbG9uZShjdXN0b21NZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZyhMb2cuRVJST1IsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfTtcbiAgICByZXR1cm4gTG9nO1xufSgpKTtcbi8vIFNpbmdsZXRvbiBDb25zdGFudHNcbi8qIGVzbGludCBrZXktc3BhY2luZzowICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTG9nLCB7XG4gICAgREVCVUc6IHsgdmFsdWU6IDAgfSxcbiAgICBJTkZPOiB7IHZhbHVlOiAxIH0sXG4gICAgV0FSTjogeyB2YWx1ZTogMiB9LFxuICAgIEVSUk9SOiB7IHZhbHVlOiAzIH0sXG4gICAgT0ZGOiB7IHZhbHVlOiA0IH0sXG4gICAgX2xldmVsczoge1xuICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAgJ0RFQlVHJyxcbiAgICAgICAgICAgICdJTkZPJyxcbiAgICAgICAgICAgICdXQVJOJyxcbiAgICAgICAgICAgICdFUlJPUicsXG4gICAgICAgICAgICAnT0ZGJyxcbiAgICAgICAgXVxuICAgIH1cbn0pO1xudmFyIExPR19MRVZFTFNfU0VUID0ge307XG52YXIgTE9HX0xFVkVMX1ZBTFVFUyA9IFtdO1xudmFyIExPR19MRVZFTF9OQU1FUyA9IExvZy5fbGV2ZWxzLm1hcChmdW5jdGlvbiAobGV2ZWwsIGkpIHtcbiAgICBMT0dfTEVWRUxTX1NFVFtsZXZlbF0gPSB0cnVlO1xuICAgIExPR19MRVZFTF9WQUxVRVMucHVzaChpKTtcbiAgICByZXR1cm4gbGV2ZWw7XG59KTtcbmZ1bmN0aW9uIHZhbGlkYXRlTG9nTGV2ZWwobGV2ZWwpIHtcbiAgICBpZiAoIShsZXZlbCBpbiBMT0dfTEVWRUxTX1NFVCkpIHtcbiAgICAgICAgdGhyb3cgRS5JTlZBTElEX1ZBTFVFKCdsZXZlbCcsIExPR19MRVZFTF9OQU1FUyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVMb2dMZXZlbHMobGV2ZWxzKSB7XG4gICAgT2JqZWN0LmtleXMobGV2ZWxzKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVOYW1lKSB7XG4gICAgICAgIHZhbGlkYXRlTG9nTGV2ZWwobGV2ZWxzW21vZHVsZU5hbWVdLnRvVXBwZXJDYXNlKCkpO1xuICAgIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBMb2c7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2cuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBtb3ZpbmcgYXZlcmFnZSBkZWx0YSBmb3IgdGhlIGdpdmVuIHBhaXIgb2ZzYW1wbGVzLiBBIHNhbXBsZSAoUylcbiAqIGNvbnNpc3RzIG9mIGEgbnVtZXJhdG9yIChTbikgYW5kIGEgZGVub21pbmF0b3IgKFNkKS5UaGUgbW92aW5nIGF2ZXJhZ2UgZGVsdGEgaXNcbiAqIGNhbGN1bGF0ZWQgYXMgZm9sbG93czpcbiAqXG4gKiBNb3ZpbmdBdmdEZWx0YSA9IChTblsxXSAtIFNuWzBdKSAvIChTZFsxXSAtIFNkWzBdKVxuICovXG52YXIgTW92aW5nQXZlcmFnZURlbHRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1vdmluZ0F2ZXJhZ2VEZWx0YSgpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgX3NhbXBsZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAgICAgICAgICB7IGRlbm9taW5hdG9yOiAwLCBudW1lcmF0b3I6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBkZW5vbWluYXRvcjogMCwgbnVtZXJhdG9yOiAwIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtb3ZpbmcgYXZlcmFnZSBkZWx0YS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIE1vdmluZ0F2ZXJhZ2VEZWx0YS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2FtcGxlcyA9IHRoaXMuX3NhbXBsZXM7XG4gICAgICAgIHZhciBkZW5vbWluYXRvckRlbHRhID0gKHNhbXBsZXNbMV0uZGVub21pbmF0b3IgLSBzYW1wbGVzWzBdLmRlbm9taW5hdG9yKSB8fCBJbmZpbml0eTtcbiAgICAgICAgdmFyIG51bWVyYXRvckRlbHRhID0gc2FtcGxlc1sxXS5udW1lcmF0b3IgLSBzYW1wbGVzWzBdLm51bWVyYXRvcjtcbiAgICAgICAgcmV0dXJuIG51bWVyYXRvckRlbHRhIC8gZGVub21pbmF0b3JEZWx0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1dCBhIHNhbXBsZSBhbmQgZ2V0IHJpZCBvZiB0aGUgb2xkZXIgc2FtcGxlIHRvIG1haW50YWluIHNhbXBsZSBzaXplIG9mIDIuXG4gICAgICogQHBhcmFtIG51bWVyYXRvclxuICAgICAqIEBwYXJhbSBkZW5vbWluYXRvclxuICAgICAqL1xuICAgIE1vdmluZ0F2ZXJhZ2VEZWx0YS5wcm90b3R5cGUucHV0U2FtcGxlID0gZnVuY3Rpb24gKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICAgICAgdmFyIHNhbXBsZXMgPSB0aGlzLl9zYW1wbGVzO1xuICAgICAgICBzYW1wbGVzLnNoaWZ0KCk7XG4gICAgICAgIHNhbXBsZXMucHVzaCh7IGRlbm9taW5hdG9yOiBkZW5vbWluYXRvciwgbnVtZXJhdG9yOiBudW1lcmF0b3IgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTW92aW5nQXZlcmFnZURlbHRhO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gTW92aW5nQXZlcmFnZURlbHRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92aW5nYXZlcmFnZWRlbHRhLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogTW9uaXRvciB0aGUgbmV0d29yayBjb25uZWN0aW9uIHN0YXR1cyB0byBkZXRlY3QgaW50ZXJydXB0aW9ucyBhbmQgaGFuZG9mZnMuXG4gKi9cbnZhciBOZXR3b3JrTW9uaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTmV0d29ya01vbml0b3J9LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uTmV0d29ya0NoYW5nZWRcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5ldHdvcmtNb25pdG9yKG9uTmV0d29ya0NoYW5nZWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgbmF2aWdhdG9yOiBuYXZpZ2F0b3IsXG4gICAgICAgICAgICB3aW5kb3c6IHdpbmRvdyxcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBuYXYgPSBvcHRpb25zLm5hdmlnYXRvcjtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBuYXYuY29ubmVjdGlvbiB8fCB7IHR5cGU6IG51bGwgfTtcbiAgICAgICAgdmFyIHR5cGUgPSBjb25uZWN0aW9uLnR5cGU7XG4gICAgICAgIHZhciBfYSA9IGNvbm5lY3Rpb24udHlwZSA/IHtcbiAgICAgICAgICAgIF9ldmVudHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogWydjaGFuZ2UnLCAndHlwZWNoYW5nZSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xpc3RlbmVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ldHdvcmtDaGFuZ2VkID0gdHlwZSAhPT0gX3RoaXMudHlwZSAmJiBfdGhpcy5pc09ubGluZTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IF90aGlzLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25OZXR3b3JrQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY29ubmVjdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgX2V2ZW50czoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbJ29ubGluZSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xpc3RlbmVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9uTmV0d29ya0NoYW5nZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMud2luZG93XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIF9ldmVudHMgPSBfYS5fZXZlbnRzLCBfbGlzdGVuZXIgPSBfYS5fbGlzdGVuZXIsIF90YXJnZXQgPSBfYS5fdGFyZ2V0O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBpc09ubGluZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbmF2Lm9uTGluZSA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5hdi5vbkxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLnR5cGUgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xpc3RlbmVyOiBfbGlzdGVuZXIsXG4gICAgICAgICAgICBfZXZlbnRzOiBfZXZlbnRzLFxuICAgICAgICAgICAgX3RhcmdldDogX3RhcmdldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIHtAbGluayBOZXR3b3JrTW9uaXRvcn0uXG4gICAgICovXG4gICAgTmV0d29ya01vbml0b3IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuX2xpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSB7QGxpbmsgTmV0d29ya01vbml0b3J9LlxuICAgICAqL1xuICAgIE5ldHdvcmtNb25pdG9yLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuX2xpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTmV0d29ya01vbml0b3I7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrTW9uaXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmttb25pdG9yLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTnVsbE9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE51bGxPYnNlcnZlcihjYWxsYmFjaykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBfY2FsbGJhY2s6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2FsbGJhY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE51bGxPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIE51bGxPYnNlcnZlci5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgTnVsbE9ic2VydmVyLnByb3RvdHlwZS5tYWtlVmlzaWJsZSA9IGZ1bmN0aW9uICh2aWRlb0VsKSB7XG4gICAgICAgIHZhciB2aXNpYmxlRW50cnkgPSB0aGlzLl9tYWtlRmFrZUVudHJ5KHZpZGVvRWwsIHRydWUpO1xuICAgICAgICB0aGlzLl9jYWxsYmFjayhbdmlzaWJsZUVudHJ5XSk7XG4gICAgfTtcbiAgICBOdWxsT2JzZXJ2ZXIucHJvdG90eXBlLm1ha2VJbnZpc2libGUgPSBmdW5jdGlvbiAodmlkZW9FbCkge1xuICAgICAgICB2YXIgaW52aXNpYmxlRW50cnkgPSB0aGlzLl9tYWtlRmFrZUVudHJ5KHZpZGVvRWwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2soW2ludmlzaWJsZUVudHJ5XSk7XG4gICAgfTtcbiAgICBOdWxsT2JzZXJ2ZXIucHJvdG90eXBlLl9tYWtlRmFrZUVudHJ5ID0gZnVuY3Rpb24gKHZpZGVvRWxlbWVudCwgaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0OiB2aWRlb0VsZW1lbnQsIGlzSW50ZXJzZWN0aW5nOiBpc0ludGVyc2VjdGluZyB9O1xuICAgIH07XG4gICAgcmV0dXJuIE51bGxPYnNlcnZlcjtcbn0oKSk7XG52YXIgTnVsbEludGVyc2VjdGlvbk9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOdWxsSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTnVsbEludGVyc2VjdGlvbk9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBOdWxsSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG59KE51bGxPYnNlcnZlcikpO1xudmFyIE51bGxSZXNpemVPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTnVsbFJlc2l6ZU9ic2VydmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE51bGxSZXNpemVPYnNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOdWxsUmVzaXplT2JzZXJ2ZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh2aWRlb0VsKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX21ha2VGYWtlRW50cnkodmlkZW9FbCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrKFtlbnRyeV0pO1xuICAgIH07XG4gICAgcmV0dXJuIE51bGxSZXNpemVPYnNlcnZlcjtcbn0oTnVsbE9ic2VydmVyKSk7XG5tb2R1bGUuZXhwb3J0cyA9IHsgTnVsbEludGVyc2VjdGlvbk9ic2VydmVyOiBOdWxsSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsIE51bGxSZXNpemVPYnNlcnZlcjogTnVsbFJlc2l6ZU9ic2VydmVyLCBOdWxsT2JzZXJ2ZXI6IE51bGxPYnNlcnZlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVsbG9ic2VydmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfYSA9IHJlcXVpcmUoJy4uLycpLCBkaWZmZXJlbmNlID0gX2EuZGlmZmVyZW5jZSwgZmxhdE1hcCA9IF9hLmZsYXRNYXA7XG52YXIgc2V0U2ltdWxjYXN0SW5NZWRpYVNlY3Rpb24gPSByZXF1aXJlKCcuL3NpbXVsY2FzdCcpO1xudmFyIHB0VG9GaXhlZEJpdHJhdGVBdWRpb0NvZGVjTmFtZSA9IHtcbiAgICAwOiAnUENNVScsXG4gICAgODogJ1BDTUEnXG59O1xuLyoqXG4gKiBBIHBheWxvYWQgdHlwZVxuICogQHR5cGVkZWYge251bWJlcn0gUFRcbiAqL1xuLyoqXG4gKiBBbiB7QGxpbmsgQXVkaW9Db2RlY30gb3Ige0BsaW5rIFZpZGVvQ29kZWN9XG4gKiBAdHlwZWRlZiB7QXVkaW9Db2RlY3xWaWRlb0NvZGVjfSBDb2RlY1xuICovXG4vKipcbiAqIENyZWF0ZSBhIENvZGVjIE1hcCBmb3IgdGhlIGdpdmVuIG09IHNlY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VjdGlvbiAtIFRoZSBnaXZlbiBtPSBzZWN0aW9uXG4gKiBAcmV0dXJucyB7TWFwPENvZGVjLCBBcnJheTxQVD4+fVxuICovXG5mdW5jdGlvbiBjcmVhdGVDb2RlY01hcEZvck1lZGlhU2VjdGlvbihzZWN0aW9uKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oY3JlYXRlUHRUb0NvZGVjTmFtZShzZWN0aW9uKSkucmVkdWNlKGZ1bmN0aW9uIChjb2RlY01hcCwgcGFpcikge1xuICAgICAgICB2YXIgcHQgPSBwYWlyWzBdO1xuICAgICAgICB2YXIgY29kZWNOYW1lID0gcGFpclsxXTtcbiAgICAgICAgdmFyIHB0cyA9IGNvZGVjTWFwLmdldChjb2RlY05hbWUpIHx8IFtdO1xuICAgICAgICByZXR1cm4gY29kZWNNYXAuc2V0KGNvZGVjTmFtZSwgcHRzLmNvbmNhdChwdCkpO1xuICAgIH0sIG5ldyBNYXAoKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIE1hcCBvZiBNSURzIHRvIG09IHNlY3Rpb25zIGZvciB0aGUgZ2l2ZW4gU0RQLlxuICogQHBhcmFtIHtzdHJpbmd9IHNkcFxuICogQHJldHVybnMge01hcDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1pZFRvTWVkaWFTZWN0aW9uTWFwKHNkcCkge1xuICAgIHJldHVybiBnZXRNZWRpYVNlY3Rpb25zKHNkcCkucmVkdWNlKGZ1bmN0aW9uIChtaWRzVG9NZWRpYVNlY3Rpb25zLCBtZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgdmFyIG1pZCA9IGdldE1pZEZvck1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24pO1xuICAgICAgICByZXR1cm4gbWlkID8gbWlkc1RvTWVkaWFTZWN0aW9ucy5zZXQobWlkLCBtZWRpYVNlY3Rpb24pIDogbWlkc1RvTWVkaWFTZWN0aW9ucztcbiAgICB9LCBuZXcgTWFwKCkpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBNYXAgZnJvbSBQVHMgdG8gY29kZWMgbmFtZXMgZm9yIHRoZSBnaXZlbiBtPSBzZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG1lZGlhU2VjdGlvbiAtIFRoZSBnaXZlbiBtPSBzZWN0aW9uLlxuICogQHJldHVybnMge01hcDxQVCwgQ29kZWM+fSBwdFRvQ29kZWNOYW1lXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVB0VG9Db2RlY05hbWUobWVkaWFTZWN0aW9uKSB7XG4gICAgcmV0dXJuIGdldFBheWxvYWRUeXBlc0luTWVkaWFTZWN0aW9uKG1lZGlhU2VjdGlvbikucmVkdWNlKGZ1bmN0aW9uIChwdFRvQ29kZWNOYW1lLCBwdCkge1xuICAgICAgICB2YXIgcnRwbWFwUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJhPXJ0cG1hcDpcIiArIHB0ICsgXCIgKFteL10rKVwiKTtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBtZWRpYVNlY3Rpb24ubWF0Y2gocnRwbWFwUGF0dGVybik7XG4gICAgICAgIHZhciBjb2RlY05hbWUgPSBtYXRjaGVzXG4gICAgICAgICAgICA/IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgOiBwdFRvRml4ZWRCaXRyYXRlQXVkaW9Db2RlY05hbWVbcHRdXG4gICAgICAgICAgICAgICAgPyBwdFRvRml4ZWRCaXRyYXRlQXVkaW9Db2RlY05hbWVbcHRdLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICByZXR1cm4gcHRUb0NvZGVjTmFtZS5zZXQocHQsIGNvZGVjTmFtZSk7XG4gICAgfSwgbmV3IE1hcCgpKTtcbn1cbi8qKlxuICogR2V0IHRoZSBhc3NvY2lhdGVkIGZtdHAgYXR0cmlidXRlcyBmb3IgdGhlIGdpdmVuIFBheWxvYWQgVHlwZSBpbiBhbiBtPSBzZWN0aW9uLlxuICogQHBhcmFtIHtQVH0gcHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZWRpYVNlY3Rpb25cbiAqIEByZXR1cm5zIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRGbXRwQXR0cmlidXRlc0ZvclB0KHB0LCBtZWRpYVNlY3Rpb24pIHtcbiAgICAvLyBJbiBcImE9Zm10cDo8cHQ+IDxuYW1lPj08dmFsdWU+Wzs8bmFtZT49PHZhbHVlPl0qXCIsIHRoZSByZWdleCBtYXRjaGVzIHRoZSBjb2RlY1xuICAgIC8vIHByb2ZpbGUgcGFyYW1ldGVycyBleHByZXNzZWQgYXMgbmFtZS92YWx1ZSBwYWlycyBzZXBhcmF0ZWQgYnkgXCI7XCIuXG4gICAgdmFyIGZtdHBSZWdleCA9IG5ldyBSZWdFeHAoXCJeYT1mbXRwOlwiICsgcHQgKyBcIiAoLispJFwiLCAnbScpO1xuICAgIHZhciBtYXRjaGVzID0gbWVkaWFTZWN0aW9uLm1hdGNoKGZtdHBSZWdleCk7XG4gICAgcmV0dXJuIG1hdGNoZXMgJiYgbWF0Y2hlc1sxXS5zcGxpdCgnOycpLnJlZHVjZShmdW5jdGlvbiAoYXR0cnMsIG52UGFpcikge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQobnZQYWlyLnNwbGl0KCc9JyksIDIpLCBuYW1lID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgIGF0dHJzW25hbWVdID0gaXNOYU4odmFsdWUpID8gdmFsdWUgOiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiBHZXQgdGhlIE1JRCBmb3IgdGhlIGdpdmVuIG09IHNlY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVkaWFTZWN0aW9uXG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRNaWRGb3JNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gICAgLy8gSW4gXCJhPW1pZDo8bWlkPlwiLCB0aGUgcmVnZXggbWF0Y2hlcyA8bWlkPi5cbiAgICB2YXIgbWlkTWF0Y2hlcyA9IG1lZGlhU2VjdGlvbi5tYXRjaCgvXmE9bWlkOiguKykkL20pO1xuICAgIHJldHVybiBtaWRNYXRjaGVzICYmIG1pZE1hdGNoZXNbMV07XG59XG4vKipcbiAqIEdldCB0aGUgbT0gc2VjdGlvbnMgb2YgYSBwYXJ0aWN1bGFyIGtpbmQgYW5kIGRpcmVjdGlvbiBmcm9tIGFuIHNkcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHAgLSBTRFAgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tpbmRdIC0gUGF0dGVybiBmb3IgbWF0Y2hpbmcga2luZFxuICogQHBhcmFtIHtzdHJpbmd9IFtkaXJlY3Rpb25dIC0gUGF0dGVybiBmb3IgbWF0Y2hpbmcgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gbWVkaWFTZWN0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRNZWRpYVNlY3Rpb25zKHNkcCwga2luZCwgZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHNkcC5yZXBsYWNlKC9cXHJcXG5cXHJcXG4kLywgJ1xcclxcbicpLnNwbGl0KCdcXHJcXG5tPScpLnNsaWNlKDEpLm1hcChmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7IHJldHVybiBcIm09XCIgKyBtZWRpYVNlY3Rpb247IH0pLmZpbHRlcihmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICAgIHZhciBraW5kUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJtPVwiICsgKGtpbmQgfHwgJy4qJyksICdnbScpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJhPVwiICsgKGRpcmVjdGlvbiB8fCAnLionKSwgJ2dtJyk7XG4gICAgICAgIHJldHVybiBraW5kUGF0dGVybi50ZXN0KG1lZGlhU2VjdGlvbikgJiYgZGlyZWN0aW9uUGF0dGVybi50ZXN0KG1lZGlhU2VjdGlvbik7XG4gICAgfSk7XG59XG4vKipcbiAqIEdldCB0aGUgQ29kZWMgUGF5bG9hZCBUeXBlcyBwcmVzZW50IGluIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBnaXZlbiBtPSBzZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VjdGlvbiAtIFRoZSBtPSBzZWN0aW9uXG4gKiBAcmV0dXJucyB7QXJyYXk8UFQ+fSBQYXlsb2FkIFR5cGVzXG4gKi9cbmZ1bmN0aW9uIGdldFBheWxvYWRUeXBlc0luTWVkaWFTZWN0aW9uKHNlY3Rpb24pIHtcbiAgICB2YXIgbUxpbmUgPSBzZWN0aW9uLnNwbGl0KCdcXHJcXG4nKVswXTtcbiAgICAvLyBJbiBcIm09PGtpbmQ+IDxwb3J0PiA8cHJvdG8+IDxwYXlsb2FkX3R5cGVfMT4gPHBheWxvYWRfdHlwZV8yPiAuLi4gPHBheWxvYWRfdHlwZV9uPlwiLFxuICAgIC8vIHRoZSByZWdleCBtYXRjaGVzIDxwb3J0PiBhbmQgdGhlIFBheWxvYWQgVHlwZXMuXG4gICAgdmFyIG1hdGNoZXMgPSBtTGluZS5tYXRjaCgvKFswLTldKykvZyk7XG4gICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgYnV0IGluIGNhc2UgdGhlcmUgYXJlIG5vIFBheWxvYWQgVHlwZXMgaW5cbiAgICAvLyB0aGUgbT0gbGluZSwgcmV0dXJuIGFuIGVtcHR5IGFycmF5LlxuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8vIFNpbmNlIG9ubHkgdGhlIFBheWxvYWQgVHlwZXMgYXJlIG5lZWRlZCwgd2UgZGlzY2FyZCB0aGUgPHBvcnQ+LlxuICAgIHJldHVybiBtYXRjaGVzLnNsaWNlKDEpLm1hcChmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIHBhcnNlSW50KG1hdGNoLCAxMCk7IH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIHJlb3JkZXJlZCBDb2RlYyBQYXlsb2FkIFR5cGVzIGJhc2VkIG9uIHRoZSBwcmVmZXJyZWQgQ29kZWMgTmFtZXMuXG4gKiBAcGFyYW0ge01hcDxDb2RlYywgQXJyYXk8UFQ+Pn0gY29kZWNNYXAgLSBDb2RlYyBNYXBcbiAqIEBwYXJhbSB7QXJyYXk8QXVkaW9Db2RlY1NldHRpbmdzfFZpZGVvQ29kZWNTZXR0aW5ncz59IHByZWZlcnJlZENvZGVjcyAtIFByZWZlcnJlZCBDb2RlY3NcbiAqIEByZXR1cm5zIHtBcnJheTxQVD59IFJlb3JkZXJlZCBQYXlsb2FkIFR5cGVzXG4gKi9cbmZ1bmN0aW9uIGdldFJlb3JkZXJlZFBheWxvYWRUeXBlcyhjb2RlY01hcCwgcHJlZmVycmVkQ29kZWNzKSB7XG4gICAgcHJlZmVycmVkQ29kZWNzID0gcHJlZmVycmVkQ29kZWNzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNvZGVjID0gX2EuY29kZWM7XG4gICAgICAgIHJldHVybiBjb2RlYy50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICAgIHZhciBwcmVmZXJyZWRQYXlsb2FkVHlwZXMgPSBmbGF0TWFwKHByZWZlcnJlZENvZGVjcywgZnVuY3Rpb24gKGNvZGVjTmFtZSkgeyByZXR1cm4gY29kZWNNYXAuZ2V0KGNvZGVjTmFtZSkgfHwgW107IH0pO1xuICAgIHZhciByZW1haW5pbmdDb2RlY3MgPSBkaWZmZXJlbmNlKEFycmF5LmZyb20oY29kZWNNYXAua2V5cygpKSwgcHJlZmVycmVkQ29kZWNzKTtcbiAgICB2YXIgcmVtYWluaW5nUGF5bG9hZFR5cGVzID0gZmxhdE1hcChyZW1haW5pbmdDb2RlY3MsIGZ1bmN0aW9uIChjb2RlY05hbWUpIHsgcmV0dXJuIGNvZGVjTWFwLmdldChjb2RlY05hbWUpOyB9KTtcbiAgICByZXR1cm4gcHJlZmVycmVkUGF5bG9hZFR5cGVzLmNvbmNhdChyZW1haW5pbmdQYXlsb2FkVHlwZXMpO1xufVxuLyoqXG4gKiBTZXQgdGhlIGdpdmVuIENvZGVjIFBheWxvYWQgVHlwZXMgaW4gdGhlIGZpcnN0IGxpbmUgb2YgdGhlIGdpdmVuIG09IHNlY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5PFBUPn0gcGF5bG9hZFR5cGVzIC0gUGF5bG9hZCBUeXBlc1xuICogQHBhcmFtIHtzdHJpbmd9IHNlY3Rpb24gLSBHaXZlbiBtPSBzZWN0aW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVwZGF0ZWQgbT0gc2VjdGlvblxuICovXG5mdW5jdGlvbiBzZXRQYXlsb2FkVHlwZXNJbk1lZGlhU2VjdGlvbihwYXlsb2FkVHlwZXMsIHNlY3Rpb24pIHtcbiAgICB2YXIgbGluZXMgPSBzZWN0aW9uLnNwbGl0KCdcXHJcXG4nKTtcbiAgICB2YXIgbUxpbmUgPSBsaW5lc1swXTtcbiAgICB2YXIgb3RoZXJMaW5lcyA9IGxpbmVzLnNsaWNlKDEpO1xuICAgIG1MaW5lID0gbUxpbmUucmVwbGFjZSgvKFswLTldK1xccz8pKyQvLCBwYXlsb2FkVHlwZXMuam9pbignICcpKTtcbiAgICByZXR1cm4gW21MaW5lXS5jb25jYXQob3RoZXJMaW5lcykuam9pbignXFxyXFxuJyk7XG59XG4vKipcbiAqIFJldHVybiBhIG5ldyBTRFAgc3RyaW5nIHdpdGggdGhlIHJlLW9yZGVyZWQgY29kZWMgcHJlZmVyZW5jZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwXG4gKiBAcGFyYW0ge0FycmF5PEF1ZGlvQ29kZWM+fSBwcmVmZXJyZWRBdWRpb0NvZGVjcyAtIElmIGVtcHR5LCB0aGUgZXhpc3Rpbmcgb3JkZXJcbiAqICAgb2YgYXVkaW8gY29kZWNzIGlzIHByZXNlcnZlZFxuICogQHBhcmFtIHtBcnJheTxWaWRlb0NvZGVjU2V0dGluZ3M+fSBwcmVmZXJyZWRWaWRlb0NvZGVjcyAtIElmIGVtcHR5LCB0aGVcbiAqICAgZXhpc3Rpbmcgb3JkZXIgb2YgdmlkZW8gY29kZWNzIGlzIHByZXNlcnZlZFxuICogQHJldHVybnMge3N0cmluZ30gVXBkYXRlZCBTRFAgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHNldENvZGVjUHJlZmVyZW5jZXMoc2RwLCBwcmVmZXJyZWRBdWRpb0NvZGVjcywgcHJlZmVycmVkVmlkZW9Db2RlY3MpIHtcbiAgICB2YXIgbWVkaWFTZWN0aW9ucyA9IGdldE1lZGlhU2VjdGlvbnMoc2RwKTtcbiAgICB2YXIgc2Vzc2lvbiA9IHNkcC5zcGxpdCgnXFxyXFxubT0nKVswXTtcbiAgICByZXR1cm4gW3Nlc3Npb25dLmNvbmNhdChtZWRpYVNlY3Rpb25zLm1hcChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICAvLyBDb2RlYyBwcmVmZXJlbmNlcyBzaG91bGQgbm90IGJlIGFwcGxpZWQgdG8gbT1hcHBsaWNhdGlvbiBzZWN0aW9ucy5cbiAgICAgICAgaWYgKCEvXm09KGF1ZGlvfHZpZGVvKS8udGVzdChzZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtpbmQgPSBzZWN0aW9uLm1hdGNoKC9ebT0oYXVkaW98dmlkZW8pLylbMV07XG4gICAgICAgIHZhciBjb2RlY01hcCA9IGNyZWF0ZUNvZGVjTWFwRm9yTWVkaWFTZWN0aW9uKHNlY3Rpb24pO1xuICAgICAgICB2YXIgcHJlZmVycmVkQ29kZWNzID0ga2luZCA9PT0gJ2F1ZGlvJyA/IHByZWZlcnJlZEF1ZGlvQ29kZWNzIDogcHJlZmVycmVkVmlkZW9Db2RlY3M7XG4gICAgICAgIHZhciBwYXlsb2FkVHlwZXMgPSBnZXRSZW9yZGVyZWRQYXlsb2FkVHlwZXMoY29kZWNNYXAsIHByZWZlcnJlZENvZGVjcyk7XG4gICAgICAgIHZhciBuZXdTZWN0aW9uID0gc2V0UGF5bG9hZFR5cGVzSW5NZWRpYVNlY3Rpb24ocGF5bG9hZFR5cGVzLCBzZWN0aW9uKTtcbiAgICAgICAgdmFyIHBjbWFQYXlsb2FkVHlwZXMgPSBjb2RlY01hcC5nZXQoJ3BjbWEnKSB8fCBbXTtcbiAgICAgICAgdmFyIHBjbXVQYXlsb2FkVHlwZXMgPSBjb2RlY01hcC5nZXQoJ3BjbXUnKSB8fCBbXTtcbiAgICAgICAgdmFyIGZpeGVkQml0cmF0ZVBheWxvYWRUeXBlcyA9IGtpbmQgPT09ICdhdWRpbydcbiAgICAgICAgICAgID8gbmV3IFNldChwY21hUGF5bG9hZFR5cGVzLmNvbmNhdChwY211UGF5bG9hZFR5cGVzKSlcbiAgICAgICAgICAgIDogbmV3IFNldCgpO1xuICAgICAgICByZXR1cm4gZml4ZWRCaXRyYXRlUGF5bG9hZFR5cGVzLmhhcyhwYXlsb2FkVHlwZXNbMF0pXG4gICAgICAgICAgICA/IG5ld1NlY3Rpb24ucmVwbGFjZSgvXFxyXFxuYj0oQVN8VElBUyk6KFswLTldKykvZywgJycpXG4gICAgICAgICAgICA6IG5ld1NlY3Rpb247XG4gICAgfSkpLmpvaW4oJ1xcclxcbicpO1xufVxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgU0RQIHN0cmluZyB3aXRoIHNpbXVsY2FzdCBzZXR0aW5ncy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHBcbiAqIEBwYXJhbSB7TWFwPFRyYWNrLklELCBUcmFja0F0dHJpYnV0ZXM+fSB0cmFja0lkc1RvQXR0cmlidXRlc1xuICogQHJldHVybnMge3N0cmluZ30gVXBkYXRlZCBTRFAgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHNldFNpbXVsY2FzdChzZHAsIHRyYWNrSWRzVG9BdHRyaWJ1dGVzKSB7XG4gICAgdmFyIG1lZGlhU2VjdGlvbnMgPSBnZXRNZWRpYVNlY3Rpb25zKHNkcCk7XG4gICAgdmFyIHNlc3Npb24gPSBzZHAuc3BsaXQoJ1xcclxcbm09JylbMF07XG4gICAgcmV0dXJuIFtzZXNzaW9uXS5jb25jYXQobWVkaWFTZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb24ucmVwbGFjZSgvXFxyXFxuJC8sICcnKTtcbiAgICAgICAgaWYgKCEvXm09dmlkZW8vLnRlc3Qoc2VjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2RlY01hcCA9IGNyZWF0ZUNvZGVjTWFwRm9yTWVkaWFTZWN0aW9uKHNlY3Rpb24pO1xuICAgICAgICB2YXIgcGF5bG9hZFR5cGVzID0gZ2V0UGF5bG9hZFR5cGVzSW5NZWRpYVNlY3Rpb24oc2VjdGlvbik7XG4gICAgICAgIHZhciB2cDhQYXlsb2FkVHlwZXMgPSBuZXcgU2V0KGNvZGVjTWFwLmdldCgndnA4JykgfHwgW10pO1xuICAgICAgICB2YXIgaGFzVlA4UGF5bG9hZFR5cGUgPSBwYXlsb2FkVHlwZXMuc29tZShmdW5jdGlvbiAocGF5bG9hZFR5cGUpIHsgcmV0dXJuIHZwOFBheWxvYWRUeXBlcy5oYXMocGF5bG9hZFR5cGUpOyB9KTtcbiAgICAgICAgcmV0dXJuIGhhc1ZQOFBheWxvYWRUeXBlXG4gICAgICAgICAgICA/IHNldFNpbXVsY2FzdEluTWVkaWFTZWN0aW9uKHNlY3Rpb24sIHRyYWNrSWRzVG9BdHRyaWJ1dGVzKVxuICAgICAgICAgICAgOiBzZWN0aW9uO1xuICAgIH0pKS5jb25jYXQoJycpLmpvaW4oJ1xcclxcbicpO1xufVxuLyoqXG4gKiBHZXQgdGhlIG1hdGNoaW5nIFBheWxvYWQgVHlwZXMgaW4gYW4gbT0gc2VjdGlvbiBmb3IgYSBwYXJ0aWN1bGFyIHBlZXIgY29kZWMuXG4gKiBAcGFyYW0ge0NvZGVjfSBwZWVyQ29kZWNcbiAqIEBwYXJhbSB7UFR9IHBlZXJQdFxuICogQHBhcmFtIHtNYXA8Q29kZWMsIFBUPn0gY29kZWNzVG9QdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGVlclNlY3Rpb25cbiAqIEByZXR1cm5zIHtBcnJheTxQVD59XG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoaW5nUGF5bG9hZFR5cGVzKHBlZXJDb2RlYywgcGVlclB0LCBjb2RlY3NUb1B0cywgc2VjdGlvbiwgcGVlclNlY3Rpb24pIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhdCBtb3N0IG9uZSBsb2NhbCBQYXlsb2FkIFR5cGUgdGhhdCBtYXRjaGVzIHRoZSByZW1vdGUgY29kZWMsIHJldGFpbiBpdC5cbiAgICB2YXIgbWF0Y2hpbmdQdHMgPSBjb2RlY3NUb1B0cy5nZXQocGVlckNvZGVjKSB8fCBbXTtcbiAgICBpZiAobWF0Y2hpbmdQdHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nUHRzO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZm10cCBhdHRyaWJ1dGVzIGZvciB0aGUgY29kZWMgaW4gdGhlIHBlZXIgbT0gc2VjdGlvbiwgdGhlbiB3ZVxuICAgIC8vIGNhbm5vdCBnZXQgYSBtYXRjaCBpbiB0aGUgIG09IHNlY3Rpb24uIEluIHRoYXQgY2FzZSwgcmV0YWluIGFsbCBtYXRjaGluZyBQYXlsb2FkXG4gICAgLy8gVHlwZXMuXG4gICAgdmFyIHBlZXJGbXRwQXR0cnMgPSBnZXRGbXRwQXR0cmlidXRlc0ZvclB0KHBlZXJQdCwgcGVlclNlY3Rpb24pO1xuICAgIGlmICghcGVlckZtdHBBdHRycykge1xuICAgICAgICByZXR1cm4gbWF0Y2hpbmdQdHM7XG4gICAgfVxuICAgIC8vIEFtb25nIHRoZSBtYXRjaGVkIGxvY2FsIFBheWxvYWQgVHlwZXMsIGZpbmQgdGhlIG9uZSB0aGF0IG1hdGNoZXMgdGhlIHJlbW90ZVxuICAgIC8vIGZtdHAgYXR0cmlidXRlcy5cbiAgICB2YXIgbWF0Y2hpbmdQdCA9IG1hdGNoaW5nUHRzLmZpbmQoZnVuY3Rpb24gKHB0KSB7XG4gICAgICAgIHZhciBmbXRwQXR0cnMgPSBnZXRGbXRwQXR0cmlidXRlc0ZvclB0KHB0LCBzZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGZtdHBBdHRycyAmJiBPYmplY3Qua2V5cyhwZWVyRm10cEF0dHJzKS5ldmVyeShmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIHBlZXJGbXRwQXR0cnNbYXR0cl0gPT09IGZtdHBBdHRyc1thdHRyXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gSWYgbm9uZSBvZiB0aGUgbWF0Y2hlZCBQYXlsb2FkIFR5cGVzIGFsc28gaGF2ZSBtYXRjaGluZyBmbXRwIGF0dHJpYnV0ZXMsXG4gICAgLy8gdGhlbiByZXRhaW4gYWxsIG9mIHRoZW0sIG90aGVyd2lzZSByZXRhaW4gb25seSB0aGUgUGF5bG9hZCBUeXBlIHRoYXRcbiAgICAvLyBtYXRjaGVzIHRoZSBwZWVyIGZtdHAgYXR0cmlidXRlcy5cbiAgICByZXR1cm4gdHlwZW9mIG1hdGNoaW5nUHQgPT09ICdudW1iZXInID8gW21hdGNoaW5nUHRdIDogbWF0Y2hpbmdQdHM7XG59XG4vKipcbiAqIEZpbHRlciBjb2RlY3MgaW4gYW4gbT0gc2VjdGlvbiBiYXNlZCBvbiBpdHMgcGVlciBtPSBzZWN0aW9uIGZyb20gdGhlIG90aGVyIHBlZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VjdGlvblxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBzdHJpbmc+fSBwZWVyTWlkc1RvTWVkaWFTZWN0aW9uc1xuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBjb2RlY3NUb1JlbW92ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmlsdGVyQ29kZWNzSW5NZWRpYVNlY3Rpb24oc2VjdGlvbiwgcGVlck1pZHNUb01lZGlhU2VjdGlvbnMsIGNvZGVjc1RvUmVtb3ZlKSB7XG4gICAgLy8gRG8gbm90aGluZyBpZiB0aGUgbT0gc2VjdGlvbiByZXByZXNlbnRzIG5laXRoZXIgYXVkaW8gbm9yIHZpZGVvLlxuICAgIGlmICghL15tPShhdWRpb3x2aWRlbykvLnRlc3Qoc2VjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgfVxuICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIG09IHNlY3Rpb24gZG9lcyBub3QgaGF2ZSBhbiBlcXVpdmFsZW50IHJlbW90ZSBtPSBzZWN0aW9uLlxuICAgIHZhciBtaWQgPSBnZXRNaWRGb3JNZWRpYVNlY3Rpb24oc2VjdGlvbik7XG4gICAgdmFyIHBlZXJTZWN0aW9uID0gbWlkICYmIHBlZXJNaWRzVG9NZWRpYVNlY3Rpb25zLmdldChtaWQpO1xuICAgIGlmICghcGVlclNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgfVxuICAgIC8vIENvbnN0cnVjdCBhIE1hcCBvZiB0aGUgcGVlciBQYXlsb2FkIFR5cGVzIHRvIHRoZWlyIGNvZGVjIG5hbWVzLlxuICAgIHZhciBwZWVyUHRUb0NvZGVjcyA9IGNyZWF0ZVB0VG9Db2RlY05hbWUocGVlclNlY3Rpb24pO1xuICAgIC8vIENvbnN0cnVjdCBhIE1hcCBvZiB0aGUgY29kZWMgbmFtZXMgdG8gdGhlaXIgUGF5bG9hZCBUeXBlcy5cbiAgICB2YXIgY29kZWNzVG9QdHMgPSBjcmVhdGVDb2RlY01hcEZvck1lZGlhU2VjdGlvbihzZWN0aW9uKTtcbiAgICAvLyBNYWludGFpbiBhIGxpc3Qgb2Ygbm9uLXJ0eCBQYXlsb2FkIFR5cGVzIHRvIHJldGFpbi5cbiAgICB2YXIgcHRzID0gZmxhdE1hcChBcnJheS5mcm9tKHBlZXJQdFRvQ29kZWNzKSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHBlZXJQdCA9IF9iWzBdLCBwZWVyQ29kZWMgPSBfYlsxXTtcbiAgICAgICAgcmV0dXJuIHBlZXJDb2RlYyAhPT0gJ3J0eCcgJiYgIWNvZGVjc1RvUmVtb3ZlLmluY2x1ZGVzKHBlZXJDb2RlYylcbiAgICAgICAgICAgID8gZ2V0TWF0Y2hpbmdQYXlsb2FkVHlwZXMocGVlckNvZGVjLCBwZWVyUHQsIGNvZGVjc1RvUHRzLCBzZWN0aW9uLCBwZWVyU2VjdGlvbilcbiAgICAgICAgICAgIDogW107XG4gICAgfSk7XG4gICAgLy8gRm9yIGVhY2ggUGF5bG9hZCBUeXBlIHRoYXQgd2lsbCBiZSByZXRhaW5lZCwgcmV0YWluIHRoZWlyIGNvcnJlc3BvbmRpbmcgcnR4XG4gICAgLy8gUGF5bG9hZCBUeXBlIGlmIHByZXNlbnQuXG4gICAgdmFyIHJ0eFB0cyA9IGNvZGVjc1RvUHRzLmdldCgncnR4JykgfHwgW107XG4gICAgLy8gSW4gXCJhPWZtdHA6PHJ0eFB0PiBhcHQ9PGFwdD5cIiwgZXh0cmFjdCB0aGUgY29kZWMgUFQgPGFwdD4gYXNzb2NpYXRlZCB3aXRoIHJ0eFB0LlxuICAgIHB0cyA9IHB0cy5jb25jYXQocnR4UHRzLmZpbHRlcihmdW5jdGlvbiAocnR4UHQpIHtcbiAgICAgICAgdmFyIGZtdHBBdHRycyA9IGdldEZtdHBBdHRyaWJ1dGVzRm9yUHQocnR4UHQsIHNlY3Rpb24pO1xuICAgICAgICByZXR1cm4gZm10cEF0dHJzICYmIHB0cy5pbmNsdWRlcyhmbXRwQXR0cnMuYXB0KTtcbiAgICB9KSk7XG4gICAgLy8gRmlsdGVyIG91dCB0aGUgYmVsb3cgbWVudGlvbmVkIGF0dHJpYnV0ZSBsaW5lcyBpbiB0aGUgbT0gc2VjdGlvbiB0aGF0IGRvIG5vdFxuICAgIC8vIGJlbG9uZyB0byBvbmUgb2YgdGhlIFBheWxvYWQgVHlwZXMgdGhhdCBhcmUgdG8gYmUgcmV0YWluZWQuXG4gICAgLy8gMS4gXCJhPXJ0cG1hcDo8cHQ+IDxjb2RlYz5cIlxuICAgIC8vIDIuIFwiYT1ydGNwLWZiOjxwdD4gPGF0dHI+WyA8YXR0cj5dKlwiXG4gICAgLy8gMy4gXCJhPWZtdHA6PHB0PiA8bmFtZT49PHZhbHVlPls7PG5hbWU+PTx2YWx1ZT5dKlwiXG4gICAgdmFyIGxpbmVzID0gc2VjdGlvbi5zcGxpdCgnXFxyXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBwdE1hdGNoZXMgPSBsaW5lLm1hdGNoKC9eYT0ocnRwbWFwfGZtdHB8cnRjcC1mYik6KC4rKSAuKyQvKTtcbiAgICAgICAgdmFyIHB0ID0gcHRNYXRjaGVzICYmIHB0TWF0Y2hlc1syXTtcbiAgICAgICAgcmV0dXJuICFwdE1hdGNoZXMgfHwgKHB0ICYmIHB0cy5pbmNsdWRlcyhwYXJzZUludChwdCwgMTApKSk7XG4gICAgfSk7XG4gICAgLy8gRmlsdGVyIHRoZSBsaXN0IG9mIFBheWxvYWQgVHlwZXMgaW4gdGhlIGZpcnN0IGxpbmUgb2YgdGhlIG09IHNlY3Rpb24uXG4gICAgdmFyIG9yZGVyZWRQdHMgPSBnZXRQYXlsb2FkVHlwZXNJbk1lZGlhU2VjdGlvbihzZWN0aW9uKS5maWx0ZXIoZnVuY3Rpb24gKHB0KSB7IHJldHVybiBwdHMuaW5jbHVkZXMocHQpOyB9KTtcbiAgICByZXR1cm4gc2V0UGF5bG9hZFR5cGVzSW5NZWRpYVNlY3Rpb24ob3JkZXJlZFB0cywgbGluZXMuam9pbignXFxyXFxuJykpO1xufVxuLyoqXG4gKiBGaWx0ZXIgbG9jYWwgY29kZWNzIGJhc2VkIG9uIHRoZSByZW1vdGUgU0RQLlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsU2RwXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlU2RwXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVwZGF0ZWQgbG9jYWwgU0RQXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckxvY2FsQ29kZWNzKGxvY2FsU2RwLCByZW1vdGVTZHApIHtcbiAgICB2YXIgbG9jYWxNZWRpYVNlY3Rpb25zID0gZ2V0TWVkaWFTZWN0aW9ucyhsb2NhbFNkcCk7XG4gICAgdmFyIGxvY2FsU2Vzc2lvbiA9IGxvY2FsU2RwLnNwbGl0KCdcXHJcXG5tPScpWzBdO1xuICAgIHZhciByZW1vdGVNaWRzVG9NZWRpYVNlY3Rpb25zID0gY3JlYXRlTWlkVG9NZWRpYVNlY3Rpb25NYXAocmVtb3RlU2RwKTtcbiAgICByZXR1cm4gW2xvY2FsU2Vzc2lvbl0uY29uY2F0KGxvY2FsTWVkaWFTZWN0aW9ucy5tYXAoZnVuY3Rpb24gKGxvY2FsU2VjdGlvbikge1xuICAgICAgICByZXR1cm4gZmlsdGVyQ29kZWNzSW5NZWRpYVNlY3Rpb24obG9jYWxTZWN0aW9uLCByZW1vdGVNaWRzVG9NZWRpYVNlY3Rpb25zLCBbXSk7XG4gICAgfSkpLmpvaW4oJ1xcclxcbicpO1xufVxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgU0RQIHN0cmluZyBhZnRlciByZXZlcnRpbmcgc2ltdWxjYXN0IGZvciBub24gdnA4IHNlY3Rpb25zIGluIHJlbW90ZSBzZHAuXG4gKiBAcGFyYW0gbG9jYWxTZHAgLSBzaW11bGNhc3QgZW5hYmxlZCBsb2NhbCBzZHBcbiAqIEBwYXJhbSBsb2NhbFNkcFdpdGhvdXRTaW11bGNhc3QgLSBsb2NhbCBzZHAgYmVmb3JlIHNpbXVsY2FzdCB3YXMgc2V0XG4gKiBAcGFyYW0gcmVtb3RlU2RwIC0gcmVtb3RlIHNkcFxuICogQHBhcmFtIHJldmVydEZvckFsbCAtIHdoZW4gdHJ1ZSBzaW11bGNhc3Qgd2lsbCBiZSByZXZlcnRlZCBmb3IgYWxsIGNvZGVjcy4gd2hlbiBmYWxzZSBpdCB3aWxsIGJlIHJldmVydGVkXG4gKiAgb25seSBmb3Igbm9uLXZwOCBjb2RlY3MuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFVwZGF0ZWQgU0RQIHN0cmluZ1xuICovXG5mdW5jdGlvbiByZXZlcnRTaW11bGNhc3QobG9jYWxTZHAsIGxvY2FsU2RwV2l0aG91dFNpbXVsY2FzdCwgcmVtb3RlU2RwLCByZXZlcnRGb3JBbGwpIHtcbiAgICBpZiAocmV2ZXJ0Rm9yQWxsID09PSB2b2lkIDApIHsgcmV2ZXJ0Rm9yQWxsID0gZmFsc2U7IH1cbiAgICB2YXIgcmVtb3RlTWlkVG9NZWRpYVNlY3Rpb25zID0gY3JlYXRlTWlkVG9NZWRpYVNlY3Rpb25NYXAocmVtb3RlU2RwKTtcbiAgICB2YXIgbG9jYWxNaWRUb01lZGlhU2VjdGlvbnNXaXRob3V0U2ltdWxjYXN0ID0gY3JlYXRlTWlkVG9NZWRpYVNlY3Rpb25NYXAobG9jYWxTZHBXaXRob3V0U2ltdWxjYXN0KTtcbiAgICB2YXIgbWVkaWFTZWN0aW9ucyA9IGdldE1lZGlhU2VjdGlvbnMobG9jYWxTZHApO1xuICAgIHZhciBzZXNzaW9uID0gbG9jYWxTZHAuc3BsaXQoJ1xcclxcbm09JylbMF07XG4gICAgcmV0dXJuIFtzZXNzaW9uXS5jb25jYXQobWVkaWFTZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb24ucmVwbGFjZSgvXFxyXFxuJC8sICcnKTtcbiAgICAgICAgaWYgKCEvXm09dmlkZW8vLnRlc3Qoc2VjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaWRNYXRjaGVzID0gc2VjdGlvbi5tYXRjaCgvXmE9bWlkOiguKykkL20pO1xuICAgICAgICB2YXIgbWlkID0gbWlkTWF0Y2hlcyAmJiBtaWRNYXRjaGVzWzFdO1xuICAgICAgICBpZiAoIW1pZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbW90ZVNlY3Rpb24gPSByZW1vdGVNaWRUb01lZGlhU2VjdGlvbnMuZ2V0KG1pZCk7XG4gICAgICAgIHZhciByZW1vdGVQdFRvQ29kZWNzID0gY3JlYXRlUHRUb0NvZGVjTmFtZShyZW1vdGVTZWN0aW9uKTtcbiAgICAgICAgdmFyIHJlbW90ZVBheWxvYWRUeXBlcyA9IGdldFBheWxvYWRUeXBlc0luTWVkaWFTZWN0aW9uKHJlbW90ZVNlY3Rpb24pO1xuICAgICAgICB2YXIgaXNWUDhUaGVQcmVmZXJyZWRDb2RlYyA9IHJlbW90ZVBheWxvYWRUeXBlcy5sZW5ndGggJiYgcmVtb3RlUHRUb0NvZGVjcy5nZXQocmVtb3RlUGF5bG9hZFR5cGVzWzBdKSA9PT0gJ3ZwOCc7XG4gICAgICAgIHZhciBzaG91bGRSZXZlcnRTaW11bGNhc3QgPSByZXZlcnRGb3JBbGwgfHwgIWlzVlA4VGhlUHJlZmVycmVkQ29kZWM7XG4gICAgICAgIHJldHVybiBzaG91bGRSZXZlcnRTaW11bGNhc3QgPyBsb2NhbE1pZFRvTWVkaWFTZWN0aW9uc1dpdGhvdXRTaW11bGNhc3QuZ2V0KG1pZCkucmVwbGFjZSgvXFxyXFxuJC8sICcnKSA6IHNlY3Rpb247XG4gICAgfSkpLmNvbmNhdCgnJykuam9pbignXFxyXFxuJyk7XG59XG4vKipcbiAqIEFkZCBvciByZXdyaXRlIE1TSURzIGZvciBuZXcgbT0gc2VjdGlvbnMgaW4gdGhlIGdpdmVuIFNEUCB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIGxvY2FsIE1lZGlhU3RyZWFtVHJhY2sgSURzLiBUaGVzZSBjYW4gYmUgZGlmZmVyZW50IHdoZW4gcHJldmlvdXNseSByZW1vdmVkIE1lZGlhU3RyZWFtVHJhY2tzXG4gKiBhcmUgYWRkZWQgYmFjayAob3IgVHJhY2sgSURzIG1heSBub3QgYmUgcHJlc2VudCBpbiB0aGUgU0RQcyBhdCBhbGwgb25jZSBicm93c2VycyBpbXBsZW1lbnRcbiAqIHRoZSBsYXRlc3QgV2ViUlRDIHNwZWMpLlxuICogQHBhcmFtIHtzdHJpbmd9IHNkcFxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBUcmFjay5JRD59IGFjdGl2ZU1pZHNUb1RyYWNrSWRzXG4gKiBAcGFyYW0ge01hcDxUcmFjay5LaW5kLCBBcnJheTxUcmFjay5JRD4+fSB0cmFja0lkc0J5S2luZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gYWRkT3JSZXdyaXRlTmV3VHJhY2tJZHMoc2RwLCBhY3RpdmVNaWRzVG9UcmFja0lkcywgdHJhY2tJZHNCeUtpbmQpIHtcbiAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBUaGUgbT0gc2VjdGlvbnMgZm9yIHRoZSBuZXcgTWVkaWFTdHJlYW1UcmFja3MgYXJlIHVzdWFsbHlcbiAgICAvLyBwcmVzZW50IGFmdGVyIHRoZSBtPSBzZWN0aW9ucyBmb3IgdGhlIGV4aXN0aW5nIE1lZGlhU3RyZWFtVHJhY2tzLCBpbiBvcmRlclxuICAgIC8vIG9mIGFkZGl0aW9uLlxuICAgIHZhciBuZXdNaWRzVG9UcmFja0lkcyA9IEFycmF5LmZyb20odHJhY2tJZHNCeUtpbmQpLnJlZHVjZShmdW5jdGlvbiAobWlkc1RvVHJhY2tJZHMsIF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIGtpbmQgPSBfYlswXSwgdHJhY2tJZHMgPSBfYlsxXTtcbiAgICAgICAgdmFyIG1lZGlhU2VjdGlvbnMgPSBnZXRNZWRpYVNlY3Rpb25zKHNkcCwga2luZCwgJ3NlbmQob25seXxyZWN2KScpO1xuICAgICAgICB2YXIgbmV3TWlkcyA9IG1lZGlhU2VjdGlvbnMubWFwKGdldE1pZEZvck1lZGlhU2VjdGlvbikuZmlsdGVyKGZ1bmN0aW9uIChtaWQpIHsgcmV0dXJuICFhY3RpdmVNaWRzVG9UcmFja0lkcy5oYXMobWlkKTsgfSk7XG4gICAgICAgIG5ld01pZHMuZm9yRWFjaChmdW5jdGlvbiAobWlkLCBpKSB7IHJldHVybiBtaWRzVG9UcmFja0lkcy5zZXQobWlkLCB0cmFja0lkc1tpXSk7IH0pO1xuICAgICAgICByZXR1cm4gbWlkc1RvVHJhY2tJZHM7XG4gICAgfSwgbmV3IE1hcCgpKTtcbiAgICByZXR1cm4gYWRkT3JSZXdyaXRlVHJhY2tJZHMoc2RwLCBuZXdNaWRzVG9UcmFja0lkcyk7XG59XG4vKipcbiAqIEFkZCBvciByZXdyaXRlIE1TSURzIGluIHRoZSBnaXZlbiBTRFAgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIGxvY2FsIE1lZGlhU3RyZWFtVHJhY2sgSURzLlxuICogVGhlc2UgSURzIG5lZWQgbm90IGJlIHRoZSBzYW1lIChvciBUcmFjayBJRHMgbWF5IG5vdCBiZSBwcmVzZW50IGluIHRoZSBTRFBzIGF0IGFsbCBvbmNlXG4gKiBicm93c2VycyBpbXBsZW1lbnQgdGhlIGxhdGVzdCBXZWJSVEMgc3BlYykuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsIFRyYWNrLklEPn0gbWlkc1RvVHJhY2tJZHNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGFkZE9yUmV3cml0ZVRyYWNrSWRzKHNkcCwgbWlkc1RvVHJhY2tJZHMpIHtcbiAgICB2YXIgbWVkaWFTZWN0aW9ucyA9IGdldE1lZGlhU2VjdGlvbnMoc2RwKTtcbiAgICB2YXIgc2Vzc2lvbiA9IHNkcC5zcGxpdCgnXFxyXFxubT0nKVswXTtcbiAgICByZXR1cm4gW3Nlc3Npb25dLmNvbmNhdChtZWRpYVNlY3Rpb25zLm1hcChmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIG09IHNlY3Rpb24gcmVwcmVzZW50cyBuZWl0aGVyIGF1ZGlvIG5vciB2aWRlby5cbiAgICAgICAgaWYgKCEvXm09KGF1ZGlvfHZpZGVvKS8udGVzdChtZWRpYVNlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVkaWFTZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiwgYnV0IGluIGNhc2UgdGhlcmUgaXMgbm8gTUlEIGZvciB0aGUgbT0gc2VjdGlvbiwgZG8gbm90aGluZy5cbiAgICAgICAgdmFyIG1pZCA9IGdldE1pZEZvck1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24pO1xuICAgICAgICBpZiAoIW1pZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lZGlhU2VjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIFRyYWNrIElEIGZvciB0aGUgZ2l2ZW4gTUlEIGluIHRoZSBtYXAsIGRvIG5vdGhpbmcuXG4gICAgICAgIHZhciB0cmFja0lkID0gbWlkc1RvVHJhY2tJZHMuZ2V0KG1pZCk7XG4gICAgICAgIGlmICghdHJhY2tJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lZGlhU2VjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4sIGJ1dCBpbiBjYXNlIHRoZXJlIGlzIG5vIGE9bXNpZDogbGluZSwgZG8gbm90aGluZy5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSAobWVkaWFTZWN0aW9uLm1hdGNoKC9eYT1tc2lkOiguKykkL20pIHx8IFtdKVsxXTtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVkaWFTZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBhPW1zaWQ6IGxpbmUgY29udGFpbnMgdGhlIFwiYXBwZGF0YVwiIGZpZWxkLCB0aGVuIHJlcGxhY2UgaXQgd2l0aCB0aGUgVHJhY2sgSUQsXG4gICAgICAgIC8vIG90aGVyd2lzZSBhcHBlbmQgdGhlIFRyYWNrIElELlxuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoYXR0cmlidXRlcy5zcGxpdCgnICcpLCAyKSwgbXNpZCA9IF9hWzBdLCB0cmFja0lkVG9SZXdyaXRlID0gX2FbMV07XG4gICAgICAgIHZhciBtc2lkUmVnZXggPSBuZXcgUmVnRXhwKFwibXNpZDpcIiArIG1zaWQgKyAodHJhY2tJZFRvUmV3cml0ZSA/IFwiIFwiICsgdHJhY2tJZFRvUmV3cml0ZSA6ICcnKSArIFwiJFwiLCAnZ20nKTtcbiAgICAgICAgcmV0dXJuIG1lZGlhU2VjdGlvbi5yZXBsYWNlKG1zaWRSZWdleCwgXCJtc2lkOlwiICsgbXNpZCArIFwiIFwiICsgdHJhY2tJZCk7XG4gICAgfSkpLmpvaW4oJ1xcclxcbicpO1xufVxuLyoqXG4gKiBSZW1vdmVzIHNwZWNpZmllZCBzc3JjIGF0dHJpYnV0ZXMgZnJvbSBnaXZlbiBzZHAuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHNzcmNBdHRyaWJ1dGVzVG9SZW1vdmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVNTUkNBdHRyaWJ1dGVzKHNkcCwgc3NyY0F0dHJpYnV0ZXNUb1JlbW92ZSkge1xuICAgIHJldHVybiBzZHAuc3BsaXQoJ1xcclxcbicpLmZpbHRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgICByZXR1cm4gIXNzcmNBdHRyaWJ1dGVzVG9SZW1vdmUuZmluZChmdW5jdGlvbiAoc3JjQXR0cmlidXRlKSB7IHJldHVybiBuZXcgUmVnRXhwKCdhPXNzcmM6LionICsgc3JjQXR0cmlidXRlICsgJzonLCAnZycpLnRlc3QobGluZSk7IH0pO1xuICAgIH0pLmpvaW4oJ1xcclxcbicpO1xufVxuLyoqXG4gKiBEaXNhYmxlIFJUWCBpbiBhIGdpdmVuIHNkcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHBcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHNkcCB3aXRob3V0IFJUWFxuICovXG5mdW5jdGlvbiBkaXNhYmxlUnR4KHNkcCkge1xuICAgIHZhciBtZWRpYVNlY3Rpb25zID0gZ2V0TWVkaWFTZWN0aW9ucyhzZHApO1xuICAgIHZhciBzZXNzaW9uID0gc2RwLnNwbGl0KCdcXHJcXG5tPScpWzBdO1xuICAgIHJldHVybiBbc2Vzc2lvbl0uY29uY2F0KG1lZGlhU2VjdGlvbnMubWFwKGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgbT0gc2VjdGlvbiBkb2VzIG5vdCByZXByZXNlbnQgYSB2aWRlbyB0cmFjay5cbiAgICAgICAgaWYgKCEvXm09dmlkZW8vLnRlc3QobWVkaWFTZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lZGlhU2VjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBtYXAgb2YgY29kZWNzIHRvIHBheWxvYWQgdHlwZXMuXG4gICAgICAgIHZhciBjb2RlY3NUb1B0cyA9IGNyZWF0ZUNvZGVjTWFwRm9yTWVkaWFTZWN0aW9uKG1lZGlhU2VjdGlvbik7XG4gICAgICAgIC8vIEdldCB0aGUgUlRYIHBheWxvYWQgdHlwZXMuXG4gICAgICAgIHZhciBydHhQdHMgPSBjb2RlY3NUb1B0cy5nZXQoJ3J0eCcpO1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZXJlIGFyZSBubyBSVFggcGF5bG9hZCB0eXBlcy5cbiAgICAgICAgaWYgKCFydHhQdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBtZWRpYVNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBSVFggcGF5bG9hZCB0eXBlcy5cbiAgICAgICAgdmFyIHB0cyA9IG5ldyBTZXQoZ2V0UGF5bG9hZFR5cGVzSW5NZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKSk7XG4gICAgICAgIHJ0eFB0cy5mb3JFYWNoKGZ1bmN0aW9uIChydHhQdCkgeyByZXR1cm4gcHRzLmRlbGV0ZShydHhQdCk7IH0pO1xuICAgICAgICAvLyBHZXQgdGhlIFJUWCBTU1JDLlxuICAgICAgICB2YXIgcnR4U1NSQ01hdGNoZXMgPSBtZWRpYVNlY3Rpb24ubWF0Y2goL2E9c3NyYy1ncm91cDpGSUQgWzAtOV0rIChbMC05XSspLyk7XG4gICAgICAgIHZhciBydHhTU1JDID0gcnR4U1NSQ01hdGNoZXMgJiYgcnR4U1NSQ01hdGNoZXNbMV07XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZm9sbG93aW5nIGxpbmVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgUlRYIHBheWxvYWQgdHlwZXM6XG4gICAgICAgIC8vIDEuIFwiYT1mbXRwOjxydHhQdD4gYXB0PTxwdD5cIlxuICAgICAgICAvLyAyLiBcImE9cnRwbWFwOjxydHhQdD4gcnR4Ly4uLlwiXG4gICAgICAgIC8vIDMuIFwiYT1zc3JjOjxydHhTU1JDPiBjbmFtZTouLi5cIlxuICAgICAgICAvLyA0LiBcImE9c3NyYy1ncm91cDpGSUQgPFNTUkM+IDxydHhTU1JDPlwiXG4gICAgICAgIHZhciBmaWx0ZXJSZWdleGVzID0gW1xuICAgICAgICAgICAgL15hPWZtdHA6LisgYXB0PS4rJC8sXG4gICAgICAgICAgICAvXmE9cnRwbWFwOi4rIHJ0eFxcLy4rJC8sXG4gICAgICAgICAgICAvXmE9c3NyYy1ncm91cDouKyQvXG4gICAgICAgIF0uY29uY2F0KHJ0eFNTUkNcbiAgICAgICAgICAgID8gW25ldyBSZWdFeHAoXCJeYT1zc3JjOlwiICsgcnR4U1NSQyArIFwiIC4rJFwiKV1cbiAgICAgICAgICAgIDogW10pO1xuICAgICAgICBtZWRpYVNlY3Rpb24gPSBtZWRpYVNlY3Rpb24uc3BsaXQoJ1xcclxcbicpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7IHJldHVybiBmaWx0ZXJSZWdleGVzLmV2ZXJ5KGZ1bmN0aW9uIChyZWdleCkgeyByZXR1cm4gIXJlZ2V4LnRlc3QobGluZSk7IH0pOyB9KVxuICAgICAgICAgICAgLmpvaW4oJ1xcclxcbicpO1xuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgbT0gc2VjdGlvbiB3aXRob3V0IHRoZSBSVFggcGF5bG9hZCB0eXBlcy5cbiAgICAgICAgcmV0dXJuIHNldFBheWxvYWRUeXBlc0luTWVkaWFTZWN0aW9uKEFycmF5LmZyb20ocHRzKSwgbWVkaWFTZWN0aW9uKTtcbiAgICB9KSkuam9pbignXFxyXFxuJyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGFuIGE9Zm10cDogbGluZSBmcm9tIHRoZSBnaXZlbiBwYXlsb2FkIHR5cGUgYW5kIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge1BUfSBwdFxuICogQHBhcmFtIHsqfSBmbXRwQXR0cnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlRm10cExpbmVGcm9tUHRBbmRBdHRyaWJ1dGVzKHB0LCBmbXRwQXR0cnMpIHtcbiAgICB2YXIgc2VyaWFsaXplZEZtdHBBdHRycyA9IE9iamVjdC5lbnRyaWVzKGZtdHBBdHRycykubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBuYW1lID0gX2JbMF0sIHZhbHVlID0gX2JbMV07XG4gICAgICAgIHJldHVybiBuYW1lICsgXCI9XCIgKyB2YWx1ZTtcbiAgICB9KS5qb2luKCc7Jyk7XG4gICAgcmV0dXJuIFwiYT1mbXRwOlwiICsgcHQgKyBcIiBcIiArIHNlcmlhbGl6ZWRGbXRwQXR0cnM7XG59XG4vKipcbiAqIEVuYWJsZSBEVFggZm9yIG9wdXMgaW4gdGhlIG09IHNlY3Rpb25zIGZvciB0aGUgZ2l2ZW4gTUlEcy5gXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFttaWRzXSAtIElmIG5vdCBzcGVjaWZpZWQsIGVuYWJsZXMgb3B1cyBEVFggZm9yIGFsbFxuICogICBhdWRpbyBtPSBsaW5lcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUR0eEZvck9wdXMoc2RwLCBtaWRzKSB7XG4gICAgdmFyIG1lZGlhU2VjdGlvbnMgPSBnZXRNZWRpYVNlY3Rpb25zKHNkcCk7XG4gICAgdmFyIHNlc3Npb24gPSBzZHAuc3BsaXQoJ1xcclxcbm09JylbMF07XG4gICAgbWlkcyA9IG1pZHMgfHwgbWVkaWFTZWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzZWN0aW9uKSB7IHJldHVybiAvXm09YXVkaW8vLnRlc3Qoc2VjdGlvbik7IH0pXG4gICAgICAgIC5tYXAoZ2V0TWlkRm9yTWVkaWFTZWN0aW9uKTtcbiAgICByZXR1cm4gW3Nlc3Npb25dLmNvbmNhdChtZWRpYVNlY3Rpb25zLm1hcChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSBtPSBzZWN0aW9uIGlzIG5vdCBhdWRpby5cbiAgICAgICAgaWYgKCEvXm09YXVkaW8vLnRlc3Qoc2VjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIGEgbWFwIGNvZGVjcyB0byBwYXlsb2FkIHR5cGVzLlxuICAgICAgICB2YXIgY29kZWNzVG9QdHMgPSBjcmVhdGVDb2RlY01hcEZvck1lZGlhU2VjdGlvbihzZWN0aW9uKTtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBhIHBheWxvYWQgdHlwZSBmb3Igb3B1cyBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgdmFyIG9wdXNQdCA9IGNvZGVjc1RvUHRzLmdldCgnb3B1cycpO1xuICAgICAgICBpZiAoIW9wdXNQdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gZm10cCBhdHRyaWJ1dGVzIGFyZSBmb3VuZCBmb3Igb3B1cywgZG8gbm90aGluZy5cbiAgICAgICAgdmFyIG9wdXNGbXRwQXR0cnMgPSBnZXRGbXRwQXR0cmlidXRlc0ZvclB0KG9wdXNQdCwgc2VjdGlvbik7XG4gICAgICAgIGlmICghb3B1c0ZtdHBBdHRycykge1xuICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHVzZWR0eD0xIHRvIHRoZSBhPWZtdHA6IGxpbmUgZm9yIG9wdXMuXG4gICAgICAgIHZhciBvcmlnT3B1c0ZtdHBMaW5lID0gZ2VuZXJhdGVGbXRwTGluZUZyb21QdEFuZEF0dHJpYnV0ZXMob3B1c1B0LCBvcHVzRm10cEF0dHJzKTtcbiAgICAgICAgdmFyIG9yaWdPcHVzRm10cFJlZ2V4ID0gbmV3IFJlZ0V4cChvcmlnT3B1c0ZtdHBMaW5lKTtcbiAgICAgICAgLy8gSWYgdGhlIG09IHNlY3Rpb24ncyBNSUQgaXMgaW4gdGhlIGxpc3Qgb2YgTUlEcywgdGhlbiBlbmFibGUgZHR4LiBPdGhlcndpc2UgZGlzYWJsZSBpdC5cbiAgICAgICAgdmFyIG1pZCA9IGdldE1pZEZvck1lZGlhU2VjdGlvbihzZWN0aW9uKTtcbiAgICAgICAgaWYgKG1pZHMuaW5jbHVkZXMobWlkKSkge1xuICAgICAgICAgICAgb3B1c0ZtdHBBdHRycy51c2VkdHggPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG9wdXNGbXRwQXR0cnMudXNlZHR4O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHVzRm10cExpbmVXaXRoRHR4ID0gZ2VuZXJhdGVGbXRwTGluZUZyb21QdEFuZEF0dHJpYnV0ZXMob3B1c1B0LCBvcHVzRm10cEF0dHJzKTtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb24ucmVwbGFjZShvcmlnT3B1c0ZtdHBSZWdleCwgb3B1c0ZtdHBMaW5lV2l0aER0eCk7XG4gICAgfSkpLmpvaW4oJ1xcclxcbicpO1xufVxuZXhwb3J0cy5hZGRPclJld3JpdGVOZXdUcmFja0lkcyA9IGFkZE9yUmV3cml0ZU5ld1RyYWNrSWRzO1xuZXhwb3J0cy5hZGRPclJld3JpdGVUcmFja0lkcyA9IGFkZE9yUmV3cml0ZVRyYWNrSWRzO1xuZXhwb3J0cy5jcmVhdGVDb2RlY01hcEZvck1lZGlhU2VjdGlvbiA9IGNyZWF0ZUNvZGVjTWFwRm9yTWVkaWFTZWN0aW9uO1xuZXhwb3J0cy5jcmVhdGVQdFRvQ29kZWNOYW1lID0gY3JlYXRlUHRUb0NvZGVjTmFtZTtcbmV4cG9ydHMuZGlzYWJsZVJ0eCA9IGRpc2FibGVSdHg7XG5leHBvcnRzLmVuYWJsZUR0eEZvck9wdXMgPSBlbmFibGVEdHhGb3JPcHVzO1xuZXhwb3J0cy5maWx0ZXJMb2NhbENvZGVjcyA9IGZpbHRlckxvY2FsQ29kZWNzO1xuZXhwb3J0cy5nZXRNZWRpYVNlY3Rpb25zID0gZ2V0TWVkaWFTZWN0aW9ucztcbmV4cG9ydHMucmVtb3ZlU1NSQ0F0dHJpYnV0ZXMgPSByZW1vdmVTU1JDQXR0cmlidXRlcztcbmV4cG9ydHMucmV2ZXJ0U2ltdWxjYXN0ID0gcmV2ZXJ0U2ltdWxjYXN0O1xuZXhwb3J0cy5zZXRDb2RlY1ByZWZlcmVuY2VzID0gc2V0Q29kZWNQcmVmZXJlbmNlcztcbmV4cG9ydHMuc2V0U2ltdWxjYXN0ID0gc2V0U2ltdWxjYXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3dlYnJ0YycpLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbjtcbnZhciBfYSA9IHJlcXVpcmUoJy4vJyksIGNyZWF0ZVB0VG9Db2RlY05hbWUgPSBfYS5jcmVhdGVQdFRvQ29kZWNOYW1lLCBnZXRNZWRpYVNlY3Rpb25zID0gX2EuZ2V0TWVkaWFTZWN0aW9ucztcbi8qKlxuICogQW4gUlRYIHBheWxvYWQgdHlwZVxuICogQHR5cGVkZWYge1BUfSBSdHhQVFxuICovXG4vKipcbiAqIEEgbm9uLVJUWCBwYXlsb2FkIHR5cGVcbiAqIEB0eXBlZGVmIHtQVH0gTm9uUnR4UFRcbiAqL1xuLyoqXG4gKiBBIFNldCB3aXRoIGF0IGxlYXN0IG9uZSBlbGVtZW50XG4gKiBAdHlwZWRlZiB7U2V0fSBOb25FbXB0eVNldFxuICovXG4vKipcbiAqIEFwcGx5IHRoZSB3b3JrYXJvdW5kIGZvciBJc3N1ZSA4MzI5IHRvIGFuIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQuXG4gKiBAcGFyYW0ge1JUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXR9IGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7UlRDU2Vzc2lvbkRlc2NyaXB0aW9ufSBuZXdEZXNjcmlwdGlvblxuICovXG5mdW5jdGlvbiB3b3JrYXJvdW5kKGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uSW5pdCA9IHsgdHlwZTogZGVzY3JpcHRpb24udHlwZSB9O1xuICAgIGlmIChkZXNjcmlwdGlvbi50eXBlICE9PSAncm9sbGJhY2snKSB7XG4gICAgICAgIGRlc2NyaXB0aW9uSW5pdC5zZHAgPSBzZHBXb3JrYXJvdW5kKGRlc2NyaXB0aW9uLnNkcCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uSW5pdCk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHBcbiAqIEByZXR1cm5zIHtzdHJpbmd9IG5ld1NkcFxuICovXG5mdW5jdGlvbiBzZHBXb3JrYXJvdW5kKHNkcCkge1xuICAgIHZhciBtZWRpYVNlY3Rpb25zID0gZ2V0TWVkaWFTZWN0aW9ucyhzZHApO1xuICAgIHZhciBzZXNzaW9uID0gc2RwLnNwbGl0KCdcXHJcXG5tPScpWzBdO1xuICAgIHJldHVybiBbc2Vzc2lvbl1cbiAgICAgICAgLmNvbmNhdChtZWRpYVNlY3Rpb25zLm1hcChtZWRpYVNlY3Rpb25Xb3JrYXJvdW5kKSlcbiAgICAgICAgLmpvaW4oJ1xcclxcbicpO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVkaWFTZWN0aW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBuZXdNZWRpYVNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gbWVkaWFTZWN0aW9uV29ya2Fyb3VuZChtZWRpYVNlY3Rpb24pIHtcbiAgICB2YXIgcHRUb0NvZGVjTmFtZSA9IGNyZWF0ZVB0VG9Db2RlY05hbWUobWVkaWFTZWN0aW9uKTtcbiAgICBtZWRpYVNlY3Rpb24gPSBkZWxldGVEdXBsaWNhdGVSdHhQdHMobWVkaWFTZWN0aW9uLCBwdFRvQ29kZWNOYW1lKTtcbiAgICB2YXIgY29kZWNOYW1lVG9QdHMgPSBjcmVhdGVDb2RlY05hbWVUb1B0cyhwdFRvQ29kZWNOYW1lKTtcbiAgICB2YXIgcnR4UHRzID0gY29kZWNOYW1lVG9QdHMuZ2V0KCdydHgnKSB8fCBuZXcgU2V0KCk7XG4gICAgdmFyIGludmFsaWRSdHhQdHMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHJ0eFB0VG9Bc3NvY2lhdGVkUHQgPSBjcmVhdGVSdHhQdFRvQXNzb2NpYXRlZFB0KG1lZGlhU2VjdGlvbiwgcHRUb0NvZGVjTmFtZSwgcnR4UHRzLCBpbnZhbGlkUnR4UHRzKTtcbiAgICB2YXIgYXNzb2NpYXRlZFB0VG9SdHhQdCA9IGNyZWF0ZUFzc29jaWF0ZWRQdFRvUnR4UHQocnR4UHRUb0Fzc29jaWF0ZWRQdCwgaW52YWxpZFJ0eFB0cyk7XG4gICAgdmFyIHVuYXNzb2NpYXRlZFJ0eFB0cyA9IEFycmF5LmZyb20oaW52YWxpZFJ0eFB0cyk7XG4gICAgLy8gTk9URShtcm9iZXJ0cyk6IFdlIG5vcm1hbGl6ZSB0byBsb3dlcmNhc2UuXG4gICAgdmFyIGtub3duQ29kZWNOYW1lcyA9IFsnaDI2NCcsICd2cDgnLCAndnA5J107XG4gICAgdmFyIHVuYXNzb2NpYXRlZFB0cyA9IGtub3duQ29kZWNOYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKHVuYXNzb2NpYXRlZFB0cywgY29kZWNOYW1lKSB7XG4gICAgICAgIHZhciBwdHMgPSBjb2RlY05hbWVUb1B0cy5nZXQoY29kZWNOYW1lKSB8fCBuZXcgU2V0KCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHB0cykucmVkdWNlKGZ1bmN0aW9uICh1bmFzc29jaWF0ZWRQdHMsIHB0KSB7IHJldHVybiBhc3NvY2lhdGVkUHRUb1J0eFB0LmhhcyhwdClcbiAgICAgICAgICAgID8gdW5hc3NvY2lhdGVkUHRzXG4gICAgICAgICAgICA6IHVuYXNzb2NpYXRlZFB0cy5hZGQocHQpOyB9LCB1bmFzc29jaWF0ZWRQdHMpO1xuICAgIH0sIG5ldyBTZXQoKSk7XG4gICAgdW5hc3NvY2lhdGVkUHRzLmZvckVhY2goZnVuY3Rpb24gKHB0KSB7XG4gICAgICAgIGlmICh1bmFzc29jaWF0ZWRSdHhQdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcnR4UHQgPSB1bmFzc29jaWF0ZWRSdHhQdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIG1lZGlhU2VjdGlvbiA9IGRlbGV0ZUZtdHBBdHRyaWJ1dGVzRm9yUnR4UHQobWVkaWFTZWN0aW9uLCBydHhQdCk7XG4gICAgICAgICAgICBtZWRpYVNlY3Rpb24gPSBhZGRGbXRwQXR0cmlidXRlRm9yUnR4UHQobWVkaWFTZWN0aW9uLCBydHhQdCwgcHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdW5hc3NvY2lhdGVkUnR4UHRzLmZvckVhY2goZnVuY3Rpb24gKHJ0eFB0KSB7XG4gICAgICAgIG1lZGlhU2VjdGlvbiA9IGRlbGV0ZUZtdHBBdHRyaWJ1dGVzRm9yUnR4UHQobWVkaWFTZWN0aW9uLCBydHhQdCk7XG4gICAgICAgIG1lZGlhU2VjdGlvbiA9IGRlbGV0ZVJ0cG1hcEF0dHJpYnV0ZXNGb3JSdHhQdChtZWRpYVNlY3Rpb24sIHJ0eFB0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWVkaWFTZWN0aW9uO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVkaWFTZWN0aW9uXG4gKiBAcGFyYW0ge01hcDxQVCwgQ29kZWM+fSBwdFRvQ29kZWNOYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBuZXdNZWRpYVNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGVsZXRlRHVwbGljYXRlUnR4UHRzKG1lZGlhU2VjdGlvbiwgcHRUb0NvZGVjTmFtZSkge1xuICAgIC8vIE5PVEUoc3llcnJhcHJhZ2FkYSk6IEluIHNvbWUgY2FzZXMgQ2hyb21lIHByb2R1Y2VzIGFuIG9mZmVyL2Fuc3dlclxuICAgIC8vIHdpdGggZHVwbGljYXRlIFwicnR4XCIgcGF5bG9hZCBtYXBwaW5nIGluIG1lZGlhIHNlY3Rpb24uIFdoZW4gYXBwbGllZCxcbiAgICAvLyBDaHJvbWUgcmVqZWN0cyB0aGUgU0RQLiBXZSB3b3JrYXJvdW5kIHRoaXMgYnkgZGVsZXRpbmcgZHVwbGljYXRlXG4gICAgLy8gXCJydHhcIiBtYXBwaW5ncyBmb3VuZCBpbiBTRFAuXG4gICAgcmV0dXJuIEFycmF5LmZyb20ocHRUb0NvZGVjTmFtZS5rZXlzKCkpLnJlZHVjZShmdW5jdGlvbiAoc2VjdGlvbiwgcHQpIHtcbiAgICAgICAgdmFyIHJ0cG1hcFJlZ2V4ID0gbmV3IFJlZ0V4cChcIl5hPXJ0cG1hcDpcIiArIHB0ICsgXCIgcnR4LiskXCIsICdnbScpO1xuICAgICAgICByZXR1cm4gKHNlY3Rpb24ubWF0Y2gocnRwbWFwUmVnZXgpIHx8IFtdKS5zbGljZShwdFRvQ29kZWNOYW1lLmdldChwdCkgPT09ICdydHgnID8gMSA6IDApLnJlZHVjZShmdW5jdGlvbiAoc2VjdGlvbiwgcnRwbWFwKSB7XG4gICAgICAgICAgICB2YXIgcnRwbWFwUmVnZXggPSBuZXcgUmVnRXhwKFwiXFxyXFxuXCIgKyBydHBtYXApO1xuICAgICAgICAgICAgdmFyIGZtdHBtYXBSZWdleCA9IG5ldyBSZWdFeHAoXCJcXHJcXG5hPWZtdHA6XCIgKyBwdCArIFwiIGFwdD1bMC05XStcIik7XG4gICAgICAgICAgICByZXR1cm4gc2VjdGlvbi5yZXBsYWNlKHJ0cG1hcFJlZ2V4LCAnJykucmVwbGFjZShmbXRwbWFwUmVnZXgsICcnKTtcbiAgICAgICAgfSwgc2VjdGlvbik7XG4gICAgfSwgbWVkaWFTZWN0aW9uKTtcbn1cbi8qKlxuICogQHBhcmFtIHtNYXA8UFQsIENvZGVjPn0gcHRUb0NvZGVjTmFtZVxuICogQHJldHVybnMge01hcDxzdHJpbmcsIE5vbkVtcHR5U2V0PFBUPj59IGNvZGVjTmFtZVRvUHRzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvZGVjTmFtZVRvUHRzKHB0VG9Db2RlY05hbWUpIHtcbiAgICB2YXIgY29kZWNOYW1lVG9QdHMgPSBuZXcgTWFwKCk7XG4gICAgcHRUb0NvZGVjTmFtZS5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlY05hbWUsIHB0KSB7XG4gICAgICAgIHZhciBwdHMgPSBjb2RlY05hbWVUb1B0cy5nZXQoY29kZWNOYW1lKSB8fCBuZXcgU2V0KCk7XG4gICAgICAgIHJldHVybiBjb2RlY05hbWVUb1B0cy5zZXQoY29kZWNOYW1lLCBwdHMuYWRkKHB0KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvZGVjTmFtZVRvUHRzO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVkaWFTZWN0aW9uXG4gKiBAcGFyYW0ge01hcDxQVCwgQ29kZWM+fSBwdFRvQ29kZWNOYW1lXG4gKiBAcGFyYW0ge1NldDxSdHhQVD59IHJ0eFB0c1xuICogQHBhcmFtIHtTZXQ8UnR4UFQ+fSBpbnZhbGlkUnR4UHRzXG4gKiBAcmV0dXJucyB7TWFwPFJ0eFBULCBOb25SdHhQVD59IHJ0eFB0VG9Bc3NvY2lhdGVkUHRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUnR4UHRUb0Fzc29jaWF0ZWRQdChtZWRpYVNlY3Rpb24sIHB0VG9Db2RlY05hbWUsIHJ0eFB0cywgaW52YWxpZFJ0eFB0cykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHJ0eFB0cykucmVkdWNlKGZ1bmN0aW9uIChydHhQdFRvQXNzb2NpYXRlZFB0LCBydHhQdCkge1xuICAgICAgICB2YXIgZm10cFBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiYT1mbXRwOlwiICsgcnR4UHQgKyBcIiBhcHQ9KFxcXFxkKylcIik7XG4gICAgICAgIHZhciBtYXRjaGVzID0gbWVkaWFTZWN0aW9uLm1hdGNoKGZtdHBQYXR0ZXJuKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICBpbnZhbGlkUnR4UHRzLmFkZChydHhQdCk7XG4gICAgICAgICAgICByZXR1cm4gcnR4UHRUb0Fzc29jaWF0ZWRQdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHQgPSBOdW1iZXIucGFyc2VJbnQobWF0Y2hlc1sxXSk7XG4gICAgICAgIGlmICghcHRUb0NvZGVjTmFtZS5oYXMocHQpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIElzc3VlIDgzMjkuXG4gICAgICAgICAgICBpbnZhbGlkUnR4UHRzLmFkZChydHhQdCk7XG4gICAgICAgICAgICByZXR1cm4gcnR4UHRUb0Fzc29jaWF0ZWRQdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29kZWNOYW1lID0gcHRUb0NvZGVjTmFtZS5nZXQocHQpO1xuICAgICAgICBpZiAoY29kZWNOYW1lID09PSAncnR4Jykge1xuICAgICAgICAgICAgLy8gU3RyYW5nZVxuICAgICAgICAgICAgaW52YWxpZFJ0eFB0cy5hZGQocnR4UHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJ0eFB0VG9Bc3NvY2lhdGVkUHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ0eFB0VG9Bc3NvY2lhdGVkUHQuc2V0KHJ0eFB0LCBwdCk7XG4gICAgfSwgbmV3IE1hcCgpKTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lZGlhU2VjdGlvblxuICogQHBhcmFtIHtNYXA8UnR4UFQsIE5vblJ0eFBUPn0gcnR4UHRUb0Fzc29jaWF0ZWRQdFxuICogQHBhcmFtIHtTZXQ8UnR4UFQ+fSBpbnZhbGlkUnR4UHRzXG4gKiBAcmV0dXJucyB7TWFwPE5vblJ0eFBULCBSdHhQVD59IGFzc29jaWF0ZWRQdFRvUnR4UHRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzb2NpYXRlZFB0VG9SdHhQdChydHhQdFRvQXNzb2NpYXRlZFB0LCBpbnZhbGlkUnR4UHRzKSB7XG4gICAgLy8gRmlyc3QsIHdlIGNvbnN0cnVjdCBhIE1hcDxOb25SdHhQVCwgTm9uRW1wdHlTZXQ8UnR4UFQ+Pi5cbiAgICB2YXIgYXNzb2NpYXRlZFB0VG9SdHhQdHMgPSBBcnJheS5mcm9tKHJ0eFB0VG9Bc3NvY2lhdGVkUHQpLnJlZHVjZShmdW5jdGlvbiAoYXNzb2NpYXRlZFB0VG9SdHhQdHMsIHBhaXIpIHtcbiAgICAgICAgdmFyIHJ0eFB0ID0gcGFpclswXTtcbiAgICAgICAgdmFyIHB0ID0gcGFpclsxXTtcbiAgICAgICAgdmFyIHJ0eFB0cyA9IGFzc29jaWF0ZWRQdFRvUnR4UHRzLmdldChwdCkgfHwgbmV3IFNldCgpO1xuICAgICAgICByZXR1cm4gYXNzb2NpYXRlZFB0VG9SdHhQdHMuc2V0KHB0LCBydHhQdHMuYWRkKHJ0eFB0KSk7XG4gICAgfSwgbmV3IE1hcCgpKTtcbiAgICAvLyBUaGVuLCB3ZSBmaWx0ZXIgZG93biB0byBhIE1hcDxOb25SdHhQVCwgUnR4UHQ+LiBBbnkgUnR4UFRzIHRoYXQgbWFwIHRvIHRoZVxuICAgIC8vIHNhbWUgTm9uUnR4UFQgYXJlIHJlbW92ZWQgYW5kIGFkZGVkIHRvIGludmFsaWRSdHhQdHMuXG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXNzb2NpYXRlZFB0VG9SdHhQdHMpLnJlZHVjZShmdW5jdGlvbiAoYXNzb2NpYXRlZFB0VG9SdHhQdCwgcGFpcikge1xuICAgICAgICB2YXIgcHQgPSBwYWlyWzBdO1xuICAgICAgICB2YXIgcnR4UHRzID0gQXJyYXkuZnJvbShwYWlyWzFdKTtcbiAgICAgICAgaWYgKHJ0eFB0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBydHhQdHMuZm9yRWFjaChmdW5jdGlvbiAocnR4UHQpIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkUnR4UHRzLmFkZChydHhQdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhc3NvY2lhdGVkUHRUb1J0eFB0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3NvY2lhdGVkUHRUb1J0eFB0LnNldChwdCwgcnR4UHRzWzBdKTtcbiAgICB9LCBuZXcgTWFwKCkpO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVkaWFTZWN0aW9uXG4gKiBAcGFyYW0ge1J0eFBUfSBydHhQdFxuICogQHJldHVybnMge3N0cmluZ30gbmV3TWVkaWFTZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZUZtdHBBdHRyaWJ1dGVzRm9yUnR4UHQobWVkaWFTZWN0aW9uLCBydHhQdCkge1xuICAgIHZhciBwYXR0ZXJuID0gbmV3IFJlZ0V4cChcImE9Zm10cDpcIiArIHJ0eFB0ICsgXCIuKlxcclxcblwiLCAnZ20nKTtcbiAgICByZXR1cm4gbWVkaWFTZWN0aW9uLnJlcGxhY2UocGF0dGVybiwgJycpO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVkaWFTZWN0aW9uXG4gKiBAcGFyYW0ge1J0eFBUfSBydHhQdFxuICogQHJldHVybnMge3N0cmluZ30gbmV3TWVkaWFTZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZVJ0cG1hcEF0dHJpYnV0ZXNGb3JSdHhQdChtZWRpYVNlY3Rpb24sIHJ0eFB0KSB7XG4gICAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiYT1ydHBtYXA6XCIgKyBydHhQdCArIFwiLipcXHJcXG5cIiwgJ2dtJyk7XG4gICAgcmV0dXJuIG1lZGlhU2VjdGlvbi5yZXBsYWNlKHBhdHRlcm4sICcnKTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lZGlhU2VjdGlvblxuICogQHBhcmFtIHtSdHhQVH0gcnR4UHRcbiAqIEBwYXJhbSB7Tm9uUnR4UFR9IHB0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBuZXdNZWRpYVNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gYWRkRm10cEF0dHJpYnV0ZUZvclJ0eFB0KG1lZGlhU2VjdGlvbiwgcnR4UHQsIHB0KSB7XG4gICAgcmV0dXJuIG1lZGlhU2VjdGlvbi5lbmRzV2l0aCgnXFxyXFxuJylcbiAgICAgICAgPyBtZWRpYVNlY3Rpb24gKyBcImE9Zm10cDpcIiArIHJ0eFB0ICsgXCIgYXB0PVwiICsgcHQgKyBcIlxcclxcblwiXG4gICAgICAgIDogbWVkaWFTZWN0aW9uICsgXCJcXHJcXG5hPWZtdHA6XCIgKyBydHhQdCArIFwiIGFwdD1cIiArIHB0O1xufVxubW9kdWxlLmV4cG9ydHMgPSB3b3JrYXJvdW5kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNzdWU4MzI5LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfYSA9IHJlcXVpcmUoJy4uLycpLCBkaWZmZXJlbmNlID0gX2EuZGlmZmVyZW5jZSwgZmxhdE1hcCA9IF9hLmZsYXRNYXA7XG4vKipcbiAqIENyZWF0ZSBhIHJhbmRvbSB7QGxpbmsgU1NSQ30uXG4gKiBAcmV0dXJucyB7U1NSQ31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU1NSQygpIHtcbiAgICB2YXIgc3NyY01heCA9IDB4ZmZmZmZmZmY7XG4gICAgcmV0dXJuIFN0cmluZyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzc3JjTWF4KSk7XG59XG4vKipcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjTmFtZVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1NpbXVsY2FzdEVuYWJsZWRcbiAqIEBwcm9wZXJ0eSB7TWFwPFJ0eFNTUkMsIFByaW1hcnlTU1JDPn0gcnR4UGFpcnNcbiAqIEBwcm9wZXJ0eSB7U2V0PFByaW1hcnlTU1JDPn0gcHJpbWFyeVNTUkNzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RyZWFtSWRcbiAqIEBwcm9wZXJ0eSB7VHJhY2suSUR9IHRyYWNrSWRcbiAqL1xudmFyIFRyYWNrQXR0cmlidXRlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTWVkaWFTdHJlYW1UcmFja30gYXR0cmlidXRlIHN0b3JlLlxuICAgICAqIEBwYXJhbSB7VHJhY2suSUR9IHRyYWNrSWQgLSBUaGUgTWVkaWFTdHJlYW1UcmFjayBJRFxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1JRH0gc3RyZWFtSWQgLSBUaGUgTWVkaWFTdHJlYW0gSURcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY05hbWUgLSBUaGUgTWVkaWFTdHJlYW0gY25hbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFja0F0dHJpYnV0ZXModHJhY2tJZCwgc3RyZWFtSWQsIGNOYW1lKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGNOYW1lOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY05hbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1NpbXVsY2FzdEVuYWJsZWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByaW1hcnlTU1JDczoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ0eFBhaXJzOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzdHJlYW1JZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYWNrSWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0cmFja0lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQge0BsaW5rIFNpbVNTUkN9cyB0byB0aGUge0BsaW5rIFRyYWNrQXR0cmlidXRlc30uXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgVHJhY2tBdHRyaWJ1dGVzLnByb3RvdHlwZS5hZGRTaW11bGNhc3RTU1JDcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaW11bGNhc3RFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpbXVsY2FzdFNTUkNzID0gW2NyZWF0ZVNTUkMoKSwgY3JlYXRlU1NSQygpXTtcbiAgICAgICAgc2ltdWxjYXN0U1NSQ3MuZm9yRWFjaChmdW5jdGlvbiAoc3NyYykge1xuICAgICAgICAgICAgdGhpcy5wcmltYXJ5U1NSQ3MuYWRkKHNzcmMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMucnR4UGFpcnMuc2l6ZSkge1xuICAgICAgICAgICAgc2ltdWxjYXN0U1NSQ3MuZm9yRWFjaChmdW5jdGlvbiAoc3NyYykge1xuICAgICAgICAgICAgICAgIHRoaXMucnR4UGFpcnMuc2V0KGNyZWF0ZVNTUkMoKSwgc3NyYyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBnaXZlbiB7QGxpbmsgUHJpbWFyeVNTUkN9IG9yIHtAbGluayBSdHhTU1JDfSB0byB0aGUge0BsaW5rIFRyYWNrQXR0cmlidXRlc31cbiAgICAgKiBhbmQgdXBkYXRlIHRoZSBcImlzU2ltdWxjYXN0RW5hYmxlZFwiIGZsYWcgaWYgaXQgaXMgYWxzbyBhIHtAbGluayBTaW1TU1JDfS5cbiAgICAgKiBAcGFyYW0ge1NTUkN9IHNzcmMgLSBUaGUge0BsaW5rIFNTUkN9IHRvIGJlIGFkZGVkXG4gICAgICogQHBhcmFtIHs/UHJpbWFyeVNTUkN9IHByaW1hcnlTU1JDIC0gVGhlIHtAbGluayBQcmltYXJ5U1NSQ307IGlmIHRoZSBnaXZlblxuICAgICAqICAge0BsaW5rIFNTUkN9IGl0c2VsZiBpcyB0aGUge0BsaW5rIFByaW1hcnlTU1JDfSwgdGhlbiB0aGlzIGlzIHNldCB0byBudWxsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1NpbVNTUkMgLSB0cnVlIGlmIHRoZSBnaXZlbiB7QGxpbmsgU1NSQ30gaXMgYVxuICAgICAqICAge0BsaW5rIFNpbVNTUkN9OyBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBUcmFja0F0dHJpYnV0ZXMucHJvdG90eXBlLmFkZFNTUkMgPSBmdW5jdGlvbiAoc3NyYywgcHJpbWFyeVNTUkMsIGlzU2ltU1NSQykge1xuICAgICAgICBpZiAocHJpbWFyeVNTUkMpIHtcbiAgICAgICAgICAgIHRoaXMucnR4UGFpcnMuc2V0KHNzcmMsIHByaW1hcnlTU1JDKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJpbWFyeVNTUkNzLmFkZChzc3JjKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU2ltdWxjYXN0RW5hYmxlZCA9IHRoaXMuaXNTaW11bGNhc3RFbmFibGVkIHx8IGlzU2ltU1NSQztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCB0aGUgU0RQIGxpbmVzIGZvciB0aGUge0BsaW5rIFRyYWNrQXR0cmlidXRlc30uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZXhjbHVkZVJ0eD1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gQXJyYXkgb2YgU0RQIGxpbmVzXG4gICAgICovXG4gICAgVHJhY2tBdHRyaWJ1dGVzLnByb3RvdHlwZS50b1NkcExpbmVzID0gZnVuY3Rpb24gKGV4Y2x1ZGVSdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJ0eFBhaXJzID0gZXhjbHVkZVJ0eFxuICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgOiBBcnJheS5mcm9tKHRoaXMucnR4UGFpcnMuZW50cmllcygpKS5tYXAoZnVuY3Rpb24gKHJ0eFBhaXIpIHsgcmV0dXJuIHJ0eFBhaXIucmV2ZXJzZSgpOyB9KTtcbiAgICAgICAgdmFyIHNpbVNTUkNzID0gQXJyYXkuZnJvbSh0aGlzLnByaW1hcnlTU1JDcy52YWx1ZXMoKSk7XG4gICAgICAgIHZhciBzc3JjcyA9IHJ0eFBhaXJzLmxlbmd0aCA/IGZsYXRNYXAocnR4UGFpcnMpIDogc2ltU1NSQ3M7XG4gICAgICAgIHZhciBhdHRyTGluZXMgPSBmbGF0TWFwKHNzcmNzLCBmdW5jdGlvbiAoc3NyYykgeyByZXR1cm4gW1xuICAgICAgICAgICAgXCJhPXNzcmM6XCIgKyBzc3JjICsgXCIgY25hbWU6XCIgKyBfdGhpcy5jTmFtZSxcbiAgICAgICAgICAgIFwiYT1zc3JjOlwiICsgc3NyYyArIFwiIG1zaWQ6XCIgKyBfdGhpcy5zdHJlYW1JZCArIFwiIFwiICsgX3RoaXMudHJhY2tJZFxuICAgICAgICBdOyB9KTtcbiAgICAgICAgdmFyIHJ0eFBhaXJMaW5lcyA9IHJ0eFBhaXJzLm1hcChmdW5jdGlvbiAocnR4UGFpcikgeyByZXR1cm4gXCJhPXNzcmMtZ3JvdXA6RklEIFwiICsgcnR4UGFpci5qb2luKCcgJyk7IH0pO1xuICAgICAgICB2YXIgc2ltR3JvdXBMaW5lcyA9IFtcbiAgICAgICAgICAgIFwiYT1zc3JjLWdyb3VwOlNJTSBcIiArIHNpbVNTUkNzLmpvaW4oJyAnKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gcnR4UGFpckxpbmVzLmNvbmNhdChhdHRyTGluZXMpLmNvbmNhdChzaW1Hcm91cExpbmVzKTtcbiAgICB9O1xuICAgIHJldHVybiBUcmFja0F0dHJpYnV0ZXM7XG59KCkpO1xuLyoqXG4gKiBHZXQgdGhlIG1hdGNoZXMgZm9yIGEgZ2l2ZW4gUmVnRXggcGF0dGVybi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uIC0gU0RQIG1lZGlhIHNlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIC0gUmVnRXggcGF0dGVyblxuICogQHJldHVybnMge0FycmF5PEFycmF5PHN0cmluZz4+fSAtIEFycmF5IG9mIHBhdHRlcm4gbWF0Y2hlc1xuICovXG5mdW5jdGlvbiBnZXRNYXRjaGVzKHNlY3Rpb24sIHBhdHRlcm4pIHtcbiAgICB2YXIgbWF0Y2hlcyA9IHNlY3Rpb24ubWF0Y2gobmV3IFJlZ0V4cChwYXR0ZXJuLCAnZ20nKSkgfHwgW107XG4gICAgcmV0dXJuIG1hdGNoZXMubWFwKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IG1hdGNoLm1hdGNoKG5ldyBSZWdFeHAocGF0dGVybikpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWF0Y2hlcy5zbGljZSgxKTtcbiAgICB9KTtcbn1cbi8qKlxuICogR2V0IHRoZSB7QGxpbmsgU2ltU1NSQ31zIHRoYXQgYmVsb25nIHRvIGEgc2ltdWxjYXN0IGdyb3VwLlxuICogQHBhcmFtIHtzdHJpbmd9IHNlY3Rpb24gLSBTRFAgbWVkaWEgc2VjdGlvblxuICogQHJldHVybnMge1NldDxTaW1TU1JDPn0gU2V0IG9mIHNpbXVsY2FzdCB7QGxpbmsgU1NSQ31zXG4gKi9cbmZ1bmN0aW9uIGdldFNpbXVsY2FzdFNTUkNzKHNlY3Rpb24pIHtcbiAgICB2YXIgc2ltR3JvdXBQYXR0ZXJuID0gJ15hPXNzcmMtZ3JvdXA6U0lNIChbMC05XSspIChbMC05XSspIChbMC05XSspJCc7XG4gICAgcmV0dXJuIG5ldyBTZXQoZmxhdE1hcChnZXRNYXRjaGVzKHNlY3Rpb24sIHNpbUdyb3VwUGF0dGVybikpKTtcbn1cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYXR0cmlidXRlIGZvciBhbiBTU1JDLlxuICogQHBhcmFtIHtzdHJpbmd9IHNlY3Rpb24gLSBTRFAgbWVkaWEgc2VjdGlvblxuICogQHBhcmFtIHtTU1JDfSBzc3JjIC0ge0BsaW5rIFNTUkN9IHdob3NlIGF0dHJpYnV0ZSdzIHZhbHVlIGlzIHRvIGJlIGRldGVybWluZGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIC0ge0BsaW5rIFNTUkN9IGF0dHJpYnV0ZSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gLSB7QGxpbmsgU1NSQ30gYXR0cmlidXRlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldFNTUkNBdHRyaWJ1dGUoc2VjdGlvbiwgc3NyYywgYXR0cmlidXRlKSB7XG4gICAgdmFyIHBhdHRlcm4gPSBcImE9c3NyYzpcIiArIHNzcmMgKyBcIiBcIiArIGF0dHJpYnV0ZSArIFwiOiguKylcIjtcbiAgICByZXR1cm4gc2VjdGlvbi5tYXRjaChuZXcgUmVnRXhwKHBhdHRlcm4pKVsxXTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgTWFwIG9mIHtAbGluayBQcmltYXJ5U1NSQ31zIGFuZCB0aGVpciB7QGxpbmsgUnR4U1NSQ31zLlxuICogQHBhcmFtIHtzdHJpbmd9IHNlY3Rpb24gLSBTRFAgbWVkaWEgc2VjdGlvblxuICogQHJldHVybnMge01hcDxSdHhTU1JDLCBQcmltYXJ5U1NSQz59IC0gTWFwIG9mIHtAbGluayBSdHhTU1JDfXMgYW5kIHRoZWlyXG4gKiAgIGNvcnJlc3BvbmRpbmcge0BsaW5rIFByaW1hcnlTU1JDfXNcbiAqL1xuZnVuY3Rpb24gZ2V0U1NSQ1J0eFBhaXJzKHNlY3Rpb24pIHtcbiAgICB2YXIgcnR4UGFpclBhdHRlcm4gPSAnXmE9c3NyYy1ncm91cDpGSUQgKFswLTldKykgKFswLTldKykkJztcbiAgICByZXR1cm4gbmV3IE1hcChnZXRNYXRjaGVzKHNlY3Rpb24sIHJ0eFBhaXJQYXR0ZXJuKS5tYXAoZnVuY3Rpb24gKHBhaXIpIHsgcmV0dXJuIHBhaXIucmV2ZXJzZSgpOyB9KSk7XG59XG4vKipcbiAqIENyZWF0ZSBTU1JDIGF0dHJpYnV0ZSB0dXBsZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VjdGlvblxuICogQHJldHVybnMge0FycmF5PFtTU1JDLCBNZWRpYVN0cmVhbUlELCBUcmFjay5JRF0+fVxuICovXG5mdW5jdGlvbiBjcmVhdGVTU1JDQXR0cmlidXRlVHVwbGVzKHNlY3Rpb24pIHtcbiAgICB2YXIgX2EgPSBfX3JlYWQoZmxhdE1hcChnZXRNYXRjaGVzKHNlY3Rpb24sICdeYT1tc2lkOiguKykgKC4rKSQnKSksIDIpLCBzdHJlYW1JZCA9IF9hWzBdLCB0cmFja0lkID0gX2FbMV07XG4gICAgdmFyIHNzcmNzID0gZmxhdE1hcChnZXRNYXRjaGVzKHNlY3Rpb24sICdeYT1zc3JjOiguKykgY25hbWU6LiskJykpO1xuICAgIHJldHVybiBzc3Jjcy5tYXAoZnVuY3Rpb24gKHNzcmMpIHsgcmV0dXJuIFtzc3JjLCBzdHJlYW1JZCwgdHJhY2tJZF07IH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBNYXAgb2YgTWVkaWFTdHJlYW1UcmFjayBJRHMgYW5kIHRoZWlyIHtAbGluayBUcmFja0F0dHJpYnV0ZXN9LlxuICogQHBhcmFtIHtzdHJpbmd9IHNlY3Rpb24gLSBTRFAgbWVkaWEgc2VjdGlvblxuICogQHJldHVybnMge01hcDxUcmFjay5JRCwgVHJhY2tBdHRyaWJ1dGVzPn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhY2tJZHNUb0F0dHJpYnV0ZXMoc2VjdGlvbikge1xuICAgIHZhciBzaW1TU1JDcyA9IGdldFNpbXVsY2FzdFNTUkNzKHNlY3Rpb24pO1xuICAgIHZhciBydHhQYWlycyA9IGdldFNTUkNSdHhQYWlycyhzZWN0aW9uKTtcbiAgICB2YXIgc3NyY0F0dHJUdXBsZXMgPSBjcmVhdGVTU1JDQXR0cmlidXRlVHVwbGVzKHNlY3Rpb24pO1xuICAgIHJldHVybiBzc3JjQXR0clR1cGxlcy5yZWR1Y2UoZnVuY3Rpb24gKHRyYWNrSWRzVG9TU1JDcywgdHVwbGUpIHtcbiAgICAgICAgdmFyIHNzcmMgPSB0dXBsZVswXTtcbiAgICAgICAgdmFyIHN0cmVhbUlkID0gdHVwbGVbMV07XG4gICAgICAgIHZhciB0cmFja0lkID0gdHVwbGVbMl07XG4gICAgICAgIHZhciB0cmFja0F0dHJpYnV0ZXMgPSB0cmFja0lkc1RvU1NSQ3MuZ2V0KHRyYWNrSWQpIHx8IG5ldyBUcmFja0F0dHJpYnV0ZXModHJhY2tJZCwgc3RyZWFtSWQsIGdldFNTUkNBdHRyaWJ1dGUoc2VjdGlvbiwgc3NyYywgJ2NuYW1lJykpO1xuICAgICAgICB2YXIgcHJpbWFyeVNTUkMgPSBydHhQYWlycy5nZXQoc3NyYykgfHwgbnVsbDtcbiAgICAgICAgdHJhY2tBdHRyaWJ1dGVzLmFkZFNTUkMoc3NyYywgcHJpbWFyeVNTUkMsIHNpbVNTUkNzLmhhcyhzc3JjKSk7XG4gICAgICAgIHJldHVybiB0cmFja0lkc1RvU1NSQ3Muc2V0KHRyYWNrSWQsIHRyYWNrQXR0cmlidXRlcyk7XG4gICAgfSwgbmV3IE1hcCgpKTtcbn1cbi8qKlxuICogQXBwbHkgc2ltdWxjYXN0IHNldHRpbmdzIHRvIHRoZSBnaXZlbiBTRFAgbWVkaWEgc2VjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uIC0gU0RQIG1lZGlhIHNlY3Rpb25cbiAqIEBwYXJhbSB7TWFwPFRyYWNrLklELCBUcmFja0F0dHJpYnV0ZXM+fSB0cmFja0lkc1RvQXR0cmlidXRlcyAtIEV4aXN0aW5nXG4gKiAgIG1hcCB3aGljaCB3aWxsIGJlIHVwZGF0ZWQgZm9yIG5ldyBNZWRpYVN0cmVhbVRyYWNrIElEc1xuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgdHJhbnNmb3JtZWQgU0RQIG1lZGlhIHNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gc2V0U2ltdWxjYXN0SW5NZWRpYVNlY3Rpb24oc2VjdGlvbiwgdHJhY2tJZHNUb0F0dHJpYnV0ZXMpIHtcbiAgICB2YXIgbmV3VHJhY2tJZHNUb0F0dHJpYnV0ZXMgPSBjcmVhdGVUcmFja0lkc1RvQXR0cmlidXRlcyhzZWN0aW9uKTtcbiAgICB2YXIgbmV3VHJhY2tJZHMgPSBBcnJheS5mcm9tKG5ld1RyYWNrSWRzVG9BdHRyaWJ1dGVzLmtleXMoKSk7XG4gICAgdmFyIHRyYWNrSWRzID0gQXJyYXkuZnJvbSh0cmFja0lkc1RvQXR0cmlidXRlcy5rZXlzKCkpO1xuICAgIHZhciB0cmFja0lkc1RvQWRkID0gZGlmZmVyZW5jZShuZXdUcmFja0lkcywgdHJhY2tJZHMpO1xuICAgIHZhciB0cmFja0lkc1RvSWdub3JlID0gZGlmZmVyZW5jZSh0cmFja0lkcywgbmV3VHJhY2tJZHMpO1xuICAgIC8vIFVwZGF0ZSBcInRyYWNrSWRzVG9BdHRyaWJ1dGVzXCIgd2l0aCBUcmFja0F0dHJpYnV0ZXMgZm9yIG5ld1xuICAgIC8vIE1lZGlhU3RyZWFtVHJhY2sgSURzLlxuICAgIHZhciB0cmFja0F0dHJpYnV0ZXNUb0FkZCA9IGZsYXRNYXAodHJhY2tJZHNUb0FkZCwgZnVuY3Rpb24gKHRyYWNrSWQpIHsgcmV0dXJuIG5ld1RyYWNrSWRzVG9BdHRyaWJ1dGVzLmdldCh0cmFja0lkKTsgfSk7XG4gICAgdHJhY2tBdHRyaWJ1dGVzVG9BZGQuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tBdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRyYWNrQXR0cmlidXRlcy5hZGRTaW11bGNhc3RTU1JDcygpO1xuICAgICAgICB0cmFja0lkc1RvQXR0cmlidXRlcy5zZXQodHJhY2tBdHRyaWJ1dGVzLnRyYWNrSWQsIHRyYWNrQXR0cmlidXRlcyk7XG4gICAgfSk7XG4gICAgLy8gR2V0IHRoZSBTRFAgbGluZXMgb2YgdGhlIHJlbGV2YW50IE1lZGlhU3RyZWFtVHJhY2sgSURzIGZyb21cbiAgICAvLyBcInRyYWNrSWRzVG9BdHRyaWJ1dGVzXCIuXG4gICAgdHJhY2tJZHMgPSBBcnJheS5mcm9tKHRyYWNrSWRzVG9BdHRyaWJ1dGVzLmtleXMoKSk7XG4gICAgdmFyIHJlbGV2YW50VHJhY2tJZHMgPSBkaWZmZXJlbmNlKHRyYWNrSWRzLCB0cmFja0lkc1RvSWdub3JlKTtcbiAgICB2YXIgcmVsZXZhbnRUcmFja0F0dHJpYnV0ZXMgPSBmbGF0TWFwKHJlbGV2YW50VHJhY2tJZHMsIGZ1bmN0aW9uICh0cmFja0lkKSB7IHJldHVybiB0cmFja0lkc1RvQXR0cmlidXRlcy5nZXQodHJhY2tJZCk7IH0pO1xuICAgIHZhciBleGNsdWRlUnR4ID0gIXNlY3Rpb24ubWF0Y2goL2E9cnRwbWFwOlswLTldKyBydHgvKTtcbiAgICB2YXIgcmVsZXZhbnRTZHBMaW5lcyA9IGZsYXRNYXAocmVsZXZhbnRUcmFja0F0dHJpYnV0ZXMsIGZ1bmN0aW9uICh0cmFja0F0dHJpYnV0ZXMpIHsgcmV0dXJuIHRyYWNrQXR0cmlidXRlcy50b1NkcExpbmVzKGV4Y2x1ZGVSdHgpOyB9KTtcbiAgICAvLyBBZGQgdGhlIHNpbXVsY2FzdCBTU1JDIFNEUCBsaW5lcyB0byB0aGUgbWVkaWEgc2VjdGlvbi4gVGhlIFNldCBlbnN1cmVzXG4gICAgLy8gdGhhdCB0aGUgZHVwbGljYXRlcyBvZiB0aGUgU1NSQyBTRFAgbGluZXMgdGhhdCBhcmUgaW4gYm90aCBcInNlY3Rpb25cIiBhbmRcbiAgICAvLyBcInJlbGV2YW50U2RwTGluZXNcIiBhcmUgcmVtb3ZlZC5cbiAgICB2YXIgc2VjdGlvbkxpbmVzID0gZmxhdE1hcChuZXcgU2V0KHNlY3Rpb24uc3BsaXQoJ1xcclxcbicpLmNvbmNhdChyZWxldmFudFNkcExpbmVzKSkpO1xuICAgIHZhciB4R29vZ2xlRmxhZ0NvbmZlcmVuY2UgPSAnYT14LWdvb2dsZS1mbGFnOmNvbmZlcmVuY2UnO1xuICAgIGlmICghc2VjdGlvbi5tYXRjaCh4R29vZ2xlRmxhZ0NvbmZlcmVuY2UpKSB7XG4gICAgICAgIHNlY3Rpb25MaW5lcy5wdXNoKHhHb29nbGVGbGFnQ29uZmVyZW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBzZWN0aW9uTGluZXMuam9pbignXFxyXFxuJyk7XG59XG4vKipcbiAqIFN0cmluZyByZXByZXNlbnRpbmcgYSBNZWRpYVN0cmVhbSBJRC5cbiAqIEB0eXBlZGVmIHtzdHJpbmd9IE1lZGlhU3RyZWFtSURcbiAqL1xuLyoqXG4gKiBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBTU1JDIG9mIGEgTWVkaWFTdHJlYW1UcmFjay5cbiAqIEB0eXBlZGVmIHtzdHJpbmd9IFNTUkNcbiAqL1xuLyoqXG4gKiBQcmltYXJ5IFNTUkMuXG4gKiBAdHlwZWRlZiB7U1NSQ30gUHJpbWFyeVNTUkNcbiAqL1xuLyoqXG4gKiBSZXRyYW5zbWlzc2lvbiBTU1JDLlxuICogQHR5cGVkZWYge1NTUkN9IFJ0eFNTUkNcbiAqL1xuLyoqXG4gKiBTaW11bGNhc3QgU1NSQy5cbiAqIEB0eXBlZGVmIHtTU1JDfSBTaW1TU1JDXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gc2V0U2ltdWxjYXN0SW5NZWRpYVNlY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW11bGNhc3QuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdldE1lZGlhU2VjdGlvbnMgPSByZXF1aXJlKCcuLycpLmdldE1lZGlhU2VjdGlvbnM7XG4vKipcbiAqIEFuIHtAbGluayBUcmFja01hdGNoZXJ9IG1hdGNoZXMgYW4gUlRDVHJhY2tFdmVudCB3aXRoIGEgTWVkaWFTdHJlYW1UcmFja1xuICogSUQgYmFzZWQgb24gdGhlIE1JRCBvZiB0aGUgdW5kZXJseWluZyBSVENSdHBUcmFuc2NlaXZlci5cbiAqL1xudmFyIFRyYWNrTWF0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4ge0BsaW5rIFRyYWNrTWF0Y2hlcn0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhY2tNYXRjaGVyKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBfbWlkc1RvVHJhY2tJZHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBhIGdpdmVuIE1lZGlhU3RyZWFtVHJhY2sgd2l0aCBpdHMgSUQuXG4gICAgICogQHBhcmFtIHtSVENUcmFja0V2ZW50fSBldmVudFxuICAgICAqIEByZXR1cm5zIHs/VHJhY2suSUR9XG4gICAgICovXG4gICAgVHJhY2tNYXRjaGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWlkc1RvVHJhY2tJZHMuZ2V0KGV2ZW50LnRyYW5zY2VpdmVyLm1pZCkgfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUge0BsaW5rIFRyYWNrTWF0Y2hlcn0gd2l0aCBhIG5ldyBTRFAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNkcFxuICAgICAqL1xuICAgIFRyYWNrTWF0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHNkcCkge1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSBnZXRNZWRpYVNlY3Rpb25zKHNkcCwgJyhhdWRpb3x2aWRlbyknKTtcbiAgICAgICAgdGhpcy5fbWlkc1RvVHJhY2tJZHMgPSBzZWN0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKG1pZHNUb1RyYWNrSWRzLCBzZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbWlkTWF0Y2hlcyA9IHNlY3Rpb24ubWF0Y2goL15hPW1pZDooLispJC9tKSB8fCBbXTtcbiAgICAgICAgICAgIHZhciB0cmFja0lkTWF0Y2hlcyA9IHNlY3Rpb24ubWF0Y2goL15hPW1zaWQ6LisgKC4rKSQvbSkgfHwgW107XG4gICAgICAgICAgICB2YXIgbWlkID0gbWlkTWF0Y2hlc1sxXTtcbiAgICAgICAgICAgIHZhciB0cmFja0lkID0gdHJhY2tJZE1hdGNoZXNbMV07XG4gICAgICAgICAgICByZXR1cm4gbWlkICYmIHRyYWNrSWQgPyBtaWRzVG9UcmFja0lkcy5zZXQobWlkLCB0cmFja0lkKSA6IG1pZHNUb1RyYWNrSWRzO1xuICAgICAgICB9LCB0aGlzLl9taWRzVG9UcmFja0lkcyk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhY2tNYXRjaGVyO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gVHJhY2tNYXRjaGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2ttYXRjaGVyLmpzLm1hcCIsInZhciBTSURfQ0hBUlMgPSAnMTIzNDU2Nzg5MGFiY2RlZic7XG52YXIgU0lEX0NIQVJfTEVOR1RIID0gMzI7XG4vLyBjb3BpZWQgZnJvbTogaHR0cHM6Ly9jb2RlLmhxLnR3aWxpby5jb20vZmxleC9tb25rZXkvYmxvYi8wZmRjZTJiNmM1MmQ2YmUwYjE3YTVjZGI5MmYwYzU0ZjExOWI4ZWE4L3NyYy9jbGllbnQvbGliL3NpZC50cyNMMzlcbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHNpZCB1c2luZyBnaXZlbiBwcmVmaXguXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4XG4gKiBAcmV0dXJucyBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU0lEKHByZWZpeCkge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNJRF9DSEFSX0xFTkdUSDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBTSURfQ0hBUlMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFNJRF9DSEFSUy5sZW5ndGgpKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIgKyBwcmVmaXggKyByZXN1bHQ7XG59XG5leHBvcnRzLnNlc3Npb25TSUQgPSBjcmVhdGVTSUQoJ1NTJyk7XG5leHBvcnRzLmNyZWF0ZVNJRCA9IGNyZWF0ZVNJRDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX2EgPSByZXF1aXJlKCcuLi93ZWJydGMvdXRpbCcpLCBndWVzc0Jyb3dzZXIgPSBfYS5ndWVzc0Jyb3dzZXIsIGlzV2ViUlRDU3VwcG9ydGVkID0gX2Euc3VwcG9ydDtcbnZhciBfYiA9IHJlcXVpcmUoJy4vYnJvd3NlcmRldGVjdGlvbicpLCBpc0FuZHJvaWQgPSBfYi5pc0FuZHJvaWQsIGlzTW9iaWxlID0gX2IuaXNNb2JpbGUsIGlzTm9uQ2hyb21pdW1FZGdlID0gX2IuaXNOb25DaHJvbWl1bUVkZ2UsIHJlYnJhbmRlZENocm9tZUJyb3dzZXIgPSBfYi5yZWJyYW5kZWRDaHJvbWVCcm93c2VyLCBtb2JpbGVXZWJLaXRCcm93c2VyID0gX2IubW9iaWxlV2ViS2l0QnJvd3NlcjtcbnZhciBTVVBQT1JURURfQ0hST01FX0JBU0VEX0JST1dTRVJTID0gW1xuICAgICdjcmlvcycsXG4gICAgJ2VkZycsXG4gICAgJ2VkZ2UnLFxuICAgICdlbGVjdHJvbicsXG4gICAgJ2hlYWRsZXNzY2hyb21lJ1xuXTtcbnZhciBTVVBQT1JURURfQU5EUk9JRF9CUk9XU0VSUyA9IFtcbiAgICAnY2hyb21lJyxcbiAgICAnZmlyZWZveCdcbl07XG52YXIgU1VQUE9SVEVEX0lPU19CUk9XU0VSUyA9IFtcbiAgICAnY2hyb21lJyxcbiAgICAnc2FmYXJpJ1xuXTtcbi8vIEN1cnJlbnRseSBub25lLiBBZGQgJ2JyYXZlJywgJ2VkZycsIGFuZCAnZWRnZScgaGVyZSBvbmNlIHdlIHN0YXJ0IHN1cHBvcnRpbmcgdGhlbVxudmFyIFNVUFBPUlRFRF9NT0JJTEVfV0VCS0lUX0JBU0VEX0JST1dTRVJTID0gW107XG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgb2ZmaWNpYWxseSBzdXBwb3J0ZWQgYnkgdHdpbGlvLXZpZGVvLmpzLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgIHZhciBicm93c2VyID0gZ3Vlc3NCcm93c2VyKCk7XG4gICAgLy8gTk9URSAoY3NhbnRvcyk6IFJldHVybiByaWdodCBhd2F5IGlmIHRoZXJlIGlzIG5vIGJyb3dzZXIgZGV0ZWN0ZWRcbiAgICAvLyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IGNoZWNrcyB3aGljaCBjb3VsZCBsZWFkIHRvIGVycm9yc1xuICAgIGlmICghYnJvd3Nlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciByZWJyYW5kZWRDaHJvbWUgPSByZWJyYW5kZWRDaHJvbWVCcm93c2VyKGJyb3dzZXIpO1xuICAgIHZhciBtb2JpbGVXZWJLaXQgPSBtb2JpbGVXZWJLaXRCcm93c2VyKGJyb3dzZXIpO1xuICAgIHZhciBzdXBwb3J0ZWRNb2JpbGVCcm93c2VycyA9IGlzQW5kcm9pZCgpID9cbiAgICAgICAgU1VQUE9SVEVEX0FORFJPSURfQlJPV1NFUlMgOiBTVVBQT1JURURfSU9TX0JST1dTRVJTO1xuICAgIHJldHVybiAhIWJyb3dzZXJcbiAgICAgICAgJiYgaXNXZWJSVENTdXBwb3J0ZWQoKVxuICAgICAgICAmJiAoIXJlYnJhbmRlZENocm9tZSB8fCBTVVBQT1JURURfQ0hST01FX0JBU0VEX0JST1dTRVJTLmluY2x1ZGVzKHJlYnJhbmRlZENocm9tZSkpXG4gICAgICAgICYmICFpc05vbkNocm9taXVtRWRnZShicm93c2VyKVxuICAgICAgICAmJiAoIW1vYmlsZVdlYktpdCB8fCBTVVBQT1JURURfTU9CSUxFX1dFQktJVF9CQVNFRF9CUk9XU0VSUy5pbmNsdWRlcyhtb2JpbGVXZWJLaXQpKVxuICAgICAgICAmJiAoIWlzTW9iaWxlKCkgfHwgc3VwcG9ydGVkTW9iaWxlQnJvd3NlcnMuaW5jbHVkZXMoYnJvd3NlcikpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpc1N1cHBvcnRlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1cHBvcnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBBIHtAbGluayBUaW1lb3V0fSByZXByZXNlbnRzIGEgcmVzZXR0YWJsZSBhbmQgY2xlYXJhYmxlIHRpbWVvdXQuXG4gKi9cbnZhciBUaW1lb3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBUaW1lb3V0fS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIEZ1bmN0aW9uIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSBEZWxheSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthdXRvU3RhcnQ9dHJ1ZV0gLSBJZiB0cnVlLCB0aGVuIHN0YXJ0IHRoZSB7QGxpbmsgVGltZW91dH0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGltZW91dChmbiwgZGVsYXksIGF1dG9TdGFydCkge1xuICAgICAgICBpZiAoYXV0b1N0YXJ0ID09PSB2b2lkIDApIHsgYXV0b1N0YXJ0ID0gdHJ1ZTsgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBfZGVsYXk6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGVsYXksXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZm46IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZm5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdGltZW91dDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYXV0b1N0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVvdXQucHJvdG90eXBlLCBcImRlbGF5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB7QGxpbmsgVGltZW91dH0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGF5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVvdXQucHJvdG90eXBlLCBcImlzU2V0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHtAbGluayBUaW1lb3V0fSBpcyBzZXQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fdGltZW91dDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUge0BsaW5rIFRpbWVvdXR9IGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFRpbWVvdXQucHJvdG90eXBlLnNldERlbGF5ID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIHRoaXMuX2RlbGF5ID0gZGVsYXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUge0BsaW5rIFRpbWVvdXR9LCBpZiBub3QgYWxyZWFkeSBzdGFydGVkLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFRpbWVvdXQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuaXNTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBfdGhpcy5fZm47XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSwgdGhpcy5fZGVsYXkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUge0BsaW5rIFRpbWVvdXR9LlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFRpbWVvdXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHtAbGluayBUaW1lb3V0fS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBUaW1lb3V0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZW91dDtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVvdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0LmpzLm1hcCIsIi8vIE5PVEU6IERvIG5vdCBlZGl0IHRoaXMgZmlsZS4gVGhpcyBjb2RlIGlzIGF1dG8tZ2VuZXJhdGVkLiBDb250YWN0IHRoZVxuLy8gVHdpbGlvIFNESyBUZWFtIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBUd2lsaW9FcnJvciA9IHJlcXVpcmUoJy4vdHdpbGlvZXJyb3InKTtcbnZhciBUd2lsaW9FcnJvckJ5Q29kZSA9IHt9O1xuLyoqXG4gKiBDcmVhdGUgYSB7QGxpbmsgVHdpbGlvRXJyb3J9IGZvciBhIGdpdmVuIGNvZGUgYW5kIG1lc3NhZ2UuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtjb2RlXSAtIEVycm9yIGNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWVzc2FnZV0gLSBFcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJucyB7VHdpbGlvRXJyb3J9XG4gKi9cbmV4cG9ydHMuY3JlYXRlVHdpbGlvRXJyb3IgPSBmdW5jdGlvbiBjcmVhdGVUd2lsaW9FcnJvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgY29kZSA9IHR5cGVvZiBjb2RlID09PSAnbnVtYmVyJyA/IGNvZGUgOiAwO1xuICAgIG1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgbWVzc2FnZSA/IG1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcic7XG4gICAgcmV0dXJuIFR3aWxpb0Vycm9yQnlDb2RlW2NvZGVdID8gbmV3IFR3aWxpb0Vycm9yQnlDb2RlW2NvZGVdKCkgOiBuZXcgVHdpbGlvRXJyb3IoY29kZSwgbWVzc2FnZSk7XG59O1xuLyoqXG4gKiBAY2xhc3MgQWNjZXNzVG9rZW5JbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIHRoZSBBY2Nlc3NUb2tlbiB1c2VkIGZvciBjb25uZWN0aW5nIHRvIGEgUm9vbSBpcyBpbnZhbGlkLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gMjAxMDFcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ0ludmFsaWQgQWNjZXNzIFRva2VuJ1xuICovXG52YXIgQWNjZXNzVG9rZW5JbnZhbGlkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY2Vzc1Rva2VuSW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY2Vzc1Rva2VuSW52YWxpZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAyMDEwMSwgJ0ludmFsaWQgQWNjZXNzIFRva2VuJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBBY2Nlc3NUb2tlbkludmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBY2Nlc3NUb2tlbkludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuQWNjZXNzVG9rZW5JbnZhbGlkRXJyb3IgPSBBY2Nlc3NUb2tlbkludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgMjAxMDEsIHsgdmFsdWU6IEFjY2Vzc1Rva2VuSW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgQWNjZXNzVG9rZW5IZWFkZXJJbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIHRoZSBBY2Nlc3NUb2tlbiB1c2VkIGZvciBjb25uZWN0aW5nIHRvIGEgUm9vbSBoYXMgYW4gaW52YWxpZCBoZWFkZXIuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSAyMDEwMlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnSW52YWxpZCBBY2Nlc3MgVG9rZW4gaGVhZGVyJ1xuICovXG52YXIgQWNjZXNzVG9rZW5IZWFkZXJJbnZhbGlkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY2Vzc1Rva2VuSGVhZGVySW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY2Vzc1Rva2VuSGVhZGVySW52YWxpZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAyMDEwMiwgJ0ludmFsaWQgQWNjZXNzIFRva2VuIGhlYWRlcicpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgQWNjZXNzVG9rZW5IZWFkZXJJbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQWNjZXNzVG9rZW5IZWFkZXJJbnZhbGlkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLkFjY2Vzc1Rva2VuSGVhZGVySW52YWxpZEVycm9yID0gQWNjZXNzVG9rZW5IZWFkZXJJbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDIwMTAyLCB7IHZhbHVlOiBBY2Nlc3NUb2tlbkhlYWRlckludmFsaWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIEFjY2Vzc1Rva2VuSXNzdWVySW52YWxpZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciB0aGUgQWNjZXNzVG9rZW4gdXNlZCBmb3IgY29ubmVjdGluZyB0byBhIFJvb20gY29udGFpbnMgYW4gaW52YWxpZCBpc3N1ZXIgb3Igc3ViamVjdC5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDIwMTAzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdJbnZhbGlkIEFjY2VzcyBUb2tlbiBpc3N1ZXIvc3ViamVjdCdcbiAqL1xudmFyIEFjY2Vzc1Rva2VuSXNzdWVySW52YWxpZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2Nlc3NUb2tlbklzc3VlckludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2Nlc3NUb2tlbklzc3VlckludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgMjAxMDMsICdJbnZhbGlkIEFjY2VzcyBUb2tlbiBpc3N1ZXIvc3ViamVjdCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgQWNjZXNzVG9rZW5Jc3N1ZXJJbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQWNjZXNzVG9rZW5Jc3N1ZXJJbnZhbGlkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLkFjY2Vzc1Rva2VuSXNzdWVySW52YWxpZEVycm9yID0gQWNjZXNzVG9rZW5Jc3N1ZXJJbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDIwMTAzLCB7IHZhbHVlOiBBY2Nlc3NUb2tlbklzc3VlckludmFsaWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIEFjY2Vzc1Rva2VuRXhwaXJlZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciB0aGUgQWNjZXNzVG9rZW4gdXNlZCBmb3IgY29ubmVjdGluZywgb3IgcmVjb25uZWN0aW5nIHRvIGEgUm9vbSBoYXMgZXhwaXJlZC5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDIwMTA0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdBY2Nlc3MgVG9rZW4gZXhwaXJlZCBvciBleHBpcmF0aW9uIGRhdGUgaW52YWxpZCdcbiAqL1xudmFyIEFjY2Vzc1Rva2VuRXhwaXJlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2Nlc3NUb2tlbkV4cGlyZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2Nlc3NUb2tlbkV4cGlyZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgMjAxMDQsICdBY2Nlc3MgVG9rZW4gZXhwaXJlZCBvciBleHBpcmF0aW9uIGRhdGUgaW52YWxpZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgQWNjZXNzVG9rZW5FeHBpcmVkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQWNjZXNzVG9rZW5FeHBpcmVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLkFjY2Vzc1Rva2VuRXhwaXJlZEVycm9yID0gQWNjZXNzVG9rZW5FeHBpcmVkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDIwMTA0LCB7IHZhbHVlOiBBY2Nlc3NUb2tlbkV4cGlyZWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIEFjY2Vzc1Rva2VuTm90WWV0VmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgdGhlIEFjY2Vzc1Rva2VuIHVzZWQgZm9yIGNvbm5lY3RpbmcgdG8gYSBSb29tIGlzIG5vdCB5ZXQgdmFsaWQuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSAyMDEwNVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnQWNjZXNzIFRva2VuIG5vdCB5ZXQgdmFsaWQnXG4gKi9cbnZhciBBY2Nlc3NUb2tlbk5vdFlldFZhbGlkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY2Vzc1Rva2VuTm90WWV0VmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2Nlc3NUb2tlbk5vdFlldFZhbGlkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDIwMTA1LCAnQWNjZXNzIFRva2VuIG5vdCB5ZXQgdmFsaWQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIEFjY2Vzc1Rva2VuTm90WWV0VmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBY2Nlc3NUb2tlbk5vdFlldFZhbGlkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLkFjY2Vzc1Rva2VuTm90WWV0VmFsaWRFcnJvciA9IEFjY2Vzc1Rva2VuTm90WWV0VmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgMjAxMDUsIHsgdmFsdWU6IEFjY2Vzc1Rva2VuTm90WWV0VmFsaWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIEFjY2Vzc1Rva2VuR3JhbnRzSW52YWxpZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciB0aGUgQWNjZXNzVG9rZW4gdXNlZCBmb3IgY29ubmVjdGluZyB0byBhIFJvb20gaGFzIGludmFsaWQgZ3JhbnRzLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gMjAxMDZcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ0ludmFsaWQgQWNjZXNzIFRva2VuIGdyYW50cydcbiAqL1xudmFyIEFjY2Vzc1Rva2VuR3JhbnRzSW52YWxpZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2Nlc3NUb2tlbkdyYW50c0ludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2Nlc3NUb2tlbkdyYW50c0ludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgMjAxMDYsICdJbnZhbGlkIEFjY2VzcyBUb2tlbiBncmFudHMnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIEFjY2Vzc1Rva2VuR3JhbnRzSW52YWxpZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFjY2Vzc1Rva2VuR3JhbnRzSW52YWxpZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5BY2Nlc3NUb2tlbkdyYW50c0ludmFsaWRFcnJvciA9IEFjY2Vzc1Rva2VuR3JhbnRzSW52YWxpZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCAyMDEwNiwgeyB2YWx1ZTogQWNjZXNzVG9rZW5HcmFudHNJbnZhbGlkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBBY2Nlc3NUb2tlblNpZ25hdHVyZUludmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgdGhlIEFjY2Vzc1Rva2VuIHVzZWQgZm9yIGNvbm5lY3RpbmcgdG8gYSBSb29tIGhhcyBhbiBpbnZhbGlkIHNpZ25hdHVyZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDIwMTA3XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdJbnZhbGlkIEFjY2VzcyBUb2tlbiBzaWduYXR1cmUnXG4gKi9cbnZhciBBY2Nlc3NUb2tlblNpZ25hdHVyZUludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjZXNzVG9rZW5TaWduYXR1cmVJbnZhbGlkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjZXNzVG9rZW5TaWduYXR1cmVJbnZhbGlkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDIwMTA3LCAnSW52YWxpZCBBY2Nlc3MgVG9rZW4gc2lnbmF0dXJlJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBBY2Nlc3NUb2tlblNpZ25hdHVyZUludmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBY2Nlc3NUb2tlblNpZ25hdHVyZUludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuQWNjZXNzVG9rZW5TaWduYXR1cmVJbnZhbGlkRXJyb3IgPSBBY2Nlc3NUb2tlblNpZ25hdHVyZUludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgMjAxMDcsIHsgdmFsdWU6IEFjY2Vzc1Rva2VuU2lnbmF0dXJlSW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgU2lnbmFsaW5nQ29ubmVjdGlvbkVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciBhIHNpZ25hbGluZyBjb25uZWN0aW9uIGVycm9yIG9jY3VycyB0aGF0IGlzIG5vdCBjb3ZlcmVkIGJ5IGEgbW9yZSBzcGVjaWZpYyBlcnJvciBjb2RlLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMwMDBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1NpZ25hbGluZyBjb25uZWN0aW9uIGVycm9yJ1xuICovXG52YXIgU2lnbmFsaW5nQ29ubmVjdGlvbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWduYWxpbmdDb25uZWN0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2lnbmFsaW5nQ29ubmVjdGlvbkVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzAwMCwgJ1NpZ25hbGluZyBjb25uZWN0aW9uIGVycm9yJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBTaWduYWxpbmdDb25uZWN0aW9uRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2lnbmFsaW5nQ29ubmVjdGlvbkVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5TaWduYWxpbmdDb25uZWN0aW9uRXJyb3IgPSBTaWduYWxpbmdDb25uZWN0aW9uRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMDAwLCB7IHZhbHVlOiBTaWduYWxpbmdDb25uZWN0aW9uRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBTaWduYWxpbmdDb25uZWN0aW9uRGlzY29ubmVjdGVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbiBpcyB1bmV4cGVjdGVkbHkgZGlzY29ubmVjdGVkLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMwMDFcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1NpZ25hbGluZyBjb25uZWN0aW9uIGRpc2Nvbm5lY3RlZCdcbiAqL1xudmFyIFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMwMDEsICdTaWduYWxpbmcgY29ubmVjdGlvbiBkaXNjb25uZWN0ZWQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTaWduYWxpbmdDb25uZWN0aW9uRGlzY29ubmVjdGVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvciA9IFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMwMDEsIHsgdmFsdWU6IFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFNpZ25hbGluZ0Nvbm5lY3Rpb25UaW1lb3V0RXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW4gY29ubmVjdGlvbiBsaXZlbGluZXNzIGNoZWNrcyBmYWlsLCBvciB3aGVuIHRoZSBzaWduYWxpbmcgc2Vzc2lvbiBleHBpcmVzLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMwMDJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1NpZ25hbGluZyBjb25uZWN0aW9uIHRpbWVkIG91dCdcbiAqL1xudmFyIFNpZ25hbGluZ0Nvbm5lY3Rpb25UaW1lb3V0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ25hbGluZ0Nvbm5lY3Rpb25UaW1lb3V0RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2lnbmFsaW5nQ29ubmVjdGlvblRpbWVvdXRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMwMDIsICdTaWduYWxpbmcgY29ubmVjdGlvbiB0aW1lZCBvdXQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFNpZ25hbGluZ0Nvbm5lY3Rpb25UaW1lb3V0RXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2lnbmFsaW5nQ29ubmVjdGlvblRpbWVvdXRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuU2lnbmFsaW5nQ29ubmVjdGlvblRpbWVvdXRFcnJvciA9IFNpZ25hbGluZ0Nvbm5lY3Rpb25UaW1lb3V0RXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMDAyLCB7IHZhbHVlOiBTaWduYWxpbmdDb25uZWN0aW9uVGltZW91dEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgU2lnbmFsaW5nSW5jb21pbmdNZXNzYWdlSW52YWxpZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciB0aGUgQ2xpZW50IHJlY2VpdmVzIGEgbWVzc2FnZSBmcm9tIHRoZSBTZXJ2ZXIgdGhhdCB0aGUgQ2xpZW50IGNhbm5vdCBoYW5kbGUuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzAwM1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnQ2xpZW50IHJlY2VpdmVkIGFuIGludmFsaWQgc2lnbmFsaW5nIG1lc3NhZ2UnXG4gKi9cbnZhciBTaWduYWxpbmdJbmNvbWluZ01lc3NhZ2VJbnZhbGlkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ25hbGluZ0luY29taW5nTWVzc2FnZUludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaWduYWxpbmdJbmNvbWluZ01lc3NhZ2VJbnZhbGlkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMDAzLCAnQ2xpZW50IHJlY2VpdmVkIGFuIGludmFsaWQgc2lnbmFsaW5nIG1lc3NhZ2UnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFNpZ25hbGluZ0luY29taW5nTWVzc2FnZUludmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTaWduYWxpbmdJbmNvbWluZ01lc3NhZ2VJbnZhbGlkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlNpZ25hbGluZ0luY29taW5nTWVzc2FnZUludmFsaWRFcnJvciA9IFNpZ25hbGluZ0luY29taW5nTWVzc2FnZUludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMwMDMsIHsgdmFsdWU6IFNpZ25hbGluZ0luY29taW5nTWVzc2FnZUludmFsaWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFNpZ25hbGluZ091dGdvaW5nTWVzc2FnZUludmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgdGhlIENsaWVudCBzZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIFNlcnZlciB0aGF0IHRoZSBTZXJ2ZXIgY2Fubm90IGhhbmRsZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMDA0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdDbGllbnQgc2VudCBhbiBpbnZhbGlkIHNpZ25hbGluZyBtZXNzYWdlJ1xuICovXG52YXIgU2lnbmFsaW5nT3V0Z29pbmdNZXNzYWdlSW52YWxpZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWduYWxpbmdPdXRnb2luZ01lc3NhZ2VJbnZhbGlkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2lnbmFsaW5nT3V0Z29pbmdNZXNzYWdlSW52YWxpZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzAwNCwgJ0NsaWVudCBzZW50IGFuIGludmFsaWQgc2lnbmFsaW5nIG1lc3NhZ2UnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFNpZ25hbGluZ091dGdvaW5nTWVzc2FnZUludmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTaWduYWxpbmdPdXRnb2luZ01lc3NhZ2VJbnZhbGlkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlNpZ25hbGluZ091dGdvaW5nTWVzc2FnZUludmFsaWRFcnJvciA9IFNpZ25hbGluZ091dGdvaW5nTWVzc2FnZUludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMwMDQsIHsgdmFsdWU6IFNpZ25hbGluZ091dGdvaW5nTWVzc2FnZUludmFsaWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFNpZ25hbGluZ1NlcnZlckJ1c3lFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbiB0aGUgc2VydmVyIGlzIHRvbyBidXN5IHRvIGFjY2VwdCBuZXcgY2xpZW50cy5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMDA2XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdWaWRlbyBzZXJ2ZXIgaXMgYnVzeSdcbiAqL1xudmFyIFNpZ25hbGluZ1NlcnZlckJ1c3lFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbmFsaW5nU2VydmVyQnVzeUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ25hbGluZ1NlcnZlckJ1c3lFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMwMDYsICdWaWRlbyBzZXJ2ZXIgaXMgYnVzeScpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgU2lnbmFsaW5nU2VydmVyQnVzeUVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNpZ25hbGluZ1NlcnZlckJ1c3lFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuU2lnbmFsaW5nU2VydmVyQnVzeUVycm9yID0gU2lnbmFsaW5nU2VydmVyQnVzeUVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzAwNiwgeyB2YWx1ZTogU2lnbmFsaW5nU2VydmVyQnVzeUVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbU5hbWVJbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGEgUm9vbSBuYW1lIGlzIGludmFsaWQsIGFuZCB0aGUgc2NlbmFyaW8gaXMgbm90IGNvdmVyZWQgYnkgYSBtb3JlIHNwZWNpZmljIGVycm9yIGNvZGUuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzEwMFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnUm9vbSBuYW1lIGlzIGludmFsaWQnXG4gKi9cbnZhciBSb29tTmFtZUludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbU5hbWVJbnZhbGlkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm9vbU5hbWVJbnZhbGlkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMTAwLCAnUm9vbSBuYW1lIGlzIGludmFsaWQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJvb21OYW1lSW52YWxpZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvb21OYW1lSW52YWxpZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Sb29tTmFtZUludmFsaWRFcnJvciA9IFJvb21OYW1lSW52YWxpZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzEwMCwgeyB2YWx1ZTogUm9vbU5hbWVJbnZhbGlkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tTmFtZVRvb0xvbmdFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYSBSb29tIG5hbWUgaXMgdG9vIGxvbmcuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzEwMVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnUm9vbSBuYW1lIGlzIHRvbyBsb25nJ1xuICovXG52YXIgUm9vbU5hbWVUb29Mb25nRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21OYW1lVG9vTG9uZ0Vycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21OYW1lVG9vTG9uZ0Vycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzEwMSwgJ1Jvb20gbmFtZSBpcyB0b28gbG9uZycpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbU5hbWVUb29Mb25nRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbU5hbWVUb29Mb25nRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlJvb21OYW1lVG9vTG9uZ0Vycm9yID0gUm9vbU5hbWVUb29Mb25nRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTAxLCB7IHZhbHVlOiBSb29tTmFtZVRvb0xvbmdFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFJvb21OYW1lQ2hhcnNJbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGEgUm9vbSBuYW1lIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycy5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTAyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdSb29tIG5hbWUgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzJ1xuICovXG52YXIgUm9vbU5hbWVDaGFyc0ludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbU5hbWVDaGFyc0ludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tTmFtZUNoYXJzSW52YWxpZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzEwMiwgJ1Jvb20gbmFtZSBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJvb21OYW1lQ2hhcnNJbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbU5hbWVDaGFyc0ludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbU5hbWVDaGFyc0ludmFsaWRFcnJvciA9IFJvb21OYW1lQ2hhcnNJbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTAyLCB7IHZhbHVlOiBSb29tTmFtZUNoYXJzSW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbUNyZWF0ZUZhaWxlZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciB0aGUgU2VydmVyIGlzIHVuYWJsZSB0byBjcmVhdGUgYSBSb29tLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMDNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1VuYWJsZSB0byBjcmVhdGUgUm9vbSdcbiAqL1xudmFyIFJvb21DcmVhdGVGYWlsZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbUNyZWF0ZUZhaWxlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21DcmVhdGVGYWlsZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMxMDMsICdVbmFibGUgdG8gY3JlYXRlIFJvb20nKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJvb21DcmVhdGVGYWlsZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tQ3JlYXRlRmFpbGVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlJvb21DcmVhdGVGYWlsZWRFcnJvciA9IFJvb21DcmVhdGVGYWlsZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMDMsIHsgdmFsdWU6IFJvb21DcmVhdGVGYWlsZWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFJvb21Db25uZWN0RmFpbGVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGEgQ2xpZW50IGlzIHVuYWJsZSB0byBjb25uZWN0IHRvIGEgUm9vbSwgYW5kIHRoZSBzY2VuYXJpbyBpcyBub3QgY292ZXJlZCBieSBhIG1vcmUgc3BlY2lmaWMgZXJyb3IgY29kZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTA0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdVbmFibGUgdG8gY29ubmVjdCB0byBSb29tJ1xuICovXG52YXIgUm9vbUNvbm5lY3RGYWlsZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbUNvbm5lY3RGYWlsZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tQ29ubmVjdEZhaWxlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzEwNCwgJ1VuYWJsZSB0byBjb25uZWN0IHRvIFJvb20nKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJvb21Db25uZWN0RmFpbGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbUNvbm5lY3RGYWlsZWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbUNvbm5lY3RGYWlsZWRFcnJvciA9IFJvb21Db25uZWN0RmFpbGVkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTA0LCB7IHZhbHVlOiBSb29tQ29ubmVjdEZhaWxlZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbU1heFBhcnRpY2lwYW50c0V4Y2VlZGVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGEgQ2xpZW50IGlzIHVuYWJsZSB0byBjb25uZWN0IHRvIGEgUm9vbSBiZWNhdXNlIHRoZSBSb29tIGNvbnRhaW5zIHRvbyBtYW55IFBhcnRpY2lwYW50cy5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTA1XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdSb29tIGNvbnRhaW5zIHRvbyBtYW55IFBhcnRpY2lwYW50cydcbiAqL1xudmFyIFJvb21NYXhQYXJ0aWNpcGFudHNFeGNlZWRlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb29tTWF4UGFydGljaXBhbnRzRXhjZWVkZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tTWF4UGFydGljaXBhbnRzRXhjZWVkZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMxMDUsICdSb29tIGNvbnRhaW5zIHRvbyBtYW55IFBhcnRpY2lwYW50cycpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbU1heFBhcnRpY2lwYW50c0V4Y2VlZGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbU1heFBhcnRpY2lwYW50c0V4Y2VlZGVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlJvb21NYXhQYXJ0aWNpcGFudHNFeGNlZWRlZEVycm9yID0gUm9vbU1heFBhcnRpY2lwYW50c0V4Y2VlZGVkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTA1LCB7IHZhbHVlOiBSb29tTWF4UGFydGljaXBhbnRzRXhjZWVkZWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFJvb21Ob3RGb3VuZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciBhdHRlbXB0aW5nIG9wZXJhdGlvbiBvbiBhIG5vbi1leGlzdGVudCBSb29tLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMDZcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1Jvb20gbm90IGZvdW5kJ1xuICovXG52YXIgUm9vbU5vdEZvdW5kRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21Ob3RGb3VuZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21Ob3RGb3VuZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzEwNiwgJ1Jvb20gbm90IGZvdW5kJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSb29tTm90Rm91bmRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tTm90Rm91bmRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbU5vdEZvdW5kRXJyb3IgPSBSb29tTm90Rm91bmRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMDYsIHsgdmFsdWU6IFJvb21Ob3RGb3VuZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbU1heFBhcnRpY2lwYW50c091dE9mUmFuZ2VFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgaW4gdGhlIFJFU1QgQVBJIHdoZW4gTWF4UGFydGljaXBhbnRzIGlzIHNldCBvdXQgb2YgcmFuZ2UuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzEwN1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnTWF4UGFydGljaXBhbnRzIGlzIG91dCBvZiByYW5nZSdcbiAqL1xudmFyIFJvb21NYXhQYXJ0aWNpcGFudHNPdXRPZlJhbmdlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21NYXhQYXJ0aWNpcGFudHNPdXRPZlJhbmdlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm9vbU1heFBhcnRpY2lwYW50c091dE9mUmFuZ2VFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMxMDcsICdNYXhQYXJ0aWNpcGFudHMgaXMgb3V0IG9mIHJhbmdlJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSb29tTWF4UGFydGljaXBhbnRzT3V0T2ZSYW5nZUVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvb21NYXhQYXJ0aWNpcGFudHNPdXRPZlJhbmdlRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlJvb21NYXhQYXJ0aWNpcGFudHNPdXRPZlJhbmdlRXJyb3IgPSBSb29tTWF4UGFydGljaXBhbnRzT3V0T2ZSYW5nZUVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzEwNywgeyB2YWx1ZTogUm9vbU1heFBhcnRpY2lwYW50c091dE9mUmFuZ2VFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFJvb21UeXBlSW52YWxpZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCBpbiB0aGUgUkVTVCBBUEkgd2hlbiB0aGUgdXNlciBhdHRlbXB0cyB0byBjcmVhdGUgYSBSb29tIHdpdGggYW4gaW52YWxpZCBSb29tVHlwZVxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMDhcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1Jvb21UeXBlIGlzIG5vdCB2YWxpZCdcbiAqL1xudmFyIFJvb21UeXBlSW52YWxpZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb29tVHlwZUludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tVHlwZUludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMxMDgsICdSb29tVHlwZSBpcyBub3QgdmFsaWQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJvb21UeXBlSW52YWxpZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvb21UeXBlSW52YWxpZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Sb29tVHlwZUludmFsaWRFcnJvciA9IFJvb21UeXBlSW52YWxpZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzEwOCwgeyB2YWx1ZTogUm9vbVR5cGVJbnZhbGlkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tVGltZW91dE91dE9mUmFuZ2VFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgaW4gdGhlIFJFU1QgQVBJIHdoZW4gVGltZW91dCBpcyBzZXQgb3V0IG9mIHJhbmdlLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMDlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1RpbWVvdXQgaXMgb3V0IG9mIHJhbmdlJ1xuICovXG52YXIgUm9vbVRpbWVvdXRPdXRPZlJhbmdlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21UaW1lb3V0T3V0T2ZSYW5nZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21UaW1lb3V0T3V0T2ZSYW5nZUVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzEwOSwgJ1RpbWVvdXQgaXMgb3V0IG9mIHJhbmdlJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSb29tVGltZW91dE91dE9mUmFuZ2VFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tVGltZW91dE91dE9mUmFuZ2VFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbVRpbWVvdXRPdXRPZlJhbmdlRXJyb3IgPSBSb29tVGltZW91dE91dE9mUmFuZ2VFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMDksIHsgdmFsdWU6IFJvb21UaW1lb3V0T3V0T2ZSYW5nZUVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbVN0YXR1c0NhbGxiYWNrTWV0aG9kSW52YWxpZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCBpbiB0aGUgUkVTVCBBUEkgd2hlbiBTdGF0dXNDYWxsYmFja01ldGhvZCBpcyBzZXQgdG8gYW4gaW52YWxpZCB2YWx1ZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTEwXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdTdGF0dXNDYWxsYmFja01ldGhvZCBpcyBpbnZhbGlkJ1xuICovXG52YXIgUm9vbVN0YXR1c0NhbGxiYWNrTWV0aG9kSW52YWxpZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb29tU3RhdHVzQ2FsbGJhY2tNZXRob2RJbnZhbGlkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm9vbVN0YXR1c0NhbGxiYWNrTWV0aG9kSW52YWxpZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzExMCwgJ1N0YXR1c0NhbGxiYWNrTWV0aG9kIGlzIGludmFsaWQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJvb21TdGF0dXNDYWxsYmFja01ldGhvZEludmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tU3RhdHVzQ2FsbGJhY2tNZXRob2RJbnZhbGlkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlJvb21TdGF0dXNDYWxsYmFja01ldGhvZEludmFsaWRFcnJvciA9IFJvb21TdGF0dXNDYWxsYmFja01ldGhvZEludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMTAsIHsgdmFsdWU6IFJvb21TdGF0dXNDYWxsYmFja01ldGhvZEludmFsaWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFJvb21TdGF0dXNDYWxsYmFja0ludmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgaW4gdGhlIFJFU1QgQVBJIHdoZW4gU3RhdHVzQ2FsbGJhY2sgaXMgbm90IGEgdmFsaWQgVVJMIG9yIHRoZSB1cmwgaXMgdG9vIGxvbmcuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzExMVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnU3RhdHVzQ2FsbGJhY2sgaXMgaW52YWxpZCdcbiAqL1xudmFyIFJvb21TdGF0dXNDYWxsYmFja0ludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbVN0YXR1c0NhbGxiYWNrSW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21TdGF0dXNDYWxsYmFja0ludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMxMTEsICdTdGF0dXNDYWxsYmFjayBpcyBpbnZhbGlkJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSb29tU3RhdHVzQ2FsbGJhY2tJbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbVN0YXR1c0NhbGxiYWNrSW52YWxpZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Sb29tU3RhdHVzQ2FsbGJhY2tJbnZhbGlkRXJyb3IgPSBSb29tU3RhdHVzQ2FsbGJhY2tJbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTExLCB7IHZhbHVlOiBSb29tU3RhdHVzQ2FsbGJhY2tJbnZhbGlkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tU3RhdHVzSW52YWxpZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCBpbiB0aGUgUkVTVCBBUEkgd2hlbiBTdGF0dXMgaXMgbm90IHZhbGlkIG9yIHRoZSBSb29tIGlzIG5vdCBpbi1wcm9ncmVzcy5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTEyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdTdGF0dXMgaXMgaW52YWxpZCdcbiAqL1xudmFyIFJvb21TdGF0dXNJbnZhbGlkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21TdGF0dXNJbnZhbGlkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm9vbVN0YXR1c0ludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMxMTIsICdTdGF0dXMgaXMgaW52YWxpZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbVN0YXR1c0ludmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tU3RhdHVzSW52YWxpZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Sb29tU3RhdHVzSW52YWxpZEVycm9yID0gUm9vbVN0YXR1c0ludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMTIsIHsgdmFsdWU6IFJvb21TdGF0dXNJbnZhbGlkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tUm9vbUV4aXN0c0Vycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCBpbiB0aGUgUkVTVCBBUEkgd2hlbiB0aGUgUm9vbSBjcmVhdGlvbiBmYWlscyBiZWNhdXNlIGEgUm9vbSBleGlzdHMgd2l0aCB0aGUgc2FtZSBuYW1lLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMTNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1Jvb20gZXhpc3RzJ1xuICovXG52YXIgUm9vbVJvb21FeGlzdHNFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbVJvb21FeGlzdHNFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tUm9vbUV4aXN0c0Vycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzExMywgJ1Jvb20gZXhpc3RzJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSb29tUm9vbUV4aXN0c0Vycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvb21Sb29tRXhpc3RzRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlJvb21Sb29tRXhpc3RzRXJyb3IgPSBSb29tUm9vbUV4aXN0c0Vycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzExMywgeyB2YWx1ZTogUm9vbVJvb21FeGlzdHNFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFJvb21JbnZhbGlkUGFyYW1ldGVyc0Vycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCBpbiB0aGUgUkVTVCBBUEkgd2hlbiBvbmUgb3IgbW9yZSBSb29tIGNyZWF0aW9uIHBhcmFtZXRlciBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgUm9vbSB0eXBlLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMTRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1Jvb20gY3JlYXRpb24gcGFyYW1ldGVyKHMpIGluY29tcGF0aWJsZSB3aXRoIHRoZSBSb29tIHR5cGUnXG4gKi9cbnZhciBSb29tSW52YWxpZFBhcmFtZXRlcnNFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbUludmFsaWRQYXJhbWV0ZXJzRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm9vbUludmFsaWRQYXJhbWV0ZXJzRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMTE0LCAnUm9vbSBjcmVhdGlvbiBwYXJhbWV0ZXIocykgaW5jb21wYXRpYmxlIHdpdGggdGhlIFJvb20gdHlwZScpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbUludmFsaWRQYXJhbWV0ZXJzRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbUludmFsaWRQYXJhbWV0ZXJzRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlJvb21JbnZhbGlkUGFyYW1ldGVyc0Vycm9yID0gUm9vbUludmFsaWRQYXJhbWV0ZXJzRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTE0LCB7IHZhbHVlOiBSb29tSW52YWxpZFBhcmFtZXRlcnNFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFJvb21NZWRpYVJlZ2lvbkludmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgaW4gdGhlIFJFU1QgQVBJIHdoZW4gTWVkaWFSZWdpb24gaXMgc2V0IHRvIGFuIGludmFsaWQgdmFsdWUuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzExNVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnTWVkaWFSZWdpb24gaXMgaW52YWxpZCdcbiAqL1xudmFyIFJvb21NZWRpYVJlZ2lvbkludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbU1lZGlhUmVnaW9uSW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21NZWRpYVJlZ2lvbkludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMxMTUsICdNZWRpYVJlZ2lvbiBpcyBpbnZhbGlkJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSb29tTWVkaWFSZWdpb25JbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbU1lZGlhUmVnaW9uSW52YWxpZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Sb29tTWVkaWFSZWdpb25JbnZhbGlkRXJyb3IgPSBSb29tTWVkaWFSZWdpb25JbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTE1LCB7IHZhbHVlOiBSb29tTWVkaWFSZWdpb25JbnZhbGlkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tTWVkaWFSZWdpb25VbmF2YWlsYWJsZUVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCBpbiB0aGUgUkVTVCBBUEkgd2hlbiBNZWRpYVJlZ2lvbiBpcyBzZXQgdG8gYSB2YWxpZCB2YWx1ZSBidXQgbm8gbWVkaWEgc2VydmVycyBhcmUgYXZhaWxhYmxlLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMTZcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1RoZXJlIGFyZSBubyBtZWRpYSBzZXJ2ZXJzIGF2YWlsYWJsZSBpbiB0aGUgTWVkaWFSZWdpb24nXG4gKi9cbnZhciBSb29tTWVkaWFSZWdpb25VbmF2YWlsYWJsZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb29tTWVkaWFSZWdpb25VbmF2YWlsYWJsZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21NZWRpYVJlZ2lvblVuYXZhaWxhYmxlRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMTE2LCAnVGhlcmUgYXJlIG5vIG1lZGlhIHNlcnZlcnMgYXZhaWxhYmxlIGluIHRoZSBNZWRpYVJlZ2lvbicpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbU1lZGlhUmVnaW9uVW5hdmFpbGFibGVFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tTWVkaWFSZWdpb25VbmF2YWlsYWJsZUVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Sb29tTWVkaWFSZWdpb25VbmF2YWlsYWJsZUVycm9yID0gUm9vbU1lZGlhUmVnaW9uVW5hdmFpbGFibGVFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMTYsIHsgdmFsdWU6IFJvb21NZWRpYVJlZ2lvblVuYXZhaWxhYmxlRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tU3Vic2NyaXB0aW9uT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIHRoZSBzdWJzY3JpcHRpb24gb3BlcmF0aW9uIHJlcXVlc3RlZCBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGUgUm9vbSB0eXBlLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMTdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1RoZSBzdWJzY3JpcHRpb24gb3BlcmF0aW9uIHJlcXVlc3RlZCBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGUgUm9vbSB0eXBlJ1xuICovXG52YXIgUm9vbVN1YnNjcmlwdGlvbk9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb29tU3Vic2NyaXB0aW9uT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm9vbVN1YnNjcmlwdGlvbk9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzExNywgJ1RoZSBzdWJzY3JpcHRpb24gb3BlcmF0aW9uIHJlcXVlc3RlZCBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGUgUm9vbSB0eXBlJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSb29tU3Vic2NyaXB0aW9uT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbVN1YnNjcmlwdGlvbk9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Sb29tU3Vic2NyaXB0aW9uT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IgPSBSb29tU3Vic2NyaXB0aW9uT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTE3LCB7IHZhbHVlOiBSb29tU3Vic2NyaXB0aW9uT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tQ29tcGxldGVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGEgUm9vbSBpcyBjb21wbGV0ZWQgdmlhIHRoZSBSRVNUIEFQSS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTE4XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdSb29tIGNvbXBsZXRlZCdcbiAqL1xudmFyIFJvb21Db21wbGV0ZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbUNvbXBsZXRlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21Db21wbGV0ZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMxMTgsICdSb29tIGNvbXBsZXRlZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbUNvbXBsZXRlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvb21Db21wbGV0ZWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbUNvbXBsZXRlZEVycm9yID0gUm9vbUNvbXBsZXRlZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzExOCwgeyB2YWx1ZTogUm9vbUNvbXBsZXRlZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbUF1ZGlvT25seUZsYWdOb3RTdXBwb3J0ZWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYSBwYXJ0aWNpcGFudCB0cmllcyB0byBzZXQgdGhlIEF1ZGlvT25seSBmbGFnIGZvciBhIFJvb20gdHlwZSBvdGhlciB0aGFuIEdyb3VwIFJvb21zLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMjRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1RoZSBBdWRpb09ubHkgZmxhZyBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGUgUm9vbSB0eXBlJ1xuICovXG52YXIgUm9vbUF1ZGlvT25seUZsYWdOb3RTdXBwb3J0ZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbUF1ZGlvT25seUZsYWdOb3RTdXBwb3J0ZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tQXVkaW9Pbmx5RmxhZ05vdFN1cHBvcnRlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzEyNCwgJ1RoZSBBdWRpb09ubHkgZmxhZyBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGUgUm9vbSB0eXBlJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSb29tQXVkaW9Pbmx5RmxhZ05vdFN1cHBvcnRlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvb21BdWRpb09ubHlGbGFnTm90U3VwcG9ydGVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlJvb21BdWRpb09ubHlGbGFnTm90U3VwcG9ydGVkRXJyb3IgPSBSb29tQXVkaW9Pbmx5RmxhZ05vdFN1cHBvcnRlZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzEyNCwgeyB2YWx1ZTogUm9vbUF1ZGlvT25seUZsYWdOb3RTdXBwb3J0ZWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFJvb21UcmFja0tpbmROb3RTdXBwb3J0ZWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYSBwYXJ0aWNpcGFudCB0cmllcyB0byBwdWJsaXNoIGEgdHJhY2sgb3IgY29ubmVjdHMgd2l0aCBhIHRyYWNrIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgZ3JvdXAgcm9vbS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTI1XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdUaGUgdHJhY2sga2luZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBSb29tJ1xuICovXG52YXIgUm9vbVRyYWNrS2luZE5vdFN1cHBvcnRlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb29tVHJhY2tLaW5kTm90U3VwcG9ydGVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm9vbVRyYWNrS2luZE5vdFN1cHBvcnRlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzEyNSwgJ1RoZSB0cmFjayBraW5kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIFJvb20nKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJvb21UcmFja0tpbmROb3RTdXBwb3J0ZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tVHJhY2tLaW5kTm90U3VwcG9ydGVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlJvb21UcmFja0tpbmROb3RTdXBwb3J0ZWRFcnJvciA9IFJvb21UcmFja0tpbmROb3RTdXBwb3J0ZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMjUsIHsgdmFsdWU6IFJvb21UcmFja0tpbmROb3RTdXBwb3J0ZWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFBhcnRpY2lwYW50SWRlbnRpdHlJbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGEgUGFydGljaXBhbnQgaWRlbnRpdHkgaXMgaW52YWxpZCwgYW5kIHRoZSBzY2VuYXJpbyBpcyBub3QgY292ZXJlZCBieSBhIG1vcmUgc3BlY2lmaWMgZXJyb3IgY29kZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMjAwXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdQYXJ0aWNpcGFudCBpZGVudGl0eSBpcyBpbnZhbGlkJ1xuICovXG52YXIgUGFydGljaXBhbnRJZGVudGl0eUludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFydGljaXBhbnRJZGVudGl0eUludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJ0aWNpcGFudElkZW50aXR5SW52YWxpZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzIwMCwgJ1BhcnRpY2lwYW50IGlkZW50aXR5IGlzIGludmFsaWQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFBhcnRpY2lwYW50SWRlbnRpdHlJbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGFydGljaXBhbnRJZGVudGl0eUludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUGFydGljaXBhbnRJZGVudGl0eUludmFsaWRFcnJvciA9IFBhcnRpY2lwYW50SWRlbnRpdHlJbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMjAwLCB7IHZhbHVlOiBQYXJ0aWNpcGFudElkZW50aXR5SW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUGFydGljaXBhbnRJZGVudGl0eVRvb0xvbmdFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYSBQYXJ0aWNpcGFudCBpZGVudGl0eSBpcyB0b28gbG9uZy5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMjAxXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdQYXJ0aWNpcGFudCBpZGVudGl0eSBpcyB0b28gbG9uZydcbiAqL1xudmFyIFBhcnRpY2lwYW50SWRlbnRpdHlUb29Mb25nRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcnRpY2lwYW50SWRlbnRpdHlUb29Mb25nRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFydGljaXBhbnRJZGVudGl0eVRvb0xvbmdFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMyMDEsICdQYXJ0aWNpcGFudCBpZGVudGl0eSBpcyB0b28gbG9uZycpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUGFydGljaXBhbnRJZGVudGl0eVRvb0xvbmdFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYXJ0aWNpcGFudElkZW50aXR5VG9vTG9uZ0Vycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5QYXJ0aWNpcGFudElkZW50aXR5VG9vTG9uZ0Vycm9yID0gUGFydGljaXBhbnRJZGVudGl0eVRvb0xvbmdFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMyMDEsIHsgdmFsdWU6IFBhcnRpY2lwYW50SWRlbnRpdHlUb29Mb25nRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBQYXJ0aWNpcGFudElkZW50aXR5Q2hhcnNJbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGEgUGFydGljaXBhbnQgaWRlbnRpdHkgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMyMDJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1BhcnRpY2lwYW50IGlkZW50aXR5IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycydcbiAqL1xudmFyIFBhcnRpY2lwYW50SWRlbnRpdHlDaGFyc0ludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFydGljaXBhbnRJZGVudGl0eUNoYXJzSW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhcnRpY2lwYW50SWRlbnRpdHlDaGFyc0ludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMyMDIsICdQYXJ0aWNpcGFudCBpZGVudGl0eSBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFBhcnRpY2lwYW50SWRlbnRpdHlDaGFyc0ludmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYXJ0aWNpcGFudElkZW50aXR5Q2hhcnNJbnZhbGlkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlBhcnRpY2lwYW50SWRlbnRpdHlDaGFyc0ludmFsaWRFcnJvciA9IFBhcnRpY2lwYW50SWRlbnRpdHlDaGFyc0ludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMyMDIsIHsgdmFsdWU6IFBhcnRpY2lwYW50SWRlbnRpdHlDaGFyc0ludmFsaWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYSBQYXJ0aWNpcGFudCB0cmllcyB0byBwdWJsaXNoIGEgVHJhY2sgYW5kIHRoZSBtYXhpbXVtIG51bWJlciBvZiBwdWJsaXNoZWQgdHJhY2tzIGFsbG93ZWQgaW4gdGhlIFJvb20gYXQgdGhlIHNhbWUgdGltZSBoYXMgYmVlbiByZWFjaGVkXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzIwM1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnVGhlIG1heGltdW0gbnVtYmVyIG9mIHB1Ymxpc2hlZCB0cmFja3MgYWxsb3dlZCBpbiB0aGUgUm9vbSBhdCB0aGUgc2FtZSB0aW1lIGhhcyBiZWVuIHJlYWNoZWQnXG4gKi9cbnZhciBQYXJ0aWNpcGFudE1heFRyYWNrc0V4Y2VlZGVkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJ0aWNpcGFudE1heFRyYWNrc0V4Y2VlZGVkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMjAzLCAnVGhlIG1heGltdW0gbnVtYmVyIG9mIHB1Ymxpc2hlZCB0cmFja3MgYWxsb3dlZCBpbiB0aGUgUm9vbSBhdCB0aGUgc2FtZSB0aW1lIGhhcyBiZWVuIHJlYWNoZWQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYXJ0aWNpcGFudE1heFRyYWNrc0V4Y2VlZGVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvciA9IFBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMyMDMsIHsgdmFsdWU6IFBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFBhcnRpY2lwYW50Tm90Rm91bmRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYXR0ZW1wdGluZyBhbiBvcGVyYXRpb24gb24gYSBub24tZXhpc3RlbnQgUGFydGljaXBhbnQuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzIwNFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnUGFydGljaXBhbnQgbm90IGZvdW5kJ1xuICovXG52YXIgUGFydGljaXBhbnROb3RGb3VuZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYXJ0aWNpcGFudE5vdEZvdW5kRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFydGljaXBhbnROb3RGb3VuZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzIwNCwgJ1BhcnRpY2lwYW50IG5vdCBmb3VuZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUGFydGljaXBhbnROb3RGb3VuZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhcnRpY2lwYW50Tm90Rm91bmRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUGFydGljaXBhbnROb3RGb3VuZEVycm9yID0gUGFydGljaXBhbnROb3RGb3VuZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzIwNCwgeyB2YWx1ZTogUGFydGljaXBhbnROb3RGb3VuZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUGFydGljaXBhbnREdXBsaWNhdGVJZGVudGl0eUVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCBieSB0aGUgc2VydmVyIHRvIHRoZSBleGlzdGluZyBQYXJ0aWNpcGFudCB3aGVuIGEgbmV3IFBhcnRpY2lwYW50IGpvaW5zIGEgUm9vbSB3aXRoIHRoZSBzYW1lIGlkZW50aXR5IGFzIHRoZSBleGlzdGluZyBQYXJ0aWNpcGFudC5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMjA1XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdQYXJ0aWNpcGFudCBkaXNjb25uZWN0ZWQgYmVjYXVzZSBvZiBkdXBsaWNhdGUgaWRlbnRpdHknXG4gKi9cbnZhciBQYXJ0aWNpcGFudER1cGxpY2F0ZUlkZW50aXR5RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcnRpY2lwYW50RHVwbGljYXRlSWRlbnRpdHlFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJ0aWNpcGFudER1cGxpY2F0ZUlkZW50aXR5RXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMjA1LCAnUGFydGljaXBhbnQgZGlzY29ubmVjdGVkIGJlY2F1c2Ugb2YgZHVwbGljYXRlIGlkZW50aXR5JykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBQYXJ0aWNpcGFudER1cGxpY2F0ZUlkZW50aXR5RXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGFydGljaXBhbnREdXBsaWNhdGVJZGVudGl0eUVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5QYXJ0aWNpcGFudER1cGxpY2F0ZUlkZW50aXR5RXJyb3IgPSBQYXJ0aWNpcGFudER1cGxpY2F0ZUlkZW50aXR5RXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMjA1LCB7IHZhbHVlOiBQYXJ0aWNpcGFudER1cGxpY2F0ZUlkZW50aXR5RXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBUcmFja0ludmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYSBUcmFjayBpcyBpbnZhbGlkLCBhbmQgdGhlIHNjZW5hcmlvIGlzIG5vdCBjb3ZlcmVkIGJ5IGEgbW9yZSBzcGVjaWZpYyBlcnJvciBjb2RlLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMzMDBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1RyYWNrIGlzIGludmFsaWQnXG4gKi9cbnZhciBUcmFja0ludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJhY2tJbnZhbGlkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJhY2tJbnZhbGlkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMzAwLCAnVHJhY2sgaXMgaW52YWxpZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgVHJhY2tJbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVHJhY2tJbnZhbGlkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlRyYWNrSW52YWxpZEVycm9yID0gVHJhY2tJbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMzAwLCB7IHZhbHVlOiBUcmFja0ludmFsaWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFRyYWNrTmFtZUludmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYSBUcmFjayBuYW1lIGlzIGludmFsaWQsIGFuZCB0aGUgc2NlbmFyaW8gaXMgbm90IGNvdmVyZWQgYnkgYSBtb3JlIHNwZWNpZmljIGVycm9yIGNvZGUuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzMwMVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnVHJhY2sgbmFtZSBpcyBpbnZhbGlkJ1xuICovXG52YXIgVHJhY2tOYW1lSW52YWxpZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFja05hbWVJbnZhbGlkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJhY2tOYW1lSW52YWxpZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzMwMSwgJ1RyYWNrIG5hbWUgaXMgaW52YWxpZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgVHJhY2tOYW1lSW52YWxpZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRyYWNrTmFtZUludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuVHJhY2tOYW1lSW52YWxpZEVycm9yID0gVHJhY2tOYW1lSW52YWxpZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzMwMSwgeyB2YWx1ZTogVHJhY2tOYW1lSW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgVHJhY2tOYW1lVG9vTG9uZ0Vycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciBhIFRyYWNrIG5hbWUgaXMgdG9vIGxvbmcuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzMwMlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnVHJhY2sgbmFtZSBpcyB0b28gbG9uZydcbiAqL1xudmFyIFRyYWNrTmFtZVRvb0xvbmdFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJhY2tOYW1lVG9vTG9uZ0Vycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyYWNrTmFtZVRvb0xvbmdFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMzMDIsICdUcmFjayBuYW1lIGlzIHRvbyBsb25nJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBUcmFja05hbWVUb29Mb25nRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVHJhY2tOYW1lVG9vTG9uZ0Vycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5UcmFja05hbWVUb29Mb25nRXJyb3IgPSBUcmFja05hbWVUb29Mb25nRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMzAyLCB7IHZhbHVlOiBUcmFja05hbWVUb29Mb25nRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBUcmFja05hbWVDaGFyc0ludmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYSBUcmFjayBuYW1lIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycy5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMzAzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdUcmFjayBuYW1lIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycydcbiAqL1xudmFyIFRyYWNrTmFtZUNoYXJzSW52YWxpZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFja05hbWVDaGFyc0ludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFja05hbWVDaGFyc0ludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMzMDMsICdUcmFjayBuYW1lIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycycpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgVHJhY2tOYW1lQ2hhcnNJbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVHJhY2tOYW1lQ2hhcnNJbnZhbGlkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlRyYWNrTmFtZUNoYXJzSW52YWxpZEVycm9yID0gVHJhY2tOYW1lQ2hhcnNJbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMzAzLCB7IHZhbHVlOiBUcmFja05hbWVDaGFyc0ludmFsaWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFRyYWNrTmFtZUlzRHVwbGljYXRlZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciBhIFBhcnRpY2lwYW50IGlzIGN1cnJlbnRseSBwdWJsaXNoaW5nIGEgVHJhY2sgd2l0aCB0aGUgc2FtZSBuYW1lLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMzMDRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1RyYWNrIG5hbWUgaXMgZHVwbGljYXRlZCdcbiAqL1xudmFyIFRyYWNrTmFtZUlzRHVwbGljYXRlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFja05hbWVJc0R1cGxpY2F0ZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFja05hbWVJc0R1cGxpY2F0ZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMzMDQsICdUcmFjayBuYW1lIGlzIGR1cGxpY2F0ZWQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFRyYWNrTmFtZUlzRHVwbGljYXRlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRyYWNrTmFtZUlzRHVwbGljYXRlZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5UcmFja05hbWVJc0R1cGxpY2F0ZWRFcnJvciA9IFRyYWNrTmFtZUlzRHVwbGljYXRlZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzMwNCwgeyB2YWx1ZTogVHJhY2tOYW1lSXNEdXBsaWNhdGVkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBUcmFja1NlcnZlclRyYWNrQ2FwYWNpdHlSZWFjaGVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgVGhlIHNlcnZlciBkb2VzIG5vdCBoYXZlIGVub3VnaCByZXNvdXJjZXMgYXZhaWxhYmxlIHRvIGNyZWF0ZSBhIG5ldyBUcmFjay5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMzA1XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdUaGUgc2VydmVyIGhhcyByZWFjaGVkIGNhcGFjaXR5IGFuZCBjYW5ub3QgZnVsZmlsbCB0aGlzIHJlcXVlc3QnXG4gKi9cbnZhciBUcmFja1NlcnZlclRyYWNrQ2FwYWNpdHlSZWFjaGVkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYWNrU2VydmVyVHJhY2tDYXBhY2l0eVJlYWNoZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFja1NlcnZlclRyYWNrQ2FwYWNpdHlSZWFjaGVkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMzA1LCAnVGhlIHNlcnZlciBoYXMgcmVhY2hlZCBjYXBhY2l0eSBhbmQgY2Fubm90IGZ1bGZpbGwgdGhpcyByZXF1ZXN0JykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBUcmFja1NlcnZlclRyYWNrQ2FwYWNpdHlSZWFjaGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVHJhY2tTZXJ2ZXJUcmFja0NhcGFjaXR5UmVhY2hlZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5UcmFja1NlcnZlclRyYWNrQ2FwYWNpdHlSZWFjaGVkRXJyb3IgPSBUcmFja1NlcnZlclRyYWNrQ2FwYWNpdHlSZWFjaGVkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMzA1LCB7IHZhbHVlOiBUcmFja1NlcnZlclRyYWNrQ2FwYWNpdHlSZWFjaGVkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBNZWRpYUNsaWVudExvY2FsRGVzY0ZhaWxlZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciBhIENsaWVudCBpcyB1bmFibGUgdG8gY3JlYXRlIG9yIGFwcGx5IGEgbG9jYWwgbWVkaWEgZGVzY3JpcHRpb24uXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzQwMFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnQ2xpZW50IGlzIHVuYWJsZSB0byBjcmVhdGUgb3IgYXBwbHkgYSBsb2NhbCBtZWRpYSBkZXNjcmlwdGlvbidcbiAqL1xudmFyIE1lZGlhQ2xpZW50TG9jYWxEZXNjRmFpbGVkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lZGlhQ2xpZW50TG9jYWxEZXNjRmFpbGVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVkaWFDbGllbnRMb2NhbERlc2NGYWlsZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTM0MDAsICdDbGllbnQgaXMgdW5hYmxlIHRvIGNyZWF0ZSBvciBhcHBseSBhIGxvY2FsIG1lZGlhIGRlc2NyaXB0aW9uJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNZWRpYUNsaWVudExvY2FsRGVzY0ZhaWxlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lZGlhQ2xpZW50TG9jYWxEZXNjRmFpbGVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLk1lZGlhQ2xpZW50TG9jYWxEZXNjRmFpbGVkRXJyb3IgPSBNZWRpYUNsaWVudExvY2FsRGVzY0ZhaWxlZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzQwMCwgeyB2YWx1ZTogTWVkaWFDbGllbnRMb2NhbERlc2NGYWlsZWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIE1lZGlhU2VydmVyTG9jYWxEZXNjRmFpbGVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIHRoZSBTZXJ2ZXIgaXMgdW5hYmxlIHRvIGNyZWF0ZSBvciBhcHBseSBhIGxvY2FsIG1lZGlhIGRlc2NyaXB0aW9uLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTM0MDFcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1NlcnZlciBpcyB1bmFibGUgdG8gY3JlYXRlIG9yIGFwcGx5IGEgbG9jYWwgbWVkaWEgZGVzY3JpcHRpb24nXG4gKi9cbnZhciBNZWRpYVNlcnZlckxvY2FsRGVzY0ZhaWxlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZWRpYVNlcnZlckxvY2FsRGVzY0ZhaWxlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lZGlhU2VydmVyTG9jYWxEZXNjRmFpbGVkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzNDAxLCAnU2VydmVyIGlzIHVuYWJsZSB0byBjcmVhdGUgb3IgYXBwbHkgYSBsb2NhbCBtZWRpYSBkZXNjcmlwdGlvbicpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgTWVkaWFTZXJ2ZXJMb2NhbERlc2NGYWlsZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZWRpYVNlcnZlckxvY2FsRGVzY0ZhaWxlZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5NZWRpYVNlcnZlckxvY2FsRGVzY0ZhaWxlZEVycm9yID0gTWVkaWFTZXJ2ZXJMb2NhbERlc2NGYWlsZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTM0MDEsIHsgdmFsdWU6IE1lZGlhU2VydmVyTG9jYWxEZXNjRmFpbGVkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBNZWRpYUNsaWVudFJlbW90ZURlc2NGYWlsZWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgdGhlIENsaWVudCByZWNlaXZlcyBhIHJlbW90ZSBtZWRpYSBkZXNjcmlwdGlvbiBidXQgaXMgdW5hYmxlIHRvIGFwcGx5IGl0LlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTM0MDJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ0NsaWVudCBpcyB1bmFibGUgdG8gYXBwbHkgYSByZW1vdGUgbWVkaWEgZGVzY3JpcHRpb24nXG4gKi9cbnZhciBNZWRpYUNsaWVudFJlbW90ZURlc2NGYWlsZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVkaWFDbGllbnRSZW1vdGVEZXNjRmFpbGVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVkaWFDbGllbnRSZW1vdGVEZXNjRmFpbGVkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzNDAyLCAnQ2xpZW50IGlzIHVuYWJsZSB0byBhcHBseSBhIHJlbW90ZSBtZWRpYSBkZXNjcmlwdGlvbicpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgTWVkaWFDbGllbnRSZW1vdGVEZXNjRmFpbGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWVkaWFDbGllbnRSZW1vdGVEZXNjRmFpbGVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLk1lZGlhQ2xpZW50UmVtb3RlRGVzY0ZhaWxlZEVycm9yID0gTWVkaWFDbGllbnRSZW1vdGVEZXNjRmFpbGVkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzNDAyLCB7IHZhbHVlOiBNZWRpYUNsaWVudFJlbW90ZURlc2NGYWlsZWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIE1lZGlhU2VydmVyUmVtb3RlRGVzY0ZhaWxlZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciB0aGUgU2VydmVyIHJlY2VpdmVzIGEgcmVtb3RlIG1lZGlhIGRlc2NyaXB0aW9uIGJ1dCBpcyB1bmFibGUgdG8gYXBwbHkgaXQuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzQwM1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnU2VydmVyIGlzIHVuYWJsZSB0byBhcHBseSBhIHJlbW90ZSBtZWRpYSBkZXNjcmlwdGlvbidcbiAqL1xudmFyIE1lZGlhU2VydmVyUmVtb3RlRGVzY0ZhaWxlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZWRpYVNlcnZlclJlbW90ZURlc2NGYWlsZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZWRpYVNlcnZlclJlbW90ZURlc2NGYWlsZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTM0MDMsICdTZXJ2ZXIgaXMgdW5hYmxlIHRvIGFwcGx5IGEgcmVtb3RlIG1lZGlhIGRlc2NyaXB0aW9uJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNZWRpYVNlcnZlclJlbW90ZURlc2NGYWlsZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZWRpYVNlcnZlclJlbW90ZURlc2NGYWlsZWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuTWVkaWFTZXJ2ZXJSZW1vdGVEZXNjRmFpbGVkRXJyb3IgPSBNZWRpYVNlcnZlclJlbW90ZURlc2NGYWlsZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTM0MDMsIHsgdmFsdWU6IE1lZGlhU2VydmVyUmVtb3RlRGVzY0ZhaWxlZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgTWVkaWFOb1N1cHBvcnRlZENvZGVjRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIHRoZSBpbnRlcnNlY3Rpb24gb2YgY29kZWNzIHN1cHBvcnRlZCBieSB0aGUgQ2xpZW50IGFuZCB0aGUgU2VydmVyIChvciwgaW4gcGVlci10by1wZWVyLCB0aGUgQ2xpZW50IGFuZCBhbm90aGVyIFBhcnRpY2lwYW50KSBpcyBlbXB0eS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzNDA0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdObyBzdXBwb3J0ZWQgY29kZWMnXG4gKi9cbnZhciBNZWRpYU5vU3VwcG9ydGVkQ29kZWNFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVkaWFOb1N1cHBvcnRlZENvZGVjRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVkaWFOb1N1cHBvcnRlZENvZGVjRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzNDA0LCAnTm8gc3VwcG9ydGVkIGNvZGVjJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNZWRpYU5vU3VwcG9ydGVkQ29kZWNFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZWRpYU5vU3VwcG9ydGVkQ29kZWNFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuTWVkaWFOb1N1cHBvcnRlZENvZGVjRXJyb3IgPSBNZWRpYU5vU3VwcG9ydGVkQ29kZWNFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTM0MDQsIHsgdmFsdWU6IE1lZGlhTm9TdXBwb3J0ZWRDb2RlY0Vycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgTWVkaWFDb25uZWN0aW9uRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIGJ5IHRoZSBDbGllbnQgb3IgU2VydmVyIHdoZW5ldmVyIGEgbWVkaWEgY29ubmVjdGlvbiBmYWlscyBvciByYWlzZWQgYnkgdGhlIENsaWVudCB3aGVuZXZlciBpdCBkZXRlY3RzIHRoYXQgbWVkaWEgaGFzIHN0b3BwZWQgZmxvd2luZy5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzNDA1XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdNZWRpYSBjb25uZWN0aW9uIGZhaWxlZCBvciBNZWRpYSBhY3Rpdml0eSBjZWFzZWQnXG4gKi9cbnZhciBNZWRpYUNvbm5lY3Rpb25FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVkaWFDb25uZWN0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVkaWFDb25uZWN0aW9uRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzNDA1LCAnTWVkaWEgY29ubmVjdGlvbiBmYWlsZWQgb3IgTWVkaWEgYWN0aXZpdHkgY2Vhc2VkJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNZWRpYUNvbm5lY3Rpb25FcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZWRpYUNvbm5lY3Rpb25FcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuTWVkaWFDb25uZWN0aW9uRXJyb3IgPSBNZWRpYUNvbm5lY3Rpb25FcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTM0MDUsIHsgdmFsdWU6IE1lZGlhQ29ubmVjdGlvbkVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgTWVkaWFEVExTVHJhbnNwb3J0RmFpbGVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgVGhlcmUgd2FzIGEgcHJvYmxlbSB3aGlsZSBuZWdvdGlhdGluZyB3aXRoIHRoZSByZW1vdGUgRFRMUyBwZWVyLiBUaGVyZWZvcmUgdGhlIFBhcnRpY2lwYW50IHdpbGwgbm90IGJlIGFibGUgdG8gcHVibGlzaCBvciBzdWJzY3JpYmUgdG8gVHJhY2tzLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTM0MDdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ01lZGlhIGNvbm5lY3Rpb24gZmFpbGVkIGR1ZSB0byBEVExTIGhhbmRzaGFrZSBmYWlsdXJlJ1xuICovXG52YXIgTWVkaWFEVExTVHJhbnNwb3J0RmFpbGVkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lZGlhRFRMU1RyYW5zcG9ydEZhaWxlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lZGlhRFRMU1RyYW5zcG9ydEZhaWxlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzQwNywgJ01lZGlhIGNvbm5lY3Rpb24gZmFpbGVkIGR1ZSB0byBEVExTIGhhbmRzaGFrZSBmYWlsdXJlJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNZWRpYURUTFNUcmFuc3BvcnRGYWlsZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZWRpYURUTFNUcmFuc3BvcnRGYWlsZWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuTWVkaWFEVExTVHJhbnNwb3J0RmFpbGVkRXJyb3IgPSBNZWRpYURUTFNUcmFuc3BvcnRGYWlsZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTM0MDcsIHsgdmFsdWU6IE1lZGlhRFRMU1RyYW5zcG9ydEZhaWxlZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgQ29uZmlndXJhdGlvbkFjcXVpcmVGYWlsZWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgdGhlIENsaWVudCBpcyB1bmFibGUgdG8gYWNxdWlyZSBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9uIGZyb20gdGhlIFNlcnZlci5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzNTAwXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdVbmFibGUgdG8gYWNxdWlyZSBjb25maWd1cmF0aW9uJ1xuICovXG52YXIgQ29uZmlndXJhdGlvbkFjcXVpcmVGYWlsZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uZmlndXJhdGlvbkFjcXVpcmVGYWlsZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25maWd1cmF0aW9uQWNxdWlyZUZhaWxlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzUwMCwgJ1VuYWJsZSB0byBhY3F1aXJlIGNvbmZpZ3VyYXRpb24nKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIENvbmZpZ3VyYXRpb25BY3F1aXJlRmFpbGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29uZmlndXJhdGlvbkFjcXVpcmVGYWlsZWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuQ29uZmlndXJhdGlvbkFjcXVpcmVGYWlsZWRFcnJvciA9IENvbmZpZ3VyYXRpb25BY3F1aXJlRmFpbGVkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzNTAwLCB7IHZhbHVlOiBDb25maWd1cmF0aW9uQWNxdWlyZUZhaWxlZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgQ29uZmlndXJhdGlvbkFjcXVpcmVUdXJuRmFpbGVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIHRoZSBTZXJ2ZXIgaXMgdW5hYmxlIHRvIHJldHVybiBUVVJOIGNyZWRlbnRpYWxzIHRvIHRoZSBDbGllbnRcbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzNTAxXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdVbmFibGUgdG8gYWNxdWlyZSBUVVJOIGNyZWRlbnRpYWxzJ1xuICovXG52YXIgQ29uZmlndXJhdGlvbkFjcXVpcmVUdXJuRmFpbGVkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmZpZ3VyYXRpb25BY3F1aXJlVHVybkZhaWxlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmZpZ3VyYXRpb25BY3F1aXJlVHVybkZhaWxlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzUwMSwgJ1VuYWJsZSB0byBhY3F1aXJlIFRVUk4gY3JlZGVudGlhbHMnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIENvbmZpZ3VyYXRpb25BY3F1aXJlVHVybkZhaWxlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbmZpZ3VyYXRpb25BY3F1aXJlVHVybkZhaWxlZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Db25maWd1cmF0aW9uQWNxdWlyZVR1cm5GYWlsZWRFcnJvciA9IENvbmZpZ3VyYXRpb25BY3F1aXJlVHVybkZhaWxlZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzUwMSwgeyB2YWx1ZTogQ29uZmlndXJhdGlvbkFjcXVpcmVUdXJuRmFpbGVkRXJyb3IgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10d2lsaW8tdmlkZW8tZXJyb3JzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICByZXR1cm4gdG87XG59O1xuLyoqXG4gKiBAZXh0ZW5kcyBFcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSBFcnJvciBjb2RlXG4gKi9cbnZhciBUd2lsaW9FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHdpbGlvRXJyb3IsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgVHdpbGlvRXJyb3J9XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvZGUgLSBFcnJvciBjb2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXNzYWdlXSAtIEVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZpbGVOYW1lXSAtIE5hbWUgb2YgdGhlIHNjcmlwdCBmaWxlIHdoZXJlIGVycm9yIHdhcyBnZW5lcmF0ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbmVOdW1iZXJdIC0gTGluZSBudW1iZXIgb2YgdGhlIHNjcmlwdCBmaWxlIHdoZXJlIGVycm9yIHdhcyBnZW5lcmF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUd2lsaW9FcnJvcihjb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncykpKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFR3aWxpb0Vycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHZhciBlcnJvciA9IEVycm9yLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICAgICAgZXJyb3IubmFtZSA9ICdUd2lsaW9FcnJvcic7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgJ2NvZGUnLCB7XG4gICAgICAgICAgICB2YWx1ZTogY29kZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycm9yKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBlcnJvcltwcm9wXSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaHVtYW4gcmVhZGFibGUgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGVycm9yLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgVHdpbGlvRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubWVzc2FnZSA/IFwiOiBcIiArIHRoaXMubWVzc2FnZSA6ICcnO1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCIgXCIgKyB0aGlzLmNvZGUgKyBtZXNzYWdlO1xuICAgIH07XG4gICAgcmV0dXJuIFR3aWxpb0Vycm9yO1xufShFcnJvcikpO1xubW9kdWxlLmV4cG9ydHMgPSBUd2lsaW9FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR3aWxpb2Vycm9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBpc05vbkFycmF5T2JqZWN0ID0gcmVxdWlyZSgnLi8nKS5pc05vbkFycmF5T2JqZWN0O1xudmFyIF9hID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKSwgRSA9IF9hLnR5cGVFcnJvcnMsIGNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCA9IF9hLmNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCwgdmlkZW9Db250ZW50UHJlZmVyZW5jZXNNb2RlID0gX2EudmlkZW9Db250ZW50UHJlZmVyZW5jZXNNb2RlLCBzdWJzY3JpcHRpb25Nb2RlID0gX2Euc3Vic2NyaXB0aW9uTW9kZSwgdHJhY2tQcmlvcml0eSA9IF9hLnRyYWNrUHJpb3JpdHksIHRyYWNrU3dpdGNoT2ZmTW9kZSA9IF9hLnRyYWNrU3dpdGNoT2ZmTW9kZTtcbi8qKlxuICogVmFsaWRhdGUgdGhlIHtAbGluayBCYW5kd2lkdGhQcm9maWxlfSBvYmplY3QuXG4gKiBAcGFyYW0ge0JhbmR3aWR0aFByb2ZpbGV9IGJhbmR3aWR0aFByb2ZpbGVcbiAqIEByZXR1cm5zIHs/RXJyb3J9IC0gbnVsbCBpZiB2YWxpZCwgRXJyb3IgaWYgbm90LlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUJhbmR3aWR0aFByb2ZpbGUoYmFuZHdpZHRoUHJvZmlsZSkge1xuICAgIHZhciBlcnJvciA9IHZhbGlkYXRlT2JqZWN0KGJhbmR3aWR0aFByb2ZpbGUsICdvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGUnKTtcbiAgICBpZiAoIWJhbmR3aWR0aFByb2ZpbGUgfHwgZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBlcnJvciA9IHZhbGlkYXRlT2JqZWN0KGJhbmR3aWR0aFByb2ZpbGUudmlkZW8sICdvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGUudmlkZW8nLCBbXG4gICAgICAgIHsgcHJvcDogJ2NvbnRlbnRQcmVmZXJlbmNlc01vZGUnLCB2YWx1ZXM6IE9iamVjdC52YWx1ZXModmlkZW9Db250ZW50UHJlZmVyZW5jZXNNb2RlKSB9LFxuICAgICAgICB7IHByb3A6ICdkb21pbmFudFNwZWFrZXJQcmlvcml0eScsIHZhbHVlczogT2JqZWN0LnZhbHVlcyh0cmFja1ByaW9yaXR5KSB9LFxuICAgICAgICB7IHByb3A6ICdtYXhTdWJzY3JpcHRpb25CaXRyYXRlJywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBwcm9wOiAnbWF4VHJhY2tzJywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBwcm9wOiAnbWF4U3dpdGNoZWRPblRyYWNrcycsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsgcHJvcDogJ21vZGUnLCB2YWx1ZXM6IE9iamVjdC52YWx1ZXMoc3Vic2NyaXB0aW9uTW9kZSkgfSxcbiAgICAgICAgeyBwcm9wOiAnY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sJywgdmFsdWVzOiBPYmplY3QudmFsdWVzKGNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCkgfSxcbiAgICAgICAgeyBwcm9wOiAndHJhY2tTd2l0Y2hPZmZNb2RlJywgdmFsdWVzOiBPYmplY3QudmFsdWVzKHRyYWNrU3dpdGNoT2ZmTW9kZSkgfVxuICAgIF0pO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGVycm9yID0gdmFsaWRhdGVPYmplY3QoYmFuZHdpZHRoUHJvZmlsZS5hdWRpbywgJ29wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS5hdWRpbycsIFtcbiAgICAgICAgeyBwcm9wOiAnbWF4U3dpdGNoZWRPblRyYWNrcycsIHR5cGU6ICdudW1iZXInIH1cbiAgICBdKTtcbiAgICBpZiAoYmFuZHdpZHRoUHJvZmlsZS52aWRlbykge1xuICAgICAgICAvLyBtYXhUcmFja3MgaXMgcmVwbGFjZWQgYnkgY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sLlxuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciBpZiBib3RoIGFyZSBzcGVjaWZpZWQuXG4gICAgICAgIGlmICgnbWF4VHJhY2tzJyBpbiBiYW5kd2lkdGhQcm9maWxlLnZpZGVvICYmICdjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wnIGluIGJhbmR3aWR0aFByb2ZpbGUudmlkZW8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGUudmlkZW8ubWF4VHJhY2tzIGlzIGRlcHJlY2F0ZWQuIFVzZSBvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGUudmlkZW8uY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVuZGVyRGltZW5zaW9ucyBpcyByZXBsYWNlZCBieSBjb250ZW50UHJlZmVyZW5jZXNNb2RlLlxuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciBpZiBib3RoIGFyZSBzcGVjaWZpZWQuXG4gICAgICAgIGlmICgncmVuZGVyRGltZW5zaW9ucycgaW4gYmFuZHdpZHRoUHJvZmlsZS52aWRlbyAmJiAnY29udGVudFByZWZlcmVuY2VzTW9kZScgaW4gYmFuZHdpZHRoUHJvZmlsZS52aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlby5yZW5kZXJEaW1lbnNpb25zIGlzIGRlcHJlY2F0ZWQuIFVzZSBvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGUudmlkZW8uY29udGVudFByZWZlcmVuY2VzTW9kZSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1heFN3aXRjaGVkT25UcmFja3MgYW5kIG1heFRyYWNrcyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgICAgICBpZiAoJ21heFN3aXRjaGVkT25UcmFja3MnIGluIGJhbmR3aWR0aFByb2ZpbGUudmlkZW8gJiYgJ21heFRyYWNrcycgaW4gYmFuZHdpZHRoUHJvZmlsZS52aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlby5tYXhUcmFja3MgaXMgZGVwcmVjYXRlZC4gVXNlIG9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlby5jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWRhdGVSZW5kZXJEaW1lbnNpb25zKGJhbmR3aWR0aFByb2ZpbGUudmlkZW8ucmVuZGVyRGltZW5zaW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBUaHJvdyBpZiB0aGUgZ2l2ZW4gdHJhY2sgaXMgbm90IGEge0BsaW5rIExvY2FsQXVkaW9UcmFja30sIGFcbiAqIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IG9yIGEgTWVkaWFTdHJlYW1UcmFjay5cbiAqIEBwYXJhbSB7Kn0gdHJhY2tcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTG9jYWxUcmFjayh0cmFjaywgb3B0aW9ucykge1xuICAgIGlmICghKHRyYWNrIGluc3RhbmNlb2Ygb3B0aW9ucy5Mb2NhbEF1ZGlvVHJhY2tcbiAgICAgICAgfHwgdHJhY2sgaW5zdGFuY2VvZiBvcHRpb25zLkxvY2FsRGF0YVRyYWNrXG4gICAgICAgIHx8IHRyYWNrIGluc3RhbmNlb2Ygb3B0aW9ucy5Mb2NhbFZpZGVvVHJhY2tcbiAgICAgICAgfHwgdHJhY2sgaW5zdGFuY2VvZiBvcHRpb25zLk1lZGlhU3RyZWFtVHJhY2spKSB7XG4gICAgICAgIC8qIGVzbGludCBuZXctY2FwOjAgKi9cbiAgICAgICAgdGhyb3cgRS5JTlZBTElEX1RZUEUoJ3RyYWNrJywgJ0xvY2FsQXVkaW9UcmFjaywgTG9jYWxWaWRlb1RyYWNrLCBMb2NhbERhdGFUcmFjaywgb3IgTWVkaWFTdHJlYW1UcmFjaycpO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGUgYW4gb2JqZWN0LiBBbiBvYmplY3QgaXMgdmFsaWQgaWYgaXQgaXMgdW5kZWZpbmVkIG9yIGEgbm9uLW51bGwsIG5vbi1hcnJheVxuICogb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgc2F0aXNmeSB0aGUgc3BlY2lmaWVkIGRhdGEtdHlwZSBvciB2YWx1ZS1yYW5nZSByZXF1aXJlbWVudHMuXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IC0gdGhlIG9iamVjdCB0byBiZSB2YWxpZGF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG9iamVjdCBuYW1lIHRvIGJlIHVzZWQgdG8gYnVpbGQgdGhlIGVycm9yIG1lc3NhZ2UsIGlmIGludmFsaWRcbiAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gW3Byb3BDaGVja3NdIC0gb3B0aW9uYWwgZGF0YS10eXBlIG9yIHZhbHVlLXJhbmdlIHJlcXVpcmVtZW50c1xuICogICBmb3IgdGhlIG9iamVjdCdzIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHs/RXJyb3J9IC0gbnVsbCBpZiBvYmplY3QgaXMgdmFsaWQsIEVycm9yIGlmIG5vdFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIG5hbWUsIHByb3BDaGVja3MpIHtcbiAgICBpZiAocHJvcENoZWNrcyA9PT0gdm9pZCAwKSB7IHByb3BDaGVja3MgPSBbXTsgfVxuICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFdlIGRldGVybWluZSB0aGF0IGFuIHVuZGVmaW5lZCBvYmplY3QgaXMgdmFsaWQgYmVjYXVzZSB0aGlzXG4gICAgLy8gbWVhbnMgdGhlIHBhcmVudCBvYmplY3QgZG9lcyBub3QgY29udGFpbiB0aGlzIG9iamVjdCBhcyBhIHByb3BlcnR5LCB3aGljaCBpc1xuICAgIC8vIGEgdmFsaWQgc2NlbmFyaW8uXG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBXZSBkZXRlcm1pbmUgdGhhdCBpZiB0aGUgb2JqZWN0IGlzIG51bGwsIG9yIGFuIEFycmF5LCBvclxuICAgIC8vIGFueSBvdGhlciBub24tb2JqZWN0IHR5cGUsIHRoZW4gaXQgaXMgaW52YWxpZC5cbiAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8ICFpc05vbkFycmF5T2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIEUuSU5WQUxJRF9UWVBFKG5hbWUsICdvYmplY3QnKTtcbiAgICB9XG4gICAgLy8gTk9URShtbWFsYXZhbGxpKTogV2UgZGV0ZXJtaW5lIHRoYXQgdGhlIG9iamVjdCBpcyBpbnZhbGlkIGlmIGF0IGxlYXN0IG9uZSBvZlxuICAgIC8vIGl0cyBwcm9wZXJ0aWVzIGRvZXMgbm90IHNhdGlzZnkgaXRzIGRhdGEtdHlwZSBvciB2YWx1ZS1yYW5nZSByZXF1aXJlbWVudC5cbiAgICByZXR1cm4gcHJvcENoZWNrcy5yZWR1Y2UoZnVuY3Rpb24gKGVycm9yLCBfYSkge1xuICAgICAgICB2YXIgcHJvcCA9IF9hLnByb3AsIHR5cGUgPSBfYS50eXBlLCB2YWx1ZXMgPSBfYS52YWx1ZXM7XG4gICAgICAgIGlmIChlcnJvciB8fCAhKHByb3AgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtwcm9wXTtcbiAgICAgICAgaWYgKHR5cGUgJiYgdHlwZW9mIHZhbHVlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gRS5JTlZBTElEX1RZUEUobmFtZSArIFwiLlwiICsgcHJvcCwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIEUuSU5WQUxJRF9UWVBFKG5hbWUgKyBcIi5cIiArIHByb3AsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykgJiYgIXZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBFLklOVkFMSURfVkFMVUUobmFtZSArIFwiLlwiICsgcHJvcCwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSwgbnVsbCk7XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgcmVuZGVyRGltZW5zaW9ucyBmaWVsZCB0byBiZSBcImF1dG9cIiBvciB7QGxpbmsgVmlkZW9SZW5kZXJEaW1lbnNpb25zfSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ3xWaWRlb1JlbmRlckRpbWVuc2lvbnN9IHJlbmRlckRpbWVuc2lvbnNcbiAqIEByZXR1cm5zIHs/RXJyb3J9IC0gbnVsbCBpZiB2YWxpZCwgRXJyb3IgaWYgbm90LlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJlbmRlckRpbWVuc2lvbnMocmVuZGVyRGltZW5zaW9ucykge1xuICAgIHZhciBuYW1lID0gJ29wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlby5yZW5kZXJEaW1lbnNpb25zJztcbiAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZU9iamVjdChyZW5kZXJEaW1lbnNpb25zLCBuYW1lKTtcbiAgICByZXR1cm4gcmVuZGVyRGltZW5zaW9ucyA/IGVycm9yIHx8IE9iamVjdC52YWx1ZXModHJhY2tQcmlvcml0eSkucmVkdWNlKGZ1bmN0aW9uIChlcnJvciwgcHJvcCkge1xuICAgICAgICByZXR1cm4gZXJyb3IgfHwgdmFsaWRhdGVPYmplY3QocmVuZGVyRGltZW5zaW9uc1twcm9wXSwgbmFtZSArIFwiLlwiICsgcHJvcCwgW1xuICAgICAgICAgICAgeyBwcm9wOiAnaGVpZ2h0JywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgICAgIHsgcHJvcDogJ3dpZHRoJywgdHlwZTogJ251bWJlcicgfVxuICAgICAgICBdKTtcbiAgICB9LCBudWxsKSA6IGVycm9yO1xufVxuZXhwb3J0cy52YWxpZGF0ZUJhbmR3aWR0aFByb2ZpbGUgPSB2YWxpZGF0ZUJhbmR3aWR0aFByb2ZpbGU7XG5leHBvcnRzLnZhbGlkYXRlTG9jYWxUcmFjayA9IHZhbGlkYXRlTG9jYWxUcmFjaztcbmV4cG9ydHMudmFsaWRhdGVPYmplY3QgPSB2YWxpZGF0ZU9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRlLmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICpcbiAqIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCAoMS43LjApXG4gKiBhbmQgbW9kaWZpZWQgdG8gcmVtb3ZlIGJyb3dzZXIgYW5kIEFNRCBtb2R1bGUgc3VwcG9ydCwgd2hpbGUga2VlcGluZyBDb21tb25KUy5cbiAqIEl0IHdhcyBjYXVzaW5nIGEgY29uZmxpY3Qgd2hlbiB0aGlzIGlzIGJ1bmRsZWQgdXNpbmcgQ29tbW9uSlMsIGFuZCB0aGVuIGxvYWRlZCB2aWEgUmVxdWlyZUpTLlxuICogVGhlIHByb3BlciB3YXkgdG8gZml4IHRoaXMgbW9kdWxlIGlzIHRvIGhhdmUgYSBidWlsZCB0aGF0IG91dHB1dHMgQ29tbW9uSlMgYW5kIEFNRCBzZXBhcmF0ZWx5XG4gKiB3aGljaCBuZWVkcyB0byBiZSBzdWJtaXR0ZWQgdG8gdGhlIG9yaWdpbmFsIG1vZHVsZSdzIHJlcG8uXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG52YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG52YXIgaXNJRSA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSAmJiAodHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgIT09IHVuZGVmaW5lZFR5cGUpICYmICgvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpO1xudmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgXCJ0cmFjZVwiLFxuICAgIFwiZGVidWdcIixcbiAgICBcImluZm9cIixcbiAgICBcIndhcm5cIixcbiAgICBcImVycm9yXCJcbl07XG4vLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG5mdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbmZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgaWYgKGNvbnNvbGUubG9nKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb25zb2xlLnRyYWNlKVxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG59XG4vLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbi8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xuICAgICAgICByZXR1cm4gdHJhY2VGb3JJRTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbn1cbi8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcbmZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICB9XG4gICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1Zztcbn1cbi8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbi8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG5mdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbi8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG5mdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVudExldmVsO1xuICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGlnbm9yZSkgeyB9XG4gICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoaWdub3JlKSB7IH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgIHZhciBzdG9yZWRMZXZlbDtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGlnbm9yZSkgeyB9XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgfVxuICAgIC8qXG4gICAgICpcbiAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGYubmFtZSA9IG5hbWU7XG4gICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNSB9O1xuICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG4gICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICB9O1xuICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7IC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uIChwZXJzaXN0KSB7XG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgIH07XG4gICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24gKHBlcnNpc3QpIHtcbiAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgIH07XG4gICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgIH1cbiAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xufVxuLypcbiAqXG4gKiBUb3AtbGV2ZWwgQVBJXG4gKlxuICovXG52YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcbnZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgIGlmICgodHlwZW9mIG5hbWUgIT09IFwic3ltYm9sXCIgJiYgdHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgfVxuICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIobmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyO1xufTtcbi8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxudmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufTtcbmRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xufTtcbi8vIEVTNiBkZWZhdWx0IGV4cG9ydCwgZm9yIGNvbXBhdGliaWxpdHlcbmRlZmF1bHRMb2dnZXJbJ2RlZmF1bHQnXSA9IGRlZmF1bHRMb2dnZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dsZXZlbC5qcy5tYXAiLCIvKiBnbG9iYWxzIHdlYmtpdEF1ZGlvQ29udGV4dCwgQXVkaW9Db250ZXh0ICovXG4ndXNlIHN0cmljdCc7XG52YXIgTmF0aXZlQXVkaW9Db250ZXh0ID0gdHlwZW9mIEF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IEF1ZGlvQ29udGV4dFxuICAgIDogdHlwZW9mIHdlYmtpdEF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB3ZWJraXRBdWRpb0NvbnRleHRcbiAgICAgICAgOiBudWxsO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEF1ZGlvQ29udGV4dEZhY3RvcnlPcHRpb25zXG4gKiBAcHJvcGVydHkge0F1ZGlvQ29udGV4dH0gW0F1ZGlvQ29udGV4dF0gLSBUaGUgQXVkaW9Db250ZXh0IGNvbnN0cnVjdG9yXG4gKi9cbi8qKlxuICoge0BsaW5rIEF1ZGlvQ29udGV4dEZhY3Rvcnl9IGVuc3VyZXMgd2UgY29uc3RydWN0IGF0IG1vc3Qgb25lIEF1ZGlvQ29udGV4dFxuICogYXQgYSB0aW1lLCBhbmQgdGhhdCBpdCBpcyBldmVudHVhbGx5IGNsb3NlZCB3aGVuIHdlIG5vIGxvbmdlciBuZWVkIGl0LlxuICogQHByb3BlcnR5IHtBdWRpb0NvbnRleHRGYWN0b3J5fSBBdWRpb0NvbnRleHRGYWN0b3J5IC0gVGhlXG4gKiAgIHtAbGluayBBdWRpb0NvbnRleHRGYWN0b3J5fSBjb25zdHJ1Y3RvclxuICovXG52YXIgQXVkaW9Db250ZXh0RmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0F1ZGlvQ29udGV4dEZhY3RvcnlPcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdWRpb0NvbnRleHRGYWN0b3J5KG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgQXVkaW9Db250ZXh0OiBOYXRpdmVBdWRpb0NvbnRleHRcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIF9BdWRpb0NvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5BdWRpb0NvbnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYXVkaW9Db250ZXh0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaG9sZGVyczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBBdWRpb0NvbnRleHRGYWN0b3J5OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogQXVkaW9Db250ZXh0RmFjdG9yeVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRWFjaCBjYWxsIHRvIHtAbGluayBBdWRpb0NvbnRleHRGYWN0b3J5I2dldE9yQ3JlYXRlfSBzaG91bGQgYmUgcGFpcmVkIHdpdGggYVxuICAgICAqIGNhbGwgdG8ge0BsaW5rIEF1ZGlvQ29udGV4dEZhY3RvcnkjcmVsZWFzZX0uIENhbGxpbmcgdGhpcyBpbmNyZW1lbnRzIGFuXG4gICAgICogaW50ZXJuYWwgcmVmZXJlbmNlIGNvdW50LlxuICAgICAqIEBwYXJhbSB7Kn0gaG9sZGVyIC0gVGhlIG9iamVjdCB0byBob2xkIGEgcmVmZXJlbmNlIHRvIHRoZSBBdWRpb0NvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7P0F1ZGlvQ29udGV4dH1cbiAgICAgKi9cbiAgICBBdWRpb0NvbnRleHRGYWN0b3J5LnByb3RvdHlwZS5nZXRPckNyZWF0ZSA9IGZ1bmN0aW9uIChob2xkZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ob2xkZXJzLmhhcyhob2xkZXIpKSB7XG4gICAgICAgICAgICB0aGlzLl9ob2xkZXJzLmFkZChob2xkZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX0F1ZGlvQ29udGV4dCAmJiAhdGhpcy5fYXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9Db250ZXh0ID0gbmV3IHRoaXMuX0F1ZGlvQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1ZGlvQ29udGV4dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlY3JlbWVudCB0aGUgaW50ZXJuYWwgcmVmZXJlbmNlIGNvdW50LiBJZiBpdCByZWFjaGVzIHplcm8sIGNsb3NlIGFuZCBkZXN0cm95XG4gICAgICogdGhlIEF1ZGlvQ29udGV4dC5cbiAgICAgKiBAcGFyYW0geyp9IGhvbGRlciAtIFRoZSBvYmplY3QgdGhhdCBoZWxkIGEgcmVmZXJlbmNlIHRvIHRoZSBBdWRpb0NvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBBdWRpb0NvbnRleHRGYWN0b3J5LnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKGhvbGRlcikge1xuICAgICAgICBpZiAodGhpcy5faG9sZGVycy5oYXMoaG9sZGVyKSkge1xuICAgICAgICAgICAgdGhpcy5faG9sZGVycy5kZWxldGUoaG9sZGVyKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faG9sZGVycy5zaXplICYmIHRoaXMuX2F1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBdWRpb0NvbnRleHRGYWN0b3J5O1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gbmV3IEF1ZGlvQ29udGV4dEZhY3RvcnkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1ZGlvY29udGV4dC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIFJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciBgdGltZW91dGAgbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHs/bnVtYmVyfSBbdGltZW91dD0wXVxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmZ1bmN0aW9uIGRlbGF5KHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0ID0gdHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInID8gdGltZW91dCA6IDA7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQpOyB9KTtcbn1cbi8qKlxuICogQXR0ZW1wdCB0byBkZXRlY3Qgc2lsZW5jZS4gVGhlIFByb21pc2UgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiByZXR1cm5zXG4gKiBmYWxzZSBhcyBzb29uIGFzIGF1ZGlvIGlzIGRldGVjdGVkIG9yIHRydWUgYWZ0ZXIgYHRpbWVvdXRgIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBhdWRpb0NvbnRleHRcbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbVxuICogQHBhcmFtIHs/bnVtYmVyfSBbdGltZW91dD0yNTBdXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0U2lsZW5jZShhdWRpb0NvbnRleHQsIHN0cmVhbSwgdGltZW91dCkge1xuICAgIHRpbWVvdXQgPSB0eXBlb2YgdGltZW91dCA9PT0gJ251bWJlcicgPyB0aW1lb3V0IDogMjUwO1xuICAgIHZhciBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcbiAgICB2YXIgYW5hbHlzZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgICBhbmFseXNlci5mZnRTaXplID0gMjA0ODtcbiAgICBzb3VyY2UuY29ubmVjdChhbmFseXNlcik7XG4gICAgdmFyIHNhbXBsZXMgPSBuZXcgVWludDhBcnJheShhbmFseXNlci5mZnRTaXplKTtcbiAgICB2YXIgdGltZW91dERpZEZpcmUgPSBmYWxzZTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGltZW91dERpZEZpcmUgPSB0cnVlOyB9LCB0aW1lb3V0KTtcbiAgICAvKipcbiAgICAgKiBXZSBjYW4ndCB1c2UgYXN5bmMvYXdhaXQgeWV0LCBzbyBJIG5lZWQgdG8gZmFjdG9yIHRoaXMgb3V0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvRGV0ZWN0U2lsZW5jZSgpIHtcbiAgICAgICAgaWYgKHRpbWVvdXREaWRGaXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGFuYWx5c2VyLmdldEJ5dGVUaW1lRG9tYWluRGF0YShzYW1wbGVzKTtcbiAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IEFuIGF1ZGlvIE1lZGlhU3RyZWFtVHJhY2sgY2FuIGJlIHNpbGVudCBlaXRoZXIgZHVlIHRvIGFsbCBzYW1wbGVzXG4gICAgICAgIC8vIGJlaW5nIGVxdWFsIHRvIDEyOCBvciBhbGwgc2FtcGxlcyBiZWluZyBlcXVhbCB0byAwLlxuICAgICAgICByZXR1cm4gc2FtcGxlcy5zb21lKGZ1bmN0aW9uIChzYW1wbGUpIHsgcmV0dXJuIHNhbXBsZSAhPT0gMTI4ICYmIHNhbXBsZSAhPT0gMDsgfSlcbiAgICAgICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKVxuICAgICAgICAgICAgOiBkZWxheSgpLnRoZW4oZG9EZXRlY3RTaWxlbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvRGV0ZWN0U2lsZW5jZSgpLnRoZW4oZnVuY3Rpb24gKGlzU2lsZW50KSB7XG4gICAgICAgIHNvdXJjZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHJldHVybiBpc1NpbGVudDtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgc291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRldGVjdFNpbGVuY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3RzaWxlbmNlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBkZXRlY3RTaWxlbmNlID0gcmVxdWlyZSgnLi9kZXRlY3RzaWxlbmNlJyk7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYXR0ZW1wdHMgdG8gd29ya2Fyb3VuZCBXZWJLaXQgQnVnIDE4MDc0OC4gSXQgZG9lcyBzbyBieVxuICpcbiAqICAgMS4gQ2FsbGluZyBgZ2V0VXNlck1lZGlhYCwgYW5kXG4gKiAgIDIuIENoZWNraW5nIHRvIHNlZSBpZiB0aGUgcmVzdWx0aW5nIE1lZGlhU3RyZWFtIGlzIHNpbGVudC5cbiAqICAgMy4gSWYgc28sIHJlcGVhdCBTdGVwIDE7IG90aGVyd2lzZSwgcmV0dXJuIHRoZSBNZWRpYVN0cmVhbS5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gb25seSByZXBlYXRzIHVwIHRvIGBuYCB0aW1lcywgYW5kIGl0IG9ubHkgd2FpdHMgYHRpbWVvdXRgXG4gKiBtaWxsaXNlY29uZHMgd2hlbiBkZXRlY3Rpbmcgc2lsZW5jZS4gQXNzdW1pbmcgYGdldFVzZXJNZWRpYWAgaXNcbiAqIGluc3RhbnRhbmVvdXMsIGluIHRoZSBiZXN0IGNhc2UsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIFByb21pc2UgdGhhdFxuICogcmVzb2x2ZXMgaW1tZWRpYXRlbHk7IGluIHRoZSB3b3JzdCBjYXNlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBQcm9taXNlIHRoYXRcbiAqIHJlc29sdmVzIGluIGBuYCAqIGB0aW1lb3V0YCBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtMb2d9IGxvZ1xuICogQHBhcmFtIHtmdW5jdGlvbihNZWRpYVN0cmVhbUNvbnN0cmFpbnRzKTogUHJvbWlzZTxNZWRpYVN0cmVhbT59IGdldFVzZXJNZWRpYVxuICogQHBhcmFtIHtNZWRpYVN0cmVhbUNvbnN0cmFpbnRzfSBjb25zdHJhaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IFtuPTNdXG4gKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXQ9MjUwXVxuICogQHJldHVybnMgUHJvbWlzZTxNZWRpYVN0cmVhbT5cbiAqL1xuZnVuY3Rpb24gd29ya2Fyb3VuZChsb2csIGdldFVzZXJNZWRpYSwgY29uc3RyYWludHMsIG4sIHRpbWVvdXQpIHtcbiAgICBuID0gdHlwZW9mIG4gPT09ICdudW1iZXInID8gbiA6IDM7XG4gICAgdmFyIHJldHJ5ID0gMDtcbiAgICAvLyBOT1RFKG1yb2JlcnRzKTogV2UgaGF2ZSB0byBkZWxheSByZXF1aXJlLWluZyBBdWRpb0NvbnRleHRGYWN0b3J5LCBiZWNhdXNlXG4gICAgLy8gaXQgZXhwb3J0cyBhIGRlZmF1bHQgaW5zdGFuY2Ugd2hvc2UgY29uc3RydWN0b3IgY2FsbHMgT2JqZWN0LmFzc2lnbi5cbiAgICB2YXIgQXVkaW9Db250ZXh0RmFjdG9yeSA9IHJlcXVpcmUoJy4vYXVkaW9jb250ZXh0Jyk7XG4gICAgdmFyIGhvbGRlciA9IHt9O1xuICAgIHZhciBhdWRpb0NvbnRleHQgPSBBdWRpb0NvbnRleHRGYWN0b3J5LmdldE9yQ3JlYXRlKGhvbGRlcik7XG4gICAgLyoqXG4gICAgICogV2UgY2FuJ3QgdXNlIGFzeW5jL2F3YWl0IHlldCwgc28gSSBuZWVkIHRvIGZhY3RvciB0aGlzIG91dC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZWRpYVN0cmVhbT59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9Xb3JrYXJvdW5kKCkge1xuICAgICAgICByZXR1cm4gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBpc1NpbGVudFByb21pc2UgPSBjb25zdHJhaW50cy5hdWRpb1xuICAgICAgICAgICAgICAgID8gZGV0ZWN0U2lsZW5jZShhdWRpb0NvbnRleHQsIHN0cmVhbSwgdGltZW91dCkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2cud2FybignRW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgZGV0ZWN0aW5nIHNpbGVuY2UnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBpc1NpbGVudFByb21pc2UudGhlbihmdW5jdGlvbiAoaXNTaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzU2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5pbmZvKCdHb3QgYSBub24tc2lsZW50IGF1ZGlvIE1lZGlhU3RyZWFtVHJhY2s7IHJldHVybmluZyBpdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKCdHb3QgYSBzaWxlbnQgYXVkaW8gTWVkaWFTdHJlYW1UcmFjay4gTm9ybWFsbHkgd2Ugd291bGQgdHJ5IFxcXG50byBnZXQgYSBuZXcgb25lLCBidXQgd2VcXCd2ZSBydW4gb3V0IG9mIHJldHJpZXM7IHJldHVybmluZyBpdCBhbnl3YXkuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiR290IGEgc2lsZW50IGF1ZGlvIE1lZGlhU3RyZWFtVHJhY2suIFN0b3BwaW5nIGFsbCBNZWRpYVN0cmVhbVRyYWNrcyBhbmQgY2FsbGluZyBnZXRVc2VyTWVkaWEgYWdhaW4uIFRoaXMgaXMgcmV0cnkgI1wiICsgKytyZXRyeSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHsgcmV0dXJuIHRyYWNrLnN0b3AoKTsgfSk7XG4gICAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb1dvcmthcm91bmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRvV29ya2Fyb3VuZCgpLnRoZW4oZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICBBdWRpb0NvbnRleHRGYWN0b3J5LnJlbGVhc2UoaG9sZGVyKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgQXVkaW9Db250ZXh0RmFjdG9yeS5yZWxlYXNlKGhvbGRlcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSB3b3JrYXJvdW5kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2Fyb3VuZDE4MDc0OC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgZmxhdE1hcCA9IHJlcXVpcmUoJy4vdXRpbCcpLmZsYXRNYXA7XG52YXIgZ3Vlc3NCcm93c2VyID0gcmVxdWlyZSgnLi91dGlsJykuZ3Vlc3NCcm93c2VyO1xudmFyIGd1ZXNzQnJvd3NlclZlcnNpb24gPSByZXF1aXJlKCcuL3V0aWwnKS5ndWVzc0Jyb3dzZXJWZXJzaW9uO1xudmFyIGdldFNkcEZvcm1hdCA9IHJlcXVpcmUoJy4vdXRpbC9zZHAnKS5nZXRTZHBGb3JtYXQ7XG52YXIgZ3Vlc3MgPSBndWVzc0Jyb3dzZXIoKTtcbnZhciBndWVzc1ZlcnNpb24gPSBndWVzc0Jyb3dzZXJWZXJzaW9uKCk7XG52YXIgaXNDaHJvbWUgPSBndWVzcyA9PT0gJ2Nocm9tZSc7XG52YXIgaXNGaXJlZm94ID0gZ3Vlc3MgPT09ICdmaXJlZm94JztcbnZhciBpc1NhZmFyaSA9IGd1ZXNzID09PSAnc2FmYXJpJztcbnZhciBjaHJvbWVNYWpvclZlcnNpb24gPSBpc0Nocm9tZSA/IGd1ZXNzVmVyc2lvbi5tYWpvciA6IG51bGw7XG52YXIgQ0hST01FX0xFR0FDWV9NQVhfQVVESU9fTEVWRUwgPSAzMjc2Nztcbi8qKlxuICogR2V0IHRoZSBzdGFuZGFyZGl6ZWQge0BsaW5rIFJUQ1BlZXJDb25uZWN0aW9ufSBzdGF0aXN0aWNzLlxuICogQHBhcmFtIHtSVENQZWVyQ29ubmVjdGlvbn0gcGVlckNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBVc2VkIGZvciB0ZXN0aW5nXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48U3RhbmRhcmRpemVkU3RhdHNSZXNwb25zZT59XG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRzKHBlZXJDb25uZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCEocGVlckNvbm5lY3Rpb24gJiYgdHlwZW9mIHBlZXJDb25uZWN0aW9uLmdldFN0YXRzID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdHaXZlbiBQZWVyQ29ubmVjdGlvbiBkb2VzIG5vdCBzdXBwb3J0IGdldFN0YXRzJykpO1xuICAgIH1cbiAgICByZXR1cm4gX2dldFN0YXRzKHBlZXJDb25uZWN0aW9uLCBvcHRpb25zKTtcbn1cbi8qKlxuICogZ2V0U3RhdHMoKSBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSB7UlRDUGVlckNvbm5lY3Rpb259IHBlZXJDb25uZWN0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gVXNlZCBmb3IgdGVzdGluZ1xuICogQHJldHVybnMge1Byb21pc2UuPFN0YW5kYXJkaXplZFN0YXRzUmVzcG9uc2U+fVxuICovXG5mdW5jdGlvbiBfZ2V0U3RhdHMocGVlckNvbm5lY3Rpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgbG9jYWxBdWRpb1RyYWNrcyA9IGdldFRyYWNrcyhwZWVyQ29ubmVjdGlvbiwgJ2F1ZGlvJywgJ2xvY2FsJyk7XG4gICAgdmFyIGxvY2FsVmlkZW9UcmFja3MgPSBnZXRUcmFja3MocGVlckNvbm5lY3Rpb24sICd2aWRlbycsICdsb2NhbCcpO1xuICAgIHZhciByZW1vdGVBdWRpb1RyYWNrcyA9IGdldFRyYWNrcyhwZWVyQ29ubmVjdGlvbiwgJ2F1ZGlvJyk7XG4gICAgdmFyIHJlbW90ZVZpZGVvVHJhY2tzID0gZ2V0VHJhY2tzKHBlZXJDb25uZWN0aW9uLCAndmlkZW8nKTtcbiAgICB2YXIgc3RhdHNSZXNwb25zZSA9IHtcbiAgICAgICAgYWN0aXZlSWNlQ2FuZGlkYXRlUGFpcjogbnVsbCxcbiAgICAgICAgbG9jYWxBdWRpb1RyYWNrU3RhdHM6IFtdLFxuICAgICAgICBsb2NhbFZpZGVvVHJhY2tTdGF0czogW10sXG4gICAgICAgIHJlbW90ZUF1ZGlvVHJhY2tTdGF0czogW10sXG4gICAgICAgIHJlbW90ZVZpZGVvVHJhY2tTdGF0czogW11cbiAgICB9O1xuICAgIHZhciB0cmFja1N0YXRzUHJvbWlzZXMgPSBmbGF0TWFwKFtcbiAgICAgICAgW2xvY2FsQXVkaW9UcmFja3MsICdsb2NhbEF1ZGlvVHJhY2tTdGF0cycsIGZhbHNlXSxcbiAgICAgICAgW2xvY2FsVmlkZW9UcmFja3MsICdsb2NhbFZpZGVvVHJhY2tTdGF0cycsIGZhbHNlXSxcbiAgICAgICAgW3JlbW90ZUF1ZGlvVHJhY2tzLCAncmVtb3RlQXVkaW9UcmFja1N0YXRzJywgdHJ1ZV0sXG4gICAgICAgIFtyZW1vdGVWaWRlb1RyYWNrcywgJ3JlbW90ZVZpZGVvVHJhY2tTdGF0cycsIHRydWVdXG4gICAgXSwgZnVuY3Rpb24gKHRyaXBsZSkge1xuICAgICAgICB2YXIgdHJhY2tzID0gdHJpcGxlWzBdO1xuICAgICAgICB2YXIgc3RhdHNBcnJheU5hbWUgPSB0cmlwbGVbMV07XG4gICAgICAgIHZhciBpc1JlbW90ZSA9IHRyaXBsZVsyXTtcbiAgICAgICAgcmV0dXJuIHRyYWNrcy5tYXAoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VHJhY2tTdGF0cyhwZWVyQ29ubmVjdGlvbiwgdHJhY2ssIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIGlzUmVtb3RlOiBpc1JlbW90ZVxuICAgICAgICAgICAgfSwgb3B0aW9ucykpLnRoZW4oZnVuY3Rpb24gKHRyYWNrU3RhdHNBcnJheSkge1xuICAgICAgICAgICAgICAgIHRyYWNrU3RhdHNBcnJheS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja1N0YXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrU3RhdHMudHJhY2tJZCA9IHRyYWNrLmlkO1xuICAgICAgICAgICAgICAgICAgICBzdGF0c1Jlc3BvbnNlW3N0YXRzQXJyYXlOYW1lXS5wdXNoKHRyYWNrU3RhdHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh0cmFja1N0YXRzUHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0QWN0aXZlSWNlQ2FuZGlkYXRlUGFpclN0YXRzKHBlZXJDb25uZWN0aW9uLCBvcHRpb25zKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChhY3RpdmVJY2VDYW5kaWRhdGVQYWlyU3RhdHNSZXBvcnQpIHtcbiAgICAgICAgc3RhdHNSZXNwb25zZS5hY3RpdmVJY2VDYW5kaWRhdGVQYWlyID0gYWN0aXZlSWNlQ2FuZGlkYXRlUGFpclN0YXRzUmVwb3J0O1xuICAgICAgICByZXR1cm4gc3RhdHNSZXNwb25zZTtcbiAgICB9KTtcbn1cbi8qKlxuICogR2VuZXJhdGUgdGhlIHtAbGluayBTdGFuZGFyZGl6ZWRBY3RpdmVJY2VDYW5kaWRhdGVQYWlyU3RhdHNSZXBvcnR9IGZvciB0aGVcbiAqIHtAbGluayBSVENQZWVyQ29ubmVjdGlvbn0uXG4gKiBAcGFyYW0ge1JUQ1BlZXJDb25uZWN0aW9ufSBwZWVyQ29ubmVjdGlvblxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8U3RhbmRhcmRpemVkQWN0aXZlSWNlQ2FuZGlkYXRlUGFpclN0YXRzUmVwb3J0Pn1cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlSWNlQ2FuZGlkYXRlUGFpclN0YXRzKHBlZXJDb25uZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRlc3RGb3JDaHJvbWUgIT09ICd1bmRlZmluZWQnIHx8IGlzQ2hyb21lXG4gICAgICAgIHx8IHR5cGVvZiBvcHRpb25zLnRlc3RGb3JTYWZhcmkgIT09ICd1bmRlZmluZWQnIHx8IGlzU2FmYXJpKSB7XG4gICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbi5nZXRTdGF0cygpLnRoZW4oc3RhbmRhcmRpemVDaHJvbWVPclNhZmFyaUFjdGl2ZUljZUNhbmRpZGF0ZVBhaXJTdGF0cyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50ZXN0Rm9yRmlyZWZveCAhPT0gJ3VuZGVmaW5lZCcgfHwgaXNGaXJlZm94KSB7XG4gICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbi5nZXRTdGF0cygpLnRoZW4oc3RhbmRhcmRpemVGaXJlZm94QWN0aXZlSWNlQ2FuZGlkYXRlUGFpclN0YXRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignUlRDUGVlckNvbm5lY3Rpb24jZ2V0U3RhdHMoKSBub3Qgc3VwcG9ydGVkJykpO1xufVxuLyoqXG4gKiBTdGFuZGFyZGl6ZSB0aGUgYWN0aXZlIFJUQ0ljZUNhbmRpZGF0ZSBwYWlyJ3Mgc3RhdGlzdGljcyBpbiBDaHJvbWUgb3IgU2FmYXJpLlxuICogQHBhcmFtIHtSVENTdGF0c1JlcG9ydH0gc3RhdHNcbiAqIEByZXR1cm5zIHs/U3RhbmRhcmRpemVkQWN0aXZlSWNlQ2FuZGlkYXRlUGFpclN0YXRzUmVwb3J0fVxuICovXG5mdW5jdGlvbiBzdGFuZGFyZGl6ZUNocm9tZU9yU2FmYXJpQWN0aXZlSWNlQ2FuZGlkYXRlUGFpclN0YXRzKHN0YXRzKSB7XG4gICAgdmFyIGFjdGl2ZUNhbmRpZGF0ZVBhaXJTdGF0cyA9IEFycmF5LmZyb20oc3RhdHMudmFsdWVzKCkpLmZpbmQoZnVuY3Rpb24gKHN0YXQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXQudHlwZSA9PT0gJ2NhbmRpZGF0ZS1wYWlyJyAmJiBzdGF0Lm5vbWluYXRlZDtcbiAgICB9KTtcbiAgICBpZiAoIWFjdGl2ZUNhbmRpZGF0ZVBhaXJTdGF0cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGFjdGl2ZUxvY2FsQ2FuZGlkYXRlU3RhdHMgPSBzdGF0cy5nZXQoYWN0aXZlQ2FuZGlkYXRlUGFpclN0YXRzLmxvY2FsQ2FuZGlkYXRlSWQpO1xuICAgIHZhciBhY3RpdmVSZW1vdGVDYW5kaWRhdGVTdGF0cyA9IHN0YXRzLmdldChhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHMucmVtb3RlQ2FuZGlkYXRlSWQpO1xuICAgIHZhciBzdGFuZGFyZGl6ZWRDYW5kaWRhdGVTdGF0c0tleXMgPSBbXG4gICAgICAgIHsga2V5OiAnY2FuZGlkYXRlVHlwZScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsga2V5OiAnaXAnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IGtleTogJ3BvcnQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ3ByaW9yaXR5JywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBrZXk6ICdwcm90b2NvbCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsga2V5OiAndXJsJywgdHlwZTogJ3N0cmluZycgfVxuICAgIF07XG4gICAgdmFyIHN0YW5kYXJkaXplZExvY2FsQ2FuZGlkYXRlU3RhdHNLZXlzID0gc3RhbmRhcmRpemVkQ2FuZGlkYXRlU3RhdHNLZXlzLmNvbmNhdChbXG4gICAgICAgIHsga2V5OiAnZGVsZXRlZCcsIHR5cGU6ICdib29sZWFuJyB9LFxuICAgICAgICB7IGtleTogJ3JlbGF5UHJvdG9jb2wnLCB0eXBlOiAnc3RyaW5nJyB9XG4gICAgXSk7XG4gICAgdmFyIHN0YW5kYXRkaXplZExvY2FsQ2FuZGlkYXRlU3RhdHNSZXBvcnQgPSBhY3RpdmVMb2NhbENhbmRpZGF0ZVN0YXRzXG4gICAgICAgID8gc3RhbmRhcmRpemVkTG9jYWxDYW5kaWRhdGVTdGF0c0tleXMucmVkdWNlKGZ1bmN0aW9uIChyZXBvcnQsIGtleUluZm8pIHtcbiAgICAgICAgICAgIHJlcG9ydFtrZXlJbmZvLmtleV0gPSB0eXBlb2YgYWN0aXZlTG9jYWxDYW5kaWRhdGVTdGF0c1trZXlJbmZvLmtleV0gPT09IGtleUluZm8udHlwZVxuICAgICAgICAgICAgICAgID8gYWN0aXZlTG9jYWxDYW5kaWRhdGVTdGF0c1trZXlJbmZvLmtleV1cbiAgICAgICAgICAgICAgICA6IGtleUluZm8ua2V5ID09PSAnZGVsZXRlZCcgPyBmYWxzZSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcmVwb3J0O1xuICAgICAgICB9LCB7fSlcbiAgICAgICAgOiBudWxsO1xuICAgIHZhciBzdGFuZGFyZGl6ZWRSZW1vdGVDYW5kaWRhdGVTdGF0c1JlcG9ydCA9IGFjdGl2ZVJlbW90ZUNhbmRpZGF0ZVN0YXRzXG4gICAgICAgID8gc3RhbmRhcmRpemVkQ2FuZGlkYXRlU3RhdHNLZXlzLnJlZHVjZShmdW5jdGlvbiAocmVwb3J0LCBrZXlJbmZvKSB7XG4gICAgICAgICAgICByZXBvcnRba2V5SW5mby5rZXldID0gdHlwZW9mIGFjdGl2ZVJlbW90ZUNhbmRpZGF0ZVN0YXRzW2tleUluZm8ua2V5XSA9PT0ga2V5SW5mby50eXBlXG4gICAgICAgICAgICAgICAgPyBhY3RpdmVSZW1vdGVDYW5kaWRhdGVTdGF0c1trZXlJbmZvLmtleV1cbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcmVwb3J0O1xuICAgICAgICB9LCB7fSlcbiAgICAgICAgOiBudWxsO1xuICAgIHJldHVybiBbXG4gICAgICAgIHsga2V5OiAnYXZhaWxhYmxlSW5jb21pbmdCaXRyYXRlJywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBrZXk6ICdhdmFpbGFibGVPdXRnb2luZ0JpdHJhdGUnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ2J5dGVzUmVjZWl2ZWQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ2J5dGVzU2VudCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsga2V5OiAnY29uc2VudFJlcXVlc3RzU2VudCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsga2V5OiAnY3VycmVudFJvdW5kVHJpcFRpbWUnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ2xhc3RQYWNrZXRSZWNlaXZlZFRpbWVzdGFtcCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsga2V5OiAnbGFzdFBhY2tldFNlbnRUaW1lc3RhbXAnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ25vbWluYXRlZCcsIHR5cGU6ICdib29sZWFuJyB9LFxuICAgICAgICB7IGtleTogJ3ByaW9yaXR5JywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBrZXk6ICdyZWFkYWJsZScsIHR5cGU6ICdib29sZWFuJyB9LFxuICAgICAgICB7IGtleTogJ3JlcXVlc3RzUmVjZWl2ZWQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ3JlcXVlc3RzU2VudCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsga2V5OiAncmVzcG9uc2VzUmVjZWl2ZWQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ3Jlc3BvbnNlc1NlbnQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ3JldHJhbnNtaXNzaW9uc1JlY2VpdmVkJywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBrZXk6ICdyZXRyYW5zbWlzc2lvbnNTZW50JywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBrZXk6ICdzdGF0ZScsIHR5cGU6ICdzdHJpbmcnLCBmaXh1cDogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZSA9PT0gJ2lucHJvZ3Jlc3MnID8gJ2luLXByb2dyZXNzJyA6IHN0YXRlOyB9IH0sXG4gICAgICAgIHsga2V5OiAndG90YWxSb3VuZFRyaXBUaW1lJywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBrZXk6ICd0cmFuc3BvcnRJZCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsga2V5OiAnd3JpdGFibGUnLCB0eXBlOiAnYm9vbGVhbicgfVxuICAgIF0ucmVkdWNlKGZ1bmN0aW9uIChyZXBvcnQsIGtleUluZm8pIHtcbiAgICAgICAgcmVwb3J0W2tleUluZm8ua2V5XSA9IHR5cGVvZiBhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHNba2V5SW5mby5rZXldID09PSBrZXlJbmZvLnR5cGVcbiAgICAgICAgICAgID8gKGtleUluZm8uZml4dXAgPyBrZXlJbmZvLmZpeHVwKGFjdGl2ZUNhbmRpZGF0ZVBhaXJTdGF0c1trZXlJbmZvLmtleV0pIDogYWN0aXZlQ2FuZGlkYXRlUGFpclN0YXRzW2tleUluZm8ua2V5XSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlcG9ydDtcbiAgICB9LCB7XG4gICAgICAgIGxvY2FsQ2FuZGlkYXRlOiBzdGFuZGF0ZGl6ZWRMb2NhbENhbmRpZGF0ZVN0YXRzUmVwb3J0LFxuICAgICAgICByZW1vdGVDYW5kaWRhdGU6IHN0YW5kYXJkaXplZFJlbW90ZUNhbmRpZGF0ZVN0YXRzUmVwb3J0XG4gICAgfSk7XG59XG4vKipcbiAqIFN0YW5kYXJkaXplIHRoZSBhY3RpdmUgUlRDSWNlQ2FuZGlkYXRlIHBhaXIncyBzdGF0aXN0aWNzIGluIEZpcmVmb3guXG4gKiBAcGFyYW0ge1JUQ1N0YXRzUmVwb3J0fSBzdGF0c1xuICogQHJldHVybnMgez9TdGFuZGFyZGl6ZWRBY3RpdmVJY2VDYW5kaWRhdGVQYWlyU3RhdHNSZXBvcnR9XG4gKi9cbmZ1bmN0aW9uIHN0YW5kYXJkaXplRmlyZWZveEFjdGl2ZUljZUNhbmRpZGF0ZVBhaXJTdGF0cyhzdGF0cykge1xuICAgIHZhciBhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHMgPSBBcnJheS5mcm9tKHN0YXRzLnZhbHVlcygpKS5maW5kKGZ1bmN0aW9uIChzdGF0KSB7XG4gICAgICAgIHJldHVybiBzdGF0LnR5cGUgPT09ICdjYW5kaWRhdGUtcGFpcicgJiYgc3RhdC5ub21pbmF0ZWQ7XG4gICAgfSk7XG4gICAgaWYgKCFhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBhY3RpdmVMb2NhbENhbmRpZGF0ZVN0YXRzID0gc3RhdHMuZ2V0KGFjdGl2ZUNhbmRpZGF0ZVBhaXJTdGF0cy5sb2NhbENhbmRpZGF0ZUlkKTtcbiAgICB2YXIgYWN0aXZlUmVtb3RlQ2FuZGlkYXRlU3RhdHMgPSBzdGF0cy5nZXQoYWN0aXZlQ2FuZGlkYXRlUGFpclN0YXRzLnJlbW90ZUNhbmRpZGF0ZUlkKTtcbiAgICB2YXIgc3RhbmRhcmRpemVkQ2FuZGlkYXRlU3RhdHNLZXlzID0gW1xuICAgICAgICB7IGtleTogJ2NhbmRpZGF0ZVR5cGUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IGtleTogJ2lwJywgZmZLZXlzOiBbJ2FkZHJlc3MnLCAnaXBBZGRyZXNzJ10sIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsga2V5OiAncG9ydCcsIGZmS2V5czogWydwb3J0TnVtYmVyJ10sIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsga2V5OiAncHJpb3JpdHknLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ3Byb3RvY29sJywgZmZLZXlzOiBbJ3RyYW5zcG9ydCddLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IGtleTogJ3VybCcsIHR5cGU6ICdzdHJpbmcnIH1cbiAgICBdO1xuICAgIHZhciBzdGFuZGFyZGl6ZWRMb2NhbENhbmRpZGF0ZVN0YXRzS2V5cyA9IHN0YW5kYXJkaXplZENhbmRpZGF0ZVN0YXRzS2V5cy5jb25jYXQoW1xuICAgICAgICB7IGtleTogJ2RlbGV0ZWQnLCB0eXBlOiAnYm9vbGVhbicgfSxcbiAgICAgICAgeyBrZXk6ICdyZWxheVByb3RvY29sJywgdHlwZTogJ3N0cmluZycgfVxuICAgIF0pO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlcyA9IHtcbiAgICAgICAgaG9zdDogJ2hvc3QnLFxuICAgICAgICBwZWVycmVmbGV4aXZlOiAncHJmbHgnLFxuICAgICAgICByZWxheWVkOiAncmVsYXknLFxuICAgICAgICBzZXJ2ZXJyZWZsZXhpdmU6ICdzcmZseCdcbiAgICB9O1xuICAgIHZhciBzdGFuZGF0ZGl6ZWRMb2NhbENhbmRpZGF0ZVN0YXRzUmVwb3J0ID0gYWN0aXZlTG9jYWxDYW5kaWRhdGVTdGF0c1xuICAgICAgICA/IHN0YW5kYXJkaXplZExvY2FsQ2FuZGlkYXRlU3RhdHNLZXlzLnJlZHVjZShmdW5jdGlvbiAocmVwb3J0LCBrZXlJbmZvKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5SW5mby5mZktleXMgJiYga2V5SW5mby5mZktleXMuZmluZChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleSBpbiBhY3RpdmVMb2NhbENhbmRpZGF0ZVN0YXRzO1xuICAgICAgICAgICAgfSkgfHwga2V5SW5mby5rZXk7XG4gICAgICAgICAgICByZXBvcnRba2V5SW5mby5rZXldID0gdHlwZW9mIGFjdGl2ZUxvY2FsQ2FuZGlkYXRlU3RhdHNba2V5XSA9PT0ga2V5SW5mby50eXBlXG4gICAgICAgICAgICAgICAgPyBrZXkgPT09ICdjYW5kaWRhdGVUeXBlJ1xuICAgICAgICAgICAgICAgICAgICA/IGNhbmRpZGF0ZVR5cGVzW2FjdGl2ZUxvY2FsQ2FuZGlkYXRlU3RhdHNba2V5XV0gfHwgYWN0aXZlTG9jYWxDYW5kaWRhdGVTdGF0c1trZXldXG4gICAgICAgICAgICAgICAgICAgIDogYWN0aXZlTG9jYWxDYW5kaWRhdGVTdGF0c1trZXldXG4gICAgICAgICAgICAgICAgOiBrZXkgPT09ICdkZWxldGVkJyA/IGZhbHNlIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiByZXBvcnQ7XG4gICAgICAgIH0sIHt9KVxuICAgICAgICA6IG51bGw7XG4gICAgdmFyIHN0YW5kYXJkaXplZFJlbW90ZUNhbmRpZGF0ZVN0YXRzUmVwb3J0ID0gYWN0aXZlUmVtb3RlQ2FuZGlkYXRlU3RhdHNcbiAgICAgICAgPyBzdGFuZGFyZGl6ZWRDYW5kaWRhdGVTdGF0c0tleXMucmVkdWNlKGZ1bmN0aW9uIChyZXBvcnQsIGtleUluZm8pIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlJbmZvLmZmS2V5cyAmJiBrZXlJbmZvLmZmS2V5cy5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5IGluIGFjdGl2ZVJlbW90ZUNhbmRpZGF0ZVN0YXRzO1xuICAgICAgICAgICAgfSkgfHwga2V5SW5mby5rZXk7XG4gICAgICAgICAgICByZXBvcnRba2V5SW5mby5rZXldID0gdHlwZW9mIGFjdGl2ZVJlbW90ZUNhbmRpZGF0ZVN0YXRzW2tleV0gPT09IGtleUluZm8udHlwZVxuICAgICAgICAgICAgICAgID8ga2V5ID09PSAnY2FuZGlkYXRlVHlwZSdcbiAgICAgICAgICAgICAgICAgICAgPyBjYW5kaWRhdGVUeXBlc1thY3RpdmVSZW1vdGVDYW5kaWRhdGVTdGF0c1trZXldXSB8fCBhY3RpdmVSZW1vdGVDYW5kaWRhdGVTdGF0c1trZXldXG4gICAgICAgICAgICAgICAgICAgIDogYWN0aXZlUmVtb3RlQ2FuZGlkYXRlU3RhdHNba2V5XVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiByZXBvcnQ7XG4gICAgICAgIH0sIHt9KVxuICAgICAgICA6IG51bGw7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgeyBrZXk6ICdhdmFpbGFibGVJbmNvbWluZ0JpdHJhdGUnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ2F2YWlsYWJsZU91dGdvaW5nQml0cmF0ZScsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsga2V5OiAnYnl0ZXNSZWNlaXZlZCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsga2V5OiAnYnl0ZXNTZW50JywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBrZXk6ICdjb25zZW50UmVxdWVzdHNTZW50JywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBrZXk6ICdjdXJyZW50Um91bmRUcmlwVGltZScsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsga2V5OiAnbGFzdFBhY2tldFJlY2VpdmVkVGltZXN0YW1wJywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBrZXk6ICdsYXN0UGFja2V0U2VudFRpbWVzdGFtcCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsga2V5OiAnbm9taW5hdGVkJywgdHlwZTogJ2Jvb2xlYW4nIH0sXG4gICAgICAgIHsga2V5OiAncHJpb3JpdHknLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ3JlYWRhYmxlJywgdHlwZTogJ2Jvb2xlYW4nIH0sXG4gICAgICAgIHsga2V5OiAncmVxdWVzdHNSZWNlaXZlZCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsga2V5OiAncmVxdWVzdHNTZW50JywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBrZXk6ICdyZXNwb25zZXNSZWNlaXZlZCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsga2V5OiAncmVzcG9uc2VzU2VudCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsga2V5OiAncmV0cmFuc21pc3Npb25zUmVjZWl2ZWQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ3JldHJhbnNtaXNzaW9uc1NlbnQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ3N0YXRlJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgeyBrZXk6ICd0b3RhbFJvdW5kVHJpcFRpbWUnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IGtleTogJ3RyYW5zcG9ydElkJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgeyBrZXk6ICd3cml0YWJsZScsIHR5cGU6ICdib29sZWFuJyB9XG4gICAgXS5yZWR1Y2UoZnVuY3Rpb24gKHJlcG9ydCwga2V5SW5mbykge1xuICAgICAgICByZXBvcnRba2V5SW5mby5rZXldID0gdHlwZW9mIGFjdGl2ZUNhbmRpZGF0ZVBhaXJTdGF0c1trZXlJbmZvLmtleV0gPT09IGtleUluZm8udHlwZVxuICAgICAgICAgICAgPyBhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHNba2V5SW5mby5rZXldXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIHJldHVybiByZXBvcnQ7XG4gICAgfSwge1xuICAgICAgICBsb2NhbENhbmRpZGF0ZTogc3RhbmRhdGRpemVkTG9jYWxDYW5kaWRhdGVTdGF0c1JlcG9ydCxcbiAgICAgICAgcmVtb3RlQ2FuZGlkYXRlOiBzdGFuZGFyZGl6ZWRSZW1vdGVDYW5kaWRhdGVTdGF0c1JlcG9ydFxuICAgIH0pO1xufVxuLyoqXG4gKiBHZXQgbG9jYWwvcmVtb3RlIGF1ZGlvL3ZpZGVvIE1lZGlhU3RyZWFtVHJhY2tzLlxuICogQHBhcmFtIHtSVENQZWVyQ29ubmVjdGlvbn0gcGVlckNvbm5lY3Rpb24gLSBUaGUgUlRDUGVlckNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBraW5kIC0gJ2F1ZGlvJyBvciAndmlkZW8nXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xvY2FsT3JSZW1vdGVdIC0gJ2xvY2FsJyBvciAncmVtb3RlJ1xuICogQHJldHVybnMge0FycmF5PE1lZGlhU3RyZWFtVHJhY2s+fVxuICovXG5mdW5jdGlvbiBnZXRUcmFja3MocGVlckNvbm5lY3Rpb24sIGtpbmQsIGxvY2FsT3JSZW1vdGUpIHtcbiAgICB2YXIgZ2V0U2VuZGVyc09yUmVjZWl2ZXJzID0gbG9jYWxPclJlbW90ZSA9PT0gJ2xvY2FsJyA/ICdnZXRTZW5kZXJzJyA6ICdnZXRSZWNlaXZlcnMnO1xuICAgIGlmIChwZWVyQ29ubmVjdGlvbltnZXRTZW5kZXJzT3JSZWNlaXZlcnNdKSB7XG4gICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbltnZXRTZW5kZXJzT3JSZWNlaXZlcnNdKCkubWFwKGZ1bmN0aW9uIChzZW5kZXJPclJlY2VpdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VuZGVyT3JSZWNlaXZlci50cmFjaztcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrICYmIHRyYWNrLmtpbmQgPT09IGtpbmQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZ2V0U3RyZWFtcyA9IGxvY2FsT3JSZW1vdGUgPT09ICdsb2NhbCcgPyAnZ2V0TG9jYWxTdHJlYW1zJyA6ICdnZXRSZW1vdGVTdHJlYW1zJztcbiAgICByZXR1cm4gZmxhdE1hcChwZWVyQ29ubmVjdGlvbltnZXRTdHJlYW1zXSgpLCBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIHZhciBnZXRUcmFja3MgPSBraW5kID09PSAnYXVkaW8nID8gJ2dldEF1ZGlvVHJhY2tzJyA6ICdnZXRWaWRlb1RyYWNrcyc7XG4gICAgICAgIHJldHVybiBzdHJlYW1bZ2V0VHJhY2tzXSgpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBHZXQgdGhlIHN0YW5kYXJkaXplZCBzdGF0aXN0aWNzIGZvciBhIHBhcnRpY3VsYXIgTWVkaWFTdHJlYW1UcmFjay5cbiAqIEBwYXJhbSB7UlRDUGVlckNvbm5lY3Rpb259IHBlZXJDb25uZWN0aW9uXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gVXNlZCBmb3IgdGVzdGluZ1xuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5PFN0YW5kYXJkaXplZFRyYWNrU3RhdHNSZXBvcnQ+Pn1cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhY2tTdGF0cyhwZWVyQ29ubmVjdGlvbiwgdHJhY2ssIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudGVzdEZvckNocm9tZSAhPT0gJ3VuZGVmaW5lZCcgfHwgaXNDaHJvbWUpIHtcbiAgICAgICAgcmV0dXJuIGNocm9tZU9yU2FmYXJpR2V0VHJhY2tTdGF0cyhwZWVyQ29ubmVjdGlvbiwgdHJhY2spO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudGVzdEZvckZpcmVmb3ggIT09ICd1bmRlZmluZWQnIHx8IGlzRmlyZWZveCkge1xuICAgICAgICByZXR1cm4gZmlyZWZveEdldFRyYWNrU3RhdHMocGVlckNvbm5lY3Rpb24sIHRyYWNrLCBvcHRpb25zLmlzUmVtb3RlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRlc3RGb3JTYWZhcmkgIT09ICd1bmRlZmluZWQnIHx8IGlzU2FmYXJpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50ZXN0Rm9yU2FmYXJpICE9PSAndW5kZWZpbmVkJyB8fCBnZXRTZHBGb3JtYXQoKSA9PT0gJ3VuaWZpZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hyb21lT3JTYWZhcmlHZXRUcmFja1N0YXRzKHBlZXJDb25uZWN0aW9uLCB0cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URShzeWVycmFwcmFnYWRhKTogZ2V0U3RhdHMoKSBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gICAgICAgIC8vIFNhZmFyaSB2ZXJzaW9ucyB3aGVyZSBwbGFuLWIgaXMgdGhlIFNEUCBmb3JtYXRcbiAgICAgICAgLy8gZHVlIHRvIHRoaXMgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTkyNjAxXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoW1xuICAgICAgICAgICAgJ2dldFN0YXRzKCkgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIHZlcnNpb24gb2YgU2FmYXJpJyxcbiAgICAgICAgICAgICdkdWUgdG8gdGhpcyBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xOTI2MDEnXG4gICAgICAgIF0uam9pbignICcpKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1JUQ1BlZXJDb25uZWN0aW9uI2dldFN0YXRzKCkgbm90IHN1cHBvcnRlZCcpKTtcbn1cbi8qKlxuICogR2V0IHRoZSBzdGFuZGFyZGl6ZWQgc3RhdGlzdGljcyBmb3IgYSBwYXJ0aWN1bGFyIE1lZGlhU3RyZWFtVHJhY2sgaW4gQ2hyb21lIG9yIFNhZmFyaS5cbiAqIEBwYXJhbSB7UlRDUGVlckNvbm5lY3Rpb259IHBlZXJDb25uZWN0aW9uXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXk8U3RhbmRhcmRpemVkVHJhY2tTdGF0c1JlcG9ydD4+fVxuICovXG5mdW5jdGlvbiBjaHJvbWVPclNhZmFyaUdldFRyYWNrU3RhdHMocGVlckNvbm5lY3Rpb24sIHRyYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKGNocm9tZU1ham9yVmVyc2lvbiAmJiBjaHJvbWVNYWpvclZlcnNpb24gPCA2Nykge1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24uZ2V0U3RhdHMoZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShbc3RhbmRhcmRpemVDaHJvbWVMZWdhY3lTdGF0cyhyZXNwb25zZSwgdHJhY2spXSk7XG4gICAgICAgICAgICB9LCBudWxsLCByZWplY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBlZXJDb25uZWN0aW9uLmdldFN0YXRzKHRyYWNrKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShzdGFuZGFyZGl6ZUNocm9tZU9yU2FmYXJpU3RhdHMocmVzcG9uc2UpKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICB9KTtcbn1cbi8qKlxuICogR2V0IHRoZSBzdGFuZGFyZGl6ZWQgc3RhdGlzdGljcyBmb3IgYSBwYXJ0aWN1bGFyIE1lZGlhU3RyZWFtVHJhY2sgaW4gRmlyZWZveC5cbiAqIEBwYXJhbSB7UlRDUGVlckNvbm5lY3Rpb259IHBlZXJDb25uZWN0aW9uXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzUmVtb3RlXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXk8U3RhbmRhcmRpemVkVHJhY2tTdGF0c1JlcG9ydD4+fVxuICovXG5mdW5jdGlvbiBmaXJlZm94R2V0VHJhY2tTdGF0cyhwZWVyQ29ubmVjdGlvbiwgdHJhY2ssIGlzUmVtb3RlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcGVlckNvbm5lY3Rpb24uZ2V0U3RhdHModHJhY2spLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXNvbHZlKFtzdGFuZGFyZGl6ZUZpcmVmb3hTdGF0cyhyZXNwb25zZSwgaXNSZW1vdGUpXSk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgfSk7XG59XG4vKipcbiAqIFN0YW5kYXJkaXplIHRoZSBNZWRpYVN0cmVhbVRyYWNrJ3MgbGVnYWN5IHN0YXRpc3RpY3MgaW4gQ2hyb21lLlxuICogQHBhcmFtIHtSVENTdGF0c1Jlc3BvbnNlfSByZXNwb25zZVxuICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICogQHJldHVybnMge1N0YW5kYXJkaXplZFRyYWNrU3RhdHNSZXBvcnR9XG4gKi9cbmZ1bmN0aW9uIHN0YW5kYXJkaXplQ2hyb21lTGVnYWN5U3RhdHMocmVzcG9uc2UsIHRyYWNrKSB7XG4gICAgdmFyIHNzcmNSZXBvcnQgPSByZXNwb25zZS5yZXN1bHQoKS5maW5kKGZ1bmN0aW9uIChyZXBvcnQpIHtcbiAgICAgICAgcmV0dXJuIHJlcG9ydC50eXBlID09PSAnc3NyYycgJiYgcmVwb3J0LnN0YXQoJ2dvb2dUcmFja0lkJykgPT09IHRyYWNrLmlkO1xuICAgIH0pO1xuICAgIHZhciBzdGFuZGFyZGl6ZWRTdGF0cyA9IHt9O1xuICAgIGlmIChzc3JjUmVwb3J0KSB7XG4gICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLnRpbWVzdGFtcCA9IE1hdGgucm91bmQoTnVtYmVyKHNzcmNSZXBvcnQudGltZXN0YW1wKSk7XG4gICAgICAgIHN0YW5kYXJkaXplZFN0YXRzID0gc3NyY1JlcG9ydC5uYW1lcygpLnJlZHVjZShmdW5jdGlvbiAoc3RhdHMsIG5hbWUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2dvb2dDb2RlY05hbWUnOlxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5jb2RlY05hbWUgPSBzc3JjUmVwb3J0LnN0YXQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2dvb2dSdHQnOlxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5yb3VuZFRyaXBUaW1lID0gTnVtYmVyKHNzcmNSZXBvcnQuc3RhdChuYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2dvb2dKaXR0ZXJSZWNlaXZlZCc6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLmppdHRlciA9IE51bWJlcihzc3JjUmVwb3J0LnN0YXQobmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnb29nRnJhbWVXaWR0aElucHV0JzpcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMuZnJhbWVXaWR0aElucHV0ID0gTnVtYmVyKHNzcmNSZXBvcnQuc3RhdChuYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2dvb2dGcmFtZUhlaWdodElucHV0JzpcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMuZnJhbWVIZWlnaHRJbnB1dCA9IE51bWJlcihzc3JjUmVwb3J0LnN0YXQobmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnb29nRnJhbWVXaWR0aFNlbnQnOlxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5mcmFtZVdpZHRoU2VudCA9IE51bWJlcihzc3JjUmVwb3J0LnN0YXQobmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnb29nRnJhbWVIZWlnaHRTZW50JzpcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMuZnJhbWVIZWlnaHRTZW50ID0gTnVtYmVyKHNzcmNSZXBvcnQuc3RhdChuYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2dvb2dGcmFtZVdpZHRoUmVjZWl2ZWQnOlxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5mcmFtZVdpZHRoUmVjZWl2ZWQgPSBOdW1iZXIoc3NyY1JlcG9ydC5zdGF0KG5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZ29vZ0ZyYW1lSGVpZ2h0UmVjZWl2ZWQnOlxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5mcmFtZUhlaWdodFJlY2VpdmVkID0gTnVtYmVyKHNzcmNSZXBvcnQuc3RhdChuYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2dvb2dGcmFtZVJhdGVJbnB1dCc6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLmZyYW1lUmF0ZUlucHV0ID0gTnVtYmVyKHNzcmNSZXBvcnQuc3RhdChuYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2dvb2dGcmFtZVJhdGVTZW50JzpcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMuZnJhbWVSYXRlU2VudCA9IE51bWJlcihzc3JjUmVwb3J0LnN0YXQobmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnb29nRnJhbWVSYXRlUmVjZWl2ZWQnOlxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5mcmFtZVJhdGVSZWNlaXZlZCA9IE51bWJlcihzc3JjUmVwb3J0LnN0YXQobmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzc3JjJzpcbiAgICAgICAgICAgICAgICAgICAgc3RhdHNbbmFtZV0gPSBzc3JjUmVwb3J0LnN0YXQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2J5dGVzUmVjZWl2ZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2J5dGVzU2VudCc6XG4gICAgICAgICAgICAgICAgY2FzZSAncGFja2V0c0xvc3QnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3BhY2tldHNSZWNlaXZlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAncGFja2V0c1NlbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2F1ZGlvSW5wdXRMZXZlbCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnYXVkaW9PdXRwdXRMZXZlbCc6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzW25hbWVdID0gTnVtYmVyKHNzcmNSZXBvcnQuc3RhdChuYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRzO1xuICAgICAgICB9LCBzdGFuZGFyZGl6ZWRTdGF0cyk7XG4gICAgfVxuICAgIHJldHVybiBzdGFuZGFyZGl6ZWRTdGF0cztcbn1cbi8qKlxuICogU3RhbmRhcmRpemUgdGhlIE1lZGlhU3RyZWFtVHJhY2sncyBzdGF0aXN0aWNzIGluIENocm9tZSBvciBTYWZhcmkuXG4gKiBAcGFyYW0ge1JUQ1N0YXRzUmVzcG9uc2V9IHJlc3BvbnNlXG4gKiBAcmV0dXJucyB7QXJyYXk8U3RhbmRhcmRpemVkVHJhY2tTdGF0c1JlcG9ydD59XG4gKi9cbmZ1bmN0aW9uIHN0YW5kYXJkaXplQ2hyb21lT3JTYWZhcmlTdGF0cyhyZXNwb25zZSkge1xuICAgIHZhciBpbmJvdW5kID0gbnVsbDtcbiAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogV2Ugc2hvdWxkIGV4cGVjdCBtb3JlIHRoYW4gb25lIFwib3V0Ym91bmQtcnRwXCIgc3RhdHMgZm9yIGFcbiAgICAvLyBWUDggc2ltdWxjYXN0IE1lZGlhU3RyZWFtVHJhY2suXG4gICAgdmFyIG91dGJvdW5kID0gW107XG4gICAgdmFyIHJlbW90ZUluYm91bmQgPSBudWxsO1xuICAgIHZhciByZW1vdGVPdXRib3VuZCA9IG51bGw7XG4gICAgdmFyIHRyYWNrID0gbnVsbDtcbiAgICB2YXIgY29kZWMgPSBudWxsO1xuICAgIHZhciBsb2NhbE1lZGlhID0gbnVsbDtcbiAgICByZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0KSB7XG4gICAgICAgIHN3aXRjaCAoc3RhdC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdpbmJvdW5kLXJ0cCc6XG4gICAgICAgICAgICAgICAgaW5ib3VuZCA9IHN0YXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvdXRib3VuZC1ydHAnOlxuICAgICAgICAgICAgICAgIG91dGJvdW5kLnB1c2goc3RhdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZWRpYS1zb3VyY2UnOlxuICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEgPSBzdGF0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndHJhY2snOlxuICAgICAgICAgICAgICAgIHRyYWNrID0gc3RhdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvZGVjJzpcbiAgICAgICAgICAgICAgICBjb2RlYyA9IHN0YXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZW1vdGUtaW5ib3VuZC1ydHAnOlxuICAgICAgICAgICAgICAgIHJlbW90ZUluYm91bmQgPSBzdGF0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVtb3RlLW91dGJvdW5kLXJ0cCc6XG4gICAgICAgICAgICAgICAgcmVtb3RlT3V0Ym91bmQgPSBzdGF0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGlzUmVtb3RlID0gdHJhY2sgJiYgdHJhY2sucmVtb3RlU291cmNlO1xuICAgIHZhciBtYWluU291cmNlcyA9IGlzUmVtb3RlID8gW2luYm91bmRdIDogb3V0Ym91bmQ7XG4gICAgdmFyIHN0YXRzID0gW107XG4gICAgdmFyIHJlbW90ZVNvdXJjZSA9IGlzUmVtb3RlID8gcmVtb3RlT3V0Ym91bmQgOiByZW1vdGVJbmJvdW5kOyAvLyByZW1vdGUgcnRwIHN0YXRzXG4gICAgbWFpblNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBzdGFuZGFyZGl6ZWRTdGF0cyA9IHt9O1xuICAgICAgICB2YXIgc3RhdFNvdXJjZXMgPSBbXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICBsb2NhbE1lZGlhLFxuICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICAgIHJlbW90ZVNvdXJjZSAmJiByZW1vdGVTb3VyY2Uuc3NyYyA9PT0gc291cmNlLnNzcmMgPyByZW1vdGVTb3VyY2UgOiBudWxsLCAvLyByZW1vdGUgcnRwIHN0YXRzXG4gICAgICAgIF07XG4gICAgICAgIGZ1bmN0aW9uIGdldFN0YXRWYWx1ZShuYW1lKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlRm91bmQgPSBzdGF0U291cmNlcy5maW5kKGZ1bmN0aW9uIChzdGF0U291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRTb3VyY2UgJiYgdHlwZW9mIHN0YXRTb3VyY2VbbmFtZV0gIT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgfSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VGb3VuZCA/IHNvdXJjZUZvdW5kW25hbWVdIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3NyYyA9IGdldFN0YXRWYWx1ZSgnc3NyYycpO1xuICAgICAgICBpZiAodHlwZW9mIHNzcmMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5zc3JjID0gU3RyaW5nKHNzcmMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBnZXRTdGF0VmFsdWUoJ3RpbWVzdGFtcCcpO1xuICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy50aW1lc3RhbXAgPSBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gICAgICAgIHZhciBtaW1lVHlwZSA9IGdldFN0YXRWYWx1ZSgnbWltZVR5cGUnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtaW1lVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1pbWVUeXBlID0gbWltZVR5cGUuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLmNvZGVjTmFtZSA9IG1pbWVUeXBlW21pbWVUeXBlLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3VuZFRyaXBUaW1lID0gZ2V0U3RhdFZhbHVlKCdyb3VuZFRyaXBUaW1lJyk7XG4gICAgICAgIGlmICh0eXBlb2Ygcm91bmRUcmlwVGltZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLnJvdW5kVHJpcFRpbWUgPSBNYXRoLnJvdW5kKHJvdW5kVHJpcFRpbWUgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaml0dGVyID0gZ2V0U3RhdFZhbHVlKCdqaXR0ZXInKTtcbiAgICAgICAgaWYgKHR5cGVvZiBqaXR0ZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5qaXR0ZXIgPSBNYXRoLnJvdW5kKGppdHRlciAqIDEwMDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcmFtZVdpZHRoID0gZ2V0U3RhdFZhbHVlKCdmcmFtZVdpZHRoJyk7XG4gICAgICAgIGlmICh0eXBlb2YgZnJhbWVXaWR0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChpc1JlbW90ZSkge1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLmZyYW1lV2lkdGhSZWNlaXZlZCA9IGZyYW1lV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5mcmFtZVdpZHRoU2VudCA9IGZyYW1lV2lkdGg7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMuZnJhbWVXaWR0aElucHV0ID0gdHJhY2suZnJhbWVXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJhbWVIZWlnaHQgPSBnZXRTdGF0VmFsdWUoJ2ZyYW1lSGVpZ2h0Jyk7XG4gICAgICAgIGlmICh0eXBlb2YgZnJhbWVIZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoaXNSZW1vdGUpIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5mcmFtZUhlaWdodFJlY2VpdmVkID0gZnJhbWVIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5mcmFtZUhlaWdodFNlbnQgPSBmcmFtZUhlaWdodDtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5mcmFtZUhlaWdodElucHV0ID0gdHJhY2suZnJhbWVIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyYW1lc1BlclNlY29uZCA9IGdldFN0YXRWYWx1ZSgnZnJhbWVzUGVyU2Vjb25kJyk7XG4gICAgICAgIGlmICh0eXBlb2YgZnJhbWVzUGVyU2Vjb25kID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc3RhbmRhcmRpemVkU3RhdHNbaXNSZW1vdGUgPyAnZnJhbWVSYXRlUmVjZWl2ZWQnIDogJ2ZyYW1lUmF0ZVNlbnQnXSA9IGZyYW1lc1BlclNlY29uZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZXNSZWNlaXZlZCA9IGdldFN0YXRWYWx1ZSgnYnl0ZXNSZWNlaXZlZCcpO1xuICAgICAgICBpZiAodHlwZW9mIGJ5dGVzUmVjZWl2ZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5ieXRlc1JlY2VpdmVkID0gYnl0ZXNSZWNlaXZlZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZXNTZW50ID0gZ2V0U3RhdFZhbHVlKCdieXRlc1NlbnQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBieXRlc1NlbnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5ieXRlc1NlbnQgPSBieXRlc1NlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhY2tldHNMb3N0ID0gZ2V0U3RhdFZhbHVlKCdwYWNrZXRzTG9zdCcpO1xuICAgICAgICBpZiAodHlwZW9mIHBhY2tldHNMb3N0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMucGFja2V0c0xvc3QgPSBwYWNrZXRzTG9zdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFja2V0c1JlY2VpdmVkID0gZ2V0U3RhdFZhbHVlKCdwYWNrZXRzUmVjZWl2ZWQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWNrZXRzUmVjZWl2ZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5wYWNrZXRzUmVjZWl2ZWQgPSBwYWNrZXRzUmVjZWl2ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhY2tldHNTZW50ID0gZ2V0U3RhdFZhbHVlKCdwYWNrZXRzU2VudCcpO1xuICAgICAgICBpZiAodHlwZW9mIHBhY2tldHNTZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMucGFja2V0c1NlbnQgPSBwYWNrZXRzU2VudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXVkaW9MZXZlbCA9IGdldFN0YXRWYWx1ZSgnYXVkaW9MZXZlbCcpO1xuICAgICAgICBpZiAodHlwZW9mIGF1ZGlvTGV2ZWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBhdWRpb0xldmVsID0gTWF0aC5yb3VuZChhdWRpb0xldmVsICogQ0hST01FX0xFR0FDWV9NQVhfQVVESU9fTEVWRUwpO1xuICAgICAgICAgICAgaWYgKGlzUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMuYXVkaW9PdXRwdXRMZXZlbCA9IGF1ZGlvTGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5hdWRpb0lucHV0TGV2ZWwgPSBhdWRpb0xldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0b3RhbFBhY2tldFNlbmREYWxheSA9IGdldFN0YXRWYWx1ZSgndG90YWxQYWNrZXRTZW5kRGVsYXknKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3RhbFBhY2tldFNlbmREYWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLnRvdGFsUGFja2V0U2VuZERlbGF5ID0gdG90YWxQYWNrZXRTZW5kRGFsYXk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdGFsRW5jb2RlVGltZSA9IGdldFN0YXRWYWx1ZSgndG90YWxFbmNvZGVUaW1lJyk7XG4gICAgICAgIGlmICh0eXBlb2YgdG90YWxFbmNvZGVUaW1lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMudG90YWxFbmNvZGVUaW1lID0gdG90YWxFbmNvZGVUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcmFtZXNFbmNvZGVkID0gZ2V0U3RhdFZhbHVlKCdmcmFtZXNFbmNvZGVkJyk7XG4gICAgICAgIGlmICh0eXBlb2YgZnJhbWVzRW5jb2RlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLmZyYW1lc0VuY29kZWQgPSBmcmFtZXNFbmNvZGVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wID0gZ2V0U3RhdFZhbHVlKCdlc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wJyk7XG4gICAgICAgIGlmICh0eXBlb2YgZXN0aW1hdGVkUGxheW91dFRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLmVzdGltYXRlZFBsYXlvdXRUaW1lc3RhbXAgPSBlc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3RhbERlY29kZVRpbWUgPSBnZXRTdGF0VmFsdWUoJ3RvdGFsRGVjb2RlVGltZScpO1xuICAgICAgICBpZiAodHlwZW9mIHRvdGFsRGVjb2RlVGltZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLnRvdGFsRGVjb2RlVGltZSA9IHRvdGFsRGVjb2RlVGltZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJhbWVzRGVjb2RlZCA9IGdldFN0YXRWYWx1ZSgnZnJhbWVzRGVjb2RlZCcpO1xuICAgICAgICBpZiAodHlwZW9mIGZyYW1lc0RlY29kZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5mcmFtZXNEZWNvZGVkID0gZnJhbWVzRGVjb2RlZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaml0dGVyQnVmZmVyRGVsYXkgPSBnZXRTdGF0VmFsdWUoJ2ppdHRlckJ1ZmZlckRlbGF5Jyk7XG4gICAgICAgIGlmICh0eXBlb2Ygaml0dGVyQnVmZmVyRGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5qaXR0ZXJCdWZmZXJEZWxheSA9IGppdHRlckJ1ZmZlckRlbGF5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBqaXR0ZXJCdWZmZXJFbWl0dGVkQ291bnQgPSBnZXRTdGF0VmFsdWUoJ2ppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudCcpO1xuICAgICAgICBpZiAodHlwZW9mIGppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLmppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudCA9IGppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0cy5wdXNoKHN0YW5kYXJkaXplZFN0YXRzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RhdHM7XG59XG4vKipcbiAqIFN0YW5kYXJkaXplIHRoZSBNZWRpYVN0cmVhbVRyYWNrJ3Mgc3RhdGlzdGljcyBpbiBGaXJlZm94LlxuICogQHBhcmFtIHtSVENTdGF0c1JlcG9ydH0gcmVzcG9uc2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSZW1vdGVcbiAqIEByZXR1cm5zIHtTdGFuZGFyZGl6ZWRUcmFja1N0YXRzUmVwb3J0fVxuICovXG5mdW5jdGlvbiBzdGFuZGFyZGl6ZUZpcmVmb3hTdGF0cyhyZXNwb25zZSwgaXNSZW1vdGUpIHtcbiAgICAvLyBOT1RFKG1yb2JlcnRzKTogSWYgZ2V0U3RhdHMgaXMgY2FsbGVkIG9uIGEgY2xvc2VkIFJUQ1BlZXJDb25uZWN0aW9uLFxuICAgIC8vIEZpcmVmb3ggcmV0dXJucyB1bmRlZmluZWQgaW5zdGVhZCBvZiBhbiBSVENTdGF0c1JlcG9ydC4gV2Ugd29ya2Fyb3VuZCB0aGlzXG4gICAgLy8gaGVyZS4gU2VlIHRoZSBmb2xsb3dpbmcgYnVnIGZvciBtb3JlIGRldGFpbHM6XG4gICAgLy9cbiAgICAvLyAgIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzcyMjVcbiAgICAvL1xuICAgIHJlc3BvbnNlID0gcmVzcG9uc2UgfHwgbmV3IE1hcCgpO1xuICAgIHZhciBpbmJvdW5kID0gbnVsbDtcbiAgICB2YXIgb3V0Ym91bmQgPSBudWxsO1xuICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFN0YXJ0aW5nIGZyb20gRmlyZWZveCA2MywgUlRDe0luYm91bmQsIE91dGJvdW5kfVJUUFN0cmVhbVN0YXRzLmlzUmVtb3RlXG4gICAgLy8gd2lsbCBiZSBkZXByZWNhdGVkLCBmb2xsb3dlZCBieSBpdHMgcmVtb3ZhbCBpbiBGaXJlZm94IDY2LiBBbHNvLCB0cnlpbmcgdG9cbiAgICAvLyBhY2Nlc3MgbWVtYmVycyBvZiB0aGUgcmVtb3RlIFJUQ3tJbmJvdW5kLCBPdXRib3VuZH1SVFBTdHJlYW1TdGF0cyB3aXRob3V0XG4gICAgLy8gdXNpbmcgUlRDU3RhdHNSZXBvcnQuZ2V0KHJlbW90ZUlkKSB3aWxsIHRyaWdnZXIgY29uc29sZSB3YXJuaW5ncy4gU28sIHdlXG4gICAgLy8gbm8gbG9uZ2VyIGRlcGVuZCBvbiBcImlzUmVtb3RlXCIsIGFuZCB3ZSBjYWxsIFJUQ1N0YXRzUmVwb3J0LmdldChyZW1vdGVJZClcbiAgICAvLyB0byBhY2Nlc3MgdGhlIHJlbW90ZSBSVEN7SW5ib3VuZCwgT3V0Ym91bmR9UlRQU3RyZWFtU3RhdHMuXG4gICAgLy9cbiAgICAvLyBTb3VyY2U6IGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93ZWJydGMvZ2V0c3RhdHMtaXNyZW1vdGUtNjUvXG4gICAgLy9cbiAgICByZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0KSB7XG4gICAgICAgIGlmIChzdGF0LmlzUmVtb3RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzdGF0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2luYm91bmQtcnRwJzpcbiAgICAgICAgICAgICAgICBpbmJvdW5kID0gc3RhdDtcbiAgICAgICAgICAgICAgICBvdXRib3VuZCA9IHJlc3BvbnNlLmdldChzdGF0LnJlbW90ZUlkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ291dGJvdW5kLXJ0cCc6XG4gICAgICAgICAgICAgICAgb3V0Ym91bmQgPSBzdGF0O1xuICAgICAgICAgICAgICAgIGluYm91bmQgPSByZXNwb25zZS5nZXQoc3RhdC5yZW1vdGVJZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgZmlyc3QgPSBpc1JlbW90ZSA/IGluYm91bmQgOiBvdXRib3VuZDtcbiAgICB2YXIgc2Vjb25kID0gaXNSZW1vdGUgPyBvdXRib3VuZCA6IGluYm91bmQ7XG4gICAgZnVuY3Rpb24gZ2V0U3RhdFZhbHVlKG5hbWUpIHtcbiAgICAgICAgaWYgKGZpcnN0ICYmIHR5cGVvZiBmaXJzdFtuYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdFtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Vjb25kICYmIHR5cGVvZiBzZWNvbmRbbmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Vjb25kW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc3RhbmRhcmRpemVkU3RhdHMgPSB7fTtcbiAgICB2YXIgdGltZXN0YW1wID0gZ2V0U3RhdFZhbHVlKCd0aW1lc3RhbXAnKTtcbiAgICBzdGFuZGFyZGl6ZWRTdGF0cy50aW1lc3RhbXAgPSBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gICAgdmFyIHNzcmMgPSBnZXRTdGF0VmFsdWUoJ3NzcmMnKTtcbiAgICBpZiAodHlwZW9mIHNzcmMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLnNzcmMgPSBTdHJpbmcoc3NyYyk7XG4gICAgfVxuICAgIHZhciBieXRlc1NlbnQgPSBnZXRTdGF0VmFsdWUoJ2J5dGVzU2VudCcpO1xuICAgIGlmICh0eXBlb2YgYnl0ZXNTZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5ieXRlc1NlbnQgPSBieXRlc1NlbnQ7XG4gICAgfVxuICAgIHZhciBwYWNrZXRzTG9zdCA9IGdldFN0YXRWYWx1ZSgncGFja2V0c0xvc3QnKTtcbiAgICBpZiAodHlwZW9mIHBhY2tldHNMb3N0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5wYWNrZXRzTG9zdCA9IHBhY2tldHNMb3N0O1xuICAgIH1cbiAgICB2YXIgcGFja2V0c1NlbnQgPSBnZXRTdGF0VmFsdWUoJ3BhY2tldHNTZW50Jyk7XG4gICAgaWYgKHR5cGVvZiBwYWNrZXRzU2VudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMucGFja2V0c1NlbnQgPSBwYWNrZXRzU2VudDtcbiAgICB9XG4gICAgdmFyIHJvdW5kVHJpcFRpbWUgPSBnZXRTdGF0VmFsdWUoJ3JvdW5kVHJpcFRpbWUnKTtcbiAgICBpZiAodHlwZW9mIHJvdW5kVHJpcFRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIHJvdW5kVHJpcFRpbWUgaXMgZG91YmxlIC0gbWVhc3VyZWQgaW4gc2Vjb25kcy5cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y3JlbW90ZWluYm91bmRydHBzdHJlYW1zdGF0cy1yb3VuZHRyaXB0aW1lXG4gICAgICAgIC8vIGNvdmVyIGl0IHRvIG1pbGxpc2Vjb25kcyAoYW5kIG1ha2UgaXQgaW50ZWdlcilcbiAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMucm91bmRUcmlwVGltZSA9IE1hdGgucm91bmQocm91bmRUcmlwVGltZSAqIDEwMDApO1xuICAgIH1cbiAgICB2YXIgaml0dGVyID0gZ2V0U3RhdFZhbHVlKCdqaXR0ZXInKTtcbiAgICBpZiAodHlwZW9mIGppdHRlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMuaml0dGVyID0gTWF0aC5yb3VuZChqaXR0ZXIgKiAxMDAwKTtcbiAgICB9XG4gICAgdmFyIGZyYW1lUmF0ZVNlbnQgPSBnZXRTdGF0VmFsdWUoJ2ZyYW1lcmF0ZU1lYW4nKTtcbiAgICBpZiAodHlwZW9mIGZyYW1lUmF0ZVNlbnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLmZyYW1lUmF0ZVNlbnQgPSBNYXRoLnJvdW5kKGZyYW1lUmF0ZVNlbnQpO1xuICAgIH1cbiAgICB2YXIgYnl0ZXNSZWNlaXZlZCA9IGdldFN0YXRWYWx1ZSgnYnl0ZXNSZWNlaXZlZCcpO1xuICAgIGlmICh0eXBlb2YgYnl0ZXNSZWNlaXZlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMuYnl0ZXNSZWNlaXZlZCA9IGJ5dGVzUmVjZWl2ZWQ7XG4gICAgfVxuICAgIHZhciBwYWNrZXRzUmVjZWl2ZWQgPSBnZXRTdGF0VmFsdWUoJ3BhY2tldHNSZWNlaXZlZCcpO1xuICAgIGlmICh0eXBlb2YgcGFja2V0c1JlY2VpdmVkID09PSAnbnVtYmVyJykge1xuICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5wYWNrZXRzUmVjZWl2ZWQgPSBwYWNrZXRzUmVjZWl2ZWQ7XG4gICAgfVxuICAgIHZhciBmcmFtZVJhdGVSZWNlaXZlZCA9IGdldFN0YXRWYWx1ZSgnZnJhbWVyYXRlTWVhbicpO1xuICAgIGlmICh0eXBlb2YgZnJhbWVSYXRlUmVjZWl2ZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLmZyYW1lUmF0ZVJlY2VpdmVkID0gTWF0aC5yb3VuZChmcmFtZVJhdGVSZWNlaXZlZCk7XG4gICAgfVxuICAgIHZhciB0b3RhbFBhY2tldFNlbmREYWxheSA9IGdldFN0YXRWYWx1ZSgndG90YWxQYWNrZXRTZW5kRGVsYXknKTtcbiAgICBpZiAodHlwZW9mIHRvdGFsUGFja2V0U2VuZERhbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy50b3RhbFBhY2tldFNlbmREZWxheSA9IHRvdGFsUGFja2V0U2VuZERhbGF5O1xuICAgIH1cbiAgICB2YXIgdG90YWxFbmNvZGVUaW1lID0gZ2V0U3RhdFZhbHVlKCd0b3RhbEVuY29kZVRpbWUnKTtcbiAgICBpZiAodHlwZW9mIHRvdGFsRW5jb2RlVGltZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMudG90YWxFbmNvZGVUaW1lID0gdG90YWxFbmNvZGVUaW1lO1xuICAgIH1cbiAgICB2YXIgZnJhbWVzRW5jb2RlZCA9IGdldFN0YXRWYWx1ZSgnZnJhbWVzRW5jb2RlZCcpO1xuICAgIGlmICh0eXBlb2YgZnJhbWVzRW5jb2RlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMuZnJhbWVzRW5jb2RlZCA9IGZyYW1lc0VuY29kZWQ7XG4gICAgfVxuICAgIHZhciBlc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wID0gZ2V0U3RhdFZhbHVlKCdlc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wJyk7XG4gICAgaWYgKHR5cGVvZiBlc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wID09PSAnbnVtYmVyJykge1xuICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5lc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wID0gZXN0aW1hdGVkUGxheW91dFRpbWVzdGFtcDtcbiAgICB9XG4gICAgdmFyIHRvdGFsRGVjb2RlVGltZSA9IGdldFN0YXRWYWx1ZSgndG90YWxEZWNvZGVUaW1lJyk7XG4gICAgaWYgKHR5cGVvZiB0b3RhbERlY29kZVRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLnRvdGFsRGVjb2RlVGltZSA9IHRvdGFsRGVjb2RlVGltZTtcbiAgICB9XG4gICAgdmFyIGZyYW1lc0RlY29kZWQgPSBnZXRTdGF0VmFsdWUoJ2ZyYW1lc0RlY29kZWQnKTtcbiAgICBpZiAodHlwZW9mIGZyYW1lc0RlY29kZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLmZyYW1lc0RlY29kZWQgPSBmcmFtZXNEZWNvZGVkO1xuICAgIH1cbiAgICB2YXIgaml0dGVyQnVmZmVyRGVsYXkgPSBnZXRTdGF0VmFsdWUoJ2ppdHRlckJ1ZmZlckRlbGF5Jyk7XG4gICAgaWYgKHR5cGVvZiBqaXR0ZXJCdWZmZXJEZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMuaml0dGVyQnVmZmVyRGVsYXkgPSBqaXR0ZXJCdWZmZXJEZWxheTtcbiAgICB9XG4gICAgdmFyIGppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudCA9IGdldFN0YXRWYWx1ZSgnaml0dGVyQnVmZmVyRW1pdHRlZENvdW50Jyk7XG4gICAgaWYgKHR5cGVvZiBqaXR0ZXJCdWZmZXJFbWl0dGVkQ291bnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLmppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudCA9IGppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YW5kYXJkaXplZFN0YXRzO1xufVxuLyoqXG4gKiBTdGFuZGFyZGl6ZWQgUlRDSWNlQ2FuZGlkYXRlIHN0YXRpc3RpY3MuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTdGFuZGFyZGl6ZWRJY2VDYW5kaWRhdGVTdGF0c1JlcG9ydFxuICogQHByb3BlcnR5IHsnaG9zdCd8J3ByZmx4J3wncmVsYXknfCdzcmZseCd9IGNhbmRpZGF0ZVR5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpcFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBvcnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcmlvcml0eVxuICogQHByb3BlcnR5IHsndGNwJ3wndWRwJ30gcHJvdG9jb2xcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmxcbiAqL1xuLyoqXG4gKiBTdGFuZGFyZGl6ZWQgbG9jYWwgUlRDSWNlQ2FuZGlkYXRlIHN0YXRpc3RpY3MuXG4gKiBAdHlwZWRlZiB7U3RhbmRhcmRpemVkSWNlQ2FuZGlkYXRlU3RhdHNSZXBvcnR9IFN0YW5kYXJkaXplZExvY2FsSWNlQ2FuZGlkYXRlU3RhdHNSZXBvcnRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlbGV0ZWQ9ZmFsc2VdXG4gKiBAcHJvcGVydHkgeyd0Y3AnfCd0bHMnfCd1ZHAnfSByZWxheVByb3RvY29sXG4gKi9cbi8qKlxuICogU3RhbmRhcmRpemVkIGFjdGl2ZSBSVENJY2VDYW5kaWRhdGUgcGFpciBzdGF0aXN0aWNzLlxuICogQHR5cGVkZWYge29iamVjdH0gU3RhbmRhcmRpemVkQWN0aXZlSWNlQ2FuZGlkYXRlUGFpclN0YXRzUmVwb3J0XG4gKiBAcHJvcGVydHkge251bWJlcn0gYXZhaWxhYmxlSW5jb21pbmdCaXRyYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gYXZhaWxhYmxlT3V0Z29pbmdCaXRyYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnl0ZXNSZWNlaXZlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJ5dGVzU2VudFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbnNlbnRSZXF1ZXN0c1NlbnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXJyZW50Um91bmRUcmlwVGltZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxhc3RQYWNrZXRSZWNlaXZlZFRpbWVzdGFtcFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxhc3RQYWNrZXRTZW50VGltZXN0YW1wXG4gKiBAcHJvcGVydHkge1N0YW5kYXJkaXplZExvY2FsSWNlQ2FuZGlkYXRlU3RhdHNSZXBvcnR9IGxvY2FsQ2FuZGlkYXRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG5vbWluYXRlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHByaW9yaXR5XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJlYWRhYmxlXG4gKiBAcHJvcGVydHkge1N0YW5kYXJkaXplZEljZUNhbmRpZGF0ZVN0YXRzUmVwb3J0fSByZW1vdGVDYW5kaWRhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXF1ZXN0c1JlY2VpdmVkXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmVxdWVzdHNTZW50XG4gKiBAcHJvcGVydHkge251bWJlcn0gcmVzcG9uc2VzUmVjZWl2ZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXNwb25zZXNTZW50XG4gKiBAcHJvcGVydHkge251bWJlcn0gcmV0cmFuc21pc3Npb25zUmVjZWl2ZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXRyYW5zbWlzc2lvbnNTZW50XG4gKiBAcHJvcGVydHkgeydmcm96ZW4nfCd3YWl0aW5nJ3wnaW4tcHJvZ3Jlc3MnfCdmYWlsZWQnfCdzdWNjZWVkZWQnfSBzdGF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvdGFsUm91bmRUcmlwVGltZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRyYW5zcG9ydElkXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHdyaXRhYmxlXG4gKi9cbi8qKlxuICogU3RhbmRhcmRpemVkIHtAbGluayBSVENQZWVyQ29ubmVjdGlvbn0gc3RhdGlzdGljcy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YW5kYXJkaXplZFN0YXRzUmVzcG9uc2VcbiAqIEBwcm9wZXJ0eSB7U3RhbmRhcmRpemVkQWN0aXZlSWNlQ2FuZGlkYXRlUGFpclN0YXRzUmVwb3J0fSBhY3RpdmVJY2VDYW5kaWRhdGVQYWlyIC0gU3RhdHMgZm9yIGFjdGl2ZSBJQ0UgY2FuZGlkYXRlIHBhaXJcbiAqIEBwcm9wZXJ0eSBBcnJheTxTdGFuZGFyZGl6ZWRUcmFja1N0YXRzUmVwb3J0PiBsb2NhbEF1ZGlvVHJhY2tTdGF0cyAtIFN0YXRzIGZvciBsb2NhbCBhdWRpbyBNZWRpYVN0cmVhbVRyYWNrc1xuICogQHByb3BlcnR5IEFycmF5PFN0YW5kYXJkaXplZFRyYWNrU3RhdHNSZXBvcnQ+IGxvY2FsVmlkZW9UcmFja1N0YXRzIC0gU3RhdHMgZm9yIGxvY2FsIHZpZGVvIE1lZGlhU3RyZWFtVHJhY2tzXG4gKiBAcHJvcGVydHkgQXJyYXk8U3RhbmRhcmRpemVkVHJhY2tTdGF0c1JlcG9ydD4gcmVtb3RlQXVkaW9UcmFja1N0YXRzIC0gU3RhdHMgZm9yIHJlbW90ZSBhdWRpbyBNZWRpYVN0cmVhbVRyYWNrc1xuICogQHByb3BlcnR5IEFycmF5PFN0YW5kYXJkaXplZFRyYWNrU3RhdHNSZXBvcnQ+IHJlbW90ZVZpZGVvVHJhY2tTdGF0cyAtIFN0YXRzIGZvciByZW1vdGUgdmlkZW8gTWVkaWFTdHJlYW1UcmFja3NcbiAqL1xuLyoqXG4gKiBTdGFuZGFyZGl6ZWQgTWVkaWFTdHJlYW1UcmFjayBzdGF0aXN0aWNzLlxuICogQHR5cGVkZWYge09iamVjdH0gU3RhbmRhcmRpemVkVHJhY2tTdGF0c1JlcG9ydFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRyYWNrSWQgLSBNZWRpYVN0cmVhbVRyYWNrIElEXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3NyYyAtIFNTUkMgb2YgdGhlIE1lZGlhU3RyZWFtVHJhY2tcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lc3RhbXAgLSBUaGUgVW5peCB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NvZGVjTmFtZV0gLSBOYW1lIG9mIHRoZSBjb2RlYyB1c2VkIHRvIGVuY29kZSB0aGUgTWVkaWFTdHJlYW1UcmFjaydzIG1lZGlhXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdW5kVHJpcFRpbWVdIC0gUm91bmQgdHJpcCB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtqaXR0ZXJdIC0gSml0dGVyIGluIG1pbGxpc2Vjb25kc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmcmFtZVdpZHRoSW5wdXRdIC0gV2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBsb2NhbCB2aWRlbyBNZWRpYVN0cmVhbVRyYWNrJ3MgY2FwdHVyZWQgZnJhbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZnJhbWVIZWlnaHRJbnB1dF0gLSBIZWlnaHQgaW4gcGl4ZWxzIG9mIHRoZSBsb2NhbCB2aWRlbyBNZWRpYVN0cmVhbVRyYWNrJ3MgY2FwdHVyZWQgZnJhbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZnJhbWVXaWR0aFNlbnRdIC0gV2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBsb2NhbCB2aWRlbyBNZWRpYVN0cmVhbVRyYWNrJ3MgZW5jb2RlZCBmcmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmcmFtZUhlaWdodFNlbnRdIC0gSGVpZ2h0IGluIHBpeGVscyBvZiB0aGUgbG9jYWwgdmlkZW8gTWVkaWFTdHJlYW1UcmFjaydzIGVuY29kZWQgZnJhbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZnJhbWVXaWR0aFJlY2VpdmVkXSAtIFdpZHRoIGluIHBpeGVscyBvZiB0aGUgcmVtb3RlIHZpZGVvIE1lZGlhU3RyZWFtVHJhY2sncyByZWNlaXZlZCBmcmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmcmFtZUhlaWdodFJlY2VpdmVkXSAtIEhlaWdodCBpbiBwaXhlbHMgb2YgdGhlIHJlbW90ZSB2aWRlbyBNZWRpYVN0cmVhbVRyYWNrJ3MgcmVjZWl2ZWQgZnJhbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZnJhbWVSYXRlSW5wdXRdIC0gQ2FwdHVyZWQgZnJhbWVzIHBlciBzZWNvbmQgb2YgdGhlIGxvY2FsIHZpZGVvIE1lZGlhU3RyZWFtVHJhY2tcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZnJhbWVSYXRlU2VudF0gLSBGcmFtZXMgcGVyIHNlY29uZCBvZiB0aGUgbG9jYWwgdmlkZW8gTWVkaWFTdHJlYW1UcmFjaydzIGVuY29kZWQgdmlkZW9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZnJhbWVSYXRlUmVjZWl2ZWRdIC0gRnJhbWVzIHBlciBzZWNvbmQgb2YgdGhlIHJlbW90ZSB2aWRlbyBNZWRpYVN0cmVhbVRyYWNrJ3MgcmVjZWl2ZWQgdmlkZW9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYnl0ZXNSZWNlaXZlZF0gLSBOdW1iZXIgb2YgYnl0ZXMgb2YgdGhlIHJlbW90ZSBNZWRpYVN0cmVhbVRyYWNrJ3MgbWVkaWEgcmVjZWl2ZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYnl0ZXNTZW50XSAtIE51bWJlciBvZiBieXRlcyBvZiB0aGUgbG9jYWwgTWVkaWFTdHJlYW1UcmFjaydzIG1lZGlhIHNlbnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGFja2V0c0xvc3RdIC0gTnVtYmVyIG9mIHBhY2tldHMgb2YgdGhlIE1lZGlhU3RyZWFtVHJhY2sncyBtZWRpYSBsb3N0XG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BhY2tldHNSZWNlaXZlZF0gLSBOdW1iZXIgb2YgcGFja2V0cyBvZiB0aGUgcmVtb3RlIE1lZGlhU3RyZWFtVHJhY2sncyBtZWRpYSByZWNlaXZlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwYWNrZXRzU2VudF0gLSBOdW1iZXIgb2YgcGFja2V0cyBvZiB0aGUgbG9jYWwgTWVkaWFTdHJlYW1UcmFjaydzIG1lZGlhIHNlbnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdG90YWxQYWNrZXRTZW5kRGVsYXldIC0gVGhlIHRvdGFsIG51bWJlciBvZiBzZWNvbmRzIHRoYXQgdGhlIGxvY2FsIE1lZGlhU3RyZWFtVHJhY2sncyBwYWNrZXRzXG4gKiAgaGF2ZSBzcGVudCBidWZmZXJlZCBsb2NhbGx5IGJlZm9yZSBiZWluZyBzZW50IG92ZXIgdGhlIG5ldHdvcmtcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdG90YWxFbmNvZGVUaW1lXSAtIFRoZSB0b3RhbCBudW1iZXIgb2Ygc2Vjb25kcyBzcGVudCBvbiBlbmNvZGluZyB0aGUgbG9jYWwgTWVkaWFTdHJlYW1UcmFjaydzIGZyYW1lc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmcmFtZXNFbmNvZGVkXSAtIFRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIG9mIHRoZSBsb2NhbCBNZWRpYVN0cmVhbVRyYWNrIHRoYXQgaGF2ZSBiZWVuIGVuY29kZWQgc29yIGZhclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtlc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wXSAtIFRoZSBlc3RpbWF0ZWQgcGxheW91dCB0aW1lIG9mIHRoZSByZW1vdGUgTWVkaWFTdHJlYW1UcmFja1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0b3RhbERlY29kZVRpbWVdIC0gVGhlIHRvdGFsIG51bWJlciBvZiBzZWNvbmRzIHNwZW50IG9uIGRlY29kaW5nIHRoZSByZW1vdGUgTWVkaWFTdHJlYW1UcmFjaydzIGZyYW1lc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmcmFtZXNEZWNvZGVkXSAtIFRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIG9mIHRoZSByZW1vdGUgTWVkaWFTdHJlYW1UcmFjayB0aGF0IGhhdmUgYmVlbiBkZWNvZGVkIHNvciBmYXJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaml0dGVyQnVmZmVyRGVsYXldIC0gVGhlIHN1bSBvZiB0aGUgdGltZSwgaW4gc2Vjb25kcywgZWFjaCBhdWRpbyBzYW1wbGUgb3IgYSB2aWRlbyBmcmFtZSBvZiB0aGUgcmVtb3RlXG4gKiAgIE1lZGlhU3RyZWFtVHJhY2sgdGFrZXMgZnJvbSB0aGUgdGltZSB0aGUgZmlyc3QgcGFja2V0IGlzIHJlY2VpdmVkIGJ5IHRoZSBqaXR0ZXIgYnVmZmVyIHRvIHRoZSB0aW1lIGl0IGV4aXRzIHRoZSBqaXR0ZXIgYnVmZmVyXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudF0gLSBUaGUgdG90YWwgbnVtYmVyIG9mIGF1ZGlvIHNhbXBsZXMgb3IgdmlkZW8gZnJhbWVzIHRoYXQgaGF2ZSBjb21lIG91dCBvZiB0aGUgaml0dGVyIGJ1ZmZlclxuICogQHByb3BlcnR5IHtBdWRpb0xldmVsfSBbYXVkaW9JbnB1dExldmVsXSAtIFRoZSB7QGxpbmsgQXVkaW9MZXZlbH0gb2YgdGhlIGxvY2FsIGF1ZGlvIE1lZGlhU3RyZWFtVHJhY2tcbiAqIEBwcm9wZXJ0eSB7QXVkaW9MZXZlbH0gW2F1ZGlvT3V0cHV0TGV2ZWxdIC0gVGhlIHtAbGluayBBdWRpb0xldmVsfSBvZiB0aGUgcmVtb3RlIHZpZGVvIE1lZGlhU3RyZWFtVHJhY2tcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBnZXRTdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldHN0YXRzLmpzLm1hcCIsIi8qIGdsb2JhbHMgbmF2aWdhdG9yICovXG4ndXNlIHN0cmljdCc7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdmVyeSBzaW1pbGFyIHRvIDxjb2RlPm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhPC9jb2RlPlxuICogZXhjZXB0IHRoYXQgaWYgbm8gTWVkaWFTdHJlYW1Db25zdHJhaW50cyBhcmUgcHJvdmlkZWQsIHRoZW4gYm90IGF1ZGlvIGFuZCB2aWRlb1xuICogYXJlIHJlcXVlc3RlZC5cbiAqIEBmdW5jdGlvbiBnZXRVc2VyTWVkaWFcbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW1Db25zdHJhaW50c30gW2NvbnN0cmFpbnRzPXthdWRpbzp0cnVlLHZpZGVvOnRydWV9XSAtIHRoZVxuICogICBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzIG9iamVjdCBzcGVjaWZ5aW5nIHdoYXQga2luZCBvZiBNZWRpYVN0cmVhbSB0b1xuICogICByZXF1ZXN0IGZyb20gdGhlIGJyb3dzZXIgKGJ5IGRlZmF1bHQgYm90aCBhdWRpbyBhbmQgdmlkZW8pXG4gKiBAcmV0dXJucyBQcm9taXNlPE1lZGlhU3RyZWFtPlxuICovXG5mdW5jdGlvbiBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCdcbiAgICAgICAgJiYgdHlwZW9mIG5hdmlnYXRvci5tZWRpYURldmljZXMgPT09ICdvYmplY3QnXG4gICAgICAgICYmIHR5cGVvZiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzIHx8IHsgYXVkaW86IHRydWUsIHZpZGVvOiB0cnVlIH07XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2dldFVzZXJNZWRpYSBpcyBub3Qgc3VwcG9ydGVkJykpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBnZXRVc2VyTWVkaWE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXR1c2VybWVkaWEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFdlYlJUQyA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2ViUlRDLCB7XG4gICAgZ2V0U3RhdHM6IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHJlcXVpcmUoJy4vZ2V0c3RhdHMnKVxuICAgIH0sXG4gICAgZ2V0VXNlck1lZGlhOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiByZXF1aXJlKCcuL2dldHVzZXJtZWRpYScpXG4gICAgfSxcbiAgICBNZWRpYVN0cmVhbToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogcmVxdWlyZSgnLi9tZWRpYXN0cmVhbScpXG4gICAgfSxcbiAgICBNZWRpYVN0cmVhbVRyYWNrOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiByZXF1aXJlKCcuL21lZGlhc3RyZWFtdHJhY2snKVxuICAgIH0sXG4gICAgUlRDSWNlQ2FuZGlkYXRlOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiByZXF1aXJlKCcuL3J0Y2ljZWNhbmRpZGF0ZScpXG4gICAgfSxcbiAgICBSVENQZWVyQ29ubmVjdGlvbjoge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogcmVxdWlyZSgnLi9ydGNwZWVyY29ubmVjdGlvbicpXG4gICAgfSxcbiAgICBSVENTZXNzaW9uRGVzY3JpcHRpb246IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHJlcXVpcmUoJy4vcnRjc2Vzc2lvbmRlc2NyaXB0aW9uJylcbiAgICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gV2ViUlRDO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyogZ2xvYmFscyBNZWRpYVN0cmVhbSAqL1xuJ3VzZSBzdHJpY3QnO1xuaWYgKHR5cGVvZiBNZWRpYVN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gTWVkaWFTdHJlYW07XG59XG5lbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIE1lZGlhU3RyZWFtKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lZGlhU3RyZWFtIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWFzdHJlYW0uanMubWFwIiwiLyogZ2xvYmFsIE1lZGlhU3RyZWFtVHJhY2sgKi9cbid1c2Ugc3RyaWN0JztcbmlmICh0eXBlb2YgTWVkaWFTdHJlYW1UcmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gTWVkaWFTdHJlYW1UcmFjaztcbn1cbmVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gTWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZWRpYVN0cmVhbVRyYWNrIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWFzdHJlYW10cmFjay5qcy5tYXAiLCIvKiBnbG9iYWwgUlRDSWNlQ2FuZGlkYXRlICovXG4ndXNlIHN0cmljdCc7XG5pZiAodHlwZW9mIFJUQ0ljZUNhbmRpZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gUlRDSWNlQ2FuZGlkYXRlO1xufVxuZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSVENJY2VDYW5kaWRhdGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUlRDSWNlQ2FuZGlkYXRlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnRjaWNlY2FuZGlkYXRlLmpzLm1hcCIsIi8qIGdsb2JhbHMgUlRDRGF0YUNoYW5uZWwsIFJUQ1BlZXJDb25uZWN0aW9uLCBSVENTZXNzaW9uRGVzY3JpcHRpb24gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBDaHJvbWVSVENTZXNzaW9uRGVzY3JpcHRpb24gPSByZXF1aXJlKCcuLi9ydGNzZXNzaW9uZGVzY3JpcHRpb24vY2hyb21lJyk7XG52YXIgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50dGFyZ2V0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG52YXIgTGF0Y2ggPSByZXF1aXJlKCcuLi91dGlsL2xhdGNoJyk7XG52YXIgTWVkaWFTdHJlYW0gPSByZXF1aXJlKCcuLi9tZWRpYXN0cmVhbScpO1xudmFyIFJUQ1J0cFNlbmRlclNoaW0gPSByZXF1aXJlKCcuLi9ydGNydHBzZW5kZXInKTtcbnZhciBzZHBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWwvc2RwJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBpc0lPU0Nocm9tZSA9IHJlcXVpcmUoJy4uL3V0aWwnKS5pc0lPU0Nocm9tZTtcbnZhciBpc1VuaWZpZWRQbGFuID0gc2RwVXRpbHMuZ2V0U2RwRm9ybWF0KCkgPT09ICd1bmlmaWVkJztcbi8vIE5PVEUobXJvYmVydHMpOiBUaGlzIGNsYXNzIHdyYXBzIENocm9tZSdzIFJUQ1BlZXJDb25uZWN0aW9uIGltcGxlbWVudGF0aW9uLlxuLy8gSXQgcHJvdmlkZXMgc29tZSBmdW5jdGlvbmFsaXR5IG5vdCBjdXJyZW50bHkgcHJlc2VudCBpbiBDaHJvbWUsIG5hbWVseSB0aGVcbi8vIGFiaWxpdGllcyB0b1xuLy9cbi8vICAgMS4gUm9sbGJhY2ssIHBlciB0aGUgd29ya2Fyb3VuZCBzdWdnZXN0ZWQgaGVyZTpcbi8vICAgICAgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTU3MzgjYzNcbi8vXG4vLyAgIDIuIExpc3RlbiBmb3IgdHJhY2sgZXZlbnRzLCBwZXIgdGhlIGFkYXB0ZXIuanMgd29ya2Fyb3VuZC5cbi8vXG4vLyAgIDMuIFNldCBpY2VUcmFuc3BvcnRQb2xpY3kuXG4vL1xuZnVuY3Rpb24gQ2hyb21lUlRDUGVlckNvbm5lY3Rpb24oY29uZmlndXJhdGlvbiwgY29uc3RyYWludHMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2hyb21lUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hyb21lUlRDUGVlckNvbm5lY3Rpb24oY29uZmlndXJhdGlvbiwgY29uc3RyYWludHMpO1xuICAgIH1cbiAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuICAgIGNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uIHx8IHt9O1xuICAgIHZhciBuZXdDb25maWd1cmF0aW9uID0gT2JqZWN0LmFzc2lnbihjb25maWd1cmF0aW9uLmljZVRyYW5zcG9ydFBvbGljeVxuICAgICAgICA/IHsgaWNlVHJhbnNwb3J0czogY29uZmlndXJhdGlvbi5pY2VUcmFuc3BvcnRQb2xpY3kgfVxuICAgICAgICA6IHt9LCBjb25maWd1cmF0aW9uKTtcbiAgICB1dGlsLmludGVyY2VwdEV2ZW50KHRoaXMsICdkYXRhY2hhbm5lbCcpO1xuICAgIHV0aWwuaW50ZXJjZXB0RXZlbnQodGhpcywgJ3NpZ25hbGluZ3N0YXRlY2hhbmdlJyk7XG4gICAgdmFyIHNkcEZvcm1hdCA9IHNkcFV0aWxzLmdldFNkcEZvcm1hdChuZXdDb25maWd1cmF0aW9uLnNkcFNlbWFudGljcyk7XG4gICAgdmFyIHBlZXJDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKG5ld0NvbmZpZ3VyYXRpb24sIGNvbnN0cmFpbnRzKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgIF9hcHBsaWVkVHJhY2tzVG9TU1JDczoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIF9sb2NhbFN0cmVhbToge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBNZWRpYVN0cmVhbSgpXG4gICAgICAgIH0sXG4gICAgICAgIF9wZWVyQ29ubmVjdGlvbjoge1xuICAgICAgICAgICAgdmFsdWU6IHBlZXJDb25uZWN0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIF9wZW5kaW5nTG9jYWxPZmZlcjoge1xuICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBfcGVuZGluZ1JlbW90ZU9mZmVyOiB7XG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIF9yb2xsZWRCYWNrVHJhY2tzVG9TU1JDczoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIF9zZHBGb3JtYXQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzZHBGb3JtYXRcbiAgICAgICAgfSxcbiAgICAgICAgX3NlbmRlcnM6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSxcbiAgICAgICAgX3NpZ25hbGluZ1N0YXRlTGF0Y2g6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTGF0Y2goKVxuICAgICAgICB9LFxuICAgICAgICBfdHJhY2tzVG9TU1JDczoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGxvY2FsRGVzY3JpcHRpb246IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0xvY2FsT2ZmZXIgPyB0aGlzLl9wZW5kaW5nTG9jYWxPZmZlciA6IHBlZXJDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW90ZURlc2NyaXB0aW9uOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdSZW1vdGVPZmZlciA/IHRoaXMuX3BlbmRpbmdSZW1vdGVPZmZlciA6IHBlZXJDb25uZWN0aW9uLnJlbW90ZURlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaWduYWxpbmdTdGF0ZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nTG9jYWxPZmZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hhdmUtbG9jYWwtb2ZmZXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZW5kaW5nUmVtb3RlT2ZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoYXZlLXJlbW90ZS1vZmZlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBwZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdkYXRhY2hhbm5lbCcsIGZ1bmN0aW9uIG9uZGF0YWNoYW5uZWwoZXZlbnQpIHtcbiAgICAgICAgc2hpbURhdGFDaGFubmVsKGV2ZW50LmNoYW5uZWwpO1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0pO1xuICAgIHBlZXJDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3NpZ25hbGluZ3N0YXRlY2hhbmdlJywgZnVuY3Rpb24gb25zaWduYWxpbmdzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykge1xuICAgICAgICAgICAgc2VsZi5fYXBwbGllZFRyYWNrc1RvU1NSQ3MgPSBuZXcgTWFwKHNlbGYuX3RyYWNrc1RvU1NSQ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZi5fcGVuZGluZ0xvY2FsT2ZmZXIgJiYgIXNlbGYuX3BlbmRpbmdSZW1vdGVPZmZlcikge1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50LmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBwZWVyQ29ubmVjdGlvbi5vbnRyYWNrID0gZnVuY3Rpb24gb250cmFjaygpIHtcbiAgICAgICAgLy8gTk9URShtcm9iZXJ0cyk6IGFkYXB0ZXIuanMncyBcInRyYWNrXCIgZXZlbnQgc2hpbSBvbmx5IGtpY2tzIG9mZiBpZiB3ZSBzZXRcbiAgICAgICAgLy8gdGhlIG9udHJhY2sgcHJvcGVydHkgb2YgdGhlIFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGVlckNvbm5lY3Rpb24uYWRkU3RyZWFtKHRoaXMuX2xvY2FsU3RyZWFtKTtcbiAgICB9XG4gICAgdXRpbC5wcm94eVByb3BlcnRpZXMoUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCB0aGlzLCBwZWVyQ29ubmVjdGlvbik7XG59XG5pbmhlcml0cyhDaHJvbWVSVENQZWVyQ29ubmVjdGlvbiwgRXZlbnRUYXJnZXQpO1xuaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBUaGlzIHNoaW0gc3VwcG9ydHMgb3VyIGxpbWl0ZWQgY2FzZSBvZiBhZGRpbmdcbiAgICAvLyBhbGwgTWVkaWFTdHJlYW1UcmFja3MgdG8gb25lIE1lZGlhU3RyZWFtLiBJdCBoYXMgYmVlbiBpbXBsZW1lbnRlZCB0aGlzXG4gICAgLy8ga2VlcGluZyBpbiBtaW5kIHRoYXQgdGhpcyBpcyB0byBiZSBtYWludGFpbmVkIG9ubHkgdW50aWwgXCJhZGRUcmFja1wiIGlzXG4gICAgLy8gc3VwcG9ydGVkIG5hdGl2ZWx5IGluIENocm9tZS5cbiAgICBDaHJvbWVSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjaygpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciB0cmFjayA9IGFyZ3NbMF07XG4gICAgICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBNZWRpYVN0cmVhbVRyYWNrIFsnICsgdHJhY2suaWQgKyAnLCAnXG4gICAgICAgICAgICAgICAgKyB0cmFjay5raW5kICsgJ106IFJUQ1BlZXJDb25uZWN0aW9uIGlzIGNsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZW5kZXIgPSB0aGlzLl9zZW5kZXJzLmdldCh0cmFjayk7XG4gICAgICAgIGlmIChzZW5kZXIgJiYgc2VuZGVyLnRyYWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgTWVkaWFTdHJlYW1UcmFjayBbJyArIHRyYWNrLmlkICsgJywgJ1xuICAgICAgICAgICAgICAgICsgdHJhY2sua2luZCArICddOiBSVENQZWVyQ29ubmVjdGlvbiBhbHJlYWR5IGhhcyBpdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLnJlbW92ZVN0cmVhbSh0aGlzLl9sb2NhbFN0cmVhbSk7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uYWRkU3RyZWFtKHRoaXMuX2xvY2FsU3RyZWFtKTtcbiAgICAgICAgc2VuZGVyID0gbmV3IFJUQ1J0cFNlbmRlclNoaW0odHJhY2spO1xuICAgICAgICB0aGlzLl9zZW5kZXJzLnNldCh0cmFjaywgc2VuZGVyKTtcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICB9O1xuICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFRoaXMgc2hpbSBzdXBwb3J0cyBvdXIgbGltaXRlZCBjYXNlIG9mIHJlbW92aW5nXG4gICAgLy8gTWVkaWFTdHJlYW1UcmFja3MgZnJvbSBvbmUgTWVkaWFTdHJlYW0uIEl0IGhhcyBiZWVuIGltcGxlbWVudGVkIHRoaXNcbiAgICAvLyBrZWVwaW5nIGluIG1pbmQgdGhhdCB0aGlzIGlzIHRvIGJlIG1haW50YWluZWQgb25seSB1bnRpbCBcInJlbW92ZVRyYWNrXCIgaXNcbiAgICAvLyBzdXBwb3J0ZWQgbmF0aXZlbHkgaW4gQ2hyb21lLlxuICAgIENocm9tZVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgICAgICBpZiAodGhpcy5fcGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZW1vdmUgTWVkaWFTdHJlYW1UcmFjazogUlRDUGVlckNvbm5lY3Rpb24gaXMgY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYWNrID0gc2VuZGVyLnRyYWNrO1xuICAgICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VuZGVyID0gdGhpcy5fc2VuZGVycy5nZXQodHJhY2spO1xuICAgICAgICBpZiAoc2VuZGVyICYmIHNlbmRlci50cmFjaykge1xuICAgICAgICAgICAgc2VuZGVyLnRyYWNrID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLnJlbW92ZVN0cmVhbSh0aGlzLl9sb2NhbFN0cmVhbSk7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5hZGRTdHJlYW0odGhpcy5fbG9jYWxTdHJlYW0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaHJvbWVSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3NlbmRlcnMudmFsdWVzKCkpO1xuICAgIH07XG59XG5lbHNlIHtcbiAgICBDaHJvbWVSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVtb3ZlIE1lZGlhU3RyZWFtVHJhY2s6IFJUQ1BlZXJDb25uZWN0aW9uIGlzIGNsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBOT1RFKG1odXluaCk6IERvIG5vdGhpbmcuIEluIENocm9tZSwgd2lsbCB0aHJvdyBpZiBhICdzZW5kZXIgd2FzIG5vdFxuICAgICAgICAgICAgLy8gY3JlYXRlZCBieSB0aGlzIHBlZXIgY29ubmVjdGlvbicuIFRoaXMgYmVoYXZpb3IgZG9lcyBub3Qgc2VlbSB0byBiZVxuICAgICAgICAgICAgLy8gc3BlYyBjb21wbGlhbnQsIHNvIGEgdGVtcG9yYXJ5IHNoaW0gaXMgaW50cm9kdWNlZC4gQSBidWcgaGFzIGJlZW4gZmlsZWQsXG4gICAgICAgICAgICAvLyBhbmQgaXMgdHJhY2tlZCBoZXJlOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODYwODUzXG4gICAgICAgIH1cbiAgICB9O1xufVxuQ2hyb21lUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLXJlbW90ZS1vZmZlcicpIHtcbiAgICAgICAgLy8gTk9URShtcm9iZXJ0cyk6IEJlY2F1c2UgdGhlIENocm9tZVJUQ1BlZXJDb25uZWN0aW9uIHNpbXVsYXRlcyB0aGVcbiAgICAgICAgLy8gXCJoYXZlLXJlbW90ZS1vZmZlclwiIHNpZ25hbGluZ1N0YXRlcywgd2Ugb25seSB3YW50IHRvIGludm9rZSB0aGUgdHJ1ZVxuICAgICAgICAvLyBhZGRJY2VDYW5kaWRhdGVzIG1ldGhvZCB3aGVuIHRoZSByZW1vdGUgZGVzY3JpcHRpb24gaGFzIGJlZW4gYXBwbGllZC5cbiAgICAgICAgcHJvbWlzZSA9IHRoaXMuX3NpZ25hbGluZ1N0YXRlTGF0Y2gud2hlbignbG93JykudGhlbihmdW5jdGlvbiBzaWduYWxpbmdTdGF0ZXNSZXNvbHZlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9wZWVyQ29ubmVjdGlvbi5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcm9taXNlID0gdGhpcy5fcGVlckNvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcmdzLmxlbmd0aCA+IDFcbiAgICAgICAgPyB1dGlsLmxlZ2FjeVByb21pc2UocHJvbWlzZSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgOiBwcm9taXNlO1xufTtcbi8vIE5PVEUobXJvYmVydHMpOiBUaGUgV2ViUlRDIHNwZWMgZG9lcyBub3Qgc3BlY2lmeSB0aGF0IGNsb3NlIHNob3VsZCB0aHJvdyBhblxuLy8gRXJyb3I7IGhvd2V2ZXIsIGluIENocm9tZSBpdCBkb2VzLiBXZSB3b3JrYXJvdW5kIHRoaXMgYnkgY2hlY2tpbmcgdGhlXG4vLyBzaWduYWxpbmdTdGF0ZSBtYW51YWxseS5cbkNocm9tZVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLnNpZ25hbGluZ1N0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgICB0aGlzLl9wZW5kaW5nTG9jYWxPZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZW1vdGVPZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfVxufTtcbi8vIE5PVEUobXJvYmVydHMpOiBCZWNhdXNlIHdlIHdvcmthcm91bmQgQ2hyb21lJ3MgbGFjayBvZiByb2xsYmFjayBzdXBwb3J0IGJ5XG4vLyBcImZha2luZ1wiIHNldFJlbW90ZURlc2NyaXB0aW9uLCB3ZSBjYW5ub3QgY3JlYXRlIGFuIGFuc3dlciB1bnRpbCB3ZSBhY3R1YWxseVxuLy8gYXBwbHkgdGhlIHJlbW90ZSBkZXNjcmlwdGlvbi4gVGhpcyBtZWFucywgb25jZSB5b3UgY2FsbCBjcmVhdGVBbnN3ZXIsIHlvdVxuLy8gY2FuIG5vIGxvbmdlciByb2xsYmFjay4gVGhpcyBpcyBhY2NlcHRhYmxlIGZvciBvdXIgdXNlIGNhc2UgYmVjYXVzZSB3ZSB3aWxsXG4vLyBhcHBseSB0aGUgbmV3bHktY3JlYXRlZCBhbnN3ZXIgYWxtb3N0IGltbWVkaWF0ZWx5OyBob3dldmVyLCB0aGlzIG1heSBiZVxuLy8gdW5hY2NlcHRhYmxlIGZvciBvdGhlciB1c2UgY2FzZXMuXG5DaHJvbWVSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gY3JlYXRlQW5zd2VyKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBwcm9taXNlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5fcGVuZGluZ1JlbW90ZU9mZmVyKSB7XG4gICAgICAgIHByb21pc2UgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbih0aGlzLl9wZW5kaW5nUmVtb3RlT2ZmZXIpLnRoZW4oZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb25TdWNjZWVkZWQoKSB7XG4gICAgICAgICAgICAvLyBOT1RFKG1yb2JlcnRzKTogVGhlIHNpZ25hbGluZ1N0YXRlcyBiZXR3ZWVuIHRoZSBDaHJvbWVSVENQZWVyQ29ubmVjdGlvblxuICAgICAgICAgICAgLy8gYW5kIHRoZSB1bmRlcmx5aW5nIFJUQ1BlZXJDb25uZWN0aW9uIGltcGxlbWVudGF0aW9uIGhhdmUgY29udmVyZ2VkLiBXZVxuICAgICAgICAgICAgLy8gY2FuIHVuYmxvY2sgYW55IHBlbmRpbmcgY2FsbHMgdG8gYWRkSWNlQ2FuZGlkYXRlIG5vdy5cbiAgICAgICAgICAgIHNlbGYuX3NpZ25hbGluZ1N0YXRlTGF0Y2gubG93ZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiBjcmVhdGVBbnN3ZXJTdWNjZWVkZWQoYW5zd2VyKSB7XG4gICAgICAgICAgICBzZWxmLl9wZW5kaW5nUmVtb3RlT2ZmZXIgPSBudWxsO1xuICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogSWYgY3JlYXRlQW5zd2VyKCkgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHJvbGxpbmcgYmFjaywgdGhlbiB3ZSBub1xuICAgICAgICAgICAgLy8gbG9uZ2VyIG5lZWQgdG8gcmV0YWluIHRoZSByb2xsZWQgYmFjayB0cmFja3MgdG8gU1NSQ3MgTWFwLlxuICAgICAgICAgICAgc2VsZi5fcm9sbGVkQmFja1RyYWNrc1RvU1NSQ3MuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hyb21lUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYW5zd2VyJyxcbiAgICAgICAgICAgICAgICBzZHA6IHVwZGF0ZVRyYWNrSWRzVG9TU1JDcyhzZWxmLl9zZHBGb3JtYXQsIHNlbGYuX3RyYWNrc1RvU1NSQ3MsIGFuc3dlci5zZHApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb25PckNyZWF0ZUFuc3dlckZhaWxlZChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5fcGVuZGluZ1JlbW90ZU9mZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByb21pc2UgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKS50aGVuKGZ1bmN0aW9uIChhbnN3ZXIpIHtcbiAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IElmIGNyZWF0ZUFuc3dlcigpIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciByb2xsaW5nIGJhY2ssIHRoZW4gd2Ugbm9cbiAgICAgICAgICAgIC8vIGxvbmdlciBuZWVkIHRvIHJldGFpbiB0aGUgcm9sbGVkIGJhY2sgdHJhY2tzIHRvIFNTUkNzIE1hcC5cbiAgICAgICAgICAgIHNlbGYuX3JvbGxlZEJhY2tUcmFja3NUb1NTUkNzLmNsZWFyKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENocm9tZVJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Fuc3dlcicsXG4gICAgICAgICAgICAgICAgc2RwOiB1cGRhdGVUcmFja0lkc1RvU1NSQ3Moc2VsZi5fc2RwRm9ybWF0LCBzZWxmLl90cmFja3NUb1NTUkNzLCBhbnN3ZXIuc2RwKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJncy5sZW5ndGggPiAxXG4gICAgICAgID8gdXRpbC5sZWdhY3lQcm9taXNlKHByb21pc2UsIGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgIDogcHJvbWlzZTtcbn07XG5DaHJvbWVSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcigpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgb3B0aW9ucyA9IChhcmdzLmxlbmd0aCA+IDEgPyBhcmdzWzJdIDogYXJnc1swXSkgfHwge307XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChpc0lPU0Nocm9tZSgpKSB7XG4gICAgICAgIC8vIE5PVEUgKGpvbWEpOiBGcm9tIFNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uIGluIG9yZGVyIHRvIHN1cHBvcnQgaU9TIENocm9tZS5cbiAgICAgICAgaWYgKG9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyAmJiAhdGhpcy5fYXVkaW9UcmFuc2NlaXZlciAmJiAhKGlzVW5pZmllZFBsYW4gJiYgaGFzUmVjZWl2ZXJzRm9yVHJhY2tzT2ZLaW5kKHRoaXMsICdhdWRpbycpKSkge1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9UcmFuc2NlaXZlciA9IGlzVW5pZmllZFBsYW5cbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycsIHsgZGlyZWN0aW9uOiAncmVjdm9ubHknIH0pXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5hZGRUcmFuc2NlaXZlcignYXVkaW8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gJiYgIXRoaXMuX3ZpZGVvVHJhbnNjZWl2ZXIgJiYgIShpc1VuaWZpZWRQbGFuICYmIGhhc1JlY2VpdmVyc0ZvclRyYWNrc09mS2luZCh0aGlzLCAndmlkZW8nKSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW87XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZGVvVHJhbnNjZWl2ZXIgPSBpc1VuaWZpZWRQbGFuXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5hZGRUcmFuc2NlaXZlcigndmlkZW8nLCB7IGRpcmVjdGlvbjogJ3JlY3Zvbmx5JyB9KVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3BlZXJDb25uZWN0aW9uLmNyZWF0ZU9mZmVyKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKG9mZmVyKSB7XG4gICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IElmIGNyZWF0ZU9mZmVyKCkgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHJvbGxpbmcgYmFjaywgdGhlbiB3ZSBub1xuICAgICAgICAvLyBsb25nZXIgbmVlZCB0byByZXRhaW4gdGhlIHJvbGxlZCBiYWNrIHRyYWNrcyB0byBTU1JDcyBNYXAuXG4gICAgICAgIHNlbGYuX3JvbGxlZEJhY2tUcmFja3NUb1NTUkNzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ2hyb21lUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6IG9mZmVyLnR5cGUsXG4gICAgICAgICAgICBzZHA6IHVwZGF0ZVRyYWNrSWRzVG9TU1JDcyhzZWxmLl9zZHBGb3JtYXQsIHNlbGYuX3RyYWNrc1RvU1NSQ3MsIG9mZmVyLnNkcClcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFyZ3MubGVuZ3RoID4gMVxuICAgICAgICA/IHV0aWwubGVnYWN5UHJvbWlzZShwcm9taXNlLCBhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICA6IHByb21pc2U7XG59O1xuQ2hyb21lUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsID0gZnVuY3Rpb24gY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCkge1xuICAgIGRhdGFDaGFubmVsRGljdCA9IHNoaW1EYXRhQ2hhbm5lbEluaXQoZGF0YUNoYW5uZWxEaWN0KTtcbiAgICB2YXIgZGF0YUNoYW5uZWwgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KTtcbiAgICBzaGltRGF0YUNoYW5uZWwoZGF0YUNoYW5uZWwpO1xuICAgIHJldHVybiBkYXRhQ2hhbm5lbDtcbn07XG5DaHJvbWVSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gYXJnc1swXTtcbiAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBJZiBzZXRMb2NhbERlc2NyaXB0aW9uKCkgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHJvbGxpbmcgYmFjayxcbiAgICAvLyB0aGVuIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgcm9sbGVkIGJhY2sgdHJhY2tzIHRvIFNTUkNzIE1hcC5cbiAgICBpZiAodGhpcy5fcm9sbGVkQmFja1RyYWNrc1RvU1NSQ3Muc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5fdHJhY2tzVG9TU1JDcyA9IG5ldyBNYXAodGhpcy5fcm9sbGVkQmFja1RyYWNrc1RvU1NSQ3MpO1xuICAgICAgICB0aGlzLl9yb2xsZWRCYWNrVHJhY2tzVG9TU1JDcy5jbGVhcigpO1xuICAgIH1cbiAgICB2YXIgcHJvbWlzZSA9IHNldERlc2NyaXB0aW9uKHRoaXMsIHRydWUsIGRlc2NyaXB0aW9uKTtcbiAgICByZXR1cm4gYXJncy5sZW5ndGggPiAxXG4gICAgICAgID8gdXRpbC5sZWdhY3lQcm9taXNlKHByb21pc2UsIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgIDogcHJvbWlzZTtcbn07XG5DaHJvbWVSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBhcmdzWzBdO1xuICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IElmIHNldFJlbW90ZURlc2NyaXB0aW9uKCkgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHJvbGxpbmcgYmFjayxcbiAgICAvLyB0aGVuIHdlIG5vIGxvbmdlciBuZWVkIHRvIHJldGFpbiB0aGUgcm9sbGVkIGJhY2sgdHJhY2tzIHRvIFNTUkNzIE1hcC5cbiAgICB0aGlzLl9yb2xsZWRCYWNrVHJhY2tzVG9TU1JDcy5jbGVhcigpO1xuICAgIHZhciBwcm9taXNlID0gc2V0RGVzY3JpcHRpb24odGhpcywgZmFsc2UsIGRlc2NyaXB0aW9uKTtcbiAgICByZXR1cm4gYXJncy5sZW5ndGggPiAxXG4gICAgICAgID8gdXRpbC5sZWdhY3lQcm9taXNlKHByb21pc2UsIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgIDogcHJvbWlzZTtcbn07XG51dGlsLmRlbGVnYXRlTWV0aG9kcyhSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsIENocm9tZVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ19wZWVyQ29ubmVjdGlvbicpO1xuLy8gTk9URShtcm9iZXJ0cyk6IFdlIHdvcmthcm91bmQgQ2hyb21lJ3MgbGFjayBvZiByb2xsYmFjayBzdXBwb3J0LCBwZXIgdGhlXG4vLyB3b3JrYXJvdW5kIHN1Z2dlc3RlZCBoZXJlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NTczOCNjM1xuLy8gTmFtZWx5LCB3ZSBcImZha2VcIiBzZXR0aW5nIHRoZSBsb2NhbCBvciByZW1vdGUgZGVzY3JpcHRpb24gYW5kIGluc3RlYWQgYnVmZmVyXG4vLyBpdC4gSWYgd2UgcmVjZWl2ZSBvciBjcmVhdGUgYW4gYW5zd2VyLCB0aGVuIHdlIHdpbGwgYWN0dWFsbHkgYXBwbHkgdGhlXG4vLyBkZXNjcmlwdGlvbi4gVW50aWwgd2UgcmVjZWl2ZSBvciBjcmVhdGUgYW4gYW5zd2VyLCB3ZSB3aWxsIGJlIGFibGUgdG9cbi8vIFwicm9sbGJhY2tcIiBieSBzaW1wbHkgZGlzY2FyZGluZyB0aGUgYnVmZmVyIGRlc2NyaXB0aW9uLlxuZnVuY3Rpb24gc2V0RGVzY3JpcHRpb24ocGVlckNvbm5lY3Rpb24sIGxvY2FsLCBkZXNjcmlwdGlvbikge1xuICAgIGZ1bmN0aW9uIHNldFBlbmRpbmdMb2NhbE9mZmVyKG9mZmVyKSB7XG4gICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24uX3BlbmRpbmdMb2NhbE9mZmVyID0gb2ZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ1JlbW90ZU9mZmVyID0gb2ZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJQZW5kaW5nTG9jYWxPZmZlcigpIHtcbiAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24uX3BlbmRpbmdSZW1vdGVPZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBlbmRpbmdMb2NhbE9mZmVyID0gbG9jYWwgPyBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXIgOiBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ1JlbW90ZU9mZmVyO1xuICAgIHZhciBwZW5kaW5nUmVtb3RlT2ZmZXIgPSBsb2NhbCA/IHBlZXJDb25uZWN0aW9uLl9wZW5kaW5nUmVtb3RlT2ZmZXIgOiBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXI7XG4gICAgdmFyIGludGVybWVkaWF0ZVN0YXRlID0gbG9jYWwgPyAnaGF2ZS1sb2NhbC1vZmZlcicgOiAnaGF2ZS1yZW1vdGUtb2ZmZXInO1xuICAgIHZhciBzZXRMb2NhbERlc2NyaXB0aW9uID0gbG9jYWwgPyAnc2V0TG9jYWxEZXNjcmlwdGlvbicgOiAnc2V0UmVtb3RlRGVzY3JpcHRpb24nO1xuICAgIHZhciBwcm9taXNlO1xuICAgIGlmICghbG9jYWwgJiYgcGVuZGluZ1JlbW90ZU9mZmVyICYmIGRlc2NyaXB0aW9uLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgIHByb21pc2UgPSBzZXRSZW1vdGVBbnN3ZXIocGVlckNvbm5lY3Rpb24sIGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09IGludGVybWVkaWF0ZVN0YXRlICYmIHBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJykge1xuICAgICAgICAgICAgLy8gTk9URShtcm9iZXJ0cyk6IEVycm9yIG1lc3NhZ2UgY29waWVkIGZyb20gRmlyZWZveC5cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgJyArIChsb2NhbCA/ICdsb2NhbCcgOiAncmVtb3RlJykgK1xuICAgICAgICAgICAgICAgICcgb2ZmZXIgaW4gc3RhdGUgJyArIHBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbmVlZCB0byBzYXZlIHRoaXMgbG9jYWwgb2ZmZXIgaW4gY2FzZSBvZiBhIHJvbGxiYWNrLiBXZSBhbHNvIG5lZWQgdG9cbiAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBzaWduYWxpbmdTdGF0ZSBiZXR3ZWVuIHRoZSBDaHJvbWVSVENQZWVyQ29ubmVjdGlvblxuICAgICAgICAvLyBhbmQgdGhlIHVuZGVybHlpbmcgUlRDUGVlckNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb24gYXJlIGFib3V0IHRvIGRpdmVyZ2UuXG4gICAgICAgIC8vIElmIHNvLCB3ZSBuZWVkIHRvIGVuc3VyZSBzdWJzZXF1ZW50IGNhbGxzIHRvIGFkZEljZUNhbmRpZGF0ZSB3aWxsIGJsb2NrLlxuICAgICAgICBpZiAoIXBlbmRpbmdMb2NhbE9mZmVyICYmIHBlZXJDb25uZWN0aW9uLl9zaWduYWxpbmdTdGF0ZUxhdGNoLnN0YXRlID09PSAnbG93Jykge1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24uX3NpZ25hbGluZ1N0YXRlTGF0Y2gucmFpc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXNTaWduYWxpbmdTdGF0ZSA9IHBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlO1xuICAgICAgICBzZXRQZW5kaW5nTG9jYWxPZmZlcih1bndyYXAoZGVzY3JpcHRpb24pKTtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAvLyBPbmx5IGRpc3BhdGNoIGEgc2lnbmFsaW5nc3RhdGVjaGFuZ2UgZXZlbnQgaWYgd2UgdHJhbnNpdGlvbmVkLlxuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09IHByZXZpb3VzU2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiBkaXNwYXRjaFNpZ25hbGluZ1N0YXRlQ2hhbmdlRXZlbnQoKSB7XG4gICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3NpZ25hbGluZ3N0YXRlY2hhbmdlJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ3JvbGxiYWNrJykge1xuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09IGludGVybWVkaWF0ZVN0YXRlKSB7XG4gICAgICAgICAgICAvLyBOT1RFKG1yb2JlcnRzKTogRXJyb3IgbWVzc2FnZSBjb3BpZWQgZnJvbSBGaXJlZm94LlxuICAgICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQ2Fubm90IHJvbGxiYWNrICcgK1xuICAgICAgICAgICAgICAgIChsb2NhbCA/ICdsb2NhbCcgOiAncmVtb3RlJykgKyAnIGRlc2NyaXB0aW9uIGluICcgKyBwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHBlbmRpbmcgb2ZmZXIuXG4gICAgICAgICAgICBjbGVhclBlbmRpbmdMb2NhbE9mZmVyKCk7XG4gICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBXZSBzdG9yZSB0aGUgcm9sbGVkIGJhY2sgdHJhY2tzIHRvIFNTUkNzIE1hcCBoZXJlIGluIGNhc2VcbiAgICAgICAgICAgIC8vIHNldExvY2FsRGVzY3JpcHRpb24oKSBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYSByb2xsYmFjayAod2l0aG91dCBjYWxsaW5nXG4gICAgICAgICAgICAvLyBjcmVhdGVPZmZlcigpIG9yIGNyZWF0ZUFuc3dlcigpKSwgaW4gd2hpY2ggY2FzZSB0aGlzIHJvbGwgYmFjayBpcyBub3QgZHVlIHRvIGFcbiAgICAgICAgICAgIC8vIGdsYXJlIHNjZW5hcmlvIGFuZCB0aGlzIE1hcCBzaG91bGQgYmUgcmVzdG9yZWQuXG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5fcm9sbGVkQmFja1RyYWNrc1RvU1NSQ3MgPSBuZXcgTWFwKHBlZXJDb25uZWN0aW9uLl90cmFja3NUb1NTUkNzKTtcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLl90cmFja3NUb1NTUkNzID0gbmV3IE1hcChwZWVyQ29ubmVjdGlvbi5fYXBwbGllZFRyYWNrc1RvU1NSQ3MpO1xuICAgICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIGRpc3BhdGNoU2lnbmFsaW5nU3RhdGVDaGFuZ2VFdmVudCgpIHtcbiAgICAgICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc2lnbmFsaW5nc3RhdGVjaGFuZ2UnKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZSB8fCBwZWVyQ29ubmVjdGlvbi5fcGVlckNvbm5lY3Rpb25bc2V0TG9jYWxEZXNjcmlwdGlvbl0odW53cmFwKGRlc2NyaXB0aW9uKSk7XG59XG5mdW5jdGlvbiBzZXRSZW1vdGVBbnN3ZXIocGVlckNvbm5lY3Rpb24sIGFuc3dlcikge1xuICAgIC8vIEFwcGx5IHRoZSBwZW5kaW5nIGxvY2FsIG9mZmVyLlxuICAgIHZhciBwZW5kaW5nTG9jYWxPZmZlciA9IHBlZXJDb25uZWN0aW9uLl9wZW5kaW5nTG9jYWxPZmZlcjtcbiAgICByZXR1cm4gcGVlckNvbm5lY3Rpb24uX3BlZXJDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24ocGVuZGluZ0xvY2FsT2ZmZXIpLnRoZW4oZnVuY3Rpb24gc2V0TG9jYWxPZmZlclN1Y2NlZWRlZCgpIHtcbiAgICAgICAgcGVlckNvbm5lY3Rpb24uX3BlbmRpbmdMb2NhbE9mZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHBlZXJDb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfSkudGhlbihmdW5jdGlvbiBzZXRSZW1vdGVBbnN3ZXJTdWNjZWVkZWQoKSB7XG4gICAgICAgIC8vIE5PVEUobXJvYmVydHMpOiBUaGUgc2lnbmFsaW5nU3RhdGVzIGJldHdlZW4gdGhlIENocm9tZVJUQ1BlZXJDb25uZWN0aW9uXG4gICAgICAgIC8vIGFuZCB0aGUgdW5kZXJseWluZyBSVENQZWVyQ29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbiBoYXZlIGNvbnZlcmdlZC4gV2VcbiAgICAgICAgLy8gY2FuIHVuYmxvY2sgYW55IHBlbmRpbmcgY2FsbHMgdG8gYWRkSWNlQ2FuZGlkYXRlIG5vdy5cbiAgICAgICAgcGVlckNvbm5lY3Rpb24uX3NpZ25hbGluZ1N0YXRlTGF0Y2gubG93ZXIoKTtcbiAgICB9KTtcbn1cbi8qKlxuICogV2hldGhlciBhIENocm9tZVJUQ1BlZXJDb25uZWN0aW9uIGhhcyBhbnkgUlRDUnRwUmVjZWl2ZXJzKHMpIGZvciB0aGUgZ2l2ZW5cbiAqIE1lZGlhU3RyZWFtVHJhY2sga2luZC5cbiAqIEBwYXJhbSB7Q2hyb21lUlRDUGVlckNvbm5lY3Rpb259IHBlZXJDb25uZWN0aW9uXG4gKiBAcGFyYW0geydhdWRpbycgfCAndmlkZW8nfSBraW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzUmVjZWl2ZXJzRm9yVHJhY2tzT2ZLaW5kKHBlZXJDb25uZWN0aW9uLCBraW5kKSB7XG4gICAgcmV0dXJuICEhcGVlckNvbm5lY3Rpb24uZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZChmdW5jdGlvbiAodHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJlY2VpdmVyICYmIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrICYmIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09IGtpbmQ7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB1bndyYXAoZGVzY3JpcHRpb24pIHtcbiAgICBpZiAoZGVzY3JpcHRpb24gaW5zdGFuY2VvZiBDaHJvbWVSVENTZXNzaW9uRGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uLl9kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uLl9kZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihkZXNjcmlwdGlvbik7XG59XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgb3Igbm90IHdlIG5lZWQgdG8gYXBwbHkgb3VyIG1heFBhY2tldExpZmVUaW1lIHNoaW0uIFdlIGFyZVxuICogcHJldHR5IGNvbnNlcnZhdGl2ZTogd2UnbGwgb25seSBhcHBseSBpdCBpZiB0aGUgbGVnYWN5IG1heFJldHJhbnNtaXRUaW1lXG4gKiBwcm9wZXJ0eSBpcyBhdmFpbGFibGUgX2FuZF8gdGhlIHN0YW5kYXJkIG1heFBhY2tldExpZmVUaW1lIHByb3BlcnR5IGlzIF9ub3RfXG4gKiBhdmFpbGFibGUgKHRoZSB0aGlua2luZyBiZWluZyB0aGF0IENocm9tZSB3aWxsIGxhbmQgdGhlIHN0YW5kYXJkcy1jb21wbGlhbnRcbiAqIHByb3BlcnR5KS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBuZWVkc01heFBhY2tldExpZmVUaW1lU2hpbSgpIHtcbiAgICByZXR1cm4gJ21heFJldHJhbnNtaXRUaW1lJyBpbiBSVENEYXRhQ2hhbm5lbC5wcm90b3R5cGVcbiAgICAgICAgJiYgISgnbWF4UGFja2V0TGlmZVRpbWUnIGluIFJUQ0RhdGFDaGFubmVsLnByb3RvdHlwZSk7XG59XG4vKipcbiAqIFNoaW0gYW4gUlRDRGF0YUNoYW5uZWxJbml0IGRpY3Rpb25hcnkgKGlmIG5lY2Vzc2FyeSkuIFRoaXMgZnVuY3Rpb24gcmV0dXJuc1xuICogYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBSVENEYXRhQ2hhbm5lbEluaXQuXG4gKiBAcGFyYW0ge1JUQ0RhdGFDaGFubmVsSW5pdH0gZGF0YUNoYW5uZWxEaWN0XG4gKiBAcmV0dXJucyB7UlRDRGF0YUNoYW5uZWxJbml0fVxuICovXG5mdW5jdGlvbiBzaGltRGF0YUNoYW5uZWxJbml0KGRhdGFDaGFubmVsRGljdCkge1xuICAgIGRhdGFDaGFubmVsRGljdCA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGFDaGFubmVsRGljdCk7XG4gICAgaWYgKG5lZWRzTWF4UGFja2V0TGlmZVRpbWVTaGltKCkgJiYgJ21heFBhY2tldExpZmVUaW1lJyBpbiBkYXRhQ2hhbm5lbERpY3QpIHtcbiAgICAgICAgZGF0YUNoYW5uZWxEaWN0Lm1heFJldHJhbnNtaXRUaW1lID0gZGF0YUNoYW5uZWxEaWN0Lm1heFBhY2tldExpZmVUaW1lO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YUNoYW5uZWxEaWN0O1xufVxuLyoqXG4gKiBTaGltIGFuIFJUQ0RhdGFDaGFubmVsIChpZiBuZWNlc3NhcnkpLiBUaGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlXG4gKiBSVENEYXRhQ2hhbm5lbC5cbiAqIEBwYXJhbSB7UlRDRGF0YUNoYW5uZWx9IGRhdGFDaGFubmVsXG4gKiBAcmV0dXJucyB7UlRDRGF0YUNoYW5uZWx9XG4gKi9cbmZ1bmN0aW9uIHNoaW1EYXRhQ2hhbm5lbChkYXRhQ2hhbm5lbCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhQ2hhbm5lbCwgJ21heFJldHJhbnNtaXRzJywge1xuICAgICAgICB2YWx1ZTogZGF0YUNoYW5uZWwubWF4UmV0cmFuc21pdHMgPT09IDY1NTM1XG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogZGF0YUNoYW5uZWwubWF4UmV0cmFuc21pdHNcbiAgICB9KTtcbiAgICBpZiAobmVlZHNNYXhQYWNrZXRMaWZlVGltZVNoaW0oKSkge1xuICAgICAgICAvLyBOT1RFKG1yb2JlcnRzKTogV2UgY2FuIHJlbmFtZSBgbWF4UmV0cmFuc21pdFRpbWVgIHRvIGBtYXhQYWNrZXRMaWZlVGltZWAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Njk2NjgxXG4gICAgICAgIC8vXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhQ2hhbm5lbCwgJ21heFBhY2tldExpZmVUaW1lJywge1xuICAgICAgICAgICAgdmFsdWU6IGRhdGFDaGFubmVsLm1heFJldHJhbnNtaXRUaW1lID09PSA2NTUzNVxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogZGF0YUNoYW5uZWwubWF4UmV0cmFuc21pdFRpbWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhQ2hhbm5lbDtcbn1cbi8qKlxuICogVXBkYXRlIHRoZSBtYXBwaW5ncyBmcm9tIE1lZGlhU3RyZWFtVHJhY2sgSURzIHRvIFNTUkNzIGFzIGluZGljYXRlZCBieSBib3RoXG4gKiB0aGUgTWFwIGZyb20gTWVkaWFTdHJlYW1UcmFjayBJRHMgdG8gU1NSQ3MgYW5kIHRoZSBTRFAgaXRzZWxmLiBUaGlzIG1ldGhvZFxuICogZW5zdXJlcyB0aGF0IFNTUkNzIG5ldmVyIGNoYW5nZSBvbmNlIGFubm91bmNlZC5cbiAqIEBwYXJhbSB7J3BsYW5iJ3wndW5pZmllZCd9IHNkcEZvcm1hdFxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj59IHRyYWNrc1RvU1NSQ3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHAgLSBhbiBTRFAgd2hvc2UgZm9ybWF0IGlzIGRldGVybWluZWQgYnkgYHNkcFNlbWFudGljc2BcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHVwZGF0ZWRTZHAgLSB1cGRhdGVkIFNEUFxuICovXG5mdW5jdGlvbiB1cGRhdGVUcmFja0lkc1RvU1NSQ3Moc2RwRm9ybWF0LCB0cmFja3NUb1NTUkNzLCBzZHApIHtcbiAgICByZXR1cm4gc2RwRm9ybWF0ID09PSAndW5pZmllZCdcbiAgICAgICAgPyBzZHBVdGlscy51cGRhdGVVbmlmaWVkUGxhblRyYWNrSWRzVG9TU1JDcyh0cmFja3NUb1NTUkNzLCBzZHApXG4gICAgICAgIDogc2RwVXRpbHMudXBkYXRlUGxhbkJUcmFja0lkc1RvU1NSQ3ModHJhY2tzVG9TU1JDcywgc2RwKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gQ2hyb21lUlRDUGVlckNvbm5lY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHJvbWUuanMubWFwIiwiLyogZ2xvYmFscyBSVENQZWVyQ29ubmVjdGlvbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudHRhcmdldCcpO1xudmFyIEZpcmVmb3hSVENTZXNzaW9uRGVzY3JpcHRpb24gPSByZXF1aXJlKCcuLi9ydGNzZXNzaW9uZGVzY3JpcHRpb24vZmlyZWZveCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIHVwZGF0ZVRyYWNrc1RvU1NSQ3MgPSByZXF1aXJlKCcuLi91dGlsL3NkcCcpLnVwZGF0ZVVuaWZpZWRQbGFuVHJhY2tJZHNUb1NTUkNzO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG4vLyBOT1RFKG1yb2JlcnRzKTogVGhpcyBpcyBhIHNob3J0LWxpdmVkIHdvcmthcm91bmQuIENoZWNraW5nIHRoZSB1c2VyIGFnZW50XG4vLyBzdHJpbmcgbWlnaHQgbm90IGZpeCBldmVyeSBhZmZlY3RlZCBGaXJlZm94IGluc3RhbmNlLCBidXQgaXQgc2hvdWxkIGJlIGdvb2Rcbi8vIGVub3VnaCBmb3IgdGhpcyBidWcuXG52YXIgbmVlZHNXb3JrYXJvdW5kRm9yQnVnMTQ4MDI3NyA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnXG4gICAgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudFxuICAgICYmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvNjEvKSB8fCBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvNjIvKSk7XG4vLyBOT1RFKG1yb2JlcnRzKTogVGhpcyBjbGFzcyB3cmFwcyBGaXJlZm94J3MgUlRDUGVlckNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb24uXG4vLyBJdCBwcm92aWRlcyBzb21lIGZ1bmN0aW9uYWxpdHkgbm90IGN1cnJlbnRseSBwcmVzZW50IGluIEZpcmVmb3gsIG5hbWVseSB0aGVcbi8vIGFiaWxpdGllcyB0b1xuLy9cbi8vICAgMS4gQ2FsbCBzZXRMb2NhbERlc2NyaXB0aW9uIGFuZCBzZXRSZW1vdGVEZXNjcmlwdGlvbiB3aXRoIG5ldyBvZmZlcnMgaW5cbi8vICAgICAgc2lnbmFsaW5nU3RhdGVzIFwiaGF2ZS1sb2NhbC1vZmZlclwiIGFuZCBcImhhdmUtcmVtb3RlLW9mZmVyXCIsXG4vLyAgICAgIHJlc3BlY3RpdmVseS5cbi8vXG4vLyAgIDIuIFRoZSBhYmlsaXR5IHRvIGNhbGwgY3JlYXRlT2ZmZXIgaW4gc2lnbmFsaW5nU3RhdGUgXCJoYXZlLWxvY2FsLW9mZmVyXCIuXG4vL1xuLy8gQm90aCBvZiB0aGVzZSBhcmUgaW1wbGVtZW50ZWQgdXNpbmcgcm9sbGJhY2tzIHRvIHdvcmthcm91bmQgdGhlIGZvbGxvd2luZ1xuLy8gYnVnOlxuLy9cbi8vICAgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA3MjM4OFxuLy9cbi8vIFdlIGFsc28gcHJvdmlkZSBhIHdvcmthcm91bmQgZm9yIGEgYnVnIHdoZXJlIEZpcmVmb3ggbWF5IGNoYW5nZSB0aGVcbi8vIHByZXZpb3VzbHktbmVnb3RpYXRlZCBEVExTIHJvbGUgaW4gYW4gYW5zd2VyLCB3aGljaCBicmVha3MgQ2hyb21lOlxuLy9cbi8vICAgICBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjQwODk3XG4vL1xuZnVuY3Rpb24gRmlyZWZveFJUQ1BlZXJDb25uZWN0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRmlyZWZveFJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gbmV3IEZpcmVmb3hSVENQZWVyQ29ubmVjdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcbiAgICB1dGlsLmludGVyY2VwdEV2ZW50KHRoaXMsICdzaWduYWxpbmdzdGF0ZWNoYW5nZScpO1xuICAgIC8qIGVzbGludCBuZXctY2FwOjAgKi9cbiAgICB2YXIgcGVlckNvbm5lY3Rpb24gPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oY29uZmlndXJhdGlvbik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICBfaW5pdGlhbGx5TmVnb3RpYXRlZER0bHNSb2xlOiB7XG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIF9pc0Nsb3NlZDoge1xuICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgX3BlZXJDb25uZWN0aW9uOiB7XG4gICAgICAgICAgICB2YWx1ZTogcGVlckNvbm5lY3Rpb25cbiAgICAgICAgfSxcbiAgICAgICAgX3JvbGxpbmdCYWNrOiB7XG4gICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBfdHJhY2tzVG9TU1JDczoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9LFxuICAgICAgICBpY2VHYXRoZXJpbmdTdGF0ZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0Nsb3NlZCA/ICdjb21wbGV0ZScgOiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5pY2VHYXRoZXJpbmdTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9jYWxEZXNjcmlwdGlvbjoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdmVyd3JpdGVXaXRoSW5pdGlhbGx5TmVnb3RpYXRlZER0bHNSb2xlKHRoaXMuX3BlZXJDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb24sIHRoaXMuX2luaXRpYWxseU5lZ290aWF0ZWREdGxzUm9sZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25hbGluZ1N0YXRlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2xvc2VkID8gJ2Nsb3NlZCcgOiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJldmlvdXNTaWduYWxpbmdTdGF0ZTtcbiAgICBwZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdzaWduYWxpbmdzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uIG9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgIGlmICghc2VsZi5fcm9sbGluZ0JhY2sgJiYgc2VsZi5zaWduYWxpbmdTdGF0ZSAhPT0gcHJldmlvdXNTaWduYWxpbmdTdGF0ZSkge1xuICAgICAgICAgICAgcHJldmlvdXNTaWduYWxpbmdTdGF0ZSA9IHNlbGYuc2lnbmFsaW5nU3RhdGU7XG4gICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBJbiBGaXJlZm94LCAnc2lnbmFsaW5nc3RhdGVjaGFuZ2UnIGV2ZW50IGlzXG4gICAgICAgICAgICAvLyB0cmlnZ2VyZWQgc3luY2hyb25vdXNseSBpbiB0aGUgc2FtZSB0aWNrIGFmdGVyXG4gICAgICAgICAgICAvLyBSVENQZWVyQ29ubmVjdGlvbiNjbG9zZSgpIGlzIGNhbGxlZC4gU28gd2UgbWltaWMgQ2hyb21lJ3MgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIGJ5IHRyaWdnZXJpbmcgJ3NpZ25hbGluZ3N0YXRlY2hhbmdlJyBvbiB0aGUgbmV4dCB0aWNrLlxuICAgICAgICAgICAgdmFyIGRpc3BhdGNoRXZlbnRUb1NlbGYgPSBzZWxmLmRpc3BhdGNoRXZlbnQuYXBwbHkuYmluZChzZWxmLmRpc3BhdGNoRXZlbnQsIHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoc2VsZi5faXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGRpc3BhdGNoRXZlbnRUb1NlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudFRvU2VsZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdXRpbC5wcm94eVByb3BlcnRpZXMoUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCB0aGlzLCBwZWVyQ29ubmVjdGlvbik7XG59XG5pbmhlcml0cyhGaXJlZm94UlRDUGVlckNvbm5lY3Rpb24sIEV2ZW50VGFyZ2V0KTtcbi8vIE5PVEUobW1hbGF2YWxsaSk6IEZpcmVmb3ggdGhyb3dzIGEgVHlwZUVycm9yIHdoZW4gdGhlIFBlZXJDb25uZWN0aW9uJ3Ncbi8vIHByb3RvdHlwZSdzIFwicGVlcklkZW50aXR5XCIgcHJvcGVydHkgaXMgYWNjZXNzZWQuIEluIG9yZGVyIHRvIG92ZXJjb21lXG4vLyB0aGlzLCB3ZSBpZ25vcmUgdGhpcyBwcm9wZXJ0eSB3aGlsZSBkZWxlZ2F0aW5nIG1ldGhvZHMuXG4vLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjM4MTVcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGaXJlZm94UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAncGVlcklkZW50aXR5Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGlkcDogJycsXG4gICAgICAgIG5hbWU6ICcnXG4gICAgfSlcbn0pO1xuaWYgKG5lZWRzV29ya2Fyb3VuZEZvckJ1ZzE0ODAyNzcpIHtcbiAgICBGaXJlZm94UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2soKSB7XG4gICAgICAgIHZhciB0cmFjayA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIHNlbmRlciA9IHRoaXMuX3BlZXJDb25uZWN0aW9uLmFkZFRyYWNrLmFwcGx5KHRoaXMuX3BlZXJDb25uZWN0aW9uLCBhcmd1bWVudHMpO1xuICAgICAgICBzZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICB9O1xufVxuRmlyZWZveFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIHByb21pc2U7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHByb21pc2UgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKS50aGVuKGZ1bmN0aW9uIGNyZWF0ZUFuc3dlclN1Y2NlZWRlZChhbnN3ZXIpIHtcbiAgICAgICAgc2F2ZUluaXRpYWxseU5lZ290aWF0ZWREdGxzUm9sZShzZWxmLCBhbnN3ZXIpO1xuICAgICAgICByZXR1cm4gb3ZlcndyaXRlV2l0aEluaXRpYWxseU5lZ290aWF0ZWREdGxzUm9sZShhbnN3ZXIsIHNlbGYuX2luaXRpYWxseU5lZ290aWF0ZWREdGxzUm9sZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdXRpbC5sZWdhY3lQcm9taXNlKHByb21pc2UsIGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgIDogcHJvbWlzZTtcbn07XG4vLyBOT1RFKG1yb2JlcnRzKTogVGhlIFdlYlJUQyBzcGVjIGFsbG93cyB5b3UgdG8gY2FsbCBjcmVhdGVPZmZlciBmcm9tIGFueVxuLy8gc2lnbmFsaW5nU3RhdGUgb3RoZXIgdGhhbiBcImNsb3NlZFwiOyBob3dldmVyLCBGaXJlZm94IGhhcyBub3QgeWV0IGltcGxlbWVudGVkXG4vLyB0aGlzIChodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDcyMzg4KS4gV2Ugd29ya2Fyb3VuZFxuLy8gdGhpcyBieSByb2xsaW5nIGJhY2sgaWYgd2UgYXJlIGluIHN0YXRlIFwiaGF2ZS1sb2NhbC1vZmZlclwiIG9yXG4vLyBcImhhdmUtcmVtb3RlLW9mZmVyXCIuIFRoaXMgaXMgYWNjZXB0YWJsZSBmb3Igb3VyIHVzZSBjYXNlIGJlY2F1c2Ugd2Ugd2lsbFxuLy8gYXBwbHkgdGhlIG5ld2x5LWNyZWF0ZWQgb2ZmZXIgYWxtb3N0IGltbWVkaWF0ZWx5OyBob3dldmVyLCB0aGlzIG1heSBiZVxuLy8gdW5hY2NlcHRhYmxlIGZvciBvdGhlciB1c2UgY2FzZXMuXG5GaXJlZm94UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIG9wdGlvbnMgPSAoYXJncy5sZW5ndGggPiAxID8gYXJnc1syXSA6IGFyZ3NbMF0pIHx8IHt9O1xuICAgIHZhciBwcm9taXNlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2hhdmUtbG9jYWwtb2ZmZXInIHx8XG4gICAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLXJlbW90ZS1vZmZlcicpIHtcbiAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2hhdmUtbG9jYWwtb2ZmZXInO1xuICAgICAgICBwcm9taXNlID0gcm9sbGJhY2sodGhpcywgbG9jYWwsIGZ1bmN0aW9uIHJvbGxiYWNrU3VjY2VlZGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY3JlYXRlT2ZmZXIob3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IHNlbGYuX3BlZXJDb25uZWN0aW9uLmNyZWF0ZU9mZmVyKG9wdGlvbnMpO1xuICAgIH1cbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChvZmZlcikge1xuICAgICAgICByZXR1cm4gbmV3IEZpcmVmb3hSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgdHlwZTogb2ZmZXIudHlwZSxcbiAgICAgICAgICAgIHNkcDogdXBkYXRlVHJhY2tzVG9TU1JDcyhzZWxmLl90cmFja3NUb1NTUkNzLCBvZmZlci5zZHApXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBhcmdzLmxlbmd0aCA+IDFcbiAgICAgICAgPyB1dGlsLmxlZ2FjeVByb21pc2UocHJvbWlzZSwgYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgOiBwcm9taXNlO1xufTtcbi8vIE5PVEUobXJvYmVydHMpOiBXaGlsZSBGaXJlZm94IHdpbGwgcmVqZWN0IHRoZSBQcm9taXNlIHJldHVybmVkIGJ5XG4vLyBzZXRMb2NhbERlc2NyaXB0aW9uIHdoZW4gY2FsbGVkIGZyb20gc2lnbmFsaW5nU3RhdGUgXCJoYXZlLWxvY2FsLW9mZmVyXCIgd2l0aFxuLy8gYW4gYW5zd2VyLCBpdCBzdGlsbCB1cGRhdGVzIHRoZSAubG9jYWxEZXNjcmlwdGlvbiBwcm9wZXJ0eS4gV2Ugd29ya2Fyb3VuZFxuLy8gdGhpcyBieSBleHBsaWNpdGx5IGhhbmRsaW5nIHRoaXMgY2FzZS5cbkZpcmVmb3hSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gYXJnc1swXTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBpZiAoZGVzY3JpcHRpb24gJiYgZGVzY3JpcHRpb24udHlwZSA9PT0gJ2Fuc3dlcicgJiYgdGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2hhdmUtbG9jYWwtb2ZmZXInKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgbG9jYWwgYW5zd2VyIGluIHN0YXRlIGhhdmUtbG9jYWwtb2ZmZXInKSk7XG4gICAgfVxuICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgID8gdXRpbC5sZWdhY3lQcm9taXNlKHByb21pc2UsIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICA6IHByb21pc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMuX3BlZXJDb25uZWN0aW9uLCBhcmdzKTtcbn07XG4vLyBOT1RFKG1yb2JlcnRzKTogVGhlIFdlYlJUQyBzcGVjIGFsbG93cyB5b3UgdG8gY2FsbCBzZXRSZW1vdGVEZXNjcmlwdGlvbiB3aXRoXG4vLyBhbiBvZmZlciBtdWx0aXBsZSB0aW1lcyBpbiBzaWduYWxpbmdTdGF0ZSBcImhhdmUtcmVtb3RlLW9mZmVyXCI7IGhvd2V2ZXIsXG4vLyBGaXJlZm94IGhhcyBub3QgeWV0IGltcGxlbWVudGVkIHRoaXMgKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwNzIzODgpLlxuLy8gV2Ugd29ya2Fyb3VuZCB0aGlzIGJ5IHJvbGxpbmcgYmFjayBpZiB3ZSBhcmUgaW4gc3RhdGUgXCJoYXZlLXJlbW90ZS1vZmZlclwiLlxuLy8gVGhpcyBpcyBhY2NlcHRhYmxlIGZvciBvdXIgdXNlIGNhc2U7IGhvd2V2ZXIsIHRoaXMgbWF5IGJlIHVuYWNjZXB0YWJsZSBmb3Jcbi8vIG90aGVyIHVzZSBjYXNlcy5cbi8vXG4vLyBXaGlsZSBGaXJlZm94IHdpbGwgcmVqZWN0IHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IHNldFJlbW90ZURlc2NyaXB0aW9uIHdoZW5cbi8vIGNhbGxlZCBmcm9tIHNpZ25hbGluZ1N0YXRlIFwiaGF2ZS1yZW1vdGUtb2ZmZXJcIiB3aXRoIGFuIGFuc3dlciwgaXQgc2lsbFxuLy8gdXBkYXRlcyB0aGUgLnJlbW90ZURlc2NyaXB0aW9uIHByb3BlcnR5LiBXZSB3b3JrYXJvdW5kIHRoaXMgYnkgZXhwbGljaXRseVxuLy8gaGFuZGxpbmcgdGhpcyBjYXNlLlxuRmlyZWZveFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IGFyZ3NbMF07XG4gICAgdmFyIHByb21pc2U7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChkZXNjcmlwdGlvbiAmJiB0aGlzLnNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1yZW1vdGUtb2ZmZXInKSB7XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQ2Fubm90IHNldCByZW1vdGUgYW5zd2VyIGluIHN0YXRlIGhhdmUtcmVtb3RlLW9mZmVyJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSByb2xsYmFjayh0aGlzLCBmYWxzZSwgZnVuY3Rpb24gcm9sbGJhY2tTdWNjZWVkZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3BlZXJDb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlID0gdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24oZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uU3VjY2VlZGVkKCkge1xuICAgICAgICBzYXZlSW5pdGlhbGx5TmVnb3RpYXRlZER0bHNSb2xlKHNlbGYsIGRlc2NyaXB0aW9uLCB0cnVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJncy5sZW5ndGggPiAxXG4gICAgICAgID8gdXRpbC5sZWdhY3lQcm9taXNlKHByb21pc2UsIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgIDogcHJvbWlzZTtcbn07XG4vLyBOT1RFKG1yb2JlcnRzKTogVGhlIFdlYlJUQyBzcGVjIHNwZWNpZmllcyB0aGF0IHRoZSBQZWVyQ29ubmVjdGlvbidzIGludGVybmFsXG4vLyBpc0Nsb3NlZCBzbG90IHNob3VsZCBpbW1lZGlhdGVseSBiZSBzZXQgdG8gdHJ1ZTsgaG93ZXZlciwgaW4gRmlyZWZveCBpdFxuLy8gb2NjdXJzIGluIHRoZSBuZXh0IHRpY2suIFdlIHdvcmthcm91bmQgdGhpcyBieSB0cmFja2luZyBpc0Nsb3NlZCBtYW51YWxseS5cbkZpcmVmb3hSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgdGhpcy5faXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgIH1cbn07XG51dGlsLmRlbGVnYXRlTWV0aG9kcyhSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsIEZpcmVmb3hSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdfcGVlckNvbm5lY3Rpb24nKTtcbmZ1bmN0aW9uIHJvbGxiYWNrKHBlZXJDb25uZWN0aW9uLCBsb2NhbCwgb25jZVJvbGxlZEJhY2spIHtcbiAgICB2YXIgc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGxvY2FsID8gJ3NldExvY2FsRGVzY3JpcHRpb24nIDogJ3NldFJlbW90ZURlc2NyaXB0aW9uJztcbiAgICBwZWVyQ29ubmVjdGlvbi5fcm9sbGluZ0JhY2sgPSB0cnVlO1xuICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbi5fcGVlckNvbm5lY3Rpb25bc2V0TG9jYWxEZXNjcmlwdGlvbl0obmV3IEZpcmVmb3hSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICB0eXBlOiAncm9sbGJhY2snXG4gICAgfSkpLnRoZW4ob25jZVJvbGxlZEJhY2spLnRoZW4oZnVuY3Rpb24gb25jZVJvbGxlZEJhY2tTdWNjZWVkZWQocmVzdWx0KSB7XG4gICAgICAgIHBlZXJDb25uZWN0aW9uLl9yb2xsaW5nQmFjayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIGZ1bmN0aW9uIHJvbGxiYWNrT3JPbmNlUm9sbGVkQmFja0ZhaWxlZChlcnJvcikge1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5fcm9sbGluZ0JhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG59XG4vKipcbiAqIEV4dHJhY3QgdGhlIGluaXRpYWxseSBuZWdvdGlhdGVkIERUTFMgcm9sZSBvdXQgb2YgYW4gUlRDU2Vzc2lvbkRlc2NyaXB0aW9uJ3NcbiAqIHNkcCBwcm9wZXJ0eSBhbmQgc2F2ZSBpdCBvbiB0aGUgRmlyZWZveFJUQ1BlZXJDb25uZWN0aW9uIGlmIGFuZCBvbmx5IGlmXG4gKlxuICogICAxLiBBIERUTFMgcm9sZSB3YXMgbm90IGFscmVhZHkgc2F2ZWQgb24gdGhlIEZpcmVmb3hSVENQZWVyQ29ubmVjdGlvbiwgYW5kXG4gKiAgIDIuIFRoZSBkZXNjcmlwdGlvbiBpcyBhbiBhbnN3ZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RmlyZWZveFJUQ1BlZXJDb25uZWN0aW9ufSBwZWVyQ29ubmVjdGlvblxuICogQHBhcmFtIHtSVENTZXNzaW9uRGVzY3JpcHRpb259IGRlc2NyaXB0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdGU9ZmFsc2VdIC0gaWYgdHJ1ZSwgc2F2ZSB0aGUgaW52ZXJzZSBvZiB0aGUgRFRMUyByb2xlLFxuICogICBlLmcuIFwiYWN0aXZlXCIgaW5zdGVhZCBvZiBcInBhc3NpdmVcIiBhbmQgdmljZSB2ZXJzYVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gc2F2ZUluaXRpYWxseU5lZ290aWF0ZWREdGxzUm9sZShwZWVyQ29ubmVjdGlvbiwgZGVzY3JpcHRpb24sIHJlbW90ZSkge1xuICAgIC8vIE5PVEUobXJvYmVydHMpOiBKU0VQIHNwZWNpZmllcyB0aGF0IG9mZmVycyBhbHdheXMgb2ZmZXIgXCJhY3RwYXNzXCIgYXMgdGhlXG4gICAgLy8gRFRMUyByb2xlLiBXZSBuZWVkIHRvIGluc3BlY3QgYW5zd2VycyB0byBmaWd1cmUgb3V0IHRoZSBuZWdvdGlhdGVkIERUTFNcbiAgICAvLyByb2xlLlxuICAgIGlmIChwZWVyQ29ubmVjdGlvbi5faW5pdGlhbGx5TmVnb3RpYXRlZER0bHNSb2xlIHx8IGRlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSBkZXNjcmlwdGlvbi5zZHAubWF0Y2goL2E9c2V0dXA6KFthLXpdKykvKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGR0bHNSb2xlID0gbWF0Y2hbMV07XG4gICAgcGVlckNvbm5lY3Rpb24uX2luaXRpYWxseU5lZ290aWF0ZWREdGxzUm9sZSA9IHJlbW90ZSA/IHtcbiAgICAgICAgYWN0aXZlOiAncGFzc2l2ZScsXG4gICAgICAgIHBhc3NpdmU6ICdhY3RpdmUnXG4gICAgfVtkdGxzUm9sZV0gOiBkdGxzUm9sZTtcbn1cbi8qKlxuICogT3ZlcndyaXRlIHRoZSBEVExTIHJvbGUgaW4gdGhlIHNkcCBwcm9wZXJ0eSBvZiBhbiBSVENTZXNzaW9uRGVzY3JpcHRpb24gaWZcbiAqIGFuZCBvbmx5IGlmXG4gKlxuICogICAxLiBUaGUgZGVzY3JpcHRpb24gaXMgYW4gYW5zd2VyLCBhbmRcbiAqICAgMi4gQSBEVExTIHJvbGUgaXMgcHJvdmlkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UlRDU2Vzc2lvbkRlc2NyaXB0aW9ufSBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge3N0cmluZ30gW2R0bHNSb2xlXSAtIG9uZSBvZiBcImFjdGl2ZVwiIG9yIFwicGFzc2l2ZVwiXG4gKiBAcmV0dXJucyB7P1JUQ1Nlc3Npb25EZXNjcmlwdGlvbn0gZGVzY3JpcHRpb25cbiAqL1xuZnVuY3Rpb24gb3ZlcndyaXRlV2l0aEluaXRpYWxseU5lZ290aWF0ZWREdGxzUm9sZShkZXNjcmlwdGlvbiwgZHRsc1JvbGUpIHtcbiAgICBpZiAoZGVzY3JpcHRpb24gJiYgZGVzY3JpcHRpb24udHlwZSA9PT0gJ2Fuc3dlcicgJiYgZHRsc1JvbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXJlZm94UlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICAgICAgICBzZHA6IGRlc2NyaXB0aW9uLnNkcC5yZXBsYWNlKC9hPXNldHVwOlthLXpdKy9nLCAnYT1zZXR1cDonICsgZHRsc1JvbGUpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRpb247XG59XG5tb2R1bGUuZXhwb3J0cyA9IEZpcmVmb3hSVENQZWVyQ29ubmVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcmVmb3guanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBndWVzc0Jyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsJykuZ3Vlc3NCcm93c2VyO1xuICAgIHN3aXRjaCAoZ3Vlc3NCcm93c2VyKCkpIHtcbiAgICAgICAgY2FzZSAnY2hyb21lJzpcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jaHJvbWUnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmaXJlZm94JzpcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9maXJlZm94Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2FmYXJpJzpcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zYWZhcmknKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBSVENQZWVyQ29ubmVjdGlvbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUlRDUGVlckNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUlRDUGVlckNvbm5lY3Rpb24gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKiBnbG9iYWxzIFJUQ1BlZXJDb25uZWN0aW9uLCBSVENTZXNzaW9uRGVzY3JpcHRpb24gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnR0YXJnZXQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBMYXRjaCA9IHJlcXVpcmUoJy4uL3V0aWwvbGF0Y2gnKTtcbnZhciBzZHBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWwvc2RwJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBpc1VuaWZpZWRQbGFuID0gc2RwVXRpbHMuZ2V0U2RwRm9ybWF0KCkgPT09ICd1bmlmaWVkJztcbnZhciB1cGRhdGVUcmFja0lkc1RvU1NSQ3MgPSBpc1VuaWZpZWRQbGFuXG4gICAgPyBzZHBVdGlscy51cGRhdGVVbmlmaWVkUGxhblRyYWNrSWRzVG9TU1JDc1xuICAgIDogc2RwVXRpbHMudXBkYXRlUGxhbkJUcmFja0lkc1RvU1NSQ3M7XG5mdW5jdGlvbiBTYWZhcmlSVENQZWVyQ29ubmVjdGlvbihjb25maWd1cmF0aW9uKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gbmV3IFNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuICAgIHV0aWwuaW50ZXJjZXB0RXZlbnQodGhpcywgJ2RhdGFjaGFubmVsJyk7XG4gICAgdXRpbC5pbnRlcmNlcHRFdmVudCh0aGlzLCAnaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJyk7XG4gICAgdXRpbC5pbnRlcmNlcHRFdmVudCh0aGlzLCAnc2lnbmFsaW5nc3RhdGVjaGFuZ2UnKTtcbiAgICB1dGlsLmludGVyY2VwdEV2ZW50KHRoaXMsICd0cmFjaycpO1xuICAgIHZhciBwZWVyQ29ubmVjdGlvbiA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgIF9hcHBsaWVkVHJhY2tzVG9TU1JDczoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIF9hdWRpb1RyYW5zY2VpdmVyOiB7XG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIF9pc0Nsb3NlZDoge1xuICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgX3BlZXJDb25uZWN0aW9uOiB7XG4gICAgICAgICAgICB2YWx1ZTogcGVlckNvbm5lY3Rpb25cbiAgICAgICAgfSxcbiAgICAgICAgX3BlbmRpbmdMb2NhbE9mZmVyOiB7XG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIF9wZW5kaW5nUmVtb3RlT2ZmZXI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgX3JvbGxlZEJhY2tUcmFja3NUb1NTUkNzOiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgX3NpZ25hbGluZ1N0YXRlTGF0Y2g6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTGF0Y2goKVxuICAgICAgICB9LFxuICAgICAgICBfdHJhY2tzVG9TU1JDczoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIF92aWRlb1RyYW5zY2VpdmVyOiB7XG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGxvY2FsRGVzY3JpcHRpb246IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0xvY2FsT2ZmZXIgfHwgdGhpcy5fcGVlckNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaWNlQ29ubmVjdGlvblN0YXRlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2xvc2VkID8gJ2Nsb3NlZCcgOiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGljZUdhdGhlcmluZ1N0YXRlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2xvc2VkID8gJ2NvbXBsZXRlJyA6IHRoaXMuX3BlZXJDb25uZWN0aW9uLmljZUdhdGhlcmluZ1N0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdGVEZXNjcmlwdGlvbjoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nUmVtb3RlT2ZmZXIgfHwgdGhpcy5fcGVlckNvbm5lY3Rpb24ucmVtb3RlRGVzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25hbGluZ1N0YXRlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnY2xvc2VkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVuZGluZ0xvY2FsT2ZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoYXZlLWxvY2FsLW9mZmVyJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVuZGluZ1JlbW90ZU9mZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGF2ZS1yZW1vdGUtb2ZmZXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignZGF0YWNoYW5uZWwnLCBmdW5jdGlvbiBvbmRhdGFjaGFubmVsKGV2ZW50KSB7XG4gICAgICAgIHNoaW1EYXRhQ2hhbm5lbChldmVudC5jaGFubmVsKTtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9KTtcbiAgICBwZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiBvbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHNlbGYuX2lzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50LmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG4gICAgcGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignc2lnbmFsaW5nc3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiBvbnNpZ25hbGluZ3N0YXRlY2hhbmdlKCkge1xuICAgICAgICBpZiAoc2VsZi5faXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnKSB7XG4gICAgICAgICAgICBzZWxmLl9hcHBsaWVkVHJhY2tzVG9TU1JDcyA9IG5ldyBNYXAoc2VsZi5fdHJhY2tzVG9TU1JDcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWxmLl9wZW5kaW5nTG9jYWxPZmZlciAmJiAhc2VsZi5fcGVuZGluZ1JlbW90ZU9mZmVyKSB7XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIE5PVEUoc3llcnJhcHJhZ2FkYSk6IFRoaXMgZW5zdXJlcyB0aGF0IFNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uJ3MgXCJyZW1vdGVEZXNjcmlwdGlvblwiLCB3aGVuIGFjY2Vzc2VkXG4gICAgLy8gaW4gYW4gUlRDVHJhY2tFdmVudCBsaXN0ZW5lciwgd2lsbCBwb2ludCB0byB0aGUgdW5kZXJseWluZyBSVENQZWVyQ29ubmVjdGlvbidzXG4gICAgLy8gXCJyZW1vdGVEZXNjcmlwdGlvblwiLiBCZWZvcmUgdGhpcyBmaXgsIHRoaXMgd2FzIHN0aWxsIHBvaW50aW5nIHRvIFwiX3BlbmRpbmdSZW1vdGVPZmZlclwiXG4gICAgLy8gZXZlbiB0aG91Z2ggYSBuZXcgcmVtb3RlIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBoYWQgYWxyZWFkeSBiZWVuIGFwcGxpZWQuXG4gICAgcGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCBmdW5jdGlvbiBvbnRyYWNrKGV2ZW50KSB7XG4gICAgICAgIHNlbGYuX3BlbmRpbmdSZW1vdGVPZmZlciA9IG51bGw7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfSk7XG4gICAgdXRpbC5wcm94eVByb3BlcnRpZXMoUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCB0aGlzLCBwZWVyQ29ubmVjdGlvbik7XG59XG5pbmhlcml0cyhTYWZhcmlSVENQZWVyQ29ubmVjdGlvbiwgRXZlbnRUYXJnZXQpO1xuU2FmYXJpUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLXJlbW90ZS1vZmZlcicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbGluZ1N0YXRlTGF0Y2gud2hlbignbG93JykudGhlbihmdW5jdGlvbiBzaWduYWxpbmdTdGF0ZXNSZXNvbHZlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9wZWVyQ29ubmVjdGlvbi5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbn07XG5TYWZhcmlSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBOT1RFKG1yb2JlcnRzKTogSW4gZ2VuZXJhbCwgdGhpcyBpcyBub3QgdGhlIHdheSB0byBkbyB0aGlzOyBob3dldmVyLCBpdCdzXG4gICAgLy8gZ29vZCBlbm91Z2ggZm9yIG91ciBhcHBsaWNhdGlvbi5cbiAgICBpZiAob3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvICYmICF0aGlzLl9hdWRpb1RyYW5zY2VpdmVyICYmICEoaXNVbmlmaWVkUGxhbiAmJiBoYXNSZWNlaXZlcnNGb3JUcmFja3NPZktpbmQodGhpcywgJ2F1ZGlvJykpKSB7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW87XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9hdWRpb1RyYW5zY2VpdmVyID0gaXNVbmlmaWVkUGxhblxuICAgICAgICAgICAgICAgID8gdGhpcy5hZGRUcmFuc2NlaXZlcignYXVkaW8nLCB7IGRpcmVjdGlvbjogJ3JlY3Zvbmx5JyB9KVxuICAgICAgICAgICAgICAgIDogdGhpcy5hZGRUcmFuc2NlaXZlcignYXVkaW8nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gJiYgIXRoaXMuX3ZpZGVvVHJhbnNjZWl2ZXIgJiYgIShpc1VuaWZpZWRQbGFuICYmIGhhc1JlY2VpdmVyc0ZvclRyYWNrc09mS2luZCh0aGlzLCAndmlkZW8nKSkpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZGVvVHJhbnNjZWl2ZXIgPSBpc1VuaWZpZWRQbGFuXG4gICAgICAgICAgICAgICAgPyB0aGlzLmFkZFRyYW5zY2VpdmVyKCd2aWRlbycsIHsgZGlyZWN0aW9uOiAncmVjdm9ubHknIH0pXG4gICAgICAgICAgICAgICAgOiB0aGlzLmFkZFRyYW5zY2VpdmVyKCd2aWRlbycpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uLmNyZWF0ZU9mZmVyKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKG9mZmVyKSB7XG4gICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IElmIGNyZWF0ZU9mZmVyKCkgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHJvbGxpbmcgYmFjayxcbiAgICAgICAgLy8gdGhlbiB3ZSBubyBsb25nZXIgbmVlZCB0byByZXRhaW4gdGhlIHJvbGxlZCBiYWNrIHRyYWNrcyB0byBTU1JDcyBNYXAuXG4gICAgICAgIHNlbGYuX3JvbGxlZEJhY2tUcmFja3NUb1NTUkNzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6IG9mZmVyLnR5cGUsXG4gICAgICAgICAgICBzZHA6IHVwZGF0ZVRyYWNrSWRzVG9TU1JDcyhzZWxmLl90cmFja3NUb1NTUkNzLCBvZmZlci5zZHApXG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5fcGVuZGluZ1JlbW90ZU9mZmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbih0aGlzLl9wZW5kaW5nUmVtb3RlT2ZmZXIpLnRoZW4oZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb25TdWNjZWVkZWQoKSB7XG4gICAgICAgICAgICBzZWxmLl9zaWduYWxpbmdTdGF0ZUxhdGNoLmxvd2VyKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fcGVlckNvbm5lY3Rpb24uY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gY3JlYXRlQW5zd2VyU3VjY2VlZGVkKGFuc3dlcikge1xuICAgICAgICAgICAgc2VsZi5fcGVuZGluZ1JlbW90ZU9mZmVyID0gbnVsbDtcbiAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IElmIGNyZWF0ZUFuc3dlcigpIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciByb2xsaW5nIGJhY2ssIHRoZW4gd2Ugbm9cbiAgICAgICAgICAgIC8vIGxvbmdlciBuZWVkIHRvIHJldGFpbiB0aGUgcm9sbGVkIGJhY2sgdHJhY2tzIHRvIFNTUkNzIE1hcC5cbiAgICAgICAgICAgIHNlbGYuX3JvbGxlZEJhY2tUcmFja3NUb1NTUkNzLmNsZWFyKCk7XG4gICAgICAgICAgICByZXR1cm4gaXNVbmlmaWVkUGxhbiA/IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFuc3dlci50eXBlLFxuICAgICAgICAgICAgICAgIHNkcDogdXBkYXRlVHJhY2tJZHNUb1NTUkNzKHNlbGYuX3RyYWNrc1RvU1NSQ3MsIGFuc3dlci5zZHApXG4gICAgICAgICAgICB9KSA6IGFuc3dlcjtcbiAgICAgICAgfSwgZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb25PckNyZWF0ZUFuc3dlckZhaWxlZChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5fcGVuZGluZ1JlbW90ZU9mZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uLmNyZWF0ZUFuc3dlcihvcHRpb25zKS50aGVuKGZ1bmN0aW9uIGNyZWF0ZUFuc3dlclN1Y2NlZWRlZChhbnN3ZXIpIHtcbiAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogSWYgY3JlYXRlQW5zd2VyKCkgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHJvbGxpbmcgYmFjaywgdGhlbiB3ZSBub1xuICAgICAgICAvLyBsb25nZXIgbmVlZCB0byByZXRhaW4gdGhlIHJvbGxlZCBiYWNrIHRyYWNrcyB0byBTU1JDcyBNYXAuXG4gICAgICAgIHNlbGYuX3JvbGxlZEJhY2tUcmFja3NUb1NTUkNzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiBpc1VuaWZpZWRQbGFuID8gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgICB0eXBlOiBhbnN3ZXIudHlwZSxcbiAgICAgICAgICAgIHNkcDogdXBkYXRlVHJhY2tJZHNUb1NTUkNzKHNlbGYuX3RyYWNrc1RvU1NSQ3MsIGFuc3dlci5zZHApXG4gICAgICAgIH0pIDogYW5zd2VyO1xuICAgIH0pO1xufTtcblNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVEYXRhQ2hhbm5lbCA9IGZ1bmN0aW9uIGNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBkYXRhQ2hhbm5lbERpY3QpIHtcbiAgICB2YXIgZGF0YUNoYW5uZWwgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KTtcbiAgICBzaGltRGF0YUNoYW5uZWwoZGF0YUNoYW5uZWwpO1xuICAgIHJldHVybiBkYXRhQ2hhbm5lbDtcbn07XG5TYWZhcmlSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICBzZW5kZXIucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLnJlbW92ZVRyYWNrKHNlbmRlcik7XG59O1xuU2FmYXJpUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRMb2NhbERlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgLy8gTk9URShtbWFsYXZhbGxpKTogSWYgc2V0TG9jYWxEZXNjcmlwdGlvbigpIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciByb2xsaW5nIGJhY2ssXG4gICAgLy8gdGhlbiB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIHJvbGxlZCBiYWNrIHRyYWNrcyB0byBTU1JDcyBNYXAuXG4gICAgaWYgKHRoaXMuX3JvbGxlZEJhY2tUcmFja3NUb1NTUkNzLnNpemUgPiAwKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrc1RvU1NSQ3MgPSBuZXcgTWFwKHRoaXMuX3JvbGxlZEJhY2tUcmFja3NUb1NTUkNzKTtcbiAgICAgICAgdGhpcy5fcm9sbGVkQmFja1RyYWNrc1RvU1NSQ3MuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldERlc2NyaXB0aW9uKHRoaXMsIHRydWUsIGRlc2NyaXB0aW9uKTtcbn07XG5TYWZhcmlSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IElmIHNldFJlbW90ZURlc2NyaXB0aW9uKCkgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHJvbGxpbmcgYmFjayxcbiAgICAvLyB0aGVuIHdlIG5vIGxvbmdlciBuZWVkIHRvIHJldGFpbiB0aGUgcm9sbGVkIGJhY2sgdHJhY2tzIHRvIFNTUkNzIE1hcC5cbiAgICB0aGlzLl9yb2xsZWRCYWNrVHJhY2tzVG9TU1JDcy5jbGVhcigpO1xuICAgIHJldHVybiBzZXREZXNjcmlwdGlvbih0aGlzLCBmYWxzZSwgZGVzY3JpcHRpb24pO1xufTtcblNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLl9pc0Nsb3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lzQ2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJykpO1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdzaWduYWxpbmdzdGF0ZWNoYW5nZScpKTtcbiAgICB9KTtcbn07XG51dGlsLmRlbGVnYXRlTWV0aG9kcyhSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsIFNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ19wZWVyQ29ubmVjdGlvbicpO1xuZnVuY3Rpb24gc2V0RGVzY3JpcHRpb24ocGVlckNvbm5lY3Rpb24sIGxvY2FsLCBkZXNjcmlwdGlvbikge1xuICAgIGZ1bmN0aW9uIHNldFBlbmRpbmdMb2NhbE9mZmVyKG9mZmVyKSB7XG4gICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24uX3BlbmRpbmdMb2NhbE9mZmVyID0gb2ZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ1JlbW90ZU9mZmVyID0gb2ZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJQZW5kaW5nTG9jYWxPZmZlcigpIHtcbiAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24uX3BlbmRpbmdSZW1vdGVPZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBlbmRpbmdMb2NhbE9mZmVyID0gbG9jYWwgPyBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXIgOiBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ1JlbW90ZU9mZmVyO1xuICAgIHZhciBwZW5kaW5nUmVtb3RlT2ZmZXIgPSBsb2NhbCA/IHBlZXJDb25uZWN0aW9uLl9wZW5kaW5nUmVtb3RlT2ZmZXIgOiBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXI7XG4gICAgdmFyIGludGVybWVkaWF0ZVN0YXRlID0gbG9jYWwgPyAnaGF2ZS1sb2NhbC1vZmZlcicgOiAnaGF2ZS1yZW1vdGUtb2ZmZXInO1xuICAgIHZhciBzZXRMb2NhbERlc2NyaXB0aW9uID0gbG9jYWwgPyAnc2V0TG9jYWxEZXNjcmlwdGlvbicgOiAnc2V0UmVtb3RlRGVzY3JpcHRpb24nO1xuICAgIGlmICghbG9jYWwgJiYgcGVuZGluZ1JlbW90ZU9mZmVyICYmIGRlc2NyaXB0aW9uLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgIHJldHVybiBzZXRSZW1vdGVBbnN3ZXIocGVlckNvbm5lY3Rpb24sIGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09IGludGVybWVkaWF0ZVN0YXRlICYmIHBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQ2Fubm90IHNldCAnICsgKGxvY2FsID8gJ2xvY2FsJyA6ICdyZW1vdGUnKSArXG4gICAgICAgICAgICAgICAgJyBvZmZlciBpbiBzdGF0ZSAnICsgcGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBlbmRpbmdMb2NhbE9mZmVyICYmIHBlZXJDb25uZWN0aW9uLl9zaWduYWxpbmdTdGF0ZUxhdGNoLnN0YXRlID09PSAnbG93Jykge1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24uX3NpZ25hbGluZ1N0YXRlTGF0Y2gucmFpc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXNTaWduYWxpbmdTdGF0ZSA9IHBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlO1xuICAgICAgICBzZXRQZW5kaW5nTG9jYWxPZmZlcihkZXNjcmlwdGlvbik7XG4gICAgICAgIC8vIE9ubHkgZGlzcGF0Y2ggYSBzaWduYWxpbmdzdGF0ZWNoYW5nZSBldmVudCBpZiB3ZSB0cmFuc2l0aW9uZWQuXG4gICAgICAgIGlmIChwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSAhPT0gcHJldmlvdXNTaWduYWxpbmdTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gZGlzcGF0Y2hTaWduYWxpbmdTdGF0ZUNoYW5nZUV2ZW50KCkge1xuICAgICAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdzaWduYWxpbmdzdGF0ZWNoYW5nZScpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ3JvbGxiYWNrJykge1xuICAgICAgICBpZiAocGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09IGludGVybWVkaWF0ZVN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDYW5ub3Qgcm9sbGJhY2sgJyArXG4gICAgICAgICAgICAgICAgKGxvY2FsID8gJ2xvY2FsJyA6ICdyZW1vdGUnKSArICcgZGVzY3JpcHRpb24gaW4gJyArIHBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJQZW5kaW5nTG9jYWxPZmZlcigpO1xuICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBXZSBzdG9yZSB0aGUgcm9sbGVkIGJhY2sgdHJhY2tzIHRvIFNTUkNzIE1hcCBoZXJlIGluIGNhc2VcbiAgICAgICAgLy8gc2V0TG9jYWxEZXNjcmlwdGlvbigpIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlcmEgcm9sbGJhY2sgKHdpdGhvdXQgY2FsbGluZ1xuICAgICAgICAvLyBjcmVhdGVPZmZlcigpIG9yIGNyZWF0ZUFuc3dlcigpKSwgaW4gd2hpY2ggY2FzZSB0aGlzIHJvbGwgYmFjayBpcyBub3QgZHVlIHRvXG4gICAgICAgIC8vIGEgZ2xhcmUgc2NlbmFyaW8gYW5kIHRoaXMgTWFwIHNob3VsZCBiZSByZXN0b3JlZC5cbiAgICAgICAgcGVlckNvbm5lY3Rpb24uX3JvbGxlZEJhY2tUcmFja3NUb1NTUkNzID0gbmV3IE1hcChwZWVyQ29ubmVjdGlvbi5fdHJhY2tzVG9TU1JDcyk7XG4gICAgICAgIHBlZXJDb25uZWN0aW9uLl90cmFja3NUb1NTUkNzID0gbmV3IE1hcChwZWVyQ29ubmVjdGlvbi5fYXBwbGllZFRyYWNrc1RvU1NSQ3MpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiBkaXNwYXRjaFNpZ25hbGluZ1N0YXRlQ2hhbmdlRXZlbnQoKSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc2lnbmFsaW5nc3RhdGVjaGFuZ2UnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGVlckNvbm5lY3Rpb24uX3BlZXJDb25uZWN0aW9uW3NldExvY2FsRGVzY3JpcHRpb25dKGRlc2NyaXB0aW9uKTtcbn1cbmZ1bmN0aW9uIHNldFJlbW90ZUFuc3dlcihwZWVyQ29ubmVjdGlvbiwgYW5zd2VyKSB7XG4gICAgdmFyIHBlbmRpbmdMb2NhbE9mZmVyID0gcGVlckNvbm5lY3Rpb24uX3BlbmRpbmdMb2NhbE9mZmVyO1xuICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbi5fcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihwZW5kaW5nTG9jYWxPZmZlcikudGhlbihmdW5jdGlvbiBzZXRMb2NhbE9mZmVyU3VjY2VlZGVkKCkge1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gcGVlckNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIHNldFJlbW90ZUFuc3dlclN1Y2NlZWRlZCgpIHtcbiAgICAgICAgcGVlckNvbm5lY3Rpb24uX3NpZ25hbGluZ1N0YXRlTGF0Y2gubG93ZXIoKTtcbiAgICB9KTtcbn1cbi8qKlxuICogV2hldGhlciBhIFNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uIGhhcyBhbnkgUlRDUnRwUmVjZWl2ZXJzKHMpIGZvciB0aGUgZ2l2ZW5cbiAqIE1lZGlhU3RyZWFtVHJhY2sga2luZC5cbiAqIEBwYXJhbSB7U2FmYXJpUlRDUGVlckNvbm5lY3Rpb259IHBlZXJDb25uZWN0aW9uXG4gKiBAcGFyYW0geydhdWRpbycgfCAndmlkZW8nfSBraW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzUmVjZWl2ZXJzRm9yVHJhY2tzT2ZLaW5kKHBlZXJDb25uZWN0aW9uLCBraW5kKSB7XG4gICAgcmV0dXJuICEhcGVlckNvbm5lY3Rpb24uZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZChmdW5jdGlvbiAodHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJlY2VpdmVyICYmIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrICYmIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09IGtpbmQ7XG4gICAgfSk7XG59XG4vKipcbiAqIFNoaW0gYW4gUlRDRGF0YUNoYW5uZWwuIFRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGUgUlRDRGF0YUNoYW5uZWwuXG4gKiBAcGFyYW0ge1JUQ0RhdGFDaGFubmVsfSBkYXRhQ2hhbm5lbFxuICogQHJldHVybnMge1JUQ0RhdGFDaGFubmVsfVxuICovXG5mdW5jdGlvbiBzaGltRGF0YUNoYW5uZWwoZGF0YUNoYW5uZWwpIHtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGF0YUNoYW5uZWwsIHtcbiAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IHtcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhQ2hhbm5lbC5tYXhQYWNrZXRMaWZlVGltZSA9PT0gNjU1MzVcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IGRhdGFDaGFubmVsLm1heFBhY2tldExpZmVUaW1lXG4gICAgICAgIH0sXG4gICAgICAgIG1heFJldHJhbnNtaXRzOiB7XG4gICAgICAgICAgICB2YWx1ZTogZGF0YUNoYW5uZWwubWF4UmV0cmFuc21pdHMgPT09IDY1NTM1XG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBkYXRhQ2hhbm5lbC5tYXhSZXRyYW5zbWl0c1xuICAgICAgICB9XG4gICAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IFNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FmYXJpLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogUlRDUnRwU2VuZGVyIHNoaW0uXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gKiBAcHJvcGVydHkge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gKi9cbmZ1bmN0aW9uIFJUQ1J0cFNlbmRlclNoaW0odHJhY2spIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgIHRyYWNrOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRyYWNrLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gTk9URShtbWFsYXZhbGxpKTogQmVjYXVzZSBvZiB0aGUgd2F5IHdlIHdpbGwgYmUgdXNpbmcgdGhpcyBzaGltLCB0aGVyZVxuLy8gYXJlIGEgY291cGxlIG9mIHVzZSBjYXNlcyB0aGF0IHdpbGwgbm90IGJlIGNvdmVyZWQ6XG4vL1xuLy8gLyogQ2FzZSAxICovXG4vLyBjb25zdCBzZW5kZXIgPSBwYy5hZGRUcmFjayh0cmFjayk7XG4vLyBhc3NlcnQuZXF1YWwoc2VuZGVyLnRyYWNrLCB0cmFjayk7XG4vLyBwYy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuLy8gYXNzZXJ0LmVxdWFsKHNlbmRlci50cmFjaywgbnVsbCk7IC8qIEVycm9yICovXG4vL1xuLy8gLyogQ2FzZSAyICovXG4vLyBjb25zdCBzZW5kZXIgPSBwYy5hZGRUcmFjayh0cmFjayk7XG4vLyBjb25zdCBzZW5kZXJzMSA9IG5ldyBTZXQocGMuZ2V0U2VuZGVycygpKTtcbi8vIGFzc2VydChzZW5kZXJzMS5oYXMoc2VuZGVyKSk7XG4vLyBwYy5yZW1vdmVUcmFjayh0cmFjayk7XG4vLyBjb25zdCBzZW5kZXJzMiA9IG5ldyBTZXQocGMuZ2V0U2VuZGVycygpKTtcbi8vIGFzc2VydChzZW5kZXJzMi5oYXMoc2VuZGVyKSk7IC8qIEVycm9yICovXG4vL1xuLy8gRm9yIG5vdywgc2luY2Ugd2Ugb25seSB1c2Ugc2VuZGVycyBmb3IgcGFzc2luZyB0aGVtIHRvIFJUQ1BlZXJDb25uZWN0aW9uI3JlbW92ZVRyYWNrKCksXG4vLyB3ZSB3aWxsIG9taXQgaGFuZGxpbmcgdGhlc2UgdXNlIGNhc2VzIGZvciBub3csIGFuZCByZXZpc2l0IHRoZW0gd2hlbiB3ZSBzdGFydFxuLy8gdXNpbmcgdGhlIFJUQ1J0cFNlbmRlciBBUElzLlxubW9kdWxlLmV4cG9ydHMgPSBSVENSdHBTZW5kZXJTaGltO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnRjcnRwc2VuZGVyLmpzLm1hcCIsIi8qIGdsb2JhbHMgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uICovXG4ndXNlIHN0cmljdCc7XG4vLyBUaGlzIGNsYXNzIHdyYXBzIENocm9tZSdzIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBpbXBsZW1lbnRhdGlvbi4gSXQgcHJvdmlkZXNcbi8vIG9uZSBwaWVjZSBvZiBmdW5jdGlvbmFsaXR5IG5vdCBjdXJyZW50bHkgcHJlc2VudCBpbiBDaHJvbWUsIG5hbWVseVxuLy9cbi8vICAgMS4gUm9sbGJhY2sgc3VwcG9ydFxuLy8gICAgICBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NDY3NlxuLy9cbmZ1bmN0aW9uIENocm9tZVJUQ1Nlc3Npb25EZXNjcmlwdGlvbihkZXNjcmlwdGlvbkluaXREaWN0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENocm9tZVJUQ1Nlc3Npb25EZXNjcmlwdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaHJvbWVSVENTZXNzaW9uRGVzY3JpcHRpb24oZGVzY3JpcHRpb25Jbml0RGljdCk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgY29uc3RydWN0b3IgaXMgY2FsbGVkIHdpdGggYW4gb2JqZWN0IHdpdGggYSAudHlwZSBwcm9wZXJ0eSBzZXQgdG9cbiAgICAvLyBcInJvbGxiYWNrXCIsIHdlIHNob3VsZCBub3QgY2FsbCBDaHJvbWUncyBSVENTZXNzaW9uRGVzY3JpcHRpb24gY29uc3RydWN0b3IsXG4gICAgLy8gYmVjYXVzZSB0aGlzIHdvdWxkIHRocm93IGFuIFJUQ1NkcFR5cGUgZXJyb3IuXG4gICAgdmFyIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb25Jbml0RGljdCAmJiBkZXNjcmlwdGlvbkluaXREaWN0LnR5cGUgPT09ICdyb2xsYmFjaydcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihkZXNjcmlwdGlvbkluaXREaWN0KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgIF9kZXNjcmlwdGlvbjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZHA6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZGVzY3JpcHRpb24gPyBkZXNjcmlwdGlvbi5zZHAgOiBkZXNjcmlwdGlvbkluaXREaWN0LnNkcFxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGRlc2NyaXB0aW9uID8gZGVzY3JpcHRpb24udHlwZSA6IGRlc2NyaXB0aW9uSW5pdERpY3QudHlwZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IENocm9tZVJUQ1Nlc3Npb25EZXNjcmlwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNocm9tZS5qcy5tYXAiLCIvKiBnbG9iYWxzIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiAqL1xuJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBSVENTZXNzaW9uRGVzY3JpcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXJlZm94LmpzLm1hcCIsIi8qIGdsb2JhbHMgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uICovXG4ndXNlIHN0cmljdCc7XG5pZiAodHlwZW9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBndWVzc0Jyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsJykuZ3Vlc3NCcm93c2VyO1xuICAgIHN3aXRjaCAoZ3Vlc3NCcm93c2VyKCkpIHtcbiAgICAgICAgY2FzZSAnY2hyb21lJzpcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jaHJvbWUnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmaXJlZm94JzpcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9maXJlZm94Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gUlRDU2Vzc2lvbkRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSVENTZXNzaW9uRGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbi8qKlxuICogRXZlbnQgdGFyZ2V0LlxuICogQGNsYXNzXG4gKi9cbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgX2V2ZW50RW1pdHRlcjoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBFdmVudEVtaXR0ZXIoKVxuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIERpc3BhdGNoIGFuIEV2ZW50IHRvIHRoZSB7QGxpbmsgRXZlbnRUYXJnZXR9LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50RW1pdHRlci5lbWl0KGV2ZW50LnR5cGUsIGV2ZW50KTtcbn07XG4vKipcbiAqIEFkZCBhbiBFdmVudCBsaXN0ZW5lciB0byB0aGUge0BsaW5rIEV2ZW50VGFyZ2V0fS5cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudEVtaXR0ZXIuYWRkTGlzdGVuZXIuYXBwbHkodGhpcy5fZXZlbnRFbWl0dGVyLCBhcmd1bWVudHMpO1xufTtcbi8qKlxuICogUmVtb3ZlIGFuIEV2ZW50IGxpc3RlbmVyIHRvIHRoZSB7QGxpbmsgRXZlbnRUYXJnZXR9LlxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lci5hcHBseSh0aGlzLl9ldmVudEVtaXR0ZXIsIGFyZ3VtZW50cyk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50dGFyZ2V0LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQ3JlYXRlIGEge0BsaW5rIERlZmVycmVkfS5cbiAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAqL1xuZnVuY3Rpb24gZGVmZXIoKSB7XG4gICAgdmFyIGRlZmVycmVkID0ge307XG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59XG4vKipcbiAqIENvcHkgYSBtZXRob2QgZnJvbSBhIGBzb3VyY2VgIHByb3RvdHlwZSBvbnRvIGEgYHdyYXBwZXJgIHByb3RvdHlwZS4gSW52b2tpbmdcbiAqIHRoZSBtZXRob2Qgb24gdGhlIGB3cmFwcGVyYCBwcm90b3R5cGUgd2lsbCBpbnZva2UgdGhlIGNvcnJlc3BvbmRpbmcgbWV0aG9kXG4gKiBvbiBhbiBpbnN0YW5jZSBhY2Nlc3NlZCBieSBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSB3cmFwcGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZGVsZWdhdGVNZXRob2Qoc291cmNlLCB3cmFwcGVyLCB0YXJnZXQsIG1ldGhvZE5hbWUpIHtcbiAgICBpZiAobWV0aG9kTmFtZSBpbiB3cmFwcGVyKSB7XG4gICAgICAgIC8vIFNraXAgYW55IG1ldGhvZHMgYWxyZWFkeSBzZXQuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0aG9kTmFtZS5tYXRjaCgvXm9uW2Etel0rJC8pKSB7XG4gICAgICAgIC8vIFNraXAgRXZlbnRIYW5kbGVycyAodGhlc2UgYXJlIGhhbmRsZWQgaW4gdGhlIGNvbnN0cnVjdG9yKS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXNQcm9wZXJ0eSA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBwcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IHByb3BEZXNjICYmICEhcHJvcERlc2MuZ2V0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gaXRzIG9rYXkgdG8gZWF0IGZhaWx1cmUgaGVyZS5cbiAgICB9XG4gICAgLy8gTk9URShtcGF0d2FyZGhhbik6c2tpcCBwcm9wZXJ0aWVzLiB3ZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIG92ZXJyaWRpbmdcbiAgICAvLyBmdW5jdGlvbnMuIHdlIGRvIG5vdCBldmVuIHdhbnQgdG8gZXZhbHVhdGUgIGB0eXBlb2Ygc291cmNlW21ldGhvZE5hbWVdYCBmb3IgcHJvcGVydGllc1xuICAgIC8vIGJlY2F1c2UgZ2V0dGVyIHdvdWxkIGdldCBpbnZva2VkLCBhbmQgdGhleSBtaWdodCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICAvLyBGb3IgZXhhbXBsZSBSVENQZWVyQ29ubmVjdGlvbi5wZWVySWRlbnRpdHkgaXMgYSBwcm9wZXJ0eSB0aGF0IHJldHVybnMgYSBwcm9taXNlLlxuICAgIC8vIGNhbGxpbmcgdHlwZW9mIFJUQ1BlZXJDb25uZWN0aW9uLnBlZXJJZGVudGl0eSwgd291bGQgbGVhayBhIHByb21pc2UsIGFuZCBpbiBjYXNlIGl0IHJlamVjdHNcbiAgICAvLyB3ZSBzZWUgZXJyb3JzLlxuICAgIGlmIChpc1Byb3BlcnR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHR5cGU7XG4gICAgdHJ5IHtcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBOT1RFKG1yb2JlcnRzKTogQXR0ZW1wdGluZyB0byBjaGVjayB0aGUgdHlwZSBvZiBub24tZnVuY3Rpb24gbWVtYmVyc1xuICAgICAgICAvLyBvbiB0aGUgcHJvdG90eXBlIHRocm93cyBhbiBlcnJvciBmb3Igc29tZSB0eXBlcy5cbiAgICB9XG4gICAgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gU2tpcCBub24tZnVuY3Rpb24gbWVtYmVycy5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBlc2xpbnQgbm8tbG9vcC1mdW5jOjAgKi9cbiAgICB3cmFwcGVyW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YXJnZXRdW21ldGhvZE5hbWVdLmFwcGx5KHRoaXNbdGFyZ2V0XSwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuLyoqXG4gKiBDb3B5IG1ldGhvZHMgZnJvbSBhIGBzb3VyY2VgIHByb3RvdHlwZSBvbnRvIGEgYHdyYXBwZXJgIHByb3RvdHlwZS4gSW52b2tpbmdcbiAqIHRoZSBtZXRob2RzIG9uIHRoZSBgd3JhcHBlcmAgcHJvdG90eXBlIHdpbGwgaW52b2tlIHRoZSBjb3JyZXNwb25kaW5nIG1ldGhvZFxuICogb24gYW4gaW5zdGFuY2UgYWNjZXNzZWQgYnkgYHRhcmdldGAuXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlXG4gKiBAcGFyYW0ge29iamVjdH0gd3JhcHBlclxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZGVsZWdhdGVNZXRob2RzKHNvdXJjZSwgd3JhcHBlciwgdGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBzb3VyY2UpIHtcbiAgICAgICAgZGVsZWdhdGVNZXRob2Qoc291cmNlLCB3cmFwcGVyLCB0YXJnZXQsIG1ldGhvZE5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogRmluZHMgdGhlIGl0ZW1zIGluIGxpc3QxIHRoYXQgYXJlIG5vdCBpbiBsaXN0Mi5cbiAqIEBwYXJhbSB7QXJyYXk8Kj58TWFwPCo+fFNldDwqPn0gbGlzdDFcbiAqIEBwYXJhbSB7QXJyYXk8Kj58TWFwPCo+fFNldDwqPn0gbGlzdDJcbiAqIEByZXR1cm5zIHtTZXR9XG4gKi9cbmZ1bmN0aW9uIGRpZmZlcmVuY2UobGlzdDEsIGxpc3QyKSB7XG4gICAgbGlzdDEgPSBBcnJheS5pc0FycmF5KGxpc3QxKSA/IG5ldyBTZXQobGlzdDEpIDogbmV3IFNldChsaXN0MS52YWx1ZXMoKSk7XG4gICAgbGlzdDIgPSBBcnJheS5pc0FycmF5KGxpc3QyKSA/IG5ldyBTZXQobGlzdDIpIDogbmV3IFNldChsaXN0Mi52YWx1ZXMoKSk7XG4gICAgdmFyIGRpZmZlcmVuY2UgPSBuZXcgU2V0KCk7XG4gICAgbGlzdDEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoIWxpc3QyLmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgZGlmZmVyZW5jZS5hZGQoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGlmZmVyZW5jZTtcbn1cbi8qKlxuICogTWFwIGEgbGlzdCB0byBhbiBhcnJheSBvZiBhcnJheXMsIGFuZCByZXR1cm4gdGhlIGZsYXR0ZW5lZCByZXN1bHQuXG4gKiBAcGFyYW0ge0FycmF5PCo+fFNldDwqPnxNYXA8Kj59IGxpc3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKik6IEFycmF5PCo+fSBtYXBGblxuICogQHJldHVybnMgQXJyYXk8Kj5cbiAqL1xuZnVuY3Rpb24gZmxhdE1hcChsaXN0LCBtYXBGbikge1xuICAgIHZhciBsaXN0QXJyYXkgPSBsaXN0IGluc3RhbmNlb2YgTWFwIHx8IGxpc3QgaW5zdGFuY2VvZiBTZXRcbiAgICAgICAgPyBBcnJheS5mcm9tKGxpc3QudmFsdWVzKCkpXG4gICAgICAgIDogbGlzdDtcbiAgICByZXR1cm4gbGlzdEFycmF5LnJlZHVjZShmdW5jdGlvbiAoZmxhdHRlbmVkLCBpdGVtKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBtYXBGbihpdGVtKTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQobWFwcGVkKTtcbiAgICB9LCBbXSk7XG59XG4vKipcbiAqIEdldCB0aGUgYnJvd3NlcidzIHVzZXIgYWdlbnQsIGlmIGF2YWlsYWJsZS5cbiAqIEByZXR1cm5zIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICA/IG5hdmlnYXRvci51c2VyQWdlbnRcbiAgICAgICAgOiBudWxsO1xufVxuLyoqXG4gKiBHdWVzcyB0aGUgYnJvd3Nlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlckFnZW50PW5hdmlnYXRvci51c2VyQWdlbnRdXG4gKiBAcmV0dXJucyB7P3N0cmluZ30gYnJvd3NlciAtIFwiY2hyb21lXCIsIFwiZmlyZWZveFwiLCBcInNhZmFyaVwiLCBvciBudWxsXG4gKi9cbmZ1bmN0aW9uIGd1ZXNzQnJvd3Nlcih1c2VyQWdlbnQpIHtcbiAgICBpZiAodHlwZW9mIHVzZXJBZ2VudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gICAgfVxuICAgIGlmICgvQ2hyb21lfENyaU9TLy50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgcmV0dXJuICdjaHJvbWUnO1xuICAgIH1cbiAgICBpZiAoL0ZpcmVmb3h8RnhpT1MvLnRlc3QodXNlckFnZW50KSkge1xuICAgICAgICByZXR1cm4gJ2ZpcmVmb3gnO1xuICAgIH1cbiAgICBpZiAoL1NhZmFyaXxpUGhvbmV8aVBhZHxpUG9kLy50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgcmV0dXJuICdzYWZhcmknO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogR3Vlc3MgdGhlIGJyb3dzZXIgdmVyc2lvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlckFnZW50PW5hdmlnYXRvci51c2VyQWdlbnRdXG4gKiBAcmV0dXJucyB7P3ttYWpvcjogbnVtYmVyLCBtaW5vcjogbnVtYmVyfX1cbiAqL1xuZnVuY3Rpb24gZ3Vlc3NCcm93c2VyVmVyc2lvbih1c2VyQWdlbnQpIHtcbiAgICBpZiAodHlwZW9mIHVzZXJBZ2VudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gICAgfVxuICAgIHZhciBwcmVmaXggPSB7XG4gICAgICAgIGNocm9tZTogJ0Nocm9tZXxDcmlPUycsXG4gICAgICAgIGZpcmVmb3g6ICdGaXJlZm94fEZ4aU9TJyxcbiAgICAgICAgc2FmYXJpOiAnVmVyc2lvbidcbiAgICB9W2d1ZXNzQnJvd3Nlcih1c2VyQWdlbnQpXTtcbiAgICBpZiAoIXByZWZpeCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnKCcgKyBwcmVmaXggKyAnKS8oW15cXFxcc10rKScpO1xuICAgIHZhciBtYXRjaCA9ICh1c2VyQWdlbnQubWF0Y2gocmVnZXgpIHx8IFtdKVsyXTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmVyc2lvbnMgPSBtYXRjaC5zcGxpdCgnLicpLm1hcChOdW1iZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1ham9yOiBpc05hTih2ZXJzaW9uc1swXSkgPyBudWxsIDogdmVyc2lvbnNbMF0sXG4gICAgICAgIG1pbm9yOiBpc05hTih2ZXJzaW9uc1sxXSkgPyBudWxsIDogdmVyc2lvbnNbMV1cbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgaU9TIENocm9tZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlckFnZW50PW5hdmlnYXRvci51c2VyQWdlbnRdXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNJT1NDaHJvbWUodXNlckFnZW50KSB7XG4gICAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudCgpO1xuICAgIH1cbiAgICByZXR1cm4gKC9Nb2JpLy50ZXN0KHVzZXJBZ2VudCkgJiYgZ3Vlc3NCcm93c2VyKCkgPT09ICdjaHJvbWUnICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KHVzZXJBZ2VudCkpO1xufVxuLyoqXG4gKiBJbnRlcmNlcHQgYW4gZXZlbnQgdGhhdCBtaWdodCBvdGhlcndpc2UgYmUgcHJveGllZCBvbiBhbiBFdmVudFRhcmdldC5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBpbnRlcmNlcHRFdmVudCh0YXJnZXQsIHR5cGUpIHtcbiAgICB2YXIgY3VycmVudExpc3RlbmVyID0gbnVsbDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnb24nICsgdHlwZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50TGlzdGVuZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0xpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0xpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExpc3RlbmVyID0gbmV3TGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGlzdGVuZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFRoaXMgaXMgYSBmdW5jdGlvbiBmb3IgdHVybmluZyBhIFByb21pc2UgaW50byB0aGUga2luZCByZWZlcmVuY2VkIGluIHRoZVxuICogTGVnYWN5IEludGVyZmFjZSBFeHRlbnNpb25zIHNlY3Rpb24gb2YgdGhlIFdlYlJUQyBzcGVjLlxuICogQHBhcmFtIHtQcm9taXNlPCo+fSBwcm9taXNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uPCo+fSBvblN1Y2Nlc3NcbiAqIEBwYXJhbSB7ZnVuY3Rpb248RXJyb3I+fSBvbkZhaWx1cmVcbiAqIEByZXR1cm5zIHtQcm9taXNlPHVuZGVmaW5lZD59XG4gKi9cbmZ1bmN0aW9uIGxlZ2FjeVByb21pc2UocHJvbWlzZSwgb25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgICBpZiAob25TdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgb25TdWNjZXNzKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgb25GYWlsdXJlKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xufVxuLyoqXG4gKiBNYWtlIGEgdW5pcXVlIElELlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBtYWtlVVVJRCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgICAgIHZhciB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBGb3IgZWFjaCBwcm9wZXJ0eSBuYW1lIG9uIHRoZSBgc291cmNlYCBwcm90b3R5cGUsIGFkZCBnZXR0ZXJzIGFuZC9vciBzZXR0ZXJzXG4gKiB0byBgd3JhcHBlcmAgdGhhdCBwcm94eSB0byBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSB3cmFwcGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBwcm94eVByb3BlcnRpZXMoc291cmNlLCB3cmFwcGVyLCB0YXJnZXQpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgICAgICBwcm94eVByb3BlcnR5KHNvdXJjZSwgd3JhcHBlciwgdGFyZ2V0LCBwcm9wZXJ0eU5hbWUpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBGb3IgdGhlIHByb3BlcnR5IG5hbWUgb24gdGhlIGBzb3VyY2VgIHByb3RvdHlwZSwgYWRkIGEgZ2V0dGVyIGFuZC9vciBzZXR0ZXJcbiAqIHRvIGB3cmFwcGVyYCB0aGF0IHByb3hpZXMgdG8gYHRhcmdldGAuXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlXG4gKiBAcGFyYW0ge29iamVjdH0gd3JhcHBlclxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gcHJveHlQcm9wZXJ0eShzb3VyY2UsIHdyYXBwZXIsIHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgaWYgKHByb3BlcnR5TmFtZSBpbiB3cmFwcGVyKSB7XG4gICAgICAgIC8vIFNraXAgYW55IHByb3BlcnRpZXMgYWxyZWFkeSBzZXQuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvcGVydHlOYW1lLm1hdGNoKC9eb25bYS16XSskLykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdyYXBwZXIsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIocHJvcGVydHlOYW1lLnNsaWNlKDIpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3cmFwcGVyLmRpc3BhdGNoRXZlbnQuYXBwbHkod3JhcHBlciwgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdyYXBwZXIsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIG5hdGl2ZSBXZWJSVEMgQVBJcyBhcmUgc3VwcG9ydGVkLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHN1cHBvcnQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnXG4gICAgICAgICYmIHR5cGVvZiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzID09PSAnb2JqZWN0J1xuICAgICAgICAmJiB0eXBlb2YgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPT09ICdmdW5jdGlvbidcbiAgICAgICAgJiYgdHlwZW9mIFJUQ1BlZXJDb25uZWN0aW9uID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBEZWZlcnJlZFxuICogQHByb3BlcnR5IHtQcm9taXNlfSBwcm9taXNlXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSByZWplY3RcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHJlc29sdmVcbiAqL1xuZXhwb3J0cy5kZWZlciA9IGRlZmVyO1xuZXhwb3J0cy5kZWxlZ2F0ZU1ldGhvZHMgPSBkZWxlZ2F0ZU1ldGhvZHM7XG5leHBvcnRzLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuZXhwb3J0cy5mbGF0TWFwID0gZmxhdE1hcDtcbmV4cG9ydHMuZ3Vlc3NCcm93c2VyID0gZ3Vlc3NCcm93c2VyO1xuZXhwb3J0cy5ndWVzc0Jyb3dzZXJWZXJzaW9uID0gZ3Vlc3NCcm93c2VyVmVyc2lvbjtcbmV4cG9ydHMuaXNJT1NDaHJvbWUgPSBpc0lPU0Nocm9tZTtcbmV4cG9ydHMuaW50ZXJjZXB0RXZlbnQgPSBpbnRlcmNlcHRFdmVudDtcbmV4cG9ydHMubGVnYWN5UHJvbWlzZSA9IGxlZ2FjeVByb21pc2U7XG5leHBvcnRzLm1ha2VVVUlEID0gbWFrZVVVSUQ7XG5leHBvcnRzLnByb3h5UHJvcGVydGllcyA9IHByb3h5UHJvcGVydGllcztcbmV4cG9ydHMuc3VwcG9ydCA9IHN1cHBvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgZGVmZXIgPSByZXF1aXJlKCcuLycpLmRlZmVyO1xudmFyIHN0YXRlcyA9IHtcbiAgICBoaWdoOiBuZXcgU2V0KFsnbG93J10pLFxuICAgIGxvdzogbmV3IFNldChbJ2hpZ2gnXSlcbn07XG4vKipcbiAqIENvbnN0cnVjdCBhIHtAbGluayBMYXRjaH0uXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgQSB7QGxpbmsgTGF0Y2h9IGhhcyB0d28gc3RhdGVzIChcImhpZ2hcIiBhbmQgXCJsb3dcIikgYW5kIG1ldGhvZHMgZm9yXG4gKiB0cmFuc2l0aW9uaW5nIGJldHdlZW4gdGhlbSAoe0BsaW5rIExhdGNoI3JhaXNlfSBhbmQge0BsaW5rIExhdGNoI2xvd2VyfSkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2luaXRpYWxTdGF0ZT1cImxvd1wiXSAtIGVpdGhlciBcImhpZ2hcIiBvciBcImxvd1wiXG4gKi9cbmZ1bmN0aW9uIExhdGNoKGluaXRpYWxTdGF0ZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMYXRjaCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXRjaChpbml0aWFsU3RhdGUpO1xuICAgIH1cbiAgICB2YXIgc3RhdGUgPSBpbml0aWFsU3RhdGUgfHwgJ2xvdyc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICBfc3RhdGU6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gX3N0YXRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2hlbkRlZmVycmVkcyA9IHRoaXMuX3doZW5EZWZlcnJlZHMuZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgd2hlbkRlZmVycmVkcy5mb3JFYWNoKGZ1bmN0aW9uIChkZWZlcnJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHdoZW5EZWZlcnJlZHMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfd2hlbkRlZmVycmVkczoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoW1xuICAgICAgICAgICAgICAgIFsnaGlnaCcsIG5ldyBTZXQoKV0sXG4gICAgICAgICAgICAgICAgWydsb3cnLCBuZXcgU2V0KCldXG4gICAgICAgICAgICBdKVxuICAgICAgICB9LFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBUcmFuc2l0aW9uIHRvIFwibG93XCIuXG4gKiBAcmV0dXJucyB7dGhpc31cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5MYXRjaC5wcm90b3R5cGUubG93ZXIgPSBmdW5jdGlvbiBsb3dlcigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uKCdsb3cnKTtcbn07XG4vKipcbiAqIFRyYW5zaXRpb24gdG8gXCJoaWdoXCIuXG4gKiBAcmV0dXJucyB7dGhpc31cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5MYXRjaC5wcm90b3R5cGUucmFpc2UgPSBmdW5jdGlvbiByYWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uKCdoaWdoJyk7XG59O1xuLyoqXG4gKiBUcmFuc2l0aW9uIHRvIGEgbmV3IHN0YXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1N0YXRlXG4gKiBAcmV0dXJucyB7dGhpc31cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5MYXRjaC5wcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHRyYW5zaXRpb24obmV3U3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlc1t0aGlzLnN0YXRlXS5oYXMobmV3U3RhdGUpKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZVVucmVhY2hhYmxlU3RhdGVFcnJvcih0aGlzLnN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgfVxuICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBSZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUge0BsaW5rIExhdGNofSB0cmFuc2l0aW9ucyB0b1xuICogdGhlIHNwZWNpZmllZCBzdGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZVxuICogQHJldHVybnMge1Byb21pc2U8dGhpcz59XG4gKi9cbkxhdGNoLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24gd2hlbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlc1t0aGlzLnN0YXRlXS5oYXMoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjcmVhdGVVbnJlYWNoYWJsZVN0YXRlRXJyb3IodGhpcy5zdGF0ZSwgc3RhdGUpKTtcbiAgICB9XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB0aGlzLl93aGVuRGVmZXJyZWRzLmdldChzdGF0ZSkuYWRkKGRlZmVycmVkKTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG4vKipcbiAqIENyZWF0ZSBhbiB1bnJlYWNoYWJsZSBzdGF0ZSBFcnJvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tIC0gc3RhdGUgdG8gYmUgdHJhbnNpdGlvbmVkIGZyb21cbiAqIEBwYXJhbSB7c3RyaW5nfSB0byAtIHN0YXRlIHRvIGJlIHRyYW5zaXRpb25lZCB0b1xuICogQHJldHVybiB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVucmVhY2hhYmxlU3RhdGVFcnJvcihmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0Nhbm5vdCB0cmFuc2l0aW9uIGZyb20gXCInICsgZnJvbSArICdcIiB0byBcIicgKyB0byArICdcIicpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBMYXRjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhdGNoLmpzLm1hcCIsIi8qIGdsb2JhbHMgUlRDUGVlckNvbm5lY3Rpb24sIFJUQ1J0cFRyYW5zY2VpdmVyICovXG4ndXNlIHN0cmljdCc7XG52YXIgZmxhdE1hcCA9IHJlcXVpcmUoJy4vJykuZmxhdE1hcDtcbnZhciBndWVzc0Jyb3dzZXIgPSByZXF1aXJlKCcuLycpLmd1ZXNzQnJvd3Nlcjtcbi8vIE5PVEUobW1hbGF2YWxsaSk6IFdlIGNhY2hlIENocm9tZSdzIHNkcFNlbWFudGljcyBzdXBwb3J0IGluIG9yZGVyIHRvIHByZXZlbnRcbi8vIGluc3RhbnRpYXRpb24gb2YgbW9yZSB0aGFuIG9uZSBSVENQZWVyQ29ubmVjdGlvbi5cbnZhciBpc1NkcFNlbWFudGljc1N1cHBvcnRlZCA9IG51bGw7XG4vKipcbiAqIENoZWNrIGlmIENocm9tZSBzdXBwb3J0cyBzcGVjaWZ5aW5nIHNkcFNlbWFudGljcyBmb3IgYW4gUlRDUGVlckNvbm5lY3Rpb24uXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjaGVja0lmU2RwU2VtYW50aWNzSXNTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKHR5cGVvZiBpc1NkcFNlbWFudGljc1N1cHBvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBpc1NkcFNlbWFudGljc1N1cHBvcnRlZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaXNTZHBTZW1hbnRpY3NTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGlzU2RwU2VtYW50aWNzU3VwcG9ydGVkO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XG4gICAgICAgIG5ldyBSVENQZWVyQ29ubmVjdGlvbih7IHNkcFNlbWFudGljczogJ2ZvbycgfSk7XG4gICAgICAgIGlzU2RwU2VtYW50aWNzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlzU2RwU2VtYW50aWNzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzU2RwU2VtYW50aWNzU3VwcG9ydGVkO1xufVxuLy8gTk9URShtbWFsYXZhbGxpKTogV2UgY2FjaGUgQ2hyb21lJ3MgU0RQIGZvcm1hdCBpbiBvcmRlciB0byBwcmV2ZW50XG4vLyBpbnN0YW50aWF0aW9uIG9mIG1vcmUgdGhhbiBvbmUgUlRDUGVlckNvbm5lY3Rpb24uXG52YXIgY2hyb21lU2RwRm9ybWF0ID0gbnVsbDtcbi8qKlxuICogR2V0IENocm9tZSdzIGRlZmF1bHQgU0RQIGZvcm1hdC5cbiAqIEByZXR1cm5zIHsncGxhbmInfCd1bmlmaWVkJ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q2hyb21lRGVmYXVsdFNkcEZvcm1hdCgpIHtcbiAgICBpZiAoIWNocm9tZVNkcEZvcm1hdCkge1xuICAgICAgICBpZiAodHlwZW9mIFJUQ1BlZXJDb25uZWN0aW9uICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgJiYgJ2FkZFRyYW5zY2VpdmVyJyBpbiBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV3IFJUQ1BlZXJDb25uZWN0aW9uKCkuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICAgICAgICAgICAgY2hyb21lU2RwRm9ybWF0ID0gJ3VuaWZpZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjaHJvbWVTZHBGb3JtYXQgPSAncGxhbmInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hyb21lU2RwRm9ybWF0ID0gJ3BsYW5iJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hyb21lU2RwRm9ybWF0O1xufVxuLyoqXG4gKiBHZXQgQ2hyb21lJ3MgU0RQIGZvcm1hdC5cbiAqIEBwYXJhbSB7J3BsYW4tYid8J3VuaWZpZWQtcGxhbid9IFtzZHBTZW1hbnRpY3NdXG4gKiBAcmV0dXJucyB7J3BsYW5iJ3wndW5pZmllZCd9XG4gKi9cbmZ1bmN0aW9uIGdldENocm9tZVNkcEZvcm1hdChzZHBTZW1hbnRpY3MpIHtcbiAgICBpZiAoIXNkcFNlbWFudGljcyB8fCAhY2hlY2tJZlNkcFNlbWFudGljc0lzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGdldENocm9tZURlZmF1bHRTZHBGb3JtYXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ3BsYW4tYic6ICdwbGFuYicsXG4gICAgICAgICd1bmlmaWVkLXBsYW4nOiAndW5pZmllZCdcbiAgICB9W3NkcFNlbWFudGljc107XG59XG4vKipcbiAqIEdldCBTYWZhcmkncyBkZWZhdWx0IFNEUCBmb3JtYXQuXG4gKiBAcmV0dXJucyB7J3BsYW5iJ3wndW5pZmllZCd9XG4gKi9cbmZ1bmN0aW9uIGdldFNhZmFyaVNkcEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIFJUQ1J0cFRyYW5zY2VpdmVyICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAmJiAnY3VycmVudERpcmVjdGlvbicgaW4gUlRDUnRwVHJhbnNjZWl2ZXIucHJvdG90eXBlXG4gICAgICAgID8gJ3VuaWZpZWQnXG4gICAgICAgIDogJ3BsYW5iJztcbn1cbi8qKlxuICogR2V0IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBTRFAgZm9ybWF0LlxuICogQHBhcmFtIHsncGxhbi1iJ3wndW5pZmllZC1wbGFuJ30gW3NkcFNlbWFudGljc11cbiAqIEByZXR1cm5zIHsncGxhbmInfCd1bmlmaWVkJ31cbiAqL1xuZnVuY3Rpb24gZ2V0U2RwRm9ybWF0KHNkcFNlbWFudGljcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNocm9tZTogZ2V0Q2hyb21lU2RwRm9ybWF0KHNkcFNlbWFudGljcyksXG4gICAgICAgIGZpcmVmb3g6ICd1bmlmaWVkJyxcbiAgICAgICAgc2FmYXJpOiBnZXRTYWZhcmlTZHBGb3JtYXQoKVxuICAgIH1bZ3Vlc3NCcm93c2VyKCldIHx8IG51bGw7XG59XG4vKipcbiAqIE1hdGNoIGEgcGF0dGVybiBhY3Jvc3MgbGluZXMsIHJldHVybmluZyB0aGUgZmlyc3QgY2FwdHVyZSBncm91cCBmb3IgYW55XG4gKiBtYXRjaGVzLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm5cbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lc1xuICogQHJldHVybnMge1NldDxzdHJpbmc+fSBtYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoZXMocGF0dGVybiwgbGluZXMpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGxpbmVzLm1hdGNoKG5ldyBSZWdFeHAocGF0dGVybiwgJ2dtJykpIHx8IFtdO1xuICAgIHJldHVybiBtYXRjaGVzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0cywgbGluZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKG5ldyBSZWdFeHAocGF0dGVybikpO1xuICAgICAgICByZXR1cm4gbWF0Y2ggPyByZXN1bHRzLmFkZChtYXRjaFsxXSkgOiByZXN1bHRzO1xuICAgIH0sIG5ldyBTZXQoKSk7XG59XG4vKipcbiAqIEdldCBhIFNldCBvZiBNZWRpYVN0cmVhbVRyYWNrIElEcyBmcm9tIGFuIFNEUC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwXG4gKiBAcmV0dXJucyB7U2V0PHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldFRyYWNrSWRzKHBhdHRlcm4sIHNkcCkge1xuICAgIHJldHVybiBnZXRNYXRjaGVzKHBhdHRlcm4sIHNkcCk7XG59XG4vKipcbiAqIEdldCBhIFNldCBvZiBNZWRpYVN0cmVhbVRyYWNrIElEcyBmcm9tIGEgUGxhbiBCIFNEUC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHAgLSBQbGFuIEIgU0RQXG4gKiBAcmV0dXJucyB7U2V0PHN0cmluZz59IHRyYWNrSWRzXG4gKi9cbmZ1bmN0aW9uIGdldFBsYW5CVHJhY2tJZHMoc2RwKSB7XG4gICAgcmV0dXJuIGdldFRyYWNrSWRzKCdeYT1zc3JjOlswLTldKyArbXNpZDouKyArKC4rKSAqJCcsIHNkcCk7XG59XG4vKipcbiAqIEdldCBhIFNldCBvZiBNZWRpYVN0cmVhbVRyYWNrIElEcyBmcm9tIGEgVW5pZmllZCBQbGFuIFNEUC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHAgLSBVbmlmaWVkIFBsYW4gU0RQXG4gKiBAcmV0dXJucyB7U2V0PHN0cmluZz59IHRyYWNrSWRzXG4gKi9cbmZ1bmN0aW9uIGdldFVuaWZpZWRQbGFuVHJhY2tJZHMoc2RwKSB7XG4gICAgcmV0dXJuIGdldFRyYWNrSWRzKCdeYT1tc2lkOi4rICsoLispICokJywgc2RwKTtcbn1cbi8qKlxuICogR2V0IGEgU2V0IG9mIFNTUkNzIGZvciBhIE1lZGlhU3RyZWFtVHJhY2sgZnJvbSBhIFBsYW4gQiBTRFAuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwIC0gUGxhbiBCIFNEUFxuICogQHBhcmFtIHtzdHJpbmd9IHRyYWNrSWQgLSBNZWRpYVN0cmVhbVRyYWNrIElEXG4gKiBAcmV0dXJucyB7U2V0PHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldFBsYW5CU1NSQ3Moc2RwLCB0cmFja0lkKSB7XG4gICAgdmFyIHBhdHRlcm4gPSAnXmE9c3NyYzooWzAtOV0rKSArbXNpZDpbXiBdKyArJyArIHRyYWNrSWQgKyAnICokJztcbiAgICByZXR1cm4gZ2V0TWF0Y2hlcyhwYXR0ZXJuLCBzZHApO1xufVxuLyoqXG4gKiBHZXQgdGhlIG09IHNlY3Rpb25zIG9mIGEgcGFydGljdWxhciBraW5kIGFuZCBkaXJlY3Rpb24gZnJvbSBhbiBzZHAuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwIC0gIHNkcCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBba2luZF0gLSBQYXR0ZXJuIGZvciBtYXRjaGluZyBraW5kXG4gKiBAcGFyYW0ge3N0cmluZ30gW2RpcmVjdGlvbl0gLSBQYXR0ZXJuIGZvciBtYXRjaGluZyBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBtZWRpYVNlY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGdldE1lZGlhU2VjdGlvbnMoc2RwLCBraW5kLCBkaXJlY3Rpb24pIHtcbiAgICBraW5kID0ga2luZCB8fCAnLionO1xuICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCAnLionO1xuICAgIHJldHVybiBzZHAuc3BsaXQoJ1xcclxcbm09Jykuc2xpY2UoMSkubWFwKGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICdtPScgKyBtZWRpYVNlY3Rpb247XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgdmFyIGtpbmRQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnbT0nICsga2luZCwgJ2dtJyk7XG4gICAgICAgIHZhciBkaXJlY3Rpb25QYXR0ZXJuID0gbmV3IFJlZ0V4cCgnYT0nICsgZGlyZWN0aW9uLCAnZ20nKTtcbiAgICAgICAgcmV0dXJuIGtpbmRQYXR0ZXJuLnRlc3QobWVkaWFTZWN0aW9uKSAmJiBkaXJlY3Rpb25QYXR0ZXJuLnRlc3QobWVkaWFTZWN0aW9uKTtcbiAgICB9KTtcbn1cbi8qKlxuICogR2V0IHRoZSBTZXQgb2YgU1NSQ3MgYW5ub3VuY2VkIGluIGEgTWVkaWFTZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG1lZGlhU2VjdGlvblxuICogQHJldHVybnMge0FycmF5PHN0cmluZz59IHNzcmNzXG4gKi9cbmZ1bmN0aW9uIGdldE1lZGlhU2VjdGlvblNTUkNzKG1lZGlhU2VjdGlvbikge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGdldE1hdGNoZXMoJ15hPXNzcmM6KFswLTldKykgKy4qJCcsIG1lZGlhU2VjdGlvbikpO1xufVxuLyoqXG4gKiBHZXQgYSBTZXQgb2YgU1NSQ3MgZm9yIGEgTWVkaWFTdHJlYW1UcmFjayBmcm9tIGEgVW5pZmllZCBQbGFuIFNEUC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHAgLSBVbmlmaWVkIFBsYW4gU0RQXG4gKiBAcGFyYW0ge3N0cmluZ30gdHJhY2tJZCAtIE1lZGlhU3RyZWFtVHJhY2sgSURcbiAqIEByZXR1cm5zIHtTZXQ8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0VW5pZmllZFBsYW5TU1JDcyhzZHAsIHRyYWNrSWQpIHtcbiAgICB2YXIgbWVkaWFTZWN0aW9ucyA9IGdldE1lZGlhU2VjdGlvbnMoc2RwKTtcbiAgICB2YXIgbXNpZEF0dHJSZWdFeHAgPSBuZXcgUmVnRXhwKCdeYT1tc2lkOlteIF0rICsnICsgdHJhY2tJZCArICcgKiQnLCAnZ20nKTtcbiAgICB2YXIgbWF0Y2hpbmdNZWRpYVNlY3Rpb25zID0gbWVkaWFTZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgICByZXR1cm4gbWVkaWFTZWN0aW9uLm1hdGNoKG1zaWRBdHRyUmVnRXhwKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFNldChmbGF0TWFwKG1hdGNoaW5nTWVkaWFTZWN0aW9ucywgZ2V0TWVkaWFTZWN0aW9uU1NSQ3MpKTtcbn1cbi8qKlxuICogR2V0IGEgTWFwIGZyb20gTWVkaWFTdHJlYW1UcmFjayBJRHMgdG8gU1NSQ3MgZnJvbSBhbiBTRFAuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk6IFNldDxzdHJpbmc+fSBnZXRUcmFja0lkc1xuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIHN0cmluZyk6IFNldDxzdHJpbmc+fSBnZXRTU1JDc1xuICogQHBhcmFtIHtzdHJpbmd9IHNkcCAtIFNEUFxuICogQHJldHVybnMge01hcDxzdHJpbmcsIFNldDxzdHJpbmc+Pn0gdHJhY2tJZHNUb1NTUkNzXG4gKi9cbmZ1bmN0aW9uIGdldFRyYWNrSWRzVG9TU1JDcyhnZXRUcmFja0lkcywgZ2V0U1NSQ3MsIHNkcCkge1xuICAgIHJldHVybiBuZXcgTWFwKEFycmF5LmZyb20oZ2V0VHJhY2tJZHMoc2RwKSkubWFwKGZ1bmN0aW9uICh0cmFja0lkKSB7XG4gICAgICAgIHJldHVybiBbdHJhY2tJZCwgZ2V0U1NSQ3Moc2RwLCB0cmFja0lkKV07XG4gICAgfSkpO1xufVxuLyoqXG4gKiBHZXQgYSBNYXAgZnJvbSBNZWRpYVN0cmVhbVRyYWNrIElEcyB0byBTU1JDcyBmcm9tIGEgUGxhbiBCIFNEUC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHAgLSBQbGFuIEIgU0RQXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgU2V0PHN0cmluZz4+fSB0cmFja0lkc1RvU1NSQ3NcbiAqL1xuZnVuY3Rpb24gZ2V0UGxhbkJUcmFja0lkc1RvU1NSQ3Moc2RwKSB7XG4gICAgcmV0dXJuIGdldFRyYWNrSWRzVG9TU1JDcyhnZXRQbGFuQlRyYWNrSWRzLCBnZXRQbGFuQlNTUkNzLCBzZHApO1xufVxuLyoqXG4gKiBHZXQgYSBNYXAgZnJvbSBNZWRpYVN0cmVhbVRyYWNrIElEcyB0byBTU1JDcyBmcm9tIGEgUGxhbiBCIFNEUC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHAgLSBQbGFuIEIgU0RQXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgU2V0PHN0cmluZz4+fSB0cmFja0lkc1RvU1NSQ3NcbiAqL1xuZnVuY3Rpb24gZ2V0VW5pZmllZFBsYW5UcmFja0lkc1RvU1NSQ3Moc2RwKSB7XG4gICAgcmV0dXJuIGdldFRyYWNrSWRzVG9TU1JDcyhnZXRVbmlmaWVkUGxhblRyYWNrSWRzLCBnZXRVbmlmaWVkUGxhblNTUkNzLCBzZHApO1xufVxuLyoqXG4gKiBVcGRhdGUgdGhlIG1hcHBpbmdzIGZyb20gTWVkaWFTdHJlYW1UcmFjayBJRHMgdG8gU1NSQ3MgYXMgaW5kaWNhdGVkIGJ5IGJvdGhcbiAqIHRoZSBNYXAgZnJvbSBNZWRpYVN0cmVhbVRyYWNrIElEcyB0byBTU1JDcyBhbmQgdGhlIFNEUCBpdHNlbGYuIFRoaXMgbWV0aG9kXG4gKiBlbnN1cmVzIHRoYXQgU1NSQ3MgbmV2ZXIgY2hhbmdlIG9uY2UgYW5ub3VuY2VkLlxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpOiBNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj59IGdldFRyYWNrSWRzVG9TU1JDc1xuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj59IHRyYWNrSWRzVG9TU1JDc1xuICogQHBhcmFtIHtzdHJpbmd9IHNkcCAtIFNEUFxuICogQHJldHVybnMge3N0cmlubmd9IHVwZGF0ZWRTZHAgLSB1cGRhdGVkIFNEUFxuICovXG5mdW5jdGlvbiB1cGRhdGVUcmFja0lkc1RvU1NSQ3MoZ2V0VHJhY2tJZHNUb1NTUkNzLCB0cmFja0lkc1RvU1NSQ3MsIHNkcCkge1xuICAgIHZhciBuZXdUcmFja0lkc1RvU1NSQ3MgPSBnZXRUcmFja0lkc1RvU1NSQ3Moc2RwKTtcbiAgICB2YXIgbmV3U1NSQ3NUb09sZFNTUkNzID0gbmV3IE1hcCgpO1xuICAgIC8vIE5PVEUobXJvYmVydHMpOiBGaXJzdCwgdXBkYXRlIGE9c3NyYyBhdHRyaWJ1dGVzLlxuICAgIG5ld1RyYWNrSWRzVG9TU1JDcy5mb3JFYWNoKGZ1bmN0aW9uIChzc3JjcywgdHJhY2tJZCkge1xuICAgICAgICBpZiAoIXRyYWNrSWRzVG9TU1JDcy5oYXModHJhY2tJZCkpIHtcbiAgICAgICAgICAgIHRyYWNrSWRzVG9TU1JDcy5zZXQodHJhY2tJZCwgc3NyY3MpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRTU1JDcyA9IEFycmF5LmZyb20odHJhY2tJZHNUb1NTUkNzLmdldCh0cmFja0lkKSk7XG4gICAgICAgIHZhciBuZXdTU1JDcyA9IEFycmF5LmZyb20oc3NyY3MpO1xuICAgICAgICBvbGRTU1JDcy5mb3JFYWNoKGZ1bmN0aW9uIChvbGRTU1JDLCBpKSB7XG4gICAgICAgICAgICB2YXIgbmV3U1NSQyA9IG5ld1NTUkNzW2ldO1xuICAgICAgICAgICAgbmV3U1NSQ3NUb09sZFNTUkNzLnNldChuZXdTU1JDLCBvbGRTU1JDKTtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gJ15hPXNzcmM6JyArIG5ld1NTUkMgKyAnICguKikkJztcbiAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9ICdhPXNzcmM6JyArIG9sZFNTUkMgKyAnICQxJztcbiAgICAgICAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKG5ldyBSZWdFeHAocGF0dGVybiwgJ2dtJyksIHJlcGxhY2VtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gTk9URShtcm9iZXJ0cyk6IFRoZW4sIHVwZGF0ZSBhPXNzcmMtZ3JvdXAgYXR0cmlidXRlcy5cbiAgICB2YXIgcGF0dGVybiA9ICdeKGE9c3NyYy1ncm91cDpbXiBdKyArKSguKikkJztcbiAgICB2YXIgbWF0Y2hlcyA9IHNkcC5tYXRjaChuZXcgUmVnRXhwKHBhdHRlcm4sICdnbScpKSB8fCBbXTtcbiAgICBtYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gbGluZS5tYXRjaChuZXcgUmVnRXhwKHBhdHRlcm4pKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVmaXggPSBtYXRjaFsxXTtcbiAgICAgICAgdmFyIG5ld1NTUkNzID0gbWF0Y2hbMl07XG4gICAgICAgIHZhciBvbGRTU1JDcyA9IG5ld1NTUkNzLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChuZXdTU1JDKSB7XG4gICAgICAgICAgICB2YXIgb2xkU1NSQyA9IG5ld1NTUkNzVG9PbGRTU1JDcy5nZXQobmV3U1NSQyk7XG4gICAgICAgICAgICByZXR1cm4gb2xkU1NSQyA/IG9sZFNTUkMgOiBuZXdTU1JDO1xuICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKG1hdGNoWzBdLCBwcmVmaXggKyBvbGRTU1JDcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNkcDtcbn1cbi8qKlxuICogVXBkYXRlIHRoZSBtYXBwaW5ncyBmcm9tIE1lZGlhU3RyZWFtVHJhY2sgSURzIHRvIFNTUkNzIGFzIGluZGljYXRlZCBieSBib3RoXG4gKiB0aGUgTWFwIGZyb20gTWVkaWFTdHJlYW1UcmFjayBJRHMgdG8gU1NSQ3MgYW5kIHRoZSBQbGFuIEIgU0RQIGl0c2VsZi4gVGhpc1xuICogbWV0aG9kIGVuc3VyZXMgdGhhdCBTU1JDcyBuZXZlciBjaGFuZ2Ugb25jZSBhbm5vdW5jZWQuXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsIFNldDxzdHJpbmc+Pn0gdHJhY2tJZHNUb1NTUkNzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwIC0gUGxhbiBCIFNEUFxuICogQHJldHVybnMge3N0cmluZ30gdXBkYXRlZFNkcCAtIHVwZGF0ZWQgUGxhbiBCIFNEUFxuICovXG5mdW5jdGlvbiB1cGRhdGVQbGFuQlRyYWNrSWRzVG9TU1JDcyh0cmFja0lkc1RvU1NSQ3MsIHNkcCkge1xuICAgIHJldHVybiB1cGRhdGVUcmFja0lkc1RvU1NSQ3MoZ2V0UGxhbkJUcmFja0lkc1RvU1NSQ3MsIHRyYWNrSWRzVG9TU1JDcywgc2RwKTtcbn1cbi8qKlxuICogVXBkYXRlIHRoZSBtYXBwaW5ncyBmcm9tIE1lZGlhU3RyZWFtVHJhY2sgSURzIHRvIFNTUkNzIGFzIGluZGljYXRlZCBieSBib3RoXG4gKiB0aGUgTWFwIGZyb20gTWVkaWFTdHJlYW1UcmFjayBJRHMgdG8gU1NSQ3MgYW5kIHRoZSBQbGFuIEIgU0RQIGl0c2VsZi4gVGhpc1xuICogbWV0aG9kIGVuc3VyZXMgdGhhdCBTU1JDcyBuZXZlciBjaGFuZ2Ugb25jZSBhbm5vdW5jZWQuXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsIFNldDxzdHJpbmc+Pn0gdHJhY2tJZHNUb1NTUkNzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwIC0gUGxhbiBCIFNEUFxuICogQHJldHVybnMge3N0cmluZ30gdXBkYXRlZFNkcCAtIHVwZGF0ZWQgUGxhbiBCIFNEUFxuICovXG5mdW5jdGlvbiB1cGRhdGVVbmlmaWVkUGxhblRyYWNrSWRzVG9TU1JDcyh0cmFja0lkc1RvU1NSQ3MsIHNkcCkge1xuICAgIHJldHVybiB1cGRhdGVUcmFja0lkc1RvU1NSQ3MoZ2V0VW5pZmllZFBsYW5UcmFja0lkc1RvU1NSQ3MsIHRyYWNrSWRzVG9TU1JDcywgc2RwKTtcbn1cbmV4cG9ydHMuZ2V0U2RwRm9ybWF0ID0gZ2V0U2RwRm9ybWF0O1xuZXhwb3J0cy5nZXRNZWRpYVNlY3Rpb25zID0gZ2V0TWVkaWFTZWN0aW9ucztcbmV4cG9ydHMuZ2V0UGxhbkJUcmFja0lkcyA9IGdldFBsYW5CVHJhY2tJZHM7XG5leHBvcnRzLmdldFVuaWZpZWRQbGFuVHJhY2tJZHMgPSBnZXRVbmlmaWVkUGxhblRyYWNrSWRzO1xuZXhwb3J0cy5nZXRQbGFuQlNTUkNzID0gZ2V0UGxhbkJTU1JDcztcbmV4cG9ydHMuZ2V0VW5pZmllZFBsYW5TU1JDcyA9IGdldFVuaWZpZWRQbGFuU1NSQ3M7XG5leHBvcnRzLnVwZGF0ZVBsYW5CVHJhY2tJZHNUb1NTUkNzID0gdXBkYXRlUGxhbkJUcmFja0lkc1RvU1NSQ3M7XG5leHBvcnRzLnVwZGF0ZVVuaWZpZWRQbGFuVHJhY2tJZHNUb1NTUkNzID0gdXBkYXRlVW5pZmllZFBsYW5UcmFja0lkc1RvU1NSQ3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZHAuanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLCBudWxsLCByZXQpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQsIHJlaiwgY2IpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbE1vZHVsZSkge1xuXHRpZiAoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdHZhciBtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsTW9kdWxlKTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJleHBvcnRzXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hdG9taWMtdXBkYXRlcyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuLyogZXNsaW50LWRpc2FibGUgcXVvdGVzICovXG4ndXNlIHN0cmljdCc7XG5jb25zb2xlLmxvZygnbG9hZGVkIHRva2Vucy5qcycpO1xuaW1wb3J0IHsgY3JlYXRlQnV0dG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL2J1dHRvbic7XG5pbXBvcnQgeyBjcmVhdGVEaXYgfSBmcm9tICcuL2NvbXBvbmVudHMvY3JlYXRlRGl2Jztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb3J0LWltcG9ydHNcbmltcG9ydCB7IGNyZWF0ZUxvZywgbG9nIH0gZnJvbSAnLi9jb21wb25lbnRzL2xvZyc7XG5pbXBvcnQgeyBjcmVhdGVMYWJlbGVkSW5wdXQgfSBmcm9tICcuL2NvbXBvbmVudHMvY3JlYXRlTGFiZWxlZElucHV0JztcbmltcG9ydCB7IGNyZWF0ZUxpbmsgfSBmcm9tICcuL2NvbXBvbmVudHMvY3JlYXRlTGluayc7XG5pbXBvcnQgeyBjcmVhdGVTZWxlY3Rpb24gfSBmcm9tICcuL2NvbXBvbmVudHMvY3JlYXRlU2VsZWN0aW9uJztcbmltcG9ydCBWaWRlbyBmcm9tICd0d2lsaW8tdmlkZW8nO1xuZGVtbyhWaWRlbywgZG9jdW1lbnQuYm9keSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZW1vKFZpZGVvOiB0eXBlb2YgaW1wb3J0KCd0d2lsaW8tdmlkZW8nKSwgY29udGFpbmVyRGl2OiBIVE1MRWxlbWVudCkge1xuICAvLyBjcmVhdGUgaHRtbFxuICBjb25zdCBjb250YWluZXIgPSBjcmVhdGVEaXYoY29udGFpbmVyRGl2LCAnZm9vJywgJ2ZvbycpO1xuICBjcmVhdGVMb2coY29udGFpbmVyRGl2KTtcblxuICBjcmVhdGVMaW5rKHsgY29udGFpbmVyLCBsaW5rVGV4dDogJ2hleSEnLCBsaW5rVXJsOiAnaHR0cHM6Ly93d3cudHdpbGlvLmNvbScgfSk7XG4gIGNvbnN0IHJvb21OYW1lSW5wdXQgPSAgY3JlYXRlTGFiZWxlZElucHV0KHsgY29udGFpbmVyLCBsYWJlbFRleHQ6ICdyb29tTmFtZScsIHBsYWNlSG9sZGVyOiAncm9vbU5hbWUnLCBpbml0aWFsVmFsdWU6IFwicm9vbU5hbWVcIiB9KTtcbiAgLy8gY29uc3QgYWNjb3VudFNpZCA9ICBjcmVhdGVMYWJlbGVkSW5wdXQoeyBjb250YWluZXIsIGxhYmVsVGV4dDogJ2FjY291bnRTaWQnLCBwbGFjZUhvbGRlcjogJ0FDeHh4eCcsIGluaXRpYWxWYWx1ZTogXCJBQ3h4eFwiIH0pO1xuICBjb25zdCBhcGlLZXlTaWQgPSAgY3JlYXRlTGFiZWxlZElucHV0KHsgY29udGFpbmVyLCBsYWJlbFRleHQ6ICdhcGlLZXlTaWQnLCBwbGFjZUhvbGRlcjogJ1NLeHh4JywgaW5pdGlhbFZhbHVlOiBcIlNLeHh4XCIgfSk7XG4gIGNvbnN0IGFwaUtleVNlY3JldCA9ICBjcmVhdGVMYWJlbGVkSW5wdXQoeyBjb250YWluZXIsIGxhYmVsVGV4dDogJ2FwaUtleVNlY3JldCcsIHBsYWNlSG9sZGVyOiAneHh4eCcsIGluaXRpYWxWYWx1ZTogXCJ4eHh4XCIgfSk7XG4gIGNvbnN0IGVudlNlbGVjdCA9IGNyZWF0ZVNlbGVjdGlvbih7XG4gICAgY29udGFpbmVyLFxuICAgIC8vIGlkOiAnZW52JyxcbiAgICBvcHRpb25zOiBbJ2RldicsICdzdGFnZScsICdwcm9kJ10sXG4gICAgdGl0bGU6ICdlbnYnLFxuICAgIG9uQ2hhbmdlOiAoKSA9PiBsb2coJ2VudiBjaGFuZ2U6JywgZW52U2VsZWN0LmdldFZhbHVlKCkpXG4gIH0pO1xuICBjb25zdCB0b3BvbG9neVNlbGVjdCA9IGNyZWF0ZVNlbGVjdGlvbih7XG4gICAgY29udGFpbmVyLFxuICAgIC8vIGlkOiAndG9wb2xvZ3knLFxuICAgIG9wdGlvbnM6IFsnZ3JvdXAtc21hbGwnLCAncGVlci10by1wZWVyJywgJ2dyb3VwJywgJ2dvJ10sXG4gICAgdGl0bGU6ICd0b3BvbG9neScsXG4gICAgb25DaGFuZ2U6ICgpID0+IGxvZygndG9wb2xvZ3kgY2hhbmdlOicsIHRvcG9sb2d5U2VsZWN0LmdldFZhbHVlKCkpXG4gIH0pO1xuXG5cbiAgY3JlYXRlQnV0dG9uKCdjcmVhdGVSb29tJywgY29udGFpbmVyLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgSE9TVF9OQU1FX1JFU1QgPSBlbnZTZWxlY3QuZ2V0VmFsdWUoKSA9PT0gJ3Byb2QnID8gJ3ZpZGVvLnR3aWxpby5jb20nIDogYHZpZGVvLiR7ZW52U2VsZWN0LmdldFZhbHVlKCl9LnR3aWxpby5jb21gO1xuICAgIGNvbnN0IEhPU1RfVVJMX1JFU1QgPSAnaHR0cHM6Ly8nICsgSE9TVF9OQU1FX1JFU1Q7XG4gICAgLy9cbiAgICAvLyBOT1RFOiBmZXRjaCByZXF1ZXN0IGJlbG93IHJlcXVpcmVzIHRoYXQgY2hyb21lIGJlIG9wZW5lZCB3aXRoIGAtLWRpc2FibGUtd2ViLXNlY3VyaXR5YCBsaWtlOlxuICAgIC8vIG9wZW4gLW5hIC9BcHBsaWNhdGlvbnMvR29vZ2xlXFwgQ2hyb21lLmFwcCAtLWFyZ3MgLS11c2VyLWRhdGEtZGlyPVwiL3Zhci90bXAvQ2hyb21lIGRldiBzZXNzaW9uXCIgLS1kaXNhYmxlLXdlYi1zZWN1cml0eVxuICAgIC8vXG4gICAgdmFyIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBUeXBlOiB0b3BvbG9neVNlbGVjdC5nZXRWYWx1ZSgpLCBVbmlxdWVOYW1lOiByb29tTmFtZUlucHV0LnZhbHVlIH0pO1xuICAgIGNvbnN0IHJvb21SZXN1bHQgPSBhd2FpdCBmZXRjaChgJHtIT1NUX1VSTF9SRVNUfS92MS9Sb29tc2AsIHtcbiAgICAgIFwiaGVhZGVyc1wiOiB7XG4gICAgICAgIFwiYXV0aG9yaXphdGlvblwiOiAnQmFzaWMgJyArIGJ0b2EoYXBpS2V5U2lkLnZhbHVlICsgXCI6XCIgKyBhcGlLZXlTZWNyZXQudmFsdWUpLFxuICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgICAgICBcInNlYy1mZXRjaC1kZXN0XCI6IFwiZW1wdHlcIixcbiAgICAgICAgXCJzZWMtZmV0Y2gtbW9kZVwiOiBcImNvcnNcIixcbiAgICAgICAgXCJzZWMtZmV0Y2gtc2l0ZVwiOiBcImNyb3NzLXNpdGVcIlxuICAgICAgfSxcbiAgICAgIFwiYm9keVwiOiBzZWFyY2hQYXJhbXMsXG4gICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgIFwibW9kZVwiOiBcImNvcnNcIixcbiAgICAgIFwiY3JlZGVudGlhbHNcIjogXCJpbmNsdWRlXCJcbiAgICB9KTtcblxuICAgIGlmIChyb29tUmVzdWx0Lm9rKSB7XG4gICAgICBjb25zdCBqc29uID0gYXdhaXQgcm9vbVJlc3VsdC5qc29uKCk7XG4gICAgICBpZiAoanNvbi5zdGF0dXMgPT09ICdpbi1wcm9ncmVzcycpIHtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICB9XG4gICAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGNyZWF0ZSByb29tOiAnLCByb29tUmVzdWx0KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBjcmVhdGUgJHt0b3BvbG9neVNlbGVjdC5nZXRWYWx1ZSgpfSBSb29tOiAke3Jvb21OYW1lSW5wdXQudmFsdWV9YCk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGludGVyZmFjZSBJQnV0dG9uIHtcbiAgYnRuOiBIVE1MQnV0dG9uRWxlbWVudCxcbiAgc2hvdzogKHZpc2libGU6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHRleHQ6IChuZXdUZXh0OiBzdHJpbmcpID0+IHZvaWQ7XG4gIGNsaWNrOiAoKSA9PiB2b2lkO1xuICBlbmFibGU6ICgpID0+IHZvaWQ7XG4gIGRpc2FibGU6ICgpID0+IHZvaWQ7XG59O1xuXG5pbXBvcnQganNzIGZyb20gJy4uL2pzcydcblxuLy8gQ3JlYXRlIHlvdXIgc3R5bGUuXG5jb25zdCBzdHlsZSA9IHtcbiAgYnV0dG9uOiB7XG4gICAgaGVpZ2h0OiAnMmVtJyxcbiAgICBtYXJnaW46ICcycHgnLFxuICB9LFxufVxuLy8gQ29tcGlsZSBzdHlsZXMsIGFwcGx5IHBsdWdpbnMuXG5jb25zdCBzaGVldCA9IGpzcy5jcmVhdGVTdHlsZVNoZWV0KHN0eWxlKVxuc2hlZXQuYXR0YWNoKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCdXR0b24odGV4dDogc3RyaW5nLCBjb250YWluZXI6IEhUTUxFbGVtZW50LCBvbkNsaWNrOiAoKSA9PiB2b2lkKTogSUJ1dHRvbiB7XG4gIGNvbnN0IGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICBidG4uY2xhc3NMaXN0LmFkZChzaGVldC5jbGFzc2VzLmJ1dHRvbik7XG4gIGJ0bi5pbm5lckhUTUwgPSB0ZXh0O1xuICBidG4ub25jbGljayA9IG9uQ2xpY2s7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChidG4pO1xuICByZXR1cm4ge1xuICAgIGJ0bixcbiAgICBzaG93OiAodmlzaWJsZTogYm9vbGVhbikgPT4geyBidG4uc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnaW5saW5lLWJsb2NrJyA6ICdub25lJzsgfSxcbiAgICB0ZXh0OiAobmV3VGV4dDogc3RyaW5nKSA9PiB7IGJ0bi5pbm5lckhUTUwgPSBuZXdUZXh0OyB9LFxuICAgIGNsaWNrOiAoKSA9PiBvbkNsaWNrKCksXG4gICAgZW5hYmxlOiAoKSA9PiB7IGJ0bi5kaXNhYmxlZCA9IGZhbHNlOyB9LFxuICAgIGRpc2FibGU6ICgpID0+IHsgYnRuLmRpc2FibGVkID0gdHJ1ZTsgfVxuICB9O1xufVxuXG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi9jcmVhdGVFbGVtZW50JztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURpdihjb250YWluZXI6IEhUTUxFbGVtZW50LCBkaXZDbGFzczogc3RyaW5nW10gfCBzdHJpbmcsIGlkPzogc3RyaW5nKTogSFRNTERpdkVsZW1lbnQge1xuICBkaXZDbGFzcyA9IEFycmF5LmlzQXJyYXkoZGl2Q2xhc3MpID8gZGl2Q2xhc3MgOiBbZGl2Q2xhc3NdO1xuICByZXR1cm4gY3JlYXRlRWxlbWVudCh7IGNvbnRhaW5lciwgdHlwZTogJ2RpdicsIGNsYXNzTmFtZXM6IGRpdkNsYXNzLCBpZCB9KSBhcyBIVE1MRGl2RWxlbWVudDtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHsgY29udGFpbmVyLCB0eXBlLCBpZCwgY2xhc3NOYW1lcywgc3R5bGUsIGlubmVySHRtbCB9OiB7XG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gIHR5cGU6IHN0cmluZyxcbiAgaWQ/OiBzdHJpbmdcbiAgY2xhc3NOYW1lcz86IHN0cmluZ1tdLFxuICBzdHlsZT86IHN0cmluZyxcbiAgaW5uZXJIdG1sPzogc3RyaW5nLFxufSk6IEhUTUxFbGVtZW50IHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICBpZiAoaWQpIHtcbiAgICBlbC5pZCA9IGlkO1xuICB9XG4gIGlmIChjbGFzc05hbWVzKSB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgfVxuXG4gIGlmIChzdHlsZSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZSk7XG4gIH1cblxuICBpZiAoaW5uZXJIdG1sKSB7XG4gICAgZWwuaW5uZXJIVE1MID0gaW5uZXJIdG1sO1xuICB9XG5cbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcbiAgcmV0dXJuIGVsO1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4vY3JlYXRlRWxlbWVudCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMYWJlbGVkSW5wdXQoeyBjb250YWluZXIsIGxhYmVsVGV4dCwgcGxhY2VIb2xkZXIsIGluaXRpYWxWYWx1ZSwgbGFiZWxDbGFzc2VzID0gW10sIGlucHV0VHlwZSA9ICdpbnB1dCcsIGlucHV0Q2xhc3NlcyA9IFtdLCBsYWJlbFBhcmVudCA9IGZhbHNlIH06IHtcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgbGFiZWxUZXh0OiBzdHJpbmcgfCBIVE1MRWxlbWVudCxcbiAgcGxhY2VIb2xkZXI6IHN0cmluZyxcbiAgaW5pdGlhbFZhbHVlPzogc3RyaW5nLFxuICBsYWJlbENsYXNzZXM/OiBzdHJpbmdbXSxcbiAgaW5wdXRUeXBlPzogc3RyaW5nLFxuICBpbnB1dENsYXNzZXM/OnN0cmluZ1tdLFxuICBsYWJlbFBhcmVudD86IGJvb2xlYW5cbn0pIDogSFRNTElucHV0RWxlbWVudCB7XG4gIGxldCBpZGVudGl0eUxhYmVsID0gbnVsbDtcbiAgaWYgKHR5cGVvZiBsYWJlbFRleHQgPT09ICdzdHJpbmcnKSAge1xuICAgIGlkZW50aXR5TGFiZWwgPSBjcmVhdGVFbGVtZW50KHsgY29udGFpbmVyLCB0eXBlOiAnbGFiZWwnLCBjbGFzc05hbWVzOiBsYWJlbENsYXNzZXMsIGlubmVySHRtbDogbGFiZWxUZXh0IH0pO1xuICB9IGVsc2Uge1xuICAgIGlkZW50aXR5TGFiZWwgPSBsYWJlbFRleHQ7XG4gIH1cbiAgY29uc3QgaW5wdXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudCh7IGNvbnRhaW5lcjogbGFiZWxQYXJlbnQgPyBpZGVudGl0eUxhYmVsIDogY29udGFpbmVyLCB0eXBlOiBpbnB1dFR5cGUsIGNsYXNzTmFtZXM6IGlucHV0Q2xhc3NlcyB9KSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICBpbnB1dEVsZW1lbnQucGxhY2Vob2xkZXIgPSBwbGFjZUhvbGRlcjtcbiAgaWYgKGluaXRpYWxWYWx1ZSkge1xuICAgIGlucHV0RWxlbWVudC52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dEVsZW1lbnQ7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi9jcmVhdGVFbGVtZW50JztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxpbmsoeyBjb250YWluZXIsIGxpbmtUZXh0LCBsaW5rVXJsLCBuZXdUYWIgPSBmYWxzZSB9IDoge1xuICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICBsaW5rVGV4dDogc3RyaW5nLFxuICBsaW5rVXJsOiBzdHJpbmcsXG4gIG5ld1RhYj8gOiBib29sZWFuXG59KSA6IEhUTUxBbmNob3JFbGVtZW50IHtcbiAgdmFyIGEgPSBjcmVhdGVFbGVtZW50KHsgY29udGFpbmVyLCB0eXBlOiAnYScgfSkgYXMgSFRNTEFuY2hvckVsZW1lbnQ7XG4gIGEuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGlua1RleHQpKTtcbiAgYS50aXRsZSA9IGxpbmtUZXh0O1xuICBhLmhyZWYgPSBsaW5rVXJsO1xuICBpZiAobmV3VGFiKSB7XG4gICAgYS50YXJnZXQgPSAnX2JsYW5rJztcbiAgfVxuICByZXR1cm4gYTtcbn1cbiIsIlxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGlvbih7IGlkLCBjb250YWluZXIsIG9wdGlvbnMgPSBbJ2RvZycsICdjYXQnLCAncGFycm90JywgJ3JhYmJpdCddLCB0aXRsZSA9ICdQZXRzJywgc2VsZWN0Q2xhc3NlcyA9IFtdLCBsYWJlbENsYXNzZXMgPSBbXSwgb25DaGFuZ2UgPSAoKSA9PiB7IH0gfToge1xuICBpZD86IHN0cmluZyxcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgb3B0aW9uczogc3RyaW5nW10sXG4gIHRpdGxlOiBzdHJpbmcsXG4gIGxhYmVsQ2xhc3Nlcz86IHN0cmluZ1tdLFxuICBzZWxlY3RDbGFzc2VzPzogc3RyaW5nW10sXG4gIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xufSkge1xuICBjb25zdCBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgaWYgKGlkKSB7XG4gICAgc2VsZWN0LmlkID0gaWQ7XG4gIH1cblxuICBzZWxlY3QuY2xhc3NMaXN0LmFkZCguLi5zZWxlY3RDbGFzc2VzKTtcblxuICBmb3IgKGNvbnN0IHZhbCBvZiBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgb3B0aW9uLnZhbHVlID0gdmFsO1xuICAgIG9wdGlvbi50ZXh0ID0gdmFsO1xuICAgIHNlbGVjdC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICB9XG5cbiAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICBsYWJlbC5pbm5lckhUTUwgPSB0aXRsZTtcbiAgbGFiZWwuaHRtbEZvciA9IHNlbGVjdC5pZDtcbiAgbGFiZWwuY2xhc3NMaXN0LmFkZCguLi5sYWJlbENsYXNzZXMpO1xuXG4gIHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG5cbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKS5hcHBlbmRDaGlsZChzZWxlY3QpO1xuICByZXR1cm4ge1xuICAgIHNlbGVjdCxcbiAgICBnZXRWYWx1ZTogKCkgPT4geyByZXR1cm4gc2VsZWN0LnZhbHVlOyB9LFxuICAgIHNldFZhbHVlOiAodmFsdWU6IHN0cmluZykgPT4geyBzZWxlY3QudmFsdWUgPSB2YWx1ZTsgLyogbm90IGlmIHRoZSB2YWx1ZSBpcyBub3Qgb25lIG9mIHRoZSBvcHRpb25zIHRoZW4gYSBibGFuayB2YWx1ZSBnZXRzIHNlbGVjdGVkICovIH1cbiAgfTtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbmltcG9ydCB7IGNyZWF0ZUJ1dHRvbiB9IGZyb20gJy4vYnV0dG9uJztcblxuaW1wb3J0IGpzcyBmcm9tICcuLi9qc3MnXG5cbi8vIENyZWF0ZSB5b3VyIHN0eWxlLlxuY29uc3Qgc3R5bGUgPSB7XG4gIGxvZ0Rpdjoge1xuICAgIGhlaWdodDogJzE1ZW0nLFxuICAgIHBhZGRpbmc6ICcxLjVlbScsXG4gICAgJ21pbi1oZWlnaHQnOiAnMTAwJScsXG4gICAgJ21heC1oZWlnaHQnOiAnMTAwJScsXG4gICAgJ21hcmdpbi10b3AnOiAnMy4xMjVlbScsXG4gICAgJ3RleHQtYWxpZ24nOiAnbGVmdCcsXG4gICAgJ292ZXJmbG93LXknOiAnc2Nyb2xsJyxcbiAgfSxcbiAgbG9nUDoge1xuICAgIGNvbG9yOiAnIzY4Njg2NScsXG4gICAgd2lkdGg6ICc5MCUnLFxuICAgICdmb250LWZhbWlseSc6ICdcXCdTaGFyZSBUZWNoIE1vbm9cXCcsIFxcJ0NvdXJpZXIgTmV3XFwnLCBDb3VyaWVyLCBmaXhlZC13aWR0aCcsXG4gICAgJ2ZvbnQtc2l6ZSc6ICcxLjI1ZW0nLFxuICAgICdsaW5lLWhlaWdodCc6ICcxLjI1ZW0nLFxuICAgICdtYXJnaW4tbGVmdCc6ICcxZW0nLFxuICAgICd0ZXh0LWluZGVudCc6ICctMS4yNWVtJyxcblxuICAgIH1cbn1cbi8vIENvbXBpbGUgc3R5bGVzLCBhcHBseSBwbHVnaW5zLlxuY29uc3Qgc2hlZXQgPSBqc3MuY3JlYXRlU3R5bGVTaGVldChzdHlsZSlcbnNoZWV0LmF0dGFjaCgpO1xuXG5sZXQgbG9nQ2xlYXJCdG46IHsgYnRuOiBIVE1MQnV0dG9uRWxlbWVudDsgc2hvdzogKHZpc2libGU6IGJvb2xlYW4pID0+IHZvaWQ7IHRleHQ6IChuZXdUZXh0OiBzdHJpbmcpID0+IHZvaWQ7IGNsaWNrOiAoKSA9PiB2b2lkOyBlbmFibGU6ICgpID0+IHZvaWQ7IGRpc2FibGU6ICgpID0+IHZvaWQ7IH07XG5sZXQgcmVhbExvZ0RpdjogSFRNTERpdkVsZW1lbnQ7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTG9nKGxvZ0Rpdj8gOiBIVE1MRWxlbWVudCkge1xuICBpZiAoIWxvZ0NsZWFyQnRuKSB7XG4gICAgaWYgKCFsb2dEaXYpIHtcbiAgICAgIGxvZ0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbG9nRGl2LmNsYXNzTGlzdC5hZGQoc2hlZXQuY2xhc3Nlcy5sb2dEaXYpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsb2dEaXYpO1xuICAgIH1cbiAgICBsb2dDbGVhckJ0biA9IGNyZWF0ZUJ1dHRvbignY2xlYXIgbG9nJywgbG9nRGl2LCAoKSA9PiB7XG4gICAgICByZWFsTG9nRGl2LmlubmVySFRNTCA9ICcnO1xuICAgIH0pO1xuXG4gICAgcmVhbExvZ0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxvZ0Rpdi5hcHBlbmRDaGlsZChyZWFsTG9nRGl2KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nKC4uLmFyZ3M6IGFueVtdKSB7XG4gIGNyZWF0ZUxvZygpO1xuICBjb25zdCBtZXNzYWdlID0gYXJncy5tYXAoYXJnID0+IFN0cmluZyhhcmcpKS5qb2luKCcsICcpO1xuICByZWFsTG9nRGl2LmlubmVySFRNTCArPSAnPHA+JyArIG1lc3NhZ2UgICsgJzwvcD4nO1xuICByZWFsTG9nRGl2LnNjcm9sbFRvcCA9IHJlYWxMb2dEaXYuc2Nyb2xsSGVpZ2h0O1xuICBjb25zb2xlLmxvZyguLi5hcmdzKTtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hdG9taWMtdXBkYXRlcyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuLyogZXNsaW50LWRpc2FibGUgcXVvdGVzICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQganNzIGZyb20gJ2pzcyc7XG5pbXBvcnQgcHJlc2V0IGZyb20gJ2pzcy1wcmVzZXQtZGVmYXVsdCc7XG5cbmpzcy5zZXR1cChwcmVzZXQoKSk7XG5leHBvcnQgZGVmYXVsdCBqc3M7XG5cbiJdLCJzb3VyY2VSb290IjoiIn0=