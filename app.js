/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../work/twilio-video.js/es5/cancelableroompromise.js":
/*!****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/cancelableroompromise.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var CancelablePromise = __webpack_require__(/*! ./util/cancelablepromise */ "../../work/twilio-video.js/es5/util/cancelablepromise.js");
/**
 * Create a {@link CancelablePromise<Room>}.
 * @param {function(function(Array<LocalTrack>): CancelablePromise<RoomSignaling>):
 *   Promise<function(): CancelablePromise<RoomSignaling>>} getLocalTracks
 * @param {function(Array<LocalTrack>): LocalParticipant} createLocalParticipant
 * @param {function(Array<LocalTrack>): CancelablePromise<RoomSignaling>} createRoomSignaling
 * @param {function(LocalParticipant, RoomSignaling): Room} createRoom
 * @returns CancelablePromise<Room>
 */
function createCancelableRoomPromise(getLocalTracks, createLocalParticipant, createRoomSignaling, createRoom) {
    var cancelableRoomSignalingPromise;
    var cancellationError = new Error('Canceled');
    return new CancelablePromise(function onCreate(resolve, reject, isCanceled) {
        var localParticipant;
        getLocalTracks(function getLocalTracksSucceeded(localTracks) {
            if (isCanceled()) {
                return CancelablePromise.reject(cancellationError);
            }
            localParticipant = createLocalParticipant(localTracks);
            return createRoomSignaling(localParticipant).then(function createRoomSignalingSucceeded(getCancelableRoomSignalingPromise) {
                if (isCanceled()) {
                    throw cancellationError;
                }
                cancelableRoomSignalingPromise = getCancelableRoomSignalingPromise();
                return cancelableRoomSignalingPromise;
            });
        }).then(function roomSignalingConnected(roomSignaling) {
            if (isCanceled()) {
                roomSignaling.disconnect();
                throw cancellationError;
            }
            resolve(createRoom(localParticipant, roomSignaling));
        }).catch(function onError(error) {
            reject(error);
        });
    }, function onCancel() {
        if (cancelableRoomSignalingPromise) {
            cancelableRoomSignalingPromise.cancel();
        }
    });
}
module.exports = createCancelableRoomPromise;
//# sourceMappingURL=cancelableroompromise.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/connect.js":
/*!**************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/connect.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var MediaStreamTrack = __webpack_require__(/*! @twilio/webrtc */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/index.js").MediaStreamTrack;
var _a = __webpack_require__(/*! @twilio/webrtc/lib/util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js"), guessBrowser = _a.guessBrowser, guessBrowserVersion = _a.guessBrowserVersion;
var createCancelableRoomPromise = __webpack_require__(/*! ./cancelableroompromise */ "../../work/twilio-video.js/es5/cancelableroompromise.js");
var createLocalTracks = __webpack_require__(/*! ./createlocaltracks */ "../../work/twilio-video.js/es5/createlocaltracks.js");
var EncodingParametersImpl = __webpack_require__(/*! ./encodingparameters */ "../../work/twilio-video.js/es5/encodingparameters.js");
var LocalParticipant = __webpack_require__(/*! ./localparticipant */ "../../work/twilio-video.js/es5/localparticipant.js");
var _b = __webpack_require__(/*! ./media/track/es5 */ "../../work/twilio-video.js/es5/media/track/es5/index.js"), LocalAudioTrack = _b.LocalAudioTrack, LocalDataTrack = _b.LocalDataTrack, LocalVideoTrack = _b.LocalVideoTrack;
var NetworkQualityConfigurationImpl = __webpack_require__(/*! ./networkqualityconfiguration */ "../../work/twilio-video.js/es5/networkqualityconfiguration.js");
var Room = __webpack_require__(/*! ./room */ "../../work/twilio-video.js/es5/room.js");
var SignalingV2 = __webpack_require__(/*! ./signaling/v2 */ "../../work/twilio-video.js/es5/signaling/v2/index.js");
var _c = __webpack_require__(/*! ./util */ "../../work/twilio-video.js/es5/util/index.js"), asLocalTrack = _c.asLocalTrack, buildLogLevels = _c.buildLogLevels, filterObject = _c.filterObject, isNonArrayObject = _c.isNonArrayObject;
var _d = __webpack_require__(/*! ./util/constants */ "../../work/twilio-video.js/es5/util/constants.js"), DEFAULT_ENVIRONMENT = _d.DEFAULT_ENVIRONMENT, DEFAULT_LOG_LEVEL = _d.DEFAULT_LOG_LEVEL, DEFAULT_LOGGER_NAME = _d.DEFAULT_LOGGER_NAME, DEFAULT_REALM = _d.DEFAULT_REALM, DEFAULT_REGION = _d.DEFAULT_REGION, WS_SERVER = _d.WS_SERVER, E = _d.typeErrors;
var CancelablePromise = __webpack_require__(/*! ./util/cancelablepromise */ "../../work/twilio-video.js/es5/util/cancelablepromise.js");
var EventObserver = __webpack_require__(/*! ./util/eventobserver */ "../../work/twilio-video.js/es5/util/eventobserver.js");
var DefaultLog = __webpack_require__(/*! ./util/log */ "../../work/twilio-video.js/es5/util/log.js");
var validateBandwidthProfile = __webpack_require__(/*! ./util/validate */ "../../work/twilio-video.js/es5/util/validate.js").validateBandwidthProfile;
var safariVersion = guessBrowser() === 'safari' && guessBrowserVersion();
// This is used to make out which connect() call a particular Log statement
// belongs to. Each call to connect() increments this counter.
var connectCalls = 0;
var didPrintSafariWarning = false;
var isSafariWithoutVP8Support = false;
if (safariVersion) {
    var safariMajorVersion = safariVersion.major, safariMinorVersion = safariVersion.minor;
    isSafariWithoutVP8Support = safariMajorVersion < 12 || (safariMajorVersion === 12 && safariMinorVersion < 1);
}
var deprecatedConnectOptionsProps = new Set([
    { didWarn: false, shouldDelete: true, name: 'abortOnIceServersTimeout' },
    { didWarn: false, shouldDelete: true, name: 'dscpTagging', newName: 'enableDscp' },
    { didWarn: false, shouldDelete: true, name: 'iceServersTimeout' },
    { didWarn: false, shouldDelete: false, name: 'eventListener', newName: 'Video.Logger' },
    { didWarn: false, shouldDelete: false, name: 'logLevel', newName: 'Video.Logger' },
]);
var deprecatedBandwidthProfileOptions = new Set([
    { didWarn: false, shouldDelete: false, name: 'maxTracks', newName: 'bandwidthProfile.video.clientTrackSwitchOffControl' },
    { didWarn: false, shouldDelete: false, name: 'renderDimensions', newName: 'bandwidthProfile.video.contentPreferencesMode' },
]);
/**
 * Connect to a {@link Room}.
 *   <br><br>
 *   By default, this will automatically acquire an array containing a
 *   {@link LocalAudioTrack} and {@link LocalVideoTrack} before connecting to
 *   the {@link Room}. These will be stopped when you disconnect from the
 *   {@link Room}.
 *   <br><br>
 *   You can override the default behavior by specifying
 *   <code>options</code>. For example, rather than acquiring a
 *   {@link LocalAudioTrack} and {@link LocalVideoTrack} automatically, you can
 *   pass your own array which you can stop yourself. See {@link ConnectOptions}
 *   for more information.
 * @alias module:twilio-video.connect
 * @param {string} token - The Access Token string
 * @param {ConnectOptions} [options] - Options to override the default behavior, invalid options are ignored.
 * @returns {CancelablePromise<Room>}
 * @throws {RangeError}
 * @throws {TwilioError}
 * @throws {TypeError}
 * @example
 * var Video = require('twilio-video');
 * var token = getAccessToken();
 * Video.connect(token, {
 *   name: 'my-cool-room'
 * }).then(function(room) {
 *   room.on('participantConnected', function(participant) {
 *     console.log(participant.identity + ' has connected');
 *   });

 *   room.once('disconnected', function() {
 *     console.log('You left the Room:', room.name);
 *   });
 * }).catch(error => {
 *   console.log('Could not connect to the Room:', error.message);
 * });
 * @example
 * var Video = require('twilio-video');
 * var token = getAccessToken();
 *
 * // Connect with audio-only
 * Video.connect(token, {
 *   name: 'my-cool-room',
 *   audio: true
 * }).then(function(room) {
 *   room.on('participantConnected', function(participant) {
 *     console.log(participant.identity + ' has connected');
 *   });
 *
 *   room.once('disconnected', function() {
 *     console.log('You left the Room:', room.name);
 *   });
 * }).catch(error => {
 *   console.log('Could not connect to the Room:', error.message);
 * });
 * @example
 * var Video = require('twilio-video');
 * var token = getAccessToken();
 *
 * // Connect with media acquired using getUserMedia()
 * navigator.mediaDevices.getUserMedia({
 *   audio: true,
 *   video: true
 * }).then(function(mediaStream) {
 *   return Video.connect(token, {
 *     name: 'my-cool-room',
 *     tracks: mediaStream.getTracks()
 *   });
 * }).then(function(room) {
 *   room.on('participantConnected', function(participant) {
 *     console.log(participant.identity + ' has connected');
 *   });
 *
 *   room.once('disconnected', function() {
 *     console.log('You left the Room:', room.name);
 *   });
 * }).catch(error => {
 *   console.log('Could not connect to the Room:', error.message);
 * });
 * @example
 * var Video = require('twilio-video');
 * var token = getAccessToken();
 *
 * // Connect with custom names for LocalAudioTrack and LocalVideoTrack
 * Video.connect(token, {
 *   name: 'my-cool-room'
 *   audio: { name: 'microphone' },
 *   video: { name: 'camera' }
 * }).then(function(room) {
 *   room.localParticipants.trackPublications.forEach(function(publication) {
 *     console.log('The LocalTrack "' + publication.trackName + '" was successfully published');
 *   });
 * }).catch(error => {
 *   console.log('Could not connect to the Room:', error.message);
 * });
 * @example
 * // Accessing the SDK logger
 * var { Logger, connect } = require('twilio-video');
 * var token = getAccessToken();
 *
 * var logger = Logger.getLogger('twilio-video');
 *
 * // Listen for logs
 * var originalFactory = logger.methodFactory;
 * logger.methodFactory = function (methodName, logLevel, loggerName) {
 *   var method = originalFactory(methodName, logLevel, loggerName);
 *
 *   return function (datetime, logLevel, component, message, data) {
 *     method(datetime, logLevel, component, message, data);
 *     // Send to your own server
 *     postDataToServer(arguments);
 *   };
 * };
 * logger.setLevel('debug');
 *
 * connect(token, {
 *   name: 'my-cool-room'
 * }).then(function(room) {
 *   room.on('participantConnected', function(participant) {
 *     console.log(participant.identity + ' has connected');
 *   });
 * }).catch(error => {
 *   console.log('Could not connect to the Room:', error.message);
 * });
 */
function connect(token, options) {
    if (typeof options === 'undefined') {
        options = {};
    }
    if (!isNonArrayObject(options)) {
        return CancelablePromise.reject(E.INVALID_TYPE('options', 'object'));
    }
    var Log = options.Log || DefaultLog;
    var loggerName = options.loggerName || DEFAULT_LOGGER_NAME;
    var logLevel = options.logLevel || DEFAULT_LOG_LEVEL;
    var logLevels = buildLogLevels(logLevel);
    var logComponentName = "[connect #" + ++connectCalls + "]";
    var log;
    try {
        log = new Log('default', logComponentName, logLevels, loggerName);
    }
    catch (error) {
        return CancelablePromise.reject(error);
    }
    // NOTE(csantos): Log a warning for the deprecated ConnectOptions properties.
    // The warning is displayed only for the first call to connect() per browser session.
    // Additionally, the options that are no longer needed will be removed.
    deprecateOptions(options, log, deprecatedConnectOptionsProps);
    options = Object.assign({
        automaticSubscription: true,
        createLocalTracks: createLocalTracks,
        dominantSpeaker: false,
        enableDscp: false,
        environment: DEFAULT_ENVIRONMENT,
        eventListener: null,
        insights: true,
        LocalAudioTrack: LocalAudioTrack,
        LocalDataTrack: LocalDataTrack,
        LocalParticipant: LocalParticipant,
        LocalVideoTrack: LocalVideoTrack,
        Log: Log,
        MediaStreamTrack: MediaStreamTrack,
        loggerName: loggerName,
        logLevel: logLevel,
        maxAudioBitrate: null,
        maxVideoBitrate: null,
        name: null,
        networkMonitor: true,
        networkQuality: false,
        preferredAudioCodecs: [],
        preferredVideoCodecs: [],
        realm: DEFAULT_REALM,
        region: DEFAULT_REGION,
        signaling: SignalingV2
    }, filterObject(options));
    /* eslint new-cap:0 */
    var wsServer = WS_SERVER(options.environment, options.region);
    var eventObserver = new EventObserver(Date.now(), log, options.eventListener);
    options = Object.assign({ eventObserver: eventObserver, wsServer: wsServer }, options);
    options.log = log;
    // NOTE(mroberts): Print the Safari warning once if the log-level is at least
    // "warn", i.e. neither "error" nor "off".
    // NOTE(mmalavalli): Print the Safari warning only for versions 12.0 and below.
    if (isSafariWithoutVP8Support
        && !didPrintSafariWarning
        && (log.logLevel !== 'error' && log.logLevel !== 'off')) {
        didPrintSafariWarning = true;
        log.warn([
            'Support for Safari 12.0 and below is limited because it does not support VP8.',
            'This means you may experience codec issues in Group Rooms. You may also',
            'experience codec issues in Peer-to-Peer (P2P) Rooms containing Android- or',
            'iOS-based Participants who do not support H.264. However, P2P Rooms',
            'with browser-based Participants should work. For more information, please',
            'refer to this guide: https://www.twilio.com/docs/video/javascript-v2-developing-safari-11'
        ].join(' '));
    }
    if (typeof token !== 'string') {
        return CancelablePromise.reject(E.INVALID_TYPE('token', 'string'));
    }
    // NOTE(mmalavalli): The Room "name" in "options" was being used
    // as the LocalTrack name in asLocalTrack(). So we pass a copy of
    // "options" without the "name".
    var localTrackOptions = Object.assign({}, options);
    delete localTrackOptions.name;
    if ('tracks' in options) {
        if (!Array.isArray(options.tracks)) {
            return CancelablePromise.reject(E.INVALID_TYPE('options.tracks', 'Array of LocalAudioTrack, LocalVideoTrack or MediaStreamTrack'));
        }
        try {
            options.tracks = options.tracks.map(function (track) { return asLocalTrack(track, localTrackOptions); });
        }
        catch (error) {
            return CancelablePromise.reject(error);
        }
    }
    var error = validateBandwidthProfile(options.bandwidthProfile);
    if (error) {
        return CancelablePromise.reject(error);
    }
    // Note(mpatwardhan): "clientTrackSwitchOffControl" allows tracks to be switched off
    // and "contentPreferencesMode" allows track dimensions to be specified dynamically.
    // The properties can have one of the three values internally:
    // 1) "auto" = sdk will decide and send the hints.
    // 2) "manual" - app can use api to send the hints.
    // 3) "disabled" = do not enable this feature. (this is internal only value)
    // 'disabled' is needed because clientTrackSwitchOffControl and contentPreferencesMode are incompatible with
    // deprecated properties maxTracks and renderDimensions respectively. once we make @breaking_version_change
    // we can remove 'disabled' state along with maxTracks and renderDimensions.
    options.clientTrackSwitchOffControl = 'disabled'; // should sdk turn off idle tracks automatically?
    options.contentPreferencesMode = 'disabled'; // should sdk  use video element dimensions for content hints?
    if (options.bandwidthProfile) {
        options.clientTrackSwitchOffControl = 'auto';
        options.contentPreferencesMode = 'auto';
        if (options.bandwidthProfile.video) {
            // log any warnings about deprecated bwp options
            deprecateOptions(options.bandwidthProfile.video, log, deprecatedBandwidthProfileOptions);
            if ('maxTracks' in options.bandwidthProfile.video) {
                // when deprecated maxTracks is specified. disable clientTrackSwitchOffControl
                options.clientTrackSwitchOffControl = 'disabled';
            }
            else if (options.bandwidthProfile.video.clientTrackSwitchOffControl === 'manual') {
                options.clientTrackSwitchOffControl = 'manual';
            }
            else {
                options.clientTrackSwitchOffControl = 'auto';
            }
            if ('renderDimensions' in options.bandwidthProfile.video) {
                options.contentPreferencesMode = 'disabled';
            }
            else if (options.bandwidthProfile.video.contentPreferencesMode === 'manual') {
                options.contentPreferencesMode = 'manual';
            }
            else {
                options.contentPreferencesMode = 'auto';
            }
        }
    }
    var Signaling = options.signaling;
    var signaling = new Signaling(options.wsServer, options);
    log.info('Connecting to a Room');
    log.debug('Options:', options);
    var encodingParameters = new EncodingParametersImpl({
        maxAudioBitrate: options.maxAudioBitrate,
        maxVideoBitrate: options.maxVideoBitrate
    });
    var preferredCodecs = {
        audio: options.preferredAudioCodecs.map(normalizeCodecSettings),
        video: options.preferredVideoCodecs.map(normalizeCodecSettings)
    };
    var networkQualityConfiguration = new NetworkQualityConfigurationImpl(isNonArrayObject(options.networkQuality) ? options.networkQuality : {});
    // Create a CancelableRoomPromise<Room> that resolves after these steps:
    // 1 - Get the LocalTracks.
    // 2 - Create the LocalParticipant using options.tracks.
    // 3 - Connect to rtc-room-service and create the RoomSignaling.
    // 4 - Create the Room and then resolve the CancelablePromise.
    var cancelableRoomPromise = createCancelableRoomPromise(getLocalTracks.bind(null, options), createLocalParticipant.bind(null, signaling, log, encodingParameters, networkQualityConfiguration, options), createRoomSignaling.bind(null, token, options, signaling, encodingParameters, preferredCodecs), createRoom.bind(null, options));
    cancelableRoomPromise.then(function (room) {
        log.info('Connected to Room:', room.toString());
        log.info('Room name:', room.name);
        log.debug('Room:', room);
        return room;
    }, function (error) {
        if (cancelableRoomPromise._isCanceled) {
            log.info('Attempt to connect to a Room was canceled');
        }
        else {
            log.info('Error while connecting to a Room:', error);
        }
    });
    return cancelableRoomPromise;
}
/**
 * You may pass these options to {@link connect} in order to override the
 * default behavior.
 * @typedef {object} ConnectOptions
 * @property {boolean|CreateLocalTrackOptions} [audio=true] - Whether or not to
 *   get local audio with <code>getUserMedia</code> when <code>tracks</code>
 *   are not provided.
 * @property {boolean} [automaticSubscription=true] - By default, you will subscribe
 *   to all RemoteTracks shared by other Participants in a Room. You can now override this
 *   behavior by setting this flag to <code>false</code>. It will make sure that you will
 *   not subscribe to any RemoteTrack in a Group or Small Group Room. Setting it to
 *   <code>true</code>, or not setting it at all preserves the default behavior. This
 *   flag does not have any effect in a Peer-to-Peer Room.
 * @property {BandwidthProfileOptions} [bandwidthProfile] - You can optionally configure
 *   how your available downlink bandwidth is shared among the RemoteTracks you have subscribed
 *   to in a Group Room. By default, bandwidth is shared equally among the RemoteTracks.
 *   This has no effect in Peer-to-Peer Rooms.
 * @property {boolean} [dominantSpeaker=false] - Whether to enable the Dominant
 *   Speaker API or not. This only takes effect in Group Rooms.
 * @property {boolean} [dscpTagging=false] - <code>(deprecated: use "enableDscp" instead)</code>
 *   DSCP tagging allows you to request enhanced QoS treatment for RTP media packets from any
 *   firewall that the client may be behind. Setting this option to <code>true</code> will
 *   request DSCP tagging for media packets on supported browsers (only Chrome supports this
 *   as of now). Audio packets will be sent with DSCP header value set to 0xb8 which corresponds
 *   to Expedited Forwarding (EF). Video packets will be sent with DSCP header value set to 0x88
 *   which corresponds to Assured Forwarding (AF41).
 * @property {boolean} [enableDscp=false] - DSCP tagging allows you to request enhanced
 *   QoS treatment for RTP media packets from any firewall that the client may be behind.
 *   Setting this option to <code>true</code> will request DSCP tagging for media packets
 *   on supported browsers (only Chrome supports this as of now). Audio packets will be
 *   sent with DSCP header value set to 0xb8 which corresponds to Expedited Forwarding (EF).
 *   Video packets will be sent with DSCP header value set to 0x88 which corresponds to
 *   Assured Forwarding (AF41).
 * @property {EventListener} [eventListener] - <code>(deprecated: use [Video.Logger](module-twilio-video.html)</code>
 *   you can listen to fine-grained events related to signaling and media that are
 *   not available in the public APIs. These events might be useful for your own reporting
 *   and diagnostics.
 * @property {Array<RTCIceServer>} iceServers - Override the STUN and TURN
 *   servers used when connecting to {@link Room}s
 * @property {RTCIceTransportPolicy} [iceTransportPolicy="all"] - Override the
 *   ICE transport policy to be one of "relay" or "all"
 * @property {boolean} [insights=true] - Whether publishing events
 *   to the Insights gateway is enabled or not
 * @property {?number} [maxAudioBitrate=null] - Max outgoing audio bitrate (bps);
 *   A <code>null</code> or a <code>0</code> value does not set any bitrate limit;
 *   This value is set as a hint for variable bitrate codecs, but will not take
 *   effect for fixed bitrate codecs; Based on our tests, Chrome, Firefox and Safari
 *   support a bitrate range of 12000 bps to 256000 bps for Opus codec; This parameter
 *   has no effect on iSAC, PCMU and PCMA codecs
 * @property {?number} [maxVideoBitrate=null] - Max outgoing video bitrate (bps);
 *   A <code>null</code> or <code>0</code> value does not set any bitrate limit;
 *   This value is set as a hint for variable bitrate codecs, but will not take
 *   effect for fixed bitrate codecs; Based on our tests, Chrome, Firefox and Safari
 *   all seem to support an average bitrate range of 20000 bps (20 kbps) to
 *   8000000 bps (8 mbps) for a 720p VideoTrack
 * @property {?string} [name=null] - Set to connect to a {@link Room} by name
 * @property {boolean|NetworkQualityConfiguration} [networkQuality=false] - Whether to enable the Network
 *   Quality API or not. This only takes effect in Group Rooms. Pass a {@link NetworkQualityConfiguration}
 *   to configure verbosity levels for network quality information for {@link LocalParticipant}
 *   and {@link RemoteParticipant}s. A <code>true</code> value will set the {@link NetworkQualityVerbosity}
 *   for the {@link LocalParticipant} to {@link NetworkQualityVerbosity}<code style="padding:0 0">#minimal</code>
 *   and the {@link NetworkQualityVerbosity} for {@link RemoteParticipant}s to
 *   {@link NetworkQualityVerbosity}<code style="padding:0 0">#none</code>.
 * @property {string} [region='gll'] - Preferred signaling region; By default, you will be connected to the
 *   nearest signaling server determined by latency based routing. Setting a value other
 *   than <code style="padding:0 0">gll</code> bypasses routing and guarantees that signaling traffic will be
 *   terminated in the region that you prefer. Please refer to this <a href="https://www.twilio.com/docs/video/ip-address-whitelisting#signaling-communication" target="_blank">table</a>
 *   for the list of supported signaling regions.
 * @property {Array<AudioCodec|AudioCodecSettings>} [preferredAudioCodecs=[]] - Preferred audio codecs;
 *  An empty array preserves the current audio codec preference order.
 * @property {Array<VideoCodec|VideoCodecSettings>} [preferredVideoCodecs=[]] -
 *  Preferred video codecs; An empty array preserves the current video codec
 *  preference order. If you want to set a preferred video codec on a Group Room,
 *  you will need to create the Room using the REST API and set the
 *  <code>VideoCodecs</code> property.
 *  See <a href="https://www.twilio.com/docs/api/video/rooms-resource#create-room">
 *  here</a> for more information.
 * @property {LogLevel|LogLevels} [logLevel='warn'] - <code>(deprecated: use [Video.Logger](module-twilio-video.html) instead.
 *   See [examples](module-twilio-video.html#.connect) for details)</code>
 *   Set the default log verbosity
 *   of logging. Passing a {@link LogLevel} string will use the same
 *   level for all components. Pass a {@link LogLevels} to set specific log
 *   levels.
 * @property {string} [loggerName='twilio-video'] - The name of the logger. Use this name when accessing the logger used by the SDK.
 *   See [examples](module-twilio-video.html#.connect) for details.
 * @property {Array<LocalTrack|MediaStreamTrack>} [tracks] - The
 *   {@link LocalTrack}s or MediaStreamTracks with which to join the
 *   {@link Room}. These tracks can be obtained either by calling
 *   {@link createLocalTracks}, or by constructing them from the MediaStream
 *   obtained by calling <code>getUserMedia()</code>.
 * @property {boolean|CreateLocalTrackOptions} [video=true] - Whether or not to
 *   get local video with <code>getUserMedia</code> when <code>tracks</code>
 *   are not provided.
 */
/**
 * {@link BandwidthProfileOptions} allows you to configure how your available downlink
 * bandwidth is shared among the RemoteTracks you have subscribed to in a Group Room.
 * @typedef {object} BandwidthProfileOptions
 * @property {VideoBandwidthProfileOptions} [video] - Optional parameter to configure
 *   how your available downlink bandwidth is shared among the {@link RemoteVideoTrack}s you
 *   have subscribed to in a Group Room.
 */
/**
 * {@link VideoBandwidthProfileOptions} allows you to configure how your available downlink
 * bandwidth is shared among the {@link RemoteVideoTrack}s you have subscribed to in a Group Room.
 * @typedef {object} VideoBandwidthProfileOptions
 * @property {Track.Priority} [dominantSpeakerPriority="standard"] - Optional parameter to
 *   specify the minimum subscribe {@link Track.Priority} of the Dominant Speaker's {@link RemoteVideoTrack}s.
 *   This means that the Dominant Speaker's {@link RemoteVideoTrack}s that are published with
 *   lower {@link Track.Priority} will be subscribed to with the {@link Track.Priority} specified here.
 *   This has no effect on {@link RemoteVideoTrack}s published with higher {@link Track.Priority}, which will
 *   still be subscribed to with with the same {@link Track.Priority}. If not specified, this defaults to "standard".
 *   This parameter only applies to a Group Room Participant when {@link ConnectOptions}.dominantSpeaker is set to true.
 * @property {number} [maxSubscriptionBitrate] - Optional parameter to specify the maximum
 *   downlink video bandwidth in bits per second (bps). By default, there are no limits on
 *   the downlink video bandwidth.
 * @property {ClientTrackSwitchOffControl} [clientTrackSwitchOffControl="auto"] - Optional parameter that determines
 *    when to turn the {@link RemoteVideoTrack} on or off. When set to "auto", SDK will use the visibility of the
 *    attached elements to determine if the {@link RemoteVideoTrack} should be turned off or on. When the attached video elements become invisible the {@link RemoteVideoTrack} will
 *    be turned off, and when elements become visible they will be turned on. When set to "manual" you can turn the {@link RemoteVideoTrack}
 *    on and off using the api {@link RemoteVideoTrack#switchOn} and {@link RemoteVideoTrack#switchOff} respectively.
 * @property {VideoContentPreferencesMode} [contentPreferencesMode="auto"] - This Optional parameter configures
 *    the mode for specifying content preferences for the {@link RemoteVideoTrack}. When set to "auto" the
 *    SDK determines the render dimensions by inspecting the attached video elements. {@link RemoteVideoTrack}s rendered in smaller video elements
 *    will receive a lower resolution stream compared to the video rendered in larger video elements. When set to "manual" you can set
 *    the dimensions programmatically by calling {@link RemoteVideoTrack#setContentPreferences}.
 * @property {number} [maxTracks] - <code>(deprecated: use "clientTrackSwitchOffControl" instead)</code>. Optional
 *   parameter to specify the maximum number of visible {@link RemoteVideoTrack}s, which will be selected based on
 *   {@link Track.Priority} and an N-Loudest policy. By default there are no limits on the number of visible {@link RemoteVideoTrack}s.
 *   0 or a negative value will remove any limit on the maximum number of visible {@link RemoteVideoTrack}s.
 * @property {BandwidthProfileMode} [mode="grid"] - Optional parameter to specify how the {@link RemoteVideoTrack}s'
 *   TrackPriority values are mapped to bandwidth allocation in Group Rooms. This defaults to "grid",
 *   which results in equal bandwidth share allocation to all {@link RemoteVideoTrack}s.
 * @property {VideoRenderDimensions} [renderDimensions] - <code>(deprecated: use "contentPreferencesMode" instead)</code>. Optional
 * parameter to specify the desired render dimensions of {@link RemoteVideoTrack}s.
 * @property {TrackSwitchOffMode} [trackSwitchOffMode="predicted"] - Optional parameter to configure
 *   how {@link RemoteVideoTrack}s are switched off in response to bandwidth pressure. Defaults to "predicted".
 */
/**
 * @deprecated
 * {@link VideoRenderDimensions} allows you to specify the desired render dimensions of {@link RemoteVideoTrack}s.
 * You can specify 'auto' for this field - which is also default value -  based on {@link Track.Priority}. The bandwidth allocation algorithm will distribute the available downlink bandwidth
 * proportional to the requested render dimensions. This is just an input for calculating the bandwidth to be allocated
 * and does not affect the actual resolution of the {@link RemoteVideoTrack}s.
 * @typedef {object} VideoRenderDimensions
 * @property {VideoTrack.Dimensions} [high] - Optional parameter to specify the desired rendering dimensions of
 *   {@link RemoteVideoTrack} whose {@link Track.Priority} is "high". 0 or a negative value will result in the lowest
 *   possible resolution. This defaults to 1280 x 720 (HD).
 * @property {VideoTrack.Dimensions} [low] - Optional parameter to specify the desired rendering dimensions of
 *   {@link RemoteVideoTrack} whose {@link Track.Priority} is "low". 0 or a negative value will result in the lowest
 *   possible resolution. This defaults to 176 x 144 (QCIF).
 * @property {VideoTrack.Dimensions} [standard] - Optional parameter to specify the desired rendering dimensions of
 *   {@link RemoteVideoTrack} whose {@link Track.Priority} is "standard". 0 or a negative value will result in the lowest
 *   possible resolution. This defaults to 640 x 480 (VGA).
 */
/**
 * Configure verbosity levels for network quality information for
 * {@link LocalParticipant} and {@link RemoteParticipant}s.
 * @typedef {object} NetworkQualityConfiguration
 * @property {NetworkQualityVerbosity} [local=1] - Verbosity level for {@link LocalParticipant}
 * @property {NetworkQualityVerbosity} [remote=0] - Verbosity level for {@link RemoteParticipant}s
 */
/**
 * You may pass these levels to {@link ConnectOptions} to override
 * log levels for individual components.
 * @typedef {object} LogLevels
 * @property {LogLevel} [default='warn'] - Log level for 'default' modules.
 * @property {LogLevel} [media='warn'] - Log level for 'media' modules.
 * @property {LogLevel} [signaling='warn'] - Log level for 'signaling' modules.
 * @property {LogLevel} [webrtc='warn'] - Log level for 'webrtc' modules.
 */
/**
 * Audio codec settings.
 * @typedef {object} AudioCodecSettings
 * @property {AudioCodec} codec - Audio codec name
 */
/**
 * Opus codec settings.
 * @typedef {AudioCodecSettings} OpusCodecSettings
 * @property {AudioCodec} name - "opus"
 * @property {boolean} [dtx=true] - Enable/disable discontinuous transmission (DTX);
 *   If enabled all published {@link LocalAudioTrack}s will reduce the outgoing bitrate
 *   to near-zero whenever speech is not detected, resulting in bandwidth and CPU savings;
 *   It defaults to true.
 */
/**
 * Video codec settings.
 * @typedef {object} VideoCodecSettings
 * @property {VideoCodec} codec - Video codec name
 */
/**
 * VP8 codec settings.
 * @typedef {VideoCodecSettings} VP8CodecSettings
 * @property {VideoCodec} name - "VP8"
 * @property {boolean} [simulcast=false] - Enable/disable VP8 simulcast; If
 *   enabled, Twilio's Video SDK will send three video streams of different
 *   qualities
 */
/**
 * Names of the supported audio codecs.
 * @enum {string}
 */
// eslint-disable-next-line
var AudioCodec = {
    isac: 'isac',
    opus: 'opus',
    PCMA: 'PCMA',
    PCMU: 'PCMU'
};
/**
 * Names of the supported video codecs.
 * @enum {string}
 */
// eslint-disable-next-line
var VideoCodec = {
    H264: 'H264',
    VP8: 'VP8'
};
// VP9 is supported by most browsers, but backend doesn't at the moment.
// Hide it from public documentation until then.
VideoCodec.VP9 = 'VP9';
/**
 * Levels for logging verbosity.
 * @enum {string}
 */
// eslint-disable-next-line
var LogLevel = {
    debug: 'debug',
    info: 'info',
    warn: 'warn',
    error: 'error',
    off: 'off'
};
/**
 * The verbosity level of network quality information of a {@link Participant}.
 * @enum {number}
 */
// eslint-disable-next-line
var NetworkQualityVerbosity = {
    /**
     * Nothing is reported for the {@link Participant}. This has no effect and
     * defaults to {@link NetworkQualityVerbosity}<code style="padding:0 0">#minimal</code>
     * for the {@link LocalParticipant}.
     */
    none: 0,
    /**
     * Reports {@link NetworkQualityLevel} for the {@link Participant}.
     */
    minimal: 1,
    /**
     * Reports {@link NetworkQualityLevel} and {@link NetworkQualityStats} for the {@link Participant}.
     * {@link NetworkQualityStats} is populated with audio and video {@link NetworkQualityLevel}s
     * based on which the {@link Participant}'s {@link NetworkQualityLevel} is calculated.
     */
    moderate: 2,
    /**
     * Reports {@link NetworkQualityLevel} and {@link NetworkQualityStats} for the {@link Participant}.
     * {@link NetworkQualityStats} is populated with audio and Video {@link NetworkQualityLevel}s
     * and their corresponding {@link NetworkQualityMediaStats} based on which the
     * {@link Participant}'s {@link NetworkQualityLevel} is calculated.
     */
    detailed: 3
};
/**
 * {@link TrackSwitchOffMode} specifies when {@link RemoteVideoTrack}s' are switched off.
 * @enum {string}
 */
// eslint-disable-next-line
var TrackSwitchOffMode = {
    /**
     * In this mode, {@link RemoteVideoTrack}s are switched off only when network congestion
     * is detected.
     */
    detected: 'detected',
    /**
     * In this mode, {@link RemoteVideoTrack}s are pro-actively switched off when network
     * congestion is predicted by the bandwidth estimation mechanism.
     */
    predicted: 'predicted',
    /**
     * In this mode, {@link RemoteVideoTrack}s are not switched off. Instead in response to network
     * congestion, tracks will be adjusted to lower quality.
     */
    disabled: 'disabled'
};
/**
 * {@link BandwidthProfileMode} specifies how {@link RemoteVideoTrack}s' {@link Track.Priority} values
 * are mapped to bandwidth allocation in Group Rooms.
 * @enum {string}
 */
// eslint-disable-next-line
var BandwidthProfileMode = {
    /**
     * This mode is for use cases where all the subscribed {@link RemoteVideoTrack}s are
     * equally important. The bandwidth allocation algorithm will share the available
     * downlink bandwidth equally among the subscribed {@link RemoteVideoTrack}s, irrespective
     * of their {@link Track.Priority}. In case of insufficient downlink bandwidth, the lower
     * priority {@link RemoteVideoTrack}s are switched off.
     */
    grid: 'grid',
    /**
     * This mode is for use cases where some {@link RemoteVideoTrack}s are prioritized more than
     * others. However, the lower priority {@link RemoteVideoTrack}s still need to be visible.
     * The bandwidth allocation algorithm will share the available downlink bandwidth proportional
     * to the requested {@link VideoRenderDimensions} corresponding to their {@link Track.Priority}.
     * In case of insufficient downlink bandwidth, the quality of higher priority {@link RemoteVideoTrack}s
     * may be degraded to avoid switching off lower priority {@link RemoteVideoTrack}s.
     */
    collaboration: 'collaboration',
    /**
     * This mode is for use cases where some {@link RemoteVideoTrack}s are deemed critical and must
     * be preserved at any cost over the other {@link RemoteVideoTrack}s. The bandwidth allocation
     * algorithm will allocate as big a share of the available downlink bandwidth as it possibly
     * can to the higher priority {@link RemoteVideoTrack}s, and only then consider the lower priority
     * {@link RemoteVideoTrack}s. In case of insufficient downlink bandwidth, the lower priority
     * {@link RemoteVideoTrack}s are switched off in order to preserve the quality of the higher
     * priority {@link RemoteVideoTrack}s.
     */
    presentation: 'presentation'
};
/**
 * {@link VideoContentPreferencesMode} specifies how {@link RemoteVideoTrack}s' render dimensions are
 * decided by the SDK.
 * @enum {string}
 */
// eslint-disable-next-line
var VideoContentPreferencesMode = {
    /**
     * when set to auto, SDK uses the sizes of the video elements attached to the to the  {@link RemoteVideoTrack} dynamically to
     * decide the render dimensions. {@link RemoteVideoTrack}s rendered in smaller video elements will be given smaller bandwidth allocation
     * compared to the tracks rendered in large video elements.
     */
    auto: 'auto',
    /**
     * When set to manual, application can use {@link RemoteVideoTrack#setContentPreference} to set the
     * desired render dimensions for the {@link RemoteVideoTrack}.
     */
    manual: 'manual'
};
/**
 * {@link ClientTrackSwitchOffControl} specifies how {@link RemoteVideoTrack}s' turned on and off
 * @enum {string}
 */
// eslint-disable-next-line
var ClientTrackSwitchOffControl = {
    /**
     * when set to auto, SDK uses the visibility of the video elements attached to the to the  {@link RemoteVideoTrack} to decide.
     * on turning tracks on or off. The track that are not attached to any video elements or not visible on the screen will be turned
     * off automatically.
     */
    auto: 'auto',
    /**
     * When set to manual, application can use {@link RemoteVideoTrack}s switchOff and switchOn apis to control turn the track on or off.
     */
    manual: 'manual'
};
/**
 * Names of the supported levels for {@link EventListenerEvent}s.
 * @enum {string}
 */
// eslint-disable-next-line
var EventListenerLevel = {
    debug: 'debug',
    error: 'error',
    info: 'info',
    warning: 'warning'
};
/**
 * Names of the supported groups for {@link EventListenerEvent}s.
 * @enum {string}
 */
// eslint-disable-next-line
var EventListenerGroup = {
    /**
     * Events associated with the connection to Twilio's signaling server
     */
    signaling: 'signaling'
};
/**
 * An {@link EventListener} allows you to listen to fine-grained {@link EventListenerEvent}s related
 * to signaling and media that are not available in the public APIs, which might be useful for your own
 * reporting and diagnostics.
 * @typedef {EventEmitter} EventListener
 * @example
 * const { EventEmitter } = require('events');
 * const { connect } = require('twilio-video');
 *
 * const eventListener = new EventEmitter();
 * eventListener.on('event', function(event) {
 *   console.log('The SDK raised an event:', event);
 * });
 *
 * connect('token', {
 *   eventListener: eventListener
 * });
 */
/**
 * The SDK raised an {@link EventListenerEvent}.
 * @event EventListener#event
 * @param {EventListenerEvent} event - Context about the event raised by the SDK.
 * This can be one of the following:
 *  * {@link EventListenerClosedEvent}
 *  * {@link EventListenerConnectingEvent}
 *  * {@link EventListenerEarlyEvent}
 *  * {@link EventListenerOpenEvent}
 *  * {@link EventListenerWaitingEvent}
 */
/**
 * An {@link EventListenerEvent} provides context about an event raised by the SDK on the
 * {@link EventListener}. Apart from the properties listed here, it may also include some
 * event-specific data within an optional "payload" property. The different types of
 * {@link EventListenerEvent}s are listed below:
 *  * {@link EventListenerClosedEvent}
 *  * {@link EventListenerConnectingEvent}
 *  * {@link EventListenerEarlyEvent}
 *  * {@link EventListenerOpenEvent}
 *  * {@link EventListenerWaitingEvent}
 * @typedef {object} EventListenerEvent
 * @property {number} elapsedTime - The time elapsed in milliseconds since connect() was called
 * @property {EventListenerGroup} group - The group under which the event is classified
 * @property {EventListenerLevel} level - The verbosity level of the event, which can be one of "debug", "error", "info", "warning"
 * @property {string} name - The name of the event
 * @property {*} [payload] - Optional event-specific data
 * @property {number} timestamp - The time in milliseconds relative to the Unix Epoch when the event was raised
 */
/**
 * The connection to Twilio's signaling server was closed.
 * @typedef {EventListenerEvent} EventListenerClosedEvent
 * @property {EventListenerGroup} group='signaling'
 * @property {EventListenerLevel} level - 'info' if the connection was closed by the client, 'error' otherwise
 * @property {string} name='closed'
 * @property {{reason: string}} payload - Reason for the connection being closed. It can be one of
 *   'busy', 'failed', 'local', 'remote' or 'timeout'
 */
/**
 * The SDK is connecting to Twilio's signaling server.
 * @typedef {EventListenerEvent} EventListenerConnectingEvent
 * @property {EventListenerGroup} group='signaling'
 * @property {EventListenerLevel} level='info'
 * @property {string} name='connecting'
 */
/**
 * The SDK is about to connect to Twilio's signaling server.
 * @typedef {EventListenerEvent} EventListenerEarlyEvent
 * @property {EventListenerGroup} group='signaling'
 * @property {EventListenerLevel} level='info'
 * @property {string} name='early'
 */
/**
 * The SDK has established a signaling connection to Twilio's signaling server.
 * @typedef {EventListenerEvent} EventListenerOpenEvent
 * @property {EventListenerGroup} group='signaling'
 * @property {EventListenerLevel} level='info'
 * @property {string} name='open'
 */
/**
 * The SDK is waiting to retry connecting th Twilio's signaling server. This can
 * happen if the server is busy with too many connection requests.
 * @typedef {EventListenerEvent} EventListenerWaitingEvent
 * @property {EventListenerGroup} group='signaling'
 * @property {EventListenerLevel} level='warning'
 * @property {string} name='waiting'
 */
function deprecateOptions(options, log, deprecationTable) {
    deprecationTable.forEach(function (prop) {
        var didWarn = prop.didWarn, name = prop.name, newName = prop.newName, shouldDelete = prop.shouldDelete;
        if (name in options && typeof options[name] !== 'undefined') {
            if (newName && shouldDelete) {
                options[newName] = options[name];
            }
            if (shouldDelete) {
                delete options[name];
            }
            if (!didWarn && !['error', 'off'].includes(log.level)) {
                log.warn("The ConnectOptions \"" + name + "\" is " + (newName
                    ? "deprecated and scheduled for removal. Please use \"" + newName + "\" instead."
                    : 'no longer applicable and will be ignored.'));
                prop.didWarn = true;
            }
        }
    });
}
function createLocalParticipant(signaling, log, encodingParameters, networkQualityConfiguration, options, localTracks) {
    var localParticipantSignaling = signaling.createLocalParticipantSignaling(encodingParameters, networkQualityConfiguration);
    log.debug('Creating a new LocalParticipant:', localParticipantSignaling);
    return new options.LocalParticipant(localParticipantSignaling, localTracks, options);
}
function createRoom(options, localParticipant, roomSignaling) {
    var room = new Room(localParticipant, roomSignaling, options);
    var log = options.log;
    log.debug('Creating a new Room:', room);
    roomSignaling.on('stateChanged', function stateChanged(state) {
        if (state === 'disconnected') {
            log.info('Disconnected from Room:', room.toString());
            roomSignaling.removeListener('stateChanged', stateChanged);
        }
    });
    return room;
}
function createRoomSignaling(token, options, signaling, encodingParameters, preferredCodecs, localParticipant) {
    options.log.debug('Creating a new RoomSignaling');
    return signaling.connect(localParticipant._signaling, token, encodingParameters, preferredCodecs, options);
}
function getLocalTracks(options, handleLocalTracks) {
    var log = options.log;
    options.shouldStopLocalTracks = !options.tracks;
    if (options.shouldStopLocalTracks) {
        log.info('LocalTracks were not provided, so they will be acquired '
            + 'automatically before connecting to the Room. LocalTracks will '
            + 'be released if connecting to the Room fails or if the Room '
            + 'is disconnected');
    }
    else {
        log.info('Getting LocalTracks');
        log.debug('Options:', options);
    }
    return options.createLocalTracks(options).then(function getLocalTracksSucceeded(localTracks) {
        var promise = handleLocalTracks(localTracks);
        promise.catch(function handleLocalTracksFailed() {
            if (options.shouldStopLocalTracks) {
                log.info('The automatically acquired LocalTracks will now be stopped');
                localTracks.forEach(function (track) {
                    track.stop();
                });
            }
        });
        return promise;
    });
}
function normalizeCodecSettings(nameOrSettings) {
    var settings = typeof nameOrSettings === 'string'
        ? { codec: nameOrSettings }
        : nameOrSettings;
    switch (settings.codec.toLowerCase()) {
        case 'opus': {
            return Object.assign({ dtx: true }, settings);
        }
        case 'vp8': {
            return Object.assign({ simulcast: false }, settings);
        }
        default: {
            return settings;
        }
    }
}
module.exports = connect;
//# sourceMappingURL=connect.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/createlocaltrack.js":
/*!***********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/createlocaltrack.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var defaultCreateLocalTracks = __webpack_require__(/*! ./createlocaltracks */ "../../work/twilio-video.js/es5/createlocaltracks.js");
var _a = __webpack_require__(/*! ./util/constants */ "../../work/twilio-video.js/es5/util/constants.js"), DEFAULT_LOG_LEVEL = _a.DEFAULT_LOG_LEVEL, DEFAULT_LOGGER_NAME = _a.DEFAULT_LOGGER_NAME;
/**
 * Request a {@link LocalAudioTrack} or {@link LocalVideoTrack}.
 * @param {Track.Kind} kind - "audio" or "video"
 * @param {CreateLocalTrackOptions} [options]
 * @returns {Promise<LocalAudioTrack|LocalVideoTrack>}
 * @private
 */
function createLocalTrack(kind, options) {
    options = Object.assign({
        createLocalTracks: defaultCreateLocalTracks,
        loggerName: DEFAULT_LOGGER_NAME,
        logLevel: DEFAULT_LOG_LEVEL,
    }, options);
    var createOptions = {};
    createOptions.loggerName = options.loggerName;
    createOptions.logLevel = options.logLevel;
    delete options.loggerName;
    delete options.logLevel;
    var createLocalTracks = options.createLocalTracks;
    delete options.createLocalTracks;
    createOptions[kind] = Object.keys(options).length > 0 ? options : true;
    return createLocalTracks(createOptions).then(function (localTracks) { return localTracks[0]; });
}
/**
 * Request a {@link LocalAudioTrack}.
 * @alias module:twilio-video.createLocalAudioTrack
 * @param {CreateLocalTrackOptions} [options] - Options for requesting a {@link LocalAudioTrack}
 * @returns {Promise<LocalAudioTrack>}
 * @example
 * var Video = require('twilio-video');
 *
 * // Connect to the Room with just video
 * Video.connect('my-token', {
 *   name: 'my-cool-room',
 *   video: true
 * }).then(function(room) {
 *   // Add audio after connecting to the Room
 *   Video.createLocalAudioTrack().then(function(localTrack) {
 *     room.localParticipant.publishTrack(localTrack);
 *   });
 * });
 * @example
 * var Video = require('twilio-video');
 *
 * // Request the default LocalAudioTrack with a custom name
 * Video.createLocalAudioTrack({ name: 'microphone' }).then(function(localTrack) {
 *   console.log(localTrack.name); // 'microphone'
 * });
 */
function createLocalAudioTrack(options) {
    return createLocalTrack('audio', options);
}
/**
 * Request a {@link LocalVideoTrack}. Note that on mobile browsers,
 * the camera can be reserved by only one {@link LocalVideoTrack} at any given
 * time. If you attempt to create a second {@link LocalVideoTrack}, video frames
 * will no longer be supplied to the first {@link LocalVideoTrack}.
 * @alias module:twilio-video.createLocalVideoTrack
 * @param {CreateLocalTrackOptions} [options] - Options for requesting a {@link LocalVideoTrack}
 * @returns {Promise<LocalVideoTrack>}
 * @example
 * var Video = require('twilio-video');
 *
 * // Connect to the Room with just audio
 * Video.connect('my-token', {
 *   name: 'my-cool-room',
 *   audio: true
 * }).then(function(room) {
 *   // Add video after connecting to the Room
 *   Video.createLocalVideoTrack().then(function(localTrack) {
 *     room.localParticipant.publishTrack(localTrack);
 *   });
 * });
 * @example
 * var Video = require('twilio-video');
 *
 * // Request the default LocalVideoTrack with a custom name
 * Video.createLocalVideoTrack({ name: 'camera' }).then(function(localTrack) {
 *   console.log(localTrack.name); // 'camera'
 * });
 */
function createLocalVideoTrack(options) {
    return createLocalTrack('video', options);
}
/**
 * Create {@link LocalTrack} options. Apart from the properties listed here, you can
 * also specify any of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints" target="_blank">MediaTrackConstraints</a>
 * properties.
 * @typedef {MediaTrackConstraints} CreateLocalTrackOptions
 * @property {LogLevel|LogLevels} [logLevel='warn'] - <code>(deprecated: use [Video.Logger](module-twilio-video.html) instead.
 *   See [examples](module-twilio-video.html#.connect) for details)</code>
 *   Set the default log verbosity
 *   of logging. Passing a {@link LogLevel} string will use the same
 *   level for all components. Pass a {@link LogLevels} to set specific log
 *   levels.
 * @property {string} [loggerName='twilio-video'] - The name of the logger. Use this name when accessing the logger used by the SDK.
 *   See [examples](module-twilio-video.html#.connect) for details.
 * @property {string} [name] - The {@link LocalTrack}'s name; by default,
 *   it is set to the {@link LocalTrack}'s ID.
 * @property {boolean} [workaroundWebKitBug180748=false] - Only valid for
 *   {@link LocalAudioTrack}s; setting this attempts to workaround WebKit Bug
 *   180748, where, in Safari, getUserMedia may return a silent audio
 *   MediaStreamTrack.
 */
module.exports = {
    audio: createLocalAudioTrack,
    video: createLocalVideoTrack
};
//# sourceMappingURL=createlocaltrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/createlocaltracks.js":
/*!************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/createlocaltracks.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var asLocalTrack = __webpack_require__(/*! ./util */ "../../work/twilio-video.js/es5/util/index.js").asLocalTrack;
var buildLogLevels = __webpack_require__(/*! ./util */ "../../work/twilio-video.js/es5/util/index.js").buildLogLevels;
var getUserMedia = __webpack_require__(/*! @twilio/webrtc */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/index.js").getUserMedia;
var _a = __webpack_require__(/*! ./media/track/es5 */ "../../work/twilio-video.js/es5/media/track/es5/index.js"), LocalAudioTrack = _a.LocalAudioTrack, LocalDataTrack = _a.LocalDataTrack, LocalVideoTrack = _a.LocalVideoTrack;
var MediaStreamTrack = __webpack_require__(/*! @twilio/webrtc */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/index.js").MediaStreamTrack;
var Log = __webpack_require__(/*! ./util/log */ "../../work/twilio-video.js/es5/util/log.js");
var _b = __webpack_require__(/*! ./util/constants */ "../../work/twilio-video.js/es5/util/constants.js"), DEFAULT_LOG_LEVEL = _b.DEFAULT_LOG_LEVEL, DEFAULT_LOGGER_NAME = _b.DEFAULT_LOGGER_NAME;
var workaround180748 = __webpack_require__(/*! ./webaudio/workaround180748 */ "../../work/twilio-video.js/es5/webaudio/workaround180748.js");
// This is used to make out which createLocalTracks() call a particular Log
// statement belongs to. Each call to createLocalTracks() increments this
// counter.
var createLocalTrackCalls = 0;
/**
 * Request {@link LocalTrack}s. By default, it requests a
 * {@link LocalAudioTrack} and a {@link LocalVideoTrack}.
 * Note that on mobile browsers, the camera can be reserved by only one {@link LocalVideoTrack}
 * at any given time. If you attempt to create a second {@link LocalVideoTrack}, video frames
 * will no longer be supplied to the first {@link LocalVideoTrack}.
 * @alias module:twilio-video.createLocalTracks
 * @param {CreateLocalTracksOptions} [options]
 * @returns {Promise<Array<LocalTrack>>}
 * @example
 * var Video = require('twilio-video');
 * // Request audio and video tracks
 * Video.createLocalTracks().then(function(localTracks) {
 *   var localMediaContainer = document.getElementById('local-media-container-id');
 *   localTracks.forEach(function(track) {
 *     localMediaContainer.appendChild(track.attach());
 *   });
 * });
 * @example
 * var Video = require('twilio-video');
 * // Request just the default audio track
 * Video.createLocalTracks({ audio: true }).then(function(localTracks) {
 *   return Video.connect('my-token', {
 *     name: 'my-cool-room',
 *     tracks: localTracks
 *   });
 * });
 * @example
 * var Video = require('twilio-video');
 * // Request the audio and video tracks with custom names
 * Video.createLocalTracks({
 *   audio: { name: 'microphone' },
 *   video: { name: 'camera' }
 * }).then(function(localTracks) {
 *   localTracks.forEach(function(localTrack) {
 *     console.log(localTrack.name);
 *   });
 * });
 *
 * @example
 * var Video = require('twilio-video');
 * var localTracks;
 *
 * // Pre-acquire tracks to display camera preview.
 * Video.createLocalTracks().then(function(tracks) {
 *  localTracks = tracks;
 *  var localVideoTrack = localTracks.find(track => track.kind === 'video');
 *  divContainer.appendChild(localVideoTrack.attach());
 * })
 *
 * // Later, join the Room with the pre-acquired LocalTracks.
 * Video.connect('token', {
 *   name: 'my-cool-room',
 *   tracks: localTracks
 * });
 *
 */
function createLocalTracks(options) {
    var isAudioVideoAbsent = !(options && ('audio' in options || 'video' in options));
    options = Object.assign({
        audio: isAudioVideoAbsent,
        getUserMedia: getUserMedia,
        loggerName: DEFAULT_LOGGER_NAME,
        logLevel: DEFAULT_LOG_LEVEL,
        LocalAudioTrack: LocalAudioTrack,
        LocalDataTrack: LocalDataTrack,
        LocalVideoTrack: LocalVideoTrack,
        MediaStreamTrack: MediaStreamTrack,
        Log: Log,
        video: isAudioVideoAbsent
    }, options);
    var logComponentName = "[createLocalTracks #" + ++createLocalTrackCalls + "]";
    var logLevels = buildLogLevels(options.logLevel);
    var log = new options.Log('default', logComponentName, logLevels, options.loggerName);
    // NOTE(mmalavalli): The Room "name" in "options" was being used
    // as the LocalTrack name in asLocalTrack(). So we pass a copy of
    // "options" without the "name".
    var localTrackOptions = Object.assign({ log: log }, options);
    delete localTrackOptions.name;
    if (options.audio === false && options.video === false) {
        log.info('Neither audio nor video requested, so returning empty LocalTracks');
        return Promise.resolve([]);
    }
    if (options.tracks) {
        log.info('Adding user-provided LocalTracks');
        log.debug('LocalTracks:', options.tracks);
        return Promise.resolve(options.tracks);
    }
    var extraLocalTrackOptions = {
        audio: options.audio && options.audio.name
            ? { name: options.audio.name }
            : {},
        video: options.video && options.video.name
            ? { name: options.video.name }
            : {}
    };
    extraLocalTrackOptions.audio.isCreatedByCreateLocalTracks = true;
    extraLocalTrackOptions.video.isCreatedByCreateLocalTracks = true;
    if (options.audio && typeof options.audio.workaroundWebKitBug1208516 === 'boolean') {
        extraLocalTrackOptions.audio.workaroundWebKitBug1208516 = options.audio.workaroundWebKitBug1208516;
    }
    if (options.video && typeof options.video.workaroundWebKitBug1208516 === 'boolean') {
        extraLocalTrackOptions.video.workaroundWebKitBug1208516 = options.video.workaroundWebKitBug1208516;
    }
    if (options.audio) {
        delete options.audio.name;
    }
    if (options.video) {
        delete options.video.name;
    }
    var mediaStreamConstraints = {
        audio: options.audio,
        video: options.video
    };
    var workaroundWebKitBug180748 = options.audio && options.audio.workaroundWebKitBug180748;
    var mediaStreamPromise = workaroundWebKitBug180748
        ? workaround180748(log, options.getUserMedia, mediaStreamConstraints)
        : options.getUserMedia(mediaStreamConstraints);
    return mediaStreamPromise.then(function (mediaStream) {
        var mediaStreamTracks = mediaStream.getAudioTracks().concat(mediaStream.getVideoTracks());
        log.info('Call to getUserMedia successful; got MediaStreamTracks:', mediaStreamTracks);
        return mediaStreamTracks.map(function (mediaStreamTrack) { return asLocalTrack(mediaStreamTrack, Object.assign(extraLocalTrackOptions[mediaStreamTrack.kind], localTrackOptions)); });
    }, function (error) {
        log.warn('Call to getUserMedia failed:', error);
        throw error;
    });
}
/**
 * {@link createLocalTracks} options
 * @typedef {object} CreateLocalTracksOptions
 * @property {boolean|CreateLocalTrackOptions} [audio=true] - Whether or not to
 *   get local audio with <code>getUserMedia</code> when <code>tracks</code>
 *   are not provided.
 * @property {LogLevel|LogLevels} [logLevel='warn'] - <code>(deprecated: use [Video.Logger](module-twilio-video.html) instead.
 *   See [examples](module-twilio-video.html#.connect) for details)</code>
 *   Set the default log verbosity
 *   of logging. Passing a {@link LogLevel} string will use the same
 *   level for all components. Pass a {@link LogLevels} to set specific log
 *   levels.
 * @property {string} [loggerName='twilio-video'] - The name of the logger. Use this name when accessing the logger used by the SDK.
 *   See [examples](module-twilio-video.html#.connect) for details.
 * @property {boolean|CreateLocalTrackOptions} [video=true] - Whether or not to
 *   get local video with <code>getUserMedia</code> when <code>tracks</code>
 *   are not provided.
 */
module.exports = createLocalTracks;
//# sourceMappingURL=createlocaltracks.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/data/receiver.js":
/*!********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/data/receiver.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DataTrackTransceiver = __webpack_require__(/*! ./transceiver */ "../../work/twilio-video.js/es5/data/transceiver.js");
var DataTransport = __webpack_require__(/*! ./transport */ "../../work/twilio-video.js/es5/data/transport.js");
/**
 * A {@link DataTrackReceiver} represents a {@link DataTrackTransceiver} over
 * which data can be received. Internally, it users a single RTCDataChannel to
 * receive data.
 * @extends DataTrackTransceiver
 * @emits DataTrackReceiver#message
 * @emits DataTrackReceiver#close
 */
var DataTrackReceiver = /** @class */ (function (_super) {
    __extends(DataTrackReceiver, _super);
    /**
     * Construct an {@link DataTrackReceiver}.
     * @param {RTCDataChannel} dataChannel
     */
    function DataTrackReceiver(dataChannel) {
        var _this = _super.call(this, dataChannel.label, dataChannel.maxPacketLifeTime, dataChannel.maxRetransmits, dataChannel.ordered) || this;
        Object.defineProperties(_this, {
            _dataChannel: {
                value: dataChannel
            }
        });
        // NOTE(mmalavalli): In Firefox, the default value for "binaryType" is "blob".
        // So, we set it to "arraybuffer" to ensure that it is consistent with Chrome
        // and Safari.
        dataChannel.binaryType = 'arraybuffer';
        dataChannel.addEventListener('message', function (event) {
            _this.emit('message', event.data);
        });
        dataChannel.addEventListener('close', function () {
            _this.emit('close');
        });
        return _this;
    }
    DataTrackReceiver.prototype.stop = function () {
        this._dataChannel.close();
        _super.prototype.stop.call(this);
    };
    /**
     * Create a {@link DataTransport} from the {@link DataTrackReceiver}.
     * @returns {DataTransport}
     */
    DataTrackReceiver.prototype.toDataTransport = function () {
        return new DataTransport(this._dataChannel);
    };
    return DataTrackReceiver;
}(DataTrackTransceiver));
/**
 * @event DataTrackReceiver#message
 * @param {string|ArrayBuffer} data
 */
/**
 * @event DataTrackReceiver#close
 */
module.exports = DataTrackReceiver;
//# sourceMappingURL=receiver.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/data/sender.js":
/*!******************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/data/sender.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DataTrackTransceiver = __webpack_require__(/*! ./transceiver */ "../../work/twilio-video.js/es5/data/transceiver.js");
var makeUUID = __webpack_require__(/*! ../util */ "../../work/twilio-video.js/es5/util/index.js").makeUUID;
/**
 * A {@link DataTrackSender} represents a {@link DataTrackTransceiver} over
 * which data can be sent. Internally, it uses a collection of RTCDataChannels
 * to send data.
 * @extends DataTrackTransceiver
 */
var DataTrackSender = /** @class */ (function (_super) {
    __extends(DataTrackSender, _super);
    /**
     * Construct a {@link DataTrackSender}.
     * @param {?number} maxPacketLifeTime
     * @param {?number} maxRetransmits
     * @param {boolean} ordered
     */
    function DataTrackSender(maxPacketLifeTime, maxRetransmtis, ordered) {
        var _this = _super.call(this, makeUUID(), maxPacketLifeTime, maxRetransmtis, ordered) || this;
        Object.defineProperties(_this, {
            _clones: {
                value: new Set()
            },
            _dataChannels: {
                value: new Set()
            }
        });
        return _this;
    }
    /**
     * Add a cloned {@link DataTrackSender}.
     * @private
     * @returns {void}
     */
    DataTrackSender.prototype._addClone = function (clone) {
        this._clones.add(clone);
    };
    /**
     * Remove a cloned {@link DataTrackSender}.
     * @returns {void}
     */
    DataTrackSender.prototype.removeClone = function (clone) {
        this._clones.delete(clone);
    };
    /**
     * Add an RTCDataChannel to the {@link DataTrackSender}.
     * @param {RTCDataChannel} dataChannel
     * @returns {this}
     */
    DataTrackSender.prototype.addDataChannel = function (dataChannel) {
        this._dataChannels.add(dataChannel);
        return this;
    };
    /**
     * Return a new {@link DataTrackSender}. Any message sent over this
     * {@link DataTrackSender} will also be sent over the clone. Whenever this
     * {@link DataTrackSender} is stopped, so to will the clone.
     * @returns {DataTrackSender}
     */
    DataTrackSender.prototype.clone = function () {
        var _this = this;
        var clone = new DataTrackSender(this.maxPacketLifeTime, this.maxRetransmits, this.ordered);
        this._addClone(clone);
        clone.once('stopped', function () { return _this.removeClone(clone); });
        return clone;
    };
    /**
     * Remove an RTCDataChannel from the {@link DataTrackSender}.
     * @param {RTCDataChannel} dataChannel
     * @returns {this}
     */
    DataTrackSender.prototype.removeDataChannel = function (dataChannel) {
        this._dataChannels.delete(dataChannel);
        return this;
    };
    /**
     * Send data over the {@link DataTrackSender}. Internally, this calls
     * <code>send</code> over each of the underlying RTCDataChannels.
     * @param {string|Blob|ArrayBuffer|ArrayBufferView} data
     * @returns {this}
     */
    DataTrackSender.prototype.send = function (data) {
        this._dataChannels.forEach(function (dataChannel) {
            try {
                dataChannel.send(data);
            }
            catch (error) {
                // Do nothing.
            }
        });
        this._clones.forEach(function (clone) {
            try {
                clone.send(data);
            }
            catch (error) {
                // Do nothing.
            }
        });
        return this;
    };
    DataTrackSender.prototype.stop = function () {
        this._dataChannels.forEach(function (dataChannel) { return dataChannel.close(); });
        this._clones.forEach(function (clone) { return clone.stop(); });
        _super.prototype.stop.call(this);
    };
    return DataTrackSender;
}(DataTrackTransceiver));
module.exports = DataTrackSender;
//# sourceMappingURL=sender.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/data/transceiver.js":
/*!***********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/data/transceiver.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackTransceiver = __webpack_require__(/*! ../transceiver */ "../../work/twilio-video.js/es5/transceiver.js");
/**
 * A {@link DataTrackTransceiver} represents either one or more local
 * RTCDataChannels or a single remote RTCDataChannel. It can be used to send or
 * receive data.
 * @extends TrackTransceiver
 * @property {string} id
 * @property {string} kind - "data"
 * @property {?number} maxPacketLifeTime
 * @property {?number} maxRetransmits
 * @property {boolean} ordered
 */
var DataTrackTransceiver = /** @class */ (function (_super) {
    __extends(DataTrackTransceiver, _super);
    /**
     * Construct a {@link DataTrackTransceiver}.
     * @param {string} id
     * @param {?number} maxPacketLifeTime
     * @param {?number} maxRetransmits
     * @param {boolean} ordered
     */
    function DataTrackTransceiver(id, maxPacketLifeTime, maxRetransmits, ordered) {
        var _this = _super.call(this, id, 'data') || this;
        Object.defineProperties(_this, {
            maxPacketLifeTime: {
                enumerable: true,
                value: maxPacketLifeTime
            },
            maxRetransmits: {
                enumerable: true,
                value: maxRetransmits
            },
            ordered: {
                enumerable: true,
                value: ordered
            }
        });
        return _this;
    }
    return DataTrackTransceiver;
}(TrackTransceiver));
module.exports = DataTrackTransceiver;
//# sourceMappingURL=transceiver.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/data/transport.js":
/*!*********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/data/transport.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
/**
 * @classdesc A {@link DataTransport} implements {@link MediaSignalingTransport}
 *   in terms of an RTCDataChannel.
 * @extends EventEmitter
 * @implements MediaSignalingTransport
 * @emits DataTransport#message
 */
var DataTransport = /** @class */ (function (_super) {
    __extends(DataTransport, _super);
    /**
     * Construct a {@link DataTransport}.
     * @param {RTCDataChannel} dataChannel
     */
    function DataTransport(dataChannel) {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _dataChannel: {
                value: dataChannel
            },
            _messageQueue: {
                value: []
            }
        });
        dataChannel.addEventListener('open', function () {
            _this._messageQueue.splice(0).forEach(function (message) { return _this._publish(message); });
        });
        dataChannel.addEventListener('message', function (_a) {
            var data = _a.data;
            try {
                var message = JSON.parse(data);
                _this.emit('message', message);
            }
            catch (error) {
                // Do nothing.
            }
        });
        _this.publish({ type: 'ready' });
        return _this;
    }
    /**
     * @param message
     * @private
     */
    DataTransport.prototype._publish = function (message) {
        var data = JSON.stringify(message);
        try {
            this._dataChannel.send(data);
        }
        catch (error) {
            // Do nothing.
        }
    };
    /**
     * Publish a message. Returns true if calling the method resulted in
     * publishing (or eventually publishing) the update.
     * @param {object} message
     * @returns {boolean}
     */
    DataTransport.prototype.publish = function (message) {
        var dataChannel = this._dataChannel;
        if (dataChannel.readyState === 'closing' || dataChannel.readyState === 'closed') {
            return false;
        }
        if (dataChannel.readyState === 'connecting') {
            this._messageQueue.push(message);
            return true;
        }
        this._publish(message);
        return true;
    };
    return DataTransport;
}(EventEmitter));
/**
 * The {@link DataTransport} received a message.
 * @event DataTransport#message
 * @param {object} message
 */
module.exports = DataTransport;
//# sourceMappingURL=transport.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/encodingparameters.js":
/*!*************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/encodingparameters.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
/**
 * {@link EncodingParametersImpl} represents an object which notifies its
 * listeners of any changes in the values of its properties.
 * @extends EventEmitter
 * @implements EncodingParameters
 * @emits EncodingParametersImpl#changed
 * @property {?number} maxAudioBitrate
 * @property {?number} maxVideoBitrate
 */
var EncodingParametersImpl = /** @class */ (function (_super) {
    __extends(EncodingParametersImpl, _super);
    /**
     * Construct an {@link EncodingParametersImpl}.
     * @param {EncodingParamters} encodingParameters - Initial {@link EncodingParameters}
     */
    function EncodingParametersImpl(encodingParameters) {
        var _this = _super.call(this) || this;
        encodingParameters = Object.assign({
            maxAudioBitrate: null,
            maxVideoBitrate: null
        }, encodingParameters);
        Object.defineProperties(_this, {
            maxAudioBitrate: {
                value: encodingParameters.maxAudioBitrate,
                writable: true
            },
            maxVideoBitrate: {
                value: encodingParameters.maxVideoBitrate,
                writable: true
            }
        });
        return _this;
    }
    /**
     * Returns the bitrate values in an {@link EncodingParameters}.
     * @returns {EncodingParameters}
     */
    EncodingParametersImpl.prototype.toJSON = function () {
        return {
            maxAudioBitrate: this.maxAudioBitrate,
            maxVideoBitrate: this.maxVideoBitrate
        };
    };
    /**
     * Update the bitrate values with those in the given {@link EncodingParameters}.
     * @param {EncodingParameters} encodingParameters - The new {@link EncodingParameters}
     * @fires EncodingParametersImpl#changed
     */
    EncodingParametersImpl.prototype.update = function (encodingParameters) {
        var _this = this;
        encodingParameters = Object.assign({
            maxAudioBitrate: this.maxAudioBitrate,
            maxVideoBitrate: this.maxVideoBitrate
        }, encodingParameters);
        var shouldEmitChanged = [
            'maxAudioBitrate',
            'maxVideoBitrate'
        ].reduce(function (shouldEmitChanged, maxKindBitrate) {
            if (_this[maxKindBitrate] !== encodingParameters[maxKindBitrate]) {
                _this[maxKindBitrate] = encodingParameters[maxKindBitrate];
                shouldEmitChanged = true;
            }
            return shouldEmitChanged;
        }, false);
        if (shouldEmitChanged) {
            this.emit('changed');
        }
    };
    return EncodingParametersImpl;
}(EventEmitter));
/**
 * At least one of the {@link EncodingParametersImpl}'s bitrate values changed.
 * @event EncodingParametersImpl#changed
 */
module.exports = EncodingParametersImpl;
//# sourceMappingURL=encodingparameters.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/eventemitter.js":
/*!*******************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/eventemitter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var hidePrivateAndCertainPublicPropertiesInClass = __webpack_require__(/*! ./util */ "../../work/twilio-video.js/es5/util/index.js").hidePrivateAndCertainPublicPropertiesInClass;
module.exports = hidePrivateAndCertainPublicPropertiesInClass(EventEmitter, ['domain']);
//# sourceMappingURL=eventemitter.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/index.js":
/*!************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var preflighttest_1 = __webpack_require__(/*! ./preflight/preflighttest */ "../../work/twilio-video.js/es5/preflight/preflighttest.js");
var internals = {
    connect: __webpack_require__(/*! ./connect */ "../../work/twilio-video.js/es5/connect.js"),
    createLocalAudioTrack: __webpack_require__(/*! ./createlocaltrack */ "../../work/twilio-video.js/es5/createlocaltrack.js").audio,
    createLocalTracks: __webpack_require__(/*! ./createlocaltracks */ "../../work/twilio-video.js/es5/createlocaltracks.js"),
    createLocalVideoTrack: __webpack_require__(/*! ./createlocaltrack */ "../../work/twilio-video.js/es5/createlocaltrack.js").video,
    isSupported: __webpack_require__(/*! ./util/support */ "../../work/twilio-video.js/es5/util/support.js")(),
    version: __webpack_require__(/*! ../package.json */ "../../work/twilio-video.js/package.json").version,
    Logger: __webpack_require__(/*! ./vendor/loglevel */ "../../work/twilio-video.js/es5/vendor/loglevel.js"),
    LocalAudioTrack: __webpack_require__(/*! ./media/track/es5 */ "../../work/twilio-video.js/es5/media/track/es5/index.js").LocalAudioTrack,
    LocalDataTrack: __webpack_require__(/*! ./media/track/es5 */ "../../work/twilio-video.js/es5/media/track/es5/index.js").LocalDataTrack,
    LocalVideoTrack: __webpack_require__(/*! ./media/track/es5 */ "../../work/twilio-video.js/es5/media/track/es5/index.js").LocalVideoTrack
};
function connect(token, options) {
    return internals.connect(token, options);
}
function createLocalAudioTrack(options) {
    return internals.createLocalAudioTrack(options);
}
function createLocalTracks(options) {
    return internals.createLocalTracks(options);
}
function createLocalVideoTrack(options) {
    return internals.createLocalVideoTrack(options);
}
/**
 * @module twilio-video
 * @property {boolean} isSupported - true if the current browser is officially
 *   supported by twilio-video.js; In this context, "supported" means that
 *   twilio-video.js has been extensively tested with this browser; This
 *   <a href="https://www.twilio.com/docs/video/javascript#supported-browsers" target="_blank">table</a>
 *   specifies the list of officially supported browsers.
 *
 * @property {object} Logger - The <a href="https://www.npmjs.com/package/loglevel" target="_blank">loglevel</a>
 *    module used by the SDK. Use this object to access the internal loggers and perform actions as defined by the
 *   <a href="https://www.npmjs.com/package/loglevel" target="_blank">loglevel</a> APIs.
 *   See [connect](#.connect) for examples.
 *
 * @property {string} version - current version of twilio-video.js.
 */
var isSupported = internals.isSupported;
var version = internals.version;
var Logger = internals.Logger;
var LocalAudioTrack = internals.LocalAudioTrack;
var LocalVideoTrack = internals.LocalVideoTrack;
var LocalDataTrack = internals.LocalDataTrack;
module.exports = {
    connect: connect,
    createLocalAudioTrack: createLocalAudioTrack,
    createLocalTracks: createLocalTracks,
    createLocalVideoTrack: createLocalVideoTrack,
    runPreflight: preflighttest_1.runPreflight,
    isSupported: isSupported,
    version: version,
    Logger: Logger,
    LocalAudioTrack: LocalAudioTrack,
    LocalVideoTrack: LocalVideoTrack,
    LocalDataTrack: LocalDataTrack
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/localparticipant.js":
/*!***********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/localparticipant.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaStreamTrack = __webpack_require__(/*! @twilio/webrtc */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/index.js").MediaStreamTrack;
var _a = __webpack_require__(/*! ./util */ "../../work/twilio-video.js/es5/util/index.js"), asLocalTrack = _a.asLocalTrack, asLocalTrackPublication = _a.asLocalTrackPublication, trackClass = _a.trackClass;
var _b = __webpack_require__(/*! ./util/constants */ "../../work/twilio-video.js/es5/util/constants.js"), E = _b.typeErrors, trackPriority = _b.trackPriority;
var validateLocalTrack = __webpack_require__(/*! ./util/validate */ "../../work/twilio-video.js/es5/util/validate.js").validateLocalTrack;
var _c = __webpack_require__(/*! ./media/track/es5 */ "../../work/twilio-video.js/es5/media/track/es5/index.js"), LocalAudioTrack = _c.LocalAudioTrack, LocalDataTrack = _c.LocalDataTrack, LocalVideoTrack = _c.LocalVideoTrack;
var LocalAudioTrackPublication = __webpack_require__(/*! ./media/track/localaudiotrackpublication */ "../../work/twilio-video.js/es5/media/track/localaudiotrackpublication.js");
var LocalDataTrackPublication = __webpack_require__(/*! ./media/track/localdatatrackpublication */ "../../work/twilio-video.js/es5/media/track/localdatatrackpublication.js");
var LocalVideoTrackPublication = __webpack_require__(/*! ./media/track/localvideotrackpublication */ "../../work/twilio-video.js/es5/media/track/localvideotrackpublication.js");
var Participant = __webpack_require__(/*! ./participant */ "../../work/twilio-video.js/es5/participant.js");
/**
 * A {@link LocalParticipant} represents the local {@link Participant} in a
 * {@link Room}.
 * @extends Participant
 * @property {Map<Track.SID, LocalAudioTrackPublication>} audioTracks -
 *    The {@link LocalParticipant}'s {@link LocalAudioTrackPublication}s
 * @property {Map<Track.SID, LocalDataTrackPublication>} dataTracks -
 *    The {@link LocalParticipant}'s {@link LocalDataTrackPublication}s
 * @property {Map<Track.SID, LocalTrackPublication>} tracks -
 *    The {@link LocalParticipant}'s {@link LocalTrackPublication}s
 * @property {Map<Track.SID, LocalVideoTrackPublication>} videoTracks -
 *    The {@link LocalParticipant}'s {@link LocalVideoTrackPublication}s
 * @property {string} signalingRegion - The geographical region of the
 *     signaling edge the {@link LocalParticipant} is connected to.
 *
 * @emits RemoteParticipant#reconnected
 * @emits RemoteParticipant#reconnecting
 * @emits LocalParticipant#trackDimensionsChanged
 * @emits LocalParticipant#trackDisabled
 * @emits LocalParticipant#trackEnabled
 * @emits LocalParticipant#trackPublicationFailed
 * @emits LocalParticipant#trackPublished
 * @emits LocalParticipant#trackStarted
 * @emits LocalParticipant#trackStopped
 */
var LocalParticipant = /** @class */ (function (_super) {
    __extends(LocalParticipant, _super);
    /**
     * Construct a {@link LocalParticipant}.
     * @param {ParticipantSignaling} signaling
     * @param {Array<LocalTrack>} localTracks
     * @param {Object} options
     */
    function LocalParticipant(signaling, localTracks, options) {
        var _this = this;
        options = Object.assign({
            LocalAudioTrack: LocalAudioTrack,
            LocalVideoTrack: LocalVideoTrack,
            LocalDataTrack: LocalDataTrack,
            MediaStreamTrack: MediaStreamTrack,
            LocalAudioTrackPublication: LocalAudioTrackPublication,
            LocalVideoTrackPublication: LocalVideoTrackPublication,
            LocalDataTrackPublication: LocalDataTrackPublication,
            shouldStopLocalTracks: false,
            tracks: localTracks
        }, options);
        var tracksToStop = options.shouldStopLocalTracks
            ? new Set(localTracks.filter(function (localTrack) { return localTrack.kind !== 'data'; }))
            : new Set();
        _this = _super.call(this, signaling, options) || this;
        Object.defineProperties(_this, {
            _eventObserver: {
                value: options.eventObserver
            },
            _LocalAudioTrack: {
                value: options.LocalAudioTrack
            },
            _LocalDataTrack: {
                value: options.LocalDataTrack
            },
            _LocalVideoTrack: {
                value: options.LocalVideoTrack
            },
            _MediaStreamTrack: {
                value: options.MediaStreamTrack
            },
            _LocalAudioTrackPublication: {
                value: options.LocalAudioTrackPublication
            },
            _LocalDataTrackPublication: {
                value: options.LocalDataTrackPublication
            },
            _LocalVideoTrackPublication: {
                value: options.LocalVideoTrackPublication
            },
            _tracksToStop: {
                value: tracksToStop
            },
            signalingRegion: {
                enumerable: true,
                get: function () {
                    return signaling.signalingRegion;
                }
            }
        });
        _this._handleTrackSignalingEvents();
        return _this;
    }
    /**
     * @private
     * @param {LocalTrack} track
     * @param {Track.ID} id
     * @param {Track.Priority} priority
     * @returns {?LocalTrack}
     */
    LocalParticipant.prototype._addTrack = function (track, id, priority) {
        var addedTrack = _super.prototype._addTrack.call(this, track, id);
        if (addedTrack && this.state !== 'disconnected') {
            this._addLocalTrack(track, priority);
        }
        return addedTrack;
    };
    /**
     * @private
     * @param {LocalTrack} track
     * @param {Track.Priority} priority
     * @returns {void}
     */
    LocalParticipant.prototype._addLocalTrack = function (track, priority) {
        this._signaling.addTrack(track._trackSender, track.name, priority);
        this._log.info("Added a new " + trackClass(track, true) + ":", track.id);
        this._log.debug(trackClass(track, true) + ":", track);
    };
    /**
     * @private
     * @param {LocalTrack} track
     * @param {Track.ID} id
     * @returns {?LocalTrack}
     */
    LocalParticipant.prototype._removeTrack = function (track, id) {
        var removedTrack = _super.prototype._removeTrack.call(this, track, id);
        if (removedTrack && this.state !== 'disconnected') {
            this._signaling.removeTrack(track._trackSender);
            this._log.info("Removed a " + trackClass(track, true) + ":", track.id);
            this._log.debug(trackClass(track, true) + ":", track);
        }
        return removedTrack;
    };
    /**
     * Get the {@link LocalTrack} events to re-emit.
     * @private
     * @returns {Array<Array<string>>} events
     */
    LocalParticipant.prototype._getTrackEvents = function () {
        return _super.prototype._getTrackEvents.call(this).concat([
            ['disabled', 'trackDisabled'],
            ['enabled', 'trackEnabled'],
            ['stopped', 'trackStopped']
        ]);
    };
    LocalParticipant.prototype.toString = function () {
        return "[LocalParticipant #" + this._instanceId + (this.sid ? ": " + this.sid : '') + "]";
    };
    /**
     * @private
     */
    LocalParticipant.prototype._handleTrackSignalingEvents = function () {
        var _this = this;
        var log = this._log;
        if (this.state === 'disconnected') {
            return;
        }
        var signaling = this._signaling;
        function localTrackDisabled(localTrack) {
            var trackSignaling = signaling.getPublication(localTrack._trackSender);
            if (trackSignaling) {
                trackSignaling.disable();
                log.debug("Disabled the " + trackClass(localTrack, true) + ":", localTrack.id);
            }
        }
        function localTrackEnabled(localTrack) {
            var trackSignaling = signaling.getPublication(localTrack._trackSender);
            if (trackSignaling) {
                trackSignaling.enable();
                log.debug("Enabled the " + trackClass(localTrack, true) + ":", localTrack.id);
            }
        }
        function localTrackStopped(localTrack) {
            // NOTE(mroberts): We shouldn't need to check for `stop`, since DataTracks
            // do not emit "stopped".
            var trackSignaling = signaling.getPublication(localTrack._trackSender);
            if (trackSignaling) {
                trackSignaling.stop();
            }
            return trackSignaling;
        }
        this.on('trackDisabled', localTrackDisabled);
        this.on('trackEnabled', localTrackEnabled);
        this.on('trackStopped', localTrackStopped);
        this._tracks.forEach(function (track) {
            _this._addLocalTrack(track, trackPriority.PRIORITY_STANDARD);
            _this._getOrCreateLocalTrackPublication(track).catch(function (error) {
                // Just log a warning for now.
                log.warn("Failed to get or create LocalTrackPublication for " + track + ":", error);
            });
        });
        var self = this;
        signaling.on('stateChanged', function stateChanged(state) {
            log.debug('Transitioned to state:', state);
            if (state === 'disconnected') {
                log.debug('Removing LocalTrack event listeners');
                signaling.removeListener('stateChanged', stateChanged);
                self.removeListener('trackDisabled', localTrackDisabled);
                self.removeListener('trackEnabled', localTrackEnabled);
                self.removeListener('trackStopped', localTrackStopped);
                // NOTE(mmalavalli): Remove the stale MediaTrackSender clones so that we
                // do not call replaceTrack() on their RTCRtpSenders.
                self._tracks.forEach(function (track) {
                    var trackSignaling = localTrackStopped(track);
                    if (trackSignaling) {
                        track._trackSender.removeClone(trackSignaling._trackTransceiver);
                    }
                });
                log.info("LocalParticipant disconnected. Stopping " + self._tracksToStop.size + " automatically-acquired LocalTracks");
                self._tracksToStop.forEach(function (track) {
                    track.stop();
                });
            }
            else if (state === 'connected') {
                // NOTE(mmalavalli): Any transition to "connected" here is a result of
                // successful signaling reconnection, and not a first-time establishment
                // of the signaling connection.
                log.info('reconnected');
                // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.
                // Do not signal  public events synchronously with lock held.
                setTimeout(function () { return self.emit('reconnected'); }, 0);
            }
        });
    };
    /**
     * @private
     * @param {LocalTrack} localTrack
     * @returns {Promise<LocalTrackPublication>}
     */
    LocalParticipant.prototype._getOrCreateLocalTrackPublication = function (localTrack) {
        var localTrackPublication = getTrackPublication(this.tracks, localTrack);
        if (localTrackPublication) {
            return Promise.resolve(localTrackPublication);
        }
        var log = this._log;
        var self = this;
        var trackSignaling = this._signaling.getPublication(localTrack._trackSender);
        if (!trackSignaling) {
            return Promise.reject(new Error("Unexpected error: The " + localTrack + " cannot be published"));
        }
        function unpublish(publication) {
            self.unpublishTrack(publication.track);
        }
        return new Promise(function (resolve, reject) {
            function updated() {
                var error = trackSignaling.error;
                if (error) {
                    trackSignaling.removeListener('updated', updated);
                    log.warn("Failed to publish the " + trackClass(localTrack, true) + ": " + error.message);
                    self._removeTrack(localTrack, localTrack.id);
                    setTimeout(function () {
                        self.emit('trackPublicationFailed', error, localTrack);
                    });
                    reject(error);
                    return;
                }
                if (!self._tracks.has(localTrack.id)) {
                    trackSignaling.removeListener('updated', updated);
                    reject(new Error("The " + localTrack + " was unpublished"));
                    return;
                }
                var sid = trackSignaling.sid;
                if (!sid) {
                    return;
                }
                trackSignaling.removeListener('updated', updated);
                var options = {
                    log: log,
                    LocalAudioTrackPublication: self._LocalAudioTrackPublication,
                    LocalDataTrackPublication: self._LocalDataTrackPublication,
                    LocalVideoTrackPublication: self._LocalVideoTrackPublication
                };
                localTrackPublication = getTrackPublication(self.tracks, localTrack);
                if (!localTrackPublication) {
                    localTrackPublication = asLocalTrackPublication(localTrack, trackSignaling, unpublish, options);
                    self._addTrackPublication(localTrackPublication);
                }
                var state = self._signaling.state;
                if (state === 'connected' || state === 'connecting') {
                    if (localTrack._processorEventObserver) {
                        localTrack._processorEventObserver.on('event', function (event) {
                            self._eventObserver.emit('event', {
                                name: event.name,
                                payload: event.data,
                                group: 'video-processor',
                                level: 'info'
                            });
                        });
                    }
                    // NOTE(csantos): For tracks created before joining a room or already joined but about to publish it
                    if (localTrack.processedTrack) {
                        localTrack._captureFrames();
                        localTrack._setSenderMediaStreamTrack(true);
                    }
                }
                if (state === 'connected') {
                    setTimeout(function () {
                        self.emit('trackPublished', localTrackPublication);
                    });
                }
                resolve(localTrackPublication);
            }
            trackSignaling.on('updated', updated);
        });
    };
    /**
     * Publishes a {@link LocalTrack} to the {@link Room}.
     * @param {LocalTrack} localTrack - The {@link LocalTrack} to publish
     * @param {LocalTrackPublishOptions} [options] - The {@link LocalTrackPublishOptions}
     *   for publishing the {@link LocalTrack}
     * @returns {Promise<LocalTrackPublication>} - Resolves with the corresponding
     *   {@link LocalTrackPublication} if successful; In a Large Group Room (Maximum
     *   Participants greater than 50), rejects with a {@link ParticipantMaxTracksExceededError}
     *   if either the total number of published Tracks in the Room exceeds 16, or the {@link LocalTrack}
     *   is part of a set of {@link LocalTrack}s which along with the published Tracks exceeds 16.
     * @throws {TypeError}
     * @throws {RangeError}
     * @example
     * var Video = require('twilio-video');
     *
     * Video.connect(token, {
     *   name: 'my-cool-room',
     *   audio: true
     * }).then(function(room) {
     *   return Video.createLocalVideoTrack({
     *     name: 'camera'
     *   }).then(function(localVideoTrack) {
     *     return room.localParticipant.publishTrack(localVideoTrack, {
     *       priority: 'high'
     *     });
     *   });
     * }).then(function(publication) {
     *   console.log('The LocalTrack "' + publication.trackName
     *     + '" was successfully published with priority "'
     *     * publication.priority + '"');
     * });
    */ /**
     * Publishes a MediaStreamTrack to the {@link Room}.
     * @param {MediaStreamTrack} mediaStreamTrack - The MediaStreamTrack
     *   to publish; if a corresponding {@link LocalAudioTrack} or
     *   {@link LocalVideoTrack} has not yet been published, this method will
     *   construct one
     * @param {MediaStreamTrackPublishOptions} [options] - The options for publishing
     *   the MediaStreamTrack
     * @returns {Promise<LocalTrackPublication>} - Resolves with the corresponding
     *   {@link LocalTrackPublication} if successful; In a Large Group Room (Maximum
     *   Participants greater than 50), rejects with a {@link ParticipantMaxTracksExceededError}
     *   if the total number of published Tracks in the Room exceeds 16, or the {@link LocalTrack}
     *   is part of a set of {@link LocalTrack}s which along with the published Tracks exceeds 16.
     * @throws {TypeError}
     * @throws {RangeError}
     * @example
     * var Video = require('twilio-video');
     *
     * Video.connect(token, {
     *   name: 'my-cool-room',
     *   audio: true
     * }).then(function(room) {
     *   return navigator.mediaDevices.getUserMedia({
     *     video: true
     *   }).then(function(mediaStream) {
     *     var mediaStreamTrack = mediaStream.getTracks()[0];
     *     return room.localParticipant.publishTrack(mediaStreamTrack, {
     *       name: 'camera',
     *       priority: 'high'
     *     });
     *   });
     * }).then(function(publication) {
     *   console.log('The LocalTrack "' + publication.trackName
     *     + '" was successfully published with priority "'
     *     * publication.priority + '"');
     * });
     */
    LocalParticipant.prototype.publishTrack = function (localTrackOrMediaStreamTrack, options) {
        var trackPublication = getTrackPublication(this.tracks, localTrackOrMediaStreamTrack);
        if (trackPublication) {
            return Promise.resolve(trackPublication);
        }
        options = Object.assign({
            log: this._log,
            priority: trackPriority.PRIORITY_STANDARD,
            LocalAudioTrack: this._LocalAudioTrack,
            LocalDataTrack: this._LocalDataTrack,
            LocalVideoTrack: this._LocalVideoTrack,
            MediaStreamTrack: this._MediaStreamTrack
        }, options);
        var localTrack;
        try {
            localTrack = asLocalTrack(localTrackOrMediaStreamTrack, options);
        }
        catch (error) {
            return Promise.reject(error);
        }
        var priorityValues = Object.values(trackPriority);
        if (!priorityValues.includes(options.priority)) {
            // eslint-disable-next-line new-cap
            return Promise.reject(E.INVALID_VALUE('LocalTrackPublishOptions.priority', priorityValues));
        }
        var addedLocalTrack = this._addTrack(localTrack, localTrack.id, options.priority)
            || this._tracks.get(localTrack.id);
        return this._getOrCreateLocalTrackPublication(addedLocalTrack);
    };
    /**
     * Publishes multiple {@link LocalTrack}s to the {@link Room}.
     * @param {Array<LocalTrack|MediaStreamTrack>} tracks - The {@link LocalTrack}s
     *   to publish; for any MediaStreamTracks provided, if a corresponding
     *   {@link LocalAudioTrack} or {@link LocalVideoTrack} has not yet been
     *   published, this method will construct one
     * @returns {Promise<Array<LocalTrackPublication>>} - The resulting
     *   {@link LocalTrackPublication}s if successful; In a Large Group Room (Maximum
     *   Participants greater than 50), rejects with a {@link ParticipantMaxTracksExceededError}
     *   if the total number of published Tracks in the Room exceeds 16, or the {@link LocalTrack}s
     *   along with the published Tracks exceeds 16.
     * @throws {TypeError}
     */
    LocalParticipant.prototype.publishTracks = function (tracks) {
        if (!Array.isArray(tracks)) {
            // eslint-disable-next-line new-cap
            throw E.INVALID_TYPE('tracks', 'Array of LocalAudioTrack, LocalVideoTrack, LocalDataTrack, or MediaStreamTrack');
        }
        return Promise.all(tracks.map(this.publishTrack, this));
    };
    LocalParticipant.prototype.setBandwidthProfile = function () {
        this._log.warn('setBandwidthProfile is not implemented yet and may be available in future versions of twilio-video.js');
    };
    /**
     * Sets the {@link NetworkQualityVerbosity} for the {@link LocalParticipant} and
     * {@link RemoteParticipant}s. It does nothing if Network Quality is not enabled
     * while calling {@link connect}.
     * @param {NetworkQualityConfiguration} networkQualityConfiguration - The new
     *   {@link NetworkQualityConfiguration}; If either or both of the local and
     *   remote {@link NetworkQualityVerbosity} values are absent, then the corresponding
     *   existing values are retained
     * @returns {this}
     * @example
     * // Update verbosity levels for both LocalParticipant and RemoteParticipants
     * localParticipant.setNetworkQualityConfiguration({
     *   local: 1,
     *   remote: 2
     * });
     * @example
     * // Update verbosity level for only the LocalParticipant
     * localParticipant.setNetworkQualityConfiguration({
     *   local: 1
     * });
     *  @example
     * // Update verbosity level for only the RemoteParticipants
     * localParticipant.setNetworkQualityConfiguration({
     *   remote: 2
     * });
     */
    LocalParticipant.prototype.setNetworkQualityConfiguration = function (networkQualityConfiguration) {
        if (typeof networkQualityConfiguration !== 'object'
            || networkQualityConfiguration === null) {
            // eslint-disable-next-line new-cap
            throw E.INVALID_TYPE('networkQualityConfiguration', 'NetworkQualityConfiguration');
        }
        ['local', 'remote'].forEach(function (prop) {
            if (prop in networkQualityConfiguration && (typeof networkQualityConfiguration[prop] !== 'number' || isNaN(networkQualityConfiguration[prop]))) {
                // eslint-disable-next-line new-cap
                throw E.INVALID_TYPE("networkQualityConfiguration." + prop, 'number');
            }
        });
        this._signaling.setNetworkQualityConfiguration(networkQualityConfiguration);
        return this;
    };
    /**
     * Set the {@link LocalParticipant}'s {@link EncodingParameters}.
     * @param {?EncodingParameters} [encodingParameters] - The new
     *   {@link EncodingParameters}; If null, then the bitrate limits are removed;
     *   If not specified, then the existing bitrate limits are preserved
     * @returns {this}
     * @throws {TypeError}
     */
    LocalParticipant.prototype.setParameters = function (encodingParameters) {
        if (typeof encodingParameters !== 'undefined'
            && typeof encodingParameters !== 'object') {
            // eslint-disable-next-line new-cap
            throw E.INVALID_TYPE('encodingParameters', 'EncodingParameters, null or undefined');
        }
        if (encodingParameters) {
            ['maxAudioBitrate', 'maxVideoBitrate'].forEach(function (prop) {
                if (typeof encodingParameters[prop] !== 'undefined'
                    && typeof encodingParameters[prop] !== 'number'
                    && encodingParameters[prop] !== null) {
                    // eslint-disable-next-line new-cap
                    throw E.INVALID_TYPE("encodingParameters." + prop, 'number, null or undefined');
                }
            });
        }
        else if (encodingParameters === null) {
            encodingParameters = { maxAudioBitrate: null, maxVideoBitrate: null };
        }
        this._signaling.setParameters(encodingParameters);
        return this;
    };
    /**
     * Stops publishing a {@link LocalTrack} to the {@link Room}.
     * @param {LocalTrack|MediaStreamTrack} track - The {@link LocalTrack}
     *   to stop publishing; if a MediaStreamTrack is provided, this method
     *   looks up the corresponding {@link LocalAudioTrack} or
     *   {@link LocalVideoTrack} to stop publishing
     * @returns {?LocalTrackPublication} - The corresponding
     *   {@link LocalTrackPublication} if the {@link LocalTrack} was previously
     *   published, null otherwise
     * @throws {TypeError}
    */
    LocalParticipant.prototype.unpublishTrack = function (track) {
        validateLocalTrack(track, {
            LocalAudioTrack: this._LocalAudioTrack,
            LocalDataTrack: this._LocalDataTrack,
            LocalVideoTrack: this._LocalVideoTrack,
            MediaStreamTrack: this._MediaStreamTrack
        });
        var localTrack = this._tracks.get(track.id);
        if (!localTrack) {
            return null;
        }
        var trackSignaling = this._signaling.getPublication(localTrack._trackSender);
        trackSignaling.publishFailed(new Error("The " + localTrack + " was unpublished"));
        localTrack = this._removeTrack(localTrack, localTrack.id);
        if (!localTrack) {
            return null;
        }
        var localTrackPublication = getTrackPublication(this.tracks, localTrack);
        if (localTrackPublication) {
            this._removeTrackPublication(localTrackPublication);
        }
        return localTrackPublication;
    };
    /**
     * Stops publishing multiple {@link LocalTrack}s to the {@link Room}.
     * @param {Array<LocalTrack|MediaStreamTrack>} tracks - The {@link LocalTrack}s
     *   to stop publishing; for any MediaStreamTracks provided, this method looks
     *   up the corresponding {@link LocalAudioTrack} or {@link LocalVideoTrack} to
     *   stop publishing
     * @returns {Array<LocalTrackPublication>} - The corresponding
     *   {@link LocalTrackPublication}s that were successfully unpublished
     * @throws {TypeError}
     */
    LocalParticipant.prototype.unpublishTracks = function (tracks) {
        var _this = this;
        if (!Array.isArray(tracks)) {
            // eslint-disable-next-line new-cap
            throw E.INVALID_TYPE('tracks', 'Array of LocalAudioTrack, LocalVideoTrack, LocalDataTrack, or MediaStreamTrack');
        }
        return tracks.reduce(function (unpublishedTracks, track) {
            var unpublishedTrack = _this.unpublishTrack(track);
            return unpublishedTrack ? unpublishedTracks.concat(unpublishedTrack) : unpublishedTracks;
        }, []);
    };
    return LocalParticipant;
}(Participant));
/**
 * The {@link LocalParticipant} has reconnected to the {@link Room} after a signaling connection disruption.
 * @event LocalParticipant#reconnected
 */
/**
 * The {@link LocalParticipant} is reconnecting to the {@link Room} after a signaling connection disruption.
 * @event LocalParticipant#reconnecting
 */
/**
 * One of the {@link LocalParticipant}'s {@link LocalVideoTrack}'s dimensions changed.
 * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} whose dimensions changed
 * @event LocalParticipant#trackDimensionsChanged
 */
/**
 * A {@link LocalTrack} was disabled by the {@link LocalParticipant}.
 * @param {LocalTrack} track - The {@link LocalTrack} that was disabled
 * @event LocalParticipant#trackDisabled
 */
/**
 * A {@link LocalTrack} was enabled by the {@link LocalParticipant}.
 * @param {LocalTrack} track - The {@link LocalTrack} that was enabled
 * @event LocalParticipant#trackEnabled
 */
/**
 * A {@link LocalTrack} failed to publish. Check the error message for more
 * information. In a Large Group Room (Maximum Participants greater than 50),
 * this event is raised with a {@link ParticipantMaxTracksExceededError} either
 * when attempting to publish the {@link LocalTrack} will exceed the Maximum Published
 * Tracks limit of 16, or the {@link LocalTrack} is part of a set of {@link LocalTrack}s
 * which along with the published Tracks exceeds 16.
 * @param {TwilioError} error - A {@link TwilioError} explaining why publication
 *   failed
 * @param {LocalTrack} localTrack - The {@link LocalTrack} that failed to
 *   publish
 * @event LocalParticipant#trackPublicationFailed
 */
/**
 * A {@link LocalTrack} was successfully published.
 * @param {LocalTrackPublication} publication - The resulting
 *   {@link LocalTrackPublication} for the published {@link LocalTrack}
 * @event LocalParticipant#trackPublished
 */
/**
 * One of the {@link LocalParticipant}'s {@link LocalTrack}s started.
 * @param {LocalTrack} track - The {@link LocalTrack} that started
 * @event LocalParticipant#trackStarted
 */
/**
 * One of the {@link LocalParticipant}'s {@link LocalTrack}s stopped, either
 * because {@link LocalTrack#stop} was called or because the underlying
 * MediaStreamTrack ended).
 * @param {LocalTrack} track - The {@link LocalTrack} that stopped
 * @event LocalParticipant#trackStopped
 */
/**
 * Outgoing media encoding parameters.
 * @typedef {object} EncodingParameters
 * @property {?number} [maxAudioBitrate] - Max outgoing audio bitrate (bps);
 *   If not specified, retains the existing bitrate limit; A <code>null</code> or a
 *   <code>0</code> value removes any previously set bitrate limit; This value is set
 *   as a hint for variable bitrate codecs, but will not take effect for fixed bitrate
 *   codecs; Based on our tests, Chrome, Firefox and Safari support a bitrate range of
 *   12000 bps to 256000 bps for Opus codec; This parameter has no effect on iSAC, PCMU
 *   and PCMA codecs
 * @property {?number} [maxVideoBitrate] - Max outgoing video bitrate (bps);
 *   If not specified, retains the existing bitrate limit; A <code>null</code> or
 *   a <code>0</code> value removes any previously set bitrate limit; This value is
 *   set as a hint for variable bitrate codecs, but will not take effect for fixed
 *   bitrate codecs; Based on our tests, Chrome, Firefox and Safari all seem to support
 *   an average bitrate range of 20000 bps (20 kbps) to 8000000 bps (8 mbps) for a
 *   720p VideoTrack.
 *   Note: this limit is not applied for screen share tracks published on Chrome.
 */
/**
 * Options for publishing a {@link LocalTrack}.
 * @typedef {object} LocalTrackPublishOptions
 * @property {Track.Priority} [priority='standard'] - The priority with which the {@link LocalTrack}
 *   is to be published; In Group or Small Group Rooms, the appropriate bandwidth is
 *   allocated to the {@link LocalTrack} based on its {@link Track.Priority}; It has no
 *   effect in Peer-to-Peer Rooms; It defaults to "standard" when not provided
 */
/**
 * Options for publishing a {@link MediaStreamTrack}.
 * @typedef {LocalTrackOptions} MediaStreamTrackPublishOptions
 * @property {Track.Priority} [priority='standard'] - The priority with which the {@link LocalTrack}
 *   is to be published; In Group or Small Group Rooms, the appropriate bandwidth is
 *   allocated to the {@link LocalTrack} based on its {@link Track.Priority}; It has no
 *   effect in Peer-to-Peer Rooms; It defaults to "standard" when not provided
 */
/**
 * @private
 * @param {Map<Track.SID, LocalTrackPublication>} trackPublications
 * @param {LocalTrack|MediaStreamTrack} track
 * @returns {?LocalTrackPublication} trackPublication
 */
function getTrackPublication(trackPublications, track) {
    return Array.from(trackPublications.values()).find(function (trackPublication) { return trackPublication.track === track
        || trackPublication.track.mediaStreamTrack === track; }) || null;
}
module.exports = LocalParticipant;
//# sourceMappingURL=localparticipant.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/audiotrack.js":
/*!*****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/audiotrack.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaTrack = __webpack_require__(/*! ./mediatrack */ "../../work/twilio-video.js/es5/media/track/mediatrack.js");
/**
 * An {@link AudioTrack} is a {@link Track} representing audio.
 * @extends Track
 * @property {boolean} isStarted - Whether or not the {@link AudioTrack} has
 *   started; if the {@link AudioTrack} started, there is enough audio data to
 *   begin playback
 * @property {boolean} isEnabled - Whether or not the {@link AudioTrack} is
 *   enabled; if the {@link AudioTrack} is not enabled, it is "muted"
 * @property {Track.Kind} kind - "audio"
 * @property {MediaStreamTrack} mediaStreamTrack - An audio MediaStreamTrack
 * @property {?MediaStreamTrack} processedTrack - The source of processed audio samples.
 * It is always null as audio processing is not currently supported.
 * @emits AudioTrack#disabled
 * @emits AudioTrack#enabled
 * @emits AudioTrack#started
 */
var AudioTrack = /** @class */ (function (_super) {
    __extends(AudioTrack, _super);
    /**
     * Construct an {@link AudioTrack}.
     * @param {MediaTrackTransceiver} mediaTrackTransceiver
     * @param {{log: Log}} options
     */
    function AudioTrack(mediaTrackTransceiver, options) {
        return _super.call(this, mediaTrackTransceiver, options) || this;
    }
    /**
     * @private
     */
    AudioTrack.prototype._start = function () {
        _super.prototype._start.call(this);
        if (this._dummyEl) {
            // once started let go of dummy element
            this._dummyEl.srcObject = null;
            this._dummyEl = null;
        }
    };
    /**
     * Create an HTMLAudioElement and attach the {@link AudioTrack} to it.
     *
     * The HTMLAudioElement's <code>srcObject</code> will be set to a new
     * MediaStream containing the {@link AudioTrack}'s MediaStreamTrack.
     *
     * @returns {HTMLAudioElement} audioElement
     * @example
     * const Video = require('twilio-video');
     *
     * Video.createLocalAudioTrack().then(function(audioTrack) {
     *   const audioElement = audioTrack.attach();
     *   document.body.appendChild(audioElement);
     * });
    */ /**
     * Attach the {@link AudioTrack} to an existing HTMLMediaElement. The
     * HTMLMediaElement could be an HTMLAudioElement or an HTMLVideoElement.
     *
     * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,
     * this method sets it to a new MediaStream containing the {@link AudioTrack}'s
     * MediaStreamTrack; otherwise, it adds the {@link MediaTrack}'s
     * MediaStreamTrack to the existing MediaStream. Finally, if there are any other
     * MediaStreamTracks of the same kind on the MediaStream, this method removes
     * them.
     *
     * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement to attach to
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * const Video = require('twilio-video');
     *
     * const videoElement = document.createElement('video');
     * document.body.appendChild(videoElement);
     *
     * Video.createLocalAudioTrack().then(function(audioTrack) {
     *   audioTrack.attach(videoElement);
     * });
    */ /**
     * Attach the {@link AudioTrack} to an HTMLMediaElement selected by
     * <code>document.querySelector</code>. The HTMLMediaElement could be an
     * HTMLAudioElement or an HTMLVideoElement.
     *
     * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,
     * this method sets it to a new MediaStream containing the {@link AudioTrack}'s
     * MediaStreamTrack; otherwise, it adds the {@link AudioTrack}'s
     * MediaStreamTrack to the existing MediaStream. Finally, if there are any other
     * MediaStreamTracks of the same kind on the MediaStream, this method removes
     * them.
     *
     * @param {string} selector - A query selector for the HTMLMediaElement to
     *   attach to
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * const Video = require('twilio-video');
     *
     * const videoElement = document.createElement('video');
     * videoElement.id = 'my-video-element';
     * document.body.appendChild(videoElement);
     *
     * Video.createLocalAudioTrack().then(function(track) {
     *   track.attach('#my-video-element');
     * });
     */
    AudioTrack.prototype.attach = function () {
        return _super.prototype.attach.apply(this, arguments);
    };
    /**
     * Detach the {@link AudioTrack} from all previously attached HTMLMediaElements.
     * @returns {Array<HTMLMediaElement>} mediaElements
     * @example
     * const mediaElements = audioTrack.detach();
     * mediaElements.forEach(mediaElement => mediaElement.remove());
    */ /**
     * Detach the {@link AudioTrack} from a previously attached HTMLMediaElement.
     * @param {HTMLMediaElement} mediaElement - One of the HTMLMediaElements to
     *   which the {@link AudioTrack} is attached
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * const videoElement = document.getElementById('my-video-element');
     * audioTrack.detach(videoElement).remove();
    */ /**
     * Detach the {@link AudioTrack} from a previously attached HTMLMediaElement
     *   specified by <code>document.querySelector</code>.
     * @param {string} selector - The query selector of HTMLMediaElement to which
     *    the {@link AudioTrack} is attached
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * audioTrack.detach('#my-video-element').remove();
     */
    AudioTrack.prototype.detach = function () {
        return _super.prototype.detach.apply(this, arguments);
    };
    return AudioTrack;
}(MediaTrack));
/**
 * The {@link AudioTrack} was disabled, i.e. "muted".
 * @param {AudioTrack} track - The {@link AudioTrack} that was disabled
 * @event AudioTrack#disabled
 */
/**
 * The {@link AudioTrack} was enabled, i.e. "unmuted".
 * @param {AudioTrack} track - The {@link AudioTrack} that was enabled
 * @event AudioTrack#enabled
 */
/**
 * The {@link AudioTrack} started. This means there is enough audio data to
 * begin playback.
 * @param {AudioTrack} track - The {@link AudioTrack} that started
 * @event AudioTrack#started
 */
module.exports = AudioTrack;
//# sourceMappingURL=audiotrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/es5/index.js":
/*!****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/es5/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {
    LocalAudioTrack: __webpack_require__(/*! ./localaudiotrack */ "../../work/twilio-video.js/es5/media/track/es5/localaudiotrack.js"),
    LocalVideoTrack: __webpack_require__(/*! ./localvideotrack */ "../../work/twilio-video.js/es5/media/track/es5/localvideotrack.js"),
    LocalDataTrack: __webpack_require__(/*! ./localdatatrack */ "../../work/twilio-video.js/es5/media/track/es5/localdatatrack.js")
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/es5/localaudiotrack.js":
/*!**************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/es5/localaudiotrack.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// eslint-disable-next-line no-warning-comments
// TODO(mroberts): Remove this when we go to the next major version. This is
// only in place so that we can support ES6 classes without requiring `new`.

var inherits = __webpack_require__(/*! util */ "./node_modules/util/util.js").inherits;
var LocalAudioTrackClass = __webpack_require__(/*! ../localaudiotrack */ "../../work/twilio-video.js/es5/media/track/localaudiotrack.js");
function LocalAudioTrack(mediaStreamTrack, options) {
    var track = new LocalAudioTrackClass(mediaStreamTrack, options);
    Object.setPrototypeOf(track, LocalAudioTrack.prototype);
    return track;
}
inherits(LocalAudioTrack, LocalAudioTrackClass);
module.exports = LocalAudioTrack;
//# sourceMappingURL=localaudiotrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/es5/localdatatrack.js":
/*!*************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/es5/localdatatrack.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// eslint-disable-next-line no-warning-comments
// TODO(mroberts): Remove this when we go to the next major version. This is
// only in place so that we can support ES6 classes without requiring `new`.

var inherits = __webpack_require__(/*! util */ "./node_modules/util/util.js").inherits;
var LocalDataTrackClass = __webpack_require__(/*! ../localdatatrack */ "../../work/twilio-video.js/es5/media/track/localdatatrack.js");
function LocalDataTrack(options) {
    var track = new LocalDataTrackClass(options);
    Object.setPrototypeOf(track, LocalDataTrack.prototype);
    return track;
}
inherits(LocalDataTrack, LocalDataTrackClass);
module.exports = LocalDataTrack;
//# sourceMappingURL=localdatatrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/es5/localvideotrack.js":
/*!**************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/es5/localvideotrack.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// eslint-disable-next-line no-warning-comments
// TODO(mroberts): Remove this when we go to the next major version. This is
// only in place so that we can support ES6 classes without requiring `new`.

var inherits = __webpack_require__(/*! util */ "./node_modules/util/util.js").inherits;
var LocalVideoTrackClass = __webpack_require__(/*! ../localvideotrack */ "../../work/twilio-video.js/es5/media/track/localvideotrack.js");
function LocalVideoTrack(mediaStreamTrack, options) {
    var track = new LocalVideoTrackClass(mediaStreamTrack, options);
    Object.setPrototypeOf(track, LocalVideoTrack.prototype);
    return track;
}
inherits(LocalVideoTrack, LocalVideoTrackClass);
module.exports = LocalVideoTrack;
//# sourceMappingURL=localvideotrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/index.js":
/*!************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! ../../eventemitter */ "../../work/twilio-video.js/es5/eventemitter.js");
var _a = __webpack_require__(/*! ../../util */ "../../work/twilio-video.js/es5/util/index.js"), buildLogLevels = _a.buildLogLevels, valueToJSON = _a.valueToJSON;
var DEFAULT_LOG_LEVEL = __webpack_require__(/*! ../../util/constants */ "../../work/twilio-video.js/es5/util/constants.js").DEFAULT_LOG_LEVEL;
var Log = __webpack_require__(/*! ../../util/log */ "../../work/twilio-video.js/es5/util/log.js");
var nInstances = 0;
/**
 * A {@link Track} represents a stream of audio, video, or data.
 * @extends EventEmitter
 * @property {Track.Kind} kind - The {@link Track}'s kind
 * @property {string} name - The {@link Track}'s name
 */
var Track = /** @class */ (function (_super) {
    __extends(Track, _super);
    /**
     * Construct a {@link Track}.
     * @param {Track.ID} id - The {@link Track}'s ID
     * @param {Track.Kind} kind - The {@link Track}'s kind
     * @param {{ log: Log, name: ?string }} options
     */
    function Track(id, kind, options) {
        var _this = this;
        options = Object.assign({
            name: id,
            log: null,
            logLevel: DEFAULT_LOG_LEVEL
        }, options);
        _this = _super.call(this) || this;
        var name = String(options.name);
        var logLevels = buildLogLevels(options.logLevel);
        var log = options.log
            ? options.log.createLog('media', _this)
            : new Log('media', _this, logLevels, options.loggerName);
        Object.defineProperties(_this, {
            _instanceId: {
                value: ++nInstances
            },
            _log: {
                value: log
            },
            kind: {
                enumerable: true,
                value: kind
            },
            name: {
                enumerable: true,
                value: name
            }
        });
        return _this;
    }
    Track.prototype.toJSON = function () {
        return valueToJSON(this);
    };
    return Track;
}(EventEmitter));
/**
 * The {@link Track} ID is a string identifier for the {@link Track}.
 * @typedef {string} Track.ID
 */
/**
 * The {@link Track} kind is either "audio", "video", or "data".
 * @typedef {string} Track.Kind
 */
/**
 * The {@link Track}'s priority can be "low", "standard", or "high".
 * @typedef {string} Track.Priority
 */
/**
 * The {@link Track} SID is a unique string identifier for the {@link Track}
 * that is published to a {@link Room}.
 * @typedef {string} Track.SID
 */
/**
 * A {@link DataTrack} is a {@link LocalDataTrack} or {@link RemoteDataTrack}.
 * @typedef {LocalDataTrack|RemoteDataTrack} DataTrack
 */
/**
 * A {@link LocalTrack} is a {@link LocalAudioTrack}, {@link LocalVideoTrack},
 * or {@link LocalDataTrack}.
 * @typedef {LocalAudioTrack|LocalVideoTrack|LocalDataTrack} LocalTrack
 */
/**
 * {@link LocalTrack} options
 * @typedef {object} LocalTrackOptions
 * @property {LogLevel|LogLevels} logLevel - Log level for 'media' modules
 * @property {string} [name] - The {@link LocalTrack}'s name; by default,
 *   it is set to the {@link LocalTrack}'s ID.
 */
/**
 * A {@link RemoteTrack} is a {@link RemoteAudioTrack},
 * {@link RemoteVideoTrack}, or {@link RemoteDataTrack}.
 * @typedef {RemoteAudioTrack|RemoteVideoTrack|RemoteDataTrack} RemoteTrack
 */
module.exports = Track;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/localaudiotrack.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/localaudiotrack.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var AudioTrack = __webpack_require__(/*! ./audiotrack */ "../../work/twilio-video.js/es5/media/track/audiotrack.js");
var mixinLocalMediaTrack = __webpack_require__(/*! ./localmediatrack */ "../../work/twilio-video.js/es5/media/track/localmediatrack.js");
var LocalMediaAudioTrack = mixinLocalMediaTrack(AudioTrack);
/**
 * A {@link LocalAudioTrack} is an {@link AudioTrack} representing audio that
 * your {@link LocalParticipant} can publish to a {@link Room}. It can be
 * enabled and disabled with {@link LocalAudioTrack#enable} and
 * {@link LocalAudioTrack#disable} or stopped completely with
 * {@link LocalAudioTrack#stop}.
 * @extends AudioTrack
 * @property {Track.ID} id - The {@link LocalAudioTrack}'s ID
 * @property {boolean} isStopped - Whether or not the {@link LocalAudioTrack} is
 *   stopped
 * @emits LocalAudioTrack#disabled
 * @emits LocalAudioTrack#enabled
 * @emits LocalAudioTrack#started
 * @emits LocalAudioTrack#stopped
 */
var LocalAudioTrack = /** @class */ (function (_super) {
    __extends(LocalAudioTrack, _super);
    /**
     * Construct a {@link LocalAudioTrack} from a MediaStreamTrack.
     * @param {MediaStreamTrack} mediaStreamTrack - An audio MediaStreamTrack
     * @param {LocalTrackOptions} [options] - {@link LocalTrack} options
     */
    function LocalAudioTrack(mediaStreamTrack, options) {
        return _super.call(this, mediaStreamTrack, options) || this;
    }
    LocalAudioTrack.prototype.toString = function () {
        return "[LocalAudioTrack #" + this._instanceId + ": " + this.id + "]";
    };
    LocalAudioTrack.prototype.attach = function (el) {
        el = _super.prototype.attach.call(this, el);
        el.muted = true;
        return el;
    };
    /**
     * @private
     */
    LocalAudioTrack.prototype._end = function () {
        return _super.prototype._end.apply(this, arguments);
    };
    /**
     * Disable the {@link LocalAudioTrack}. This is effectively "mute".
     * @returns {this}
     * @fires LocalAudioTrack#disabled
     */
    LocalAudioTrack.prototype.disable = function () {
        return _super.prototype.disable.apply(this, arguments);
    };
    /**
     * Enable the {@link LocalAudioTrack}. This is effectively "unmute".
     * @returns {this}
     * @fires LocalAudioTrack#enabled
    */ /**
     * Enable or disable the {@link LocalAudioTrack}. This is effectively "unmute"
     * or "mute".
     * @param {boolean} [enabled] - Specify false to mute the
     *   {@link LocalAudioTrack}
     * @returns {this}
     * @fires LocalAudioTrack#disabled
     * @fires LocalAudioTrack#enabled
     */
    LocalAudioTrack.prototype.enable = function () {
        return _super.prototype.enable.apply(this, arguments);
    };
    /**
     * Restart the {@link LocalAudioTrack}. This stops the existing MediaStreamTrack
     * and creates a new MediaStreamTrack. If the {@link LocalAudioTrack} is being published
     * to a {@link Room}, then all the {@link RemoteParticipant}s will start receiving media
     * from the newly created MediaStreamTrack. You can access the new MediaStreamTrack via
     * the <code>mediaStreamTrack</code> property. If you want to listen to events on
     * the MediaStreamTrack directly, please do so in the "started" event handler. Also,
     * the {@link LocalAudioTrack}'s ID is no longer guaranteed to be the same as the
     * underlying MediaStreamTrack's ID.
     * @param {MediaTrackConstraints} [constraints] - The optional <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints" target="_blank">MediaTrackConstraints</a>
     *   for restarting the {@link LocalAudioTrack}; If not specified, then the current MediaTrackConstraints
     *   will be used; If <code>{}</code> (empty object) is specified, then the default MediaTrackConstraints
     *   will be used
     * @returns {Promise<void>} Rejects with a TypeError if the {@link LocalAudioTrack} was not created
     *   using an one of <code>createLocalAudioTrack</code>, <code>createLocalTracks</code> or <code>connect</code>;
     *   Also rejects with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Exceptions" target="_blank">DOMException</a>
     *   raised by <code>getUserMedia</code> when it fails
     * @fires LocalAudioTrack#stopped
     * @fires LocalAudioTrack#started
     * @example
     * const { connect, createLocalAudioTrack } = require('twilio-video');
     *
     * // Create a LocalAudioTrack that captures audio from a USB microphone.
     * createLocalAudioTrack({ deviceId: 'usb-mic-id' }).then(function(localAudioTrack) {
     *   return connect('token', {
     *     name: 'my-cool-room',
     *     tracks: [localAudioTrack]
     *   });
     * }).then(function(room) {
     *   // Restart the LocalAudioTrack to capture audio from the default microphone.
     *   const localAudioTrack = Array.from(room.localParticipant.audioTracks.values())[0].track;
     *   return localAudioTrack.restart({ deviceId: 'default-mic-id' });
     * });
     */
    LocalAudioTrack.prototype.restart = function () {
        return _super.prototype.restart.apply(this, arguments);
    };
    /**
     * Calls stop on the underlying MediaStreamTrack. If you choose to stop a
     * {@link LocalAudioTrack}, you should unpublish it after stopping.
     * @returns {this}
     * @fires LocalAudioTrack#stopped
     */
    LocalAudioTrack.prototype.stop = function () {
        return _super.prototype.stop.apply(this, arguments);
    };
    return LocalAudioTrack;
}(LocalMediaAudioTrack));
/**
 * The {@link LocalAudioTrack} was disabled, i.e. "muted".
 * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was
 *   disabled
 * @event LocalAudioTrack#disabled
 */
/**
 * The {@link LocalAudioTrack} was enabled, i.e. "unmuted".
 * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was enabled
 * @event LocalAudioTrack#enabled
 */
/**
 * The {@link LocalAudioTrack} started. This means there is enough audio data to
 * begin playback.
 * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that started
 * @event LocalAudioTrack#started
 */
/**
 * The {@link LocalAudioTrack} stopped, either because {@link LocalAudioTrack#stop}
 * or {@link LocalAudioTrack#restart} was called or because the underlying
 * MediaStreamTrack ended.
 * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that stopped
 * @event LocalAudioTrack#stopped
 */
module.exports = LocalAudioTrack;
//# sourceMappingURL=localaudiotrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/localaudiotrackpublication.js":
/*!*********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/localaudiotrackpublication.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalTrackPublication = __webpack_require__(/*! ./localtrackpublication */ "../../work/twilio-video.js/es5/media/track/localtrackpublication.js");
/**
 * A {@link LocalAudioTrackPublication} is a {@link LocalAudioTrack} that has
 * been published to a {@link Room}.
 * @extends LocalTrackPublication
 * @property {Track.Kind} kind - "audio"
 * @property {LocalAudioTrack} track - the {@link LocalAudioTrack}
 */
var LocalAudioTrackPublication = /** @class */ (function (_super) {
    __extends(LocalAudioTrackPublication, _super);
    /**
     * Construct a {@link LocalAudioTrackPublication}.
     * @param {LocalTrackPublicationSignaling} signaling - The corresponding
     *   {@link LocalTrackPublicationSignaling}
     * @param {LocalAudioTrack} track - the {@link LocalAudioTrack}
     * @param {function(LocalTrackPublication): void} unpublish - The callback
     *    that unpublishes the {@link LocalTrackPublication}
     * @param {TrackPublicationOptions} options - {@link LocalTrackPublication} options
     */
    function LocalAudioTrackPublication(signaling, track, unpublish, options) {
        return _super.call(this, signaling, track, unpublish, options) || this;
    }
    LocalAudioTrackPublication.prototype.toString = function () {
        return "[LocalAudioTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return LocalAudioTrackPublication;
}(LocalTrackPublication));
module.exports = LocalAudioTrackPublication;
//# sourceMappingURL=localaudiotrackpublication.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/localdatatrack.js":
/*!*********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/localdatatrack.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Track = __webpack_require__(/*! ./ */ "../../work/twilio-video.js/es5/media/track/index.js");
var DefaultDataTrackSender = __webpack_require__(/*! ../../data/sender */ "../../work/twilio-video.js/es5/data/sender.js");
/**
 * A {@link LocalDataTrack} is a {@link Track} representing data that your
 * {@link LocalParticipant} can publish to a {@link Room}.
 * @extends Track
 * @property {Track.ID} id - The {@link LocalDataTrack}'s ID
 * @property {Track.Kind} kind - "data"
 * @property {?number} maxPacketLifeTime - If non-null, this represents a time
 *   limit (in milliseconds) during which the {@link LocalDataTrack} will send
 *   or re-send data if not acknowledged on the underlying RTCDataChannel(s).
 * @property {?number} maxRetransmits - If non-null, this represents the number
 *   of times the {@link LocalDataTrack} will resend data if not successfully
 *   delivered on the underlying RTCDataChannel(s).
 * @property {boolean} ordered - true if data on the {@link LocalDataTrack} is
 *   guaranteed to be sent in order.
 * @property {boolean} reliable - This is true if both
 *   <code>maxPacketLifeTime</code> and <code>maxRetransmits</code> are set to
 *   null. In other words, if this is true, there is no bound on packet lifetime
 *   or the number of times the {@link LocalDataTrack} will attempt to send
 *   data, ensuring "reliable" transmission.
 * @example
 * var Video = require('twilio-video');
 *
 * var localDataTrack = new Video.LocalDataTrack();
 * window.addEventListener('mousemove', function(event) {
 *   localDataTrack.send(JSON.stringify({
 *     x: e.clientX,
 *     y: e.clientY
 *   }));
 * });
 *
 * var token1 = getAccessToken();
 * Video.connect(token1, {
 *   name: 'my-cool-room',
 *   tracks: [localDataTrack]
 * });
 *
 * var token2 = getAccessToken();
 * Video.connect(token2, {
 *   name: 'my-cool-room',
 *   tracks: []
 * }).then(function(room) {
 *   room.on('trackSubscribed', function(track) {
 *     track.on('message', function(message) {
 *       console.log(JSON.parse(message)); // { x: <number>, y: <number> }
 *     });
 *   });
 * });
 */
var LocalDataTrack = /** @class */ (function (_super) {
    __extends(LocalDataTrack, _super);
    /**
     * Construct a {@link LocalDataTrack}.
     * @param {LocalDataTrackOptions} [options] - {@link LocalDataTrack} options
     */
    function LocalDataTrack(options) {
        var _this = this;
        options = Object.assign({
            DataTrackSender: DefaultDataTrackSender,
            maxPacketLifeTime: null,
            maxRetransmits: null,
            ordered: true
        }, options);
        var DataTrackSender = options.DataTrackSender;
        var dataTrackSender = new DataTrackSender(options.maxPacketLifeTime, options.maxRetransmits, options.ordered);
        _this = _super.call(this, dataTrackSender.id, 'data', options) || this;
        Object.defineProperties(_this, {
            _trackSender: {
                value: dataTrackSender
            },
            id: {
                enumerable: true,
                value: dataTrackSender.id
            },
            maxPacketLifeTime: {
                enumerable: true,
                value: options.maxPacketLifeTime
            },
            maxRetransmits: {
                enumerable: true,
                value: options.maxRetransmits
            },
            ordered: {
                enumerable: true,
                value: options.ordered
            },
            reliable: {
                enumerable: true,
                value: options.maxPacketLifeTime === null
                    && options.maxRetransmits === null
            }
        });
        return _this;
    }
    /**
     * Send a message over the {@link LocalDataTrack}.
     * @param {string|Blob|ArrayBuffer|ArrayBufferView} data
     * @returns {void}
     */
    LocalDataTrack.prototype.send = function (data) {
        this._trackSender.send(data);
    };
    return LocalDataTrack;
}(Track));
/**
 * {@link LocalDataTrack} options
 * @typedef {LocalTrackOptions} LocalDataTrackOptions
 * @property {?number} [maxPacketLifeTime=null] - Set this to limit the time
 *   (in milliseconds) during which the LocalDataTrack will send or re-send data
 *   if not successfully delivered on the underlying RTCDataChannel(s). It is an
 *   error to specify both this and <code>maxRetransmits</code>.
 * @property {?number} [maxRetransmits=null] - Set this to limit the number of
 *   times the {@link LocalDataTrack} will send or re-send data if not
 *   acknowledged on the underlying RTCDataChannel(s). It is an error to specify
 *   both this and <code>maxPacketLifeTime</code>.
 * @property {boolean} [ordered=true] - Set this to false to allow data on the
 *   LocalDataTrack to be sent out-of-order.
 */
module.exports = LocalDataTrack;
//# sourceMappingURL=localdatatrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/localdatatrackpublication.js":
/*!********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/localdatatrackpublication.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalTrackPublication = __webpack_require__(/*! ./localtrackpublication */ "../../work/twilio-video.js/es5/media/track/localtrackpublication.js");
/**
 * A {@link LocalDataTrackPublication} is a {@link LocalDataTrack} that has been
 * published to a {@link Room}.
 * @extends LocalTrackPublication
 * @property {Track.Kind} kind - "data"
 * @property {LocalDataTrack} track - the {@link LocalDataTrack}
 */
var LocalDataTrackPublication = /** @class */ (function (_super) {
    __extends(LocalDataTrackPublication, _super);
    /**
     * Construct a {@link LocalDataTrackPublication}.
     * @param {LocalTrackPublicationSignaling} signaling - The corresponding
     *   {@link LocalTrackPublicationSignaling}
     * @param {LocalDataTrack} track - the {@link LocalDataTrack}
     * @param {function(LocalTrackPublication): void} unpublish - The callback
     *    that unpublishes the {@link LocalTrackPublication}
     * @param {TrackPublicationOptions} options - {@link LocalTrackPublication} options
     */
    function LocalDataTrackPublication(signaling, track, unpublish, options) {
        return _super.call(this, signaling, track, unpublish, options) || this;
    }
    LocalDataTrackPublication.prototype.toString = function () {
        return "[LocalDataTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return LocalDataTrackPublication;
}(LocalTrackPublication));
module.exports = LocalDataTrackPublication;
//# sourceMappingURL=localdatatrackpublication.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/localmediatrack.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/localmediatrack.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint new-cap:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var getUserMedia = __webpack_require__(/*! @twilio/webrtc */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/index.js").getUserMedia;
var guessBrowser = __webpack_require__(/*! @twilio/webrtc/lib/util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").guessBrowser;
var _a = __webpack_require__(/*! ../../util */ "../../work/twilio-video.js/es5/util/index.js"), capitalize = _a.capitalize, defer = _a.defer, waitForSometime = _a.waitForSometime, waitForEvent = _a.waitForEvent;
var ILLEGAL_INVOKE = __webpack_require__(/*! ../../util/constants */ "../../work/twilio-video.js/es5/util/constants.js").typeErrors.ILLEGAL_INVOKE;
var detectSilentAudio = __webpack_require__(/*! ../../util/detectsilentaudio */ "../../work/twilio-video.js/es5/util/detectsilentaudio.js");
var detectSilentVideo = __webpack_require__(/*! ../../util/detectsilentvideo */ "../../work/twilio-video.js/es5/util/detectsilentvideo.js");
var documentVisibilityMonitor = __webpack_require__(/*! ../../util/documentvisibilitymonitor.js */ "../../work/twilio-video.js/es5/util/documentvisibilitymonitor.js");
var localMediaRestartDeferreds = __webpack_require__(/*! ../../util/localmediarestartdeferreds */ "../../work/twilio-video.js/es5/util/localmediarestartdeferreds.js");
var gUMSilentTrackWorkaround = __webpack_require__(/*! ../../webaudio/workaround180748 */ "../../work/twilio-video.js/es5/webaudio/workaround180748.js");
var MediaTrackSender = __webpack_require__(/*! ./sender */ "../../work/twilio-video.js/es5/media/track/sender.js");
function mixinLocalMediaTrack(AudioOrVideoTrack) {
    /**
     * A {@link LocalMediaTrack} represents audio or video that your
     * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be
     * enabled and disabled with {@link LocalMediaTrack#enable} and
     * {@link LocalMediaTrack#disable} or stopped completely with
     * {@link LocalMediaTrack#stop}.
     * @emits LocalMediaTrack#stopped
     */
    return /** @class */ (function (_super) {
        __extends(LocalMediaTrack, _super);
        /**
         * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.
         * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack
         * @param {LocalTrackOptions} [options] - {@link LocalTrack} options
         */
        function LocalMediaTrack(mediaStreamTrack, options) {
            var _this = this;
            // NOTE(mpatwardhan): by default workaround for WebKitBug1208516 will be enabled on Safari browsers
            // although the bug is seen  mainly on iOS devices, we do not have a reliable way to tell iOS from MacOs
            // userAgent on iOS pretends its macOs if Safari is set to request desktop pages.
            var workaroundWebKitBug1208516 = guessBrowser() === 'safari'
                && typeof document === 'object'
                && typeof document.addEventListener === 'function'
                && typeof document.visibilityState === 'string';
            options = Object.assign({
                getUserMedia: getUserMedia,
                isCreatedByCreateLocalTracks: false,
                workaroundWebKitBug1208516: workaroundWebKitBug1208516,
                gUMSilentTrackWorkaround: gUMSilentTrackWorkaround
            }, options);
            var mediaTrackSender = new MediaTrackSender(mediaStreamTrack);
            var kind = mediaTrackSender.kind;
            _this = _super.call(this, mediaTrackSender, options) || this;
            Object.defineProperties(_this, {
                _constraints: {
                    value: typeof options[kind] === 'object'
                        ? options[kind]
                        : {},
                    writable: true
                },
                _getUserMedia: {
                    value: options.getUserMedia
                },
                _gUMSilentTrackWorkaround: {
                    value: options.gUMSilentTrackWorkaround
                },
                _workaroundWebKitBug1208516: {
                    value: options.workaroundWebKitBug1208516
                },
                _workaroundWebKitBug1208516Cleanup: {
                    value: null,
                    writable: true
                },
                _didCallEnd: {
                    value: false,
                    writable: true
                },
                _isCreatedByCreateLocalTracks: {
                    value: options.isCreatedByCreateLocalTracks
                },
                _trackSender: {
                    value: mediaTrackSender
                },
                id: {
                    enumerable: true,
                    value: mediaTrackSender.id
                },
                isEnabled: {
                    enumerable: true,
                    get: function () {
                        return mediaTrackSender.enabled;
                    }
                },
                isStopped: {
                    enumerable: true,
                    get: function () {
                        return mediaTrackSender.readyState === 'ended';
                    }
                }
            });
            // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,
            // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.
            if (_this._workaroundWebKitBug1208516) {
                _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);
            }
            return _this;
        }
        /**
         * @private
         */
        LocalMediaTrack.prototype._end = function () {
            if (this._didCallEnd) {
                return;
            }
            _super.prototype._end.call(this);
            this._didCallEnd = true;
            this.emit('stopped', this);
        };
        /**
         * @private
         */
        LocalMediaTrack.prototype._initialize = function () {
            if (this._didCallEnd) {
                this._didCallEnd = false;
            }
            _super.prototype._initialize.call(this);
        };
        /**
         * @private
         */
        LocalMediaTrack.prototype._reacquireTrack = function (constraints) {
            var _a;
            var _b = this, getUserMedia = _b._getUserMedia, gUMSilentTrackWorkaround = _b._gUMSilentTrackWorkaround, log = _b._log, kind = _b.mediaStreamTrack.kind;
            log.info('Re-acquiring the MediaStreamTrack');
            log.debug('Constraints:', constraints);
            var gUMConstraints = Object.assign({
                audio: false,
                video: false
            }, (_a = {}, _a[kind] = constraints, _a));
            var gUMPromise = this._workaroundWebKitBug1208516Cleanup
                ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints)
                : getUserMedia(gUMConstraints);
            return gUMPromise.then(function (mediaStream) {
                return mediaStream.getTracks()[0];
            });
        };
        /**
         * @private
         */
        LocalMediaTrack.prototype._restart = function (constraints) {
            var _this = this;
            var log = this._log;
            constraints = constraints || this._constraints;
            // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack
            // without stopping it first, then a NotReadableError is raised in case of
            // video, or the restarted audio will still be silent. Hence, we stop the
            // MediaStreamTrack here.
            this._stop();
            return this._reacquireTrack(constraints).catch(function (error) {
                log.error('Failed to re-acquire the MediaStreamTrack:', { error: error, constraints: constraints });
                throw error;
            }).then(function (newMediaStreamTrack) {
                log.info('Re-acquired the MediaStreamTrack');
                log.debug('MediaStreamTrack:', newMediaStreamTrack);
                _this._constraints = Object.assign({}, constraints);
                return _this._setMediaStreamTrack(newMediaStreamTrack);
            });
        };
        /**
         * @private
         */
        LocalMediaTrack.prototype._setMediaStreamTrack = function (mediaStreamTrack) {
            var _this = this;
            // NOTE(mpatwardhan): Preserve the value of the "enabled" flag.
            mediaStreamTrack.enabled = this.mediaStreamTrack.enabled;
            // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already
            // stopped, this should fire a "stopped" event.
            this._stop();
            // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has
            // the processedTrack already set, we don't want to replace that.
            return (this._unprocessedTrack ? Promise.resolve().then(function () {
                _this._unprocessedTrack = mediaStreamTrack;
            }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(function (error) {
                _this._log.warn('setMediaStreamTrack failed:', { error: error, mediaStreamTrack: mediaStreamTrack });
            })).then(function () {
                _this._initialize();
                _this._getAllAttachedElements().forEach(function (el) { return _this._attach(el); });
            });
        };
        /**
         * @private
         */
        LocalMediaTrack.prototype._stop = function () {
            this.mediaStreamTrack.stop();
            this._end();
            return this;
        };
        LocalMediaTrack.prototype.enable = function (enabled) {
            enabled = typeof enabled === 'boolean' ? enabled : true;
            if (enabled !== this.mediaStreamTrack.enabled) {
                this._log.info((enabled ? 'En' : 'Dis') + "abling");
                this.mediaStreamTrack.enabled = enabled;
                this.emit(enabled ? 'enabled' : 'disabled', this);
            }
            return this;
        };
        LocalMediaTrack.prototype.disable = function () {
            return this.enable(false);
        };
        LocalMediaTrack.prototype.restart = function (constraints) {
            var _this = this;
            var kind = this.kind;
            if (!this._isCreatedByCreateLocalTracks) {
                return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a'
                    + (" Local" + capitalize(kind) + "Track that is created using createLocalTracks")
                    + (" or createLocal" + capitalize(kind) + "Track.")));
            }
            if (this._workaroundWebKitBug1208516Cleanup) {
                this._workaroundWebKitBug1208516Cleanup();
                this._workaroundWebKitBug1208516Cleanup = null;
            }
            var promise = this._restart(constraints);
            if (this._workaroundWebKitBug1208516) {
                promise = promise.finally(function () {
                    _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);
                });
            }
            return promise;
        };
        LocalMediaTrack.prototype.stop = function () {
            this._log.info('Stopping');
            if (this._workaroundWebKitBug1208516Cleanup) {
                this._workaroundWebKitBug1208516Cleanup();
                this._workaroundWebKitBug1208516Cleanup = null;
            }
            return this._stop();
        };
        return LocalMediaTrack;
    }(AudioOrVideoTrack));
}
/**
 * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.
 * @private
 * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack
 * @returns {function} Clean up listeners attached by the workaround
 */
function restartWhenInadvertentlyStopped(localMediaTrack) {
    var log = localMediaTrack._log, kind = localMediaTrack.kind;
    var detectSilence = { audio: detectSilentAudio, video: detectSilentVideo }[kind];
    var el = localMediaTrack._dummyEl, mediaStreamTrack = localMediaTrack.mediaStreamTrack;
    var trackChangeInProgress = null;
    function checkSilence() {
        // The dummy element is paused, so play it and then detect silence.
        return el.play().then(function () { return detectSilence(el); }).then(function (isSilent) {
            if (isSilent) {
                log.warn('Silence detected');
            }
            else {
                log.info('Non-silence detected');
            }
            return isSilent;
        }).catch(function (error) {
            log.warn('Failed to detect silence:', error);
        }).finally(function () {
            // Pause the dummy element again.
            el.pause();
        });
    }
    function shouldReacquireTrack() {
        var _workaroundWebKitBug1208516Cleanup = localMediaTrack._workaroundWebKitBug1208516Cleanup, isStopped = localMediaTrack.isStopped, muted = localMediaTrack.mediaStreamTrack.muted;
        var isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup;
        // NOTE(mmalavalli): Restart the LocalMediaTrack if:
        // 1. The app is foregrounded, and
        // 2. A restart is not already in progress, and
        // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent
        return Promise.resolve().then(function () {
            return document.visibilityState === 'visible'
                && !trackChangeInProgress
                && (muted || isInadvertentlyStopped || checkSilence());
        });
    }
    function maybeRestart() {
        return Promise.race([
            waitForEvent(mediaStreamTrack, 'unmute'),
            waitForSometime(50)
        ]).then(function () { return shouldReacquireTrack(); }).then(function (shouldReacquire) {
            if (shouldReacquire && !trackChangeInProgress) {
                trackChangeInProgress = defer();
                localMediaTrack._restart().finally(function () {
                    el = localMediaTrack._dummyEl;
                    removeMediaStreamTrackListeners();
                    mediaStreamTrack = localMediaTrack.mediaStreamTrack;
                    addMediaStreamTrackListeners();
                    trackChangeInProgress.resolve();
                    trackChangeInProgress = null;
                });
            }
            // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,
            // then this makes sure that visibility callback for phase 2 is called only
            // after the MediaStreamTrack is re-acquired.
            var promise = (trackChangeInProgress && trackChangeInProgress.promise) || Promise.resolve();
            return promise.finally(function () { return localMediaRestartDeferreds.resolveDeferred(kind); });
        });
    }
    function onMute() {
        var log = localMediaTrack._log, kind = localMediaTrack.kind;
        log.info('Muted');
        log.debug('LocalMediaTrack:', localMediaTrack);
        // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being
        // backgrounded, and the inadvertently paused elements are played before it
        // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,
        // setting this Deferred will make sure that the inadvertently paused elements
        // are played only after the LocalMediaTrack is unmuted.
        //
        // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853
        //
        localMediaRestartDeferreds.startDeferred(kind);
    }
    function addMediaStreamTrackListeners() {
        mediaStreamTrack.addEventListener('ended', maybeRestart);
        mediaStreamTrack.addEventListener('mute', onMute);
        mediaStreamTrack.addEventListener('unmute', maybeRestart);
    }
    function removeMediaStreamTrackListeners() {
        mediaStreamTrack.removeEventListener('ended', maybeRestart);
        mediaStreamTrack.removeEventListener('mute', onMute);
        mediaStreamTrack.removeEventListener('unmute', maybeRestart);
    }
    // NOTE(mpatwardhan): listen for document visibility callback on phase 1.
    // this ensures that we acquire media tracks before RemoteMediaTrack
    // tries to `play` them (in phase 2). This order is important because
    // play can fail on safari if audio is not being captured.
    var onVisibilityChange = function (isVisible) {
        return isVisible ? maybeRestart() : false;
    };
    documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);
    addMediaStreamTrackListeners();
    return function () {
        documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);
        removeMediaStreamTrackListeners();
    };
}
module.exports = mixinLocalMediaTrack;
//# sourceMappingURL=localmediatrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/localtrackpublication.js":
/*!****************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/localtrackpublication.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint new-cap:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackPublication = __webpack_require__(/*! ./trackpublication */ "../../work/twilio-video.js/es5/media/track/trackpublication.js");
var _a = __webpack_require__(/*! ../../util/constants */ "../../work/twilio-video.js/es5/util/constants.js"), E = _a.typeErrors, trackPriority = _a.trackPriority;
/**
 * A {@link LocalTrackPublication} is a {@link LocalTrack} that has been
 * published to a {@link Room}.
 * @extends TrackPublication
 * @property {boolean} isTrackEnabled - whether the published {@link LocalTrack}
 *   is enabled
 * @property {Track.Kind} kind - kind of the published {@link LocalTrack}
 * @property {Track.Priority} priority - the publish priority of the {@link LocalTrack}
 * @property {LocalTrack} track - the {@link LocalTrack}
 */
var LocalTrackPublication = /** @class */ (function (_super) {
    __extends(LocalTrackPublication, _super);
    /**
     * Construct a {@link LocalTrackPublication}.
     * @param {LocalTrackPublicationSignaling} signaling - The corresponding
     *   {@link LocalTrackPublicationSignaling}
     * @param {LocalTrack} track - The {@link LocalTrack}
     * @param {function(LocalTrackPublication): void} unpublish - The callback
     *   that unpublishes the {@link LocalTrackPublication}
     * @param {TrackPublicationOptions} options - {@link LocalTrackPublication}
     *   options
     */
    function LocalTrackPublication(signaling, track, unpublish, options) {
        var _this = _super.call(this, track.name, signaling.sid, options) || this;
        Object.defineProperties(_this, {
            _reemitTrackEvent: {
                value: function () { return _this.emit(_this.isTrackEnabled
                    ? 'trackEnabled'
                    : 'trackDisabled'); }
            },
            _signaling: {
                value: signaling
            },
            _unpublish: {
                value: unpublish
            },
            isTrackEnabled: {
                enumerable: true,
                get: function () {
                    return this.track.kind === 'data' ? true : this.track.isEnabled;
                }
            },
            kind: {
                enumerable: true,
                value: track.kind
            },
            priority: {
                enumerable: true,
                get: function () {
                    return signaling.updatedPriority;
                }
            },
            track: {
                enumerable: true,
                value: track
            }
        });
        track.on('disabled', _this._reemitTrackEvent);
        track.on('enabled', _this._reemitTrackEvent);
        return _this;
    }
    LocalTrackPublication.prototype.toString = function () {
        return "[LocalTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    /**
     * Update the {@link Track.Priority} of the published {@link LocalTrack}.
     * @param {Track.Priority} priority - the new {@link Track.priority}
     * @returns {this}
     * @throws {RangeError}
     */
    LocalTrackPublication.prototype.setPriority = function (priority) {
        var priorityValues = Object.values(trackPriority);
        if (!priorityValues.includes(priority)) {
            throw E.INVALID_VALUE('priority', priorityValues);
        }
        this._signaling.setPriority(priority);
        return this;
    };
    /**
     * Unpublish a {@link LocalTrackPublication}. This means that the media
     * from this {@link LocalTrackPublication} is no longer available to the
     * {@link Room}'s {@link RemoteParticipant}s.
     * @returns {this}
     */
    LocalTrackPublication.prototype.unpublish = function () {
        this.track.removeListener('disabled', this._reemitTrackEvent);
        this.track.removeListener('enabled', this._reemitTrackEvent);
        this._unpublish(this);
        return this;
    };
    return LocalTrackPublication;
}(TrackPublication));
module.exports = LocalTrackPublication;
//# sourceMappingURL=localtrackpublication.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/localvideotrack.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/localvideotrack.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var guessBrowser = __webpack_require__(/*! @twilio/webrtc/lib/util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").guessBrowser;
var detectSilentVideo = __webpack_require__(/*! ../../util/detectsilentvideo */ "../../work/twilio-video.js/es5/util/detectsilentvideo.js");
var mixinLocalMediaTrack = __webpack_require__(/*! ./localmediatrack */ "../../work/twilio-video.js/es5/media/track/localmediatrack.js");
var VideoTrack = __webpack_require__(/*! ./videotrack */ "../../work/twilio-video.js/es5/media/track/videotrack.js");
var LocalMediaVideoTrack = mixinLocalMediaTrack(VideoTrack);
/**
 * A {@link LocalVideoTrack} is a {@link VideoTrack} representing video that
 * your {@link LocalParticipant} can publish to a {@link Room}. It can be
 * enabled and disabled with {@link LocalVideoTrack#enable} and
 * {@link LocalVideoTrack#disable} or stopped completely with
 * {@link LocalVideoTrack#stop}.
 * @extends VideoTrack
 * @property {Track.ID} id - The {@link LocalVideoTrack}'s ID
 * @property {boolean} isStopped - Whether or not the {@link LocalVideoTrack} is
 *   stopped
 * @emits LocalVideoTrack#disabled
 * @emits LocalVideoTrack#enabled
 * @emits LocalVideoTrack#started
 * @emits LocalVideoTrack#stopped
 */
var LocalVideoTrack = /** @class */ (function (_super) {
    __extends(LocalVideoTrack, _super);
    /**
     * Construct a {@link LocalVideoTrack} from a MediaStreamTrack.
     * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack
     * @param {LocalTrackOptions} [options] - {@link LocalTrack} options
     */
    function LocalVideoTrack(mediaStreamTrack, options) {
        var _this = this;
        options = Object.assign({
            workaroundSilentLocalVideo: guessBrowser() === 'safari'
                && typeof document !== 'undefined'
                && typeof document.createElement === 'function'
        }, options);
        _this = _super.call(this, mediaStreamTrack, options) || this;
        Object.defineProperties(_this, {
            _workaroundSilentLocalVideo: {
                value: options.workaroundSilentLocalVideo
                    ? workaroundSilentLocalVideo
                    : null
            },
            _workaroundSilentLocalVideoCleanup: {
                value: null,
                writable: true
            }
        });
        // NOTE(mmalavalli): In iOS Safari, we work around a bug where local video
        // MediaStreamTracks are silent (even though they are enabled, live and unmuted)
        // after accepting/rejecting a phone call.
        if (_this._workaroundSilentLocalVideo) {
            _this._workaroundSilentLocalVideoCleanup = _this._workaroundSilentLocalVideo(_this, document);
        }
        return _this;
    }
    LocalVideoTrack.prototype.toString = function () {
        return "[LocalVideoTrack #" + this._instanceId + ": " + this.id + "]";
    };
    /**
     * @private
     */
    LocalVideoTrack.prototype._checkIfCanCaptureFrames = function () {
        return _super.prototype._checkIfCanCaptureFrames.call(this, this._trackSender.isPublishing);
    };
    /**
     * @private
     */
    LocalVideoTrack.prototype._end = function () {
        return _super.prototype._end.apply(this, arguments);
    };
    /**
     * @private
     */
    LocalVideoTrack.prototype._setSenderMediaStreamTrack = function (useProcessed) {
        var _this = this;
        var unprocessedTrack = this.mediaStreamTrack;
        var mediaStreamTrack = useProcessed ? this.processedTrack : unprocessedTrack;
        return this._trackSender.setMediaStreamTrack(mediaStreamTrack)
            .catch(function (error) { return _this._log.warn('setMediaStreamTrack failed on LocalVideoTrack RTCRtpSender', { error: error, mediaStreamTrack: mediaStreamTrack }); })
            .then(function () {
            _this._unprocessedTrack = useProcessed ? unprocessedTrack : null;
        });
    };
    /**
     * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.
     * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.
     * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.
     * @returns {this}
     * @example
     * class GrayScaleProcessor {
     *   constructor(percentage) {
     *     this.percentage = percentage;
     *   }
     *   processFrame(inputFrameBuffer, outputFrameBuffer) {
     *     const context = outputFrameBuffer.getContext('2d');
     *     context.filter = `grayscale(${this.percentage}%)`;
     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
     *   }
     * }
     *
     * const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;
     * localVideoTrack.addProcessor(new GrayScaleProcessor(100));
     */
    LocalVideoTrack.prototype.addProcessor = function () {
        this._log.debug('Adding VideoProcessor to the LocalVideoTrack');
        var result = _super.prototype.addProcessor.apply(this, arguments);
        if (!this.processedTrack) {
            return this._log.warn('Unable to add a VideoProcessor to the LocalVideoTrack');
        }
        this._log.debug('Updating LocalVideoTrack\'s MediaStreamTrack with the processed MediaStreamTrack', this.processedTrack);
        this._setSenderMediaStreamTrack(true);
        return result;
    };
    /**
     * Remove the previously added {@link VideoProcessor} using `addProcessor` API.
     * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.
     * @returns {this}
     * @example
     * class GrayScaleProcessor {
     *   constructor(percentage) {
     *     this.percentage = percentage;
     *   }
     *   processFrame(inputFrameBuffer, outputFrameBuffer) {
     *     const context = outputFrameBuffer.getContext('2d');
     *     context.filter = `grayscale(${this.percentage}%)`;
     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
     *   }
     * }
     *
     * const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;
     * const grayScaleProcessor = new GrayScaleProcessor(100);
     * localVideoTrack.addProcessor(grayScaleProcessor);
     *
     * document.getElementById('remove-button').onclick = () => localVideoTrack.removeProcessor(grayScaleProcessor);
     */
    LocalVideoTrack.prototype.removeProcessor = function () {
        var _this = this;
        this._log.debug('Removing VideoProcessor from the LocalVideoTrack');
        var result = _super.prototype.removeProcessor.apply(this, arguments);
        this._log.debug('Updating LocalVideoTrack\'s MediaStreamTrack with the original MediaStreamTrack');
        this._setSenderMediaStreamTrack()
            .then(function () { return _this._updateElementsMediaStreamTrack(); });
        return result;
    };
    /**
     * Disable the {@link LocalVideoTrack}. This is effectively "pause".
     * If a {@link VideoProcessor} is added, then `processedTrack` is disabled as well.
     * @returns {this}
     * @fires VideoTrack#disabled
     */
    LocalVideoTrack.prototype.disable = function () {
        var result = _super.prototype.disable.apply(this, arguments);
        if (this.processedTrack) {
            this.processedTrack.enabled = false;
        }
        return result;
    };
    /**
     * Enable the {@link LocalVideoTrack}. This is effectively "unpause".
     * If a {@link VideoProcessor} is added, then `processedTrack` is enabled as well.
     * @returns {this}
     * @fires VideoTrack#enabled
    */ /**
     * Enable or disable the {@link LocalVideoTrack}. This is effectively "unpause"
     * or "pause". If a {@link VideoProcessor} is added,
     * then `processedTrack` is enabled or disabled as well.
     * @param {boolean} [enabled] - Specify false to pause the
     *   {@link LocalVideoTrack}
     * @returns {this}
     * @fires VideoTrack#disabled
     * @fires VideoTrack#enabled
     */
    LocalVideoTrack.prototype.enable = function (enabled) {
        if (enabled === void 0) { enabled = true; }
        var result = _super.prototype.enable.apply(this, arguments);
        if (this.processedTrack) {
            this.processedTrack.enabled = enabled;
            if (enabled) {
                this._captureFrames();
                this._log.debug('Updating LocalVideoTrack\'s MediaStreamTrack with the processed MediaStreamTrack', this.processedTrack);
                this._setSenderMediaStreamTrack(true);
            }
        }
        return result;
    };
    /**
     * Restart the {@link LocalVideoTrack}. This stops the existing MediaStreamTrack
     * and creates a new MediaStreamTrack. If the {@link LocalVideoTrack} is being published
     * to a {@link Room}, then all the {@link RemoteParticipant}s will start receiving media
     * from the newly created MediaStreamTrack. You can access the new MediaStreamTrack via
     * the <code>mediaStreamTrack</code> property. If you want to listen to events on
     * the MediaStreamTrack directly, please do so in the "started" event handler. Also,
     * the {@link LocalVideoTrack}'s ID is no longer guaranteed to be the same as the
     * underlying MediaStreamTrack's ID.
     * @param {MediaTrackConstraints} [constraints] - The optional <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints" target="_blank">MediaTrackConstraints</a>
     *   for restarting the {@link LocalVideoTrack}; If not specified, then the current MediaTrackConstraints
     *   will be used; If <code>{}</code> (empty object) is specified, then the default MediaTrackConstraints
     *   will be used
     * @returns {Promise<void>} Rejects with a TypeError if the {@link LocalVideoTrack} was not created
     *   using an one of <code>createLocalVideoTrack</code>, <code>createLocalTracks</code> or <code>connect</code>;
     *   Also rejects with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Exceptions" target="_blank">DOMException</a>
     *   raised by <code>getUserMedia</code> when it fails
     * @fires LocalVideoTrack#stopped
     * @fires LocalVideoTrack#started
     * @example
     * const { connect, createLocalVideoTrack } = require('twilio-video');
     *
     * // Create a LocalVideoTrack that captures video from the front-facing camera.
     * createLocalVideoTrack({ facingMode: 'user' }).then(function(localVideoTrack) {
     *   return connect('token', {
     *     name: 'my-cool-room',
     *     tracks: [localVideoTrack]
     *   });
     * }).then(function(room) {
     *   // Restart the LocalVideoTrack to capture video from the back-facing camera.
     *   const localVideoTrack = Array.from(room.localParticipant.videoTracks.values())[0].track;
     *   return localVideoTrack.restart({ facingMode: 'environment' });
     * });
     */
    LocalVideoTrack.prototype.restart = function () {
        var _this = this;
        if (this._workaroundSilentLocalVideoCleanup) {
            this._workaroundSilentLocalVideoCleanup();
            this._workaroundSilentLocalVideoCleanup = null;
        }
        var promise = _super.prototype.restart.apply(this, arguments);
        if (this.processor) {
            promise.then(function () {
                _this._restartProcessor();
            });
        }
        if (this._workaroundSilentLocalVideo) {
            promise.finally(function () {
                _this._workaroundSilentLocalVideoCleanup = _this._workaroundSilentLocalVideo(_this, document);
            });
        }
        return promise;
    };
    /**
     * Calls stop on the underlying MediaStreamTrack. If you choose to stop a
     * {@link LocalVideoTrack}, you should unpublish it after stopping.
     * @returns {this}
     * @fires LocalVideoTrack#stopped
     */
    LocalVideoTrack.prototype.stop = function () {
        if (this._workaroundSilentLocalVideoCleanup) {
            this._workaroundSilentLocalVideoCleanup();
            this._workaroundSilentLocalVideoCleanup = null;
        }
        return _super.prototype.stop.apply(this, arguments);
    };
    return LocalVideoTrack;
}(LocalMediaVideoTrack));
/**
 * Work around a bug where local video MediaStreamTracks are silent (even though
 * they are enabled, live and unmuted) after accepting/rejecting a phone call.
 * @private
 * @param {LocalVideoTrack} localVideoTrack
 * @param {HTMLDocument} doc
 * @returns {function} Cleans up listeners attached by the workaround
 */
function workaroundSilentLocalVideo(localVideoTrack, doc) {
    var log = localVideoTrack._log;
    var el = localVideoTrack._dummyEl, mediaStreamTrack = localVideoTrack.mediaStreamTrack;
    function onUnmute() {
        if (!localVideoTrack.isEnabled) {
            return;
        }
        log.info('Unmuted, checking silence');
        // The dummy element is paused, so play it and then detect silence.
        el.play().then(function () { return detectSilentVideo(el, doc); }).then(function (isSilent) {
            if (!isSilent) {
                log.info('Non-silent frames detected, so no need to restart');
                return;
            }
            log.warn('Silence detected, restarting');
            // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack
            // without stopping it first, then a NotReadableError is raised. Hence,
            // we stop the MediaStreamTrack here.
            localVideoTrack._stop();
            // Restart the LocalVideoTrack.
            // eslint-disable-next-line consistent-return
            return localVideoTrack._restart();
        }).catch(function (error) {
            log.warn('Failed to detect silence and restart:', error);
        }).finally(function () {
            // If silent frames were not detected, then pause the dummy element again.
            el = localVideoTrack._dummyEl;
            if (!el.paused) {
                el.pause();
            }
            // Reset the unmute handler.
            mediaStreamTrack.removeEventListener('unmute', onUnmute);
            mediaStreamTrack = localVideoTrack.mediaStreamTrack;
            mediaStreamTrack.addEventListener('unmute', onUnmute);
        });
    }
    // Set the unmute handler.
    mediaStreamTrack.addEventListener('unmute', onUnmute);
    return function () {
        mediaStreamTrack.removeEventListener('unmute', onUnmute);
    };
}
/**
 * The {@link LocalVideoTrack} was disabled, i.e. "muted".
 * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was
 *   disabled
 * @event LocalVideoTrack#disabled
 */
/**
 * The {@link LocalVideoTrack} was enabled, i.e. "unmuted".
 * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that was enabled
 * @event LocalVideoTrack#enabled
 */
/**
 * The {@link LocalVideoTrack} started. This means there is enough video data
 * to begin playback.
 * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that started
 * @event LocalVideoTrack#started
 */
/**
 * The {@link LocalVideoTrack} stopped, either because {@link LocalVideoTrack#stop}
 * or {@link LocalVideoTrack#restart} was called or because the underlying
 * MediaStreamTrack ended.
 * @param {LocalVideoTrack} track - The {@link LocalVideoTrack} that stopped
 * @event LocalVideoTrack#stopped
 */
module.exports = LocalVideoTrack;
//# sourceMappingURL=localvideotrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/localvideotrackpublication.js":
/*!*********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/localvideotrackpublication.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalTrackPublication = __webpack_require__(/*! ./localtrackpublication */ "../../work/twilio-video.js/es5/media/track/localtrackpublication.js");
/**
 * A {@link LocalVideoTrackPublication} is a {@link LocalVideoTrack} that has
 * been published to a {@link Room}.
 * @extends LocalTrackPublication
 * @property {Track.Kind} kind - "video"
 * @property {LocalVideoTrack} track - the {@link LocalVideoTrack}
 */
var LocalVideoTrackPublication = /** @class */ (function (_super) {
    __extends(LocalVideoTrackPublication, _super);
    /**
     * Construct a {@link LocalVideoTrackPublication}.
     * @param {LocalTrackPublicationSignaling} signaling - The corresponding
     *   {@link LocalTrackPublicationSignaling}
     * @param {LocalVideoTrack} track - the {@link LocalVideoTrack}
     * @param {function(LocalTrackPublication): void} unpublish - The callback
     *    that unpublishes the {@link LocalTrackPublication}
     * @param {TrackPublicationOptions} options - {@link LocalTrackPublication} options
     */
    function LocalVideoTrackPublication(signaling, track, unpublish, options) {
        return _super.call(this, signaling, track, unpublish, options) || this;
    }
    LocalVideoTrackPublication.prototype.toString = function () {
        return "[LocalVideoTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return LocalVideoTrackPublication;
}(LocalTrackPublication));
module.exports = LocalVideoTrackPublication;
//# sourceMappingURL=localvideotrackpublication.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/mediatrack.js":
/*!*****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/mediatrack.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var guessBrowser = __webpack_require__(/*! @twilio/webrtc/lib/util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").guessBrowser;
var MediaStream = __webpack_require__(/*! @twilio/webrtc */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/index.js").MediaStream;
var _a = __webpack_require__(/*! ../../util */ "../../work/twilio-video.js/es5/util/index.js"), waitForEvent = _a.waitForEvent, waitForSometime = _a.waitForSometime;
var localMediaRestartDeferreds = __webpack_require__(/*! ../../util/localmediarestartdeferreds */ "../../work/twilio-video.js/es5/util/localmediarestartdeferreds.js");
var Track = __webpack_require__(/*! ./ */ "../../work/twilio-video.js/es5/media/track/index.js");
/**
 * A {@link MediaTrack} represents audio or video that can be sent to or
 * received from a {@link Room}.
 * @extends Track
 * @property {Track.ID} id - This {@link Track}'s ID
 * @property {boolean} isStarted - Whether or not the {@link MediaTrack} has
 *   started
 * @property {boolean} isEnabled - Whether or not the {@link MediaTrack} is
 *   enabled (i.e., whether it is paused or muted)
 * @property {Track.Kind} kind - The kind of the underlying
 *   MediaStreamTrack, "audio" or "video"
 * @property {MediaStreamTrack} mediaStreamTrack - The underlying
 *   MediaStreamTrack
 * @emits MediaTrack#disabled
 * @emits MediaTrack#enabled
 * @emits MediaTrack#started
 */
var MediaTrack = /** @class */ (function (_super) {
    __extends(MediaTrack, _super);
    /**
     * Construct a {@link MediaTrack}.
     * @param {MediaTrackTransceiver} mediaTrackTransceiver
     * @param {{log: Log}} options
     */
    function MediaTrack(mediaTrackTransceiver, options) {
        var _this = this;
        options = Object.assign({
            playPausedElementsIfNotBackgrounded: guessBrowser() === 'safari'
                && typeof document === 'object'
                && typeof document.addEventListener === 'function'
                && typeof document.visibilityState === 'string'
        }, options);
        _this = _super.call(this, mediaTrackTransceiver.id, mediaTrackTransceiver.kind, options) || this;
        var isStarted = false;
        options = Object.assign({
            MediaStream: MediaStream
        }, options);
        /* istanbul ignore next */
        Object.defineProperties(_this, {
            _attachments: {
                value: new Set()
            },
            _dummyEl: {
                value: null,
                writable: true
            },
            _elShims: {
                value: new WeakMap()
            },
            _isStarted: {
                get: function () {
                    return isStarted;
                },
                set: function (_isStarted) {
                    isStarted = _isStarted;
                }
            },
            _playPausedElementsIfNotBackgrounded: {
                value: options.playPausedElementsIfNotBackgrounded
            },
            _shouldShimAttachedElements: {
                value: options.workaroundWebKitBug212780
                    || options.playPausedElementsIfNotBackgrounded
            },
            _unprocessedTrack: {
                value: null,
                writable: true
            },
            _MediaStream: {
                value: options.MediaStream
            },
            isStarted: {
                enumerable: true,
                get: function () {
                    return isStarted;
                }
            },
            mediaStreamTrack: {
                enumerable: true,
                get: function () {
                    return this._unprocessedTrack || mediaTrackTransceiver.track;
                }
            },
            processedTrack: {
                enumerable: true,
                value: null,
                writable: true
            }
        });
        _this._initialize();
        return _this;
    }
    /**
     * @private
     */
    MediaTrack.prototype._start = function () {
        this._log.debug('Started');
        this._isStarted = true;
        if (this._dummyEl) {
            this._dummyEl.oncanplay = null;
        }
        // eslint-disable-next-line no-use-before-define
        this.emit('started', this);
    };
    /**
     * @private
     */
    MediaTrack.prototype._initialize = function () {
        var self = this;
        this._log.debug('Initializing');
        this._dummyEl = this._createElement();
        this.mediaStreamTrack.addEventListener('ended', function onended() {
            self._end();
            self.mediaStreamTrack.removeEventListener('ended', onended);
        });
        if (this._dummyEl) {
            this._dummyEl.muted = true;
            this._dummyEl.oncanplay = this._start.bind(this, this._dummyEl);
            // NOTE(csantos): We always want to attach the original mediaStreamTrack for dummyEl
            this._attach(this._dummyEl, this.mediaStreamTrack);
            this._attachments.delete(this._dummyEl);
        }
    };
    /**
     * @private
     */
    MediaTrack.prototype._end = function () {
        this._log.debug('Ended');
        if (this._dummyEl) {
            this._dummyEl.remove();
            this._dummyEl.srcObject = null;
            this._dummyEl.oncanplay = null;
            this._dummyEl = null;
        }
    };
    MediaTrack.prototype.attach = function (el) {
        var _this = this;
        if (typeof el === 'string') {
            el = this._selectElement(el);
        }
        else if (!el) {
            el = this._createElement();
        }
        this._log.debug('Attempting to attach to element:', el);
        el = this._attach(el);
        if (this._shouldShimAttachedElements && !this._elShims.has(el)) {
            var onUnintentionallyPaused = this._playPausedElementsIfNotBackgrounded
                ? function () { return playIfPausedAndNotBackgrounded(el, _this._log); }
                : null;
            this._elShims.set(el, shimMediaElement(el, onUnintentionallyPaused));
        }
        return el;
    };
    /**
     * Attach the provided MediaStreamTrack to the media element.
     * @param el - The media element to attach to
     * @param mediaStreamTrack - The MediaStreamTrack to attach. If this is
     * not provided, it uses the processedTrack if it exists
     * or it defaults to the current mediaStreamTrack
     * @private
     */
    MediaTrack.prototype._attach = function (el, mediaStreamTrack) {
        if (mediaStreamTrack === void 0) { mediaStreamTrack = this.processedTrack || this.mediaStreamTrack; }
        var mediaStream = el.srcObject;
        if (!(mediaStream instanceof this._MediaStream)) {
            mediaStream = new this._MediaStream();
        }
        var getTracks = mediaStreamTrack.kind === 'audio'
            ? 'getAudioTracks'
            : 'getVideoTracks';
        mediaStream[getTracks]().forEach(function (track) {
            mediaStream.removeTrack(track);
        });
        mediaStream.addTrack(mediaStreamTrack);
        // NOTE(mpatwardhan): resetting `srcObject` here, causes flicker (JSDK-2641), but it lets us
        // to sidestep the a chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1052353
        //
        el.srcObject = mediaStream;
        el.autoplay = true;
        el.playsInline = true;
        if (!this._attachments.has(el)) {
            this._attachments.add(el);
        }
        return el;
    };
    /**
     * @private
     */
    MediaTrack.prototype._selectElement = function (selector) {
        var el = document.querySelector(selector);
        if (!el) {
            throw new Error("Selector matched no element: " + selector);
        }
        return el;
    };
    /**
     * @private
     */
    MediaTrack.prototype._updateElementsMediaStreamTrack = function () {
        var _this = this;
        this._log.debug('Reattaching all elements to update mediaStreamTrack');
        this._getAllAttachedElements().forEach(function (el) { return _this._attach(el); });
    };
    /**
     * @private
     */
    MediaTrack.prototype._createElement = function () {
        return typeof document !== 'undefined'
            ? document.createElement(this.kind)
            : null;
    };
    MediaTrack.prototype.detach = function (el) {
        var els;
        if (typeof el === 'string') {
            els = [this._selectElement(el)];
        }
        else if (!el) {
            els = this._getAllAttachedElements();
        }
        else {
            els = [el];
        }
        this._log.debug('Attempting to detach from elements:', els);
        this._detachElements(els);
        return el ? els[0] : els;
    };
    /**
     * @private
     */
    MediaTrack.prototype._detachElements = function (elements) {
        return elements.map(this._detachElement.bind(this));
    };
    /**
     * @private
     */
    MediaTrack.prototype._detachElement = function (el) {
        if (!this._attachments.has(el)) {
            return el;
        }
        var mediaStream = el.srcObject;
        if (mediaStream instanceof this._MediaStream) {
            mediaStream.removeTrack(this.processedTrack || this.mediaStreamTrack);
        }
        this._attachments.delete(el);
        if (this._shouldShimAttachedElements && this._elShims.has(el)) {
            var shim = this._elShims.get(el);
            shim.unShim();
            this._elShims.delete(el);
        }
        return el;
    };
    /**
     * @private
     */
    MediaTrack.prototype._getAllAttachedElements = function () {
        var els = [];
        this._attachments.forEach(function (el) {
            els.push(el);
        });
        return els;
    };
    return MediaTrack;
}(Track));
/**
 * Play an HTMLMediaElement if it is paused and not backgrounded.
 * @private
 * @param {HTMLMediaElement} el
 * @param {Log} log
 * @returns {void}
 */
function playIfPausedAndNotBackgrounded(el, log) {
    var tag = el.tagName.toLowerCase();
    log.warn('Unintentionally paused:', el);
    // NOTE(mmalavalli): When the element is unintentionally paused, we wait one
    // second for the "onvisibilitychange" event on the HTMLDocument to see if the
    // app will be backgrounded. If not, then the element can be safely played.
    Promise.race([
        waitForEvent(document, 'visibilitychange'),
        waitForSometime(1000)
    ]).then(function () {
        if (document.visibilityState === 'visible') {
            // NOTE(mmalavalli): We play the inadvertently paused elements only after
            // the LocalAudioTrack is unmuted to work around WebKit Bug 213853.
            //
            // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853
            //
            localMediaRestartDeferreds.whenResolved('audio').then(function () {
                log.info("Playing unintentionally paused <" + tag + "> element");
                log.debug('Element:', el);
                return el.play();
            }).then(function () {
                log.info("Successfully played unintentionally paused <" + tag + "> element");
                log.debug('Element:', el);
            }).catch(function (error) {
                log.warn("Error while playing unintentionally paused <" + tag + "> element:", { error: error, el: el });
            });
        }
    });
}
/**
 * Shim the pause() and play() methods of the given HTMLMediaElement so that
 * we can detect if it was paused unintentionally.
 * @param {HTMLMediaElement} el
 * @param {?function} [onUnintentionallyPaused=null]
 * @returns {{pausedIntentionally: function, unShim: function}}
 */
function shimMediaElement(el, onUnintentionallyPaused) {
    if (onUnintentionallyPaused === void 0) { onUnintentionallyPaused = null; }
    var origPause = el.pause;
    var origPlay = el.play;
    var pausedIntentionally = false;
    el.pause = function () {
        pausedIntentionally = true;
        return origPause.call(el);
    };
    el.play = function () {
        pausedIntentionally = false;
        return origPlay.call(el);
    };
    var onPause = onUnintentionallyPaused ? function () {
        if (!pausedIntentionally) {
            onUnintentionallyPaused();
        }
    } : null;
    if (onPause) {
        el.addEventListener('pause', onPause);
    }
    return {
        pausedIntentionally: function () {
            return pausedIntentionally;
        },
        unShim: function () {
            el.pause = origPause;
            el.play = origPlay;
            if (onPause) {
                el.removeEventListener('pause', onPause);
            }
        }
    };
}
module.exports = MediaTrack;
//# sourceMappingURL=mediatrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/receiver.js":
/*!***************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/receiver.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaTrackTransceiver = __webpack_require__(/*! ./transceiver */ "../../work/twilio-video.js/es5/media/track/transceiver.js");
/**
 * A {@link MediaTrackReceiver} represents a remote MediaStreamTrack.
 * @extends MediaTrackTransceiver
 */
var MediaTrackReceiver = /** @class */ (function (_super) {
    __extends(MediaTrackReceiver, _super);
    /**
     * Construct a {@link MediaTrackReceiver}.
     * @param {Track.ID} id - The MediaStreamTrack ID signaled through RSP/SDP
     * @param {MediaStreamTrack} mediaStreamTrack - The remote MediaStreamTrack
     */
    function MediaTrackReceiver(id, mediaStreamTrack) {
        return _super.call(this, id, mediaStreamTrack) || this;
    }
    return MediaTrackReceiver;
}(MediaTrackTransceiver));
module.exports = MediaTrackReceiver;
//# sourceMappingURL=receiver.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/remoteaudiotrack.js":
/*!***********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/remoteaudiotrack.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var AudioTrack = __webpack_require__(/*! ./audiotrack */ "../../work/twilio-video.js/es5/media/track/audiotrack.js");
var mixinRemoteMediaTrack = __webpack_require__(/*! ./remotemediatrack */ "../../work/twilio-video.js/es5/media/track/remotemediatrack.js");
var RemoteMediaAudioTrack = mixinRemoteMediaTrack(AudioTrack);
/**
 * A {@link RemoteAudioTrack} represents an {@link AudioTrack} published to a
 * {@link Room} by a {@link RemoteParticipant}.
 * @extends AudioTrack
 * @property {boolean} isEnabled - Whether the {@link RemoteAudioTrack} is enabled
 * @property {boolean} isSwitchedOff - Whether the {@link RemoteAudioTrack} is switched off
 * @property {Track.SID} sid - The {@link RemoteAudioTrack}'s SID
 * @property {?Track.Priority} priority - The subscribe priority of the {@link RemoteAudioTrack}
 * @emits RemoteAudioTrack#disabled
 * @emits RemoteAudioTrack#enabled
 * @emits RemoteAudioTrack#started
 * @emits RemoteAudioTrack#switchedOff
 * @emits RemoteAudioTrack#switchedOn
 */
var RemoteAudioTrack = /** @class */ (function (_super) {
    __extends(RemoteAudioTrack, _super);
    /**
     * Construct a {@link RemoteAudioTrack}.
     * @param {Track.SID} sid - The {@link RemoteAudioTrack}'s SID
     * @param {MediaTrackReceiver} mediaTrackReceiver - An audio MediaStreamTrack container
     * @param {boolean} isEnabled - Whether the {@link RemoteAudioTrack} is enabled
     * @param {boolean} isSwitchedOff - Whether the {@link RemoteAudioTrack} is switched off
     * @param {function(?Track.Priority): void} setPriority - Set or clear the subscribe
     *  {@link Track.Priority} of the {@link RemoteAudioTrack}
     * @param {function(ClientRenderHint): void} setRenderHint - Set render hints.
     * @param {{log: Log}} options - The {@link RemoteTrack} options
     */
    function RemoteAudioTrack(sid, mediaTrackReceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options) {
        return _super.call(this, sid, mediaTrackReceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options) || this;
    }
    RemoteAudioTrack.prototype.toString = function () {
        return "[RemoteAudioTrack #" + this._instanceId + ": " + this.sid + "]";
    };
    /**
     * Update the subscribe {@link Track.Priority} of the {@link RemoteAudioTrack}.
     * @param {?Track.Priority} priority - the new subscribe {@link Track.Priority};
     *   Currently setPriority has no effect on audio tracks.
     * @returns {this}
     * @throws {RangeError}
     */
    RemoteAudioTrack.prototype.setPriority = function (priority) {
        return _super.prototype.setPriority.call(this, priority);
    };
    return RemoteAudioTrack;
}(RemoteMediaAudioTrack));
/**
 * The {@link RemoteAudioTrack} was disabled, i.e. "muted".
 * @param {RemoteAudioTrack} track - The {@link RemoteAudioTrack} that was
 *   disabled
 * @event RemoteAudioTrack#disabled
 */
/**
 * The {@link RemoteAudioTrack} was enabled, i.e. "unmuted".
 * @param {RemoteAudioTrack} track - The {@link RemoteAudioTrack} that was
 *   enabled
 * @event RemoteAudioTrack#enabled
 */
/**
 * The {@link RemoteAudioTrack} started. This means there is enough audio data
 * to begin playback.
 * @param {RemoteAudioTrack} track - The {@link RemoteAudioTrack} that started
 * @event RemoteAudioTrack#started
 */
/**
 * A {@link RemoteAudioTrack} was switched off.
 * @param {RemoteAudioTrack} track - The {@link RemoteAudioTrack} that was
 *   switched off
 * @event RemoteAudioTrack#switchedOff
 */
/**
 * A {@link RemoteAudioTrack} was switched on.
 * @param {RemoteAudioTrack} track - The {@link RemoteAudioTrack} that was
 *   switched on
 * @event RemoteAudioTrack#switchedOn
 */
module.exports = RemoteAudioTrack;
//# sourceMappingURL=remoteaudiotrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/remoteaudiotrackpublication.js":
/*!**********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/remoteaudiotrackpublication.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteTrackPublication = __webpack_require__(/*! ./remotetrackpublication */ "../../work/twilio-video.js/es5/media/track/remotetrackpublication.js");
/**
 * A {@link RemoteAudioTrackPublication} represents a {@link RemoteAudioTrack}
 * that has been published to a {@link Room}.
 * @property {Track.Kind} kind - "audio"
 * @property {?RemoteAudioTrack} track - unless you have subscribed to the
 *   {@link RemoteAudioTrack}, this property is null
 * @emits RemoteAudioTrackPublication#subscribed
 * @emits RemoteAudioTrackPublication#subscriptionFailed
 * @emits RemoteAudioTrackPublication#trackDisabled
 * @emits RemoteAudioTrackPublication#trackEnabled
 * @emits RemoteAudioTrackPublication#unsubscribed
 */
var RemoteAudioTrackPublication = /** @class */ (function (_super) {
    __extends(RemoteAudioTrackPublication, _super);
    /**
     * Construct a {@link RemoteAudioTrackPublication}.
     * @param {RemoteTrackPublicationSignaling} signaling - {@link RemoteTrackPublication} signaling
     * @param {RemoteTrackPublicationOptions} options - {@link RemoteTrackPublication}
     *   options
     */
    function RemoteAudioTrackPublication(signaling, options) {
        return _super.call(this, signaling, options) || this;
    }
    RemoteAudioTrackPublication.prototype.toString = function () {
        return "[RemoteAudioTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return RemoteAudioTrackPublication;
}(RemoteTrackPublication));
/**
 * Your {@link LocalParticipant} subscribed to the {@link RemoteAudioTrack}.
 * @param {RemoteAudioTrack} track - the {@link RemoteAudioTrack} that was subscribed to
 * @event RemoteAudioTrackPublication#subscribed
 */
/**
 * Your {@link LocalParticipant} failed to subscribe to the {@link RemoteAudioTrack}.
 * @param {TwilioError} error - the reason the {@link RemoteAudioTrack} could not be
 *   subscribed to
 * @event RemoteAudioTrackPublication#subscriptionFailed
 */
/**
 * The {@link RemoteAudioTrack} was disabled.
 * @event RemoteAudioTrackPublication#trackDisabled
 */
/**
 * The {@link RemoteAudioTrack} was enabled.
 * @event RemoteAudioTrackPublication#trackEnabled
 */
/**
 * Your {@link LocalParticipant} unsubscribed from the {@link RemoteAudioTrack}.
 * @param {RemoteAudioTrack} track - the {@link RemoteAudioTrack} that was unsubscribed from
 * @event RemoteAudioTrackPublication#unsubscribed
 */
module.exports = RemoteAudioTrackPublication;
//# sourceMappingURL=remoteaudiotrackpublication.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/remotedatatrack.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/remotedatatrack.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var Track = __webpack_require__(/*! ./ */ "../../work/twilio-video.js/es5/media/track/index.js");
var _a = __webpack_require__(/*! ../../util/constants */ "../../work/twilio-video.js/es5/util/constants.js"), E = _a.typeErrors, trackPriority = _a.trackPriority;
/**
 * A {@link RemoteDataTrack} represents data published to a {@link Room} by a
 * {@link RemoteParticipant}.
 * @extends Track
 * @property {boolean} isEnabled - true
 * @property {boolean} isSubscribed - Whether the {@link RemoteDataTrack} is
 *   subscribed to
 * @property {boolean} isSwitchedOff - Whether the {@link RemoteDataTrack} is
 *   switched off
 * @property {Track.Kind} kind - "data"
 * @property {?number} maxPacketLifeTime - If non-null, this represents a time
 *   limit (in milliseconds) during which data will be transmitted or
 *   retransmitted if not acknowledged on the underlying RTCDataChannel.
 * @property {?number} maxRetransmits - If non-null, this represents the number
 *   of times the data will be retransmitted if not successfully received on the
 *   underlying RTCDataChannel.
 * @property {boolean} ordered - true if data on the {@link RemoteDataTrack} can
 *   be received out-of-order.
 * @property {?Track.Priority} priority - The subscribe priority of the {@link RemoteDataTrack}
 * @property {boolean} reliable - This is true if both
 *   <code>maxPacketLifeTime</code> and <code>maxRetransmits</code> are set to
 *   null. In other words, if this is true, there is no bound on packet lifetime
 *   or the number of retransmits that will be attempted, ensuring "reliable"
 *   transmission.
 * @property {Track.SID} sid - The SID assigned to the {@link RemoteDataTrack}
 * @emits RemoteDataTrack#message
 * @emits RemoteDataTrack#switchedOff
 * @emits RemoteDataTrack#switchedOn
 */
var RemoteDataTrack = /** @class */ (function (_super) {
    __extends(RemoteDataTrack, _super);
    /**
     * Construct a {@link RemoteDataTrack} from a {@link DataTrackReceiver}.
     * @param {Track.SID} sid
     * @param {DataTrackReceiver} dataTrackReceiver
     * @param {{log: Log, name: ?string}} options
     */
    function RemoteDataTrack(sid, dataTrackReceiver, options) {
        var _this = _super.call(this, dataTrackReceiver.id, 'data', options) || this;
        Object.defineProperties(_this, {
            _isSwitchedOff: {
                value: false,
                writable: true
            },
            _priority: {
                value: null,
                writable: true
            },
            isEnabled: {
                enumerable: true,
                value: true
            },
            isSwitchedOff: {
                enumerable: true,
                get: function () {
                    return this._isSwitchedOff;
                }
            },
            maxPacketLifeTime: {
                enumerable: true,
                value: dataTrackReceiver.maxPacketLifeTime
            },
            maxRetransmits: {
                enumerable: true,
                value: dataTrackReceiver.maxRetransmits
            },
            ordered: {
                enumerable: true,
                value: dataTrackReceiver.ordered
            },
            priority: {
                enumerable: true,
                get: function () {
                    return this._priority;
                }
            },
            reliable: {
                enumerable: true,
                value: dataTrackReceiver.maxPacketLifeTime === null
                    && dataTrackReceiver.maxRetransmits === null
            },
            sid: {
                enumerable: true,
                value: sid
            }
        });
        dataTrackReceiver.on('message', function (data) {
            _this.emit('message', data, _this);
        });
        return _this;
    }
    /**
     * Update the subscriber {@link Track.Priority} of the {@link RemoteDataTrack}.
     * @param {?Track.Priority} priority - the new {@link Track.priority};
     *   Currently setPriority has no effect on data tracks.
     * @returns {this}
     * @throws {RangeError}
     */
    RemoteDataTrack.prototype.setPriority = function (priority) {
        var priorityValues = __spreadArray([null], __read(Object.values(trackPriority)));
        if (!priorityValues.includes(priority)) {
            // eslint-disable-next-line new-cap
            throw E.INVALID_VALUE('priority', priorityValues);
        }
        // Note: priority has no real effect on the data tracks.
        this._priority = priority;
        return this;
    };
    /**
     * @private
     */
    RemoteDataTrack.prototype._setEnabled = function () {
        // Do nothing.
    };
    /**
     * @private
     * @param {boolean} isSwitchedOff
     */
    RemoteDataTrack.prototype._setSwitchedOff = function (isSwitchedOff) {
        if (this._isSwitchedOff !== isSwitchedOff) {
            this._isSwitchedOff = isSwitchedOff;
            this.emit(isSwitchedOff ? 'switchedOff' : 'switchedOn', this);
        }
    };
    return RemoteDataTrack;
}(Track));
/**
 * A message was received over the {@link RemoteDataTrack}.
 * @event RemoteDataTrack#message
 * @param {string|ArrayBuffer} data
 * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} that received
 *   the message
 */
/**
 * A {@link RemoteDataTrack} was switched off.
 * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} that was
 *   switched off
 * @event RemoteDataTrack#switchedOff
 */
/**
 * A {@link RemoteDataTrack} was switched on.
 * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} that was
 *   switched on
 * @event RemoteDataTrack#switchedOn
 */
module.exports = RemoteDataTrack;
//# sourceMappingURL=remotedatatrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/remotedatatrackpublication.js":
/*!*********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/remotedatatrackpublication.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteTrackPublication = __webpack_require__(/*! ./remotetrackpublication */ "../../work/twilio-video.js/es5/media/track/remotetrackpublication.js");
/**
 * A {@link RemoteDataTrackPublication} represents a {@link RemoteDataTrack}
 * that has been published to a {@link Room}.
 * @property {Track.Kind} kind - "data"
 * @property {?RemoteDataTrack} track - unless you have subscribed to the
 *   {@link RemoteDataTrack}, this property is null
 * @emits RemoteDataTrackPublication#subscribed
 * @emits RemoteDataTrackPublication#subscriptionFailed
 * @emits RemoteDataTrackPublication#unsubscribed
 */
var RemoteDataTrackPublication = /** @class */ (function (_super) {
    __extends(RemoteDataTrackPublication, _super);
    /**
     * Construct a {@link RemoteDataTrackPublication}.
     * @param {RemoteTrackPublicationSignaling} signaling - {@link RemoteTrackPublication} signaling
     * @param {RemoteTrackPublicationOptions} options - {@link RemoteTrackPublication}
     *   options
     */
    function RemoteDataTrackPublication(signaling, options) {
        return _super.call(this, signaling, options) || this;
    }
    RemoteDataTrackPublication.prototype.toString = function () {
        return "[RemoteDataTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return RemoteDataTrackPublication;
}(RemoteTrackPublication));
/**
 * Your {@link LocalParticipant} subscribed to the {@link RemoteDataTrack}.
 * @param {RemoteDataTrack} track - the {@link RemoteDataTrack} that was subscribed to
 * @event RemoteDataTrackPublication#subscribed
 */
/**
 * Your {@link LocalParticipant} failed to subscribe to the {@link RemoteDataTrack}.
 * @param {TwilioError} error - the reason the {@link RemoteDataTrack} could not be
 *   subscribed to
 * @event RemoteDataTrackPublication#subscriptionFailed
 */
/**
 * Your {@link LocalParticipant} unsubscribed from the {@link RemoteDataTrack}.
 * @param {RemoteDataTrack} track - the {@link RemoteDataTrack} that was unsubscribed from
 * @event RemoteDataTrackPublication#unsubscribed
 */
module.exports = RemoteDataTrackPublication;
//# sourceMappingURL=remotedatatrackpublication.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/remotemediatrack.js":
/*!***********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/remotemediatrack.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var _a = __webpack_require__(/*! ../../util/constants */ "../../work/twilio-video.js/es5/util/constants.js"), E = _a.typeErrors, trackPriority = _a.trackPriority;
var guessBrowser = __webpack_require__(/*! @twilio/webrtc/lib/util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").guessBrowser;
var documentVisibilityMonitor = __webpack_require__(/*! ../../util/documentvisibilitymonitor.js */ "../../work/twilio-video.js/es5/util/documentvisibilitymonitor.js");
function mixinRemoteMediaTrack(AudioOrVideoTrack) {
    /**
     * A {@link RemoteMediaTrack} represents a {@link MediaTrack} published to a
     * {@link Room} by a {@link RemoteParticipant}.
     * @property {boolean} isEnabled - Whether the {@link RemoteMediaTrack} is enabled
     * @property {boolean} isSwitchedOff - Whether the {@link RemoteMediaTrack} is switched off
     * @property {Track.SID} sid - The SID assigned to the {@link RemoteMediaTrack}
     * @property {?Track.Priority} priority - The subscribe priority of the {@link RemoteMediaTrack}
     * @emits RemoteMediaTrack#disabled
     * @emits RemoteMediaTrack#enabled
     * @emits RemoteMediaTrack#switchedOff
     * @emits RemoteMediaTrack#switchedOn
     */
    return /** @class */ (function (_super) {
        __extends(RemoteMediaTrack, _super);
        /**
         * Construct a {@link RemoteMediaTrack}.
         * @param {Track.SID} sid
         * @param {MediaTrackReceiver} mediaTrackReceiver
         * @param {boolean} isEnabled
          @param {boolean} isSwitchedOff
         * @param {function(?Track.Priority): void} setPriority - Set or clear the subscribe
         *  {@link Track.Priority} of the {@link RemoteMediaTrack}
         * @param {function(ClientRenderHint): void} setRenderHint - Set render hints.
         * @param {{log: Log, name: ?string}} options
         */
        function RemoteMediaTrack(sid, mediaTrackReceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options) {
            var _this = this;
            options = Object.assign({
                // NOTE(mpatwardhan): WebKit bug: 212780 sometimes causes the audio/video elements to stay paused when safari
                // regains foreground. To workaround it, when safari gains foreground - we will play any elements that were
                // playing before safari lost foreground.
                workaroundWebKitBug212780: guessBrowser() === 'safari'
                    && typeof document === 'object'
                    && typeof document.addEventListener === 'function'
                    && typeof document.visibilityState === 'string'
            }, options);
            _this = _super.call(this, mediaTrackReceiver, options) || this;
            Object.defineProperties(_this, {
                _isEnabled: {
                    value: isEnabled,
                    writable: true
                },
                _isSwitchedOff: {
                    value: isSwitchedOff,
                    writable: true
                },
                _priority: {
                    value: null,
                    writable: true
                },
                _setPriority: {
                    value: setPriority
                },
                _setRenderHint: {
                    value: function (renderHint) {
                        _this._log.debug('updating render hint:', renderHint);
                        setRenderHint(renderHint);
                    }
                },
                isEnabled: {
                    enumerable: true,
                    get: function () {
                        return this._isEnabled;
                    }
                },
                isSwitchedOff: {
                    enumerable: true,
                    get: function () {
                        return this._isSwitchedOff;
                    }
                },
                priority: {
                    enumerable: true,
                    get: function () {
                        return this._priority;
                    }
                },
                sid: {
                    enumerable: true,
                    value: sid
                },
                _workaroundWebKitBug212780: {
                    value: options.workaroundWebKitBug212780
                },
                _workaroundWebKitBug212780Cleanup: {
                    value: null,
                    writable: true
                }
            });
            return _this;
        }
        /**
         * Update the subscribe {@link Track.Priority} of the {@link RemoteMediaTrack}.
         * @param {?Track.Priority} priority - the new subscribe {@link Track.Priority};
         *   If <code>null</code>, then the subscribe {@link Track.Priority} is cleared, which
         *   means the {@link Track.Priority} set by the publisher is now the effective priority.
         * @returns {this}
         * @throws {RangeError}
         */
        RemoteMediaTrack.prototype.setPriority = function (priority) {
            var priorityValues = __spreadArray([null], __read(Object.values(trackPriority)));
            if (!priorityValues.includes(priority)) {
                // eslint-disable-next-line new-cap
                throw E.INVALID_VALUE('priority', priorityValues);
            }
            if (this._priority !== priority) {
                this._priority = priority;
                this._setPriority(priority);
            }
            return this;
        };
        /**
         * @private
         * @param {boolean} isEnabled
         */
        RemoteMediaTrack.prototype._setEnabled = function (isEnabled) {
            if (this._isEnabled !== isEnabled) {
                this._isEnabled = isEnabled;
                this.emit(this._isEnabled ? 'enabled' : 'disabled', this);
            }
        };
        /**
         * @private
         * @param {boolean} isSwitchedOff
         */
        RemoteMediaTrack.prototype._setSwitchedOff = function (isSwitchedOff) {
            if (this._isSwitchedOff !== isSwitchedOff) {
                this._isSwitchedOff = isSwitchedOff;
                this.emit(isSwitchedOff ? 'switchedOff' : 'switchedOn', this);
            }
        };
        RemoteMediaTrack.prototype.attach = function (el) {
            var result = _super.prototype.attach.call(this, el);
            if (this.mediaStreamTrack.enabled !== true) {
                // NOTE(mpatwardhan): we disable mediaStreamTrack when there
                // are no attachments to it (see notes below). Now that there
                // are attachments re-enable the track.
                this.mediaStreamTrack.enabled = true;
                if (this.processedTrack) {
                    this.processedTrack.enabled = true;
                }
                // NOTE(csantos): since remote tracks disables/enables the mediaStreamTrack,
                // captureFrames stops along with it. We need to start it again after re-enabling.
                // See attach/detach methods in this class and in VideoTrack class.
                if (this.processor) {
                    this._captureFrames();
                }
            }
            if (this._workaroundWebKitBug212780) {
                this._workaroundWebKitBug212780Cleanup = this._workaroundWebKitBug212780Cleanup
                    || playIfPausedWhileInBackground(this);
            }
            return result;
        };
        RemoteMediaTrack.prototype.detach = function (el) {
            var result = _super.prototype.detach.call(this, el);
            if (this._attachments.size === 0) {
                // NOTE(mpatwardhan): chrome continues playing webrtc audio
                // track even after audio element is removed from the DOM.
                // https://bugs.chromium.org/p/chromium/issues/detail?id=749928
                // to workaround: here disable the track when
                // there are no elements attached to it.
                this.mediaStreamTrack.enabled = false;
                if (this.processedTrack) {
                    this.processedTrack.enabled = false;
                }
                if (this._workaroundWebKitBug212780Cleanup) {
                    // unhook visibility change
                    this._workaroundWebKitBug212780Cleanup();
                    this._workaroundWebKitBug212780Cleanup = null;
                }
            }
            return result;
        };
        return RemoteMediaTrack;
    }(AudioOrVideoTrack));
}
function playIfPausedWhileInBackground(remoteMediaTrack) {
    var log = remoteMediaTrack._log, kind = remoteMediaTrack.kind;
    function onVisibilityChanged(isVisible) {
        if (!isVisible) {
            return;
        }
        remoteMediaTrack._attachments.forEach(function (el) {
            var shim = remoteMediaTrack._elShims.get(el);
            var isInadvertentlyPaused = el.paused && shim && !shim.pausedIntentionally();
            if (isInadvertentlyPaused) {
                log.info("Playing inadvertently paused <" + kind + "> element");
                log.debug('Element:', el);
                log.debug('RemoteMediaTrack:', remoteMediaTrack);
                el.play().then(function () {
                    log.info("Successfully played inadvertently paused <" + kind + "> element");
                    log.debug('Element:', el);
                    log.debug('RemoteMediaTrack:', remoteMediaTrack);
                }).catch(function (err) {
                    log.warn("Error while playing inadvertently paused <" + kind + "> element:", { err: err, el: el, remoteMediaTrack: remoteMediaTrack });
                });
            }
        });
    }
    // NOTE(mpatwardhan): listen for document visibility callback on phase 2.
    // this ensures that any LocalMediaTrack's restart (which listen on phase 1) gets executed
    // first. This order is important because we `play` tracks in the callback, and
    // play can fail on safari if audio is not being captured.
    documentVisibilityMonitor.onVisibilityChange(2, onVisibilityChanged);
    return function () {
        documentVisibilityMonitor.offVisibilityChange(2, onVisibilityChanged);
    };
}
/**
 * A {@link RemoteMediaTrack} was disabled.
 * @param {RemoteMediaTrack} track - The {@link RemoteMediaTrack} that was
 *   disabled
 * @event RemoteMediaTrack#disabled
 */
/**
 * A {@link RemoteMediaTrack} was enabled.
 * @param {RemoteMediaTrack} track - The {@link RemoteMediaTrack} that was
 *   enabled
 * @event RemoteMediaTrack#enabled
 */
/**
 * A {@link RemoteMediaTrack} was switched off.
 * @param {RemoteMediaTrack} track - The {@link RemoteMediaTrack} that was
 *   switched off
 * @event RemoteMediaTrack#switchedOff
 */
/**
 * A {@link RemoteMediaTrack} was switched on.
 * @param {RemoteMediaTrack} track - The {@link RemoteMediaTrack} that was
 *   switched on
 * @event RemoteMediaTrack#switchedOn
 */
/**
 * A {@link ClientRenderHint} object specifies track dimensions and /enabled disable state.
 * This state will be used by the server(SFU) to determine bandwidth allocation for the track,
 * and turn it on or off as needed.
 * @typedef {object} ClientRenderHint
 * @property {boolean} [enabled] - track is enabled or disabled. defaults to disabled.
 * @property {VideoTrack.Dimensions} [renderDimensions] - Optional parameter to specify the desired
 *   render dimensions of {@link RemoteVideoTrack}s. This property must be specified if enabled=true
 */
module.exports = mixinRemoteMediaTrack;
//# sourceMappingURL=remotemediatrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/remotetrackpublication.js":
/*!*****************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/remotetrackpublication.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackPublication = __webpack_require__(/*! ./trackpublication */ "../../work/twilio-video.js/es5/media/track/trackpublication.js");
/**
 * A {@link RemoteTrackPublication} represents a {@link RemoteTrack} that has
 * been published to a {@link Room}.
 * @extends TrackPublication
 * @property {boolean} isSubscribed - whether the published {@link RemoteTrack}
 *   is subscribed to
 * @property {boolean} isTrackEnabled - whether the published
 *   {@link RemoteTrack} is enabled
 * @property {Track.Kind} kind - kind of the published {@link RemoteTrack}
 * @property {Track.Priority} publishPriority - the {@link Track.Priority} of the published
 *   {@link RemoteTrack} set by the {@link RemoteParticipant}
 * @property {?RemoteTrack} track - Unless you have subscribed to the
 *   {@link RemoteTrack}, this property is null
 * @emits RemoteTrackPublication#publishPriorityChanged
 * @emits RemoteTrackPublication#subscribed
 * @emits RemoteTrackPublication#subscriptionFailed
 * @emits RemoteTrackPublication#trackDisabled
 * @emits RemoteTrackPublication#trackEnabled
 * @emits RemoteTrackPublication#trackSwitchedOff
 * @emits RemoteTrackPublication#trackSwitchedOn
 * @emits RemoteTrackPublication#unsubscribed
 *
 */
var RemoteTrackPublication = /** @class */ (function (_super) {
    __extends(RemoteTrackPublication, _super);
    /**
     * Construct a {@link RemoteTrackPublication}.
     * @param {RemoteTrackPublicationSignaling} signaling - {@link RemoteTrackPublication} signaling
     * @param {RemoteTrackPublicationOptions} options - {@link RemoteTrackPublication}
     *   options
     */
    function RemoteTrackPublication(signaling, options) {
        var _this = _super.call(this, signaling.name, signaling.sid, options) || this;
        Object.defineProperties(_this, {
            _signaling: {
                value: signaling
            },
            _track: {
                value: null,
                writable: true
            },
            isSubscribed: {
                enumerable: true,
                get: function () {
                    return !!this._track;
                }
            },
            isTrackEnabled: {
                enumerable: true,
                get: function () {
                    return signaling.isEnabled;
                }
            },
            kind: {
                enumerable: true,
                value: signaling.kind
            },
            publishPriority: {
                enumerable: true,
                get: function () {
                    return signaling.priority;
                }
            },
            track: {
                enumerable: true,
                get: function () {
                    return this._track;
                }
            }
        });
        // remember original state, and fire events only on change.
        var error = signaling.error, isEnabled = signaling.isEnabled, isSwitchedOff = signaling.isSwitchedOff, priority = signaling.priority;
        signaling.on('updated', function () {
            if (error !== signaling.error) {
                error = signaling.error;
                _this.emit('subscriptionFailed', signaling.error);
                return;
            }
            if (isEnabled !== signaling.isEnabled) {
                isEnabled = signaling.isEnabled;
                if (_this.track) {
                    _this.track._setEnabled(signaling.isEnabled);
                }
                _this.emit(signaling.isEnabled ? 'trackEnabled' : 'trackDisabled');
            }
            if (isSwitchedOff !== signaling.isSwitchedOff) {
                _this._log.debug(_this.trackSid + ": " + (isSwitchedOff ? 'OFF' : 'ON') + " => " + (signaling.isSwitchedOff ? 'OFF' : 'ON'));
                isSwitchedOff = signaling.isSwitchedOff;
                if (_this.track) {
                    _this.track._setSwitchedOff(signaling.isSwitchedOff);
                    _this.emit(isSwitchedOff ? 'trackSwitchedOff' : 'trackSwitchedOn', _this.track);
                }
                else if (isSwitchedOff) {
                    _this._log.warn('Track was not subscribed when switched Off.');
                }
            }
            if (priority !== signaling.priority) {
                priority = signaling.priority;
                _this.emit('publishPriorityChanged', priority);
            }
        });
        return _this;
    }
    RemoteTrackPublication.prototype.toString = function () {
        return "[RemoteTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    /**
     * @private
     * @param {RemoteTrack} track
     */
    RemoteTrackPublication.prototype._subscribed = function (track) {
        if (!this._track && track) {
            this._track = track;
            this.emit('subscribed', track);
        }
    };
    /**
     * @private
     */
    RemoteTrackPublication.prototype._unsubscribe = function () {
        if (this._track) {
            var track = this._track;
            this._track = null;
            this.emit('unsubscribed', track);
        }
    };
    return RemoteTrackPublication;
}(TrackPublication));
/**
 * The {@link RemoteTrack}'s publish {@link Track.Priority} was changed by the
 * {@link RemoteParticipant}.
 * @param {Track.Priority} priority - the {@link RemoteTrack}'s new publish
 *   {@link Track.Priority}; RemoteTrackPublication#publishPriority is also
 *   updated accordingly
 * @event RemoteTrackPublication#publishPriorityChanged
 */
/**
 * Your {@link LocalParticipant} subscribed to the {@link RemoteTrack}.
 * @param {RemoteTrack} track - the {@link RemoteTrack} that was subscribed to
 * @event RemoteTrackPublication#subscribed
 */
/**
 * Your {@link LocalParticipant} failed to subscribe to the {@link RemoteTrack}.
 * @param {TwilioError} error - the reason the {@link RemoteTrack} could not be
 *   subscribed to
 * @event RemoteTrackPublication#subscriptionFailed
 */
/**
 * The {@link RemoteTrack} was disabled.
 * @event RemoteTrackPublication#trackDisabled
 */
/**
 * The {@link RemoteTrack} was enabled.
 * @event RemoteTrackPublication#trackEnabled
 */
/**
 * The {@link RemoteTrack} was switched off.
 * @param {RemoteTrack} track - the {@link RemoteTrack} that was switched off
 * @event RemoteTrackPublication#trackSwitchedOff
 */
/**
 * The {@link RemoteTrack} was switched on.
 * @param {RemoteTrack} track - the {@link RemoteTrack} that was switched on
 * @event RemoteTrackPublication#trackSwitchedOn
 */
/**
 * Your {@link LocalParticipant} unsubscribed from the {@link RemoteTrack}.
 * @param {RemoteTrack} track - the {@link RemoteTrack} that was unsubscribed from
 * @event RemoteTrackPublication#unsubscribed
 */
/**
 * {@link RemoteTrackPublication} options
 * @typedef {object} RemoteTrackPublicationOptions
 * @property {LogLevel|LogLevels} logLevel - Log level for 'media' modules
 */
module.exports = RemoteTrackPublication;
//# sourceMappingURL=remotetrackpublication.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/remotevideotrack.js":
/*!***********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/remotevideotrack.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var mixinRemoteMediaTrack = __webpack_require__(/*! ./remotemediatrack */ "../../work/twilio-video.js/es5/media/track/remotemediatrack.js");
var VideoTrack = __webpack_require__(/*! ./videotrack */ "../../work/twilio-video.js/es5/media/track/videotrack.js");
var documentVisibilityMonitor = __webpack_require__(/*! ../../util/documentvisibilitymonitor.js */ "../../work/twilio-video.js/es5/util/documentvisibilitymonitor.js");
var NullObserver = __webpack_require__(/*! ../../util/nullobserver.js */ "../../work/twilio-video.js/es5/util/nullobserver.js").NullObserver;
var Timeout = __webpack_require__(/*! ../../util/timeout */ "../../work/twilio-video.js/es5/util/timeout.js");
var RemoteMediaVideoTrack = mixinRemoteMediaTrack(VideoTrack);
var TRACK_TURN_OF_DELAY_MS = 50;
/**
 * A {@link RemoteVideoTrack} represents a {@link VideoTrack} published to a
 * {@link Room} by a {@link RemoteParticipant}.
 * @extends VideoTrack
 * @property {boolean} isEnabled - Whether the {@link RemoteVideoTrack} is enabled
 * @property {boolean} isSwitchedOff - Whether the {@link RemoteVideoTrack} is switched off
 * @property {Track.SID} sid - The {@link RemoteVideoTrack}'s SID
 * @property {?Track.Priority} priority - The subscribe priority of the {@link RemoteVideoTrack}
 * @emits RemoteVideoTrack#dimensionsChanged
 * @emits RemoteVideoTrack#disabled
 * @emits RemoteVideoTrack#enabled
 * @emits RemoteVideoTrack#started
 * @emits RemoteVideoTrack#switchedOff
 * @emits RemoteVideoTrack#switchedOn
 */
var RemoteVideoTrack = /** @class */ (function (_super) {
    __extends(RemoteVideoTrack, _super);
    /**
     * Construct a {@link RemoteVideoTrack}.
     * @param {Track.SID} sid - The {@link RemoteVideoTrack}'s SID
     * @param {MediaTrackReceiver} mediaTrackReceiver - A video MediaStreamTrack container
     * @param {boolean} isEnabled - whether the {@link RemoteVideoTrack} is enabled
     * @param {boolean} isSwitchedOff - Whether the {@link RemoteVideoTrack} is switched off
     * @param {function(?Track.Priority): void} setPriority - Set or clear the subscribe
     *  {@link Track.Priority} of the {@link RemoteVideoTrack}
     * @param {function(ClientRenderHint): void} setRenderHint - Set render hints.
     * @param {{log: Log}} options - The {@link RemoteTrack} options
     */
    function RemoteVideoTrack(sid, mediaTrackReceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options) {
        var _this = this;
        options = Object.assign({
            clientTrackSwitchOffControl: 'auto',
            contentPreferencesMode: 'auto',
            enableDocumentVisibilityTurnOff: true,
        }, options);
        options = Object.assign({
            IntersectionObserver: typeof IntersectionObserver === 'undefined' || options.clientTrackSwitchOffControl !== 'auto' ? NullObserver : IntersectionObserver,
            ResizeObserver: typeof ResizeObserver === 'undefined' || options.contentPreferencesMode !== 'auto' ? NullObserver : ResizeObserver,
        }, options);
        _this = _super.call(this, sid, mediaTrackReceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options) || this;
        Object.defineProperties(_this, {
            _enableDocumentVisibilityTurnOff: {
                value: options.enableDocumentVisibilityTurnOff === true && options.clientTrackSwitchOffControl === 'auto',
            },
            _documentVisibilityTurnOffCleanup: {
                value: null,
                writable: true
            },
            _clientTrackSwitchOffControl: {
                value: options.clientTrackSwitchOffControl,
            },
            _contentPreferencesMode: {
                value: options.contentPreferencesMode,
            },
            _invisibleElements: {
                value: new WeakSet(),
            },
            _turnOffTimer: {
                value: new Timeout(function () {
                    _this._setRenderHint({ enabled: false });
                }, TRACK_TURN_OF_DELAY_MS, false),
            },
            _resizeObserver: {
                value: new options.ResizeObserver(function (entries) {
                    // NOTE(mpatwardhan): we ignore elements in _invisibleElements
                    // to ensure that ResizeObserver does not end-up turning off a track when a fresh Video element is
                    // attached and IntersectionObserver has not had its callback executed yet.
                    var visibleElementResized = entries.find(function (entry) { return !_this._invisibleElements.has(entry.target); });
                    if (visibleElementResized) {
                        maybeUpdateDimensionHint(_this);
                    }
                })
            },
            _intersectionObserver: {
                value: new options.IntersectionObserver(function (entries) {
                    var shouldSetRenderHint = false;
                    entries.forEach(function (entry) {
                        var wasVisible = !_this._invisibleElements.has(entry.target);
                        if (wasVisible !== entry.isIntersecting) {
                            if (entry.isIntersecting) {
                                _this._log.debug('intersectionObserver detected: Off => On');
                                _this._invisibleElements.delete(entry.target);
                            }
                            else {
                                _this._log.debug('intersectionObserver detected: On => Off');
                                _this._invisibleElements.add(entry.target);
                            }
                            shouldSetRenderHint = true;
                        }
                    });
                    if (shouldSetRenderHint) {
                        maybeUpdateEnabledHint(_this);
                        // when visibility of an element changes that may cause the "biggest" element to change,
                        // update dimensions as well. since dimensions are cached and de-duped at signaling layer,
                        // its okay if they got  resent.
                        maybeUpdateDimensionHint(_this);
                    }
                }, { threshold: 0.25 })
            },
        });
        return _this;
    }
    /**
     * @private
     */
    RemoteVideoTrack.prototype._start = function (dummyEl) {
        var result = _super.prototype._start.call(this, dummyEl);
        // NOTE(mpatwardhan): after emitting started, update turn off track if not visible.
        maybeUpdateEnabledHint(this);
        return result;
    };
    /**
     * Request to switch on a {@link RemoteVideoTrack}, This method is applicable only for the group rooms and only when connected with
     * clientTrackSwitchOffControl in video bandwidth profile options set to 'manual'
     * @returns {this}
     */
    RemoteVideoTrack.prototype.switchOn = function () {
        if (this._clientTrackSwitchOffControl !== 'manual') {
            throw new Error('Invalid state. You can call switchOn only when bandwidthProfile.video.clientTrackSwitchOffControl is set to "manual"');
        }
        this._setRenderHint({ enabled: true });
        return this;
    };
    /**
     * Request to switch off a {@link RemoteVideoTrack}, This method is applicable only for the group rooms and only when connected with
     * clientTrackSwitchOffControl in video bandwidth profile options set to 'manual'
     * @returns {this}
     */
    RemoteVideoTrack.prototype.switchOff = function () {
        if (this._clientTrackSwitchOffControl !== 'manual') {
            throw new Error('Invalid state. You can call switchOff only when bandwidthProfile.video.clientTrackSwitchOffControl is set to "manual"');
        }
        this._setRenderHint({ enabled: false });
        return this;
    };
    /**
     * Set the {@link RemoteVideoTrack}'s content preferences. This method is applicable only for the group rooms and only when connected with
     * videoContentPreferencesMode in video bandwidth profile options set to 'manual'
     * @param {VideoContentPreferences} contentPreferences - requested preferences.
     * @returns {this}
     */
    RemoteVideoTrack.prototype.setContentPreferences = function (contentPreferences) {
        if (this._contentPreferencesMode !== 'manual') {
            throw new Error('Invalid state. You can call switchOn only when bandwidthProfile.video.contentPreferencesMode is set to "manual"');
        }
        if (contentPreferences.renderDimensions) {
            this._setRenderHint({ renderDimensions: contentPreferences.renderDimensions });
        }
        return this;
    };
    RemoteVideoTrack.prototype.attach = function (el) {
        var result = _super.prototype.attach.call(this, el);
        if (this._clientTrackSwitchOffControl === 'auto') {
            // start off the element as invisible. will mark it
            // visible (and update render hints) once intersection observer calls back.
            this._invisibleElements.add(result);
        }
        this._intersectionObserver.observe(result);
        this._resizeObserver.observe(result);
        if (this._enableDocumentVisibilityTurnOff) {
            this._documentVisibilityTurnOffCleanup = this._documentVisibilityTurnOffCleanup || setupDocumentVisibilityTurnOff(this);
        }
        return result;
    };
    RemoteVideoTrack.prototype.detach = function (el) {
        var _this = this;
        var result = _super.prototype.detach.call(this, el);
        var elements = Array.isArray(result) ? result : [result];
        elements.forEach(function (element) {
            _this._intersectionObserver.unobserve(element);
            _this._resizeObserver.unobserve(element);
            _this._invisibleElements.delete(element);
        });
        if (this._attachments.size === 0) {
            if (this._documentVisibilityTurnOffCleanup) {
                this._documentVisibilityTurnOffCleanup();
                this._documentVisibilityTurnOffCleanup = null;
            }
        }
        maybeUpdateEnabledHint(this);
        maybeUpdateDimensionHint(this);
        return result;
    };
    /**
     * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.
     * When a Participant un-publishes and re-publishes a VideoTrack, a new RemoteVideoTrack is created and
     * any VideoProcessors attached to the previous RemoteVideoTrack would have to be re-added again.
     * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.
     * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.
     * @returns {this}
     * @example
     * class GrayScaleProcessor {
     *   constructor(percentage) {
     *     this.percentage = percentage;
     *   }
     *   processFrame(inputFrameBuffer, outputFrameBuffer) {
     *     const context = outputFrameBuffer.getContext('2d');
     *     context.filter = `grayscale(${this.percentage}%)`;
     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
     *   }
     * }
     *
     * const grayscaleProcessor = new GrayScaleProcessor(100);
     *
     * Array.from(room.participants.values()).forEach(participant => {
     *   const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;
     *   remoteVideoTrack.addProcessor(grayscaleProcessor);
     * });
     */
    RemoteVideoTrack.prototype.addProcessor = function () {
        return _super.prototype.addProcessor.apply(this, arguments);
    };
    /**
     * Remove the previously added {@link VideoProcessor} using `addProcessor` API.
     * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.
     * @returns {this}
     * @example
     * class GrayScaleProcessor {
     *   constructor(percentage) {
     *     this.percentage = percentage;
     *   }
     *   processFrame(inputFrameBuffer, outputFrameBuffer) {
     *     const context = outputFrameBuffer.getContext('2d');
     *     context.filter = `grayscale(${this.percentage}%)`;
     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
     *   }
     * }
     *
     * const grayscaleProcessor = new GrayScaleProcessor(100);
     *
     * Array.from(room.participants.values()).forEach(participant => {
     *   const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;
     *   remoteVideoTrack.addProcessor(grayscaleProcessor);
     * });
     *
     * document.getElementById('remove-button').onclick = () => {
     *   Array.from(room.participants.values()).forEach(participant => {
     *     const remoteVideoTrack = Array.from(participant.videoTracks.values())[0].track;
     *     remoteVideoTrack.removeProcessor(grayscaleProcessor);
     *   });
     * }
     */
    RemoteVideoTrack.prototype.removeProcessor = function () {
        return _super.prototype.removeProcessor.apply(this, arguments);
    };
    RemoteVideoTrack.prototype.toString = function () {
        return "[RemoteVideoTrack #" + this._instanceId + ": " + this.sid + "]";
    };
    /**
     * Update the subscribe {@link Track.Priority} of the {@link RemoteVideoTrack}.
     * @param {?Track.Priority} priority - the new subscribe {@link Track.Priority};
     *   If <code>null</code>, then the subscribe {@link Track.Priority} is cleared, which
     *   means the {@link Track.Priority} set by the publisher is now the effective priority.
     * @returns {this}
     * @throws {RangeError}
     */
    RemoteVideoTrack.prototype.setPriority = function (priority) {
        return _super.prototype.setPriority.call(this, priority);
    };
    return RemoteVideoTrack;
}(RemoteMediaVideoTrack));
function setupDocumentVisibilityTurnOff(removeVideoTrack) {
    function onVisibilityChanged() {
        maybeUpdateEnabledHint(removeVideoTrack);
    }
    documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChanged);
    return function () {
        documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChanged);
    };
}
function maybeUpdateEnabledHint(removeVideoTrack) {
    if (removeVideoTrack._clientTrackSwitchOffControl !== 'auto') {
        return;
    }
    var visibleElements = removeVideoTrack._getAllAttachedElements().filter(function (el) { return !removeVideoTrack._invisibleElements.has(el); });
    var enabled = document.visibilityState === 'visible' && visibleElements.length > 0;
    if (enabled === true) {
        removeVideoTrack._turnOffTimer.clear();
        removeVideoTrack._setRenderHint({ enabled: true });
    }
    else if (!removeVideoTrack._turnOffTimer.isSet) {
        // set the track to be turned off after some delay.
        removeVideoTrack._turnOffTimer.start();
    }
}
function maybeUpdateDimensionHint(removeVideoTrack) {
    if (removeVideoTrack._contentPreferencesMode !== 'auto') {
        return;
    }
    var visibleElements = removeVideoTrack._getAllAttachedElements().filter(function (el) { return !removeVideoTrack._invisibleElements.has(el); });
    if (visibleElements.length > 0) {
        var _a = __read(visibleElements.sort(function (el1, el2) {
            return el2.clientHeight + el2.clientWidth - el1.clientHeight - el1.clientWidth - 1;
        }), 1), _b = _a[0], clientHeight = _b.clientHeight, clientWidth = _b.clientWidth;
        var renderDimensions = { height: clientHeight, width: clientWidth };
        removeVideoTrack._setRenderHint({ renderDimensions: renderDimensions });
    }
}
/**
 * @typedef {object} VideoContentPreferences
 * @property {VideoTrack.Dimensions} [renderDimensions] - Render Dimensions to request for the {@link RemoteVideoTrack}.
 */
/**
 * The {@link RemoteVideoTrack}'s dimensions changed.
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} whose
 *   dimensions changed
 * @event RemoteVideoTrack#dimensionsChanged
 */
/**
 * The {@link RemoteVideoTrack} was disabled, i.e. "paused".
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was
 *   disabled
 * @event RemoteVideoTrack#disabled
 */
/**
 * The {@link RemoteVideoTrack} was enabled, i.e. "resumed".
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was
 *   enabled
 * @event RemoteVideoTrack#enabled
 */
/**
 * The {@link RemoteVideoTrack} started. This means there is enough video data
 * to begin playback.
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that started
 * @event RemoteVideoTrack#started
 */
/**
 * A {@link RemoteVideoTrack} was switched off.
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was
 *   switched off
 * @event RemoteVideoTrack#switchedOff
 */
/**
 * A {@link RemoteVideoTrack} was switched on.
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} that was
 *   switched on
 * @event RemoteVideoTrack#switchedOn
 */
module.exports = RemoteVideoTrack;
//# sourceMappingURL=remotevideotrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/remotevideotrackpublication.js":
/*!**********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/remotevideotrackpublication.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteTrackPublication = __webpack_require__(/*! ./remotetrackpublication */ "../../work/twilio-video.js/es5/media/track/remotetrackpublication.js");
/**
 * A {@link RemoteVideoTrackPublication} represents a {@link RemoteVideoTrack}
 * that has been published to a {@link Room}.
 * @property {Track.Kind} kind - "video"
 * @property {?RemoteVideoTrack} track - unless you have subscribed to the
 *   {@link RemoteVideoTrack}, this property is null
 * @emits RemoteVideoTrackPublication#subscribed
 * @emits RemoteVideoTrackPublication#subscriptionFailed
 * @emits RemoteVideoTrackPublication#trackDisabled
 * @emits RemoteVideoTrackPublication#trackEnabled
 * @emits RemoteVideoTrackPublication#unsubscribed
 */
var RemoteVideoTrackPublication = /** @class */ (function (_super) {
    __extends(RemoteVideoTrackPublication, _super);
    /**
     * Construct a {@link RemoteVideoTrackPublication}.
     * @param {RemoteTrackPublicationSignaling} signaling - {@link RemoteTrackPublication} signaling
     * @param {RemoteTrackPublicationOptions} options - {@link RemoteTrackPublication}
     *   options
     */
    function RemoteVideoTrackPublication(signaling, options) {
        return _super.call(this, signaling, options) || this;
    }
    RemoteVideoTrackPublication.prototype.toString = function () {
        return "[RemoteVideoTrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return RemoteVideoTrackPublication;
}(RemoteTrackPublication));
/**
 * Your {@link LocalParticipant} subscribed to the {@link RemoteVideoTrack}.
 * @param {RemoteVideoTrack} track - the {@link RemoteVideoTrack} that was subscribed to
 * @event RemoteVideoTrackPublication#subscribed
 */
/**
 * Your {@link LocalParticipant} failed to subscribe to the {@link RemoteVideoTrack}.
 * @param {TwilioError} error - the reason the {@link RemoteVideoTrack} could not be
 *   subscribed to
 * @event RemoteVideoTrackPublication#subscriptionFailed
 */
/**
 * The {@link RemoteVideoTrack} was disabled.
 * @event RemoteVideoTrackPublication#trackDisabled
 */
/**
 * The {@link RemoteVideoTrack} was enabled.
 * @event RemoteVideoTrackPublication#trackEnabled
 */
/**
 * Your {@link LocalParticipant} unsubscribed from the {@link RemoteVideoTrack}.
 * @param {RemoteVideoTrack} track - the {@link RemoteVideoTrack} that was unsubscribed from
 * @event RemoteVideoTrackPublication#unsubscribed
 */
module.exports = RemoteVideoTrackPublication;
//# sourceMappingURL=remotevideotrackpublication.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/sender.js":
/*!*************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/sender.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaTrackTransceiver = __webpack_require__(/*! ./transceiver */ "../../work/twilio-video.js/es5/media/track/transceiver.js");
/**
 * A {@link MediaTrackSender} represents one or more local RTCRtpSenders.
 * @extends MediaTrackTransceiver
 */
var MediaTrackSender = /** @class */ (function (_super) {
    __extends(MediaTrackSender, _super);
    /**
     * Construct a {@link MediaTrackSender}.
     * @param {MediaStreamTrack} mediaStreamTrack
     */
    function MediaTrackSender(mediaStreamTrack) {
        var _this = _super.call(this, mediaStreamTrack.id, mediaStreamTrack) || this;
        Object.defineProperties(_this, {
            _clones: {
                value: new Set()
            },
            _senders: {
                value: new Set()
            },
            isPublishing: {
                get: function () {
                    return !!this._clones.size;
                }
            }
        });
        return _this;
    }
    /**
     * Return a new {@link MediaTrackSender} containing a clone of the underlying
     * MediaStreamTrack. No RTCRtpSenders are copied.
     * @returns {MediaTrackSender}
     */
    MediaTrackSender.prototype.clone = function () {
        var clone = new MediaTrackSender(this.track.clone());
        this._clones.add(clone);
        return clone;
    };
    /**
     * Remove a cloned {@link MediaTrackSender}.
     * @returns {void}
     */
    MediaTrackSender.prototype.removeClone = function (clone) {
        this._clones.delete(clone);
    };
    /**
     * Set the given MediaStreamTrack.
     * @param {MediaStreamTrack} mediaStreamTrack
     * @returns {Promise<void>}
     */
    MediaTrackSender.prototype.setMediaStreamTrack = function (mediaStreamTrack) {
        var _this = this;
        var clones = Array.from(this._clones);
        var senders = Array.from(this._senders);
        return Promise.all(clones.map(function (clone) {
            return clone.setMediaStreamTrack(mediaStreamTrack.clone());
        }).concat(senders.map(function (sender) {
            return sender.replaceTrack(mediaStreamTrack);
        }))).finally(function () {
            _this._track = mediaStreamTrack;
        });
    };
    /**
     * Add an RTCRtpSender.
     * @param {RTCRtpSender} sender
     * @returns {this}
     */
    MediaTrackSender.prototype.addSender = function (sender) {
        this._senders.add(sender);
        return this;
    };
    /**
     * Remove an RTCRtpSender.
     * @param {RTCRtpSender} sender
     * @returns {this}
     */
    MediaTrackSender.prototype.removeSender = function (sender) {
        this._senders.delete(sender);
        return this;
    };
    return MediaTrackSender;
}(MediaTrackTransceiver));
module.exports = MediaTrackSender;
//# sourceMappingURL=sender.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/trackpublication.js":
/*!***********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/trackpublication.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! ../../eventemitter */ "../../work/twilio-video.js/es5/eventemitter.js");
var _a = __webpack_require__(/*! ../../util */ "../../work/twilio-video.js/es5/util/index.js"), buildLogLevels = _a.buildLogLevels, valueToJSON = _a.valueToJSON;
var DEFAULT_LOG_LEVEL = __webpack_require__(/*! ../../util/constants */ "../../work/twilio-video.js/es5/util/constants.js").DEFAULT_LOG_LEVEL;
var Log = __webpack_require__(/*! ../../util/log */ "../../work/twilio-video.js/es5/util/log.js");
var nInstances = 0;
/**
 * A {@link TrackPublication} represents a {@link Track} that
 * has been published to a {@link Room}.
 * @property {string} trackName - the published {@link Track}'s name
 * @property {Track.SID} trackSid - SID assigned to the published {@link Track}
 * @emits TrackPublication#trackDisabled
 * @emits TrackPublication#trackEnabled
 */
var TrackPublication = /** @class */ (function (_super) {
    __extends(TrackPublication, _super);
    /**
     * Construct a {@link TrackPublication}.
     * @param {string} trackName - the published {@link Track}'s name
     * @param {Track.SID} trackSid - SID assigned to the {@link Track}
     * @param {TrackPublicationOptions} options - {@link TrackPublication} options
     */
    function TrackPublication(trackName, trackSid, options) {
        var _this = _super.call(this) || this;
        options = Object.assign({
            logLevel: DEFAULT_LOG_LEVEL
        }, options);
        var logLevels = buildLogLevels(options.logLevel);
        Object.defineProperties(_this, {
            _instanceId: {
                value: nInstances++
            },
            _log: {
                value: options.log ? options.log.createLog('default', _this) : new Log('default', _this, logLevels, options.loggerName)
            },
            trackName: {
                enumerable: true,
                value: trackName
            },
            trackSid: {
                enumerable: true,
                value: trackSid
            }
        });
        return _this;
    }
    TrackPublication.prototype.toJSON = function () {
        return valueToJSON(this);
    };
    TrackPublication.prototype.toString = function () {
        return "[TrackPublication #" + this._instanceId + ": " + this.trackSid + "]";
    };
    return TrackPublication;
}(EventEmitter));
/**
 * The published {@link Track} was disabled.
 * @event TrackPublication#trackDisabled
 */
/**
 * The published {@link Track} was enabled.
 * @event TrackPublication#trackEnabled
 */
/**
 * A {@link LocalAudioTrackPublication} or a {@link RemoteAudioTrackPublication}.
 * @typedef {LocalAudioTrackPublication|RemoteAudioTrackPublication} AudioTrackPublication
 */
/**
 * A {@link LocalDataTrackPublication} or a {@link RemoteDataTrackPublication}.
 * @typedef {LocalDataTrackPublication|RemoteDataTrackPublication} DataTrackPublication
 */
/**
 * A {@link LocalVideoTrackPublication} or a {@link RemoteVideoTrackPublication}.
 * @typedef {LocalVideoTrackPublication|RemoteVideoTrackPublication} VideoTrackPublication
 */
/**
 * {@link TrackPublication} options
 * @typedef {object} TrackPublicationOptions
 * @property {LogLevel|LogLevels} logLevel - Log level for 'media' modules
 */
module.exports = TrackPublication;
//# sourceMappingURL=trackpublication.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/transceiver.js":
/*!******************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/transceiver.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackTransceiver = __webpack_require__(/*! ../../transceiver */ "../../work/twilio-video.js/es5/transceiver.js");
/**
 * A {@link MediaTrackTransceiver} represents either one or more local
 * RTCRtpSenders, or a single RTCRtpReceiver.
 * @extends TrackTransceiver
 * @property {MediaStreamTrack} track
 */
var MediaTrackTransceiver = /** @class */ (function (_super) {
    __extends(MediaTrackTransceiver, _super);
    /**
     * Construct a {@link MediaTrackTransceiver}.
     * @param {Track.ID} id - The MediaStreamTrack ID signaled through RSP/SDP
     * @param {MediaStreamTrack} mediaStreamTrack
     */
    function MediaTrackTransceiver(id, mediaStreamTrack) {
        var _this = _super.call(this, id, mediaStreamTrack.kind) || this;
        Object.defineProperties(_this, {
            _track: {
                value: mediaStreamTrack,
                writable: true
            },
            enabled: {
                enumerable: true,
                get: function () {
                    return this._track.enabled;
                }
            },
            readyState: {
                enumerable: true,
                get: function () {
                    return this._track.readyState;
                }
            },
            track: {
                enumerable: true,
                get: function () {
                    return this._track;
                }
            }
        });
        return _this;
    }
    MediaTrackTransceiver.prototype.stop = function () {
        this.track.stop();
        _super.prototype.stop.call(this);
    };
    return MediaTrackTransceiver;
}(TrackTransceiver));
module.exports = MediaTrackTransceiver;
//# sourceMappingURL=transceiver.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/videoprocessoreventobserver.js":
/*!**********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/videoprocessoreventobserver.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var DEFAULT_VIDEO_PROCESSOR_STATS_INTERVAL_MS = __webpack_require__(/*! ../../util/constants */ "../../work/twilio-video.js/es5/util/constants.js").DEFAULT_VIDEO_PROCESSOR_STATS_INTERVAL_MS;
/**
 * VideoProcessorEventObserver listens to {@link VideoProcessor} related events
 * and re-emits them as a generic event with some additional information.
 * @extends EventEmitter
 * @emits VideoProcessorEventObserver#event
 */
var VideoProcessorEventObserver = /** @class */ (function (_super) {
    __extends(VideoProcessorEventObserver, _super);
    /**
     * Constructor.
     * @param {Log} log
     */
    function VideoProcessorEventObserver(log) {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _lastStatsSaveTime: {
                value: null,
                writable: true
            },
            _lastStatsPublishTime: {
                value: null,
                writable: true
            },
            _log: {
                value: log
            },
            _processorInfo: {
                value: null,
                writable: true
            },
            _stats: {
                value: null,
                writable: true
            }
        });
        _this.on('add', function (info) {
            _this._lastStatsSaveTime = Date.now();
            _this._lastStatsPublishTime = Date.now();
            _this._processorInfo = info;
            _this._stats = [];
            _this._reemitEvent('add', _this._getEventData());
        });
        _this.on('remove', function () {
            var data = _this._getEventData();
            _this._lastStatsSaveTime = null;
            _this._lastStatsPublishTime = null;
            _this._processorInfo = null;
            _this._stats = null;
            _this._reemitEvent('remove', data);
        });
        _this.on('start', function () {
            _this._reemitEvent('start', _this._getEventData());
        });
        _this.on('stop', function (message) {
            _this._reemitEvent('stop', Object.assign({ message: message }, _this._getEventData()));
        });
        _this.on('stats', function () { return _this._maybeEmitStats(); });
        return _this;
    }
    /**
     * @private
     */
    VideoProcessorEventObserver.prototype._getEventData = function () {
        if (!this._processorInfo) {
            return {};
        }
        var _a = this._processorInfo, processor = _a.processor, captureHeight = _a.captureHeight, captureWidth = _a.captureWidth, inputFrameRate = _a.inputFrameRate, isRemoteVideoTrack = _a.isRemoteVideoTrack;
        var data = { captureHeight: captureHeight, captureWidth: captureWidth, inputFrameRate: inputFrameRate, isRemoteVideoTrack: isRemoteVideoTrack };
        data.name = processor._name || 'VideoProcessor';
        ['assetsPath', 'blurFilterRadius', 'fitType', 'isSimdEnabled', 'maskBlurRadius', 'version'].forEach(function (prop) {
            var val = processor["_" + prop];
            if (typeof val !== 'undefined') {
                data[prop] = val;
            }
        });
        Object.keys(data).forEach(function (prop) {
            var val = data[prop];
            if (typeof val === 'boolean') {
                data[prop] = val ? 'true' : 'false';
            }
        });
        return data;
    };
    /**
     * Save stats every second. If a specific time interval has elapsed,
     * the stats event will be emitted
     * @private
     */
    VideoProcessorEventObserver.prototype._maybeEmitStats = function () {
        if (!this._stats || !this._processorInfo) {
            return;
        }
        var benchmark = this._processorInfo.processor._benchmark;
        if (!benchmark) {
            return;
        }
        var now = Date.now();
        if (now - this._lastStatsSaveTime < 1000) {
            return;
        }
        var entry = { outputFrameRate: benchmark.getRate('totalProcessingDelay') };
        ['captureFrameDelay', 'imageCompositionDelay', 'inputImageResizeDelay', 'processFrameDelay', 'segmentationDelay'].forEach(function (name) {
            entry[name] = benchmark.getAverageDelay(name);
        });
        this._lastStatsSaveTime = now;
        this._stats.push(entry);
        if (now - this._lastStatsPublishTime < DEFAULT_VIDEO_PROCESSOR_STATS_INTERVAL_MS) {
            return;
        }
        this._lastStatsPublishTime = now;
        var stats = this._stats.splice(0);
        var averages = stats.reduce(function (averages, current, n) {
            Object.keys(entry).forEach(function (name) {
                if (!averages[name]) {
                    averages[name] = 0;
                }
                averages[name] = ((averages[name] * n) + current[name]) / (n + 1);
            });
            return averages;
        }, {});
        Object.keys(averages).forEach(function (name) {
            averages[name] = parseFloat(averages[name].toFixed(2));
        });
        this._reemitEvent('stats', Object.assign({}, averages, this._getEventData()));
    };
    /**
     * @private
     */
    VideoProcessorEventObserver.prototype._reemitEvent = function (name, data) {
        this._log.debug("VideoProcessor:" + name, data);
        this.emit('event', { name: name, data: data });
    };
    return VideoProcessorEventObserver;
}(EventEmitter));
module.exports = VideoProcessorEventObserver;
//# sourceMappingURL=videoprocessoreventobserver.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/media/track/videotrack.js":
/*!*****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/media/track/videotrack.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaTrack = __webpack_require__(/*! ./mediatrack */ "../../work/twilio-video.js/es5/media/track/mediatrack.js");
var VideoProcessorEventObserver = __webpack_require__(/*! ./videoprocessoreventobserver */ "../../work/twilio-video.js/es5/media/track/videoprocessoreventobserver.js");
var DEFAULT_FRAME_RATE = __webpack_require__(/*! ../../util/constants */ "../../work/twilio-video.js/es5/util/constants.js").DEFAULT_FRAME_RATE;
/**
 * A {@link VideoTrack} is a {@link Track} representing video.
 * @extends Track
 * @property {boolean} isStarted - Whether or not the {@link VideoTrack} has
 *   started; if the {@link VideoTrack} started, there is enough video data to
 *   begin playback
 * @property {boolean} isEnabled - Whether or not the {@link VideoTrack} is
 *   enabled; if the {@link VideoTrack} is not enabled, it is "paused"
 * @property {VideoTrack.Dimensions} dimensions - The {@link VideoTrack}'s
 *   {@link VideoTrack.Dimensions}
 * @property {Track.Kind} kind - "video"
 * @property {MediaStreamTrack} mediaStreamTrack - A video MediaStreamTrack
 * @property {?MediaStreamTrack} processedTrack - The source of processed video frames.
 * It is null if no VideoProcessor has been added.
 * @property {?VideoProcessor} processor - A {@link VideoProcessor} that is currently
 *   processing video frames. It is null if video frames are not being processed.
 * @emits VideoTrack#dimensionsChanged
 * @emits VideoTrack#disabled
 * @emits VideoTrack#enabled
 * @emits VideoTrack#started
 */
var VideoTrack = /** @class */ (function (_super) {
    __extends(VideoTrack, _super);
    /**
     * Construct a {@link VideoTrack}.
     * @param {MediaTrackTransceiver} mediaTrackTransceiver
     * @param {{log: Log}} options
     */
    function VideoTrack(mediaTrackTransceiver, options) {
        var _this = _super.call(this, mediaTrackTransceiver, options) || this;
        Object.defineProperties(_this, {
            _captureTimeoutId: {
                value: null,
                writable: true
            },
            _isCapturing: {
                value: false,
                writable: true
            },
            _inputFrame: {
                value: null,
                writable: true
            },
            _outputFrame: {
                value: null,
                writable: true
            },
            _processorEventObserver: {
                value: null,
                writable: true,
            },
            _unmuteHandler: {
                value: null,
                writable: true
            },
            dimensions: {
                enumerable: true,
                value: {
                    width: null,
                    height: null
                }
            },
            processor: {
                enumerable: true,
                value: null,
                writable: true
            }
        });
        _this._processorEventObserver = new (options.VideoProcessorEventObserver || VideoProcessorEventObserver)(_this._log);
        return _this;
    }
    /**
     * @private
     */
    VideoTrack.prototype._checkIfCanCaptureFrames = function (isPublishing) {
        if (isPublishing === void 0) { isPublishing = false; }
        var canCaptureFrames = true;
        var message = '';
        var _a = this.mediaStreamTrack, enabled = _a.enabled, readyState = _a.readyState;
        if (!enabled) {
            canCaptureFrames = false;
            message = 'MediaStreamTrack is disabled';
        }
        if (readyState === 'ended') {
            canCaptureFrames = false;
            message = 'MediaStreamTrack is ended';
        }
        if (!this.processor) {
            canCaptureFrames = false;
            message = 'VideoProcessor not detected.';
        }
        if (!this._attachments.size && !isPublishing) {
            canCaptureFrames = false;
            message = 'VideoTrack is not publishing and there is no attached element.';
        }
        if (message) {
            this._log.debug(message);
        }
        return { canCaptureFrames: canCaptureFrames, message: message };
    };
    /**
     * @private
     */
    VideoTrack.prototype._captureFrames = function () {
        var _this = this;
        if (this._isCapturing) {
            this._log.debug('Ignoring captureFrames call. Capture is already in progress');
            return;
        }
        if (!this._checkIfCanCaptureFrames().canCaptureFrames) {
            this._isCapturing = false;
            this._log.debug('Cannot capture frames. Ignoring captureFrames call.');
            return;
        }
        this._isCapturing = true;
        this._processorEventObserver.emit('start');
        this._log.debug('Start capturing frames');
        var startTime = Date.now();
        var processFramePeriodMs;
        this._dummyEl.play().then(function () {
            var captureFrame = function (cb) {
                clearTimeout(_this._captureTimeoutId);
                var _a = _this.mediaStreamTrack.getSettings().frameRate, frameRate = _a === void 0 ? DEFAULT_FRAME_RATE : _a;
                var capturePeriodMs = Math.floor(1000 / frameRate);
                var delay = capturePeriodMs - processFramePeriodMs;
                if (delay < 0 || typeof processFramePeriodMs !== 'number') {
                    delay = 0;
                }
                _this._captureTimeoutId = setTimeout(cb, delay);
            };
            var process = function () {
                var checkResult = _this._checkIfCanCaptureFrames();
                if (!checkResult.canCaptureFrames) {
                    _this._isCapturing = false;
                    _this._processorEventObserver.emit('stop', checkResult.message);
                    _this._log.debug('Cannot capture frames. Stopping capturing frames.');
                    return;
                }
                startTime = Date.now();
                var _a = _this.mediaStreamTrack.getSettings(), _b = _a.width, width = _b === void 0 ? 0 : _b, _c = _a.height, height = _c === void 0 ? 0 : _c;
                // Setting the canvas' dimension triggers a redraw.
                // Only set it if it has changed.
                if (_this._inputFrame.width !== width) {
                    _this._inputFrame.width = width;
                    _this._inputFrame.height = height;
                    if (_this._outputFrame) {
                        _this._outputFrame.width = width;
                        _this._outputFrame.height = height;
                    }
                }
                _this._inputFrame.getContext('2d').drawImage(_this._dummyEl, 0, 0, width, height);
                var result = null;
                try {
                    result = _this.processor.processFrame(_this._inputFrame, _this._outputFrame);
                }
                catch (ex) {
                    _this._log.debug('Exception detected after calling processFrame.', ex);
                }
                ((result instanceof Promise) ? result : Promise.resolve(result))
                    .then(function () {
                    if (_this._outputFrame) {
                        _this.processedTrack.requestFrame();
                        _this._processorEventObserver.emit('stats');
                    }
                })
                    .finally(function () {
                    processFramePeriodMs = Date.now() - startTime;
                    captureFrame(process);
                });
            };
            captureFrame(process);
        }).catch(function (error) { return _this._log.error('Video element cannot be played', { error: error, track: _this }); });
    };
    /**
     * @private
     */
    VideoTrack.prototype._initialize = function () {
        var _this = this;
        _super.prototype._initialize.call(this);
        if (this._dummyEl) {
            this._dummyEl.onloadedmetadata = function () {
                if (dimensionsChanged(_this, _this._dummyEl)) {
                    _this.dimensions.width = _this._dummyEl.videoWidth;
                    _this.dimensions.height = _this._dummyEl.videoHeight;
                }
            };
            this._dummyEl.onresize = function () {
                if (dimensionsChanged(_this, _this._dummyEl)) {
                    _this.dimensions.width = _this._dummyEl.videoWidth;
                    _this.dimensions.height = _this._dummyEl.videoHeight;
                    if (_this.isStarted) {
                        _this._log.debug('Dimensions changed:', _this.dimensions);
                        _this.emit(VideoTrack.DIMENSIONS_CHANGED, _this);
                    }
                }
            };
        }
    };
    /**
     * @private
     */
    VideoTrack.prototype._restartProcessor = function () {
        var processor = this.processor;
        if (processor) {
            this.removeProcessor(processor);
            this.addProcessor(processor);
        }
    };
    /**
     * @private
     */
    VideoTrack.prototype._start = function (dummyEl) {
        this.dimensions.width = dummyEl.videoWidth;
        this.dimensions.height = dummyEl.videoHeight;
        this._log.debug('Dimensions:', this.dimensions);
        return _super.prototype._start.call(this, dummyEl);
    };
    /**
     * Add a {@link VideoProcessor} to allow for custom processing of video frames belonging to a VideoTrack.
     * Only Chrome supports this as of now. Calling this API from a non-supported browser will result in a log warning.
     * @param {VideoProcessor} processor - The {@link VideoProcessor} to use.
     * @returns {this}
     * @example
     * class GrayScaleProcessor {
     *   constructor(percentage) {
     *     this.percentage = percentage;
     *   }
     *   processFrame(inputFrameBuffer, outputFrameBuffer) {
     *     const context = outputFrameBuffer.getContext('2d');
     *     context.filter = `grayscale(${this.percentage}%)`;
     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
     *   }
     * }
     *
     * Video.createLocalVideoTrack().then(function(videoTrack) {
     *   videoTrack.addProcessor(new GrayScaleProcessor(100));
     * });
     */
    VideoTrack.prototype.addProcessor = function (processor) {
        var _this = this;
        if (typeof OffscreenCanvas !== 'function') {
            return this._log.warn('Adding a VideoProcessor is not supported in this browser.');
        }
        if (!processor || typeof processor.processFrame !== 'function') {
            throw new Error('Received an invalid VideoProcessor from addProcessor.');
        }
        if (this.processor) {
            throw new Error('A VideoProcessor has already been added.');
        }
        if (!this._dummyEl) {
            throw new Error('VideoTrack has not been initialized.');
        }
        this._log.debug('Adding VideoProcessor to the VideoTrack', processor);
        if (!this._unmuteHandler) {
            this._unmuteHandler = function () {
                _this._log.debug('mediaStreamTrack unmuted');
                // NOTE(csantos): On certain scenarios where mediaStreamTrack is coming from muted to unmuted state,
                // the processedTrack doesn't unmutes automatically although enabled is already set to true.
                // This is a terminal state for the processedTrack and should be restarted. (VIDEO-4176)
                if (_this.processedTrack.muted) {
                    _this._log.debug('mediaStreamTrack is unmuted but processedTrack is muted. Restarting processor.');
                    _this._restartProcessor();
                }
            };
            this.mediaStreamTrack.addEventListener('unmute', this._unmuteHandler);
        }
        var _a = this.mediaStreamTrack.getSettings(), _b = _a.width, width = _b === void 0 ? 0 : _b, _c = _a.height, height = _c === void 0 ? 0 : _c, _d = _a.frameRate, frameRate = _d === void 0 ? DEFAULT_FRAME_RATE : _d;
        this._inputFrame = new OffscreenCanvas(width, height);
        this._outputFrame = document.createElement('canvas');
        this._outputFrame.width = width;
        this._outputFrame.height = height;
        this.processedTrack = this._outputFrame.captureStream(0).getTracks()[0];
        this.processedTrack.enabled = this.mediaStreamTrack.enabled;
        this.processor = processor;
        this._processorEventObserver.emit('add', {
            processor: processor,
            captureHeight: height,
            captureWidth: width,
            inputFrameRate: frameRate,
            isRemoteVideoTrack: this.toString().includes('RemoteVideoTrack')
        });
        this._updateElementsMediaStreamTrack();
        this._captureFrames();
        return this;
    };
    /**
     * Create an HTMLVideoElement and attach the {@link VideoTrack} to it.
     *
     * The HTMLVideoElement's <code>srcObject</code> will be set to a new
     * MediaStream containing the {@link VideoTrack}'s MediaStreamTrack.
     *
     * @returns {HTMLVideoElement} videoElement
     * @example
     * const Video = require('twilio-video');
     *
     * Video.createLocalVideoTrack().then(function(videoTrack) {
     *   const videoElement = videoTrack.attach();
     *   document.body.appendChild(videoElement);
     * });
    */ /**
     * Attach the {@link VideoTrack} to an existing HTMLMediaElement. The
     * HTMLMediaElement could be an HTMLAudioElement or an HTMLVideoElement.
     *
     * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,
     * this method sets it to a new MediaStream containing the {@link VideoTrack}'s
     * MediaStreamTrack; otherwise, it adds the {@link MediaTrack}'s
     * MediaStreamTrack to the existing MediaStream. Finally, if there are any other
     * MediaStreamTracks of the same kind on the MediaStream, this method removes
     * them.
     *
     * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement to attach to
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * const Video = require('twilio-video');
     *
     * const videoElement = document.createElement('video');
     * document.body.appendChild(videoElement);
     *
     * Video.createLocalVideoTrack().then(function(videoTrack) {
     *   videoTrack.attach(videoElement);
     * });
    */ /**
     * Attach the {@link VideoTrack} to an HTMLMediaElement selected by
     * <code>document.querySelector</code>. The HTMLMediaElement could be an
     * HTMLAudioElement or an HTMLVideoElement.
     *
     * If the HTMLMediaElement's <code>srcObject</code> is not set to a MediaStream,
     * this method sets it to a new MediaStream containing the {@link VideoTrack}'s
     * MediaStreamTrack; otherwise, it adds the {@link VideoTrack}'s
     * MediaStreamTrack to the existing MediaStream. Finally, if there are any other
     * MediaStreamTracks of the same kind on the MediaStream, this method removes
     * them.
     *
     * @param {string} selector - A query selector for the HTMLMediaElement to
     *   attach to
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * const Video = require('twilio-video');
     *
     * const videoElement = document.createElement('video');
     * videoElement.id = 'my-video-element';
     * document.body.appendChild(videoElement);
     *
     * Video.createLocalVideoTrack().then(function(track) {
     *   track.attach('#my-video-element');
     * });
     */
    VideoTrack.prototype.attach = function () {
        var result = _super.prototype.attach.apply(this, arguments);
        if (this.processor) {
            this._captureFrames();
        }
        return result;
    };
    /**
     * Detach the {@link VideoTrack} from all previously attached HTMLMediaElements.
     * @returns {Array<HTMLMediaElement>} mediaElements
     * @example
     * const mediaElements = videoTrack.detach();
     * mediaElements.forEach(mediaElement => mediaElement.remove());
    */ /**
     * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement.
     * @param {HTMLMediaElement} mediaElement - One of the HTMLMediaElements to
     *   which the {@link VideoTrack} is attached
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * const videoElement = document.getElementById('my-video-element');
     * videoTrack.detach(videoElement).remove();
    */ /**
     * Detach the {@link VideoTrack} from a previously attached HTMLMediaElement
     *   specified by <code>document.querySelector</code>.
     * @param {string} selector - The query selector of HTMLMediaElement to which
     *    the {@link VideoTrack} is attached
     * @returns {HTMLMediaElement} mediaElement
     * @example
     * videoTrack.detach('#my-video-element').remove();
     */
    VideoTrack.prototype.detach = function () {
        return _super.prototype.detach.apply(this, arguments);
    };
    /**
     * Remove the previously added {@link VideoProcessor} using `addProcessor` API.
     * @param {VideoProcessor} processor - The {@link VideoProcessor} to remove.
     * @returns {this}
     * @example
     * class GrayScaleProcessor {
     *   constructor(percentage) {
     *     this.percentage = percentage;
     *   }
     *   processFrame(inputFrameBuffer, outputFrameBuffer) {
     *     const context = outputFrameBuffer.getContext('2d');
     *     context.filter = `grayscale(${this.percentage}%)`;
     *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
     *   }
     * }
     *
     * Video.createLocalVideoTrack().then(function(videoTrack) {
     *   const grayScaleProcessor = new GrayScaleProcessor(100);
     *   videoTrack.addProcessor(grayScaleProcessor);
     *   document.getElementById('remove-button').onclick = () => videoTrack.removeProcessor(grayScaleProcessor);
     * });
     */
    VideoTrack.prototype.removeProcessor = function (processor) {
        if (!processor) {
            throw new Error('Received an invalid VideoProcessor from removeProcessor.');
        }
        if (!this.processor) {
            throw new Error('No existing VideoProcessor detected.');
        }
        if (processor !== this.processor) {
            throw new Error('The provided VideoProcessor is different than the existing one.');
        }
        this._processorEventObserver.emit('remove');
        this._log.debug('Removing VideoProcessor from the VideoTrack', processor);
        clearTimeout(this._captureTimeoutId);
        this.mediaStreamTrack.removeEventListener('unmute', this._unmuteHandler);
        this._unmuteHandler = null;
        this._isCapturing = false;
        this.processor = null;
        this.processedTrack = null;
        this._inputFrame.getContext('2d').clearRect(0, 0, this._inputFrame.width, this._inputFrame.height);
        this._outputFrame.getContext('2d').clearRect(0, 0, this._outputFrame.width, this._outputFrame.height);
        this._inputFrame = null;
        this._outputFrame = null;
        this._updateElementsMediaStreamTrack();
        return this;
    };
    return VideoTrack;
}(MediaTrack));
VideoTrack.DIMENSIONS_CHANGED = 'dimensionsChanged';
function dimensionsChanged(track, elem) {
    return track.dimensions.width !== elem.videoWidth
        || track.dimensions.height !== elem.videoHeight;
}
/**
 * A {@link VideoTrack}'s width and height.
 * @typedef {object} VideoTrack.Dimensions
 * @property {?number} width - The {@link VideoTrack}'s width or null if the
 *   {@link VideoTrack} has not yet started
 * @property {?number} height - The {@link VideoTrack}'s height or null if the
 *   {@link VideoTrack} has not yet started
 */
/**
 * A {@link VideoProcessor}, when added via {@link VideoTrack#addProcessor},
 * is used to process incoming video frames before
 * sending to the encoder or renderer.
 * @typedef {object} VideoProcessor
 * @property {function} processFrame - A callback to receive input and output frame buffers for processing.
 * The input frame buffer contains the original video frame which can be used for additional processing
 * such as applying filters to it. The output frame buffer is used to receive the processed video frame
 * before sending to the encoder or renderer.
 *
 * Any exception raised (either synchronously or asynchronously) in `processFrame` will result in the frame being dropped.
 * This callback has the following signature:<br/><br/>
 * <code>processFrame(</code><br/>
 * &nbsp;&nbsp;<code>inputFrameBuffer: OffscreenCanvas,</code><br/>
 * &nbsp;&nbsp;<code>outputFrameBuffer: HTMLCanvasElement</code><br/>
 * <code>): Promise&lt;void&gt; | void;</code>
 *
 * @example
 * class GrayScaleProcessor {
 *   constructor(percentage) {
 *     this.percentage = percentage;
 *   }
 *   processFrame(inputFrameBuffer, outputFrameBuffer) {
 *     const context = outputFrameBuffer.getContext('2d');
 *     context.filter = `grayscale(${this.percentage}%)`;
 *     context.drawImage(inputFrameBuffer, 0, 0, inputFrameBuffer.width, inputFrameBuffer.height);
 *   }
 * }
 */
/**
 * The {@link VideoTrack}'s dimensions changed.
 * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed
 * @event VideoTrack#dimensionsChanged
 */
/**
 * The {@link VideoTrack} was disabled, i.e. "paused".
 * @param {VideoTrack} track - The {@link VideoTrack} that was disabled
 * @event VideoTrack#disabled
 */
/**
 * The {@link VideoTrack} was enabled, i.e. "unpaused".
 * @param {VideoTrack} track - The {@link VideoTrack} that was enabled
 * @event VideoTrack#enabled
 */
/**
 * The {@link VideoTrack} started. This means there is enough video data to
 * begin playback.
 * @param {VideoTrack} track - The {@link VideoTrack} that started
 * @event VideoTrack#started
 */
module.exports = VideoTrack;
//# sourceMappingURL=videotrack.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/networkqualityconfiguration.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/networkqualityconfiguration.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var _a = __webpack_require__(/*! ./util/constants */ "../../work/twilio-video.js/es5/util/constants.js"), DEFAULT_NQ_LEVEL_LOCAL = _a.DEFAULT_NQ_LEVEL_LOCAL, DEFAULT_NQ_LEVEL_REMOTE = _a.DEFAULT_NQ_LEVEL_REMOTE, MAX_NQ_LEVEL = _a.MAX_NQ_LEVEL;
var inRange = __webpack_require__(/*! ./util */ "../../work/twilio-video.js/es5/util/index.js").inRange;
/**
 * {@link NetworkQualityConfigurationImpl} represents an object which notifies its
 * listeners of any changes in the values of its properties.
 * @extends EventEmitter
 * @implements NetworkQualityConfiguration
 * @property {?NetworkQualityVerbosity} local - Verbosity level for {@link LocalParticipant}
 * @property {?NetworkQualityVerbosity} remote - Verbosity level for {@link RemoteParticipant}s
 */
var NetworkQualityConfigurationImpl = /** @class */ (function (_super) {
    __extends(NetworkQualityConfigurationImpl, _super);
    /**
     * Construct an {@link NetworkQualityConfigurationImpl}.
     * @param {NetworkQualityConfiguration} networkQualityConfiguration - Initial {@link NetworkQualityConfiguration}
     */
    function NetworkQualityConfigurationImpl(networkQualityConfiguration) {
        var _this = _super.call(this) || this;
        networkQualityConfiguration = Object.assign({
            local: DEFAULT_NQ_LEVEL_LOCAL,
            remote: DEFAULT_NQ_LEVEL_REMOTE
        }, networkQualityConfiguration);
        Object.defineProperties(_this, {
            local: {
                value: inRange(networkQualityConfiguration.local, DEFAULT_NQ_LEVEL_LOCAL, MAX_NQ_LEVEL)
                    ? networkQualityConfiguration.local
                    : DEFAULT_NQ_LEVEL_LOCAL,
                writable: true
            },
            remote: {
                value: inRange(networkQualityConfiguration.remote, DEFAULT_NQ_LEVEL_REMOTE, MAX_NQ_LEVEL)
                    ? networkQualityConfiguration.remote
                    : DEFAULT_NQ_LEVEL_REMOTE,
                writable: true
            }
        });
        return _this;
    }
    /**
     * Update the verbosity levels for network quality information for
     * {@link LocalParticipant} and {@link RemoteParticipant} with those
     * in the given {@link NetworkQualityConfiguration}.
     * @param {NetworkQualityConfiguration} networkQualityConfiguration - The new {@link NetworkQualityConfiguration}
     */
    NetworkQualityConfigurationImpl.prototype.update = function (networkQualityConfiguration) {
        var _this = this;
        networkQualityConfiguration = Object.assign({
            local: this.local,
            remote: this.remote
        }, networkQualityConfiguration);
        [
            ['local', DEFAULT_NQ_LEVEL_LOCAL, 3],
            ['remote', DEFAULT_NQ_LEVEL_REMOTE, 3]
        ].forEach(function (_a) {
            var _b = __read(_a, 3), localOrRemote = _b[0], min = _b[1], max = _b[2];
            _this[localOrRemote] = typeof networkQualityConfiguration[localOrRemote] === 'number'
                && inRange(networkQualityConfiguration[localOrRemote], min, max)
                ? networkQualityConfiguration[localOrRemote]
                : min;
        });
    };
    return NetworkQualityConfigurationImpl;
}(EventEmitter));
module.exports = NetworkQualityConfigurationImpl;
//# sourceMappingURL=networkqualityconfiguration.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/participant.js":
/*!******************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/participant.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var EventEmitter = __webpack_require__(/*! ./eventemitter */ "../../work/twilio-video.js/es5/eventemitter.js");
var RemoteAudioTrack = __webpack_require__(/*! ./media/track/remoteaudiotrack */ "../../work/twilio-video.js/es5/media/track/remoteaudiotrack.js");
var RemoteAudioTrackPublication = __webpack_require__(/*! ./media/track/remoteaudiotrackpublication */ "../../work/twilio-video.js/es5/media/track/remoteaudiotrackpublication.js");
var RemoteDataTrack = __webpack_require__(/*! ./media/track/remotedatatrack */ "../../work/twilio-video.js/es5/media/track/remotedatatrack.js");
var RemoteDataTrackPublication = __webpack_require__(/*! ./media/track/remotedatatrackpublication */ "../../work/twilio-video.js/es5/media/track/remotedatatrackpublication.js");
var RemoteVideoTrack = __webpack_require__(/*! ./media/track/remotevideotrack */ "../../work/twilio-video.js/es5/media/track/remotevideotrack.js");
var RemoteVideoTrackPublication = __webpack_require__(/*! ./media/track/remotevideotrackpublication */ "../../work/twilio-video.js/es5/media/track/remotevideotrackpublication.js");
var util = __webpack_require__(/*! ./util */ "../../work/twilio-video.js/es5/util/index.js");
var nInstances = 0;
/**
 * {@link NetworkQualityLevel} is a value from 0–5, inclusive, representing the
 * quality of a network connection.
 * @typedef {number} NetworkQualityLevel
 */
/**
 * @extends EventEmitter
 * @property {Map<Track.SID, AudioTrackPublication>} audioTracks -
 *    The {@link Participant}'s {@link AudioTrackPublication}s
 * @property {Map<Track.SID, DataTrackPublication>} dataTracks -
 *    The {@link Participant}'s {@link DataTrackPublication}s.
 * @property {Participant.Identity} identity - The identity of the {@link Participant}
 * @property {?NetworkQualityLevel} networkQualityLevel - The
 *    {@link Participant}'s current {@link NetworkQualityLevel}, if any
 * @property {?NetworkQualityStats} networkQualityStats - The
 *    {@link Participant}'s current {@link NetworkQualityStats}, if any
 * @property {Participant.SID} sid - The {@link Participant}'s SID
 * @property {string} state - "connected", "disconnected" or "reconnecting"
 * @property {Map<Track.SID, TrackPublication>} tracks -
 *    The {@link Participant}'s {@link TrackPublication}s
 * @property {Map<Track.SID, VideoTrackPublication>} videoTracks -
 *    The {@link Participant}'s {@link VideoTrackPublication}s
 * @emits Participant#disconnected
 * @emits Participant#networkQualityLevelChanged
 * @emits Participant#reconnected
 * @emits Participant#reconnecting
 * @emits Participant#trackDimensionsChanged
 * @emits Participant#trackStarted
 */
var Participant = /** @class */ (function (_super) {
    __extends(Participant, _super);
    /**
     * Construct a {@link Participant}.
     * @param {ParticipantSignaling} signaling
     * @param {object} [options]
     */
    function Participant(signaling, options) {
        var _this = _super.call(this) || this;
        options = Object.assign({
            RemoteAudioTrack: RemoteAudioTrack,
            RemoteAudioTrackPublication: RemoteAudioTrackPublication,
            RemoteDataTrack: RemoteDataTrack,
            RemoteDataTrackPublication: RemoteDataTrackPublication,
            RemoteVideoTrack: RemoteVideoTrack,
            RemoteVideoTrackPublication: RemoteVideoTrackPublication,
            tracks: []
        }, options);
        var indexed = indexTracksById(options.tracks);
        var log = options.log.createLog('default', _this);
        var audioTracks = new Map(indexed.audioTracks);
        var dataTracks = new Map(indexed.dataTracks);
        var tracks = new Map(indexed.tracks);
        var videoTracks = new Map(indexed.videoTracks);
        Object.defineProperties(_this, {
            _RemoteAudioTrack: {
                value: options.RemoteAudioTrack
            },
            _RemoteAudioTrackPublication: {
                value: options.RemoteAudioTrackPublication
            },
            _RemoteDataTrack: {
                value: options.RemoteDataTrack
            },
            _RemoteDataTrackPublication: {
                value: options.RemoteDataTrackPublication
            },
            _RemoteVideoTrack: {
                value: options.RemoteVideoTrack
            },
            _RemoteVideoTrackPublication: {
                value: options.RemoteVideoTrackPublication
            },
            _audioTracks: {
                value: audioTracks
            },
            _dataTracks: {
                value: dataTracks
            },
            _instanceId: {
                value: ++nInstances
            },
            _clientTrackSwitchOffControl: {
                value: options.clientTrackSwitchOffControl,
            },
            _contentPreferencesMode: {
                value: options.contentPreferencesMode,
            },
            _log: {
                value: log
            },
            _signaling: {
                value: signaling
            },
            _tracks: {
                value: tracks
            },
            _trackEventReemitters: {
                value: new Map()
            },
            _trackPublicationEventReemitters: {
                value: new Map()
            },
            _trackSignalingUpdatedEventCallbacks: {
                value: new Map()
            },
            _videoTracks: {
                value: videoTracks
            },
            audioTracks: {
                enumerable: true,
                value: new Map()
            },
            dataTracks: {
                enumerable: true,
                value: new Map()
            },
            identity: {
                enumerable: true,
                get: function () {
                    return signaling.identity;
                }
            },
            networkQualityLevel: {
                enumerable: true,
                get: function () {
                    return signaling.networkQualityLevel;
                }
            },
            networkQualityStats: {
                enumerable: true,
                get: function () {
                    return signaling.networkQualityStats;
                }
            },
            sid: {
                enumerable: true,
                get: function () {
                    return signaling.sid;
                }
            },
            state: {
                enumerable: true,
                get: function () {
                    return signaling.state;
                }
            },
            tracks: {
                enumerable: true,
                value: new Map()
            },
            videoTracks: {
                enumerable: true,
                value: new Map()
            }
        });
        _this._tracks.forEach(reemitTrackEvents.bind(null, _this));
        signaling.on('networkQualityLevelChanged', function () {
            return _this.emit('networkQualityLevelChanged', _this.networkQualityLevel, _this.networkQualityStats &&
                (_this.networkQualityStats.audio || _this.networkQualityStats.video)
                ? _this.networkQualityStats
                : null);
        });
        reemitSignalingStateChangedEvents(_this, signaling);
        log.info("Created a new Participant" + (_this.identity ? ": " + _this.identity : ''));
        return _this;
    }
    /**
     * Get the {@link RemoteTrack} events to re-emit.
     * @private
     * @returns {Array<Array<string>>} events
     */
    Participant.prototype._getTrackEvents = function () {
        return [
            ['dimensionsChanged', 'trackDimensionsChanged'],
            ['message', 'trackMessage'],
            ['started', 'trackStarted']
        ];
    };
    /**
     * @private
     */
    Participant.prototype._getTrackPublicationEvents = function () {
        return [];
    };
    Participant.prototype.toString = function () {
        return "[Participant #" + this._instanceId + ": " + this.sid + "]";
    };
    /**
     * @private
     * @param {RemoteTrack} track
     * @param {Track.ID} id
     * @returns {?RemoteTrack}
     */
    Participant.prototype._addTrack = function (track, id) {
        var log = this._log;
        if (this._tracks.has(id)) {
            return null;
        }
        this._tracks.set(id, track);
        var tracksByKind = {
            audio: this._audioTracks,
            video: this._videoTracks,
            data: this._dataTracks
        }[track.kind];
        tracksByKind.set(id, track);
        reemitTrackEvents(this, track, id);
        log.info("Added a new " + util.trackClass(track) + ":", id);
        log.debug(util.trackClass(track) + ":", track);
        return track;
    };
    /**
     * @private
     * @param {RemoteTrackPublication} publication
     * @returns {?RemoteTrackPublication}
     */
    Participant.prototype._addTrackPublication = function (publication) {
        var log = this._log;
        if (this.tracks.has(publication.trackSid)) {
            return null;
        }
        this.tracks.set(publication.trackSid, publication);
        var trackPublicationsByKind = {
            audio: this.audioTracks,
            data: this.dataTracks,
            video: this.videoTracks
        }[publication.kind];
        trackPublicationsByKind.set(publication.trackSid, publication);
        reemitTrackPublicationEvents(this, publication);
        log.info("Added a new " + util.trackPublicationClass(publication) + ":", publication.trackSid);
        log.debug(util.trackPublicationClass(publication) + ":", publication);
        return publication;
    };
    /**
     * @private
     */
    Participant.prototype._handleTrackSignalingEvents = function () {
        var _a = this, log = _a._log, clientTrackSwitchOffControl = _a._clientTrackSwitchOffControl, contentPreferencesMode = _a._contentPreferencesMode;
        var self = this;
        if (this.state === 'disconnected') {
            return;
        }
        var RemoteAudioTrack = this._RemoteAudioTrack;
        var RemoteAudioTrackPublication = this._RemoteAudioTrackPublication;
        var RemoteVideoTrack = this._RemoteVideoTrack;
        var RemoteVideoTrackPublication = this._RemoteVideoTrackPublication;
        var RemoteDataTrack = this._RemoteDataTrack;
        var RemoteDataTrackPublication = this._RemoteDataTrackPublication;
        var participantSignaling = this._signaling;
        function trackSignalingAdded(signaling) {
            var RemoteTrackPublication = {
                audio: RemoteAudioTrackPublication,
                data: RemoteDataTrackPublication,
                video: RemoteVideoTrackPublication
            }[signaling.kind];
            var publication = new RemoteTrackPublication(signaling, { log: log });
            self._addTrackPublication(publication);
            var isSubscribed = signaling.isSubscribed;
            if (isSubscribed) {
                trackSignalingSubscribed(signaling);
            }
            self._trackSignalingUpdatedEventCallbacks.set(signaling.sid, function () {
                if (isSubscribed !== signaling.isSubscribed) {
                    isSubscribed = signaling.isSubscribed;
                    if (isSubscribed) {
                        trackSignalingSubscribed(signaling);
                        return;
                    }
                    trackSignalingUnsubscribed(signaling);
                }
            });
            signaling.on('updated', self._trackSignalingUpdatedEventCallbacks.get(signaling.sid));
        }
        function trackSignalingRemoved(signaling) {
            if (signaling.isSubscribed) {
                signaling.setTrackTransceiver(null);
            }
            var updated = self._trackSignalingUpdatedEventCallbacks.get(signaling.sid);
            if (updated) {
                signaling.removeListener('updated', updated);
                self._trackSignalingUpdatedEventCallbacks.delete(signaling.sid);
            }
            var publication = self.tracks.get(signaling.sid);
            if (publication) {
                self._removeTrackPublication(publication);
            }
        }
        function trackSignalingSubscribed(signaling) {
            var isEnabled = signaling.isEnabled, name = signaling.name, kind = signaling.kind, sid = signaling.sid, trackTransceiver = signaling.trackTransceiver, isSwitchedOff = signaling.isSwitchedOff;
            var RemoteTrack = {
                audio: RemoteAudioTrack,
                video: RemoteVideoTrack,
                data: RemoteDataTrack
            }[kind];
            var publication = self.tracks.get(sid);
            // NOTE(mroberts): It should never be the case that the TrackSignaling and
            // MediaStreamTrack or DataTrackReceiver kinds disagree; however, just in
            // case, we handle it here.
            if (!RemoteTrack || kind !== trackTransceiver.kind) {
                return;
            }
            var options = { log: log, name: name, clientTrackSwitchOffControl: clientTrackSwitchOffControl, contentPreferencesMode: contentPreferencesMode };
            var setPriority = function (newPriority) { return participantSignaling.updateSubscriberTrackPriority(sid, newPriority); };
            var setRenderHint = function (renderHint) {
                if (signaling.isSubscribed) {
                    participantSignaling.updateTrackRenderHint(sid, renderHint);
                }
            };
            var track = kind === 'data'
                ? new RemoteTrack(sid, trackTransceiver, options)
                : new RemoteTrack(sid, trackTransceiver, isEnabled, isSwitchedOff, setPriority, setRenderHint, options);
            self._addTrack(track, publication, trackTransceiver.id);
        }
        function trackSignalingUnsubscribed(signaling) {
            var _a = __read(Array.from(self._tracks.entries()).find(function (_a) {
                var _b = __read(_a, 2), track = _b[1];
                return track.sid === signaling.sid;
            }), 2), id = _a[0], track = _a[1];
            var publication = self.tracks.get(signaling.sid);
            if (track) {
                self._removeTrack(track, publication, id);
            }
        }
        participantSignaling.on('trackAdded', trackSignalingAdded);
        participantSignaling.on('trackRemoved', trackSignalingRemoved);
        participantSignaling.tracks.forEach(trackSignalingAdded);
        participantSignaling.on('stateChanged', function stateChanged(state) {
            if (state === 'disconnected') {
                log.debug('Removing event listeners');
                participantSignaling.removeListener('stateChanged', stateChanged);
                participantSignaling.removeListener('trackAdded', trackSignalingAdded);
                participantSignaling.removeListener('trackRemoved', trackSignalingRemoved);
            }
            else if (state === 'connected') {
                // NOTE(mmalavalli): Any transition to "connected" here is a result of
                // successful signaling reconnection, and not a first-time establishment
                // of the signaling connection.
                log.info('reconnected');
                // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.
                // Do not signal  public events synchronously with lock held.
                setTimeout(function () { return self.emit('reconnected'); }, 0);
            }
        });
    };
    /**
     * @private
     * @param {RemoteTrack} track
     * @param {Track.ID} id
     * @returns {?RemoteTrack}
     */
    Participant.prototype._removeTrack = function (track, id) {
        if (!this._tracks.has(id)) {
            return null;
        }
        this._tracks.delete(id);
        var tracksByKind = {
            audio: this._audioTracks,
            video: this._videoTracks,
            data: this._dataTracks
        }[track.kind];
        tracksByKind.delete(id);
        var reemitters = this._trackEventReemitters.get(id) || new Map();
        reemitters.forEach(function (reemitter, event) {
            track.removeListener(event, reemitter);
        });
        var log = this._log;
        log.info("Removed a " + util.trackClass(track) + ":", id);
        log.debug(util.trackClass(track) + ":", track);
        return track;
    };
    /**
     * @private
     * @param {RemoteTrackPublication} publication
     * @returns {?RemoteTrackPublication}
     */
    Participant.prototype._removeTrackPublication = function (publication) {
        publication = this.tracks.get(publication.trackSid);
        if (!publication) {
            return null;
        }
        this.tracks.delete(publication.trackSid);
        var trackPublicationsByKind = {
            audio: this.audioTracks,
            data: this.dataTracks,
            video: this.videoTracks
        }[publication.kind];
        trackPublicationsByKind.delete(publication.trackSid);
        var reemitters = this._trackPublicationEventReemitters.get(publication.trackSid) || new Map();
        reemitters.forEach(function (reemitter, event) {
            publication.removeListener(event, reemitter);
        });
        var log = this._log;
        log.info("Removed a " + util.trackPublicationClass(publication) + ":", publication.trackSid);
        log.debug(util.trackPublicationClass(publication) + ":", publication);
        return publication;
    };
    Participant.prototype.toJSON = function () {
        return util.valueToJSON(this);
    };
    return Participant;
}(EventEmitter));
/**
 * A {@link Participant.SID} is a 34-character string starting with "PA"
 * that uniquely identifies a {@link Participant}.
 * @type string
 * @typedef Participant.SID
 */
/**
 * A {@link Participant.Identity} is a string that identifies a
 * {@link Participant}. You can think of it like a name.
 * @typedef {string} Participant.Identity
 */
/**
 * The {@link Participant} has disconnected.
 * @param {Participant} participant - The {@link Participant} that disconnected.
 * @event Participant#disconnected
 */
/**
 * The {@link Participant}'s {@link NetworkQualityLevel} changed.
 * @param {NetworkQualityLevel} networkQualityLevel - The new
 *   {@link NetworkQualityLevel}
 * @param {?NetworkQualityStats} networkQualityStats - The {@link NetworkQualityStats}
 *   based on which {@link NetworkQualityLevel} is calculated, if any
 * @event Participant#networkQualityLevelChanged
 */
/**
 * The {@link Participant} has reconnected to the {@link Room} after a signaling connection disruption.
 * @event Participant#reconnected
 */
/**
 * The {@link Participant} is reconnecting to the {@link Room} after a signaling connection disruption.
 * @event Participant#reconnecting
 */
/**
 * One of the {@link Participant}'s {@link VideoTrack}'s dimensions changed.
 * @param {VideoTrack} track - The {@link VideoTrack} whose dimensions changed
 * @event Participant#trackDimensionsChanged
 */
/**
 * One of the {@link Participant}'s {@link Track}s started.
 * @param {Track} track - The {@link Track} that started
 * @event Participant#trackStarted
 */
/**
 * Indexed {@link Track}s by {@link Track.ID}.
 * @typedef {object} IndexedTracks
 * @property {Array<{0: Track.ID, 1: AudioTrack}>} audioTracks - Indexed
 *   {@link AudioTrack}s
 * @property {Array<{0: Track.ID, 1: DataTrack}>} dataTracks - Indexed
 *   {@link DataTrack}s
 * @property {Array<{0: Track.ID, 1: Track}>} tracks - Indexed {@link Track}s
 * @property {Array<{0: Track.ID, 1: VideoTrack}>} videoTracks - Indexed
 *   {@link VideoTrack}s
 * @private
 */
/**
 * Index tracks by {@link Track.ID}.
 * @param {Array<Track>} tracks
 * @returns {IndexedTracks}
 * @private
 */
function indexTracksById(tracks) {
    var indexedTracks = tracks.map(function (track) { return [track.id, track]; });
    var indexedAudioTracks = indexedTracks.filter(function (keyValue) { return keyValue[1].kind === 'audio'; });
    var indexedVideoTracks = indexedTracks.filter(function (keyValue) { return keyValue[1].kind === 'video'; });
    var indexedDataTracks = indexedTracks.filter(function (keyValue) { return keyValue[1].kind === 'data'; });
    return {
        audioTracks: indexedAudioTracks,
        dataTracks: indexedDataTracks,
        tracks: indexedTracks,
        videoTracks: indexedVideoTracks
    };
}
/**
 * Re-emit {@link ParticipantSignaling} 'stateChanged' events.
 * @param {Participant} participant
 * @param {ParticipantSignaling} signaling
 * @private
 */
function reemitSignalingStateChangedEvents(participant, signaling) {
    var log = participant._log;
    if (participant.state === 'disconnected') {
        return;
    }
    // Reemit state transition events from the ParticipantSignaling.
    signaling.on('stateChanged', function stateChanged(state) {
        log.debug('Transitioned to state:', state);
        participant.emit(state, participant);
        if (state === 'disconnected') {
            log.debug('Removing Track event reemitters');
            signaling.removeListener('stateChanged', stateChanged);
            participant._tracks.forEach(function (track) {
                var reemitters = participant._trackEventReemitters.get(track.id);
                if (track && reemitters) {
                    reemitters.forEach(function (reemitter, event) {
                        track.removeListener(event, reemitter);
                    });
                }
            });
            // eslint-disable-next-line no-warning-comments
            // TODO(joma): Removing this introduced unit test failures in the RemoteParticipant.
            // Investigate further before removing.
            signaling.tracks.forEach(function (trackSignaling) {
                var track = participant._tracks.get(trackSignaling.id);
                var reemitters = participant._trackEventReemitters.get(trackSignaling.id);
                if (track && reemitters) {
                    reemitters.forEach(function (reemitter, event) {
                        track.removeListener(event, reemitter);
                    });
                }
            });
            participant._trackEventReemitters.clear();
            participant.tracks.forEach(function (publication) {
                participant._trackPublicationEventReemitters.get(publication.trackSid)
                    .forEach(function (reemitter, event) {
                    publication.removeListener(event, reemitter);
                });
            });
            participant._trackPublicationEventReemitters.clear();
        }
    });
}
/**
 * Re-emit {@link Track} events.
 * @param {Participant} participant
 * @param {Track} track
 * @param {Track.ID} id
 * @private
 */
function reemitTrackEvents(participant, track, id) {
    var trackEventReemitters = new Map();
    if (participant.state === 'disconnected') {
        return;
    }
    participant._getTrackEvents().forEach(function (eventPair) {
        var trackEvent = eventPair[0];
        var participantEvent = eventPair[1];
        trackEventReemitters.set(trackEvent, function () {
            var args = [participantEvent].concat([].slice.call(arguments));
            return participant.emit.apply(participant, __spreadArray([], __read(args)));
        });
        track.on(trackEvent, trackEventReemitters.get(trackEvent));
    });
    participant._trackEventReemitters.set(id, trackEventReemitters);
}
/**
 * Re-emit {@link TrackPublication} events.
 * @private
 * @param {Participant} participant
 * @param {TrackPublication} publication
 */
function reemitTrackPublicationEvents(participant, publication) {
    var publicationEventReemitters = new Map();
    if (participant.state === 'disconnected') {
        return;
    }
    participant._getTrackPublicationEvents().forEach(function (_a) {
        var _b = __read(_a, 2), publicationEvent = _b[0], participantEvent = _b[1];
        publicationEventReemitters.set(publicationEvent, function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            participant.emit.apply(participant, __spreadArray(__spreadArray([participantEvent], __read(args)), [publication]));
        });
        publication.on(publicationEvent, publicationEventReemitters.get(publicationEvent));
    });
    participant._trackPublicationEventReemitters.set(publication.trackSid, publicationEventReemitters);
}
module.exports = Participant;
//# sourceMappingURL=participant.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/preflight/getCombinedConnectionStats.js":
/*!*******************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/preflight/getCombinedConnectionStats.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCombinedConnectionStats = void 0;
function getStatValues(report, statName, kind, reportTypes) {
    var results = [];
    report.forEach(function (stat) {
        if ((reportTypes.length === 0 || reportTypes.includes(stat.type)) &&
            (kind.length === 0 || kind.includes(stat.kind)) &&
            typeof stat[statName] === 'number') {
            results.push(stat[statName]);
        }
    });
    return results;
}
function getCombinedConnectionStats(_a) {
    var publisher = _a.publisher, subscriber = _a.subscriber;
    return __awaiter(this, void 0, void 0, function () {
        var _b, publisherStats, subscriberStats, timestamps, timestamp, jitter, packets, packetsLost, trackRoundTripTime, currentRoundTripTime, roundTripTime, bytesSent, bytesReceived, selectedIceCandidatePairStats, iceCandidateStats;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, Promise.all([publisher, subscriber].map(function (pc) { return pc.getStats(); }))];
                case 1:
                    _b = __read.apply(void 0, [_c.sent(), 2]), publisherStats = _b[0], subscriberStats = _b[1];
                    timestamps = getStatValues(subscriberStats, 'timestamp', ['audio'], ['inbound-rtp']);
                    timestamp = timestamps.length > 0 ? timestamps[0] : 0;
                    jitter = getStatValues(subscriberStats, 'jitter', ['audio'], ['inbound-rtp']).reduce(function (a, b) { return Math.max(a, b); }, 0);
                    packets = getStatValues(subscriberStats, 'packetsReceived', ['audio', 'video'], ['inbound-rtp']).reduce(function (a, b) { return a + b; }, 0);
                    packetsLost = getStatValues(subscriberStats, 'packetsLost', ['audio', 'video'], ['inbound-rtp']).reduce(function (a, b) { return a + b; }, 0);
                    trackRoundTripTime = getStatValues(publisherStats, 'roundTripTime', ['audio', 'video'], ['remote-inbound-rtp']).reduce(function (a, b) { return Math.max(a, b); }, 0);
                    currentRoundTripTime = getStatValues(subscriberStats, 'currentRoundTripTime', [], ['candidate-pair']).reduce(function (a, b) { return Math.max(a, b); }, 0);
                    roundTripTime = (currentRoundTripTime || trackRoundTripTime) * 1000;
                    bytesSent = getStatValues(publisherStats, 'bytesSent', [], ['candidate-pair']).reduce(function (a, b) { return a + b; }, 0);
                    bytesReceived = getStatValues(subscriberStats, 'bytesReceived', [], ['candidate-pair']).reduce(function (a, b) { return a + b; }, 0);
                    selectedIceCandidatePairStats = extractSelectedActiveCandidatePair(subscriberStats);
                    iceCandidateStats = [];
                    subscriberStats.forEach(function (stat) {
                        if (stat.type === 'local-candidate' || stat.type === 'remote-candidate') {
                            iceCandidateStats.push(makeStandardCandidateStats(stat));
                        }
                    });
                    return [2 /*return*/, { timestamp: timestamp, jitter: jitter, packets: packets, packetsLost: packetsLost, roundTripTime: roundTripTime, bytesSent: bytesSent, bytesReceived: bytesReceived, selectedIceCandidatePairStats: selectedIceCandidatePairStats, iceCandidateStats: iceCandidateStats }];
            }
        });
    });
}
exports.getCombinedConnectionStats = getCombinedConnectionStats;
function makeStandardCandidateStats(input) {
    var standardizedCandidateStatsKeys = [
        { key: 'transportId', type: 'string' },
        { key: 'candidateType', type: 'string' },
        { key: 'port', altKeys: ['portNumber'], type: 'number' },
        { key: 'address', altKeys: ['ip', 'ipAddress'], type: 'string' },
        { key: 'priority', type: 'number' },
        { key: 'protocol', altKeys: ['transport'], type: 'string' },
        { key: 'url', type: 'string' },
        { key: 'deleted', type: 'boolean' },
        { key: 'relayProtocol', type: 'string' },
    ];
    return standardizedCandidateStatsKeys.reduce(function (report, keyInfo) {
        var keysToLookFor = [keyInfo.key];
        if (keyInfo.altKeys) {
            keysToLookFor = keysToLookFor.concat(keyInfo.altKeys);
        }
        var key = keysToLookFor.find(function (key) { return key in input; });
        if (key && typeof input[key] === keyInfo.type) {
            report[keyInfo.key] = input[key];
        }
        return report;
    }, {});
}
function extractSelectedActiveCandidatePair(stats) {
    var selectedCandidatePairId = null;
    var candidatePairs = [];
    stats.forEach(function (stat) {
        if (stat.type === 'transport' && stat.selectedCandidatePairId) {
            selectedCandidatePairId = stat.selectedCandidatePairId;
        }
        else if (stat.type === 'candidate-pair') {
            candidatePairs.push(stat);
        }
    });
    var activeCandidatePairStatsFound = candidatePairs.find(function (pair) {
        // Firefox
        return pair.selected ||
            // Spec-compliant way
            (selectedCandidatePairId && pair.id === selectedCandidatePairId);
    });
    if (!activeCandidatePairStatsFound) {
        return null;
    }
    var activeCandidatePairStats = activeCandidatePairStatsFound;
    var activeLocalCandidateStats = stats.get(activeCandidatePairStats.localCandidateId);
    var activeRemoteCandidateStats = stats.get(activeCandidatePairStats.remoteCandidateId);
    if (!activeLocalCandidateStats || !activeRemoteCandidateStats) {
        return null;
    }
    return {
        localCandidate: makeStandardCandidateStats(activeLocalCandidateStats),
        remoteCandidate: makeStandardCandidateStats(activeRemoteCandidateStats)
    };
}
//# sourceMappingURL=getCombinedConnectionStats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/preflight/getturncredentials.js":
/*!***********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/preflight/getturncredentials.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTurnCredentials = void 0;
var TwilioConnection = __webpack_require__(/*! ../twilioconnection.js */ "../../work/twilio-video.js/es5/twilioconnection.js");
var _a = __webpack_require__(/*! ../util/constants */ "../../work/twilio-video.js/es5/util/constants.js"), WS_SERVER = _a.WS_SERVER, ICE_VERSION = _a.ICE_VERSION;
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
function getTurnCredentials(token, options) {
    return new Promise(function (resolve, reject) {
        options = __assign({ environment: 'prod', region: 'gll' }, options);
        // eslint-disable-next-line new-cap
        var wsServer = WS_SERVER(options.environment, options.region);
        var eventObserver = new events_1.EventEmitter();
        var connectionOptions = {
            networkMonitor: null,
            eventObserver: eventObserver,
            helloBody: {
                edge: 'roaming',
                preflight: true,
                token: token,
                type: 'ice',
                version: ICE_VERSION
            },
        };
        var twilioConnection = new TwilioConnection(wsServer, connectionOptions);
        var done = false;
        twilioConnection.once('close', function (reason) {
            if (!done) {
                done = true;
                reject(reason);
            }
        });
        // eslint-disable-next-line camelcase
        twilioConnection.on('message', function (message) {
            if (message.type === 'iced') {
                if (!done) {
                    done = true;
                    resolve(message.ice_servers);
                    twilioConnection.close();
                }
            }
        });
    });
}
exports.getTurnCredentials = getTurnCredentials;
//# sourceMappingURL=getturncredentials.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/preflight/makestat.js":
/*!*************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/preflight/makestat.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeStat = void 0;
/**
 * Computes min, max, average for given array.
 * @param {Array<number>} values
 * @returns {{min: number, max: number: average: number}|null}
 */
function makeStat(values) {
    if (values.length) {
        var min = Math.min.apply(Math, __spreadArray([], __read(values)));
        var max = Math.max.apply(Math, __spreadArray([], __read(values)));
        var average = values.reduce(function (total, value) { return total + value; }, 0) / values.length;
        return { min: min, max: max, average: average };
    }
    return null;
}
exports.makeStat = makeStat;
//# sourceMappingURL=makestat.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/preflight/mos.js":
/*!********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/preflight/mos.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.mosToScore = exports.calculateMOS = void 0;
var r0 = 94.768; // Constant used in computing "rFactor".
// copied from https://code.hq.twilio.com/client/sdk-frd/blob/master/voice/voice-mos-calculation.md
function calculateMOS(rtt, jitter, fractionLost) {
    // Compute the effective latency.
    var effectiveLatency = rtt + (jitter * 2) + 10;
    // Compute the initial "rFactor" from effective latency.
    var rFactor = 0;
    switch (true) {
        case effectiveLatency < 160:
            rFactor = r0 - (effectiveLatency / 40);
            break;
        case effectiveLatency < 1000:
            rFactor = r0 - ((effectiveLatency - 120) / 10);
            break;
    }
    // Adjust "rFactor" with the fraction of packets lost.
    switch (true) {
        case fractionLost <= (rFactor / 2.5):
            rFactor = Math.max(rFactor - fractionLost * 2.5, 6.52);
            break;
        default:
            rFactor = 0;
            break;
    }
    // Compute MOS from "rFactor".
    var mos = 1 +
        (0.035 * rFactor) +
        (0.000007 * rFactor) *
            (rFactor - 60) *
            (100 - rFactor);
    return mos;
}
exports.calculateMOS = calculateMOS;
function mosToScore(mosValue) {
    var score = 0;
    if (!mosValue) {
        score = 0;
    }
    else if (mosValue > 4.2) {
        score = 5;
    }
    else if (mosValue > 4.0) {
        score = 4;
    }
    else if (mosValue > 3.6) {
        score = 3;
    }
    else if (mosValue > 3) {
        score = 2;
    }
    else {
        score = 1;
    }
    return score;
}
exports.mosToScore = mosToScore;
//# sourceMappingURL=mos.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/preflight/preflighttest.js":
/*!******************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/preflight/preflighttest.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runPreflight = exports.PreflightTest = void 0;
var constants_1 = __webpack_require__(/*! ../util/constants */ "../../work/twilio-video.js/es5/util/constants.js");
var timer_1 = __webpack_require__(/*! ./timer */ "../../work/twilio-video.js/es5/preflight/timer.js");
var mos_1 = __webpack_require__(/*! ./mos */ "../../work/twilio-video.js/es5/preflight/mos.js");
var getCombinedConnectionStats_1 = __webpack_require__(/*! ./getCombinedConnectionStats */ "../../work/twilio-video.js/es5/preflight/getCombinedConnectionStats.js");
var getturncredentials_1 = __webpack_require__(/*! ./getturncredentials */ "../../work/twilio-video.js/es5/preflight/getturncredentials.js");
var makestat_1 = __webpack_require__(/*! ./makestat */ "../../work/twilio-video.js/es5/preflight/makestat.js");
var syntheticaudio_1 = __webpack_require__(/*! ./syntheticaudio */ "../../work/twilio-video.js/es5/preflight/syntheticaudio.js");
var syntheticvideo_1 = __webpack_require__(/*! ./syntheticvideo */ "../../work/twilio-video.js/es5/preflight/syntheticvideo.js");
var util_1 = __webpack_require__(/*! ../util */ "../../work/twilio-video.js/es5/util/index.js");
var Log = __webpack_require__(/*! ../util/log */ "../../work/twilio-video.js/es5/util/log.js");
var EventEmitter = __webpack_require__(/*! ../eventemitter */ "../../work/twilio-video.js/es5/eventemitter.js");
var MovingAverageDelta = __webpack_require__(/*! ../util/movingaveragedelta */ "../../work/twilio-video.js/es5/util/movingaveragedelta.js");
var SECOND = 1000;
var DEFAULT_TEST_DURATION = 10 * SECOND;
/**
 * progress values that are sent by {@link PreflightTest#event:progress}
 * @enum {string}
 */
var PreflightProgress = {
    /**
     * {@link PreflightTest} has successfully generated synthetic tracks
     */
    mediaAcquired: 'mediaAcquired',
    /**
     * {@link PreflightTest} has successfully connected to twilio server and obtained turn credentials
     */
    connected: 'connected',
    /**
     * subscriberParticipant successfully subscribed to media tracks.
     */
    mediaSubscribed: 'mediaSubscribed',
    /**
     * media flow was detected.
     */
    mediaStarted: 'mediaStarted',
    /**
     * established DTLS connection. This is measured from RTCDtlsTransport `connecting` to `connected` state.
     * On Safari, Support for measuring this is missing, this event will be not be emitted on Safari.
     */
    dtlsConnected: 'dtlsConnected',
    /**
     * established a PeerConnection, This is measured from PeerConnection `connecting` to `connected` state.
     * On Firefox, Support for measuring this is missing, this event will be not be emitted on Firefox.
     */
    peerConnectionConnected: 'peerConnectionConnected',
    /**
     * established ICE connection. This is measured from ICE connection `checking` to `connected` state.
     */
    iceConnected: 'iceConnected'
};
function notEmpty(value) {
    return value !== null && typeof value !== 'undefined';
}
var nInstances = 0;
/**
 * A {@link PreflightTest} monitors progress of an ongoing preflight test.
 * <br><br>
 * Instance of {@link PreflightTest} is returned by calling {@link module:twilio-video.runPreflight}
 * @extends EventEmitter
 * @emits PreflightTest#completed
 * @emits PreflightTest#failed
 * @emits PreflightTest#progress
 */
var PreflightTest = /** @class */ (function (_super) {
    __extends(PreflightTest, _super);
    /**
     * Constructs {@link PreflightTest}.
     * @param {string} token
     * @param {?PreflightOptions} [options]
     */
    function PreflightTest(token, options) {
        var _this = _super.call(this) || this;
        _this._testTiming = new timer_1.Timer();
        _this._dtlsTiming = new timer_1.Timer();
        _this._iceTiming = new timer_1.Timer();
        _this._peerConnectionTiming = new timer_1.Timer();
        _this._mediaTiming = new timer_1.Timer();
        _this._connectTiming = new timer_1.Timer();
        _this._sentBytesMovingAverage = new MovingAverageDelta();
        _this._packetLossMovingAverage = new MovingAverageDelta();
        _this._receivedBytesMovingAverage = new MovingAverageDelta();
        _this._log = new Log('default', _this, constants_1.DEFAULT_LOG_LEVEL, constants_1.DEFAULT_LOGGER_NAME);
        _this._testDuration = options.duration || DEFAULT_TEST_DURATION;
        _this._instanceId = nInstances++;
        _this._testTiming.start();
        _this._runPreflightTest(token, options);
        return _this;
    }
    PreflightTest.prototype.toString = function () {
        return "[Preflight #" + this._instanceId + "]";
    };
    /**
     * stops ongoing tests and emits error
     */
    PreflightTest.prototype.stop = function () {
        this._stopped = true;
    };
    PreflightTest.prototype._generatePreflightReport = function (collectedStats) {
        this._testTiming.stop();
        return {
            testTiming: this._testTiming.getTimeMeasurement(),
            networkTiming: {
                dtls: this._dtlsTiming.getTimeMeasurement(),
                ice: this._iceTiming.getTimeMeasurement(),
                peerConnection: this._peerConnectionTiming.getTimeMeasurement(),
                connect: this._connectTiming.getTimeMeasurement(),
                media: this._mediaTiming.getTimeMeasurement()
            },
            stats: {
                jitter: makestat_1.makeStat(collectedStats.jitter),
                rtt: makestat_1.makeStat(collectedStats.rtt),
                packetLoss: makestat_1.makeStat(collectedStats.packetLoss),
            },
            selectedIceCandidatePairStats: collectedStats.selectedIceCandidatePairStats,
            iceCandidateStats: collectedStats.iceCandidateStats
        };
    };
    PreflightTest.prototype._executePreflightStep = function (stepName, step) {
        return __awaiter(this, void 0, void 0, function () {
            var MAX_STEP_DURATION, stepPromise, timer, timeoutPromise, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._log.debug('Executing step: ', stepName);
                        MAX_STEP_DURATION = this._testDuration + 10 * SECOND;
                        if (this._stopped) {
                            throw new Error('stopped');
                        }
                        stepPromise = Promise.resolve().then(step);
                        timer = null;
                        timeoutPromise = new Promise(function (_resolve, reject) {
                            timer = setTimeout(function () {
                                reject(new Error("Timed out waiting for : " + stepName));
                            }, MAX_STEP_DURATION);
                        });
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, Promise.race([timeoutPromise, stepPromise])];
                    case 2:
                        result = _a.sent();
                        return [2 /*return*/, result];
                    case 3:
                        if (timer !== null) {
                            clearTimeout(timer);
                        }
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    PreflightTest.prototype._trackNetworkTimings = function (pc) {
        var _this = this;
        pc.addEventListener('iceconnectionstatechange', function () {
            if (pc.iceConnectionState === 'checking') {
                _this._iceTiming.start();
            }
            if (pc.iceConnectionState === 'connected') {
                _this._iceTiming.stop();
                _this.emit('progress', PreflightProgress.iceConnected);
            }
        });
        // firefox does not support connectionstatechange.
        pc.addEventListener('connectionstatechange', function () {
            if (pc.connectionState === 'connecting') {
                _this._peerConnectionTiming.start();
            }
            if (pc.connectionState === 'connected') {
                _this._peerConnectionTiming.stop();
                _this.emit('progress', PreflightProgress.peerConnectionConnected);
            }
        });
        // Safari does not expose sender.transport.
        var senders = pc.getSenders();
        var transport = senders.map(function (sender) { return sender.transport; }).find(notEmpty);
        if (typeof transport !== 'undefined') {
            var dtlsTransport_1 = transport;
            dtlsTransport_1.addEventListener('statechange', function () {
                if (dtlsTransport_1.state === 'connecting') {
                    _this._dtlsTiming.start();
                }
                if (dtlsTransport_1.state === 'connected') {
                    _this._dtlsTiming.stop();
                    _this.emit('progress', PreflightProgress.dtlsConnected);
                }
            });
        }
    };
    PreflightTest.prototype._runPreflightTest = function (token, options) {
        return __awaiter(this, void 0, void 0, function () {
            var localTracks, pcs, elements_1, iceServers, senderPC_1, receiverPC_1, remoteTracks_1, collectedStats_1, report, error_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        localTracks = [];
                        pcs = [];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 8, 9, 10]);
                        elements_1 = [];
                        return [4 /*yield*/, this._executePreflightStep('Acquire media', function () { return [syntheticaudio_1.syntheticAudio(), syntheticvideo_1.syntheticVideo({ width: 640, height: 480 })]; })];
                    case 2:
                        localTracks = _a.sent();
                        this.emit('progress', PreflightProgress.mediaAcquired);
                        this.emit('debug', { localTracks: localTracks });
                        this._connectTiming.start();
                        return [4 /*yield*/, this._executePreflightStep('Get turn credentials', function () { return getturncredentials_1.getTurnCredentials(token, options); })];
                    case 3:
                        iceServers = _a.sent();
                        this._connectTiming.stop();
                        this.emit('progress', PreflightProgress.connected);
                        senderPC_1 = new RTCPeerConnection({ iceServers: iceServers, iceTransportPolicy: 'relay', bundlePolicy: 'max-bundle' });
                        receiverPC_1 = new RTCPeerConnection({ iceServers: iceServers, bundlePolicy: 'max-bundle' });
                        pcs.push(senderPC_1);
                        pcs.push(receiverPC_1);
                        this._mediaTiming.start();
                        return [4 /*yield*/, this._executePreflightStep('Setup Peer Connections', function () { return __awaiter(_this, void 0, void 0, function () {
                                var remoteTracksPromise, offer, updatedOffer, answer, updatedAnswer;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            senderPC_1.addEventListener('icecandidate', function (event) { return event.candidate && receiverPC_1.addIceCandidate(event.candidate); });
                                            receiverPC_1.addEventListener('icecandidate', function (event) { return event.candidate && senderPC_1.addIceCandidate(event.candidate); });
                                            localTracks.forEach(function (track) { return senderPC_1.addTrack(track); });
                                            remoteTracksPromise = new Promise(function (resolve) {
                                                var remoteTracks = [];
                                                receiverPC_1.addEventListener('track', function (event) {
                                                    remoteTracks.push(event.track);
                                                    if (remoteTracks.length === localTracks.length) {
                                                        resolve(remoteTracks);
                                                    }
                                                });
                                            });
                                            return [4 /*yield*/, senderPC_1.createOffer()];
                                        case 1:
                                            offer = _a.sent();
                                            updatedOffer = offer;
                                            return [4 /*yield*/, senderPC_1.setLocalDescription(updatedOffer)];
                                        case 2:
                                            _a.sent();
                                            return [4 /*yield*/, receiverPC_1.setRemoteDescription(updatedOffer)];
                                        case 3:
                                            _a.sent();
                                            return [4 /*yield*/, receiverPC_1.createAnswer()];
                                        case 4:
                                            answer = _a.sent();
                                            updatedAnswer = answer;
                                            return [4 /*yield*/, receiverPC_1.setLocalDescription(updatedAnswer)];
                                        case 5:
                                            _a.sent();
                                            return [4 /*yield*/, senderPC_1.setRemoteDescription(updatedAnswer)];
                                        case 6:
                                            _a.sent();
                                            this._trackNetworkTimings(senderPC_1);
                                            return [2 /*return*/, remoteTracksPromise];
                                    }
                                });
                            }); })];
                    case 4:
                        remoteTracks_1 = _a.sent();
                        this.emit('debug', { remoteTracks: remoteTracks_1 });
                        remoteTracks_1.forEach(function (track) {
                            track.addEventListener('ended', function () { return _this._log.warn(track.kind + ':ended'); });
                            track.addEventListener('mute', function () { return _this._log.warn(track.kind + ':muted'); });
                            track.addEventListener('unmute', function () { return _this._log.warn(track.kind + ':unmuted'); });
                        });
                        this.emit('progress', PreflightProgress.mediaSubscribed);
                        return [4 /*yield*/, this._executePreflightStep('wait for tracks to start', function () {
                                return new Promise(function (resolve) {
                                    var element = document.createElement('video');
                                    element.autoplay = true;
                                    element.playsInline = true;
                                    element.muted = true;
                                    element.srcObject = new MediaStream(remoteTracks_1);
                                    elements_1.push(element);
                                    _this.emit('debugElement', element);
                                    element.oncanplay = resolve;
                                });
                            })];
                    case 5:
                        _a.sent();
                        this._mediaTiming.stop();
                        this.emit('progress', PreflightProgress.mediaStarted);
                        return [4 /*yield*/, this._executePreflightStep('collect stats for duration', function () { return _this._collectRTCStatsForDuration(_this._testDuration, initCollectedStats(), senderPC_1, receiverPC_1); })];
                    case 6:
                        collectedStats_1 = _a.sent();
                        return [4 /*yield*/, this._executePreflightStep('generate report', function () { return _this._generatePreflightReport(collectedStats_1); })];
                    case 7:
                        report = _a.sent();
                        this.emit('completed', report);
                        return [3 /*break*/, 10];
                    case 8:
                        error_1 = _a.sent();
                        this.emit('failed', error_1);
                        return [3 /*break*/, 10];
                    case 9:
                        pcs.forEach(function (pc) { return pc.close(); });
                        localTracks.forEach(function (track) { return track.stop(); });
                        return [7 /*endfinally*/];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    PreflightTest.prototype._collectRTCStats = function (collectedStats, senderPC, receiverPC) {
        return __awaiter(this, void 0, void 0, function () {
            var combinedStats, timestamp, bytesSent, bytesReceived, packets, packetsLost, roundTripTime, jitter, selectedIceCandidatePairStats, iceCandidateStats, hasLastData, fractionPacketLost, percentPacketsLost, score;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getCombinedConnectionStats_1.getCombinedConnectionStats({ publisher: senderPC, subscriber: receiverPC })];
                    case 1:
                        combinedStats = _a.sent();
                        timestamp = combinedStats.timestamp, bytesSent = combinedStats.bytesSent, bytesReceived = combinedStats.bytesReceived, packets = combinedStats.packets, packetsLost = combinedStats.packetsLost, roundTripTime = combinedStats.roundTripTime, jitter = combinedStats.jitter, selectedIceCandidatePairStats = combinedStats.selectedIceCandidatePairStats, iceCandidateStats = combinedStats.iceCandidateStats;
                        hasLastData = collectedStats.jitter.length > 0;
                        collectedStats.jitter.push(jitter);
                        collectedStats.rtt.push(roundTripTime);
                        this._sentBytesMovingAverage.putSample(bytesSent, timestamp);
                        this._receivedBytesMovingAverage.putSample(bytesReceived, timestamp);
                        this._packetLossMovingAverage.putSample(packetsLost, packets);
                        if (hasLastData) {
                            // convert BytesMovingAverage which is in bytes/millisecond to bits/second
                            collectedStats.outgoingBitrate.push(this._sentBytesMovingAverage.get() * 1000 * 8);
                            collectedStats.incomingBitrate.push(this._receivedBytesMovingAverage.get() * 1000 * 8);
                            fractionPacketLost = this._packetLossMovingAverage.get();
                            percentPacketsLost = Math.min(100, fractionPacketLost * 100);
                            collectedStats.packetLoss.push(percentPacketsLost);
                            score = mos_1.calculateMOS(roundTripTime, jitter, fractionPacketLost);
                            collectedStats.mos.push(score);
                        }
                        if (!collectedStats.selectedIceCandidatePairStats) {
                            collectedStats.selectedIceCandidatePairStats = selectedIceCandidatePairStats;
                        }
                        if (collectedStats.iceCandidateStats.length === 0) {
                            collectedStats.iceCandidateStats = iceCandidateStats;
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    PreflightTest.prototype._collectRTCStatsForDuration = function (duration, collectedStats, senderPC, receiverPC) {
        return __awaiter(this, void 0, void 0, function () {
            var startTime, STAT_INTERVAL, remainingDuration;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        startTime = Date.now();
                        STAT_INTERVAL = Math.min(1000, duration);
                        return [4 /*yield*/, util_1.waitForSometime(STAT_INTERVAL)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this._collectRTCStats(collectedStats, senderPC, receiverPC)];
                    case 2:
                        _a.sent();
                        remainingDuration = duration - (Date.now() - startTime);
                        if (!(remainingDuration > 0)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this._collectRTCStatsForDuration(remainingDuration, collectedStats, senderPC, receiverPC)];
                    case 3:
                        collectedStats = _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/, collectedStats];
                }
            });
        });
    };
    return PreflightTest;
}(EventEmitter));
exports.PreflightTest = PreflightTest;
function initCollectedStats() {
    return {
        mos: [],
        jitter: [],
        rtt: [],
        outgoingBitrate: [],
        incomingBitrate: [],
        packetLoss: [],
        selectedIceCandidatePairStats: null,
        iceCandidateStats: [],
    };
}
/**
 * Represents network timing measurements captured during preflight test
 * @typedef {object} NetworkTiming
 * @property {TimeMeasurement} [connect] - Time to establish signaling connection and acquire turn credentials
 * @property {TimeMeasurement} [media] - Time to start media. This is measured from calling connect to remote media getting started.
 * @property {TimeMeasurement} [dtls] - Time to establish dtls connection. This is measured from RTCDtlsTransport `connecting` to `connected` state. (Not available on Safari)
 * @property {TimeMeasurement} [ice] - Time to establish ice connectivity. This is measured from ICE connection `checking` to `connected` state.
 * @property {TimeMeasurement} [peerConnection] - Time to establish peer connectivity. This is measured from PeerConnection `connecting` to `connected` state. (Not available on Firefox)
 */
/**
 * Represents stats for a numerical metric.
 * @typedef {object} Stats
 * @property  {number} [average] - average value observed.
 * @property  {number} [max] - max value observed.
 * @property  {number} [min] - min value observed.
 */
/**
 * Represents stats for a numerical metric.
 * @typedef {object} SelectedIceCandidatePairStats
 * @property  {RTCIceCandidateStats} [localCandidate] - selected local ice candidate
 * @property  {RTCIceCandidateStats} [remoteCandidate] - selected local ice candidate
 */
/**
 * Represents RTC related stats that were observed during preflight test
 * @typedef {object} PreflightReportStats
 * @property {Stats} [jitter] - Packet delay variation in seconds
 * @property {Stats} [rtt] - Round trip time, to the server back to the client in milliseconds.
 * @property {Stats} [packetLoss] - Packet loss as a percent of total packets sent.
*/
/**
 * Represents report generated by {@link PreflightTest}.
 * @typedef {object} PreflightTestReport
 * @property {TimeMeasurement} [testTiming] - Time measurements of test run time.
 * @property {NetworkTiming} [networkTiming] - Network related time measurements.
 * @property {PreflightReportStats} [stats] - RTC related stats captured during the test.
 * @property {Array<RTCIceCandidateStats>} [iceCandidateStats] - List of gathered ice candidates.
 * @property {SelectedIceCandidatePairStats} selectedIceCandidatePairStats - stats for the ice candidates that were used for the connection.
 */
/**
 * You may pass these options to {@link module:twilio-video.testPreflight} in order to override the
 * default behavior.
 * @typedef {object} PreflightOptions
 * @property {string} [region='gll'] - Preferred signaling region; By default, you will be connected to the
 *   nearest signaling server determined by latency based routing. Setting a value other
 *   than <code style="padding:0 0">gll</code> bypasses routing and guarantees that signaling traffic will be
 *   terminated in the region that you prefer. Please refer to this <a href="https://www.twilio.com/docs/video/ip-address-whitelisting#signaling-communication" target="_blank">table</a>
 *   for the list of supported signaling regions.
 * @property {number} [duration=10000] - number of milliseconds to run test for.
 *   once connected test will run for this duration before generating the stats report.
 */
/**
 * Preflight test has completed successfully.
 * @param {PreflightTestReport} report - results of the test.
 * @event PreflightTest#completed
 */
/**
 * Preflight test has encountered a failed and is now stopped.
 * @param {TwilioError|Error} error - error object
 * @event PreflightTest#failed
 */
/**
 * Emitted to indicate progress of the test
 * @param {PreflightProgress} progress - indicates the status completed.
 * @event PreflightTest#progress
 */
/**
 * @method
 * @name runPreflight
 * @description Run a preflight test. This method will start a test to check the quality of network connection.
 * @memberof module:twilio-video
 * @param {string} token - The Access Token string
 * @param {PreflightOptions} options - options for the test
 * @returns {PreflightTest} preflightTest - an instance to be used to monitor progress of the test.
 * @example
 * var { runPreflight } = require('twilio-video');
 * var preflight = runPreflight();
 * preflightTest.on('progress', progress => {
 *   console.log('preflight progress:', progress);
 * });
 *
 * preflightTest.on('failed', error => {
 *   console.error('preflight error:', error);
 * });
 *
 * preflightTest.on('completed', report => {
 *   console.log('preflight completed:', report));
 * });
*/
function runPreflight(token, options) {
    if (options === void 0) { options = {}; }
    var preflight = new PreflightTest(token, options);
    return preflight;
}
exports.runPreflight = runPreflight;
//# sourceMappingURL=preflighttest.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/preflight/syntheticaudio.js":
/*!*******************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/preflight/syntheticaudio.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.syntheticAudio = void 0;
function syntheticAudio() {
    // NOTE(mpatwardhan): We have to delay require-ing AudioContextFactory, because
    // it exports a default instance whose constructor calls Object.assign.
    var audioContextFactory = __webpack_require__(/*! ../webaudio/audiocontext */ "../../work/twilio-video.js/es5/webaudio/audiocontext.js");
    var holder = {};
    var audioContext = audioContextFactory.getOrCreate(holder);
    var oscillator = audioContext.createOscillator();
    var dst = oscillator.connect(audioContext.createMediaStreamDestination());
    oscillator.start();
    var track = dst.stream.getAudioTracks()[0];
    var originalStop = track.stop;
    track.stop = function () {
        originalStop.call(track);
        audioContextFactory.release(holder);
    };
    return track;
}
exports.syntheticAudio = syntheticAudio;
//# sourceMappingURL=syntheticaudio.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/preflight/syntheticvideo.js":
/*!*******************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/preflight/syntheticvideo.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.syntheticVideo = void 0;
function syntheticVideo(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.width, width = _c === void 0 ? 640 : _c, _d = _b.height, height = _d === void 0 ? 480 : _d;
    var canvas = Object.assign(document.createElement('canvas'), { width: width, height: height });
    var ctx = canvas.getContext('2d');
    ctx.fillStyle = 'green';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    var stopped = false;
    requestAnimationFrame(function animate() {
        if (!stopped) {
            // draw random rect/circle.
            var r = Math.round(Math.random() * 255);
            var g = Math.round(Math.random() * 255);
            var b = Math.round(Math.random() * 255);
            var a = Math.round(Math.random() * 255);
            ctx.fillStyle = "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
            ctx.fillRect(Math.random() * width, Math.random() * height, 50, 50);
            requestAnimationFrame(animate);
        }
    });
    var stream = canvas.captureStream(30);
    var track = stream.getTracks()[0];
    var originalStop = track.stop;
    track.stop = function () {
        stopped = true;
        originalStop.call(track);
    };
    return track;
}
exports.syntheticVideo = syntheticVideo;
//# sourceMappingURL=syntheticvideo.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/preflight/timer.js":
/*!**********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/preflight/timer.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Timer = void 0;
var Timer = /** @class */ (function () {
    function Timer() {
        // eslint-disable-next-line no-undefined
        this._end = undefined;
        this.start();
    }
    Timer.prototype.start = function () {
        this._start = Date.now();
        return this;
    };
    Timer.prototype.stop = function () {
        this._end = Date.now();
        return this;
    };
    Timer.prototype.getTimeMeasurement = function () {
        return {
            start: this._start,
            end: this._end,
            // eslint-disable-next-line no-undefined
            duration: this._end === undefined ? undefined : this._end - this._start
        };
    };
    return Timer;
}());
exports.Timer = Timer;
//# sourceMappingURL=timer.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/queueingeventemitter.js":
/*!***************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/queueingeventemitter.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
/**
 * A {@link QueueingEventEmitter} can queue events until a listener has been
 * added.
 * @extends EventEmitter
 */
var QueueingEventEmitter = /** @class */ (function (_super) {
    __extends(QueueingEventEmitter, _super);
    /**
     * Construct a {@link QueueingEventEmitter}
     */
    function QueueingEventEmitter() {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _queuedEvents: {
                value: new Map()
            }
        });
        return _this;
    }
    /**
     * Emit any queued events.
     * @returns {boolean} true if every event had listeners, false otherwise
    */ /**
     * Emit any queued events matching the event name.
     * @param {string} event
     * @returns {boolean} true if every event had listeners, false otherwise
     */
    QueueingEventEmitter.prototype.dequeue = function (event) {
        var _this = this;
        var result = true;
        if (!event) {
            this._queuedEvents.forEach(function (_, queuedEvent) {
                result = this.dequeue(queuedEvent) && result;
            }, this);
            return result;
        }
        var queue = this._queuedEvents.get(event) || [];
        this._queuedEvents.delete(event);
        return queue.reduce(function (result, args) { return _this.emit.apply(_this, __spreadArray([], __read([event].concat(args)))) && result; }, result);
    };
    /**
     * If the event has listeners, emit the event; otherwise, queue the event.
     * @param {string} event
     * @param {...*} args
     * @returns {boolean} true if the event had listeners, false if the event was queued
     */
    QueueingEventEmitter.prototype.queue = function () {
        var args = [].slice.call(arguments);
        if (this.emit.apply(this, __spreadArray([], __read(args)))) {
            return true;
        }
        var event = args[0];
        if (!this._queuedEvents.has(event)) {
            this._queuedEvents.set(event, []);
        }
        this._queuedEvents.get(event).push(args.slice(1));
        return false;
    };
    return QueueingEventEmitter;
}(EventEmitter));
module.exports = QueueingEventEmitter;
//# sourceMappingURL=queueingeventemitter.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/remoteparticipant.js":
/*!************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/remoteparticipant.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var Participant = __webpack_require__(/*! ./participant */ "../../work/twilio-video.js/es5/participant.js");
/**
 * A {@link RemoteParticipant} represents a remote {@link Participant} in a
 * {@link Room}.
 * @extends Participant
 * @property {Map<Track.SID, RemoteAudioTrackPublication>} audioTracks -
 *    The {@link Participant}'s {@link RemoteAudioTrackPublication}s
 * @property {Map<Track.SID, RemoteDataTrackPublication>} dataTracks -
 *    The {@link Participant}'s {@link RemoteDataTrackPublication}s
 * @property {Map<Track.SID, RemoteTrackPublication>} tracks -
 *    The {@link Participant}'s {@link RemoteTrackPublication}s
 * @property {Map<Track.SID, RemoteVideoTrackPublication>} videoTracks -
 *    The {@link Participant}'s {@link RemoteVideoTrackPublication}s
 * @emits RemoteParticipant#reconnected
 * @emits RemoteParticipant#reconnecting
 * @emits RemoteParticipant#trackDimensionsChanged
 * @emits RemoteParticipant#trackDisabled
 * @emits RemoteParticipant#trackEnabled
 * @emits RemoteParticipant#trackMessage
 * @emits RemoteParticipant#trackPublished
 * @emits RemoteParticipant#trackPublishPriorityChanged
 * @emits RemoteParticipant#trackStarted
 * @emits RemoteParticipant#trackSubscribed
 * @emits RemoteParticipant#trackSubscriptionFailed
 * @emits RemoteParticipant#trackSwitchedOff
 * @emits RemoteParticipant#trackSwitchedOn
 * @emits RemoteParticipant#trackUnpublished
 * @emits RemoteParticipant#trackUnsubscribed
 */
var RemoteParticipant = /** @class */ (function (_super) {
    __extends(RemoteParticipant, _super);
    /**
     * Construct a {@link RemoteParticipant}.
     * @param {ParticipantSignaling} signaling
     * @param {object} [options]
     */
    function RemoteParticipant(signaling, options) {
        var _this = _super.call(this, signaling, options) || this;
        _this._handleTrackSignalingEvents();
        _this.once('disconnected', _this._unsubscribeTracks.bind(_this));
        return _this;
    }
    RemoteParticipant.prototype.toString = function () {
        return "[RemoteParticipant #" + this._instanceId + (this.sid ? ": " + this.sid : '') + "]";
    };
    /**
     * @private
     * @param {RemoteTrack} remoteTrack
     * @param {RemoteTrackPublication} publication
     * @param {Track.ID} id
     * @returns {?RemoteTrack}
     */
    RemoteParticipant.prototype._addTrack = function (remoteTrack, publication, id) {
        if (!_super.prototype._addTrack.call(this, remoteTrack, id)) {
            return null;
        }
        publication._subscribed(remoteTrack);
        this.emit('trackSubscribed', remoteTrack, publication);
        return remoteTrack;
    };
    /**
     * @private
     * @param {RemoteTrackPublication} publication
     * @returns {?RemoteTrackPublication}
     */
    RemoteParticipant.prototype._addTrackPublication = function (publication) {
        var addedPublication = _super.prototype._addTrackPublication.call(this, publication);
        if (!addedPublication) {
            return null;
        }
        this.emit('trackPublished', addedPublication);
        return addedPublication;
    };
    /**
     * @private
     */
    RemoteParticipant.prototype._getTrackPublicationEvents = function () {
        return __spreadArray(__spreadArray([], __read(_super.prototype._getTrackPublicationEvents.call(this))), [
            ['subscriptionFailed', 'trackSubscriptionFailed'],
            ['trackDisabled', 'trackDisabled'],
            ['trackEnabled', 'trackEnabled'],
            ['publishPriorityChanged', 'trackPublishPriorityChanged'],
            ['trackSwitchedOff', 'trackSwitchedOff'],
            ['trackSwitchedOn', 'trackSwitchedOn']
        ]);
    };
    /**
     * @private
     */
    RemoteParticipant.prototype._unsubscribeTracks = function () {
        var _this = this;
        this.tracks.forEach(function (publication) {
            if (publication.isSubscribed) {
                var track = publication.track;
                publication._unsubscribe();
                _this.emit('trackUnsubscribed', track, publication);
            }
        });
    };
    /**
     * @private
     * @param {RemoteTrack} remoteTrack
     * @param {RemoteTrackPublication} publication
     * @param {Track.ID} id
     * @returns {?RemoteTrack}
     */
    RemoteParticipant.prototype._removeTrack = function (remoteTrack, publication, id) {
        var unsubscribedTrack = this._tracks.get(id);
        if (!unsubscribedTrack) {
            return null;
        }
        _super.prototype._removeTrack.call(this, unsubscribedTrack, id);
        publication._unsubscribe();
        this.emit('trackUnsubscribed', unsubscribedTrack, publication);
        return unsubscribedTrack;
    };
    /**
     * @private
     * @param {RemoteTrackPublication} publication
     * @returns {?RemoteTrackPublication}
     */
    RemoteParticipant.prototype._removeTrackPublication = function (publication) {
        this._signaling.clearTrackHint(publication.trackSid);
        var removedPublication = _super.prototype._removeTrackPublication.call(this, publication);
        if (!removedPublication) {
            return null;
        }
        this.emit('trackUnpublished', removedPublication);
        return removedPublication;
    };
    return RemoteParticipant;
}(Participant));
/**
 * The {@link RemoteParticipant} has reconnected to the {@link Room} after a signaling connection disruption.
 * @event RemoteParticipant#reconnected
 */
/**
 * The {@link RemoteParticipant} is reconnecting to the {@link Room} after a signaling connection disruption.
 * @event RemoteParticipant#reconnecting
 */
/**
 * One of the {@link RemoteParticipant}'s {@link RemoteVideoTrack}'s dimensions changed.
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} whose dimensions changed
 * @event RemoteParticipant#trackDimensionsChanged
 */
/**
 * A {@link RemoteTrack} was disabled by the {@link RemoteParticipant}.
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} associated with the disabled {@link RemoteTrack}
 * @event RemoteParticipant#trackDisabled
 */
/**
 * A {@link RemoteTrack} was enabled by the {@link RemoteParticipant}.
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} associated with the enabled {@link RemoteTrack}
 * @event RemoteParticipant#trackEnabled
 */
/**
 * A message was received over one of the {@link RemoteParticipant}'s
 * {@link RemoteDataTrack}s.
 * @event RemoteParticipant#trackMessage
 * @param {string|ArrayBuffer} data
 * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} over which the
 *   message was received
 */
/**
 * A {@link RemoteTrack} was published by the {@link RemoteParticipant} after
 * connecting to the {@link Room}. This event is not emitted for
 * {@link RemoteTrack}s that were published while the {@link RemoteParticipant}
 * was connecting to the {@link Room}.
 * @event RemoteParticipant#trackPublished
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   which represents the published {@link RemoteTrack}
 * @example
 * function trackPublished(publication) {
 *   console.log(`Track ${publication.trackSid} was published`);
 * }
 *
 * room.on('participantConnected', participant => {
 *   // Handle RemoteTracks published while connecting to the Room.
 *   participant.trackPublications.forEach(trackPublished);
 *
 *   // Handle RemoteTracks published after connecting to the Room.
 *   participant.on('trackPublished', trackPublished);
 * });
 */
/**
 * One of the {@link RemoteParticipant}'s {@link RemoteTrack}s started.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that started
 * @event RemoteParticipant#trackStarted
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was subscribed to.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was subscribed to
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was subscribed to
 * @event RemoteParticipant#trackSubscribed
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} could not be subscribed to.
 * @param {TwilioError} error - The reason the {@link RemoteTrack} could not be
 *   subscribed to
 * @param {RemoteTrackPublication} publication - The
 *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that could not
 *   be subscribed to
 * @event RemoteParticipant#trackSubscriptionFailed
 */
/**
 * The {@link RemoteTrackPublication}'s publish {@link Track.Priority} was changed by the
 * {@link RemoteParticipant}.
 * @param {Track.Priority} priority - the {@link RemoteTrack}'s new publish
 *   {@link Track.Priority};
 * @param {RemoteTrackPublication} publication - The
 *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that changed priority
 * @event RemoteParticipant#trackPublishPriorityChanged
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was subscribed to.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched off
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was switched off
 * @event RemoteParticipant#trackSwitchedOff
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched on.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched on.
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was switched on
 * @event RemoteParticipant#trackSwitchedOn
 */
/**
 * A {@link RemoteTrack} was unpublished by the {@link RemoteParticipant}.
 * @event RemoteParticipant#trackUnpublished
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   which represents the unpublished {@link RemoteTrack}
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was unsubscribed from.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was unsubscribed from
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was unsubscribed from
 * @event RemoteParticipant#trackUnsubscribed
 */
module.exports = RemoteParticipant;
//# sourceMappingURL=remoteparticipant.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/room.js":
/*!***********************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/room.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var EventEmitter = __webpack_require__(/*! ./eventemitter */ "../../work/twilio-video.js/es5/eventemitter.js");
var RemoteParticipant = __webpack_require__(/*! ./remoteparticipant */ "../../work/twilio-video.js/es5/remoteparticipant.js");
var StatsReport = __webpack_require__(/*! ./stats/statsreport */ "../../work/twilio-video.js/es5/stats/statsreport.js");
var valueToJSON = __webpack_require__(/*! ./util */ "../../work/twilio-video.js/es5/util/index.js").valueToJSON;
var nInstances = 0;
/**
 * A {@link Room} represents communication between you and one or more
 * {@link RemoteParticipant}s sharing {@link AudioTrack}s and
 * {@link VideoTrack}s.
 * <br><br>
 * You can connect to a {@link Room} by calling {@link module:twilio-video.connect}.
 * @extends EventEmitter
 * @property {?RemoteParticipant} dominantSpeaker - The Dominant Speaker in the
 *   {@link Room}, if any
 * @property {boolean} isRecording - Whether or not the {@link Room} is being
 *   recorded
 * @property {LocalParticipant} localParticipant - Your {@link LocalParticipant}
 *   in the {@link Room}
 * @property {string} mediaRegion - String indicating geographical region
 *    where  media is processed for the {@link Room}.
 * @property {string} name - The {@link Room}'s name
 * @property {Map<Participant.SID, RemoteParticipant>} participants -
 *   The {@link RemoteParticipant}s participating in this {@link Room}
 * @property {Room.SID} sid - The {@link Room}'s SID
 * @property {string} state - "connected", "reconnecting", or "disconnected"
 * @throws {SignalingConnectionDisconnectedError}
 * @emits Room#disconnected
 * @emits Room#participantConnected
 * @emits Room#participantDisconnected
 * @emits Room#participantReconnected
 * @emits Room#participantReconnecting
 * @emits Room#reconnected
 * @emits Room#reconnecting
 * @emits Room#recordingStarted
 * @emits Room#recordingStopped
 * @emits Room#trackDimensionsChanged
 * @emits Room#trackDisabled
 * @emits Room#trackEnabled
 * @emits Room#trackMessage
 * @emits Room#trackPublished
 * @emits Room#trackPublishPriorityChanged
 * @emits Room#trackStarted
 * @emits Room#trackSubscribed
 * @emits Room#trackSwitchedOff
 * @emits Room#trackSwitchedOn
 * @emits Room#trackUnpublished
 * @emits Room#trackUnsubscribed
 */
var Room = /** @class */ (function (_super) {
    __extends(Room, _super);
    /**
     * Construct a {@link Room}.
     * @param {RoomSignaling} signaling
     * @param {?object} [options={}]
     */
    function Room(localParticipant, signaling, options) {
        var _this = _super.call(this) || this;
        var log = options.log.createLog('default', _this);
        var participants = new Map();
        /* istanbul ignore next */
        Object.defineProperties(_this, {
            _log: {
                value: log
            },
            _clientTrackSwitchOffControl: {
                value: options.clientTrackSwitchOffControl || 'disabled'
            },
            _contentPreferencesMode: {
                value: options.contentPreferencesMode || 'disabled'
            },
            _instanceId: {
                value: ++nInstances
            },
            _options: {
                value: options
            },
            _participants: {
                value: participants
            },
            _signaling: {
                value: signaling
            },
            dominantSpeaker: {
                enumerable: true,
                get: function () {
                    return this.participants.get(signaling.dominantSpeakerSid) || null;
                }
            },
            isRecording: {
                enumerable: true,
                get: function () {
                    return signaling.recording.isEnabled || false;
                }
            },
            localParticipant: {
                enumerable: true,
                value: localParticipant
            },
            name: {
                enumerable: true,
                value: signaling.name
            },
            participants: {
                enumerable: true,
                value: participants
            },
            sid: {
                enumerable: true,
                value: signaling.sid
            },
            state: {
                enumerable: true,
                get: function () {
                    return signaling.state;
                }
            },
            mediaRegion: {
                enumerable: true,
                value: signaling.mediaRegion
            }
        });
        handleRecordingEvents(_this, signaling.recording);
        handleSignalingEvents(_this, signaling);
        log.info('Created a new Room:', _this.name);
        log.debug('Initial RemoteParticipants:', Array.from(_this._participants.values()));
        return _this;
    }
    Room.prototype.toString = function () {
        return "[Room #" + this._instanceId + ": " + this.sid + "]";
    };
    /**
     * Disconnect from the {@link Room}.
     * @returns {this}
     */
    Room.prototype.disconnect = function () {
        this._log.info('Disconnecting');
        this._signaling.disconnect();
        return this;
    };
    /**
     * Get the {@link Room}'s media statistics. This is not supported in Safari 12.0 or below
     * due to this bug : https://bugs.webkit.org/show_bug.cgi?id=192601
     *
     * @returns {Promise.<Array<StatsReport>>}
     */
    Room.prototype.getStats = function () {
        var _this = this;
        return this._signaling.getStats().then(function (responses) {
            return Array.from(responses).map(function (_a) {
                var _b = __read(_a, 2), id = _b[0], response = _b[1];
                return new StatsReport(id, Object.assign({}, response, {
                    localAudioTrackStats: rewriteLocalTrackIds(_this, response.localAudioTrackStats),
                    localVideoTrackStats: rewriteLocalTrackIds(_this, response.localVideoTrackStats)
                }));
            });
        });
    };
    Room.prototype.toJSON = function () {
        return valueToJSON(this);
    };
    return Room;
}(EventEmitter));
function rewriteLocalTrackIds(room, trackStats) {
    var localParticipantSignaling = room.localParticipant._signaling;
    return trackStats.reduce(function (trackStats, trackStat) {
        var publication = localParticipantSignaling.tracks.get(trackStat.trackId);
        var trackSender = localParticipantSignaling.getSender(publication);
        return trackSender
            ? [Object.assign({}, trackStat, { trackId: trackSender.id })].concat(trackStats)
            : trackStats;
    }, []);
}
/**
 * A {@link Room.SID} is a 34-character string starting with "RM"
 * that uniquely identifies a {@link Room}.
 * @type string
 * @typedef Room.SID
 */
/**
 * The Dominant Speaker in the {@link Room} changed. Either the Dominant Speaker
 * is a new {@link RemoteParticipant} or the Dominant Speaker has been reset and
 * is now null.
 * @param {?RemoteParticipant} dominantSpeaker - The Dominant Speaker in the
 *   {@link Room}, if any
 * @event Room#dominantSpeakerChanged
 */
/**
 * Your {@link LocalParticipant} was disconnected from the {@link Room} and all
 * other {@link RemoteParticipant}s.
 * @param {Room} room - The {@link Room} your
 *   {@link LocalParticipant} was disconnected from
 * @param {?TwilioError} error - Present when the {@link LocalParticipant} got
 *   disconnected from the {@link Room} unexpectedly
 * @event Room#disconnected
 * @example
 * myRoom.on('disconnected', function(room, error) {
 *   if (error) {
 *     console.log('Unexpectedly disconnected:', error);
 *   }
 *   myRoom.localParticipant.tracks.forEach(function(track) {
 *     track.stop();
 *     track.detach();
 *   });
 * });
 */
/**
 * A {@link RemoteParticipant} joined the {@link Room}. In Large Group Rooms (Maximum
 * Participants greater than 50), this event is raised only when a {@link RemoteParticipant}
 * publishes at least one {@link LocalTrack}.
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who joined
 * @event Room#participantConnected
 * @example
 * myRoom.on('participantConnected', function(participant) {
 *   console.log(participant.identity + ' joined the Room');
 * });
 */
/**
 * A {@link RemoteParticipant} left the {@link Room}. In Large Group Rooms (Maximum
 * Participants greater than 50), this event is raised only when a {@link RemoteParticipant}
 * unpublishes all its {@link LocalTrack}s.
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who left
 * @event Room#participantDisconnected
 * @example
 * myRoom.on('participantDisconnected', function(participant) {
 *   console.log(participant.identity + ' left the Room');
 *   participant.tracks.forEach(function(track) {
 *     track.detach().forEach(function(mediaElement) {
 *       mediaElement.remove();
 *     });
 *   });
 * });
 */
/**
 * A {@link RemoteParticipant} has reconnected to the {@link Room} after a signaling connection disruption.
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} that has reconnected.
 * @event Room#participantReconnected
 * @example
 * myRoom.on('participantReconnected', participant => {
 *   console.log(participant.identity + ' reconnected to the Room');
 * });
 */
/**
 * A {@link RemoteParticipant} is reconnecting to the {@link Room} after a signaling connection disruption.
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} that is reconnecting.
 * @event Room#participantReconnecting
 * @example
 * myRoom.on('participantReconnecting', participant => {
 *   console.log(participant.identity + ' is reconnecting to the Room');
 * });
 */
/**
 * Your application successfully reconnected to the {@link Room}. When this
 * event is emitted, the {@link Room} is in state "connected".
 * @event Room#reconnected
 * @example
 * myRoom.on('reconnected', () => {
 *   console.log('Reconnected!');
 * });
 */
/**
 * Your application is reconnecting to the {@link Room}. This happens when there
 * is a disruption in your signaling connection and/or your media connection. When
 * this event is emitted, the {@link Room} is in state "reconnecting". If reconnecting
 * succeeds, the {@link Room} will emit a "reconnected" event.
 * @param {MediaConnectionError|SignalingConnectionDisconnectedError} error - A
 *   {@link MediaConnectionError} if your application is reconnecting due to a
 *   disruption in your media connection, or a {@link SignalingConnectionDisconnectedError}
 *   if your application is reconnecting due to a disruption in your signaling connection
 * @event Room#reconnecting
 * @example
 * myRoom.on('reconnecting', error => {
 *   if (error.code === 53001) {
 *     console.log('Reconnecting your signaling connection!', error.message);
 *   } else if (error.code === 53405) {
 *     console.log('Reconnecting your media connection!', error.message);
 *   }
 * });
 */
/**
 * The {@link Room} is now being recorded
 * @event Room#recordingStarted
 */
/**
 * The {@link Room} is no longer being recorded
 * @event Room#recordingStopped
 */
/**
 * One of the {@link RemoteParticipant}'s {@link VideoTrack}'s dimensions changed.
 * @param {RemoteVideoTrack} track - The {@link RemoteVideoTrack} whose dimensions changed
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteVideoTrack}'s dimensions changed
 * @event Room#trackDimensionsChanged
 */
/**
 * A {@link RemoteTrack} was disabled by a {@link RemoteParticipant} in the {@link Room}.
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} that represents disabled {@link RemoteTrack}
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who
 *   disabled the {@link RemoteTrack}
 * @event Room#trackDisabled
 */
/**
 * A {@link RemoteTrack} was enabled by a {@link RemoteParticipant} in the {@link Room}.
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication} that represents enabled {@link RemoteTrack}
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who
 *   enabled the {@link RemoteTrack}
 * @event Room#trackEnabled
 */
/**
 * A message was received over one of the {@link RemoteParticipant}'s
 * {@link RemoteDataTrack}'s.
 * @param {string|ArrayBuffer} data
 * @param {RemoteDataTrack} track - The {@link RemoteDataTrack} over which the
 *   message was received
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteDataTrack} received the message
 * @event Room#trackMessage
 */
/**
 * A {@link RemoteTrack} was published by a {@link RemoteParticipant} after
 * connecting to the {@link Room}. This event is not emitted for
 * {@link RemoteTrack}s that were published while the {@link RemoteParticipant}
 * was connecting to the {@link Room}.
 * @event Room#trackPublished
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   which represents the published {@link RemoteTrack}
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who
 *   published the {@link RemoteTrack}
 * @example
 * function trackPublished(publication, participant) {
 *   console.log(`RemoteParticipant ${participant.sid} published Track ${publication.trackSid}`);
 * }
 *
 * // Handle RemoteTracks published after connecting to the Room.
 * room.on('trackPublished', trackPublished);
 *
 * room.on('participantConnected', participant => {
 *   // Handle RemoteTracks published while connecting to the Room.
 *   participant.trackPublications.forEach(publication => trackPublished(publication, participant));
 * });
 */
/**
 * One of a {@link RemoteParticipant}'s {@link RemoteTrack}s in the {@link Room} started.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that started
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} started
 * @event Room#trackStarted
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was subscribed to.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was subscribed
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was subscribed to
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} was subscribed
 * @event Room#trackSubscribed
 * @example
 * room.on('trackSubscribed', function(track, publication, participant) {
 *   var participantView = document.getElementById('participant-view-' + participant.identity);
 *   participantView.appendChild(track.attach());
 * });
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched off.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched off
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was subscribed to
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} was switched off
 * @event Room#trackSwitchedOff
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was switched on.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was switched on
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was subscribed to
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} was switched on
 * @event Room#trackSwitchedOn
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} could not be subscribed to.
 * @param {TwilioError} error - The reason the {@link RemoteTrack} could not be
 *   subscribed to
 * @param {RemoteTrackPublication} publication - The
 *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that could not
 *   be subscribed to
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} could not be subscribed to
 * @event Room#trackSubscriptionFailed
 */
/**
 * The {@link RemoteTrack}'s publish {@link Track.Priority} was changed by the
 * {@link RemoteParticipant}.
 * @param {Track.Priority} priority - the {@link RemoteTrack}'s new publish
 *   {@link Track.Priority};
 * @param {RemoteTrackPublication} publication - The
 *   {@link RemoteTrackPublication} for the {@link RemoteTrack} that changed priority
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} changed priority
 * @event Room#trackPublishPriorityChanged
 */
/**
 * A {@link RemoteTrack} was unpublished by a {@link RemoteParticipant} to the {@link Room}.
 * @event Room#trackUnpublished
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   which represents the unpublished {@link RemoteTrack}
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} who
 *   unpublished the {@link RemoteTrack}
 */
/**
 * A {@link RemoteParticipant}'s {@link RemoteTrack} was unsubscribed from.
 * @param {RemoteTrack} track - The {@link RemoteTrack} that was unsubscribed
 * @param {RemoteTrackPublication} publication - The {@link RemoteTrackPublication}
 *   for the {@link RemoteTrack} that was unsubscribed from
 * @param {RemoteParticipant} participant - The {@link RemoteParticipant} whose
 *   {@link RemoteTrack} was unsubscribed
 * @event Room#trackUnsubscribed
 * @example
 * room.on('trackUnsubscribed', function(track, publication, participant) {
 *   track.detach().forEach(function(mediaElement) {
 *     mediaElement.remove();
 *   });
 * });
 */
function connectParticipant(room, participantSignaling) {
    var log = room._log, clientTrackSwitchOffControl = room._clientTrackSwitchOffControl, contentPreferencesMode = room._contentPreferencesMode;
    var participant = new RemoteParticipant(participantSignaling, { log: log, clientTrackSwitchOffControl: clientTrackSwitchOffControl, contentPreferencesMode: contentPreferencesMode });
    log.info('A new RemoteParticipant connected:', participant);
    room._participants.set(participant.sid, participant);
    room.emit('participantConnected', participant);
    // Reemit Track and RemoteParticipant events.
    var eventListeners = [
        ['reconnected', 'participantReconnected'],
        ['reconnecting', 'participantReconnecting'],
        'trackDimensionsChanged',
        'trackDisabled',
        'trackEnabled',
        'trackMessage',
        'trackPublished',
        'trackPublishPriorityChanged',
        'trackStarted',
        'trackSubscribed',
        'trackSubscriptionFailed',
        'trackSwitchedOff',
        'trackSwitchedOn',
        'trackUnpublished',
        'trackUnsubscribed'
    ].map(function (eventOrPair) {
        var _a = __read(Array.isArray(eventOrPair)
            ? eventOrPair
            : [eventOrPair, eventOrPair], 2), event = _a[0], participantEvent = _a[1];
        function reemit() {
            var args = [].slice.call(arguments);
            args.unshift(participantEvent);
            args.push(participant);
            room.emit.apply(room, __spreadArray([], __read(args)));
        }
        participant.on(event, reemit);
        return [event, reemit];
    });
    participant.once('disconnected', function participantDisconnected() {
        var dominantSpeaker = room.dominantSpeaker;
        log.info('RemoteParticipant disconnected:', participant);
        room._participants.delete(participant.sid);
        eventListeners.forEach(function (args) {
            participant.removeListener(args[0], args[1]);
        });
        room.emit('participantDisconnected', participant);
        if (participant === dominantSpeaker) {
            room.emit('dominantSpeakerChanged', room.dominantSpeaker);
        }
    });
}
function handleRecordingEvents(room, recording) {
    recording.on('updated', function updated() {
        var started = recording.isEnabled;
        room._log.info("Recording " + (started ? 'started' : 'stopped'));
        room.emit("recording" + (started ? 'Started' : 'Stopped'));
    });
}
function handleSignalingEvents(room, signaling) {
    var log = room._log;
    // Reemit RemoteParticipant events from the RoomSignaling.
    log.debug('Creating a new RemoteParticipant for each ParticipantSignaling '
        + 'in the RoomSignaling');
    signaling.participants.forEach(connectParticipant.bind(null, room));
    log.debug('Setting up RemoteParticipant creation for all subsequent '
        + 'ParticipantSignalings that connect to the RoomSignaling');
    signaling.on('participantConnected', connectParticipant.bind(null, room));
    signaling.on('dominantSpeakerChanged', function () { return room.emit('dominantSpeakerChanged', room.dominantSpeaker); });
    // Reemit state transition events from the RoomSignaling.
    signaling.on('stateChanged', function stateChanged(state, error) {
        log.info('Transitioned to state:', state);
        switch (state) {
            case 'disconnected':
                room.participants.forEach(function (participant) {
                    participant._unsubscribeTracks();
                });
                room.emit(state, room, error);
                room.localParticipant.tracks.forEach(function (publication) {
                    publication.unpublish();
                });
                signaling.removeListener('stateChanged', stateChanged);
                break;
            case 'reconnecting':
                // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.
                // Do not signal  public events synchronously with lock held.
                setTimeout(function () { return room.emit('reconnecting', error); }, 0);
                break;
            default:
                // NOTE(mpatwardhan): `stateChanged` can get emitted with StateMachine locked.
                // Do not signal  public events synchronously with lock held.
                setTimeout(function () { return room.emit('reconnected'); }, 0);
        }
    });
}
module.exports = Room;
//# sourceMappingURL=room.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/index.js":
/*!**********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint consistent-return:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ParticipantSignaling = __webpack_require__(/*! ./participant */ "../../work/twilio-video.js/es5/signaling/participant.js");
var RoomSignaling = __webpack_require__(/*! ./room */ "../../work/twilio-video.js/es5/signaling/room.js");
var StateMachine = __webpack_require__(/*! ../statemachine */ "../../work/twilio-video.js/es5/statemachine.js");
/*
Signaling States
----------------

              +---------+
              |         |
              | opening |
         +--->|         |
         |    +---------+
    +--------+   |   |   +------+
    |        |<--+   +-->|      |
    | closed |<----------| open |
    |        |<--+   +-->|      |
    +--------+   |   |   +------+
              +---------+   |
              |         |<--+
              | closing |
              |         |
              +---------+

*/
var states = {
    closed: [
        'opening'
    ],
    opening: [
        'closed',
        'open'
    ],
    open: [
        'closed',
        'closing'
    ],
    closing: [
        'closed',
        'open'
    ]
};
/**
 * @extends StateMachine
 * @property {string} state - one of "closed", "opening", "open", or "closing"
 */
var Signaling = /** @class */ (function (_super) {
    __extends(Signaling, _super);
    /**
     * Construct {@link Signaling}.
     */
    function Signaling() {
        return _super.call(this, 'closed', states) || this;
    }
    /**
     * @private
     */
    // NOTE(mroberts): This is a dummy implementation suitable for testing.
    Signaling.prototype._close = function (key) {
        this.transition('closing', key);
        this.transition('closed', key);
        return Promise.resolve(this);
    };
    /**
     * @private
     */
    // NOTE(mroberts): This is a dummy implementation suitable for testing.
    Signaling.prototype._connect = function (localParticipant, token, encodingParameters, preferredCodecs, options) {
        localParticipant.connect('PA00000000000000000000000000000000', 'test');
        var sid = 'RM00000000000000000000000000000000';
        var promise = Promise.resolve(new RoomSignaling(localParticipant, sid, options));
        promise.cancel = function cancel() { };
        return promise;
    };
    /**
     * @private
     */
    // NOTE(mroberts): This is a dummy implementation suitable for testing.
    Signaling.prototype._open = function (key) {
        this.transition('opening', key);
        this.transition('open', key);
        return Promise.resolve(this);
    };
    /**
     * Close the {@link Signaling}.
     * @returns {Promise<this>}
     */
    Signaling.prototype.close = function () {
        var _this = this;
        return this.bracket('close', function (key) {
            switch (_this.state) {
                case 'closed':
                    return _this;
                case 'open':
                    return _this._close(key);
                default:
                    throw new Error("Unexpected Signaling state \"" + _this.state + "\"");
            }
        });
    };
    /**
     * Connect to a {@link RoomSignaling}.
     * @param {ParticipantSignaling} localParticipant
     * @param {string} token
     * @param {EncodingParametersImpl} encodingParameters
     * @param {PreferredCodecs} preferredCodecs
     * @param {object} options
     * @returns {Promise<function(): CancelablePromise<RoomSignaling>>}
     */
    Signaling.prototype.connect = function (localParticipant, token, encodingParameters, preferredCodecs, options) {
        var self = this;
        return this.bracket('connect', function transition(key) {
            switch (self.state) {
                case 'closed':
                    return self._open(key).then(transition.bind(null, key));
                case 'open':
                    // NOTE(mroberts): We don't need to hold the lock in _connect. Instead,
                    // we just need to ensure the Signaling remains open.
                    self.releaseLockCompletely(key);
                    return self._connect(localParticipant, token, encodingParameters, preferredCodecs, options);
                default:
                    throw new Error("Unexpected Signaling state \"" + self.state + "\"");
            }
        });
    };
    /**
     * Create a local {@link ParticipantSignaling}.
     * @returns {ParticipantSignaling}
     */
    Signaling.prototype.createLocalParticipantSignaling = function () {
        return new ParticipantSignaling();
    };
    /**
     * Open the {@link Signaling}.
     * @returns {Promise<this>}
     */
    Signaling.prototype.open = function () {
        var _this = this;
        return this.bracket('open', function (key) {
            switch (_this.state) {
                case 'closed':
                    return _this._open(key);
                case 'open':
                    return _this;
                default:
                    throw new Error("Unexpected Signaling state \"" + _this.state + "\"");
            }
        });
    };
    return Signaling;
}(StateMachine));
module.exports = Signaling;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/localparticipant.js":
/*!*********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/localparticipant.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ParticipantSignaling = __webpack_require__(/*! ./participant */ "../../work/twilio-video.js/es5/signaling/participant.js");
var LocalParticipantSignaling = /** @class */ (function (_super) {
    __extends(LocalParticipantSignaling, _super);
    function LocalParticipantSignaling() {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _publicationsToTrackSenders: {
                value: new Map()
            },
            _trackSendersToPublications: {
                value: new Map()
            }
        });
        return _this;
    }
    /**
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @param {string} name
     * @param {Track.Priority} priority
     * @returns {LocalTrackPublicationSignaling} publication
     */
    LocalParticipantSignaling.prototype.addTrack = function (trackSender, name, priority) {
        var publication = this._createLocalTrackPublicationSignaling(trackSender, name, priority);
        this._trackSendersToPublications.set(trackSender, publication);
        this._publicationsToTrackSenders.set(publication, trackSender);
        _super.prototype.addTrack.call(this, publication);
        return this;
    };
    /**
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @returns {?LocalTrackPublicationSignaling}
     */
    LocalParticipantSignaling.prototype.getPublication = function (trackSender) {
        return this._trackSendersToPublications.get(trackSender) || null;
    };
    /**
     * @param {LocalTrackPublicationSignaling} trackPublication
     * @returns {?DataTrackSender|MediaTrackSender}
     */
    LocalParticipantSignaling.prototype.getSender = function (trackPublication) {
        return this._publicationsToTrackSenders.get(trackPublication) || null;
    };
    /**
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @returns {?LocalTrackPublicationSignaling}
     */
    LocalParticipantSignaling.prototype.removeTrack = function (trackSender) {
        var publication = this._trackSendersToPublications.get(trackSender);
        if (!publication) {
            return null;
        }
        this._trackSendersToPublications.delete(trackSender);
        this._publicationsToTrackSenders.delete(publication);
        var didDelete = _super.prototype.removeTrack.call(this, publication);
        if (didDelete) {
            publication.stop();
        }
        return publication;
    };
    return LocalParticipantSignaling;
}(ParticipantSignaling));
module.exports = LocalParticipantSignaling;
//# sourceMappingURL=localparticipant.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/localtrackpublication.js":
/*!**************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/localtrackpublication.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackSignaling = __webpack_require__(/*! ./track */ "../../work/twilio-video.js/es5/signaling/track.js");
/**
 * A {@link LocalTrackPublication} implementation
 * @extends TrackSignaling
 * @property {Track.ID} id
 */
var LocalTrackPublicationSignaling = /** @class */ (function (_super) {
    __extends(LocalTrackPublicationSignaling, _super);
    /**
     * Construct a {@link LocalTrackPublicationSignaling}. {@link TrackSenders}
     * are always cloned.
     * @param {DataTrackSender|MediaTrackSender} trackSender - the {@link TrackSender}
     *   of the {@link LocalTrack} to be published
     * @param {string} name - the name of the {@link LocalTrack} to be published
     * @param {Track.Priority} priority - initial {@link Track.Priority}
     */
    function LocalTrackPublicationSignaling(trackSender, name, priority) {
        var _this = this;
        trackSender = trackSender.clone();
        var enabled = trackSender.kind === 'data' ? true : trackSender.track.enabled;
        _this = _super.call(this, name, trackSender.kind, enabled, priority) || this;
        _this.setTrackTransceiver(trackSender);
        Object.defineProperties(_this, {
            _updatedPriority: {
                value: priority,
                writable: true
            },
            id: {
                enumerable: true,
                value: trackSender.id
            }
        });
        return _this;
    }
    Object.defineProperty(LocalTrackPublicationSignaling.prototype, "updatedPriority", {
        /**
         * The updated {@link Track.Priority} of the {@link LocalTrack}.
         * @property {Track.priority}
         */
        get: function () {
            return this._updatedPriority;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Enable (or disable) the {@link LocalTrackPublicationSignaling} if it is not
     * already enabled (or disabled). This also updates the cloned
     * {@link MediaTrackSender}'s MediaStreamTracks `enabled` state.
     * @param {boolean} [enabled=true]
     * @return {this}
     */
    LocalTrackPublicationSignaling.prototype.enable = function (enabled) {
        enabled = typeof enabled === 'boolean' ? enabled : true;
        this.trackTransceiver.track.enabled = enabled;
        return _super.prototype.enable.call(this, enabled);
    };
    /**
     * Rejects the SID's deferred promise with the given Error.
     * @param {Error} error
     * @returns {this}
     */
    LocalTrackPublicationSignaling.prototype.publishFailed = function (error) {
        if (setError(this, error)) {
            this.emit('updated');
        }
        return this;
    };
    /**
     * Update the {@link Track.Priority} of the published {@link LocalTrack}.
     * @param {Track.priority} priority
     * @returns {this}
     */
    LocalTrackPublicationSignaling.prototype.setPriority = function (priority) {
        if (this._updatedPriority !== priority) {
            this._updatedPriority = priority;
            this.emit('updated');
        }
        return this;
    };
    /**
     * Set the published {@link LocalTrack}'s {@link Track.SID}.
     * @param {Track.SID} sid
     * @returns {this}
     */
    LocalTrackPublicationSignaling.prototype.setSid = function (sid) {
        if (this._error) {
            return this;
        }
        return _super.prototype.setSid.call(this, sid);
    };
    /**
     * Stop the cloned {@link TrackSender}.
     * @returns {void}
     */
    LocalTrackPublicationSignaling.prototype.stop = function () {
        this.trackTransceiver.stop();
    };
    return LocalTrackPublicationSignaling;
}(TrackSignaling));
/**
 * @param {LocalTrackPublication} publication
 * @param {Error} error
 * @returns {boolean} updated
 */
function setError(publication, error) {
    if (publication._sid !== null || publication._error) {
        return false;
    }
    publication._error = error;
    return true;
}
module.exports = LocalTrackPublicationSignaling;
//# sourceMappingURL=localtrackpublication.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/participant.js":
/*!****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/participant.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var StateMachine = __webpack_require__(/*! ../statemachine */ "../../work/twilio-video.js/es5/statemachine.js");
var NetworkQualityStats = __webpack_require__(/*! ../stats/networkqualitystats */ "../../work/twilio-video.js/es5/stats/networkqualitystats.js");
/*
ParticipantSignaling States
----------------------

    +------------+     +-----------+     +--------------+
    |            |     |           |     |              |
    | connecting |---->| connected |---->| disconnected |
    |            |     |           |     |              |
    +------------+     +-----------+     +--------------+
                           | ^                    ^
                           | |  +--------------+  |
                           | |--|              |  |
                           |--->| reconnecting |--|
                                |              |
                                +--------------+
*/
var states = {
    connecting: [
        'connected'
    ],
    connected: [
        'disconnected',
        'reconnecting'
    ],
    reconnecting: [
        'connected',
        'disconnected'
    ],
    disconnected: []
};
/**
 * A {@link Participant} implementation
 * @extends StateMachine
 * @property {?string} identity
 * @property {?Participant.SID} sid
 * @property {string} state - "connecting", "connected", or "disconnected"
 * @property {Map<Track.ID | Track.SID, TrackSignaling>} tracks
 * @emits ParticipantSignaling#networkQualityLevelChanged
 * @emits ParticipantSignaling#trackAdded
 * @emits ParticipantSignaling#trackRemoved
 */
var ParticipantSignaling = /** @class */ (function (_super) {
    __extends(ParticipantSignaling, _super);
    /**
     * Construct a {@link ParticipantSignaling}.
     */
    function ParticipantSignaling() {
        var _this = _super.call(this, 'connecting', states) || this;
        Object.defineProperties(_this, {
            _identity: {
                writable: true,
                value: null
            },
            _networkQualityLevel: {
                value: null,
                writable: true
            },
            _networkQualityStats: {
                value: null,
                writable: true
            },
            _sid: {
                writable: true,
                value: null
            },
            identity: {
                enumerable: true,
                get: function () {
                    return this._identity;
                }
            },
            sid: {
                enumerable: true,
                get: function () {
                    return this._sid;
                }
            },
            tracks: {
                enumerable: true,
                value: new Map()
            }
        });
        return _this;
    }
    Object.defineProperty(ParticipantSignaling.prototype, "networkQualityLevel", {
        /**
         * Get the current {@link NetworkQualityLevel}, if any.
         * @returns {?NetworkQualityLevel} networkQualityLevel - initially null
         */
        get: function () {
            return this._networkQualityLevel;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticipantSignaling.prototype, "networkQualityStats", {
        /**
         * Get the current {@link NetworkQualityStats}
         * @returns {?NetworkQualityStats} networkQualityStats - initially null
         */
        get: function () {
            return this._networkQualityStats;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Add the {@link TrackSignaling}, MediaStreamTrack, or
     * {@link DataTrackSender} to the {@link ParticipantSignaling}.
     * @param {TrackSignaling|DataTrackSender|MediaTrackSender} track
     * @returns {this}
     * @fires ParticipantSignaling#trackAdded
     */
    ParticipantSignaling.prototype.addTrack = function (track) {
        this.tracks.set(track.id || track.sid, track);
        this.emit('trackAdded', track);
        return this;
    };
    /**
     * Disconnect the {@link ParticipantSignaling}.
     * @returns {boolean}
     */
    ParticipantSignaling.prototype.disconnect = function () {
        if (this.state !== 'disconnected') {
            this.preempt('disconnected');
            return true;
        }
        return false;
    };
    /**
     * Remove the {@link TrackSignaling}, MediaStreamTrack, or
     * {@link DataTrackSender} from the {@link ParticipantSignaling}.
     * @param {TrackSignaling|DataTrackSender|MediaTrackSender} track
     * @returns {?TrackSignaling}
     * @fires ParticipantSignaling#trackRemoved
     */
    ParticipantSignaling.prototype.removeTrack = function (track) {
        var signaling = this.tracks.get(track.id || track.sid);
        this.tracks.delete(track.id || track.sid);
        if (signaling) {
            this.emit('trackRemoved', track);
        }
        return signaling || null;
    };
    /**
     * @param {NetworkQualityLevel} networkQualityLevel
     * @param {?NetworkQualityLevels} [networkQualityLevels=null]
     * @returns {void}
     */
    ParticipantSignaling.prototype.setNetworkQualityLevel = function (networkQualityLevel, networkQualityLevels) {
        if (this._networkQualityLevel !== networkQualityLevel) {
            this._networkQualityLevel = networkQualityLevel;
            this._networkQualityStats = networkQualityLevels
                && (networkQualityLevels.audio || networkQualityLevels.video)
                ? new NetworkQualityStats(networkQualityLevels)
                : null;
            this.emit('networkQualityLevelChanged');
        }
    };
    /**
     * Connect the {@link ParticipantSignaling}.
     * @param {Participant.SID} sid
     * @param {string} identity
     * @returns {boolean}
     */
    ParticipantSignaling.prototype.connect = function (sid, identity) {
        if (this.state === 'connecting' || this.state === 'reconnecting') {
            if (!this._sid) {
                this._sid = sid;
            }
            if (!this._identity) {
                this._identity = identity;
            }
            this.preempt('connected');
            return true;
        }
        return false;
    };
    /**
     * Transition to "reconnecting" state.
     * @returns {boolean}
     */
    ParticipantSignaling.prototype.reconnecting = function () {
        if (this.state === 'connecting' || this.state === 'connected') {
            this.preempt('reconnecting');
            return true;
        }
        return false;
    };
    return ParticipantSignaling;
}(StateMachine));
/**
 * @event ParticipantSignaling#event:networkQualityLevelChanged
 */
/**
 * {@link TrackSignaling} was added to the {@link ParticipantSignaling}.
 * @event ParticipantSignaling#trackAdded
 * @param {TrackSignaling} track
 */
/**
 * {@link TrackSignaling} was removed from the {@link ParticipantSignaling}.
 * @event ParticipantSignaling#trackRemoved
 * @param {TrackSignaling} track
 */
module.exports = ParticipantSignaling;
//# sourceMappingURL=participant.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/recording.js":
/*!**************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/recording.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
/**
 * Represents recording state
 * @extends EventEmitter
 * @property {?boolean} isEnabled
 */
var RecordingSignaling = /** @class */ (function (_super) {
    __extends(RecordingSignaling, _super);
    /**
     * Construct a {@link RecordingSignaling}.
     */
    function RecordingSignaling() {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _isEnabled: {
                value: null,
                writable: true
            },
            isEnabled: {
                enumerable: true,
                get: function () {
                    return this._isEnabled;
                }
            }
        });
        return _this;
    }
    /**
     * Disable the {@link RecordingSignaling} if it is not already disabled.
     * @return {this}
     */
    RecordingSignaling.prototype.disable = function () {
        return this.enable(false);
    };
    /**
     * Enable (or disable) the {@link RecordingSignaling} if it is not already enabled
     * (or disabled).
     * @param {boolean} [enabled=true]
     * @return {this}
     */
    RecordingSignaling.prototype.enable = function (enabled) {
        enabled = typeof enabled === 'boolean' ? enabled : true;
        if (this.isEnabled !== enabled) {
            this._isEnabled = enabled;
            this.emit('updated');
        }
        return this;
    };
    return RecordingSignaling;
}(EventEmitter));
/**
 * Emitted whenever the {@link RecordingSignaling} is updated
 * @event RecordingSignaling#updated
 */
module.exports = RecordingSignaling;
//# sourceMappingURL=recording.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/remoteparticipant.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/remoteparticipant.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ParticipantSignaling = __webpack_require__(/*! ./participant */ "../../work/twilio-video.js/es5/signaling/participant.js");
/**
 * A {@link Participant} implementation
 * @extends ParticipantSignaling
 * @property {string} identity
 * @property {Participant.SID} sid
 */
var RemoteParticipantSignaling = /** @class */ (function (_super) {
    __extends(RemoteParticipantSignaling, _super);
    /**
     * Construct a {@link RemoteParticipantSignaling}.
     * @param {Participant.SID} sid
     * @param {string} identity
     */
    function RemoteParticipantSignaling(sid, identity) {
        var _this = _super.call(this) || this;
        _this.connect(sid, identity);
        return _this;
    }
    return RemoteParticipantSignaling;
}(ParticipantSignaling));
module.exports = RemoteParticipantSignaling;
//# sourceMappingURL=remoteparticipant.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/remotetrackpublication.js":
/*!***************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/remotetrackpublication.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackSignaling = __webpack_require__(/*! ./track */ "../../work/twilio-video.js/es5/signaling/track.js");
/**
 * A {@link RemoteTrackPublication} implementation
 * @extends TrackSignaling
 */
var RemoteTrackPublicationSignaling = /** @class */ (function (_super) {
    __extends(RemoteTrackPublicationSignaling, _super);
    /**
     * Construct a {@link RemoteTrackPublicationSignaling}.
     * @param {Track.SID} sid
     * @param {string} name
     * @param {Track.Kind} kind
     * @param {boolean} isEnabled
     * @param {Track.Priority} priority
     * @param {boolean} isSwitchedOff
     */
    function RemoteTrackPublicationSignaling(sid, name, kind, isEnabled, priority, isSwitchedOff) {
        var _this = _super.call(this, name, kind, isEnabled, priority) || this;
        Object.defineProperties(_this, {
            _isSwitchedOff: {
                value: isSwitchedOff,
                writable: true
            },
        });
        _this.setSid(sid);
        return _this;
    }
    Object.defineProperty(RemoteTrackPublicationSignaling.prototype, "isSubscribed", {
        /**
         * Whether the {@link RemoteTrackPublicationSignaling} is subscribed to.
         * @property {boolean}
         */
        get: function () {
            return !!this.trackTransceiver;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RemoteTrackPublicationSignaling.prototype, "isSwitchedOff", {
        /**
         * Whether the {@link RemoteTrackPublicationSignaling} is switched off.
         * @property {boolean}
         */
        get: function () {
            return this._isSwitchedOff;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @param {Error} error
     * @returns {this}
     */
    RemoteTrackPublicationSignaling.prototype.subscribeFailed = function (error) {
        if (!this.error) {
            this._error = error;
            this.emit('updated');
        }
        return this;
    };
    /**
     * Update the publish {@link Track.Priority}.
     * @param {Track.Priority} priority
     * @returns {this}
     */
    RemoteTrackPublicationSignaling.prototype.setPriority = function (priority) {
        if (this._priority !== priority) {
            this._priority = priority;
            this.emit('updated');
        }
        return this;
    };
    /**
     * Updates track switch on/off state.
     * @param {boolean} isSwitchedOff
     * @returns {this}
     */
    RemoteTrackPublicationSignaling.prototype.setSwitchedOff = function (isSwitchedOff) {
        if (this._isSwitchedOff !== isSwitchedOff) {
            this._isSwitchedOff = isSwitchedOff;
            this.emit('updated');
        }
        return this;
    };
    return RemoteTrackPublicationSignaling;
}(TrackSignaling));
module.exports = RemoteTrackPublicationSignaling;
//# sourceMappingURL=remotetrackpublication.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/room.js":
/*!*********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/room.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DefaultRecordingSignaling = __webpack_require__(/*! ./recording */ "../../work/twilio-video.js/es5/signaling/recording.js");
var StateMachine = __webpack_require__(/*! ../statemachine */ "../../work/twilio-video.js/es5/statemachine.js");
var DefaultTimeout = __webpack_require__(/*! ../util/timeout */ "../../work/twilio-video.js/es5/util/timeout.js");
var buildLogLevels = __webpack_require__(/*! ../util */ "../../work/twilio-video.js/es5/util/index.js").buildLogLevels;
var DEFAULT_LOG_LEVEL = __webpack_require__(/*! ../util/constants */ "../../work/twilio-video.js/es5/util/constants.js").DEFAULT_LOG_LEVEL;
var Log = __webpack_require__(/*! ../util/log */ "../../work/twilio-video.js/es5/util/log.js");
var _a = __webpack_require__(/*! ../util/twilio-video-errors */ "../../work/twilio-video.js/es5/util/twilio-video-errors.js"), MediaConnectionError = _a.MediaConnectionError, MediaDTLSTransportFailedError = _a.MediaDTLSTransportFailedError, SignalingConnectionDisconnectedError = _a.SignalingConnectionDisconnectedError;
var nInstances = 0;
/*
RoomSignaling States
-----------------------

    +-----------+     +--------------+
    |           |     |              |
    | connected |---->| disconnected |
    |           |     |              |
    +-----------+     +--------------+
          |  ^               ^
          |  |               |
          |  |   +--------------+
          |  +---|              |
          |      | reconnecting |
          +----->|              |
                 +--------------+

*/
var states = {
    connected: [
        'reconnecting',
        'disconnected'
    ],
    reconnecting: [
        'connected',
        'disconnected'
    ],
    disconnected: []
};
/**
 * A {@link Room} implementation
 * @extends StateMachine
 * @property {RTCPeerConnectionState} connectionState
 * @property {?Participant.SID} dominantSpeakerSid
 * @property {ParticipantSignaling} localParticipant
 * @property {RTCIceConnectionState} iceConnectionState
 * @property {string} name
 * @property {Map<string, RemoteParticipantSignaling>} participants
 * @property {RecordingSignaling} recording
 * @property {Room.SID} sid
 * @property {string} state - "connected", "reconnecting", or "disconnected"
 * @property {string} signalingConnectionState - "connected",
 *   "reconnecting", or "disconnected"
 * @emits RoomSignaling#connectionStateChanged
 * @emits RoomSignaling#dominantSpeakerChanged
 * @emits RoomSignaling#iceConnectionStateChanged
 * @emits RoomSignaling#signalingConnectionStateChanged
 */
var RoomSignaling = /** @class */ (function (_super) {
    __extends(RoomSignaling, _super);
    /**
     * Construct a {@link RoomSignaling}.
     * @param {ParticipantSignaling} localParticipant
     * @param {Room.SID} sid
     * @param {string} name
     * @param {object} options
     */
    function RoomSignaling(localParticipant, sid, name, options) {
        var _this = this;
        options = Object.assign({
            logLevel: DEFAULT_LOG_LEVEL,
            RecordingSignaling: DefaultRecordingSignaling,
            Timeout: DefaultTimeout
        }, options);
        var logLevels = buildLogLevels(options.logLevel);
        _this = _super.call(this, 'connected', states) || this;
        var RecordingSignaling = options.RecordingSignaling;
        var sessionTimeout = new options.Timeout(function () {
            _this._disconnect(_this._reconnectingError);
        }, options.sessionTimeout, false);
        Object.defineProperties(_this, {
            _instanceId: {
                value: nInstances++
            },
            _log: {
                value: options.log
                    ? options.log.createLog('default', _this)
                    : new Log('default', _this, logLevels, options.loggerName)
            },
            _mediaConnectionIsReconnecting: {
                writable: true,
                value: false
            },
            _options: {
                value: options
            },
            _reconnectingError: {
                value: null,
                writable: true
            },
            _sessionTimeout: {
                value: sessionTimeout
            },
            dominantSpeakerSid: {
                enumerable: true,
                value: null,
                writable: true
            },
            localParticipant: {
                enumerable: true,
                value: localParticipant
            },
            name: {
                enumerable: true,
                value: name
            },
            participants: {
                enumerable: true,
                value: new Map()
            },
            recording: {
                enumerable: true,
                value: new RecordingSignaling()
            },
            sid: {
                enumerable: true,
                value: sid
            }
        });
        _this.on('connectionStateChanged', function () {
            if (_this.connectionState === 'failed'
                && !['disconnected', 'failed'].includes(_this.iceConnectionState)) {
                _this._disconnect(new MediaDTLSTransportFailedError());
            }
        });
        _this.on('iceConnectionStateChanged', function () { return maybeUpdateState(_this); });
        _this.on('signalingConnectionStateChanged', function () { return maybeUpdateState(_this); });
        // NOTE(mmalavalli): In case "iceConnectionState" is already failed, update
        // the RoomSignaling state. setTimeout() ensures that the state is updated
        // after RoomV2's constructor is fully executed, thereby making "signalingConnectionState"
        // available here.
        setTimeout(function () { return maybeUpdateState(_this); });
        return _this;
    }
    /**
     * Disconnect, possibly with an Error.
     * @private
     * @param {Error} [error]
     * @returns {boolean}
     */
    RoomSignaling.prototype._disconnect = function (error) {
        if (this.state !== 'disconnected') {
            this.preempt('disconnected', null, [error]);
            return true;
        }
        return false;
    };
    RoomSignaling.prototype.toString = function () {
        return "[RoomSignaling #" + this._instanceId + ": " + (this.localParticipant ? this.localParticipant.sid : 'null') + "]";
    };
    /**
     * Connect {@link RemoteParticipantSignaling} to the {@link RoomSignaling}.
     * @param {RemoteParticipantSignaling} participant
     * @returns {boolean}
     */
    RoomSignaling.prototype.connectParticipant = function (participant) {
        var self = this;
        if (participant.state === 'disconnected') {
            return false;
        }
        if (this.participants.has(participant.sid)) {
            return false;
        }
        this.participants.set(participant.sid, participant);
        participant.on('stateChanged', function stateChanged(state) {
            if (state === 'disconnected') {
                participant.removeListener('stateChanged', stateChanged);
                self.participants.delete(participant.sid);
                self.emit('participantDisconnected', participant);
            }
        });
        this.emit('participantConnected', participant);
        return true;
    };
    /**
     * Disconnect.
     * @returns {boolean}
     */
    RoomSignaling.prototype.disconnect = function () {
        return this._disconnect();
    };
    /**
     * Set (or unset) the Dominant Speaker.
     * @param {?Participant.SID} dominantSpeakerSid
     * @returns {void}
     */
    RoomSignaling.prototype.setDominantSpeaker = function (dominantSpeakerSid) {
        this.dominantSpeakerSid = dominantSpeakerSid;
        this.emit('dominantSpeakerChanged');
    };
    return RoomSignaling;
}(StateMachine));
/**
 * @event RoomSignaling#event:connectionStateChanged
 */
/**
 * @event RoomSignaling#event:dominantSpeakerChanged
 */
/**
 * {@link RemoteParticipantSignaling} connected to the {@link RoomSignaling}.
 * @event RoomSignaling#event:participantConnected
 * @param {RemoteParticipantSignaling} participantSignaling
 */
/**
 * {@link RemoteParticipantSignaling} disconnected from the {@link RoomSignaling}.
 * @event RoomSignaling#event:participantDisconnected
 * @param {RemoteParticipantSignaling} participantSignaling
 */
/**
 * @event RoomSignaling#event:iceConnectionStateChanged
 */
/**
 * @event RoomSignaling#event:signalingConnectionStateChanged
 */
/**
 * Maybe update the {@link RoomSignaling} state.
 * @param {RoomSignaling} roomSignaling
 */
function maybeUpdateState(roomSignaling) {
    if (roomSignaling.state === 'disconnected' || roomSignaling.signalingConnectionState === 'disconnected') {
        roomSignaling._sessionTimeout.clear();
        return;
    }
    var newState;
    if (roomSignaling.signalingConnectionState === 'reconnecting') {
        newState = roomSignaling.signalingConnectionState;
    }
    else if (roomSignaling.iceConnectionState === 'failed') {
        roomSignaling._mediaConnectionIsReconnecting = true;
        newState = 'reconnecting';
    }
    else if (roomSignaling.iceConnectionState === 'new' || roomSignaling.iceConnectionState === 'checking') {
        newState = roomSignaling._mediaConnectionIsReconnecting ? 'reconnecting' : 'connected';
    }
    else {
        roomSignaling._mediaConnectionIsReconnecting = false;
        roomSignaling._reconnectingError = null;
        roomSignaling._sessionTimeout.clear();
        newState = 'connected';
    }
    if (newState === roomSignaling.state) {
        return;
    }
    if (newState === 'reconnecting') {
        roomSignaling._reconnectingError = roomSignaling.signalingConnectionState === 'reconnecting'
            ? new SignalingConnectionDisconnectedError()
            : new MediaConnectionError();
        roomSignaling._sessionTimeout.start();
        roomSignaling.preempt(newState, null, [roomSignaling._reconnectingError]);
    }
    else {
        roomSignaling.preempt(newState);
    }
}
module.exports = RoomSignaling;
//# sourceMappingURL=room.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/track.js":
/*!**********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/track.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
/**
 * A {@link Track} implementation
 * @extends EventEmitter
 * @property {Track.Kind} kind
 * @property {string} name
 */
var TrackSignaling = /** @class */ (function (_super) {
    __extends(TrackSignaling, _super);
    /**
     * Construct a {@link TrackSignaling}.
     * @param {string} name
     * @param {Track.Kind} kind
     * @param {boolean} isEnabled
     * @param {Track.Priority} priority
     */
    function TrackSignaling(name, kind, isEnabled, priority) {
        var _this = _super.call(this) || this;
        var sid = null;
        Object.defineProperties(_this, {
            _error: {
                value: null,
                writable: true
            },
            _isEnabled: {
                value: isEnabled,
                writable: true
            },
            _priority: {
                value: priority,
                writable: true
            },
            _trackTransceiver: {
                value: null,
                writable: true
            },
            _sid: {
                get: function () {
                    return sid;
                },
                set: function (_sid) {
                    if (sid === null) {
                        sid = _sid;
                    }
                }
            },
            kind: {
                enumerable: true,
                value: kind
            },
            name: {
                enumerable: true,
                value: name
            }
        });
        return _this;
    }
    Object.defineProperty(TrackSignaling.prototype, "error", {
        /**
         * Non-null if publication or subscription failed.
         * @property {?Error} error
         */
        get: function () {
            return this._error;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TrackSignaling.prototype, "isEnabled", {
        /**
         * Whether the {@link TrackSignaling} is enabled.
         * @property {boolean}
         */
        get: function () {
            return this._isEnabled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TrackSignaling.prototype, "priority", {
        /**
         * The {@link TrackSignaling}'s priority.
         * @property {Track.Priority}
         */
        get: function () {
            return this._priority;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TrackSignaling.prototype, "sid", {
        /**
         * The {@link TrackSignaling}'s {@link Track.SID}.
         * @property {Track.SID}
         */
        get: function () {
            return this._sid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TrackSignaling.prototype, "trackTransceiver", {
        /**
         * The {@link TrackSignaling}'s {@link TrackTransceiver}.
         * @property {TrackTransceiver}
         */
        get: function () {
            return this._trackTransceiver;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Disable the {@link TrackSignaling} if it is not already disabled.
     * @return {this}
     */
    TrackSignaling.prototype.disable = function () {
        return this.enable(false);
    };
    /**
     * Enable (or disable) the {@link TrackSignaling} if it is not already enabled
     * (or disabled).
     * @param {boolean} [enabled=true]
     * @return {this}
     */
    TrackSignaling.prototype.enable = function (enabled) {
        enabled = typeof enabled === 'boolean' ? enabled : true;
        if (this.isEnabled !== enabled) {
            this._isEnabled = enabled;
            this.emit('updated');
        }
        return this;
    };
    /**
     * Set the {@link TrackTransceiver} on the {@link TrackSignaling}.
     * @param {TrackTransceiver} trackTransceiver
     * @returns {this}
     */
    TrackSignaling.prototype.setTrackTransceiver = function (trackTransceiver) {
        trackTransceiver = trackTransceiver || null;
        if (this.trackTransceiver !== trackTransceiver) {
            this._trackTransceiver = trackTransceiver;
            this.emit('updated');
        }
        return this;
    };
    /**
     * Set the SID on the {@link TrackSignaling} once.
     * @param {string} sid
     * @returns {this}
     */
    TrackSignaling.prototype.setSid = function (sid) {
        if (this.sid === null) {
            this._sid = sid;
            this.emit('updated');
        }
        return this;
    };
    return TrackSignaling;
}(EventEmitter));
/**
 * Emitted whenever the {@link TrackSignaling} is updated
 * @event TrackSignaling#updated
 */
module.exports = TrackSignaling;
//# sourceMappingURL=track.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/cancelableroomsignalingpromise.js":
/*!**************************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/cancelableroomsignalingpromise.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var CancelablePromise = __webpack_require__(/*! ../../util/cancelablepromise */ "../../work/twilio-video.js/es5/util/cancelablepromise.js");
var DefaultPeerConnectionManager = __webpack_require__(/*! ./peerconnectionmanager */ "../../work/twilio-video.js/es5/signaling/v2/peerconnectionmanager.js");
var DefaultRoomV2 = __webpack_require__(/*! ./room */ "../../work/twilio-video.js/es5/signaling/v2/room.js");
var DefaultTransport = __webpack_require__(/*! ./twilioconnectiontransport */ "../../work/twilio-video.js/es5/signaling/v2/twilioconnectiontransport.js");
var _a = __webpack_require__(/*! ../../util/twilio-video-errors */ "../../work/twilio-video.js/es5/util/twilio-video-errors.js"), SignalingConnectionDisconnectedError = _a.SignalingConnectionDisconnectedError, SignalingIncomingMessageInvalidError = _a.SignalingIncomingMessageInvalidError;
var _b = __webpack_require__(/*! ../../util */ "../../work/twilio-video.js/es5/util/index.js"), flatMap = _b.flatMap, createRoomConnectEventPayload = _b.createRoomConnectEventPayload;
function createCancelableRoomSignalingPromise(token, wsServer, localParticipant, encodingParameters, preferredCodecs, options) {
    options = Object.assign({
        PeerConnectionManager: DefaultPeerConnectionManager,
        RoomV2: DefaultRoomV2,
        Transport: DefaultTransport
    }, options);
    var PeerConnectionManager = options.PeerConnectionManager, RoomV2 = options.RoomV2, Transport = options.Transport, iceServers = options.iceServers, log = options.log;
    var peerConnectionManager = new PeerConnectionManager(encodingParameters, preferredCodecs, options);
    var trackSenders = flatMap(localParticipant.tracks, function (trackV2) { return [trackV2.trackTransceiver]; });
    peerConnectionManager.setTrackSenders(trackSenders);
    var cancellationError = new Error('Canceled');
    var transport;
    var cancelablePromise = new CancelablePromise(function (resolve, reject, isCanceled) {
        var onIced = function (iceServers) {
            if (isCanceled()) {
                reject(cancellationError);
                return Promise.reject(cancellationError);
            }
            log.debug('Got ICE servers:', iceServers);
            options.iceServers = iceServers;
            peerConnectionManager.setConfiguration(options);
            return peerConnectionManager.createAndOffer().then(function () {
                if (isCanceled()) {
                    reject(cancellationError);
                    throw cancellationError;
                }
                log.debug('createAndOffer() succeeded.');
                // NOTE(mmalavalli): PeerConnectionManager#createAndOffer() queues the
                // initial offer in the event queue for the 'description' event. So,
                // we are dequeueing to prevent the spurious 'update' message sent by
                // the client after connecting to a room.
                peerConnectionManager.dequeue('description');
            }).catch(function (error) {
                log.error('createAndOffer() failed:', error);
                reject(error);
                throw error;
            });
        };
        var InsightsPublisher = options.InsightsPublisher, NullInsightsPublisher = options.NullInsightsPublisher, automaticSubscription = options.automaticSubscription, bandwidthProfile = options.bandwidthProfile, dominantSpeaker = options.dominantSpeaker, environment = options.environment, eventObserver = options.eventObserver, loggerName = options.loggerName, logLevel = options.logLevel, name = options.name, networkMonitor = options.networkMonitor, networkQuality = options.networkQuality, insights = options.insights, realm = options.realm, sdpSemantics = options.sdpSemantics, wsServerInsights = options.wsServerInsights;
        // decide which msp channels to request
        // dominantSpeaker, networkQuality
        var trackPriority = !!bandwidthProfile;
        var trackSwitchOff = !!bandwidthProfile;
        var renderHints = !!bandwidthProfile &&
            (options.clientTrackSwitchOffControl !== 'disabled' || options.contentPreferencesMode !== 'disabled');
        var transportOptions = Object.assign({
            automaticSubscription: automaticSubscription,
            dominantSpeaker: dominantSpeaker,
            environment: environment,
            eventObserver: eventObserver,
            loggerName: loggerName,
            logLevel: logLevel,
            networkMonitor: networkMonitor,
            networkQuality: networkQuality,
            iceServers: iceServers,
            insights: insights,
            onIced: onIced,
            realm: realm,
            renderHints: renderHints,
            sdpSemantics: sdpSemantics,
            trackPriority: trackPriority,
            trackSwitchOff: trackSwitchOff
        }, typeof wsServerInsights === 'string' ? {
            wsServerInsights: wsServerInsights
        } : {}, InsightsPublisher ? {
            InsightsPublisher: InsightsPublisher
        } : {}, NullInsightsPublisher ? {
            NullInsightsPublisher: NullInsightsPublisher
        } : {}, bandwidthProfile ? {
            bandwidthProfile: bandwidthProfile
        } : {});
        transport = new Transport(name, token, localParticipant, peerConnectionManager, wsServer, transportOptions);
        var connectEventPayload = createRoomConnectEventPayload(options);
        eventObserver.emit('event', connectEventPayload);
        transport.once('connected', function (initialState) {
            log.debug('Transport connected:', initialState);
            if (isCanceled()) {
                reject(cancellationError);
                return;
            }
            var localParticipantState = initialState.participant;
            if (!localParticipantState) {
                reject(new SignalingIncomingMessageInvalidError());
                return;
            }
            var signalingRegion = initialState.options.signaling_region;
            localParticipant.setSignalingRegion(signalingRegion);
            resolve(new RoomV2(localParticipant, initialState, transport, peerConnectionManager, options));
        });
        transport.once('stateChanged', function (state, error) {
            if (state === 'disconnected') {
                transport = null;
                reject(error || new SignalingConnectionDisconnectedError());
            }
            else {
                log.debug('Transport state changed:', state);
            }
        });
    }, function () {
        if (transport) {
            transport.disconnect();
            transport = null;
        }
    });
    cancelablePromise.catch(function () {
        if (transport) {
            transport.disconnect();
            transport = null;
        }
        peerConnectionManager.close();
    });
    return cancelablePromise;
}
module.exports = createCancelableRoomSignalingPromise;
//# sourceMappingURL=cancelableroomsignalingpromise.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/dominantspeakersignaling.js":
/*!********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/dominantspeakersignaling.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaSignaling = __webpack_require__(/*! ./mediasignaling */ "../../work/twilio-video.js/es5/signaling/v2/mediasignaling.js");
/**
 * @property {?Track.SID} loudestParticipantSid
 * @emits DominantSpeakerSignaling#updated
 */
var DominantSpeakerSignaling = /** @class */ (function (_super) {
    __extends(DominantSpeakerSignaling, _super);
    /**
     * Construct an {@link DominantSpeakerSignaling}.
     */
    function DominantSpeakerSignaling(getReceiver, options) {
        var _this = _super.call(this, getReceiver, 'active_speaker', options) || this;
        Object.defineProperties(_this, {
            _loudestParticipantSid: {
                value: null,
                writable: true
            },
        });
        _this.on('ready', function (transport) {
            transport.on('message', function (message) {
                switch (message.type) {
                    case 'active_speaker':
                        _this._setLoudestParticipantSid(message.participant);
                        break;
                    default:
                        break;
                }
            });
        });
        return _this;
    }
    Object.defineProperty(DominantSpeakerSignaling.prototype, "loudestParticipantSid", {
        /**
         * Get the loudest {@link Track.SID}, if known.
         * @returns {?Track.SID}
         */
        get: function () {
            return this._loudestParticipantSid;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @private
     * @param {Track.SID} loudestParticipantSid
     * @returns {void}
     */
    DominantSpeakerSignaling.prototype._setLoudestParticipantSid = function (loudestParticipantSid) {
        if (this.loudestParticipantSid === loudestParticipantSid) {
            return;
        }
        this._loudestParticipantSid = loudestParticipantSid;
        this.emit('updated');
    };
    return DominantSpeakerSignaling;
}(MediaSignaling));
/**
 * @event DominantSpeakerSignaling#updated
 */
module.exports = DominantSpeakerSignaling;
//# sourceMappingURL=dominantspeakersignaling.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/icebox.js":
/*!**************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/icebox.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Filter = __webpack_require__(/*! ../../util/filter */ "../../work/twilio-video.js/es5/util/filter.js");
/**
 * An {@link IceBox} stores trickled ICE candidates. Candidates added to the
 * {@link IceBox} via {@link IceBox#update} are compared against previously
 * trickled candidates and only new candidates will be returned (assuming they
 * match the current ICE username fragment set by {@link IceBox#setUfrag}).
 * @property {?string} ufrag
 */
var IceBox = /** @class */ (function () {
    /**
     * Construct an {@link IceBox}.
     */
    function IceBox() {
        Object.defineProperties(this, {
            _filter: {
                value: new Filter({
                    getKey: function getKey(iceState) {
                        return iceState.ufrag;
                    },
                    isLessThanOrEqualTo: function isLessThanOrEqualTo(a, b) {
                        return a.revision <= b.revision;
                    }
                })
            },
            _ufrag: {
                writable: true,
                value: null
            },
            ufrag: {
                enumerable: true,
                get: function () {
                    return this._ufrag;
                }
            }
        });
    }
    /**
     * Set the ICE username fragment on the {@link IceBox}. This method returns any
     * ICE candidates associated with the username fragment.
     * @param {string} ufrag
     * @returns {Array<RTCIceCandidateInit>}
     */
    IceBox.prototype.setUfrag = function (ufrag) {
        this._ufrag = ufrag;
        var ice = this._filter.toMap().get(ufrag);
        return ice ? ice.candidates : [];
    };
    /**
     * Update the {@link IceBox}. This method returns any new ICE candidates
     * associated with the current username fragment.
     * @param {object} iceState
     * @returns {Array<RTCIceCandidateInit>}
     */
    IceBox.prototype.update = function (iceState) {
        // NOTE(mroberts): The Server sometimes does not set the candidates property.
        iceState.candidates = iceState.candidates || [];
        var oldIceState = this._filter.toMap().get(iceState.ufrag);
        var oldCandidates = oldIceState ? oldIceState.candidates : [];
        return this._filter.update(iceState) && this._ufrag === iceState.ufrag
            ? iceState.candidates.slice(oldCandidates.length)
            : [];
    };
    return IceBox;
}());
module.exports = IceBox;
//# sourceMappingURL=icebox.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/iceconnectionmonitor.js":
/*!****************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/iceconnectionmonitor.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var _a = __webpack_require__(/*! ../../util/constants */ "../../work/twilio-video.js/es5/util/constants.js"), ICE_ACTIVITY_CHECK_PERIOD_MS = _a.ICE_ACTIVITY_CHECK_PERIOD_MS, ICE_INACTIVITY_THRESHOLD_MS = _a.ICE_INACTIVITY_THRESHOLD_MS;
/**
 * Monitors a {@link RTCPeerConnection}'s stats and notifies
 * caller when inactivity is detected.
 */
var IceConnectionMonitor = /** @class */ (function () {
    /**
     * Construct an {@link IceConnectionMonitor}.
     * @param {RTCPeerConnection} peerConnection
     * @param {object} [options]
     */
    function IceConnectionMonitor(peerConnection, options) {
        options = Object.assign({
            activityCheckPeriodMs: ICE_ACTIVITY_CHECK_PERIOD_MS,
            inactivityThresholdMs: ICE_INACTIVITY_THRESHOLD_MS,
        }, options);
        Object.defineProperties(this, {
            _activityCheckPeriodMs: {
                value: options.activityCheckPeriodMs
            },
            _inactivityThresholdMs: {
                value: options.inactivityThresholdMs
            },
            _lastActivity: {
                value: null,
                writable: true
            },
            _peerConnection: {
                value: peerConnection
            },
            _timer: {
                value: null,
                writable: true,
            },
            _onIceConnectionStateChanged: {
                value: null,
                writable: true
            }
        });
    }
    IceConnectionMonitor.prototype._getActivePairStat = function (stats) {
        var statsArray = Array.from(stats.values());
        var hasInBoundTracks = statsArray.find(function (stat) { return stat.type === 'inbound-rtp'; });
        if (!hasInBoundTracks) {
            // NOTE(mpatwardhan): when there are no tracks shared on a peerConnection
            // we may see inactivity on bytesReceived - but that is not real inactivity,
            // ignore it.
            return null;
        }
        var activePairStats = statsArray.find(function (stat) { return stat.type === 'candidate-pair' && stat.nominated; });
        // NOTE(mpatwardhan): sometimes (JSDK-2667) after getting disconnected while switching network
        // we may not find active pair. Treat this as 0 bytesReceived so that we count it towards inactivity.
        return activePairStats || {
            bytesReceived: 0,
            timestamp: Math.round((new Date()).getTime())
        };
    };
    /**
     * Get ICE connection stats, and extract received and send bytes.
     * @returns Promise<?RTCIceCandidatePairStats>
     */
    IceConnectionMonitor.prototype._getIceConnectionStats = function () {
        var _this = this;
        return this._peerConnection.getStats().then(function (stats) { return _this._getActivePairStat(stats); }).catch(function () {
            return null;
        });
    };
    /**
     * schedules/un-schedules inactivity callback.
     */
    IceConnectionMonitor.prototype._scheduleInactivityCallback = function (callback) {
        var _this = this;
        if (callback && this._onIceConnectionStateChanged === null) {
            // schedule callback
            this._onIceConnectionStateChanged = function () {
                if (_this._peerConnection.iceConnectionState === 'disconnected') {
                    // eslint-disable-next-line callback-return
                    callback();
                }
            };
            this._peerConnection.addEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);
        }
        else if (!callback && this._onIceConnectionStateChanged) {
            // unschedule callback
            this._peerConnection.removeEventListener('iceconnectionstatechange', this._onIceConnectionStateChanged);
            this._onIceConnectionStateChanged = null;
        }
    };
    /**
     * Start monitoring the ICE connection.
     * Monitors bytes received on active ice connection pair,
     * invokes onIceConnectionInactive when inactivity is detected.
     * @param {function} onIceConnectionInactive
     */
    IceConnectionMonitor.prototype.start = function (onIceConnectionInactive) {
        var _this = this;
        this.stop();
        this._timer = setInterval(function () {
            _this._getIceConnectionStats().then(function (iceStats) {
                if (!iceStats) {
                    return;
                }
                if (!_this._lastActivity || _this._lastActivity.bytesReceived !== iceStats.bytesReceived) {
                    _this._lastActivity = iceStats;
                    // detected activity, cancel scheduled callback if any.
                    _this._scheduleInactivityCallback(null);
                }
                if (iceStats.timestamp - _this._lastActivity.timestamp >= _this._inactivityThresholdMs) {
                    // detected inactivity.
                    if (_this._peerConnection.iceConnectionState === 'disconnected') {
                        onIceConnectionInactive();
                    }
                    else if (_this._onIceConnectionStateChanged === null) {
                        _this._scheduleInactivityCallback(onIceConnectionInactive);
                    }
                }
            });
        }, this._activityCheckPeriodMs);
    };
    /**
     * Stop monitoring the ICE connection state.
     * @returns {void}
     */
    IceConnectionMonitor.prototype.stop = function () {
        this._scheduleInactivityCallback(null);
        if (this._timer !== null) {
            clearInterval(this._timer);
            this._timer = null;
            this._lastActivity = null;
        }
    };
    return IceConnectionMonitor;
}());
module.exports = IceConnectionMonitor;
//# sourceMappingURL=iceconnectionmonitor.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/index.js":
/*!*************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var defaultCreateCancelableRoomSignalingPromise = __webpack_require__(/*! ./cancelableroomsignalingpromise */ "../../work/twilio-video.js/es5/signaling/v2/cancelableroomsignalingpromise.js");
var LocalParticipantV2 = __webpack_require__(/*! ./localparticipant */ "../../work/twilio-video.js/es5/signaling/v2/localparticipant.js");
var Signaling = __webpack_require__(/*! ../ */ "../../work/twilio-video.js/es5/signaling/index.js");
/**
 * {@link SignalingV2} implements version 2 of our signaling protocol.
 * @extends Signaling
 */
var SignalingV2 = /** @class */ (function (_super) {
    __extends(SignalingV2, _super);
    /**
     * Construct {@link SignalingV2}.
     * @param {string} wsServer
     * @param {?object} [options={}]
     */
    function SignalingV2(wsServer, options) {
        var _this = this;
        /* eslint new-cap:0 */
        options = Object.assign({
            createCancelableRoomSignalingPromise: defaultCreateCancelableRoomSignalingPromise
        }, options);
        _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _createCancelableRoomSignalingPromise: {
                value: options.createCancelableRoomSignalingPromise
            },
            _options: {
                value: options
            },
            _wsServer: {
                value: wsServer
            }
        });
        return _this;
    }
    /**
     * @private
     */
    SignalingV2.prototype._connect = function (localParticipant, token, encodingParameters, preferredCodecs, options) {
        options = Object.assign({}, this._options, options);
        return this._createCancelableRoomSignalingPromise.bind(null, token, this._wsServer, localParticipant, encodingParameters, preferredCodecs, options);
    };
    SignalingV2.prototype.createLocalParticipantSignaling = function (encodingParameters, networkQualityConfiguration) {
        return new LocalParticipantV2(encodingParameters, networkQualityConfiguration);
    };
    return SignalingV2;
}(Signaling));
module.exports = SignalingV2;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/localparticipant.js":
/*!************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/localparticipant.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalParticipantSignaling = __webpack_require__(/*! ../localparticipant */ "../../work/twilio-video.js/es5/signaling/localparticipant.js");
var LocalTrackPublicationV2 = __webpack_require__(/*! ./localtrackpublication */ "../../work/twilio-video.js/es5/signaling/v2/localtrackpublication.js");
var isDeepEqual = __webpack_require__(/*! ../../util */ "../../work/twilio-video.js/es5/util/index.js").isDeepEqual;
/**
 * @extends ParticipantSignaling
 * @property {BandwidthProfileOptions} bandwidthProfile
 * @property {NetworkQualityConfigurationImpl} networkQualityConfiguration
 * @property {number} revision
 * @emits LocalParticipantV2#updated
 */
var LocalParticipantV2 = /** @class */ (function (_super) {
    __extends(LocalParticipantV2, _super);
    /**
     * Construct a {@link LocalParticipantV2}.
     * @param {EncodingParametersImpl} encodingParameters
     * @param {NetworkQualityConfigurationImpl} networkQualityConfiguration
     * @param {object} [options]
     */
    function LocalParticipantV2(encodingParameters, networkQualityConfiguration, options) {
        var _this = this;
        options = Object.assign({
            LocalTrackPublicationV2: LocalTrackPublicationV2
        }, options);
        _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _bandwidthProfile: {
                value: null,
                writable: true
            },
            _bandwidthProfileRevision: {
                value: 0,
                writable: true
            },
            _encodingParameters: {
                value: encodingParameters
            },
            _removeListeners: {
                value: new Map()
            },
            _LocalTrackPublicationV2: {
                value: options.LocalTrackPublicationV2
            },
            _publishedRevision: {
                writable: true,
                value: 0
            },
            _revision: {
                writable: true,
                value: 1
            },
            _signalingRegion: {
                value: null,
                writable: true
            },
            bandwidthProfile: {
                enumerable: true,
                get: function () {
                    return this._bandwidthProfile;
                }
            },
            bandwidthProfileRevision: {
                enumerable: true,
                get: function () {
                    return this._bandwidthProfileRevision;
                }
            },
            networkQualityConfiguration: {
                enumerable: true,
                value: networkQualityConfiguration
            },
            revision: {
                enumerable: true,
                get: function () {
                    return this._revision;
                }
            },
            signalingRegion: {
                enumerable: true,
                get: function () {
                    return this._signalingRegion;
                }
            }
        });
        return _this;
    }
    /**
     * Set the signalingRegion.
     * @param {string} signalingRegion.
     */
    LocalParticipantV2.prototype.setSignalingRegion = function (signalingRegion) {
        if (!this._signalingRegion) {
            this._signalingRegion = signalingRegion;
        }
    };
    /**
     * Update the {@link BandwidthProfileOptions}.
     * @param {BandwidthProfileOptions} bandwidthProfile
     */
    LocalParticipantV2.prototype.setBandwidthProfile = function (bandwidthProfile) {
        if (!isDeepEqual(this._bandwidthProfile, bandwidthProfile)) {
            // NOTE(mmalavalli): Object.assign() copies the values of only
            // the top level properties. In order to deep copy the object, we
            // stringify and parse the object.
            this._bandwidthProfile = JSON.parse(JSON.stringify(bandwidthProfile));
            this._bandwidthProfileRevision++;
            this.didUpdate();
        }
    };
    /**
     * Set the {@link EncodingParameters}.
     * @param {?EncodingParameters} encodingParameters
     * @returns {this}
     */
    LocalParticipantV2.prototype.setParameters = function (encodingParameters) {
        this._encodingParameters.update(encodingParameters);
        return this;
    };
    /**
     * Update the {@link LocalParticipantV2} with the new state.
     * @param {Published} published
     * @returns {this}
     */
    LocalParticipantV2.prototype.update = function (published) {
        if (this._publishedRevision >= published.revision) {
            return this;
        }
        this._publishedRevision = published.revision;
        published.tracks.forEach(function (publicationState) {
            var localTrackPublicationV2 = this.tracks.get(publicationState.id);
            if (localTrackPublicationV2) {
                localTrackPublicationV2.update(publicationState);
            }
        }, this);
        return this;
    };
    /**
     * @protected
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @param {string} name
     * @param {Track.Priority} priority
     * @returns {LocalTrackPublicationV2}
     */
    LocalParticipantV2.prototype._createLocalTrackPublicationSignaling = function (trackSender, name, priority) {
        return new this._LocalTrackPublicationV2(trackSender, name, priority);
    };
    /**
     * Add a {@link LocalTrackPublicationV2} for the given {@link DataTrackSender}
     * or {@link MediaTrackSender} to the {@link LocalParticipantV2}.
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @param {string} name
     * @param {Track.Priority} priority
     * @returns {this}
     */
    LocalParticipantV2.prototype.addTrack = function (trackSender, name, priority) {
        var _this = this;
        _super.prototype.addTrack.call(this, trackSender, name, priority);
        var publication = this.getPublication(trackSender);
        var isEnabled = publication.isEnabled, updatedPriority = publication.updatedPriority;
        var updated = function () {
            // NOTE(mmalavalli): The LocalParticipantV2's state is only published if
            // the "updated" event is emitted due to LocalTrackPublicationV2's
            // .isEnabled or .updatedPriority being changed. We do not publish if it is fired due to the
            // LocalTrackPublicationV2's .sid being set.
            if (isEnabled !== publication.isEnabled || updatedPriority !== publication.updatedPriority) {
                _this.didUpdate();
                isEnabled = publication.isEnabled;
                updatedPriority = publication.updatedPriority;
            }
        };
        publication.on('updated', updated);
        this._removeListener(publication);
        this._removeListeners.set(publication, function () { return publication.removeListener('updated', updated); });
        this.didUpdate();
        return this;
    };
    /**
     * @private
     * @param {LocalTrackPublicationV2} publication
     * @returns {void}
     */
    LocalParticipantV2.prototype._removeListener = function (publication) {
        var removeListener = this._removeListeners.get(publication);
        if (removeListener) {
            removeListener();
        }
    };
    /**
     * Get the current state of the {@link LocalParticipantV2}.
     * @returns {object}
     */
    LocalParticipantV2.prototype.getState = function () {
        return {
            revision: this.revision,
            tracks: Array.from(this.tracks.values()).map(function (track) { return track.getState(); })
        };
    };
    /**
     * Increment the revision for the {@link LocalParticipantV2}.
     * @private
     * @returns {void}
     */
    LocalParticipantV2.prototype.didUpdate = function () {
        this._revision++;
        this.emit('updated');
    };
    /**
     * Remove the {@link LocalTrackPublicationV2} for the given {@link DataTrackSender}
     * or {@link MediaTrackSender} from the {@link LocalParticipantV2}.
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @returns {?LocalTrackPublicationV2}
     */
    LocalParticipantV2.prototype.removeTrack = function (trackSender) {
        var publication = _super.prototype.removeTrack.call(this, trackSender);
        if (publication) {
            trackSender.removeClone(publication.trackTransceiver);
            this._removeListener(publication);
            this.didUpdate();
        }
        return publication;
    };
    /**
     * Updates the verbosity of network quality information.
     * @param {NetworkQualityConfiguration} networkQualityConfiguration
     * @returns {void}
     */
    LocalParticipantV2.prototype.setNetworkQualityConfiguration = function (networkQualityConfiguration) {
        this.networkQualityConfiguration.update(networkQualityConfiguration);
    };
    // lib/signaling/v2/localparticipant.js
    LocalParticipantV2.prototype.setPublisherHints = function (hints) {
        var _this = this;
        //     "hints": [
        //       {
        //         "encodings": [
        //           {
        //             "enabled": true,
        //             "layer_index": 0,
        //             "max_bitrate": 500000,
        //             "max_framerate": 5,
        //             "render_dimensions": {
        //               "height": 180,
        //               "width": 320
        //             }
        //           },
        //           {
        //             "enabled": false,
        //             "layer_index": 1
        //           }
        //         ],
        //         "track": "MT123"
        //       }
        //     ],
        hints.forEach(function (_a) {
            var track = _a.track, encodings = _a.encodings;
            var trackSignaling = Array.from(_this.tracks.values()).find(function (trackPub) { return trackPub.sid === track; });
            if (trackSignaling) {
                var rtpSender = Array.from(trackSignaling.trackTransceiver._senders)[0];
                var parameters_1 = rtpSender.getParameters();
                encodings.forEach(function (_a) {
                    var enabled = _a.enabled, layerIndex = _a.layer_index;
                    parameters_1.encodings[layerIndex].active = enabled;
                });
                rtpSender.setParameters(parameters_1);
            }
            else {
                // eslint-disable-next-line no-console
                console.error('track signaling not found: ', track);
            }
        });
    };
    return LocalParticipantV2;
}(LocalParticipantSignaling));
/**
 * @interface Published
 * @property {number} revision
 * @property {Array<PublishedTrack>} tracks
 */
/**
 * @typedef {CreatedTrack|ReadyTrack|FailedTrack} PublishedTrack
 */
/**
 * @interface CreatedTrack
 * @property {Track.ID} id
 * @property {string} state - "created"
 */
/**
 * @interface ReadyTrack
 * @property {Track.ID} id
 * @property {Track.SID} sid
 * @property {string} state - "ready"
 */
/**
 * @interface FailedTrack
 * @property {Track.ID} id
 * @property {TrackError} error
 * @property {string} state - "failed"
 */
/**
 * @interface TrackError
 * @property {number} code
 * @property {string} message
 */
/**
 * @event LocalParticipantV2#updated
 */
module.exports = LocalParticipantV2;
//# sourceMappingURL=localparticipant.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/localtrackpublication.js":
/*!*****************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/localtrackpublication.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalTrackPublicationSignaling = __webpack_require__(/*! ../localtrackpublication */ "../../work/twilio-video.js/es5/signaling/localtrackpublication.js");
var createTwilioError = __webpack_require__(/*! ../../util/twilio-video-errors */ "../../work/twilio-video.js/es5/util/twilio-video-errors.js").createTwilioError;
/**
 * @extends LocalTrackPublicationSignaling
 */
var LocalTrackPublicationV2 = /** @class */ (function (_super) {
    __extends(LocalTrackPublicationV2, _super);
    /**
     * Construct a {@link LocalTrackPublicationV2}.
     * @param {DataTrackSender|MediaTrackSender} trackSender
     * @param {string} name
     * @param {Track.Priority} priority
     */
    function LocalTrackPublicationV2(trackSender, name, priority) {
        return _super.call(this, trackSender, name, priority) || this;
    }
    /**
     * Get the {@link LocalTrackPublicationV2#Representation} of a given {@link TrackSignaling}.
     * @returns {LocalTrackPublicationV2#Representation} - without the SID
     */
    LocalTrackPublicationV2.prototype.getState = function () {
        return {
            enabled: this.isEnabled,
            id: this.id,
            kind: this.kind,
            name: this.name,
            priority: this.updatedPriority
        };
    };
    /**
     * Compare the {@link LocalTrackPublicationV2} to a {@link LocalTrackPublicationV2#Representation} of itself
     * and perform any updates necessary.
     * @param {PublishedTrack} track
     * @returns {this}
     * @fires TrackSignaling#updated
     */
    LocalTrackPublicationV2.prototype.update = function (track) {
        switch (track.state) {
            case 'ready':
                this.setSid(track.sid);
                break;
            case 'failed': {
                var error = track.error;
                this.publishFailed(createTwilioError(error.code, error.message));
                break;
            }
            default: // 'created'
                break;
        }
        return this;
    };
    return LocalTrackPublicationV2;
}(LocalTrackPublicationSignaling));
/**
 * The Room Signaling Protocol (RSP) representation of a {@link LocalTrackPublicationV2}.
 * @typedef {object} LocalTrackPublicationV2#Representation
 * @property {boolean} enabled
 * @property {Track.ID} id
 * @property {Track.Kind} kind
 * @property {string} name
 * @priority {Track.Priority} priority
 * @property {Track.SID} sid
 */
module.exports = LocalTrackPublicationV2;
//# sourceMappingURL=localtrackpublication.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/mediasignaling.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/mediasignaling.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint callback-return:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var nInstances = 0;
var MediaSignaling = /** @class */ (function (_super) {
    __extends(MediaSignaling, _super);
    /**
     * Construct a {@link MediaSignaling}.
     * @param {Promise<DataTrackReceiver>} getReceive
     * @param {string} channel
     */
    function MediaSignaling(getReceiver, channel, options) {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _instanceId: {
                value: nInstances++
            },
            channel: {
                value: channel,
            },
            _log: {
                value: options.log.createLog('default', _this)
            },
            _getReceiver: {
                value: getReceiver
            },
            _receiverPromise: {
                value: null,
                writable: true,
            },
            _transport: {
                value: null,
                writable: true
            }
        });
        return _this;
    }
    Object.defineProperty(MediaSignaling.prototype, "isSetup", {
        get: function () {
            return !!this._receiverPromise;
        },
        enumerable: false,
        configurable: true
    });
    MediaSignaling.prototype.toString = function () {
        return "[MediaSignaling #" + this._instanceId + ":" + this.channel + "]";
    };
    MediaSignaling.prototype.setup = function (id) {
        var _this = this;
        this._teardown();
        this._log.info('setting up msp transport for id:', id);
        var receiverPromise = this._getReceiver(id).then(function (receiver) {
            if (receiver.kind !== 'data') {
                _this._log.error('Expected a DataTrackReceiver');
                throw new Error('Expected a DataTrackReceiver');
            }
            if (_this._receiverPromise !== receiverPromise) {
                return;
            }
            try {
                _this._transport = receiver.toDataTransport();
            }
            catch (ex) {
                _this._log.error('Failed to toDataTransport');
                throw new Error('Failed to toDataTransport');
            }
            _this.emit('ready', _this._transport);
            receiver.once('close', function () { return _this._teardown(); });
        });
        this._receiverPromise = receiverPromise;
    };
    MediaSignaling.prototype._teardown = function () {
        if (this._transport) {
            this._log.info('Tearing down');
            this._transport = null;
            this._receiverPromise = null;
            this.emit('teardown');
        }
    };
    return MediaSignaling;
}(EventEmitter));
module.exports = MediaSignaling;
//# sourceMappingURL=mediasignaling.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/networkqualitymonitor.js":
/*!*****************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/networkqualitymonitor.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint callback-return:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var PeerConnectionReportFactory = __webpack_require__(/*! ../../stats/peerconnectionreportfactory */ "../../work/twilio-video.js/es5/stats/peerconnectionreportfactory.js");
/**
 * @emits NetworkQualityMonitor#updated
 */
var NetworkQualityMonitor = /** @class */ (function (_super) {
    __extends(NetworkQualityMonitor, _super);
    /**
     * Construct a {@link NetworkQualityMonitor}.
     * @param {PeerConnectionManager} manager
     * @param {NetworkQualitySignaling} signaling
     */
    function NetworkQualityMonitor(manager, signaling) {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _factories: {
                value: new WeakMap()
            },
            _manager: {
                value: manager
            },
            _signaling: {
                value: signaling
            }
        });
        signaling.on('updated', function () { return _this.emit('updated'); });
        return _this;
    }
    Object.defineProperty(NetworkQualityMonitor.prototype, "level", {
        /**
         * Get the current {@link NetworkQualityLevel}, if any.
         * @returns {?NetworkQualityLevel} level - initially null
         */
        get: function () {
            return this._signaling.level;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NetworkQualityMonitor.prototype, "levels", {
        /**
         * Get the current {@link NetworkQualityLevels}, if any.
         * @returns {?NetworkQualityLevels} levels - initially null
         */
        get: function () {
            return this._signaling.levels;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NetworkQualityMonitor.prototype, "remoteLevels", {
        /**
         * Get the current {@link NetworkQualityLevels} of remote participants, if any.
         * @returns {Map<String, NetworkQualityLevels>} remoteLevels
         */
        get: function () {
            return this._signaling.remoteLevels;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Start monitoring.
     * @returns {void}
     */
    NetworkQualityMonitor.prototype.start = function () {
        var _this = this;
        this.stop();
        var timeout = setTimeout(function () {
            if (_this._timeout !== timeout) {
                return;
            }
            next(_this).then(function (reports) {
                if (_this._timeout !== timeout) {
                    return;
                }
                if (reports.length) {
                    var _a = __read(reports, 1), report = _a[0];
                    _this._signaling.put(report);
                }
                _this.start();
            });
        }, 200);
        this._timeout = timeout;
    };
    /**
     * Stop monitoring.
     * @returns {void}
     */
    NetworkQualityMonitor.prototype.stop = function () {
        clearTimeout(this._timeout);
        this._timeout = null;
    };
    return NetworkQualityMonitor;
}(EventEmitter));
/**
 * @param {NetworkQualityMonitor}
 * @returns {Promise<NetworkQualityInputs>}
 */
function next(monitor) {
    var pcv2s = monitor._manager._peerConnections
        ? Array.from(monitor._manager._peerConnections.values())
        : [];
    var pcs = pcv2s
        .map(function (pcv2) { return pcv2._peerConnection; })
        .filter(function (pc) { return pc.signalingState !== 'closed'; });
    var factories = pcs.map(function (pc) {
        if (monitor._factories.has(pc)) {
            return monitor._factories.get(pc);
        }
        var factory = new PeerConnectionReportFactory(pc);
        monitor._factories.set(pc, factory);
        return factory;
    });
    var reportsOrNullPromises = factories.map(function (factory) { return factory.next().catch(function () { return null; }); });
    return Promise.all(reportsOrNullPromises).then(function (reportsOrNull) { return reportsOrNull
        .filter(function (reportOrNull) { return reportOrNull; })
        .map(function (report) { return report.summarize(); }); });
}
/**
 * The {@link NetworkQualityLevel} changed.
 * @event NetworkQualityMonitor#updated
 */
module.exports = NetworkQualityMonitor;
//# sourceMappingURL=networkqualitymonitor.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/networkqualitysignaling.js":
/*!*******************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/networkqualitysignaling.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaSignaling = __webpack_require__(/*! ./mediasignaling */ "../../work/twilio-video.js/es5/signaling/v2/mediasignaling.js");
var AsyncVar = __webpack_require__(/*! ../../util/asyncvar */ "../../work/twilio-video.js/es5/util/asyncvar.js");
/**
 * @interface MediaSignalingTransport
 * @property {function(object): boolean} send
 * @emits MediaSignalingTransport#message
 */
/**
 * The {@link MediaSignalingTransport} received a message.
 * @event MediaSignalingTransport#message
 * @param {object} message
 */
/**
 * @interface LatencyStats
 * @property {number} jitter
 * @property {number} rtt
 * @property {number} level
 */
/**
 * @interface FractionLostStats
 * @property {number} fractionLost
 * @property {number} level
 */
/**
 * @interface BandwidthStats
 * @property {number} actual
 * @property {number} available
 * @property {number} level
 */
/**
 * @interface SendOrRecvStats
 * @property {BandwidthStats} bandwidth
 * @property {FractionLostStats} fractionLost
 * @property {LatencyStats} latency
 */
/**
 * @interface MediaLevels
 * @property {number} send
 * @property {SendOrRecvStats} sendStats
 * @property {number} recv
 * @property {SendOrRecvStats} recvStats
 */
/**
 * @interface NetworkQualityLevels
 * @property {number} level
 * @property {MediaLevels} audio
 * @property {MediaLevels} video
 */
/**
 * @typedef {PeerConnectionSummary} NetworkQualityInputs
 */
/**
 * @classdesc The {@link NetworkQualitySignaling} class allows submitting
 *   {@link NetworkQualityInputs} for computing {@link NetworkQualityLevel}. It
 *   does so by sending and receiving messages over a
 *   {@link MediaSignalingTransport}. The exact transport used depends on the
 *   topology of the {@link Room} that {@link NetworkQualitySignaling} is being
 *   used within: for P2P Rooms, we re-use the {@link TransportV2}; and for
 *   Group Rooms, we use a {@link DataTransport}.
 * @emits NetworkQualitySignaling#updated
 */
var NetworkQualitySignaling = /** @class */ (function (_super) {
    __extends(NetworkQualitySignaling, _super);
    /**
     * Construct a {@link NetworkQualitySignaling}.
     * @param {Promise<DataTrackReceiver>} getReceiver
     * @param {NetworkQualityConfigurationImpl} networkQualityConfiguration
     */
    function NetworkQualitySignaling(getReceiver, networkQualityConfiguration, options) {
        var _this = _super.call(this, getReceiver, 'network_quality', options) || this;
        Object.defineProperties(_this, {
            _level: {
                value: null,
                writable: true
            },
            _levels: {
                value: null,
                writable: true
            },
            _remoteLevels: {
                value: new Map(),
                writable: true
            },
            _networkQualityInputs: {
                value: new AsyncVar()
            },
            _networkQualityReportLevels: {
                get: function () {
                    return {
                        reportLevel: networkQualityConfiguration.local,
                        remoteReportLevel: networkQualityConfiguration.remote
                    };
                }
            }
        });
        _this.on('ready', function (transport) {
            transport.on('message', function (message) {
                switch (message.type) {
                    case 'network_quality':
                        _this._handleNetworkQualityMessage(message);
                        break;
                    default:
                        break;
                }
            });
        });
        _this._sendNetworkQualityInputs();
        return _this;
    }
    Object.defineProperty(NetworkQualitySignaling.prototype, "level", {
        /**
         * Get the current {@link NetworkQualityLevel}, if any.
         * @returns {?NetworkQualityLevel} level - initially null
         */
        get: function () {
            return this._level;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NetworkQualitySignaling.prototype, "levels", {
        /**
         * Get the current {@link NetworkQualityLevels}, if any.
         * @returns {?NetworkQualityLevels} levels - initially null
         */
        get: function () {
            return this._levels;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NetworkQualitySignaling.prototype, "remoteLevels", {
        /**
         * Get the current {@link NetworkQualityLevels} of remote participants, if any.
         * @returns {Map<String, NetworkQualityLevels>} remoteLevels
         */
        get: function () {
            return this._remoteLevels;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Check to see if the {@link NetworkQualityLevel} is new, and raise an
     * event if necessary.
     * @private
     * @param {object} message
     * @returns {void}
     */
    NetworkQualitySignaling.prototype._handleNetworkQualityMessage = function (message) {
        var _this = this;
        var updated = false;
        var level = null;
        var local = message ? message.local : null;
        if (typeof local === 'number') {
            // NOTE(mroberts): In prod, we plan to only send the level.
            level = local;
            this._levels = null;
        }
        else if (typeof local === 'object' && local) {
            // NOTE(mroberts): In dev, we plan to send the decomposed levels. An early
            // VMS version does not compute `level` for us, so we fallback to taking
            // the minimum ourselves.
            this._levels = local;
            level = typeof local.level === 'number'
                ? local.level
                : Math.min(local.audio.send, local.audio.recv, local.video.send, local.video.recv);
        }
        if (level !== null && this.level !== level) {
            this._level = level;
            updated = true;
        }
        this._remoteLevels = message && message.remotes
            ? message.remotes.reduce(function (levels, obj) {
                var oldObj = _this._remoteLevels.get(obj.sid) || {};
                if (oldObj.level !== obj.level) {
                    updated = true;
                }
                return levels.set(obj.sid, obj);
            }, new Map())
            : this._remoteLevels;
        if (updated) {
            this.emit('updated');
        }
        setTimeout(function () { return _this._sendNetworkQualityInputs(); }, 1000);
    };
    /**
     * Start sending {@link NetworkQualityInputs}.
     * @private
     * @returns {Promise<void>}
     */
    NetworkQualitySignaling.prototype._sendNetworkQualityInputs = function () {
        var _this = this;
        return this._networkQualityInputs.take().then(function (networkQualityInputs) {
            if (_this._transport) {
                _this._transport.publish(createNetworkQualityInputsMessage(networkQualityInputs, _this._networkQualityReportLevels));
            }
        });
    };
    /**
     * Put {@link NetworkQualityInputs} to be used for computing
     * {@link NetworkQualityLevel}.
     * @param {NetworkQualityInputs} networkQualityInputs
     * @returns {void}
     */
    NetworkQualitySignaling.prototype.put = function (networkQualityInputs) {
        this._networkQualityInputs.put(networkQualityInputs);
    };
    return NetworkQualitySignaling;
}(MediaSignaling));
/**
 * The {@link NetworkQualityLevel} changed.
 * @event NetworkQualitySignaling#updated
 */
/**
 * @typedef {object} NetworkQualityReportLevels
 * @param {number} reportLevel
 * @param {number} remoteReportLevel
 */
/**
 * @param {NetworkQualityInputs} networkQualityInputs
 * @param {NetworkQualityReportLevels} networkQualityReportLevels
 * @returns {object} message
 */
function createNetworkQualityInputsMessage(networkQualityInputs, networkQualityReportLevels) {
    return Object.assign({ type: 'network_quality' }, networkQualityInputs, networkQualityReportLevels);
}
module.exports = NetworkQualitySignaling;
//# sourceMappingURL=networkqualitysignaling.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/peerconnection.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/peerconnection.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var DefaultBackoff = __webpack_require__(/*! backoff */ "../../work/twilio-video.js/node_modules/backoff/index.js");
var _a = __webpack_require__(/*! @twilio/webrtc */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/index.js"), DefaultMediaStream = _a.MediaStream, DefaultRTCIceCandidate = _a.RTCIceCandidate, DefaultRTCPeerConnection = _a.RTCPeerConnection, DefaultRTCSessionDescription = _a.RTCSessionDescription, getStatistics = _a.getStats;
var guessBrowser = __webpack_require__(/*! @twilio/webrtc/lib/util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").guessBrowser;
var getSdpFormat = __webpack_require__(/*! @twilio/webrtc/lib/util/sdp */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/sdp.js").getSdpFormat;
var _b = __webpack_require__(/*! ../../util/constants */ "../../work/twilio-video.js/es5/util/constants.js"), DEFAULT_ICE_GATHERING_TIMEOUT_MS = _b.DEFAULT_ICE_GATHERING_TIMEOUT_MS, DEFAULT_LOG_LEVEL = _b.DEFAULT_LOG_LEVEL, DEFAULT_SESSION_TIMEOUT_SEC = _b.DEFAULT_SESSION_TIMEOUT_SEC, iceRestartBackoffConfig = _b.iceRestartBackoffConfig;
var _c = __webpack_require__(/*! ../../util/sdp */ "../../work/twilio-video.js/es5/util/sdp/index.js"), createCodecMapForMediaSection = _c.createCodecMapForMediaSection, disableRtx = _c.disableRtx, enableDtxForOpus = _c.enableDtxForOpus, getMediaSections = _c.getMediaSections, removeSSRCAttributes = _c.removeSSRCAttributes, revertSimulcastForNonVP8MediaSections = _c.revertSimulcastForNonVP8MediaSections, setBitrateParameters = _c.setBitrateParameters, setCodecPreferences = _c.setCodecPreferences, setSimulcast = _c.setSimulcast, unifiedPlanAddOrRewriteNewTrackIds = _c.unifiedPlanAddOrRewriteNewTrackIds, unifiedPlanAddOrRewriteTrackIds = _c.unifiedPlanAddOrRewriteTrackIds, unifiedPlanFilterLocalCodecs = _c.unifiedPlanFilterLocalCodecs;
var DefaultTimeout = __webpack_require__(/*! ../../util/timeout */ "../../work/twilio-video.js/es5/util/timeout.js");
var _d = __webpack_require__(/*! ../../util/twilio-video-errors */ "../../work/twilio-video.js/es5/util/twilio-video-errors.js"), MediaClientLocalDescFailedError = _d.MediaClientLocalDescFailedError, MediaClientRemoteDescFailedError = _d.MediaClientRemoteDescFailedError;
var _e = __webpack_require__(/*! ../../util */ "../../work/twilio-video.js/es5/util/index.js"), buildLogLevels = _e.buildLogLevels, getPlatform = _e.getPlatform, isChromeScreenShareTrack = _e.isChromeScreenShareTrack, oncePerTick = _e.oncePerTick;
var IceBox = __webpack_require__(/*! ./icebox */ "../../work/twilio-video.js/es5/signaling/v2/icebox.js");
var DefaultIceConnectionMonitor = __webpack_require__(/*! ./iceconnectionmonitor.js */ "../../work/twilio-video.js/es5/signaling/v2/iceconnectionmonitor.js");
var DataTrackReceiver = __webpack_require__(/*! ../../data/receiver */ "../../work/twilio-video.js/es5/data/receiver.js");
var MediaTrackReceiver = __webpack_require__(/*! ../../media/track/receiver */ "../../work/twilio-video.js/es5/media/track/receiver.js");
var StateMachine = __webpack_require__(/*! ../../statemachine */ "../../work/twilio-video.js/es5/statemachine.js");
var Log = __webpack_require__(/*! ../../util/log */ "../../work/twilio-video.js/es5/util/log.js");
var IdentityTrackMatcher = __webpack_require__(/*! ../../util/sdp/trackmatcher/identity */ "../../work/twilio-video.js/es5/util/sdp/trackmatcher/identity.js");
var OrderedTrackMatcher = __webpack_require__(/*! ../../util/sdp/trackmatcher/ordered */ "../../work/twilio-video.js/es5/util/sdp/trackmatcher/ordered.js");
var MIDTrackMatcher = __webpack_require__(/*! ../../util/sdp/trackmatcher/mid */ "../../work/twilio-video.js/es5/util/sdp/trackmatcher/mid.js");
var workaroundIssue8329 = __webpack_require__(/*! ../../util/sdp/issue8329 */ "../../work/twilio-video.js/es5/util/sdp/issue8329.js");
var guess = guessBrowser();
var platform = getPlatform();
var isAndroid = /android/.test(platform);
var isChrome = guess === 'chrome';
var isFirefox = guess === 'firefox';
var isSafari = guess === 'safari';
var isRTCRtpSenderParamsSupported = typeof RTCRtpSender !== 'undefined'
    && typeof RTCRtpSender.prototype.getParameters === 'function'
    && typeof RTCRtpSender.prototype.setParameters === 'function';
var nInstances = 0;
/*
PeerConnectionV2 States
-----------------------

    +------+    +--------+
    |      |    |        |
    | open |--->| closed |
    |      |    |        |
    +------+    +--------+
      |  ^          ^
      |  |          |
      |  |          |
      v  |          |
  +----------+      |
  |          |      |
  | updating |------+
  |          |
  +----------+

*/
var states = {
    open: [
        'closed',
        'updating'
    ],
    updating: [
        'closed',
        'open'
    ],
    closed: []
};
/**
 * @extends StateMachine
 * @property {id}
 * @emits PeerConnectionV2#connectionStateChanged
 * @emits PeerConnectionV2#iceConnectionStateChanged
 * @emits PeerConnectionV2#candidates
 * @emits PeerConnectionV2#description
 */
var PeerConnectionV2 = /** @class */ (function (_super) {
    __extends(PeerConnectionV2, _super);
    /**
     * Construct a {@link PeerConnectionV2}.
     * @param {string} id
     * @param {EncodingParametersImpl} encodingParameters
     * @param {PreferredCodecs} preferredCodecs
     * @param {object} [options]
     */
    function PeerConnectionV2(id, encodingParameters, preferredCodecs, options) {
        var _this = _super.call(this, 'open', states) || this;
        options = Object.assign({
            enableDscp: false,
            dummyAudioMediaStreamTrack: null,
            isChromeScreenShareTrack: isChromeScreenShareTrack,
            iceServers: [],
            isRTCRtpSenderParamsSupported: isRTCRtpSenderParamsSupported,
            logLevel: DEFAULT_LOG_LEVEL,
            offerOptions: {},
            revertSimulcastForNonVP8MediaSections: revertSimulcastForNonVP8MediaSections,
            sessionTimeout: DEFAULT_SESSION_TIMEOUT_SEC * 1000,
            setBitrateParameters: setBitrateParameters,
            setCodecPreferences: setCodecPreferences,
            setSimulcast: setSimulcast,
            Backoff: DefaultBackoff,
            IceConnectionMonitor: DefaultIceConnectionMonitor,
            MediaStream: DefaultMediaStream,
            RTCIceCandidate: DefaultRTCIceCandidate,
            RTCPeerConnection: DefaultRTCPeerConnection,
            RTCSessionDescription: DefaultRTCSessionDescription,
            Timeout: DefaultTimeout
        }, options);
        var configuration = getConfiguration(options);
        var sdpFormat = getSdpFormat(configuration.sdpSemantics);
        var isUnifiedPlan = sdpFormat === 'unified';
        var localMediaStream = isUnifiedPlan ? null : new options.MediaStream();
        var logLevels = buildLogLevels(options.logLevel);
        var RTCPeerConnection = options.RTCPeerConnection;
        if (options.enableDscp === true) {
            options.chromeSpecificConstraints = options.chromeSpecificConstraints || {};
            options.chromeSpecificConstraints.optional = options.chromeSpecificConstraints.optional || [];
            options.chromeSpecificConstraints.optional.push({ googDscp: true });
        }
        var log = options.log ? options.log.createLog('webrtc', _this) : new Log('webrtc', _this, logLevels, options.loggerName);
        var peerConnection = new RTCPeerConnection(configuration, options.chromeSpecificConstraints);
        if (options.dummyAudioMediaStreamTrack) {
            peerConnection.addTrack(options.dummyAudioMediaStreamTrack, localMediaStream || new options.MediaStream());
        }
        Object.defineProperties(_this, {
            _appliedTrackIdsToAttributes: {
                value: new Map(),
                writable: true
            },
            _dataChannels: {
                value: new Map()
            },
            _dataTrackReceivers: {
                value: new Set()
            },
            _descriptionRevision: {
                writable: true,
                value: 0
            },
            _didGenerateLocalCandidates: {
                writable: true,
                value: false
            },
            _enableDscp: {
                value: options.enableDscp
            },
            _encodingParameters: {
                value: encodingParameters
            },
            _isChromeScreenShareTrack: {
                value: options.isChromeScreenShareTrack,
            },
            _iceGatheringFailed: {
                value: false,
                writable: true
            },
            _iceGatheringTimeout: {
                value: new options.Timeout(function () { return _this._handleIceGatheringTimeout(); }, DEFAULT_ICE_GATHERING_TIMEOUT_MS, false)
            },
            _iceRestartBackoff: {
                value: options.Backoff.exponential(iceRestartBackoffConfig)
            },
            _instanceId: {
                value: ++nInstances
            },
            _isIceConnectionInactive: {
                writable: true,
                value: false
            },
            _isIceLite: {
                writable: true,
                value: false
            },
            _isIceRestartBackoffInProgress: {
                writable: true,
                value: false
            },
            _isRestartingIce: {
                writable: true,
                value: false
            },
            _isUnifiedPlan: {
                value: isUnifiedPlan
            },
            _isRTCRtpSenderParamsSupported: {
                value: options.isRTCRtpSenderParamsSupported
            },
            _lastIceConnectionState: {
                writable: true,
                value: null
            },
            _lastStableDescriptionRevision: {
                writable: true,
                value: 0
            },
            _localCandidates: {
                writable: true,
                value: []
            },
            _localCodecs: {
                value: new Set()
            },
            _localCandidatesRevision: {
                writable: true,
                value: 1
            },
            _localDescriptionWithoutSimulcast: {
                writable: true,
                value: null
            },
            _localDescription: {
                writable: true,
                value: null
            },
            _localMediaStream: {
                value: localMediaStream
            },
            _localUfrag: {
                writable: true,
                value: null
            },
            _log: {
                value: log
            },
            _eventObserver: {
                value: options.eventObserver
            },
            _remoteCodecMaps: {
                value: new Map()
            },
            _rtpSenders: {
                value: new Map()
            },
            _iceConnectionMonitor: {
                value: new options.IceConnectionMonitor(peerConnection)
            },
            _mediaTrackReceivers: {
                value: new Set()
            },
            _needsAnswer: {
                writable: true,
                value: false
            },
            _negotiationRole: {
                writable: true,
                value: null
            },
            _offerOptions: {
                writable: true,
                value: options.offerOptions
            },
            _onEncodingParametersChanged: {
                value: oncePerTick(function () {
                    if (_this._isRTCRtpSenderParamsSupported) {
                        if (!_this._needsAnswer) {
                            updateEncodingParameters(_this);
                        }
                        return;
                    }
                    _this.offer();
                })
            },
            _peerConnection: {
                value: peerConnection
            },
            _preferredAudioCodecs: {
                value: preferredCodecs.audio
            },
            _preferredVideoCodecs: {
                value: preferredCodecs.video
            },
            _shouldApplyDtx: {
                value: preferredCodecs.audio.every(function (_a) {
                    var codec = _a.codec;
                    return codec !== 'opus';
                })
                    || preferredCodecs.audio.some(function (_a) {
                        var codec = _a.codec, dtx = _a.dtx;
                        return codec === 'opus' && dtx;
                    })
            },
            _shouldApplySimulcast: {
                value: (isChrome || isSafari) && preferredCodecs.video.some(function (codecSettings) { return codecSettings.codec.toLowerCase() === 'vp8' && codecSettings.simulcast; })
            },
            _queuedDescription: {
                writable: true,
                value: null
            },
            _iceReconnectTimeout: {
                value: new options.Timeout(function () {
                    log.debug('ICE reconnect timed out');
                    _this.close();
                }, options.sessionTimeout, false)
            },
            _recycledTransceivers: {
                value: {
                    audio: [],
                    video: []
                }
            },
            _replaceTrackPromises: {
                value: new Map()
            },
            _remoteCandidates: {
                writable: true,
                value: new IceBox()
            },
            _sdpFormat: {
                value: sdpFormat
            },
            _setBitrateParameters: {
                value: options.setBitrateParameters
            },
            _setCodecPreferences: {
                // NOTE(mmalavalli): Re-ordering payload types in order to make sure a non-H264
                // preferred codec is selected does not work on Android Firefox due to this behavior:
                // https://bugzilla.mozilla.org/show_bug.cgi?id=1683258. So, we work around this by
                // not applying any non-H264 preferred video codec.
                value: isFirefox && isAndroid && preferredCodecs.video[0] && preferredCodecs.video[0].codec.toLowerCase() !== 'h264'
                    ? function (sdp) { return sdp; }
                    : options.setCodecPreferences
            },
            _setSimulcast: {
                value: options.setSimulcast
            },
            _revertSimulcastForNonVP8MediaSections: {
                value: options.revertSimulcastForNonVP8MediaSections
            },
            _RTCIceCandidate: {
                value: options.RTCIceCandidate
            },
            _RTCPeerConnection: {
                value: options.RTCPeerConnection
            },
            _RTCSessionDescription: {
                value: options.RTCSessionDescription
            },
            _shouldOffer: {
                writable: true,
                value: false
            },
            _shouldRestartIce: {
                writable: true,
                value: false
            },
            _trackIdsToAttributes: {
                value: new Map(),
                writable: true
            },
            _trackMatcher: {
                writable: true,
                value: null
            },
            id: {
                enumerable: true,
                value: id
            }
        });
        encodingParameters.on('changed', _this._onEncodingParametersChanged);
        peerConnection.addEventListener('connectionstatechange', _this._handleConnectionStateChange.bind(_this));
        peerConnection.addEventListener('datachannel', _this._handleDataChannelEvent.bind(_this));
        peerConnection.addEventListener('icecandidate', _this._handleIceCandidateEvent.bind(_this));
        peerConnection.addEventListener('iceconnectionstatechange', _this._handleIceConnectionStateChange.bind(_this));
        peerConnection.addEventListener('icegatheringstatechange', _this._handleIceGatheringStateChange.bind(_this));
        peerConnection.addEventListener('signalingstatechange', _this._handleSignalingStateChange.bind(_this));
        peerConnection.addEventListener('track', _this._handleTrackEvent.bind(_this));
        _this._iceRestartBackoff.on('ready', function () { return _this._initiateIceRestart(); });
        var self = _this;
        _this.on('stateChanged', function stateChanged(state) {
            if (state !== 'closed') {
                return;
            }
            self.removeListener('stateChanged', stateChanged);
            self._dataChannels.forEach(function (dataChannel, dataTrackSender) {
                self.removeDataTrackSender(dataTrackSender);
            });
        });
        return _this;
    }
    PeerConnectionV2.prototype.toString = function () {
        return "[PeerConnectionV2 #" + this._instanceId + ": " + this.id + "]";
    };
    Object.defineProperty(PeerConnectionV2.prototype, "connectionState", {
        /**
         * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's RTCPeerConnectionState
         * if supported by the browser, its RTCIceConnectionState otherwise.
         * @property {RTCPeerConnectionState}
         */
        get: function () {
            return this.iceConnectionState === 'failed'
                ? 'failed' : (this._peerConnection.connectionState || this.iceConnectionState);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PeerConnectionV2.prototype, "iceConnectionState", {
        /**
         * The {@link PeerConnectionV2}'s underlying RTCPeerConnection's
         * RTCIceConnectionState.
         * @property {RTCIceConnectionState}
         */
        get: function () {
            return ((this._isIceConnectionInactive && this._peerConnection.iceConnectionState === 'disconnected') || this._iceGatheringFailed)
                ? 'failed' : this._peerConnection.iceConnectionState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PeerConnectionV2.prototype, "isApplicationSectionNegotiated", {
        /**
         * Whether the {@link PeerConnectionV2} has negotiated or is in the process
         * of negotiating the application m= section.
         * @returns {boolean}
         */
        get: function () {
            if (this._peerConnection.signalingState !== 'closed') {
                // accessing .localDescription in 'closed' state causes it throw exceptions.
                return this._peerConnection.localDescription
                    ? getMediaSections(this._peerConnection.localDescription.sdp, 'application').length > 0
                    : false;
            }
            return true;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Add an ICE candidate to the {@link PeerConnectionV2}.
     * @private
     * @param {object} candidate
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._addIceCandidate = function (candidate) {
        var _this = this;
        return Promise.resolve().then(function () {
            candidate = new _this._RTCIceCandidate(candidate);
            return _this._peerConnection.addIceCandidate(candidate);
        }).catch(function (error) {
            // NOTE(mmalavalli): Firefox 68+ now generates an RTCIceCandidate with an
            // empty candidate string to signal end-of-candidates, followed by a null
            // candidate. As of now, Chrome and Safari reject this RTCIceCandidate. Since
            // this does not affect the media connection between Firefox 68+ and Chrome/Safari
            // in Peer-to-Peer Rooms, we suppress the Error and log a warning message.
            //
            // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=978582
            //
            _this._log.warn("Failed to add RTCIceCandidate " + (candidate ? "\"" + candidate.candidate + "\"" : 'null') + ": "
                + error.message);
        });
    };
    /**
     * Add ICE candidates to the {@link PeerConnectionV2}.
     * @private
     * @param {Array<object>} candidates
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._addIceCandidates = function (candidates) {
        return Promise.all(candidates.map(this._addIceCandidate, this)).then(function () { });
    };
    /**
     * Add a new RTCRtpTransceiver or update an existing RTCRtpTransceiver for the
     * given MediaStreamTrack.
     * @private
     * @param {MediaStreamTrack} track
     * @returns {RTCRtpTransceiver}
     */
    PeerConnectionV2.prototype._addOrUpdateTransceiver = function (track) {
        var _this = this;
        var transceiver = takeRecycledTransceiver(this, track.kind);
        if (transceiver && transceiver.sender) {
            var oldTrackId = transceiver.sender.track ? transceiver.sender.track.id : null;
            if (oldTrackId) {
                this._log.warn("Reusing transceiver: " + transceiver.mid + "] " + oldTrackId + " => " + track.id);
            }
            // NOTE(mpatwardhan):remember this transceiver while we replace track.
            // we recycle transceivers that are not in use after 'negotiationCompleted', but we want to prevent
            // this one from getting recycled while replaceTrack is pending.
            this._replaceTrackPromises.set(transceiver, transceiver.sender.replaceTrack(track).then(function () {
                transceiver.direction = 'sendrecv';
            }, function () {
                // Do nothing.
            }).finally(function () {
                _this._replaceTrackPromises.delete(transceiver);
            }));
            return transceiver;
        }
        return this._peerConnection.addTransceiver(track);
    };
    /**
     * Check the {@link IceBox}.
     * @private
     * @param {RTCSessionDescriptionInit} description
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._checkIceBox = function (description) {
        var ufrag = getUfrag(description);
        if (!ufrag) {
            return Promise.resolve();
        }
        var candidates = this._remoteCandidates.setUfrag(ufrag);
        return this._addIceCandidates(candidates);
    };
    /**
     * Create an answer and set it on the {@link PeerConnectionV2}.
     * @private
     * @param {RTCSessionDescriptionInit} offer
     * @returns {Promise<boolean>}
     */
    PeerConnectionV2.prototype._answer = function (offer) {
        var _this = this;
        return Promise.resolve().then(function () {
            if (!_this._negotiationRole) {
                _this._negotiationRole = 'answerer';
            }
            return _this._setRemoteDescription(offer);
        }).catch(function () {
            throw new MediaClientRemoteDescFailedError();
        }).then(function () {
            return _this._peerConnection.createAnswer();
        }).then(function (answer) {
            if (isFirefox) {
                // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling
                // RTX in Firefox 79+. For more details about the bug, please go here:
                // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157
                answer = new _this._RTCSessionDescription({
                    sdp: disableRtx(answer.sdp),
                    type: answer.type
                });
            }
            else {
                answer = workaroundIssue8329(answer);
            }
            // NOTE(mpatwardhan): Upcoming chrome versions are going to remove ssrc attributes
            // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110
            // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ
            // We are not referencing those attributes, but this changes goes ahead and removes them to see if it works.
            // this also helps reduce bytes on wires
            var updatedSdp = removeSSRCAttributes(answer.sdp, ['mslabel', 'label']);
            if (_this._shouldApplySimulcast) {
                var sdpWithoutSimulcast = updatedSdp;
                updatedSdp = _this._setSimulcast(sdpWithoutSimulcast, _this._sdpFormat, _this._trackIdsToAttributes);
                // NOTE(syerrapragada): VMS does not support H264 simulcast. So,
                // unset simulcast for sections in local offer where corresponding
                // sections in answer doesn't have vp8 as preferred codec and reapply offer.
                updatedSdp = _this._revertSimulcastForNonVP8MediaSections(updatedSdp, sdpWithoutSimulcast, offer.sdp);
            }
            // NOTE(mmalavalli): Work around Chromium bug 1074421.
            // https://bugs.chromium.org/p/chromium/issues/detail?id=1074421
            updatedSdp = updatedSdp.replace(/42e015/g, '42e01f');
            return _this._setLocalDescription({
                type: answer.type,
                sdp: updatedSdp
            });
        }).then(function () {
            return _this._checkIceBox(offer);
        }).then(function () {
            return _this._queuedDescription
                && _this._updateDescription(_this._queuedDescription);
        }).then(function () {
            _this._queuedDescription = null;
            return _this._maybeReoffer(_this._peerConnection.localDescription);
        }).catch(function (error) {
            var errorToThrow = error instanceof MediaClientRemoteDescFailedError ? error : new MediaClientLocalDescFailedError();
            _this._publishMediaWarning({
                message: 'Failed to _answer',
                code: errorToThrow.code,
                error: error
            });
            throw errorToThrow;
        });
    };
    /**
     * Close the underlying RTCPeerConnection. Returns false if the
     * RTCPeerConnection was already closed.
     * @private
     * @returns {boolean}
     */
    PeerConnectionV2.prototype._close = function () {
        this._iceConnectionMonitor.stop();
        if (this._peerConnection.signalingState !== 'closed') {
            this._peerConnection.close();
            this.preempt('closed');
            this._encodingParameters.removeListener('changed', this._onEncodingParametersChanged);
            return true;
        }
        return false;
    };
    /**
     * Handle a "connectionstatechange" event.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleConnectionStateChange = function () {
        this.emit('connectionStateChanged');
    };
    /**
     * Handle a "datachannel" event.
     * @private
     * @param {RTCDataChannelEvent} event
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleDataChannelEvent = function (event) {
        var _this = this;
        var dataChannel = event.channel;
        var dataTrackReceiver = new DataTrackReceiver(dataChannel);
        this._dataTrackReceivers.add(dataTrackReceiver);
        dataChannel.addEventListener('close', function () {
            _this._dataTrackReceivers.delete(dataTrackReceiver);
        });
        this.emit('trackAdded', dataTrackReceiver);
    };
    /**
     * Handle a glare scenario on the {@link PeerConnectionV2}.
     * @private
     * @param {RTCSessionDescriptionInit} offer
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._handleGlare = function (offer) {
        var _this = this;
        this._log.debug('Glare detected; rolling back');
        if (this._isRestartingIce) {
            this._log.debug('An ICE restart was in progress; we\'ll need to restart ICE again after rolling back');
            this._isRestartingIce = false;
            this._shouldRestartIce = true;
        }
        return Promise.resolve().then(function () {
            _this._trackIdsToAttributes = new Map(_this._appliedTrackIdsToAttributes);
            return _this._setLocalDescription({ type: 'rollback' });
        }).then(function () {
            _this._needsAnswer = false;
            return _this._answer(offer);
        }).then(function (didReoffer) {
            return didReoffer ? Promise.resolve() : _this._offer();
        });
    };
    PeerConnectionV2.prototype._publishMediaWarning = function (_a) {
        var message = _a.message, code = _a.code, error = _a.error, sdp = _a.sdp;
        this._eventObserver.emit('event', { level: 'warning', name: 'error', group: 'media', payload: {
                message: message,
                code: code,
                context: JSON.stringify({ error: error.message, sdp: sdp })
            } });
    };
    /**
     * Handle an ICE candidate event.
     * @private
     * @param {Event} event
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleIceCandidateEvent = function (event) {
        if (event.candidate) {
            this._log.debug('Clearing ICE gathering timeout');
            this._didGenerateLocalCandidates = true;
            this._iceGatheringTimeout.clear();
            this._localCandidates.push(event.candidate);
        }
        var peerConnectionState = {
            ice: {
                candidates: this._isIceLite ? [] : this._localCandidates.slice(),
                ufrag: this._localUfrag
            },
            id: this.id
        };
        if (!event.candidate) {
            peerConnectionState.ice.complete = true;
        }
        if (!(this._isIceLite && event.candidate)) {
            peerConnectionState.ice.revision = this._localCandidatesRevision++;
            this.emit('candidates', peerConnectionState);
        }
    };
    /**
     * Handle an ICE connection state change event.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleIceConnectionStateChange = function () {
        var _this = this;
        var iceConnectionState = this._peerConnection.iceConnectionState;
        var isIceConnectedOrComplete = ['connected', 'completed'].includes(iceConnectionState);
        var log = this._log;
        log.debug("ICE connection state is \"" + iceConnectionState + "\"");
        if (isIceConnectedOrComplete) {
            this._iceReconnectTimeout.clear();
            this._iceRestartBackoff.reset();
        }
        if (this._lastIceConnectionState !== 'failed' && iceConnectionState === 'failed' && !this._shouldRestartIce && !this._isRestartingIce) {
            // Case 1: Transition to "failed".
            log.warn('ICE failed');
            this._initiateIceRestartBackoff();
        }
        else if (['disconnected', 'failed'].includes(this._lastIceConnectionState) && isIceConnectedOrComplete) {
            // Case 2: Transition from "disconnected" or "failed".
            log.debug('ICE reconnected');
        }
        // start monitor media when connected, and continue to monitor while state is complete-disconnected-connected.
        if (iceConnectionState === 'connected') {
            this._isIceConnectionInactive = false;
            this._iceConnectionMonitor.start(function () {
                // note: iceConnection monitor waits for iceConnectionState=disconnected for
                // detecting inactivity. Its possible that it may know about disconnected before _handleIceConnectionStateChange
                _this._iceConnectionMonitor.stop();
                if (!_this._shouldRestartIce && !_this._isRestartingIce) {
                    log.warn('ICE Connection Monitor detected inactivity');
                    _this._isIceConnectionInactive = true;
                    _this._initiateIceRestartBackoff();
                    _this.emit('iceConnectionStateChanged');
                    _this.emit('connectionStateChanged');
                }
            });
        }
        else if (!['disconnected', 'completed'].includes(iceConnectionState)) { // don't stop monitoring for disconnected or completed.
            this._iceConnectionMonitor.stop();
            this._isIceConnectionInactive = false;
        }
        this._lastIceConnectionState = iceConnectionState;
        this.emit('iceConnectionStateChanged');
    };
    /**
     * Handle ICE gathering timeout.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleIceGatheringTimeout = function () {
        this._log.warn('ICE failed to gather any local candidates');
        this._iceGatheringFailed = true;
        this._initiateIceRestartBackoff();
        this.emit('iceConnectionStateChanged');
        this.emit('connectionStateChanged');
    };
    /**
     * Handle an ICE gathering state change event.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleIceGatheringStateChange = function () {
        var iceGatheringState = this._peerConnection.iceGatheringState;
        var log = this._log;
        log.debug("ICE gathering state is \"" + iceGatheringState + "\"");
        // NOTE(mmalavalli): Start the ICE gathering timeout only if the RTCPeerConnection
        // has started gathering candidates for the first time since the initial offer/answer
        // or an offer/answer with ICE restart.
        var _a = this._iceGatheringTimeout, delay = _a.delay, isSet = _a.isSet;
        if (iceGatheringState === 'gathering' && !this._didGenerateLocalCandidates && !isSet) {
            log.debug("Starting ICE gathering timeout: " + delay);
            this._iceGatheringFailed = false;
            this._iceGatheringTimeout.start();
        }
    };
    /**
     * Handle a signaling state change event.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleSignalingStateChange = function () {
        if (this._peerConnection.signalingState === 'stable') {
            this._appliedTrackIdsToAttributes = new Map(this._trackIdsToAttributes);
        }
    };
    /**
     * Handle a track event.
     * @private
     * @param {Event} event
     * @returns {void}
     */
    PeerConnectionV2.prototype._handleTrackEvent = function (event) {
        var _this = this;
        var sdp = this._peerConnection.remoteDescription
            ? this._peerConnection.remoteDescription.sdp
            : null;
        if (!this._trackMatcher) {
            this._trackMatcher = event.transceiver && event.transceiver.mid
                ? new MIDTrackMatcher()
                // NOTE(mroberts): Until Chrome ships RTCRtpTransceivers with MID
                // support, we have to use the same hacky solution as Safari. Revisit
                // this when RTCRtpTransceivers and MIDs land. We should be able to use
                // the same technique as Firefox.
                : isSafari || this._isUnifiedPlan ? new OrderedTrackMatcher() : new IdentityTrackMatcher();
        }
        this._trackMatcher.update(sdp);
        var mediaStreamTrack = event.track;
        var signaledTrackId = this._trackMatcher.match(event) || mediaStreamTrack.id;
        var mediaTrackReceiver = new MediaTrackReceiver(signaledTrackId, mediaStreamTrack);
        // NOTE(mmalavalli): In unified plan mode, "ended" is not fired on the remote
        // MediaStreamTrack when the remote peer removes a track. So, when this
        // MediaStreamTrack is re-used for a different track due to the remote peer
        // calling RTCRtpSender.replaceTrack(), we delete the previous MediaTrackReceiver
        // that owned this MediaStreamTrack before adding the new MediaTrackReceiver.
        this._mediaTrackReceivers.forEach(function (trackReceiver) {
            if (trackReceiver.track.id === mediaTrackReceiver.track.id) {
                _this._mediaTrackReceivers.delete(trackReceiver);
            }
        });
        this._mediaTrackReceivers.add(mediaTrackReceiver);
        mediaStreamTrack.addEventListener('ended', function () { return _this._mediaTrackReceivers.delete(mediaTrackReceiver); });
        this.emit('trackAdded', mediaTrackReceiver);
    };
    /**
     * Initiate ICE Restart.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._initiateIceRestart = function () {
        if (this._peerConnection.signalingState === 'closed') {
            return;
        }
        var log = this._log;
        log.warn('Attempting to restart ICE');
        this._didGenerateLocalCandidates = false;
        this._isIceRestartBackoffInProgress = false;
        this._shouldRestartIce = true;
        var _a = this._iceReconnectTimeout, delay = _a.delay, isSet = _a.isSet;
        if (!isSet) {
            log.debug("Starting ICE reconnect timeout: " + delay);
            this._iceReconnectTimeout.start();
        }
        this.offer();
    };
    /**
     * Schedule an ICE Restart.
     * @private
     * @returns {void}
     */
    PeerConnectionV2.prototype._initiateIceRestartBackoff = function () {
        if (this._peerConnection.signalingState === 'closed' || this._isIceRestartBackoffInProgress) {
            return;
        }
        this._log.warn('An ICE restart has been scheduled');
        this._isIceRestartBackoffInProgress = true;
        this._iceRestartBackoff.backoff();
    };
    /**
     * Conditionally re-offer.
     * @private
     * @param {?RTCSessionDescriptionInit} localDescription
     * @returns {Promise<boolean>}
     */
    PeerConnectionV2.prototype._maybeReoffer = function (localDescription) {
        var shouldReoffer = this._shouldOffer;
        if (localDescription && localDescription.sdp) {
            // NOTE(mmalavalli): For "unified-plan" sdps, if the local RTCSessionDescription
            // has fewer audio and/or video send* m= lines than the corresponding RTCRtpSenders
            // with non-null MediaStreamTracks, it means that the newly added RTCRtpSenders
            // require renegotiation.
            if (this._isUnifiedPlan) {
                var senders_1 = this._peerConnection.getSenders().filter(function (sender) { return sender.track; });
                shouldReoffer = ['audio', 'video'].reduce(function (shouldOffer, kind) {
                    var mediaSections = getMediaSections(localDescription.sdp, kind, '(sendrecv|sendonly)');
                    var sendersOfKind = senders_1.filter(isSenderOfKind.bind(null, kind));
                    return shouldOffer || (mediaSections.length < sendersOfKind.length);
                }, shouldReoffer);
            }
            // NOTE(mroberts): We also need to re-offer if we have a DataTrack to share
            // but no m= application section.
            var hasDataTrack = this._dataChannels.size > 0;
            var hasApplicationMediaSection = getMediaSections(localDescription.sdp, 'application').length > 0;
            var needsApplicationMediaSection = hasDataTrack && !hasApplicationMediaSection;
            shouldReoffer = shouldReoffer || needsApplicationMediaSection;
        }
        var promise = shouldReoffer ? this._offer() : Promise.resolve();
        return promise.then(function () { return shouldReoffer; });
    };
    /**
     * Create an offer and set it on the {@link PeerConnectionV2}.
     * @private
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._offer = function () {
        var _this = this;
        var offerOptions = Object.assign({}, this._offerOptions);
        this._needsAnswer = true;
        if (this._shouldRestartIce) {
            this._shouldRestartIce = false;
            this._isRestartingIce = true;
            offerOptions.iceRestart = true;
        }
        return Promise.all(this._replaceTrackPromises.values()).then(function () {
            return _this._peerConnection.createOffer(offerOptions);
        }).catch(function (error) {
            var errorToThrow = new MediaClientLocalDescFailedError();
            _this._publishMediaWarning({
                message: 'Failed to create offer',
                code: errorToThrow.code,
                error: error
            });
            throw errorToThrow;
        }).then(function (offer) {
            if (isFirefox) {
                // NOTE(mmalavalli): We work around Chromium bug 1106157 by disabling
                // RTX in Firefox 79+. For more details about the bug, please go here:
                // https://bugs.chromium.org/p/chromium/issues/detail?id=1106157
                offer = new _this._RTCSessionDescription({
                    sdp: disableRtx(offer.sdp),
                    type: offer.type
                });
            }
            else {
                offer = workaroundIssue8329(offer);
            }
            // NOTE(mpatwardhan): upcoming chrome versions are going to remove ssrc attributes
            // mslabel and label. See this bug https://bugs.chromium.org/p/webrtc/issues/detail?id=7110
            // and PSA: https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date/discuss-webrtc/jcZO-Wj0Wus/k2XvPCvoAwAJ
            // Looks like we are not referencing those attributes, but this changes goes ahead and removes them to see if it works.
            // this also helps reduce bytes on wires
            var sdp = removeSSRCAttributes(offer.sdp, ['mslabel', 'label']);
            sdp = _this._isUnifiedPlan && _this._peerConnection.remoteDescription
                ? unifiedPlanFilterLocalCodecs(sdp, _this._peerConnection.remoteDescription.sdp)
                : sdp;
            var updatedSdp = _this._setCodecPreferences(sdp, _this._preferredAudioCodecs, _this._preferredVideoCodecs);
            _this._shouldOffer = false;
            if (!_this._negotiationRole) {
                _this._negotiationRole = 'offerer';
            }
            if (_this._shouldApplySimulcast) {
                _this._localDescriptionWithoutSimulcast = {
                    type: 'offer',
                    sdp: updatedSdp
                };
                updatedSdp = _this._setSimulcast(updatedSdp, _this._sdpFormat, _this._trackIdsToAttributes);
            }
            return _this._setLocalDescription({
                type: 'offer',
                sdp: updatedSdp
            });
        });
    };
    /**
     * Get the MediaTrackSender ID of the given MediaStreamTrack ID.
     * Since a MediaTrackSender's underlying MediaStreamTrack can be
     * replaced, the corresponding IDs can mismatch.
     * @private
     * @param {Track.ID} id
     * @returns {Track.ID}
     */
    PeerConnectionV2.prototype._getMediaTrackSenderId = function (trackId) {
        var mediaTrackSender = Array.from(this._rtpSenders.keys()).find(function (_a) {
            var id = _a.track.id;
            return id === trackId;
        });
        return mediaTrackSender ? mediaTrackSender.id : trackId;
    };
    /**
     * Add or rewrite local MediaStreamTrack IDs in the given Unified Plan RTCSessionDescription.
     * @private
     * @param {RTCSessionDescription} description
     * @return {RTCSessionDescription}
     */
    PeerConnectionV2.prototype._addOrRewriteLocalTrackIds = function (description) {
        var _this = this;
        var transceivers = this._peerConnection.getTransceivers();
        var activeTransceivers = transceivers.filter(function (_a) {
            var sender = _a.sender, stopped = _a.stopped;
            return !stopped && sender && sender.track;
        });
        // NOTE(mmalavalli): There is no guarantee that MediaStreamTrack IDs will be present in
        // SDPs, and even if they are, there is no guarantee that they will be the same as the
        // actual MediaStreamTrack IDs. So, we add or re-write the actual MediaStreamTrack IDs
        // to the assigned m= sections here.
        var assignedTransceivers = activeTransceivers.filter(function (_a) {
            var mid = _a.mid;
            return mid;
        });
        var midsToTrackIds = new Map(assignedTransceivers.map(function (_a) {
            var mid = _a.mid, sender = _a.sender;
            return [mid, _this._getMediaTrackSenderId(sender.track.id)];
        }));
        var sdp1 = unifiedPlanAddOrRewriteTrackIds(description.sdp, midsToTrackIds);
        // NOTE(mmalavalli): Chrome and Safari do not apply the offer until they get an answer.
        // So, we add or re-write the actual MediaStreamTrack IDs to the unassigned m= sections here.
        var unassignedTransceivers = activeTransceivers.filter(function (_a) {
            var mid = _a.mid;
            return !mid;
        });
        var newTrackIdsByKind = new Map(['audio', 'video'].map(function (kind) { return [
            kind,
            unassignedTransceivers.filter(function (_a) {
                var sender = _a.sender;
                return sender.track.kind === kind;
            }).map(function (_a) {
                var sender = _a.sender;
                return _this._getMediaTrackSenderId(sender.track.id);
            })
        ]; }));
        var sdp2 = unifiedPlanAddOrRewriteNewTrackIds(sdp1, midsToTrackIds, newTrackIdsByKind);
        return new this._RTCSessionDescription({
            sdp: sdp2,
            type: description.type
        });
    };
    /**
     * Rollback and apply the given offer.
     * @private
     * @param {RTCSessionDescriptionInit} offer
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._rollbackAndApplyOffer = function (offer) {
        var _this = this;
        return this._setLocalDescription({ type: 'rollback' }).then(function () { return _this._setLocalDescription(offer); });
    };
    /**
     * Set a local description on the {@link PeerConnectionV2}.
     * @private
     * @param {RTCSessionDescription|RTCSessionDescriptionInit} description
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._setLocalDescription = function (description) {
        var _this = this;
        if (description.type !== 'rollback' && this._shouldApplyDtx) {
            description = new this._RTCSessionDescription({
                sdp: enableDtxForOpus(description.sdp),
                type: description.type
            });
        }
        return this._peerConnection.setLocalDescription(description).catch(function (error) {
            _this._log.warn("Calling setLocalDescription with an RTCSessionDescription of type \"" + description.type + "\" failed with the error \"" + error.message + "\".");
            var errorToThrow = new MediaClientLocalDescFailedError();
            var publishWarning = {
                message: "Calling setLocalDescription with an RTCSessionDescription of type \"" + description.type + "\" failed",
                code: errorToThrow.code,
                error: error
            };
            if (description.sdp) {
                _this._log.warn("The SDP was " + description.sdp);
                publishWarning.sdp = description.sdp;
            }
            _this._publishMediaWarning(publishWarning);
            throw errorToThrow;
        }).then(function () {
            if (description.type !== 'rollback') {
                _this._localDescription = _this._isUnifiedPlan ? _this._addOrRewriteLocalTrackIds(description) : description;
                // NOTE(mmalavalli): In order for this feature to be backward compatible with older
                // SDK versions which to not support opus DTX, we append "usedtx=1" to the local SDP
                // only while applying it. We will not send it over the wire to prevent inadvertent
                // enabling of opus DTX in older SDKs. Newer SDKs will append "usedtx=1" by themselves
                // if the developer has requested opus DTX to be enabled. (JSDK-3063)
                if (_this._shouldApplyDtx) {
                    _this._localDescription = new _this._RTCSessionDescription({
                        sdp: enableDtxForOpus(_this._localDescription.sdp, []),
                        type: _this._localDescription.type
                    });
                }
                _this._localCandidates = [];
                if (description.type === 'offer') {
                    _this._descriptionRevision++;
                }
                else if (description.type === 'answer') {
                    _this._lastStableDescriptionRevision = _this._descriptionRevision;
                    negotiationCompleted(_this);
                }
                _this._localUfrag = getUfrag(description);
                _this.emit('description', _this.getState());
            }
        });
    };
    /**
     * Set a remote RTCSessionDescription on the {@link PeerConnectionV2}.
     * @private
     * @param {RTCSessionDescriptionInit} description
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._setRemoteDescription = function (description) {
        var _this = this;
        if (description.sdp) {
            if (!this._isRTCRtpSenderParamsSupported) {
                description.sdp = this._setBitrateParameters(description.sdp, isFirefox ? 'TIAS' : 'AS', this._encodingParameters.maxAudioBitrate, this._encodingParameters.maxVideoBitrate);
            }
            description.sdp = this._setCodecPreferences(description.sdp, this._preferredAudioCodecs, this._preferredVideoCodecs);
            if (this._shouldApplyDtx) {
                description.sdp = enableDtxForOpus(description.sdp);
            }
            else {
                // NOTE(mmalavalli): Remove "usedtx=1" from opus's fmtp line if present
                // since DTX is disabled.
                description.sdp = enableDtxForOpus(description.sdp, []);
            }
            if (isFirefox) {
                // NOTE(mroberts): Do this to reduce our MediaStream count in Firefox. By
                // mapping MediaStream IDs in the SDP to "-", we ensure the "track" event
                // doesn't include any new MediaStreams in Firefox. Its `streams` member
                // will always be the empty Array.
                description.sdp = filterOutMediaStreamIds(description.sdp);
            }
            if (!this._peerConnection.remoteDescription) {
                this._isIceLite = /a=ice-lite/.test(description.sdp);
            }
        }
        description = new this._RTCSessionDescription(description);
        // eslint-disable-next-line consistent-return
        return Promise.resolve().then(function () {
            // NOTE(syerrapragada): VMS does not support H264 simulcast. So,
            // unset simulcast for sections in local offer where corresponding
            // sections in answer doesn't have vp8 as preferred codec and reapply offer.
            if (description.type === 'answer' && _this._shouldApplySimulcast) {
                var sdpWithoutSimulcastForNonVP8MediaSections = _this._revertSimulcastForNonVP8MediaSections(_this._localDescription.sdp, _this._localDescriptionWithoutSimulcast.sdp, description.sdp);
                if (sdpWithoutSimulcastForNonVP8MediaSections !== _this._localDescription.sdp) {
                    return _this._rollbackAndApplyOffer({
                        type: _this._localDescription.type,
                        sdp: sdpWithoutSimulcastForNonVP8MediaSections
                    });
                }
            }
        }).then(function () { return _this._peerConnection.setRemoteDescription(description); }).then(function () {
            if (description.type === 'answer') {
                if (_this._isRestartingIce) {
                    _this._log.debug('An ICE restart was in-progress and is now completed');
                    _this._isRestartingIce = false;
                }
                negotiationCompleted(_this);
            }
        }, function (error) {
            _this._log.warn("Calling setRemoteDescription with an RTCSessionDescription of type \"" + description.type + "\" failed with the error \"" + error.message + "\".");
            if (description.sdp) {
                _this._log.warn("The SDP was " + description.sdp);
            }
            throw error;
        });
    };
    /**
     * Update the {@link PeerConnectionV2}'s description.
     * @private
     * @param {RTCSessionDescriptionInit} description
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._updateDescription = function (description) {
        var _this = this;
        switch (description.type) {
            case 'answer':
            case 'pranswer':
                if (description.revision !== this._descriptionRevision
                    || this._peerConnection.signalingState !== 'have-local-offer') {
                    return Promise.resolve();
                }
                this._descriptionRevision = description.revision;
                break;
            case 'close':
                return this._close();
            case 'create-offer':
                if (description.revision <= this._lastStableDescriptionRevision) {
                    return Promise.resolve();
                }
                else if (this._needsAnswer) {
                    this._queuedDescription = description;
                    return Promise.resolve();
                }
                this._descriptionRevision = description.revision;
                return this._offer();
            case 'offer':
                if (description.revision <= this._lastStableDescriptionRevision
                    || this._peerConnection.signalingState === 'closed') {
                    return Promise.resolve();
                }
                if (this._peerConnection.signalingState === 'have-local-offer') {
                    // NOTE(mpatwardhan): For a peer connection
                    // 1) createOffer always generate SDP with `setup:actpass`
                    // 2) when remote description is set `setup:active`  - the answer generated selects the dtls role of setup:passive
                    // 3) when remote description is set `setup:passive` - the answer generated selects the dtls role of setup:active
                    // 4) when remote description is set `setup:actpass` - the answer generated uses the previously negotiated role (if not negotiated previously setup:active is used)
                    // This test shows the  behavior: https://github.com/twilio/twilio-webrtc.js/blob/master/test/integration/spec/rtcpeerconnection.js#L936
                    // with glare handling (if dtls role was not negotiated before ) the generated answer will set setup:active.
                    // we do not want that. lets wait for "initial negotiation" before attempting glare handling.
                    if (this._needsAnswer && this._lastStableDescriptionRevision === 0) {
                        this._queuedDescription = description;
                        return Promise.resolve();
                    }
                    this._descriptionRevision = description.revision;
                    return this._handleGlare(description);
                }
                this._descriptionRevision = description.revision;
                return this._answer(description).then(function () { });
            default:
            // Do nothing.
        }
        // Handle answer or pranswer.
        var revision = description.revision;
        return Promise.resolve().then(function () {
            return _this._setRemoteDescription(description);
        }).catch(function (error) {
            var errorToThrow = new MediaClientRemoteDescFailedError();
            _this._publishMediaWarning({
                message: "Calling setRemoteDescription with an RTCSessionDescription of type \"" + description.type + "\" failed",
                code: errorToThrow.code,
                error: error,
                sdp: description.sdp
            });
            throw errorToThrow;
        }).then(function () {
            _this._lastStableDescriptionRevision = revision;
            _this._needsAnswer = false;
            return _this._checkIceBox(description);
        }).then(function () {
            return _this._queuedDescription
                && _this._updateDescription(_this._queuedDescription);
        }).then(function () {
            _this._queuedDescription = null;
            return _this._maybeReoffer(_this._peerConnection.localDescription).then(function () { });
        });
    };
    /**
     * Update the {@link PeerConnectionV2}'s ICE candidates.
     * @private
     * @param {object} iceState
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype._updateIce = function (iceState) {
        var candidates = this._remoteCandidates.update(iceState);
        return this._addIceCandidates(candidates);
    };
    /**
     * Add a {@link DataTrackSender} to the {@link PeerConnectionV2}.
     * @param {DataTrackSender} dataTrackSender
     * @returns {void}
     */
    PeerConnectionV2.prototype.addDataTrackSender = function (dataTrackSender) {
        if (this._dataChannels.has(dataTrackSender)) {
            return;
        }
        try {
            var dataChannelDict = {
                ordered: dataTrackSender.ordered
            };
            if (dataTrackSender.maxPacketLifeTime !== null) {
                dataChannelDict.maxPacketLifeTime = dataTrackSender.maxPacketLifeTime;
            }
            if (dataTrackSender.maxRetransmits !== null) {
                dataChannelDict.maxRetransmits = dataTrackSender.maxRetransmits;
            }
            var dataChannel = this._peerConnection.createDataChannel(dataTrackSender.id, dataChannelDict);
            dataTrackSender.addDataChannel(dataChannel);
            this._dataChannels.set(dataTrackSender, dataChannel);
        }
        catch (error) {
            this._log.warn("Error creating an RTCDataChannel for DataTrack \"" + dataTrackSender.id + "\": " + error.message);
        }
    };
    /**
     * Add the {@link MediaTrackSender} to the {@link PeerConnectionV2}.
     * @param {MediaTrackSender} mediaTrackSender
     * @returns {void}
     */
    PeerConnectionV2.prototype.addMediaTrackSender = function (mediaTrackSender) {
        if (this._peerConnection.signalingState === 'closed' || this._rtpSenders.has(mediaTrackSender)) {
            return;
        }
        var sender;
        if (this._localMediaStream) {
            this._localMediaStream.addTrack(mediaTrackSender.track);
            sender = this._peerConnection.addTrack(mediaTrackSender.track, this._localMediaStream);
        }
        else {
            var transceiver = this._addOrUpdateTransceiver(mediaTrackSender.track);
            sender = transceiver.sender;
        }
        mediaTrackSender.addSender(sender);
        this._rtpSenders.set(mediaTrackSender, sender);
    };
    /**
     * Close the {@link PeerConnectionV2}.
     * @returns {void}
     */
    PeerConnectionV2.prototype.close = function () {
        if (this._close()) {
            this._descriptionRevision++;
            this._localDescription = { type: 'close' };
            this.emit('description', this.getState());
        }
    };
    /**
     * Get the {@link DataTrackReceiver}s and the {@link MediaTrackReceivers} on the
     * {@link PeerConnectionV2}.
     * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers
     */
    PeerConnectionV2.prototype.getTrackReceivers = function () {
        return Array.from(this._dataTrackReceivers).concat(Array.from(this._mediaTrackReceivers));
    };
    /**
     * Get the {@link PeerConnectionV2}'s state (specifically, its description).
     * @returns {?object}
     */
    PeerConnectionV2.prototype.getState = function () {
        if (!this._localDescription) {
            return null;
        }
        // NOTE(mpatwardhan): Return most recent localDescription. If the most recent local description is an
        // answer, and this method is called for sending a "sync" message while the next remote offer is being processed,
        // we need to send the most recent stable description revision instead of the current description revision,
        // which is supposed to be for the next local answer.
        var localDescriptionRevision = this._localDescription.type === 'answer' ? this._lastStableDescriptionRevision : this._descriptionRevision;
        var localDescription = {
            type: this._localDescription.type,
            revision: localDescriptionRevision
        };
        if (this._localDescription.sdp) {
            localDescription.sdp = this._localDescription.sdp;
        }
        return {
            description: localDescription,
            id: this.id
        };
    };
    /**
     * Create an offer and set it on the {@link PeerConnectionV2}.
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype.offer = function () {
        var _this = this;
        if (this._needsAnswer || this._isRestartingIce) {
            this._shouldOffer = true;
            return Promise.resolve();
        }
        return this.bracket('offering', function (key) {
            _this.transition('updating', key);
            var promise = _this._needsAnswer || _this._isRestartingIce ? Promise.resolve() : _this._offer();
            return promise.then(function () {
                _this.tryTransition('open', key);
            }, function (error) {
                _this.tryTransition('open', key);
                throw error;
            });
        });
    };
    /**
     * Remove a {@link DataTrackSender} from the {@link PeerConnectionV2}.
     * @param {DataTrackSender} dataTrackSender
     * @returns {void}
     */
    PeerConnectionV2.prototype.removeDataTrackSender = function (dataTrackSender) {
        var dataChannel = this._dataChannels.get(dataTrackSender);
        if (dataChannel) {
            dataTrackSender.removeDataChannel(dataChannel);
            this._dataChannels.delete(dataTrackSender);
            dataChannel.close();
        }
    };
    /**
     * Remove the {@link MediaTrackSender} from the {@link PeerConnectionV2}.
     * @param {MediaTrackSender} mediaTrackSender
     * @returns {void}
     */
    PeerConnectionV2.prototype.removeMediaTrackSender = function (mediaTrackSender) {
        var sender = this._rtpSenders.get(mediaTrackSender);
        if (!sender) {
            return;
        }
        if (this._peerConnection.signalingState !== 'closed') {
            this._peerConnection.removeTrack(sender);
        }
        if (this._localMediaStream) {
            this._localMediaStream.removeTrack(mediaTrackSender.track);
        }
        mediaTrackSender.removeSender(sender);
        this._rtpSenders.delete(mediaTrackSender);
    };
    /**
     * Set the RTCConfiguration on the underlying RTCPeerConnection.
     * @param {RTCConfiguration} configuration
     * @returns {void}
     */
    PeerConnectionV2.prototype.setConfiguration = function (configuration) {
        if (typeof this._peerConnection.setConfiguration === 'function') {
            this._peerConnection.setConfiguration(getConfiguration(configuration));
        }
    };
    /**
     * Set the ICE reconnect timeout period.
     * @param {number} period - Period in milliseconds.
     * @returns {this}
     */
    PeerConnectionV2.prototype.setIceReconnectTimeout = function (period) {
        this._iceReconnectTimeout.setDelay(period);
        this._log.debug('Updated ICE reconnection timeout period:', this._iceReconnectTimeout.delay);
        return this;
    };
    /**
     * Update the {@link PeerConnectionV2}.
     * @param {object} peerConnectionState
     * @returns {Promise<void>}
     */
    PeerConnectionV2.prototype.update = function (peerConnectionState) {
        var _this = this;
        return this.bracket('updating', function (key) {
            if (_this.state === 'closed') {
                return Promise.resolve();
            }
            _this.transition('updating', key);
            var updates = [];
            if (peerConnectionState.ice) {
                updates.push(_this._updateIce(peerConnectionState.ice));
            }
            if (peerConnectionState.description) {
                updates.push(_this._updateDescription(peerConnectionState.description));
            }
            return Promise.all(updates).then(function () {
                _this.tryTransition('open', key);
            }, function (error) {
                _this.tryTransition('open', key);
                throw error;
            });
        });
    };
    /**
     * Get the {@link PeerConnectionV2}'s media statistics.
     * @returns {Promise<StandardizedStatsResponse>}
     */
    PeerConnectionV2.prototype.getStats = function () {
        var _this = this;
        return getStatistics(this._peerConnection).then(function (response) { return rewriteTrackIds(_this, response); });
    };
    return PeerConnectionV2;
}(StateMachine));
function rewriteLocalTrackId(pcv2, stats) {
    var trackId = pcv2._getMediaTrackSenderId(stats.trackId);
    return Object.assign(stats, { trackId: trackId });
}
function rewriteTrackId(pcv2, stats) {
    var receiver = __spreadArray([], __read(pcv2._mediaTrackReceivers)).find(function (receiver) { return receiver.track.id === stats.trackId; });
    var trackId = receiver ? receiver.id : null;
    return Object.assign(stats, { trackId: trackId });
}
function rewriteTrackIds(pcv2, response) {
    return Object.assign(response, {
        remoteAudioTrackStats: response.remoteAudioTrackStats.map(function (stats) { return rewriteTrackId(pcv2, stats); }),
        remoteVideoTrackStats: response.remoteVideoTrackStats.map(function (stats) { return rewriteTrackId(pcv2, stats); }),
        localAudioTrackStats: response.localAudioTrackStats.map(function (stats) { return rewriteLocalTrackId(pcv2, stats); }),
        localVideoTrackStats: response.localVideoTrackStats.map(function (stats) { return rewriteLocalTrackId(pcv2, stats); }),
    });
}
/**
 * @event PeerConnectionV2#candidates
 * @param {object} candidates
 */
/**
 * @event PeerConnectionV2#connectionStateChanged
 */
/**
 * @event PeerConnectionV2#description
 * @param {object} description
 */
/**
 * @event PeerConnectionV2#iceConnectionStateChanged
 */
/**
 * @event PeerConnectionV2#trackAdded
 * @param {DataTrackReceiver|MediaTrackReceiver} trackReceiver
 */
function getUfrag(description) {
    if (description.sdp) {
        var match = description.sdp.match(/^a=ice-ufrag:([a-zA-Z0-9+/]+)/m);
        if (match) {
            return match[1];
        }
    }
    return null;
}
function getConfiguration(configuration) {
    return Object.assign({
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
    }, configuration);
}
/**
 * Whether the MediaStreamTrack of the given RTCRTPSender is a non-ended
 * MediaStreamTrack of a given kind.
 * @private
 * @param {string} kind
 * @param {RTCRtpSender} sender
 * @return {boolean}
 */
function isSenderOfKind(kind, sender) {
    var track = sender.track;
    return track && track.kind === kind && track.readyState !== 'ended';
}
/**
 * Preferred codecs.
 * @typedef {object} PreferredCodecs
 * @property {Array<AudioCodec>} audio
 * @property {Array<VideoCodec>} video
 */
function filterOutMediaStreamIds(sdp) {
    return sdp.replace(/a=msid:[^ ]+ /g, 'a=msid:- ');
}
/**
 * Whether an RTCRtpTransceiver can be recycled.
 * @param {RTCRtpTransceiver} transceiver
 * @returns {boolean}
 */
function shouldRecycleTransceiver(transceiver, pcv2) {
    return !transceiver.stopped
        && !pcv2._replaceTrackPromises.has(transceiver)
        && ['inactive', 'recvonly'].includes(transceiver.direction);
}
/**
 * Take a recycled RTCRtpTransceiver if available.
 * @param {PeerConnectionV2} pcv2
 * @param {Track.Kind} kind
 * @returns {?RTCRtpTransceiver}
 */
function takeRecycledTransceiver(pcv2, kind) {
    var preferredCodecs = {
        audio: pcv2._preferredAudioCodecs.map(function (_a) {
            var codec = _a.codec;
            return codec.toLowerCase();
        }),
        video: pcv2._preferredVideoCodecs.map(function (_a) {
            var codec = _a.codec;
            return codec.toLowerCase();
        })
    }[kind];
    var recycledTransceivers = pcv2._recycledTransceivers[kind];
    var localCodec = preferredCodecs.find(function (codec) { return pcv2._localCodecs.has(codec); });
    if (!localCodec) {
        return recycledTransceivers.shift();
    }
    var transceiver = recycledTransceivers.find(function (transceiver) {
        var remoteCodecMap = pcv2._remoteCodecMaps.get(transceiver.mid);
        return remoteCodecMap && remoteCodecMap.has(localCodec);
    });
    if (transceiver) {
        recycledTransceivers.splice(recycledTransceivers.indexOf(transceiver), 1);
    }
    return transceiver;
}
/**
 * Update the set of locally supported {@link Codec}s.
 * @param pcv2
 * @returns {void}
 */
function updateLocalCodecs(pcv2) {
    var description = pcv2._peerConnection.localDescription;
    if (!description) {
        return;
    }
    getMediaSections(description.sdp).forEach(function (section) {
        var codecMap = createCodecMapForMediaSection(section);
        codecMap.forEach(function (pts, codec) { return pcv2._localCodecs.add(codec); });
    });
}
/**
 * Update the {@link Codec} maps for all m= sections in the remote {@link RTCSessionDescription}s.
 * @param {PeerConnectionV2} pcv2
 * @returns {void}
 */
function updateRemoteCodecMaps(pcv2) {
    var description = pcv2._peerConnection.remoteDescription;
    if (!description) {
        return;
    }
    getMediaSections(description.sdp).forEach(function (section) {
        var mid = section.match(/^a=mid:(.+)$/m)[1];
        var codecMap = createCodecMapForMediaSection(section);
        pcv2._remoteCodecMaps.set(mid, codecMap);
    });
}
/**
 * Update the list of recycled RTCRtpTransceivers.
 * @param {PeerConnectionV2} pcv2
 */
function updateRecycledTransceivers(pcv2) {
    pcv2._recycledTransceivers.audio = [];
    pcv2._recycledTransceivers.video = [];
    pcv2._peerConnection.getTransceivers().forEach(function (transceiver) {
        if (shouldRecycleTransceiver(transceiver, pcv2)) {
            var track = transceiver.receiver.track;
            pcv2._recycledTransceivers[track.kind].push(transceiver);
        }
    });
}
/**
 * Perform certain updates after an SDP negotiation is completed.
 * @param {PeerConnectionV2} pcv2
 * @returns {void}
 */
function negotiationCompleted(pcv2) {
    if (pcv2._isUnifiedPlan) {
        updateRecycledTransceivers(pcv2);
        updateLocalCodecs(pcv2);
        updateRemoteCodecMaps(pcv2);
    }
    if (pcv2._isRTCRtpSenderParamsSupported) {
        updateEncodingParameters(pcv2);
    }
}
/**
 * Update the RTCRtpEncodingParameters of all active RTCRtpSenders.
 * @param {PeerConnectionV2} pcv2
 * @returns {void}
 */
function updateEncodingParameters(pcv2) {
    var _a = pcv2._encodingParameters, maxAudioBitrate = _a.maxAudioBitrate, maxVideoBitrate = _a.maxVideoBitrate;
    var maxBitrates = new Map([
        ['audio', maxAudioBitrate],
        ['video', maxVideoBitrate]
    ]);
    pcv2._peerConnection.getSenders().filter(function (sender) { return sender.track; }).forEach(function (sender) {
        var maxBitrate = maxBitrates.get(sender.track.kind);
        var params = sender.getParameters();
        if (maxBitrate === null || maxBitrate === 0) {
            removeMaxBitrate(params);
        }
        else if (pcv2._isChromeScreenShareTrack(sender.track)) {
            // NOTE(mpatwardhan): Sometimes (JSDK-2557) chrome does not send any bytes on screen track if MaxBitRate is set on it via setParameters,
            // To workaround this issue we will not apply maxBitrate if the track appears to be a screen share track created by chrome
            pcv2._log.warn("Not setting maxBitrate for " + sender.track.kind + " Track " + sender.track.id + " because it appears to be screen share track: " + sender.track.label);
        }
        else {
            setMaxBitrate(params, maxBitrate);
        }
        if (!isFirefox && pcv2._enableDscp && params.encodings.length > 0) {
            // NOTE(mmalavalli): "networkPriority" is a per-sender property and not
            // a per-encoding-layer property. So, we set the value only on the first
            // encoding layer. Any attempt to set the value on subsequent encoding
            // layers (in the case of simulcast) will result in the Promise returned
            // by RTCRtpSender.setParameters() being rejected.
            params.encodings[0].networkPriority = 'high';
        }
        sender.setParameters(params).catch(function (error) {
            pcv2._log.warn("Error while setting encodings parameters for " + sender.track.kind + " Track " + sender.track.id + ": " + (error.message || error.name));
        });
    });
}
/**
 * Remove maxBitrate from the RTCRtpSendParameters' encodings.
 * @param {RTCRtpSendParameters} params
 * @returns {void}
 */
function removeMaxBitrate(params) {
    if (Array.isArray(params.encodings)) {
        params.encodings.forEach(function (encoding) { return delete encoding.maxBitrate; });
    }
}
/**
 * Set the given maxBitrate in the RTCRtpSendParameters' encodings.
 * @param {RTCRtpSendParameters} params
 * @param {number} maxBitrate
 * @returns {void}
 */
function setMaxBitrate(params, maxBitrate) {
    if (isFirefox) {
        params.encodings = [{ maxBitrate: maxBitrate }];
    }
    else {
        params.encodings.forEach(function (encoding) {
            encoding.maxBitrate = maxBitrate;
        });
    }
}
module.exports = PeerConnectionV2;
//# sourceMappingURL=peerconnection.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/peerconnectionmanager.js":
/*!*****************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/peerconnectionmanager.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var guessBrowser = __webpack_require__(/*! @twilio/webrtc/lib/util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").guessBrowser;
var PeerConnectionV2 = __webpack_require__(/*! ./peerconnection */ "../../work/twilio-video.js/es5/signaling/v2/peerconnection.js");
var MediaTrackSender = __webpack_require__(/*! ../../media/track/sender */ "../../work/twilio-video.js/es5/media/track/sender.js");
var QueueingEventEmitter = __webpack_require__(/*! ../../queueingeventemitter */ "../../work/twilio-video.js/es5/queueingeventemitter.js");
var util = __webpack_require__(/*! ../../util */ "../../work/twilio-video.js/es5/util/index.js");
var MediaConnectionError = __webpack_require__(/*! ../../util/twilio-video-errors */ "../../work/twilio-video.js/es5/util/twilio-video-errors.js").MediaConnectionError;
var isFirefox = guessBrowser() === 'firefox';
/**
 * {@link PeerConnectionManager} manages multiple {@link PeerConnectionV2}s.
 * @extends QueueingEventEmitter
 * @emits PeerConnectionManager#candidates
 * @emits PeerConnectionManager#connectionStateChanged
 * @emits PeerConnectionManager#description
 * @emits PeerConnectionManager#iceConnectionStateChanged
 * @emits PeerConnectionManager#trackAdded
 */
var PeerConnectionManager = /** @class */ (function (_super) {
    __extends(PeerConnectionManager, _super);
    /**
     * Construct {@link PeerConnectionManager}.
     * @param {EncodingParametersImpl} encodingParameters
     * @param {PreferredCodecs} preferredCodecs
     * @param {object} options
     */
    function PeerConnectionManager(encodingParameters, preferredCodecs, options) {
        var _this = _super.call(this) || this;
        options = Object.assign({
            audioContextFactory: isFirefox
                ? __webpack_require__(/*! ../../webaudio/audiocontext */ "../../work/twilio-video.js/es5/webaudio/audiocontext.js")
                : null,
            PeerConnectionV2: PeerConnectionV2
        }, options);
        var audioContext = options.audioContextFactory
            ? options.audioContextFactory.getOrCreate(_this)
            : null;
        // NOTE(mroberts): If we're using an AudioContext, we don't need to specify
        // `offerToReceiveAudio` in RTCOfferOptions.
        var offerOptions = audioContext
            ? { offerToReceiveVideo: true }
            : { offerToReceiveAudio: true, offerToReceiveVideo: true };
        Object.defineProperties(_this, {
            _audioContextFactory: {
                value: options.audioContextFactory
            },
            _closedPeerConnectionIds: {
                value: new Set()
            },
            _configuration: {
                writable: true,
                value: null
            },
            _configurationDeferred: {
                writable: true,
                value: util.defer()
            },
            _connectionState: {
                value: 'new',
                writable: true
            },
            _dummyAudioTrackSender: {
                value: audioContext
                    ? new MediaTrackSender(createDummyAudioMediaStreamTrack(audioContext))
                    : null
            },
            _encodingParameters: {
                value: encodingParameters
            },
            _iceConnectionState: {
                writable: true,
                value: 'new'
            },
            _dataTrackSenders: {
                writable: true,
                value: new Set()
            },
            _lastConnectionState: {
                value: 'new',
                writable: true
            },
            _lastIceConnectionState: {
                writable: true,
                value: 'new'
            },
            _mediaTrackSenders: {
                writable: true,
                value: new Set()
            },
            _offerOptions: {
                value: offerOptions
            },
            _peerConnections: {
                value: new Map()
            },
            _preferredCodecs: {
                value: preferredCodecs
            },
            _sessionTimeout: {
                value: null,
                writable: true
            },
            _PeerConnectionV2: {
                value: options.PeerConnectionV2
            }
        });
        return _this;
    }
    Object.defineProperty(PeerConnectionManager.prototype, "connectionState", {
        /**
         * A summarized RTCPeerConnectionState across all the
         * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.
         * @property {RTCPeerConnectionState}
         */
        get: function () {
            return this._connectionState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PeerConnectionManager.prototype, "iceConnectionState", {
        /**
         * A summarized RTCIceConnectionState across all the
         * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.
         * @property {RTCIceConnectionState}
         */
        get: function () {
            return this._iceConnectionState;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Close the {@link PeerConnectionV2}s which are no longer relevant.
     * @param {Array<object>} peerConnectionStates
     * @returns {this}
     */
    PeerConnectionManager.prototype._closeAbsentPeerConnections = function (peerConnectionStates) {
        var peerConnectionIds = new Set(peerConnectionStates.map(function (peerConnectionState) { return peerConnectionState.id; }));
        this._peerConnections.forEach(function (peerConnection) {
            if (!peerConnectionIds.has(peerConnection.id)) {
                peerConnection._close();
            }
        });
        return this;
    };
    /**
     * Get the {@link PeerConnectionManager}'s configuration.
     * @private
     * @returns {Promise<object>}
     */
    PeerConnectionManager.prototype._getConfiguration = function () {
        return this._configurationDeferred.promise;
    };
    /**
     * Get or create a {@link PeerConnectionV2}.
     * @private
     * @param {string} id
     * @param {object} [configuration]
     * @returns {PeerConnectionV2}
     */
    PeerConnectionManager.prototype._getOrCreate = function (id, configuration) {
        var _this = this;
        var self = this;
        var peerConnection = this._peerConnections.get(id);
        if (!peerConnection) {
            var PeerConnectionV2_1 = this._PeerConnectionV2;
            var options = Object.assign({
                dummyAudioMediaStreamTrack: this._dummyAudioTrackSender
                    ? this._dummyAudioTrackSender.track
                    : null,
                offerOptions: this._offerOptions
            }, this._sessionTimeout ? {
                sessionTimeout: this._sessionTimeout
            } : {}, configuration);
            try {
                peerConnection = new PeerConnectionV2_1(id, this._encodingParameters, this._preferredCodecs, options);
            }
            catch (e) {
                throw new MediaConnectionError();
            }
            this._peerConnections.set(peerConnection.id, peerConnection);
            peerConnection.on('candidates', this.queue.bind(this, 'candidates'));
            peerConnection.on('description', this.queue.bind(this, 'description'));
            peerConnection.on('trackAdded', this.queue.bind(this, 'trackAdded'));
            peerConnection.on('stateChanged', function stateChanged(state) {
                if (state === 'closed') {
                    peerConnection.removeListener('stateChanged', stateChanged);
                    self._dataTrackSenders.forEach(function (sender) { return peerConnection.removeDataTrackSender(sender); });
                    self._mediaTrackSenders.forEach(function (sender) { return peerConnection.removeMediaTrackSender(sender); });
                    self._peerConnections.delete(peerConnection.id);
                    self._closedPeerConnectionIds.add(peerConnection.id);
                    updateConnectionState(self);
                    updateIceConnectionState(self);
                }
            });
            peerConnection.on('connectionStateChanged', function () { return updateConnectionState(_this); });
            peerConnection.on('iceConnectionStateChanged', function () { return updateIceConnectionState(_this); });
            this._dataTrackSenders.forEach(peerConnection.addDataTrackSender, peerConnection);
            this._mediaTrackSenders.forEach(peerConnection.addMediaTrackSender, peerConnection);
            updateIceConnectionState(this);
        }
        return peerConnection;
    };
    /**
     * Close all the {@link PeerConnectionV2}s in this {@link PeerConnectionManager}.
     * @returns {this}
     */
    PeerConnectionManager.prototype.close = function () {
        this._peerConnections.forEach(function (peerConnection) {
            peerConnection.close();
        });
        if (this._dummyAudioTrackSender) {
            this._dummyAudioTrackSender.stop();
        }
        if (this._audioContextFactory) {
            this._audioContextFactory.release(this);
        }
        updateIceConnectionState(this);
        return this;
    };
    /**
     * Create a new {@link PeerConnectionV2} on this {@link PeerConnectionManager}.
     * Then, create a new offer with the newly-created {@link PeerConnectionV2}.
     * @return {Promise<this>}
     */
    PeerConnectionManager.prototype.createAndOffer = function () {
        var _this = this;
        return this._getConfiguration().then(function (configuration) {
            var id;
            do {
                id = util.makeUUID();
            } while (_this._peerConnections.has(id));
            return _this._getOrCreate(id, configuration);
        }).then(function (peerConnection) {
            return peerConnection.offer();
        }).then(function () {
            return _this;
        });
    };
    /**
     * Get the {@link DataTrackReceiver}s and {@link MediaTrackReceiver}s of all
     * the {@link PeerConnectionV2}s.
     * @returns {Array<DataTrackReceiver|MediaTrackReceiver>} trackReceivers
     */
    PeerConnectionManager.prototype.getTrackReceivers = function () {
        return util.flatMap(this._peerConnections, function (peerConnection) { return peerConnection.getTrackReceivers(); });
    };
    /**
     * Get the states of all {@link PeerConnectionV2}s.
     * @returns {Array<object>}
     */
    PeerConnectionManager.prototype.getStates = function () {
        var peerConnectionStates = [];
        this._peerConnections.forEach(function (peerConnection) {
            var peerConnectionState = peerConnection.getState();
            if (peerConnectionState) {
                peerConnectionStates.push(peerConnectionState);
            }
        });
        return peerConnectionStates;
    };
    /**
     * Set the {@link PeerConnectionManager}'s configuration.
     * @param {object} configuration
     * @returns {this}
     */
    PeerConnectionManager.prototype.setConfiguration = function (configuration) {
        if (this._configuration) {
            this._configurationDeferred = util.defer();
            this._peerConnections.forEach(function (peerConnection) {
                peerConnection.setConfiguration(configuration);
            });
        }
        this._configuration = configuration;
        this._configurationDeferred.resolve(configuration);
        return this;
    };
    /**
     * Set the ICE reconnect timeout period for all {@link PeerConnectionV2}s.
     * @param {number} period - Period in milliseconds.
     * @returns {this}
     */
    PeerConnectionManager.prototype.setIceReconnectTimeout = function (period) {
        if (this._sessionTimeout === null) {
            this._peerConnections.forEach(function (peerConnection) {
                peerConnection.setIceReconnectTimeout(period);
            });
            this._sessionTimeout = period;
        }
        return this;
    };
    /**
     * Set the {@link DataTrackSender}s and {@link MediaTrackSender}s on the
     * {@link PeerConnectionManager}'s underlying {@link PeerConnectionV2}s.
     * @param {Array<DataTrackSender|MediaTrackSender>} trackSenders
     * @returns {this}
     */
    PeerConnectionManager.prototype.setTrackSenders = function (trackSenders) {
        var dataTrackSenders = new Set(trackSenders.filter(function (trackSender) { return trackSender.kind === 'data'; }));
        var mediaTrackSenders = new Set(trackSenders
            .filter(function (trackSender) { return trackSender && (trackSender.kind === 'audio' || trackSender.kind === 'video'); }));
        var changes = getTrackSenderChanges(this, dataTrackSenders, mediaTrackSenders);
        this._dataTrackSenders = dataTrackSenders;
        this._mediaTrackSenders = mediaTrackSenders;
        applyTrackSenderChanges(this, changes);
        return this;
    };
    /**
     * Update the {@link PeerConnectionManager}.
     * @param {Array<object>} peerConnectionStates
     * @param {boolean} [synced=false]
     * @returns {Promise<this>}
     */
    PeerConnectionManager.prototype.update = function (peerConnectionStates, synced) {
        var _this = this;
        if (synced === void 0) { synced = false; }
        if (synced) {
            this._closeAbsentPeerConnections(peerConnectionStates);
        }
        return this._getConfiguration().then(function (configuration) {
            return Promise.all(peerConnectionStates.map(function (peerConnectionState) {
                if (_this._closedPeerConnectionIds.has(peerConnectionState.id)) {
                    return null;
                }
                var peerConnection = _this._getOrCreate(peerConnectionState.id, configuration);
                return peerConnection.update(peerConnectionState);
            }));
        }).then(function () {
            return _this;
        });
    };
    /**
     * Get the {@link PeerConnectionManager}'s media statistics.
     * @returns {Promise.<Map<PeerConnectionV2#id, StandardizedStatsResponse>>}
     */
    PeerConnectionManager.prototype.getStats = function () {
        var peerConnections = Array.from(this._peerConnections.values());
        return Promise.all(peerConnections.map(function (peerConnection) { return peerConnection.getStats().then(function (response) { return [
            peerConnection.id,
            response
        ]; }); })).then(function (responses) { return new Map(responses); });
    };
    return PeerConnectionManager;
}(QueueingEventEmitter));
/**
 * Create a dummy audio MediaStreamTrack with the given AudioContext.
 * @private
 * @param {AudioContext} audioContext
 * @return {MediaStreamTrack}
 */
function createDummyAudioMediaStreamTrack(audioContext) {
    var mediaStreamDestination = audioContext.createMediaStreamDestination();
    return mediaStreamDestination.stream.getAudioTracks()[0];
}
/**
 * @event {PeerConnectionManager#candidates}
 * @param {object} candidates
 */
/**
 * @event {PeerConnectionManager#connectionStateChanged}
 */
/**
 * @event {PeerConnectionManager#description}
 * @param {object} description
 */
/**
 * @event {PeerConnectionManager#iceConnectionStateChanged}
 */
/**
 * @event {PeerConnectionManager#trackAdded}
 * @param {MediaStreamTrack|DataTrackReceiver} mediaStreamTrackOrDataTrackReceiver
 */
/**
 * Apply {@link TrackSenderChanges}.
 * @param {PeerConnectionManager} peerConnectionManager
 * @param {TrackSenderChanges} changes
 * @returns {void}
 */
function applyTrackSenderChanges(peerConnectionManager, changes) {
    if (changes.data.add.size
        || changes.data.remove.size
        || changes.media.add.size
        || changes.media.remove.size) {
        peerConnectionManager._peerConnections.forEach(function (peerConnection) {
            changes.data.remove.forEach(peerConnection.removeDataTrackSender, peerConnection);
            changes.media.remove.forEach(peerConnection.removeMediaTrackSender, peerConnection);
            changes.data.add.forEach(peerConnection.addDataTrackSender, peerConnection);
            changes.media.add.forEach(peerConnection.addMediaTrackSender, peerConnection);
            if (changes.media.add.size
                || changes.media.remove.size
                || (changes.data.add.size && !peerConnection.isApplicationSectionNegotiated)) {
                peerConnection.offer();
            }
        });
    }
}
/**
 * @interface DataTrackSenderChanges
 * @property {Set<DataTrackSender>} add
 * @property {Set<DataTrackSender>} remove
 */
/**
 * Get the {@Link DataTrackSender} changes.
 * @param {PeerConnectionManager} peerConnectionManager
 * @param {Array<DataTrackSender>} dataTrackSenders
 * @returns {DataTrackSenderChanges} changes
 */
function getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders) {
    var dataTrackSendersToAdd = util.difference(dataTrackSenders, peerConnectionManager._dataTrackSenders);
    var dataTrackSendersToRemove = util.difference(peerConnectionManager._dataTrackSenders, dataTrackSenders);
    return {
        add: dataTrackSendersToAdd,
        remove: dataTrackSendersToRemove
    };
}
/**
 * @interface TrackSenderChanges
 * @property {DataTrackSenderChanges} data
 * @property {MediaTrackSenderChanges} media
 */
/**
 * Get {@link DataTrackSender} and {@link MediaTrackSender} changes.
 * @param {PeerConnectionManager} peerConnectionManager
 * @param {Array<DataTrackSender>} dataTrackSenders
 * @param {Array<MediaTrackSender>} mediaTrackSenders
 * @returns {TrackSenderChanges} changes
 */
function getTrackSenderChanges(peerConnectionManager, dataTrackSenders, mediaTrackSenders) {
    return {
        data: getDataTrackSenderChanges(peerConnectionManager, dataTrackSenders),
        media: getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders)
    };
}
/**
 * @interface MediaTrackSenderChanges
 * @property {Set<MediaTrackSender>} add
 * @property {Set<MediaTrackSender>} remove
 */
/**
 * Get the {@link MediaTrackSender} changes.
 * @param {PeerConnectionManager} peerConnectionManager
 * @param {Array<MediaTrackSender>} mediaTrackSenders
 * @returns {MediaTrackSenderChanges} changes
 */
function getMediaTrackSenderChanges(peerConnectionManager, mediaTrackSenders) {
    var mediaTrackSendersToAdd = util.difference(mediaTrackSenders, peerConnectionManager._mediaTrackSenders);
    var mediaTrackSendersToRemove = util.difference(peerConnectionManager._mediaTrackSenders, mediaTrackSenders);
    return {
        add: mediaTrackSendersToAdd,
        remove: mediaTrackSendersToRemove
    };
}
/**
 * This object maps RTCIceConnectionState and RTCPeerConnectionState values to a "rank".
 */
var toRank = {
    new: 0,
    checking: 1,
    connecting: 2,
    connected: 3,
    completed: 4,
    disconnected: -1,
    failed: -2,
    closed: -3
};
/**
 * This object maps "rank" back to RTCIceConnectionState or RTCPeerConnectionState values.
 */
var fromRank;
/**
 * `Object.keys` is not supported in older browsers, so we can't just
 * synchronously call it in this module; we need to defer invoking it until we
 * know we're in a modern environment (i.e., anything that supports WebRTC).
 * @returns {object} fromRank
 */
function createFromRank() {
    return Object.keys(toRank).reduce(function (fromRank, state) {
        var _a;
        return Object.assign(fromRank, (_a = {}, _a[toRank[state]] = state, _a));
    }, {});
}
/**
 * Summarize RTCIceConnectionStates or RTCPeerConnectionStates.
 * @param {Array<RTCIceConnectionState>|Array<RTCPeerConnectionState>} states
 * @returns {RTCIceConnectionState|RTCPeerConnectionState} summary
 */
function summarizeIceOrPeerConnectionStates(states) {
    if (!states.length) {
        return 'new';
    }
    fromRank = fromRank || createFromRank();
    return states.reduce(function (state1, state2) {
        return fromRank[Math.max(toRank[state1], toRank[state2])];
    });
}
/**
 * Update the {@link PeerConnectionManager}'s `iceConnectionState`, and emit an
 * "iceConnectionStateChanged" event, if necessary.
 * @param {PeerConnectionManager} pcm
 * @returns {void}
 */
function updateIceConnectionState(pcm) {
    pcm._lastIceConnectionState = pcm.iceConnectionState;
    pcm._iceConnectionState = summarizeIceOrPeerConnectionStates(__spreadArray([], __read(pcm._peerConnections.values())).map(function (pcv2) { return pcv2.iceConnectionState; }));
    if (pcm.iceConnectionState !== pcm._lastIceConnectionState) {
        pcm.emit('iceConnectionStateChanged');
    }
}
/**
 * Update the {@link PeerConnectionManager}'s `connectionState`, and emit a
 * "connectionStateChanged" event, if necessary.
 * @param {PeerConnectionManager} pcm
 * @returns {void}
 */
function updateConnectionState(pcm) {
    pcm._lastConnectionState = pcm.connectionState;
    pcm._connectionState = summarizeIceOrPeerConnectionStates(__spreadArray([], __read(pcm._peerConnections.values())).map(function (pcv2) { return pcv2.connectionState; }));
    if (pcm.connectionState !== pcm._lastConnectionState) {
        pcm.emit('connectionStateChanged');
    }
}
module.exports = PeerConnectionManager;
//# sourceMappingURL=peerconnectionmanager.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/publisherhintsignaling.js":
/*!******************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/publisherhintsignaling.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint callback-return:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaSignaling = __webpack_require__(/*! ./mediasignaling */ "../../work/twilio-video.js/es5/signaling/v2/mediasignaling.js");
var PublisherHintsSignaling = /** @class */ (function (_super) {
    __extends(PublisherHintsSignaling, _super);
    /**
     * Construct a {@link RenderHintsSignaling}.
     */
    function PublisherHintsSignaling(getReceiver, options) {
        var _this = _super.call(this, getReceiver, 'publisher_hints', options) || this;
        _this.on('ready', function (transport) {
            _this._log.info('publisher_hints transport ready: ', transport);
            transport.on('message', function (message) {
                _this._log.debug('publisher_hints Incoming: ', message);
                switch (message.type) {
                    case 'publisher_hints':
                        if (message.publisher && message.publisher.hints && message.publisher.id) {
                            _this._processPublisherHints(message.publisher.hints, message.publisher.id);
                        }
                        break;
                    default:
                        _this._log.warn('Unknown message type: ', message.type);
                        break;
                }
            });
        });
        return _this;
    }
    // {
    //   "publisher": {
    //     "hints": [
    //       {
    //         "encodings": [
    //           {
    //             "enabled": true,
    //             "layer_index": 0,
    //             "max_bitrate": 500000,
    //             "max_framerate": 5,
    //             "render_dimensions": {
    //               "height": 180,
    //               "width": 320
    //             }
    //           },
    //           {
    //             "enabled": false,
    //             "layer_index": 1
    //           }
    //         ],
    //         "track": "MT123"
    //       }
    //     ],
    //     "id": 123
    //   },
    //   "type": "publisher_hints"
    // }
    PublisherHintsSignaling.prototype._processPublisherHints = function (hints, id) {
        var _this = this;
        var hintResponses = [];
        try {
            hints.forEach(function (hint) {
                hintResponses.push({
                    track: hint.track,
                    result: 'OK'
                });
                hint.encodings.forEach(function (_a) {
                    var enabled = _a.enabled, layerIndex = _a.layer_index;
                    _this._log.debug(hint.track + " layer:" + layerIndex + ", enabled:" + enabled);
                });
            });
            this.emit('updated', hints);
        }
        catch (ex) {
            this._log.error('error processing hints:', ex);
        }
        // {
        //   "type": "publisher_hints",
        //   "publisher": {
        //     "hints": [
        //       {
        //         "track": "MT123",
        //         "result": "OK"
        //       },
        //       {
        //         "track": "MT456",
        //         "result": "INVALID_PUBLISHER_HINT"
        //       },
        //       {
        //         "track": "MT789",
        //         "result": "UNKNOWN_TRACK"
        //       }
        //     ],
        //     "id": 123
        //   }
        // }
        var payLoad = {
            type: 'publisher_hints',
            publisher: { id: id, hints: hints }
        };
        this._transport.publish(payLoad);
    };
    return PublisherHintsSignaling;
}(MediaSignaling));
module.exports = PublisherHintsSignaling;
//# sourceMappingURL=publisherhintsignaling.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/recording.js":
/*!*****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/recording.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RecordingSignaling = __webpack_require__(/*! ../recording */ "../../work/twilio-video.js/es5/signaling/recording.js");
/**
 * @extends RecordingSignaling
 */
var RecordingV2 = /** @class */ (function (_super) {
    __extends(RecordingV2, _super);
    /**
     * Construct a {@link RecordingV2}.
     */
    function RecordingV2() {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _revision: {
                value: 1,
                writable: true
            }
        });
        return _this;
    }
    /**
     * Compare the {@link RecordingV2} to a {@link RecordingV2#Representation}
     * of itself and perform any updates necessary.
     * @param {RecordingV2#Representation} recording
     * @returns {this}
     * @fires RecordingSignaling#updated
     */
    RecordingV2.prototype.update = function (recording) {
        if (recording.revision < this._revision) {
            return this;
        }
        this._revision = recording.revision;
        return this.enable(recording.is_recording);
    };
    return RecordingV2;
}(RecordingSignaling));
/**
 * The Room Signaling Protocol (RSP) representation of a {@link RecordingV2}
 * @typedef {object} RecordingV2#Representation
 * @property {boolean} enabled
 * @property {number} revision
 */
module.exports = RecordingV2;
//# sourceMappingURL=recording.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/remoteparticipant.js":
/*!*************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/remoteparticipant.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteParticipantSignaling = __webpack_require__(/*! ../remoteparticipant */ "../../work/twilio-video.js/es5/signaling/remoteparticipant.js");
var RemoteTrackPublicationV2 = __webpack_require__(/*! ./remotetrackpublication */ "../../work/twilio-video.js/es5/signaling/v2/remotetrackpublication.js");
/**
 * @extends RemoteParticipantSignaling
 * @property {?number} revision
 */
var RemoteParticipantV2 = /** @class */ (function (_super) {
    __extends(RemoteParticipantV2, _super);
    /**
     * Construct a {@link RemoteParticipantV2}.
     * @param {object} participantState
     * @param {function(Track.SID): boolean} getInitialTrackSwitchOffState
     * @param {function(Track.SID, Track.Priority): boolean} setPriority
     * @param {function(Track.SID, ClientRenderHint): Promise<void>} setRenderHint
     * @param {function(Track.SID): void} clearTrackHint
     * @param {object} [options]
     */
    function RemoteParticipantV2(participantState, getInitialTrackSwitchOffState, setPriority, setRenderHint, clearTrackHint, options) {
        var _this = _super.call(this, participantState.sid, participantState.identity) || this;
        options = Object.assign({
            RemoteTrackPublicationV2: RemoteTrackPublicationV2
        }, options);
        Object.defineProperties(_this, {
            _revision: {
                writable: true,
                value: null
            },
            _RemoteTrackPublicationV2: {
                value: options.RemoteTrackPublicationV2
            },
            _getInitialTrackSwitchOffState: {
                value: getInitialTrackSwitchOffState
            },
            updateSubscriberTrackPriority: {
                value: function (trackSid, priority) { return setPriority(trackSid, priority); }
            },
            updateTrackRenderHint: {
                value: function (trackSid, renderHint) { return setRenderHint(trackSid, renderHint); }
            },
            clearTrackHint: {
                value: function (trackSid) { return clearTrackHint(trackSid); }
            },
            revision: {
                enumerable: true,
                get: function () {
                    return this._revision;
                }
            }
        });
        return _this.update(participantState);
    }
    /**
     * @private
     */
    RemoteParticipantV2.prototype._getOrCreateTrack = function (trackState) {
        var RemoteTrackPublicationV2 = this._RemoteTrackPublicationV2;
        var track = this.tracks.get(trackState.sid);
        if (!track) {
            var isSwitchedOff = this._getInitialTrackSwitchOffState(trackState.sid);
            track = new RemoteTrackPublicationV2(trackState, isSwitchedOff);
            this.addTrack(track);
        }
        return track;
    };
    /**
     * Update the {@link RemoteParticipantV2} with the new state.
     * @param {object} participantState
     * @returns {this}
     */
    RemoteParticipantV2.prototype.update = function (participantState) {
        var _this = this;
        if (this.revision !== null && participantState.revision <= this.revision) {
            return this;
        }
        this._revision = participantState.revision;
        var tracksToKeep = new Set();
        participantState.tracks.forEach(function (trackState) {
            var track = _this._getOrCreateTrack(trackState);
            track.update(trackState);
            tracksToKeep.add(track);
        });
        this.tracks.forEach(function (track) {
            if (!tracksToKeep.has(track)) {
                _this.removeTrack(track);
            }
        });
        switch (participantState.state) {
            case 'disconnected':
                this.disconnect();
                break;
            case 'reconnecting':
                this.reconnecting();
                break;
            case 'connected':
                this.connect(this.sid, this.identity);
                break;
        }
        return this;
    };
    return RemoteParticipantV2;
}(RemoteParticipantSignaling));
module.exports = RemoteParticipantV2;
//# sourceMappingURL=remoteparticipant.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/remotetrackpublication.js":
/*!******************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/remotetrackpublication.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteTrackPublicationSignaling = __webpack_require__(/*! ../remotetrackpublication */ "../../work/twilio-video.js/es5/signaling/remotetrackpublication.js");
/**
 * @extends RemoteTrackPublicationSignaling
 */
var RemoteTrackPublicationV2 = /** @class */ (function (_super) {
    __extends(RemoteTrackPublicationV2, _super);
    /**
     * Construct a {@link RemoteTrackPublicationV2}.
     * @param {RemoteTrackPublicationV2#Representation} track
     * @param {boolean} isSwitchedOff
     *
     */
    function RemoteTrackPublicationV2(track, isSwitchedOff) {
        return _super.call(this, track.sid, track.name, track.kind, track.enabled, track.priority, isSwitchedOff) || this;
    }
    /**
     * Compare the {@link RemoteTrackPublicationV2} to a
     * {@link RemoteTrackPublicationV2#Representation} of itself and perform any
     * updates necessary.
     * @param {RemoteTrackPublicationV2#Representation} track
     * @returns {this}
     * @fires TrackSignaling#updated
     */
    RemoteTrackPublicationV2.prototype.update = function (track) {
        this.enable(track.enabled);
        this.setPriority(track.priority);
        return this;
    };
    return RemoteTrackPublicationV2;
}(RemoteTrackPublicationSignaling));
/**
 * The Room Signaling Protocol (RSP) representation of a {@link RemoteTrackPublicationV2}.
 * @typedef {LocalTrackPublicationV2#Representation} RemoteTrackPublicationV2#Representation
 * @property {boolean} subscribed
 */
module.exports = RemoteTrackPublicationV2;
//# sourceMappingURL=remotetrackpublication.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/renderhintssignaling.js":
/*!****************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/renderhintssignaling.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint callback-return:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaSignaling = __webpack_require__(/*! ./mediasignaling */ "../../work/twilio-video.js/es5/signaling/v2/mediasignaling.js");
var isDeepEqual = __webpack_require__(/*! ../../util */ "../../work/twilio-video.js/es5/util/index.js").isDeepEqual;
var messageId = 1;
var RenderHintsSignaling = /** @class */ (function (_super) {
    __extends(RenderHintsSignaling, _super);
    /**
     * Construct a {@link RenderHintsSignaling}.
     */
    function RenderHintsSignaling(getReceiver, options) {
        var _this = _super.call(this, getReceiver, 'render_hints', options) || this;
        Object.defineProperties(_this, {
            _trackSidsToRenderHints: {
                value: new Map()
            },
            _isResponsePending: {
                value: false,
                writable: true,
            }
        });
        _this.on('ready', function (transport) {
            transport.on('message', function (message) {
                _this._log.debug('Incoming: ', message);
                switch (message.type) {
                    case 'render_hints':
                        _this._processHintResults((message && message.subscriber && message.subscriber.hints) || []);
                        break;
                    default:
                        _this._log.warn('Unknown message type: ', message.type);
                        break;
                }
            });
            // NOTE(mpatwardhan): When transport is set (either 1st time of after vms failover)
            // resend all track states. For this simply mark all tracks as dirty.
            Array.from(_this._trackSidsToRenderHints.keys()).forEach(function (trackSid) {
                var trackState = _this._trackSidsToRenderHints.get(trackSid);
                if (trackState.renderDimensions) {
                    trackState.isDimensionDirty = true;
                }
                if ('enabled' in trackState) {
                    trackState.isEnabledDirty = true;
                }
            });
            _this._sendHints();
        });
        return _this;
    }
    RenderHintsSignaling.prototype._processHintResults = function (hintResults) {
        var _this = this;
        this._isResponsePending = false;
        hintResults.forEach(function (hintResult) {
            if (hintResult.result !== 'OK') {
                _this._log.debug('Server error processing hint:', hintResult);
            }
        });
        this._sendHints();
    };
    RenderHintsSignaling.prototype._sendHints = function () {
        var _this = this;
        if (!this._transport || this._isResponsePending) {
            return;
        }
        var hints = [];
        Array.from(this._trackSidsToRenderHints.keys()).forEach(function (trackSid) {
            var trackState = _this._trackSidsToRenderHints.get(trackSid);
            if (trackState.isEnabledDirty || trackState.isDimensionDirty) {
                var mspHint = {
                    'track': trackSid,
                };
                if (trackState.isEnabledDirty) {
                    mspHint.enabled = trackState.enabled;
                    trackState.isEnabledDirty = false;
                }
                if (trackState.isDimensionDirty) {
                    // eslint-disable-next-line camelcase
                    mspHint.render_dimensions = trackState.renderDimensions;
                    trackState.isDimensionDirty = false;
                }
                hints.push(mspHint);
            }
        });
        if (hints.length > 0) {
            var payLoad = {
                type: 'render_hints',
                subscriber: {
                    id: messageId++,
                    hints: hints
                }
            };
            this._log.debug('Outgoing: ', payLoad);
            this._transport.publish(payLoad);
            this._isResponsePending = true;
        }
    };
    /**
     * @param {Track.SID} trackSid
     * @param {ClientRenderHint} renderHint
     */
    RenderHintsSignaling.prototype.setTrackHint = function (trackSid, renderHint) {
        var trackState = this._trackSidsToRenderHints.get(trackSid) || { isEnabledDirty: false, isDimensionDirty: false };
        if ('enabled' in renderHint && trackState.enabled !== renderHint.enabled) {
            trackState.enabled = !!renderHint.enabled;
            trackState.isEnabledDirty = true;
        }
        if (renderHint.renderDimensions && !isDeepEqual(renderHint.renderDimensions, trackState.renderDimensions)) {
            // eslint-disable-next-line camelcase
            trackState.renderDimensions = renderHint.renderDimensions;
            trackState.isDimensionDirty = true;
        }
        this._trackSidsToRenderHints.set(trackSid, trackState);
        this._sendHints();
    };
    /**
     * must be called when track is unsubscribed.
     * @param {Track.SID} trackSid
     */
    RenderHintsSignaling.prototype.clearTrackHint = function (trackSid) {
        this._trackSidsToRenderHints.delete(trackSid);
    };
    return RenderHintsSignaling;
}(MediaSignaling));
module.exports = RenderHintsSignaling;
//# sourceMappingURL=renderhintssignaling.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/room.js":
/*!************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/room.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable no-console */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var DominantSpeakerSignaling = __webpack_require__(/*! ./dominantspeakersignaling */ "../../work/twilio-video.js/es5/signaling/v2/dominantspeakersignaling.js");
var NetworkQualityMonitor = __webpack_require__(/*! ./networkqualitymonitor */ "../../work/twilio-video.js/es5/signaling/v2/networkqualitymonitor.js");
var NetworkQualitySignaling = __webpack_require__(/*! ./networkqualitysignaling */ "../../work/twilio-video.js/es5/signaling/v2/networkqualitysignaling.js");
var RecordingV2 = __webpack_require__(/*! ./recording */ "../../work/twilio-video.js/es5/signaling/v2/recording.js");
var RoomSignaling = __webpack_require__(/*! ../room */ "../../work/twilio-video.js/es5/signaling/room.js");
var RemoteParticipantV2 = __webpack_require__(/*! ./remoteparticipant */ "../../work/twilio-video.js/es5/signaling/v2/remoteparticipant.js");
var StatsReport = __webpack_require__(/*! ../../stats/statsreport */ "../../work/twilio-video.js/es5/stats/statsreport.js");
var TrackPrioritySignaling = __webpack_require__(/*! ./trackprioritysignaling */ "../../work/twilio-video.js/es5/signaling/v2/trackprioritysignaling.js");
var TrackSwitchOffSignaling = __webpack_require__(/*! ./trackswitchoffsignaling */ "../../work/twilio-video.js/es5/signaling/v2/trackswitchoffsignaling.js");
var RenderHintsSignaling = __webpack_require__(/*! ./renderhintssignaling */ "../../work/twilio-video.js/es5/signaling/v2/renderhintssignaling.js");
var PublisherHintsSignaling = __webpack_require__(/*! ./publisherhintsignaling.js */ "../../work/twilio-video.js/es5/signaling/v2/publisherhintsignaling.js");
var _a = __webpack_require__(/*! ../../util */ "../../work/twilio-video.js/es5/util/index.js"), DEFAULT_SESSION_TIMEOUT_SEC = _a.constants.DEFAULT_SESSION_TIMEOUT_SEC, createBandwidthProfilePayload = _a.createBandwidthProfilePayload, defer = _a.defer, difference = _a.difference, filterObject = _a.filterObject, flatMap = _a.flatMap, oncePerTick = _a.oncePerTick;
var MovingAverageDelta = __webpack_require__(/*! ../../util/movingaveragedelta */ "../../work/twilio-video.js/es5/util/movingaveragedelta.js");
var createTwilioError = __webpack_require__(/*! ../../util/twilio-video-errors */ "../../work/twilio-video.js/es5/util/twilio-video-errors.js").createTwilioError;
var STATS_PUBLISH_INTERVAL_MS = 10000;
/**
 * @extends RoomSignaling
 */
var RoomV2 = /** @class */ (function (_super) {
    __extends(RoomV2, _super);
    function RoomV2(localParticipant, initialState, transport, peerConnectionManager, options) {
        var _this = this;
        initialState.options = Object.assign({
            session_timeout: DEFAULT_SESSION_TIMEOUT_SEC
        }, initialState.options);
        options = Object.assign({
            DominantSpeakerSignaling: DominantSpeakerSignaling,
            NetworkQualityMonitor: NetworkQualityMonitor,
            NetworkQualitySignaling: NetworkQualitySignaling,
            RecordingSignaling: RecordingV2,
            RemoteParticipantV2: RemoteParticipantV2,
            TrackPrioritySignaling: TrackPrioritySignaling,
            TrackSwitchOffSignaling: TrackSwitchOffSignaling,
            bandwidthProfile: null,
            sessionTimeout: initialState.options.session_timeout * 1000,
            statsPublishIntervalMs: STATS_PUBLISH_INTERVAL_MS
        }, options);
        localParticipant.setBandwidthProfile(options.bandwidthProfile);
        peerConnectionManager.setIceReconnectTimeout(options.sessionTimeout);
        _this = _super.call(this, localParticipant, initialState.sid, initialState.name, options) || this;
        var getTrackReceiver = function (id) { return _this._getTrackReceiver(id); };
        var log = _this._log;
        Object.defineProperties(_this, {
            _disconnectedParticipantRevisions: {
                value: new Map()
            },
            _NetworkQualityMonitor: {
                value: options.NetworkQualityMonitor
            },
            _lastBandwidthProfileRevision: {
                value: localParticipant.bandwidthProfileRevision,
                writable: true
            },
            _networkQualityMonitor: {
                value: null,
                writable: true
            },
            _networkQualityConfiguration: {
                value: localParticipant.networkQualityConfiguration
            },
            _peerConnectionManager: {
                value: peerConnectionManager
            },
            _published: {
                value: new Map()
            },
            _publishedRevision: {
                value: 0,
                writable: true
            },
            _RemoteParticipantV2: {
                value: options.RemoteParticipantV2
            },
            _subscribed: {
                value: new Map()
            },
            _subscribedRevision: {
                value: 0,
                writable: true
            },
            _subscriptionFailures: {
                value: new Map()
            },
            _dominantSpeakerSignaling: {
                value: new options.DominantSpeakerSignaling(getTrackReceiver, { log: log })
            },
            _networkQualitySignaling: {
                value: new options.NetworkQualitySignaling(getTrackReceiver, localParticipant.networkQualityConfiguration, { log: log })
            },
            _renderHintsSignaling: {
                value: new RenderHintsSignaling(getTrackReceiver, { log: log }),
            },
            _publisherHintsSignaling: {
                value: new PublisherHintsSignaling(getTrackReceiver, { log: log }),
            },
            _trackPrioritySignaling: {
                value: new options.TrackPrioritySignaling(getTrackReceiver, { log: log }),
            },
            _trackSwitchOffSignaling: {
                value: new options.TrackSwitchOffSignaling(getTrackReceiver, { log: log }),
            },
            _pendingSwitchOffStates: {
                value: new Map()
            },
            _transport: {
                value: transport
            },
            _trackReceiverDeferreds: {
                value: new Map()
            },
            mediaRegion: {
                enumerable: true,
                value: initialState.options.media_region || null
            }
        });
        _this._initTrackSwitchOffSignaling();
        _this._initDominantSpeakerSignaling();
        _this._initNetworkQualityMonitorSignaling();
        _this._initPublisherHintSignaling();
        handleLocalParticipantEvents(_this, localParticipant);
        handlePeerConnectionEvents(_this, peerConnectionManager);
        handleTransportEvents(_this, transport);
        periodicallyPublishStats(_this, transport, options.statsPublishIntervalMs);
        _this._update(initialState);
        return _this;
    }
    Object.defineProperty(RoomV2.prototype, "connectionState", {
        /**
         * The PeerConnection state.
         * @property {RTCPeerConnectionState}
         */
        get: function () {
            return this._peerConnectionManager.connectionState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RoomV2.prototype, "signalingConnectionState", {
        /**
         * The Signaling Connection State.
         * @property {string} - "connected", "reconnecting", "disconnected"
         */
        get: function () {
            return this._transport.state === 'syncing'
                ? 'reconnecting'
                : this._transport.state;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RoomV2.prototype, "iceConnectionState", {
        /**
         * The Ice Connection State.
         * @property {RTCIceConnectionState}
         */
        get: function () {
            return this._peerConnectionManager.iceConnectionState;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @private
     */
    RoomV2.prototype._deleteTrackReceiverDeferred = function (id) {
        return this._trackReceiverDeferreds.delete(id);
    };
    /**
     * @private
     */
    RoomV2.prototype._getOrCreateTrackReceiverDeferred = function (id) {
        var deferred = this._trackReceiverDeferreds.get(id) || defer();
        var trackReceivers = this._peerConnectionManager.getTrackReceivers();
        // NOTE(mmalavalli): In Firefox, there can be instances where a MediaStreamTrack
        // for the given Track ID already exists, for example, when a Track is removed
        // and added back. If that is the case, then we should resolve 'deferred'.
        var trackReceiver = trackReceivers.find(function (trackReceiver) { return trackReceiver.id === id && trackReceiver.readyState !== 'ended'; });
        if (trackReceiver) {
            deferred.resolve(trackReceiver);
        }
        else {
            // NOTE(mmalavalli): Only add the 'deferred' to the map if it's not
            // resolved. This will prevent old copies of the MediaStreamTrack from
            // being used when the remote peer removes and re-adds a MediaStreamTrack.
            this._trackReceiverDeferreds.set(id, deferred);
        }
        return deferred;
    };
    /**
     * @private
     */
    RoomV2.prototype._addTrackReceiver = function (trackReceiver) {
        var deferred = this._getOrCreateTrackReceiverDeferred(trackReceiver.id);
        deferred.resolve(trackReceiver);
        return this;
    };
    /**
     * @private
     */
    RoomV2.prototype._disconnect = function (error) {
        var didDisconnect = _super.prototype._disconnect.call(this, error);
        if (didDisconnect) {
            this._teardownNetworkQualityMonitor();
            this._transport.disconnect();
            this._peerConnectionManager.close();
        }
        this.localParticipant.tracks.forEach(function (track) {
            track.publishFailed(error || new Error('LocalParticipant disconnected'));
        });
        return didDisconnect;
    };
    /**
     * @private
     */
    RoomV2.prototype._getTrackReceiver = function (id) {
        var _this = this;
        return this._getOrCreateTrackReceiverDeferred(id).promise.then(function (trackReceiver) {
            _this._deleteTrackReceiverDeferred(id);
            return trackReceiver;
        });
    };
    /**
     * @private
     */
    RoomV2.prototype._getInitialTrackSwitchOffState = function (trackSid) {
        var initiallySwitchedOff = this._pendingSwitchOffStates.get(trackSid) || false;
        this._pendingSwitchOffStates.delete(trackSid);
        if (initiallySwitchedOff) {
            this._log.warn("[" + trackSid + "] was initially switched off! ");
        }
        return initiallySwitchedOff;
    };
    /**
     * @private
     */
    RoomV2.prototype._getTrackSidsToTrackSignalings = function () {
        var trackSidsToTrackSignalings = flatMap(this.participants, function (participant) { return Array.from(participant.tracks); });
        return new Map(trackSidsToTrackSignalings);
    };
    /**
     * @private
     */
    RoomV2.prototype._getOrCreateRemoteParticipant = function (participantState) {
        var _this = this;
        var RemoteParticipantV2 = this._RemoteParticipantV2;
        var participant = this.participants.get(participantState.sid);
        var self = this;
        if (!participant) {
            participant = new RemoteParticipantV2(participantState, function (trackSid) { return _this._getInitialTrackSwitchOffState(trackSid); }, function (trackSid, priority) { return _this._trackPrioritySignaling.sendTrackPriorityUpdate(trackSid, 'subscribe', priority); }, function (trackSid, hint) { return _this._renderHintsSignaling.setTrackHint(trackSid, hint); }, function (trackSid) { return _this._renderHintsSignaling.clearTrackHint(trackSid); });
            participant.on('stateChanged', function stateChanged(state) {
                if (state === 'disconnected') {
                    participant.removeListener('stateChanged', stateChanged);
                    self.participants.delete(participant.sid);
                    self._disconnectedParticipantRevisions.set(participant.sid, participant.revision);
                }
            });
            this.connectParticipant(participant);
        }
        return participant;
    };
    /**
     * @private
     */
    RoomV2.prototype._getState = function () {
        return {
            participant: this.localParticipant.getState()
        };
    };
    /**
     * @private
     */
    RoomV2.prototype._maybeAddBandwidthProfile = function (update) {
        var _a = this.localParticipant, bandwidthProfile = _a.bandwidthProfile, bandwidthProfileRevision = _a.bandwidthProfileRevision;
        if (bandwidthProfile && this._lastBandwidthProfileRevision < bandwidthProfileRevision) {
            this._lastBandwidthProfileRevision = bandwidthProfileRevision;
            return Object.assign({
                bandwidth_profile: createBandwidthProfilePayload(bandwidthProfile)
            }, update);
        }
        return update;
    };
    /**
     * @private
     */
    RoomV2.prototype._publishNewLocalParticipantState = function () {
        this._transport.publish(this._maybeAddBandwidthProfile(this._getState()));
    };
    /**
     * @private
     */
    RoomV2.prototype._publishPeerConnectionState = function (peerConnectionState) {
        /* eslint camelcase:0 */
        this._transport.publish(Object.assign({
            peer_connections: [peerConnectionState]
        }, this._getState()));
    };
    /**
     * @private
     */
    RoomV2.prototype._update = function (roomState) {
        var _this = this;
        if (roomState.subscribed && roomState.subscribed.revision > this._subscribedRevision) {
            this._subscribedRevision = roomState.subscribed.revision;
            roomState.subscribed.tracks.forEach(function (trackState) {
                if (trackState.id) {
                    _this._subscriptionFailures.delete(trackState.sid);
                    _this._subscribed.set(trackState.sid, trackState.id);
                }
                else if (trackState.error && !_this._subscriptionFailures.has(trackState.sid)) {
                    _this._subscriptionFailures.set(trackState.sid, trackState.error);
                }
            });
            var subscribedTrackSids_1 = new Set(roomState.subscribed.tracks
                .filter(function (trackState) { return !!trackState.id; })
                .map(function (trackState) { return trackState.sid; }));
            this._subscribed.forEach(function (trackId, trackSid) {
                if (!subscribedTrackSids_1.has(trackSid)) {
                    _this._subscribed.delete(trackSid);
                }
            });
        }
        var participantsToKeep = new Set();
        // eslint-disable-next-line no-warning-comments
        // TODO(mroberts): Remove me once the Server is fixed.
        (roomState.participants || []).forEach(function (participantState) {
            if (participantState.sid === _this.localParticipant.sid) {
                return;
            }
            // NOTE(mmalavalli): If the incoming revision for a disconnected Participant is less than or
            // equal to the revision when it was disconnected, then the state is old and can be ignored.
            // Otherwise, the Participant was most likely disconnected in a Large Group Room when it
            // stopped publishing media, and hence needs to be re-added.
            var disconnectedParticipantRevision = _this._disconnectedParticipantRevisions.get(participantState.sid);
            if (disconnectedParticipantRevision && participantState.revision <= disconnectedParticipantRevision) {
                return;
            }
            if (disconnectedParticipantRevision) {
                _this._disconnectedParticipantRevisions.delete(participantState.sid);
            }
            var participant = _this._getOrCreateRemoteParticipant(participantState);
            participant.update(participantState);
            participantsToKeep.add(participant);
        });
        if (roomState.type === 'synced') {
            this.participants.forEach(function (participant) {
                if (!participantsToKeep.has(participant)) {
                    participant.disconnect();
                }
            });
        }
        handleSubscriptions(this);
        // eslint-disable-next-line no-warning-comments
        // TODO(mroberts): Remove me once the Server is fixed.
        /* eslint camelcase:0 */
        if (roomState.peer_connections) {
            this._peerConnectionManager.update(roomState.peer_connections, roomState.type === 'synced');
        }
        if (roomState.recording) {
            this.recording.update(roomState.recording);
        }
        if (roomState.published && roomState.published.revision > this._publishedRevision) {
            this._publishedRevision = roomState.published.revision;
            roomState.published.tracks.forEach(function (track) {
                if (track.sid) {
                    _this._published.set(track.id, track.sid);
                }
            });
            this.localParticipant.update(roomState.published);
        }
        if (roomState.participant) {
            this.localParticipant.connect(roomState.participant.sid, roomState.participant.identity);
        }
        [
            this._dominantSpeakerSignaling,
            this._networkQualitySignaling,
            this._trackPrioritySignaling,
            this._trackSwitchOffSignaling,
            this._renderHintsSignaling,
            this._publisherHintsSignaling
        ].forEach(function (mediaSignaling) {
            var channel = mediaSignaling.channel;
            if (!mediaSignaling.isSetup
                && roomState.media_signaling
                && roomState.media_signaling[channel]
                && roomState.media_signaling[channel].transport
                && roomState.media_signaling[channel].transport.type === 'data-channel') {
                mediaSignaling.setup(roomState.media_signaling[channel].transport.label);
            }
        });
        return this;
    };
    RoomV2.prototype._initPublisherHintSignaling = function () {
        var _this = this;
        this._publisherHintsSignaling.on('updated', function (hints) {
            try {
                _this.localParticipant.setPublisherHints(hints);
            }
            catch (ex) {
                _this._log.error('_initPublisherHintSignaling failed to setPublisherHints: ', ex);
            }
        });
    };
    RoomV2.prototype._initTrackSwitchOffSignaling = function () {
        var _this = this;
        this._trackSwitchOffSignaling.on('updated', function (tracksOff, tracksOn) {
            try {
                _this._log.debug('received trackSwitch: ', { tracksOn: tracksOn, tracksOff: tracksOff });
                var trackUpdates_1 = new Map();
                tracksOn.forEach(function (trackSid) { return trackUpdates_1.set(trackSid, true); });
                tracksOff.forEach(function (trackSid) {
                    if (trackUpdates_1.get(trackSid)) {
                        // NOTE(mpatwardhan): This means that VIDEO-3762 has been reproduced.
                        _this._log.warn(trackSid + " is DUPLICATED in both tracksOff and tracksOn list");
                    }
                    trackUpdates_1.set(trackSid, false);
                });
                _this.participants.forEach(function (participant) {
                    participant.tracks.forEach(function (track) {
                        var isOn = trackUpdates_1.get(track.sid);
                        if (typeof isOn !== 'undefined') {
                            track.setSwitchedOff(!isOn);
                            trackUpdates_1.delete(track.sid);
                        }
                    });
                });
                // NOTE(mpatwardhan): Cache any notification about the tracks that we do not yet know about.
                trackUpdates_1.forEach(function (isOn, trackSid) { return _this._pendingSwitchOffStates.set(trackSid, !isOn); });
            }
            catch (ex) {
                _this._log.error('error processing track switch off:', ex);
            }
        });
    };
    RoomV2.prototype._initDominantSpeakerSignaling = function () {
        var _this = this;
        this._dominantSpeakerSignaling.on('updated', function () { return _this.setDominantSpeaker(_this._dominantSpeakerSignaling.loudestParticipantSid); });
    };
    RoomV2.prototype._initNetworkQualityMonitorSignaling = function () {
        var _this = this;
        this._networkQualitySignaling.on('ready', function () {
            var networkQualityMonitor = new _this._NetworkQualityMonitor(_this._peerConnectionManager, _this._networkQualitySignaling);
            _this._networkQualityMonitor = networkQualityMonitor;
            networkQualityMonitor.on('updated', function () {
                if (_this.iceConnectionState === 'failed') {
                    return;
                }
                _this.localParticipant.setNetworkQualityLevel(networkQualityMonitor.level, networkQualityMonitor.levels);
                _this.participants.forEach(function (participant) {
                    var levels = networkQualityMonitor.remoteLevels.get(participant.sid);
                    if (levels) {
                        participant.setNetworkQualityLevel(levels.level, levels);
                    }
                });
            });
            networkQualityMonitor.start();
        });
        this._networkQualitySignaling.on('teardown', function () { return _this._teardownNetworkQualityMonitor(); });
    };
    RoomV2.prototype._teardownNetworkQualityMonitor = function () {
        if (this._networkQualityMonitor) {
            this._networkQualityMonitor.stop();
            this._networkQualityMonitor = null;
        }
    };
    /**
     * Get the {@link RoomV2}'s media statistics.
     * @returns {Promise.<Map<PeerConnectionV2#id, StandardizedStatsResponse>>}
     */
    RoomV2.prototype.getStats = function () {
        var _this = this;
        return this._peerConnectionManager.getStats().then(function (responses) {
            return new Map(Array.from(responses).map(function (_a) {
                var _b = __read(_a, 2), id = _b[0], response = _b[1];
                return [id, Object.assign({}, response, {
                        localAudioTrackStats: filterAndAddLocalTrackSids(_this, response.localAudioTrackStats),
                        localVideoTrackStats: filterAndAddLocalTrackSids(_this, response.localVideoTrackStats),
                        remoteAudioTrackStats: filterAndAddRemoteTrackSids(_this, response.remoteAudioTrackStats),
                        remoteVideoTrackStats: filterAndAddRemoteTrackSids(_this, response.remoteVideoTrackStats)
                    })];
            }));
        });
    };
    return RoomV2;
}(RoomSignaling));
/**
 * Filter out {@link TrackStats} that aren't in the collection while also
 * stamping their Track SIDs.
 * @param {Map<ID, SID>} idToSid
 * @param {Array<TrackStats>} trackStats
 * @returns {Array<TrackStats>}
 */
function filterAndAddTrackSids(idToSid, trackStats) {
    return trackStats.reduce(function (trackStats, trackStat) {
        var trackSid = idToSid.get(trackStat.trackId);
        return trackSid
            ? [Object.assign({}, trackStat, { trackSid: trackSid })].concat(trackStats)
            : trackStats;
    }, []);
}
/**
 * Filter out {@link LocalTrackStats} that aren't currently published while also
 * stamping their Track SIDs.
 * @param {RoomV2} roomV2
 * @param {Array<LocalTrackStats>} localTrackStats
 * @returns {Array<LocalTrackStats>}
 */
function filterAndAddLocalTrackSids(roomV2, localTrackStats) {
    return filterAndAddTrackSids(roomV2._published, localTrackStats);
}
/**
 * Filter out {@link RemoteTrackStats} that aren't currently subscribed while
 * also stamping their Track SIDs.
 * @param {RoomV2} roomV2
 * @param {Array<RemoteTrackStats>} remoteTrackStats
 * @returns {Array<RemoteTrackStats>}
 */
function filterAndAddRemoteTrackSids(roomV2, remoteTrackStats) {
    var idToSid = new Map(Array.from(roomV2._subscribed.entries()).map(function (_a) {
        var _b = __read(_a, 2), sid = _b[0], id = _b[1];
        return [id, sid];
    }));
    return filterAndAddTrackSids(idToSid, remoteTrackStats);
}
/**
 * @typedef {object} RoomV2#Representation
 * @property {string} name
 * @property {LocalParticipantV2#Representation} participant
 * @property {?Array<RemoteParticipantV2#Representation>} participants
 * @property {?Array<PeerConnectionV2#Representation>} peer_connections
 * @property {?RecordingV2#Representation} recording
 * @property {string} sid
 */
function handleLocalParticipantEvents(roomV2, localParticipant) {
    var localParticipantUpdated = oncePerTick(function () {
        roomV2._publishNewLocalParticipantState();
    });
    var renegotiate = oncePerTick(function () {
        var trackSenders = flatMap(localParticipant.tracks, function (trackV2) { return trackV2.trackTransceiver; });
        roomV2._peerConnectionManager.setTrackSenders(trackSenders);
    });
    localParticipant.on('trackAdded', renegotiate);
    localParticipant.on('trackRemoved', renegotiate);
    localParticipant.on('updated', localParticipantUpdated);
    roomV2.on('stateChanged', function stateChanged(state) {
        if (state === 'disconnected') {
            localParticipant.removeListener('trackAdded', renegotiate);
            localParticipant.removeListener('trackRemoved', renegotiate);
            localParticipant.removeListener('updated', localParticipantUpdated);
            roomV2.removeListener('stateChanged', stateChanged);
            localParticipant.disconnect();
        }
    });
    roomV2.on('signalingConnectionStateChanged', function () {
        var localParticipant = roomV2.localParticipant, signalingConnectionState = roomV2.signalingConnectionState;
        var identity = localParticipant.identity, sid = localParticipant.sid;
        switch (signalingConnectionState) {
            case 'connected':
                localParticipant.connect(sid, identity);
                break;
            case 'reconnecting':
                localParticipant.reconnecting();
                break;
        }
    });
}
function handlePeerConnectionEvents(roomV2, peerConnectionManager) {
    peerConnectionManager.on('description', function onDescription(description) {
        roomV2._publishPeerConnectionState(description);
    });
    peerConnectionManager.dequeue('description');
    peerConnectionManager.on('candidates', function onCandidates(candidates) {
        roomV2._publishPeerConnectionState(candidates);
    });
    peerConnectionManager.dequeue('candidates');
    peerConnectionManager.on('trackAdded', roomV2._addTrackReceiver.bind(roomV2));
    peerConnectionManager.dequeue('trackAdded');
    peerConnectionManager.getTrackReceivers().forEach(roomV2._addTrackReceiver, roomV2);
    peerConnectionManager.on('connectionStateChanged', function () {
        roomV2.emit('connectionStateChanged');
    });
    peerConnectionManager.on('iceConnectionStateChanged', function () {
        roomV2.emit('iceConnectionStateChanged');
        if (roomV2.iceConnectionState === 'failed') {
            if (roomV2.localParticipant.networkQualityLevel !== null) {
                roomV2.localParticipant.setNetworkQualityLevel(0);
            }
            roomV2.participants.forEach(function (participant) {
                if (participant.networkQualityLevel !== null) {
                    participant.setNetworkQualityLevel(0);
                }
            });
        }
    });
}
function handleTransportEvents(roomV2, transport) {
    transport.on('message', roomV2._update.bind(roomV2));
    transport.on('stateChanged', function stateChanged(state, error) {
        if (state === 'disconnected') {
            if (roomV2.state !== 'disconnected') {
                roomV2._disconnect(error);
            }
            transport.removeListener('stateChanged', stateChanged);
        }
        roomV2.emit('signalingConnectionStateChanged');
    });
}
/**
 * Periodically publish {@link StatsReport}s.
 * @private
 * @param {RoomV2} roomV2
 * @param {Transport} transport
 * @param {Number} intervalMs
 */
function periodicallyPublishStats(roomV2, transport, intervalMs) {
    var movingAverageDeltas = new Map();
    var oddPublishCount = false;
    var interval = setInterval(function () {
        roomV2.getStats().then(function (stats) {
            oddPublishCount = !oddPublishCount;
            stats.forEach(function (response, id) {
                // NOTE(mmalavalli): A StatsReport is used to publish a "stats-report"
                // event instead of using StandardizedStatsResponse directly because
                // StatsReport will add zeros to properties that do not exist.
                var report = new StatsReport(id, response, true /* prepareForInsights */);
                // NOTE(mmalavalli): Since A/V sync metrics are not part of the StatsReport class,
                // we add them to the insights payload here.
                transport.publishEvent('quality', 'stats-report', 'info', {
                    audioTrackStats: report.remoteAudioTrackStats.map(function (trackStat, i) {
                        return addAVSyncMetricsToRemoteTrackStats(trackStat, response.remoteAudioTrackStats[i], movingAverageDeltas);
                    }),
                    localAudioTrackStats: report.localAudioTrackStats.map(function (trackStat, i) {
                        return addAVSyncMetricsToLocalTrackStats(trackStat, response.localAudioTrackStats[i], movingAverageDeltas);
                    }),
                    localVideoTrackStats: report.localVideoTrackStats.map(function (trackStat, i) {
                        return addAVSyncMetricsToLocalTrackStats(trackStat, response.localVideoTrackStats[i], movingAverageDeltas);
                    }),
                    peerConnectionId: report.peerConnectionId,
                    videoTrackStats: report.remoteVideoTrackStats.map(function (trackStat, i) {
                        return addAVSyncMetricsToRemoteTrackStats(trackStat, response.remoteVideoTrackStats[i], movingAverageDeltas);
                    }),
                });
                // NOTE(mmalavalli): Clean up entries for Tracks that are no longer published or subscribed to.
                var keys = flatMap([
                    'localAudioTrackStats',
                    'localVideoTrackStats',
                    'remoteAudioTrackStats',
                    'remoteVideoTrackStats'
                ], function (prop) { return report[prop].map(function (_a) {
                    var ssrc = _a.ssrc, trackSid = _a.trackSid;
                    return trackSid + "+" + ssrc;
                }); });
                var movingAverageDeltaKeysToBeRemoved = difference(Array.from(movingAverageDeltas.keys()), keys);
                movingAverageDeltaKeysToBeRemoved.forEach(function (key) { return movingAverageDeltas.delete(key); });
                if (oddPublishCount) {
                    // NOTE(mmalavalli): null properties of the "active-ice-candidate-pair"
                    // payload are assigned default values until the Insights gateway
                    // accepts null values.
                    var activeIceCandidatePair = replaceNullsWithDefaults(response.activeIceCandidatePair, report.peerConnectionId);
                    transport.publishEvent('quality', 'active-ice-candidate-pair', 'info', activeIceCandidatePair);
                }
            });
        }, function () {
            // Do nothing.
        });
    }, intervalMs);
    roomV2.on('stateChanged', function onStateChanged(state) {
        if (state === 'disconnected') {
            clearInterval(interval);
            roomV2.removeListener('stateChanged', onStateChanged);
        }
    });
}
function handleSubscriptions(room) {
    var trackSidsToTrackSignalings = room._getTrackSidsToTrackSignalings();
    room._subscriptionFailures.forEach(function (error, trackSid) {
        var trackSignaling = trackSidsToTrackSignalings.get(trackSid);
        if (trackSignaling) {
            room._subscriptionFailures.delete(trackSid);
            trackSignaling.subscribeFailed(createTwilioError(error.code, error.message));
        }
    });
    trackSidsToTrackSignalings.forEach(function (trackSignaling) {
        var trackId = room._subscribed.get(trackSignaling.sid);
        if (!trackId || (trackSignaling.isSubscribed && trackSignaling.trackTransceiver.id !== trackId)) {
            trackSignaling.setTrackTransceiver(null);
        }
        if (trackId) {
            room._getTrackReceiver(trackId).then(function (trackReceiver) { return trackSignaling.setTrackTransceiver(trackReceiver); });
        }
    });
}
/**
 * NOTE(mmalavalli): Since A/V sync metrics are not part of the public StatsReport class, we add them
 * only for reporting purposes.
 * @private
 */
function addAVSyncMetricsToLocalTrackStats(trackStats, trackResponse, movingAverageDeltas) {
    var framesEncoded = trackResponse.framesEncoded, packetsSent = trackResponse.packetsSent, totalEncodeTime = trackResponse.totalEncodeTime, totalPacketSendDelay = trackResponse.totalPacketSendDelay;
    var augmentedTrackStats = Object.assign({}, trackStats);
    var key = trackStats.trackSid + "+" + trackStats.ssrc;
    var trackMovingAverageDeltas = movingAverageDeltas.get(key) || new Map();
    if (typeof totalEncodeTime === 'number' && typeof framesEncoded === 'number') {
        var trackAvgEncodeDelayMovingAverageDelta = trackMovingAverageDeltas.get('avgEncodeDelay')
            || new MovingAverageDelta();
        trackAvgEncodeDelayMovingAverageDelta.putSample(totalEncodeTime * 1000, framesEncoded);
        augmentedTrackStats.avgEncodeDelay = Math.round(trackAvgEncodeDelayMovingAverageDelta.get());
        trackMovingAverageDeltas.set('avgEncodeDelay', trackAvgEncodeDelayMovingAverageDelta);
    }
    if (typeof totalPacketSendDelay === 'number' && typeof packetsSent === 'number') {
        var trackAvgPacketSendDelayMovingAverageDelta = trackMovingAverageDeltas.get('avgPacketSendDelay')
            || new MovingAverageDelta();
        trackAvgPacketSendDelayMovingAverageDelta.putSample(totalPacketSendDelay * 1000, packetsSent);
        augmentedTrackStats.avgPacketSendDelay = Math.round(trackAvgPacketSendDelayMovingAverageDelta.get());
        trackMovingAverageDeltas.set('avgPacketSendDelay', trackAvgPacketSendDelayMovingAverageDelta);
    }
    movingAverageDeltas.set(key, trackMovingAverageDeltas);
    return augmentedTrackStats;
}
/**
 * NOTE(mmalavalli): Since A/V sync metrics are not part of the public StatsReport class, we add them
 * only for reporting purposes.
 * @private
 */
function addAVSyncMetricsToRemoteTrackStats(trackStats, trackResponse, movingAverageDeltas) {
    var estimatedPlayoutTimestamp = trackResponse.estimatedPlayoutTimestamp, framesDecoded = trackResponse.framesDecoded, jitterBufferDelay = trackResponse.jitterBufferDelay, jitterBufferEmittedCount = trackResponse.jitterBufferEmittedCount, totalDecodeTime = trackResponse.totalDecodeTime;
    var augmentedTrackStats = Object.assign({}, trackStats);
    var key = trackStats.trackSid + "+" + trackStats.ssrc;
    var trackMovingAverageDeltas = movingAverageDeltas.get(key) || new Map();
    if (typeof estimatedPlayoutTimestamp === 'number') {
        augmentedTrackStats.estimatedPlayoutTimestamp = estimatedPlayoutTimestamp;
    }
    if (typeof framesDecoded === 'number' && typeof totalDecodeTime === 'number') {
        var trackAvgDecodeDelayMovingAverageDelta = trackMovingAverageDeltas.get('avgDecodeDelay')
            || new MovingAverageDelta();
        trackAvgDecodeDelayMovingAverageDelta.putSample(totalDecodeTime * 1000, framesDecoded);
        augmentedTrackStats.avgDecodeDelay = Math.round(trackAvgDecodeDelayMovingAverageDelta.get());
        trackMovingAverageDeltas.set('avgDecodeDelay', trackAvgDecodeDelayMovingAverageDelta);
    }
    if (typeof jitterBufferDelay === 'number' && typeof jitterBufferEmittedCount === 'number') {
        var trackAvgJitterBufferDelayMovingAverageDelta = trackMovingAverageDeltas.get('avgJitterBufferDelay')
            || new MovingAverageDelta();
        trackAvgJitterBufferDelayMovingAverageDelta.putSample(jitterBufferDelay * 1000, jitterBufferEmittedCount);
        augmentedTrackStats.avgJitterBufferDelay = Math.round(trackAvgJitterBufferDelayMovingAverageDelta.get());
        trackMovingAverageDeltas.set('avgJitterBufferDelay', trackAvgJitterBufferDelayMovingAverageDelta);
    }
    movingAverageDeltas.set(key, trackMovingAverageDeltas);
    return augmentedTrackStats;
}
function replaceNullsWithDefaults(activeIceCandidatePair, peerConnectionId) {
    activeIceCandidatePair = Object.assign({
        availableIncomingBitrate: 0,
        availableOutgoingBitrate: 0,
        bytesReceived: 0,
        bytesSent: 0,
        consentRequestsSent: 0,
        currentRoundTripTime: 0,
        lastPacketReceivedTimestamp: 0,
        lastPacketSentTimestamp: 0,
        nominated: false,
        peerConnectionId: peerConnectionId,
        priority: 0,
        readable: false,
        requestsReceived: 0,
        requestsSent: 0,
        responsesReceived: 0,
        responsesSent: 0,
        retransmissionsReceived: 0,
        retransmissionsSent: 0,
        state: 'failed',
        totalRoundTripTime: 0,
        transportId: '',
        writable: false
    }, filterObject(activeIceCandidatePair || {}, null));
    activeIceCandidatePair.localCandidate = Object.assign({
        candidateType: 'host',
        deleted: false,
        ip: '',
        port: 0,
        priority: 0,
        protocol: 'udp',
        url: ''
    }, filterObject(activeIceCandidatePair.localCandidate || {}, null));
    activeIceCandidatePair.remoteCandidate = Object.assign({
        candidateType: 'host',
        ip: '',
        port: 0,
        priority: 0,
        protocol: 'udp',
        url: ''
    }, filterObject(activeIceCandidatePair.remoteCandidate || {}, null));
    return activeIceCandidatePair;
}
module.exports = RoomV2;
//# sourceMappingURL=room.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/trackprioritysignaling.js":
/*!******************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/trackprioritysignaling.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaSignaling = __webpack_require__(/*! ./mediasignaling */ "../../work/twilio-video.js/es5/signaling/v2/mediasignaling.js");
var TrackPrioritySignaling = /** @class */ (function (_super) {
    __extends(TrackPrioritySignaling, _super);
    /**
     * Construct a {@link TrackPrioritySignaling}.
     * @param {Promise<DataTrackReceiver>} getReceiver
     */
    function TrackPrioritySignaling(getReceiver, options) {
        var _this = _super.call(this, getReceiver, 'track_priority', options) || this;
        Object.defineProperties(_this, {
            _enqueuedPriorityUpdates: {
                value: new Map()
            },
        });
        _this.on('ready', function (transport) {
            Array.from(_this._enqueuedPriorityUpdates.keys()).forEach(function (trackSid) {
                transport.publish({
                    type: 'track_priority',
                    track: trackSid,
                    subscribe: _this._enqueuedPriorityUpdates.get(trackSid)
                });
                // NOTE(mpatwardhan)- we do not clear _enqueuedPriorityUpdates intentionally,
                // this cache will is used to re-send the priorities in case of VMS-FailOver.
            });
        });
        return _this;
    }
    /**
     * @param {Track.SID} trackSid
     * @param {'publish'|'subscribe'} publishOrSubscribe
     * @param {Track.Priority} priority
     */
    TrackPrioritySignaling.prototype.sendTrackPriorityUpdate = function (trackSid, publishOrSubscribe, priority) {
        if (publishOrSubscribe !== 'subscribe') {
            throw new Error('only subscribe priorities are supported, found: ' + publishOrSubscribe);
        }
        this._enqueuedPriorityUpdates.set(trackSid, priority);
        if (this._transport) {
            this._transport.publish({
                type: 'track_priority',
                track: trackSid,
                subscribe: priority
            });
        }
    };
    return TrackPrioritySignaling;
}(MediaSignaling));
module.exports = TrackPrioritySignaling;
//# sourceMappingURL=trackprioritysignaling.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/trackswitchoffsignaling.js":
/*!*******************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/trackswitchoffsignaling.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var MediaSignaling = __webpack_require__(/*! ./mediasignaling */ "../../work/twilio-video.js/es5/signaling/v2/mediasignaling.js");
/**
 * @emits TrackSwitchOffSignalinging#updated
 */
var TrackSwitchOffSignaling = /** @class */ (function (_super) {
    __extends(TrackSwitchOffSignaling, _super);
    /**
     * Construct a {@link TrackSwitchOffSignaling}.
     * @param {Promise<DataTrackReceiver>} getReceiver
     */
    function TrackSwitchOffSignaling(getReceiver, options) {
        var _this = _super.call(this, getReceiver, 'track_switch_off', options) || this;
        _this.on('ready', function (transport) {
            transport.on('message', function (message) {
                switch (message.type) {
                    case 'track_switch_off':
                        _this._setTrackSwitchOffUpdates(message.off || [], message.on || []);
                        break;
                    default:
                        break;
                }
            });
        });
        return _this;
    }
    /**
     * @private
     * @param {[Track.SID]} tracksSwitchedOff
     * @param {[Track.SID]} tracksSwitchedOn
     * @returns {void}
     */
    TrackSwitchOffSignaling.prototype._setTrackSwitchOffUpdates = function (tracksSwitchedOff, tracksSwitchedOn) {
        this.emit('updated', tracksSwitchedOff, tracksSwitchedOn);
    };
    return TrackSwitchOffSignaling;
}(MediaSignaling));
/**
 * @event TrackSwitchOffSignaling#updated
 */
module.exports = TrackSwitchOffSignaling;
//# sourceMappingURL=trackswitchoffsignaling.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/signaling/v2/twilioconnectiontransport.js":
/*!*********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/signaling/v2/twilioconnectiontransport.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var getSdpFormat = __webpack_require__(/*! @twilio/webrtc/lib/util/sdp */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/sdp.js").getSdpFormat;
var packageInfo = __webpack_require__(/*! ../../../package.json */ "../../work/twilio-video.js/package.json");
var InsightsPublisher = __webpack_require__(/*! ../../util/insightspublisher */ "../../work/twilio-video.js/es5/util/insightspublisher/index.js");
var NullInsightsPublisher = __webpack_require__(/*! ../../util/insightspublisher/null */ "../../work/twilio-video.js/es5/util/insightspublisher/null.js");
var StateMachine = __webpack_require__(/*! ../../statemachine */ "../../work/twilio-video.js/es5/statemachine.js");
var TwilioConnection = __webpack_require__(/*! ../../twilioconnection */ "../../work/twilio-video.js/es5/twilioconnection.js");
var DefaultBackoff = __webpack_require__(/*! backoff */ "../../work/twilio-video.js/node_modules/backoff/index.js");
var reconnectBackoffConfig = __webpack_require__(/*! ../../util/constants */ "../../work/twilio-video.js/es5/util/constants.js").reconnectBackoffConfig;
var Timeout = __webpack_require__(/*! ../../util/timeout */ "../../work/twilio-video.js/es5/util/timeout.js");
var _a = __webpack_require__(/*! ../../util */ "../../work/twilio-video.js/es5/util/index.js"), createBandwidthProfilePayload = _a.createBandwidthProfilePayload, createMediaSignalingPayload = _a.createMediaSignalingPayload, createSubscribePayload = _a.createSubscribePayload, getUserAgent = _a.getUserAgent, isNonArrayObject = _a.isNonArrayObject;
var _b = __webpack_require__(/*! ../../util/twilio-video-errors */ "../../work/twilio-video.js/es5/util/twilio-video-errors.js"), createTwilioError = _b.createTwilioError, RoomCompletedError = _b.RoomCompletedError, SignalingConnectionError = _b.SignalingConnectionError, SignalingServerBusyError = _b.SignalingServerBusyError;
var ICE_VERSION = 1;
var RSP_VERSION = 2;
var SDK_NAME = packageInfo.name + ".js";
var SDK_VERSION = packageInfo.version;
/*
TwilioConnectionTransport States
----------------

                      +-----------+
                      |           |
                      |  syncing  |---------+
                      |           |         |
                      +-----------+         |
                         ^     |            |
                         |     |            |
                         |     v            v
    +------------+    +-----------+    +--------------+
    |            |    |           |    |              |
    | connecting |--->| connected |--->| disconnected |
    |            |    |           |    |              |
    +------------+    +-----------+    +--------------+
             |                              ^
             |                              |
             |                              |
             +------------------------------+

*/
var states = {
    connecting: [
        'connected',
        'disconnected'
    ],
    connected: [
        'disconnected',
        'syncing'
    ],
    syncing: [
        'connected',
        'disconnected'
    ],
    disconnected: []
};
/**
 * A {@link TwilioConnectionTransport} supports sending and receiving Room Signaling Protocol
 * (RSP) messages. It also supports RSP requests, such as Sync and Disconnect.
 * @extends StateMachine
 * @emits TwilioConnectionTransport#connected
 * @emits TwilioConnectionTransport#message
 */
var TwilioConnectionTransport = /** @class */ (function (_super) {
    __extends(TwilioConnectionTransport, _super);
    /**
     * Construct a {@link TwilioConnectionTransport}.
     * @param {?string} name
     * @param {string} accessToken
     * @param {ParticipantSignaling} localParticipant
     * @param {PeerConnectionManager} peerConnectionManager
     * @param {string} wsServer
     * @param {object} [options]
     */
    function TwilioConnectionTransport(name, accessToken, localParticipant, peerConnectionManager, wsServer, options) {
        var _this = this;
        options = Object.assign({
            Backoff: DefaultBackoff,
            InsightsPublisher: InsightsPublisher,
            NullInsightsPublisher: NullInsightsPublisher,
            TwilioConnection: TwilioConnection,
            iceServers: null,
            sdpFormat: getSdpFormat(options.sdpSemantics),
            trackPriority: true,
            trackSwitchOff: true,
            renderHints: true,
            userAgent: getUserAgent()
        }, options);
        _this = _super.call(this, 'connecting', states) || this;
        var eventPublisherOptions = {};
        if (options.wsServerInsights) {
            eventPublisherOptions.gateway = options.wsServerInsights;
        }
        var EventPublisher = options.insights ? options.InsightsPublisher : options.NullInsightsPublisher;
        var eventPublisher = new EventPublisher(accessToken, SDK_NAME, SDK_VERSION, options.environment, options.realm, eventPublisherOptions);
        Object.defineProperties(_this, {
            _accessToken: {
                value: accessToken
            },
            _automaticSubscription: {
                value: options.automaticSubscription
            },
            _bandwidthProfile: {
                value: options.bandwidthProfile
            },
            _disconnectEventPublisher: {
                value: function () { return eventPublisher.disconnect(); }
            },
            _dominantSpeaker: {
                value: options.dominantSpeaker
            },
            _eventObserver: {
                value: options.eventObserver,
                writable: false
            },
            _renderHints: {
                value: options.renderHints
            },
            _iceServersStatus: {
                value: Array.isArray(options.iceServers)
                    ? 'overrode'
                    : 'acquire'
            },
            _localParticipant: {
                value: localParticipant
            },
            _name: {
                value: name,
            },
            _networkQuality: {
                value: isNonArrayObject(options.networkQuality) || options.networkQuality
            },
            _options: {
                value: options
            },
            _peerConnectionManager: {
                value: peerConnectionManager
            },
            _sessionTimer: {
                value: null,
                writable: true
            },
            _sessionTimeoutMS: {
                value: 0,
                writable: true
            },
            _reconnectBackoff: {
                value: options.Backoff.exponential(reconnectBackoffConfig)
            },
            _session: {
                value: null,
                writable: true
            },
            _trackPriority: {
                value: options.trackPriority
            },
            _trackSwitchOff: {
                value: options.trackSwitchOff
            },
            _twilioConnection: {
                value: null,
                writable: true
            },
            _updatesReceived: {
                value: []
            },
            _updatesToSend: {
                value: []
            },
            _userAgent: {
                value: options.userAgent
            },
            _wsServer: {
                value: wsServer
            }
        });
        // eslint-disable-next-line no-warning-comments
        // TODO(mmalavalli): Create and set EventPublisher outside this class, so
        // that the EventPublisher constructor is no longer a dependency.
        _this._eventObserver.setPublisher(eventPublisher);
        setupTransport(_this);
        _this.once('connected', function (_a) {
            var sid = _a.sid, participant = _a.participant;
            eventPublisher.connect(sid, participant.sid);
        });
        return _this;
    }
    /**
     * Create a Connect, Sync or Disconnect RSP message.
     * @private
     * @returns {?object}
     */
    TwilioConnectionTransport.prototype._createConnectOrSyncOrDisconnectMessage = function () {
        if (this.state === 'connected') {
            return null;
        }
        if (this.state === 'disconnected') {
            return {
                session: this._session,
                type: 'disconnect',
                version: RSP_VERSION
            };
        }
        var type = {
            connecting: 'connect',
            syncing: 'sync'
        }[this.state];
        var message = {
            name: this._name,
            participant: this._localParticipant.getState(),
            peer_connections: this._peerConnectionManager.getStates(),
            type: type,
            version: RSP_VERSION
        };
        if (message.type === 'connect') {
            message.ice_servers = this._iceServersStatus;
            message.publisher = {
                name: SDK_NAME,
                sdk_version: SDK_VERSION,
                user_agent: this._userAgent
            };
            if (this._bandwidthProfile) {
                message.bandwidth_profile = createBandwidthProfilePayload(this._bandwidthProfile);
            }
            message.media_signaling = createMediaSignalingPayload(this._dominantSpeaker, this._networkQuality, this._trackPriority, this._trackSwitchOff, this._renderHints);
            message.subscribe = createSubscribePayload(this._automaticSubscription);
            var sdpFormat = this._options.sdpFormat;
            if (sdpFormat) {
                message.format = sdpFormat;
            }
            message.token = this._accessToken;
        }
        else if (message.type === 'sync') {
            message.session = this._session;
            message.token = this._accessToken;
        }
        else if (message.type === 'update') {
            message.session = this._session;
        }
        return message;
    };
    /**
     * Create an "ice" message.
     * @private
     */
    TwilioConnectionTransport.prototype._createIceMessage = function () {
        return {
            edge: 'roaming',
            token: this._accessToken,
            type: 'ice',
            version: ICE_VERSION
        };
    };
    /**
     * Send a Connect, Sync or Disconnect RSP message.
     * @private
     */
    TwilioConnectionTransport.prototype._sendConnectOrSyncOrDisconnectMessage = function () {
        var message = this._createConnectOrSyncOrDisconnectMessage();
        if (message) {
            this._twilioConnection.sendMessage(message);
        }
    };
    /**
     * Disconnect the {@link TwilioConnectionTransport}. Returns true if calling the method resulted
     * in disconnection.
     * @param {TwilioError} [error]
     * @returns {boolean}
     */
    TwilioConnectionTransport.prototype.disconnect = function (error) {
        if (this.state !== 'disconnected') {
            this.preempt('disconnected', null, [error]);
            this._sendConnectOrSyncOrDisconnectMessage();
            this._twilioConnection.close();
            this._disconnectEventPublisher();
            return true;
        }
        return false;
    };
    /**
     * Publish an RSP Update. Returns true if calling the method resulted in
     * publishing (or eventually publishing) the update.
     * @param {object} update
     * @returns {boolean}
     */
    TwilioConnectionTransport.prototype.publish = function (update) {
        switch (this.state) {
            case 'connected':
                this._twilioConnection.sendMessage(Object.assign({
                    session: this._session,
                    type: 'update',
                    version: RSP_VERSION
                }, update));
                return true;
            case 'connecting':
            case 'syncing':
                this._updatesToSend.push(update);
                return true;
            case 'disconnected':
            default:
                return false;
        }
    };
    /**
     * Publish (or queue) an event to the Insights gateway.
     * @param {string} group - Event group name
     * @param {string} name - Event name
     * @param {string} level - Event level
     * @param {object} payload - Event payload
     * @returns {void}
     */
    TwilioConnectionTransport.prototype.publishEvent = function (group, name, level, payload) {
        this._eventObserver.emit('event', { group: group, name: name, level: level, payload: payload });
    };
    /**
     * Sync the {@link TwilioConnectionTransport}. Returns true if calling the method resulted in
     * syncing.
     * @returns {boolean}
     */
    TwilioConnectionTransport.prototype.sync = function () {
        if (this.state === 'connected') {
            this.preempt('syncing');
            this._sendConnectOrSyncOrDisconnectMessage();
            return true;
        }
        return false;
    };
    /**
     * @private
     * @returns {void}
     */
    TwilioConnectionTransport.prototype._setSession = function (session, sessionTimeout) {
        this._session = session;
        this._sessionTimeoutMS = sessionTimeout * 1000;
    };
    /**
     * Determines if we should attempt reconnect.
     * returns a Promise to wait on before attempting to
     * reconnect. returns null if its not okay to reconnect.
     * @private
     * @returns {Promise<void>}
     */
    TwilioConnectionTransport.prototype._getReconnectTimer = function () {
        var _this = this;
        if (this._sessionTimeoutMS === 0) {
            // this means either we have never connected.
            // or we timed out while trying to reconnect
            // In either case we do not want to reconnect.
            return null;
        }
        // start session timer
        if (!this._sessionTimer) {
            this._sessionTimer = new Timeout(function () {
                // ensure that _clearReconnectTimer wasn't
                // called while we were waiting.
                if (_this._sessionTimer) {
                    // do not allow any more reconnect attempts.
                    _this._sessionTimeoutMS = 0;
                }
            }, this._sessionTimeoutMS);
        }
        // return promise that waits with exponential backoff.
        return new Promise(function (resolve) {
            _this._reconnectBackoff.once('ready', resolve);
            _this._reconnectBackoff.backoff();
        });
    };
    /**
     * clears the session reconnect timer.
     *
     * @private
     * @returns {void}
     */
    TwilioConnectionTransport.prototype._clearReconnectTimer = function () {
        this._reconnectBackoff.reset();
        if (this._sessionTimer) {
            this._sessionTimer.clear();
            this._sessionTimer = null;
        }
    };
    return TwilioConnectionTransport;
}(StateMachine));
/**
 * @event TwilioConnectionTransport#connected
 * @param {object} initialState
 */
/**
 * @event TwilioConnectionTransport#message
 * @param {object} peerConnections
 */
function reducePeerConnections(peerConnections) {
    return Array.from(peerConnections.reduce(function (peerConnectionsById, update) {
        var reduced = peerConnectionsById.get(update.id) || update;
        // First, reduce the top-level `description` property.
        if (!reduced.description && update.description) {
            reduced.description = update.description;
        }
        else if (reduced.description && update.description) {
            if (update.description.revision > reduced.description.revision) {
                reduced.description = update.description;
            }
        }
        // Then, reduce the top-level `ice` property.
        if (!reduced.ice && update.ice) {
            reduced.ice = update.ice;
        }
        else if (reduced.ice && update.ice) {
            if (update.ice.revision > reduced.ice.revision) {
                reduced.ice = update.ice;
            }
        }
        // Finally, update the map.
        peerConnectionsById.set(reduced.id, reduced);
        return peerConnectionsById;
    }, new Map()).values());
}
function reduceUpdates(updates) {
    return updates.reduce(function (reduced, update) {
        // First, reduce the top-level `participant` property.
        if (!reduced.participant && update.participant) {
            reduced.participant = update.participant;
        }
        else if (reduced.participant && update.participant) {
            if (update.participant.revision > reduced.participant.revision) {
                reduced.participant = update.participant;
            }
        }
        // Then, reduce the top-level `peer_connections` property.
        /* eslint camelcase:0 */
        if (!reduced.peer_connections && update.peer_connections) {
            reduced.peer_connections = reducePeerConnections(update.peer_connections);
        }
        else if (reduced.peer_connections && update.peer_connections) {
            reduced.peer_connections = reducePeerConnections(reduced.peer_connections.concat(update.peer_connections));
        }
        return reduced;
    }, {});
}
function setupTransport(transport) {
    function createOrResetTwilioConnection() {
        if (transport.state === 'disconnected') {
            return;
        }
        if (transport._twilioConnection) {
            transport._twilioConnection.removeListener('message', handleMessage);
        }
        var _iceServersStatus = transport._iceServersStatus, _options = transport._options, _wsServer = transport._wsServer, state = transport.state;
        var TwilioConnection = _options.TwilioConnection;
        var twilioConnection = new TwilioConnection(_wsServer, Object.assign({
            helloBody: state === 'connecting' && _iceServersStatus === 'acquire'
                ? transport._createIceMessage()
                : transport._createConnectOrSyncOrDisconnectMessage()
        }, _options));
        twilioConnection.once('close', function (reason) {
            if (reason === TwilioConnection.CloseReason.LOCAL) {
                disconnect();
            }
            else {
                disconnect(new Error(reason));
            }
        });
        twilioConnection.on('message', handleMessage);
        transport._twilioConnection = twilioConnection;
    }
    function disconnect(error) {
        if (transport.state === 'disconnected') {
            return;
        }
        if (!error) {
            transport.disconnect();
            return;
        }
        var reconnectTimer = transport._getReconnectTimer();
        if (!reconnectTimer) {
            var twilioError = error.message === TwilioConnection.CloseReason.BUSY
                ? new SignalingServerBusyError()
                : new SignalingConnectionError();
            transport.disconnect(twilioError);
            return;
        }
        if (transport.state === 'connected') {
            transport.preempt('syncing');
        }
        reconnectTimer.then(createOrResetTwilioConnection);
    }
    function handleMessage(message) {
        if (transport.state === 'disconnected') {
            return;
        }
        if (message.type === 'error') {
            transport.disconnect(createTwilioError(message.code, message.message));
            return;
        }
        switch (transport.state) {
            case 'connected':
                switch (message.type) {
                    case 'connected':
                    case 'synced':
                    case 'update':
                        transport.emit('message', message);
                        return;
                    case 'disconnected':
                        transport.disconnect(message.status === 'completed'
                            ? new RoomCompletedError()
                            : null);
                        return;
                    default:
                        // Do nothing.
                        return;
                }
            case 'connecting':
                switch (message.type) {
                    case 'iced':
                        transport._options.onIced(message.ice_servers).then(function () {
                            transport._sendConnectOrSyncOrDisconnectMessage();
                        });
                        return;
                    case 'connected':
                        transport._setSession(message.session, message.options.session_timeout);
                        transport.emit('connected', message);
                        transport.preempt('connected');
                        return;
                    case 'synced':
                    case 'update':
                        transport._updatesReceived.push(message);
                        return;
                    case 'disconnected':
                        transport.disconnect(message.status === 'completed'
                            ? new RoomCompletedError()
                            : null);
                        return;
                    default:
                        // Do nothing.
                        return;
                }
            case 'syncing':
                switch (message.type) {
                    case 'connected':
                    case 'update':
                        transport._updatesReceived.push(message);
                        return;
                    case 'synced':
                        transport._clearReconnectTimer();
                        transport.emit('message', message);
                        transport.preempt('connected');
                        return;
                    case 'disconnected':
                        transport.disconnect(message.status === 'completed'
                            ? new RoomCompletedError()
                            : null);
                        return;
                    default:
                        // Do nothing.
                        return;
                }
            default:
                // Impossible
                return;
        }
    }
    transport.on('stateChanged', function stateChanged(state) {
        switch (state) {
            case 'connected': {
                var updates = transport._updatesToSend.splice(0);
                if (updates.length) {
                    transport.publish(reduceUpdates(updates));
                }
                transport._updatesReceived.splice(0).forEach(function (update) { return transport.emit('message', update); });
                return;
            }
            case 'disconnected':
                transport._twilioConnection.removeListener('message', handleMessage);
                transport.removeListener('stateChanged', stateChanged);
                return;
            case 'syncing':
                // Do nothing.
                return;
            default:
                // Impossible
                return;
        }
    });
    var _options = transport._options, _iceServersStatus = transport._iceServersStatus;
    var iceServers = _options.iceServers, onIced = _options.onIced;
    if (_iceServersStatus === 'overrode') {
        onIced(iceServers).then(createOrResetTwilioConnection);
    }
    else {
        createOrResetTwilioConnection();
    }
}
module.exports = TwilioConnectionTransport;
//# sourceMappingURL=twilioconnectiontransport.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/statemachine.js":
/*!*******************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/statemachine.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var util = __webpack_require__(/*! ./util */ "../../work/twilio-video.js/es5/util/index.js");
/**
 * {@link StateMachine} represents a state machine. The state machine supports a
 * reentrant locking mechanism to allow asynchronous state transitions to ensure
 * they have not been preempted. Calls to {@link StateMachine#takeLock} are
 * guaranteed to be resolved in FIFO order.
 * @extends EventEmitter
 * @property {boolean} isLocked - whether or not the {@link StateMachine} is
 *   locked performing asynchronous state transition
 * @property {string} state - the current state
 * @emits {@link StateMachine#stateChanged}
 */
var StateMachine = /** @class */ (function (_super) {
    __extends(StateMachine, _super);
    /**
     * Construct a {@link StateMachine}.
     * @param {string} initialState - the intiial state
     * @param {object} states
     */
    function StateMachine(initialState, states) {
        var _this = _super.call(this) || this;
        var lock = null;
        var state = initialState;
        states = transformStates(states);
        Object.defineProperties(_this, {
            _lock: {
                get: function () {
                    return lock;
                },
                set: function (_lock) {
                    lock = _lock;
                }
            },
            _reachableStates: {
                value: reachable(states)
            },
            _state: {
                get: function () {
                    return state;
                },
                set: function (_state) {
                    state = _state;
                }
            },
            _states: {
                value: states
            },
            _whenDeferreds: {
                value: new Set()
            },
            isLocked: {
                enumerable: true,
                get: function () {
                    return lock !== null;
                }
            },
            state: {
                enumerable: true,
                get: function () {
                    return state;
                }
            }
        });
        _this.on('stateChanged', function (state) {
            _this._whenDeferreds.forEach(function (deferred) {
                deferred.when(state, deferred.resolve, deferred.reject);
            });
        });
        return _this;
    }
    /**
     * Returns a promise whose executor function is called on each state change.
     * @param {function(state: string, resolve: function, reject: function): void} when
     * @returns {Promise.<*>}
     * @private
     */
    StateMachine.prototype._whenPromise = function (when) {
        var _this = this;
        if (typeof when !== 'function') {
            return Promise.reject(new Error('when() executor must be a function'));
        }
        var deferred = util.defer();
        deferred.when = when;
        this._whenDeferreds.add(deferred);
        return deferred.promise.then(function (payload) {
            _this._whenDeferreds.delete(deferred);
            return payload;
        }, function (error) {
            _this._whenDeferreds.delete(deferred);
            throw error;
        });
    };
    /**
     * This method takes a lock and passes the {@link StateMachine#Key} to your
     * transition function. You may perform zero or more state transitions in your
     * transition function, but you should check for preemption in each tick. You
     * may also reenter the lock. Once the Promise returned by your transition
     * function resolves or rejects, this method releases the lock it acquired for
     * you.
     * @param {string} name - a name for the lock
     * @param {function(StateMachine#Key): Promise} transitionFunction
     * @returns {Promise}
     */
    // NOTE(mroberts): This method is named after a Haskell function:
    // https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket
    StateMachine.prototype.bracket = function (name, transitionFunction) {
        var key;
        var self = this;
        function releaseLock(error) {
            if (self.hasLock(key)) {
                self.releaseLockCompletely(key);
            }
            if (error) {
                throw error;
            }
        }
        return this.takeLock(name).then(function gotKey(_key) {
            key = _key;
            return transitionFunction(key);
        }).then(function success(result) {
            releaseLock();
            return result;
        }, releaseLock);
    };
    /**
     * Check whether or not a {@link StateMachine#Key} matches the lock.
     * @param {StateMachine#Key} key
     * @returns {boolean}
     */
    StateMachine.prototype.hasLock = function (key) {
        return this._lock === key;
    };
    /**
     * Preempt any pending state transitions and immediately transition to the new
     * state. If a lock name is specified, take the lock and return the
     * {@link StateMachine#Key}.
     * @param {string} newState
     * @param {?string} [name=null] - a name for the lock
     * @param {Array<*>} [payload=[]]
     * @returns {?StateMachine#Key}
     */
    StateMachine.prototype.preempt = function (newState, name, payload) {
        // 1. Check that the new state is valid.
        if (!isValidTransition(this._states, this.state, newState)) {
            throw new Error("Cannot transition from \"" + this.state + "\" to \"" + newState + "\"");
        }
        // 2. Release the old lock, if any.
        var oldLock;
        if (this.isLocked) {
            oldLock = this._lock;
            this._lock = null;
        }
        // 3. Take the lock, if requested.
        var key = null;
        if (name) {
            key = this.takeLockSync(name);
        }
        // 4. If a lock wasn't requested, take a "preemption" lock in order to
        // maintain FIFO order of those taking locks.
        var preemptionKey = key ? null : this.takeLockSync('preemption');
        // 5. Transition.
        this.transition(newState, key || preemptionKey, payload);
        // 6. Preempt anyone blocked on the old lock.
        if (oldLock) {
            oldLock.resolve();
        }
        // 7. Release the "preemption" lock, if we took it.
        if (preemptionKey) {
            this.releaseLock(preemptionKey);
        }
        return key;
    };
    /**
     * Release a lock. This method succeeds only if the {@link StateMachine} is
     * still locked and has not been preempted.
     * @param {StateMachine#Key} key
     * @throws Error
     */
    StateMachine.prototype.releaseLock = function (key) {
        if (!this.isLocked) {
            throw new Error("Could not release the lock for " + key.name + " because the StateMachine is not locked");
        }
        else if (!this.hasLock(key)) {
            throw new Error("Could not release the lock for " + key.name + " because " + this._lock.name + " has the lock");
        }
        if (key.depth === 0) {
            this._lock = null;
            key.resolve();
        }
        else {
            key.depth--;
        }
    };
    /**
     * Release a lock completely, even if it has been reentered. This method
     * succeeds only if the {@link StateMachine} is still locked and has not been
     * preempted.
     * @param {StateMachine#Key} key
     * @throws Error
     */
    StateMachine.prototype.releaseLockCompletely = function (key) {
        if (!this.isLocked) {
            throw new Error("Could not release the lock for " + key.name + " because the StateMachine is not locked");
        }
        else if (!this.hasLock(key)) {
            throw new Error("Could not release the lock for " + key.name + " because " + this._lock.name + " has the lock");
        }
        key.depth = 0;
        this._lock = null;
        key.resolve();
    };
    /**
     * Take a lock, returning a Promise for the {@link StateMachine#Key}. You should
     * take a lock anytime you intend to perform asynchronous transitions. Calls to
     * this method are guaranteed to be resolved in FIFO order. You may reenter
     * a lock by passing its {@link StateMachine#Key}.
     * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an
     * existing {@link StateMachine#Key}
     * @returns {Promise<object>}
     */
    StateMachine.prototype.takeLock = function (nameOrKey) {
        var _this = this;
        // Reentrant lock
        if (typeof nameOrKey === 'object') {
            var key_1 = nameOrKey;
            return new Promise(function (resolve) {
                resolve(_this.takeLockSync(key_1));
            });
        }
        // New lock
        var name = nameOrKey;
        if (this.isLocked) {
            var takeLock = this.takeLock.bind(this, name);
            return this._lock.promise.then(takeLock);
        }
        return Promise.resolve(this.takeLockSync(name));
    };
    /**
     * Take a lock, returning the {@Link StateMachine#Key}. This method throws if
     * the {@link StateMachine} is locked or the wrong {@link StateMachine#Key} is
     * provided. You may reenter a lock by passing its {@link StateMachine#Key}.
     * @param {string|StateMachine#Key} nameOrKey - a name for the lock or an
     * existing {@link StateMachine#Key}
     * @returns {object}
     * @throws Error
     */
    StateMachine.prototype.takeLockSync = function (nameOrKey) {
        var key = typeof nameOrKey === 'string' ? null : nameOrKey;
        var name = key ? key.name : nameOrKey;
        if (key && !this.hasLock(key) || !key && this.isLocked) {
            throw new Error("Could not take the lock for " + name + " because the lock for " + this._lock.name + " was not released");
        }
        // Reentrant lock
        if (key) {
            key.depth++;
            return key;
        }
        // New lock
        var lock = makeLock(name);
        this._lock = lock;
        return lock;
    };
    /**
     * Transition to a new state. If the {@link StateMachine} is locked, you must
     * provide the {@link StateMachine#Key}. An invalid state or the wrong
     * {@link StateMachine#Key} will throw an error.
     * @param {string} newState
     * @param {?StateMachine#Key} [key=null]
     * @param {Array<*>} [payload=[]]
     * @throws {Error}
     */
    StateMachine.prototype.transition = function (newState, key, payload) {
        payload = payload || [];
        // 1. If we're locked, required the key.
        if (this.isLocked) {
            if (!key) {
                throw new Error('You must provide the key in order to ' +
                    'transition');
            }
            else if (!this.hasLock(key)) {
                throw new Error("Could not transition using the key for " + key.name + " because " + this._lock.name + " has the lock");
            }
        }
        else if (key) {
            throw new Error("Key provided for " + key.name + ", but the StateMachine was not locked (possibly due to preemption)");
        }
        // 2. Check that the new state is valid.
        if (!isValidTransition(this._states, this.state, newState)) {
            throw new Error("Cannot transition from \"" + this.state + "\" to \"" + newState + "\"");
        }
        // 3. Update the state and emit an event.
        this._state = newState;
        this.emit.apply(this, __spreadArray([], __read(['stateChanged', newState].concat(payload))));
    };
    /**
     * Attempt to transition to a new state. Unlike {@link StateMachine#transition},
     * this method does not throw.
     * @param {string} newState
     * @param {?StateMachine#Key} [key=null]
     * @param {Array<*>} [payload=[]]
     * @returns {boolean}
     */
    StateMachine.prototype.tryTransition = function (newState, key, payload) {
        try {
            this.transition(newState, key, payload);
        }
        catch (error) {
            return false;
        }
        return true;
    };
    /**
     * Return a Promise that resolves when the {@link StateMachine} transitions to
     * the specified state. If the {@link StateMachine} transitions such that the
     * requested state becomes unreachable, the Promise rejects.
     * @param {string} state
     * @returns {Promise<this>}
     */
    StateMachine.prototype.when = function (state) {
        var _this = this;
        if (this.state === state) {
            return Promise.resolve(this);
        }
        else if (!isValidTransition(this._reachableStates, this.state, state)) {
            return Promise.reject(createUnreachableError(this.state, state));
        }
        return this._whenPromise(function (newState, resolve, reject) {
            if (newState === state) {
                resolve(_this);
            }
            else if (!isValidTransition(_this._reachableStates, newState, state)) {
                reject(createUnreachableError(newState, state));
            }
        });
    };
    return StateMachine;
}(EventEmitter));
/**
 * @event StateMachine#stateChanged
 * @param {string} newState
 */
/**
 * Check if a transition is valid.
 * @private
 * @param {Map<*, Set<*>>} graph
 * @param {*} from
 * @param {*} to
 * @returns {boolean}
 */
function isValidTransition(graph, from, to) {
    return graph.get(from).has(to);
}
/**
 * @typedef {object} StateMachine#Key
 */
function makeLock(name) {
    var lock = util.defer();
    lock.name = name;
    lock.depth = 0;
    return lock;
}
/**
 * Compute the transitive closure of a graph (i.e. what nodes are reachable from
 * where).
 * @private
 * @param {Map<*, Set<*>>} graph
 * @returns {Map<*, Set<*>>}
 */
function reachable(graph) {
    return Array.from(graph.keys()).reduce(function (newGraph, from) { return newGraph.set(from, reachableFrom(graph, from)); }, new Map());
}
/**
 * Compute the Set of node reachable from a particular node in the graph.
 * @private
 * @param {Map<*, Set<*>>} graph
 * @param {*} from
 * @param {Set<*>} [to]
 * @returns {Set<*>}
 */
function reachableFrom(graph, from, to) {
    to = to || new Set();
    graph.get(from).forEach(function (node) {
        if (!to.has(node)) {
            to.add(node);
            reachableFrom(graph, node, to).forEach(to.add, to);
        }
    });
    return to;
}
function transformStates(states) {
    var newStates = new Map();
    for (var key in states) {
        newStates.set(key, new Set(states[key]));
    }
    return newStates;
}
/**
 * Create an "unreachable state" Error.
 * @param {string} here
 * @param {string} there
 * @returns {Error}
 */
function createUnreachableError(here, there) {
    return new Error("\"" + there + "\" cannot be reached from \"" + here + "\"");
}
module.exports = StateMachine;
//# sourceMappingURL=statemachine.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/average.js":
/*!********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/average.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint no-undefined:0 */

/**
 * @param {Array<number|undefined>} xs
 * @returns {number|undefined}
 */
function average(xs) {
    xs = xs.filter(function (x) { return typeof x === 'number'; });
    return xs.length < 1 ? undefined : xs.reduce(function (y, x) { return x + y; }) / xs.length;
}
module.exports = average;
//# sourceMappingURL=average.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/icereport.js":
/*!**********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/icereport.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @property {number} [availableSend] - bps (undefined in Firefox)
 * @property {number} recv - bps
 * @property {number} [rtt] - s (undefined in Firefox)
 * @property {number} send - bps
 */
var IceReport = /** @class */ (function () {
    /**
     * Construct an {@link IceReport}.
     * @param {number} send - bps
     * @param {number} recv - bps
     * @param {number} [rtt] - s
     * @param {number} [availableSend] - bps
     */
    function IceReport(send, recv, availableSend, rtt) {
        Object.defineProperties(this, {
            availableSend: {
                enumerable: true,
                value: availableSend
            },
            recv: {
                enumerable: true,
                value: recv
            },
            rtt: {
                enumerable: true,
                value: rtt
            },
            send: {
                enumerable: true,
                value: send
            }
        });
    }
    /**
     * @param {RTCStats} olderStats
     * @param {RTCStats} newerStats
     * @returns {IceReport}
     */
    IceReport.of = function (olderStats, newerStats) {
        var secondsElapsed = (newerStats.timestamp - olderStats.timestamp) / 1000;
        var deltaBytesSent = newerStats.bytesSent - olderStats.bytesSent;
        var deltaBytesReceived = newerStats.bytesReceived - olderStats.bytesReceived;
        var send = secondsElapsed > 0
            ? (deltaBytesSent / secondsElapsed) * 8
            : 0;
        var recv = secondsElapsed > 0
            ? (deltaBytesReceived / secondsElapsed) * 8
            : 0;
        var availableSend = newerStats.availableOutgoingBitrate, rtt = newerStats.currentRoundTripTime;
        return new IceReport(send, recv, availableSend, rtt);
    };
    return IceReport;
}());
module.exports = IceReport;
//# sourceMappingURL=icereport.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/icereportfactory.js":
/*!*****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/icereportfactory.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IceReport = __webpack_require__(/*! ./icereport */ "../../work/twilio-video.js/es5/stats/icereport.js");
/**
 * @property {IceReport} lastReport
 * @property {?RTCStats} lastStats
 */
var IceReportFactory = /** @class */ (function () {
    /**
     * Construct an {@link IceReportFactory}.
     */
    function IceReportFactory() {
        Object.defineProperties(this, {
            lastReport: {
                enumerable: true,
                value: new IceReport(0, 0),
                writable: true
            },
            lastStats: {
                enumerable: true,
                value: null,
                writable: true
            }
        });
    }
    /**
     * Create an {@link IceReport}.
     * @param {RTCStats} newerStats;
     * @returns {IceReport}
     */
    IceReportFactory.prototype.next = function (newerStats) {
        var olderStats = this.lastStats;
        this.lastStats = newerStats;
        if (olderStats) {
            var report = olderStats.id === newerStats.id
                ? IceReport.of(olderStats, newerStats)
                : new IceReport(0, 0);
            this.lastReport = report;
        }
        return this.lastReport;
    };
    return IceReportFactory;
}());
module.exports = IceReportFactory;
//# sourceMappingURL=icereportfactory.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/localaudiotrackstats.js":
/*!*********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/localaudiotrackstats.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalTrackStats = __webpack_require__(/*! ./localtrackstats */ "../../work/twilio-video.js/es5/stats/localtrackstats.js");
/**
 * Statistics for a {@link LocalAudioTrack}.
 * @extends LocalTrackStats
 * @property {?AudioLevel} audioLevel - Input {@link AudioLevel}
 * @property {?number} jitter - Audio jitter in milliseconds
 */
var LocalAudioTrackStats = /** @class */ (function (_super) {
    __extends(LocalAudioTrackStats, _super);
    /**
     * @param {string} trackId - {@link LocalAudioTrack} ID
     * @param {StandardizedTrackStatsReport} statsReport
     * @param {boolean} prepareForInsights
     */
    function LocalAudioTrackStats(trackId, statsReport, prepareForInsights) {
        var _this = _super.call(this, trackId, statsReport, prepareForInsights) || this;
        Object.defineProperties(_this, {
            audioLevel: {
                value: typeof statsReport.audioInputLevel === 'number'
                    ? statsReport.audioInputLevel
                    : null,
                enumerable: true
            },
            jitter: {
                value: typeof statsReport.jitter === 'number'
                    ? statsReport.jitter
                    : null,
                enumerable: true
            }
        });
        return _this;
    }
    return LocalAudioTrackStats;
}(LocalTrackStats));
/**
 * The maximum absolute amplitude of a set of audio samples in the
 * range of 0 to 32767 inclusive.
 * @typedef {number} AudioLevel
 */
module.exports = LocalAudioTrackStats;
//# sourceMappingURL=localaudiotrackstats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/localtrackstats.js":
/*!****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/localtrackstats.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackStats = __webpack_require__(/*! ./trackstats */ "../../work/twilio-video.js/es5/stats/trackstats.js");
/**
 * Statistics for a {@link LocalTrack}.
 * @extends TrackStats
 * @property {?number} bytesSent - Number of bytes sent
 * @property {?number} packetsSent - Number of packets sent
 * @property {?number} roundTripTime - Round trip time in milliseconds
 */
var LocalTrackStats = /** @class */ (function (_super) {
    __extends(LocalTrackStats, _super);
    /**
     * @param {string} trackId - {@link LocalTrack} ID
     * @param {StandardizedTrackStatsReport} statsReport
     * @param {boolean} prepareForInsights
     */
    function LocalTrackStats(trackId, statsReport, prepareForInsights) {
        var _this = _super.call(this, trackId, statsReport) || this;
        Object.defineProperties(_this, {
            bytesSent: {
                value: typeof statsReport.bytesSent === 'number'
                    ? statsReport.bytesSent
                    : prepareForInsights ? 0 : null,
                enumerable: true
            },
            packetsSent: {
                value: typeof statsReport.packetsSent === 'number'
                    ? statsReport.packetsSent
                    : prepareForInsights ? 0 : null,
                enumerable: true
            },
            roundTripTime: {
                value: typeof statsReport.roundTripTime === 'number'
                    ? statsReport.roundTripTime
                    : prepareForInsights ? 0 : null,
                enumerable: true
            }
        });
        return _this;
    }
    return LocalTrackStats;
}(TrackStats));
module.exports = LocalTrackStats;
//# sourceMappingURL=localtrackstats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/localvideotrackstats.js":
/*!*********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/localvideotrackstats.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalTrackStats = __webpack_require__(/*! ./localtrackstats */ "../../work/twilio-video.js/es5/stats/localtrackstats.js");
/**
 * Statistics for a {@link LocalVideoTrack}.
 * @extends LocalTrackStats
 * @property {?VideoTrack#Dimensions} captureDimensions - Video capture resolution
 * @property {?VideoTrack#Dimensions} dimensions - Video encoding resolution
 * @property {?number} captureFrameRate - Video capture frame rate
 * @property {?number} frameRate - Video encoding frame rate
 */
var LocalVideoTrackStats = /** @class */ (function (_super) {
    __extends(LocalVideoTrackStats, _super);
    /**
     * @param {string} trackId - {@link LocalVideoTrack} ID
     * @param {StandardizedTrackStatsReport} statsReport
     * @param {boolean} prepareForInsights
     */
    function LocalVideoTrackStats(trackId, statsReport, prepareForInsights) {
        var _this = _super.call(this, trackId, statsReport, prepareForInsights) || this;
        var captureDimensions = null;
        if (typeof statsReport.frameWidthInput === 'number' &&
            typeof statsReport.frameHeightInput === 'number') {
            captureDimensions = {};
            Object.defineProperties(captureDimensions, {
                width: {
                    value: statsReport.frameWidthInput,
                    enumerable: true
                },
                height: {
                    value: statsReport.frameHeightInput,
                    enumerable: true
                }
            });
        }
        var dimensions = null;
        if (typeof statsReport.frameWidthSent === 'number' &&
            typeof statsReport.frameHeightSent === 'number') {
            dimensions = {};
            Object.defineProperties(dimensions, {
                width: {
                    value: statsReport.frameWidthSent,
                    enumerable: true
                },
                height: {
                    value: statsReport.frameHeightSent,
                    enumerable: true
                }
            });
        }
        Object.defineProperties(_this, {
            captureDimensions: {
                value: captureDimensions,
                enumerable: true
            },
            dimensions: {
                value: dimensions,
                enumerable: true
            },
            captureFrameRate: {
                value: typeof statsReport.frameRateInput === 'number'
                    ? statsReport.frameRateInput
                    : null,
                enumerable: true
            },
            frameRate: {
                value: typeof statsReport.frameRateSent === 'number'
                    ? statsReport.frameRateSent
                    : null,
                enumerable: true
            }
        });
        return _this;
    }
    return LocalVideoTrackStats;
}(LocalTrackStats));
module.exports = LocalVideoTrackStats;
//# sourceMappingURL=localvideotrackstats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/networkqualityaudiostats.js":
/*!*************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/networkqualityaudiostats.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NetworkQualityMediaStats = __webpack_require__(/*! ./networkqualitymediastats */ "../../work/twilio-video.js/es5/stats/networkqualitymediastats.js");
/**
 * {@link NetworkQualityMediaStats} for a {@link Participant}'s audio.
 */
var NetworkQualityAudioStats = /** @class */ (function (_super) {
    __extends(NetworkQualityAudioStats, _super);
    /**
     * Construct a {@link NetworkQualityAudioStats}.
     * @param {MediaLevels} mediaLevels
     */
    function NetworkQualityAudioStats(mediaLevels) {
        return _super.call(this, mediaLevels) || this;
    }
    return NetworkQualityAudioStats;
}(NetworkQualityMediaStats));
module.exports = NetworkQualityAudioStats;
//# sourceMappingURL=networkqualityaudiostats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/networkqualitybandwidthstats.js":
/*!*****************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/networkqualitybandwidthstats.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Bandwidth network quality statistics.
 * @property {?number} actual - the actual bandwidth used, in bits per second
 * @property {?number} available - an estimate of available useable bandwidth, in bits per second
 * @property {?NetworkQualityLevel} level - {@link NetworkQualityLevel} for bandwidth
 */
var NetworkQualityBandwidthStats = /** @class */ (function () {
    /**
     * Construct a {@link NetworkQualityBandwidthStats}.
     * @param {BandwidthStats} bandwidthStats
     */
    function NetworkQualityBandwidthStats(_a) {
        var _b = _a.actual, actual = _b === void 0 ? null : _b, _c = _a.available, available = _c === void 0 ? null : _c, _d = _a.level, level = _d === void 0 ? null : _d;
        Object.defineProperties(this, {
            actual: {
                value: actual,
                enumerable: true
            },
            available: {
                value: available,
                enumerable: true
            },
            level: {
                value: level,
                enumerable: true
            }
        });
    }
    return NetworkQualityBandwidthStats;
}());
module.exports = NetworkQualityBandwidthStats;
//# sourceMappingURL=networkqualitybandwidthstats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/networkqualityfractionloststats.js":
/*!********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/networkqualityfractionloststats.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Fraction lost network quality statistics.
 * @property {?number} fractionLost - packets lost
 * @property {?NetworkQualityLevel} level - {@link NetworkQualityLevel} for fraction lost
 */
var NetworkQualityFractionLostStats = /** @class */ (function () {
    /**
     * Construct a {@link NetworkQualityFractionLostStats}.
     * @param {FractionLostStats} fractionLostStats
     */
    function NetworkQualityFractionLostStats(_a) {
        var _b = _a.fractionLost, fractionLost = _b === void 0 ? null : _b, _c = _a.level, level = _c === void 0 ? null : _c;
        Object.defineProperties(this, {
            fractionLost: {
                value: fractionLost,
                enumerable: true
            },
            level: {
                value: level,
                enumerable: true
            }
        });
    }
    return NetworkQualityFractionLostStats;
}());
module.exports = NetworkQualityFractionLostStats;
//# sourceMappingURL=networkqualityfractionloststats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/networkqualitylatencystats.js":
/*!***************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/networkqualitylatencystats.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Latency network quality statistics.
 * @property {?number} jitter - media jitter in seconds
 * @property {?number} rtt - round trip time in seconds
 * @property {?NetworkQualityLevel} level - {@link NetworkQualityLevel} for latency
 */
var NetworkQualityLatencyStats = /** @class */ (function () {
    /**
     * Construct a {@link NetworkQualityLatencyStats}.
     * @param {LatencyStats} latencyStats
     */
    function NetworkQualityLatencyStats(_a) {
        var _b = _a.jitter, jitter = _b === void 0 ? null : _b, _c = _a.rtt, rtt = _c === void 0 ? null : _c, _d = _a.level, level = _d === void 0 ? null : _d;
        Object.defineProperties(this, {
            jitter: {
                value: jitter,
                enumerable: true
            },
            rtt: {
                value: rtt,
                enumerable: true
            },
            level: {
                value: level,
                enumerable: true
            }
        });
    }
    return NetworkQualityLatencyStats;
}());
module.exports = NetworkQualityLatencyStats;
//# sourceMappingURL=networkqualitylatencystats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/networkqualitymediastats.js":
/*!*************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/networkqualitymediastats.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NetworkQualitySendStats = __webpack_require__(/*! ./networkqualitysendstats */ "../../work/twilio-video.js/es5/stats/networkqualitysendstats.js");
var NetworkQualityRecvStats = __webpack_require__(/*! ./networkqualityrecvstats */ "../../work/twilio-video.js/es5/stats/networkqualityrecvstats.js");
/**
 * Network quality statistics shared between a {@link Participant}'s audio or video.
 * @property {NetworkQualityLevel} send - {@link NetworkQualityLevel} of the
 *  {@link Participant}'s published audio or video
 * @property {number} recv - {@link NetworkQualityLevel} of the
 *  {@link Participant}'s subscribed audio or video
 * @property {?NetworkQualitySendOrRecvStats} sendStats - {@link NetworkQualitySendOrRecvStats}
 *   based on which {@link NetworkQualityMediaStats}<code style="padding:0 0">#send</code>
 *   is calculated
 * @property {?NetworkQualitySendOrRecvStats} recvStats - {@link NetworkQualitySendOrRecvStats}
 *   based on which {@link NetworkQualityMediaStats}<code style="padding:0 0">#recv</code>
 *   is calculated
 */
var NetworkQualityMediaStats = /** @class */ (function () {
    /**
     * Construct a {@link NetworkQualityMediaStats}.
     * @param {MediaLevels} mediaLevels
     */
    function NetworkQualityMediaStats(_a) {
        var send = _a.send, recv = _a.recv, _b = _a.sendStats, sendStats = _b === void 0 ? null : _b, _c = _a.recvStats, recvStats = _c === void 0 ? null : _c;
        Object.defineProperties(this, {
            send: {
                value: send,
                enumerable: true
            },
            recv: {
                value: recv,
                enumerable: true
            },
            sendStats: {
                value: sendStats ? new NetworkQualitySendStats(sendStats) : null,
                enumerable: true
            },
            recvStats: {
                value: recvStats ? new NetworkQualityRecvStats(recvStats) : null,
                enumerable: true
            }
        });
    }
    return NetworkQualityMediaStats;
}());
module.exports = NetworkQualityMediaStats;
//# sourceMappingURL=networkqualitymediastats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/networkqualityrecvstats.js":
/*!************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/networkqualityrecvstats.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NetworkQualitySendOrRecvStats = __webpack_require__(/*! ./networkqualitysendorrecvstats */ "../../work/twilio-video.js/es5/stats/networkqualitysendorrecvstats.js");
/**
 * {@link NetworkQualitySendOrRecvStats} based on which a {@link Participant}'s
 * {@link NetworkQualityMediaStats}<code style="padding:0 0">#recv</code> is calculated.
 */
var NetworkQualityRecvStats = /** @class */ (function (_super) {
    __extends(NetworkQualityRecvStats, _super);
    /**
     * Construct a {@link NetworkQualityRecvStats}.
     * @param {SendOrRecvStats} sendOrRecvStats
     */
    function NetworkQualityRecvStats(sendOrRecvStats) {
        return _super.call(this, sendOrRecvStats) || this;
    }
    return NetworkQualityRecvStats;
}(NetworkQualitySendOrRecvStats));
module.exports = NetworkQualityRecvStats;
//# sourceMappingURL=networkqualityrecvstats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/networkqualitysendorrecvstats.js":
/*!******************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/networkqualitysendorrecvstats.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NetworkQualityBandwidthStats = __webpack_require__(/*! ./networkqualitybandwidthstats */ "../../work/twilio-video.js/es5/stats/networkqualitybandwidthstats.js");
var NetworkQualityFractionLostStats = __webpack_require__(/*! ./networkqualityfractionloststats */ "../../work/twilio-video.js/es5/stats/networkqualityfractionloststats.js");
var NetworkQualityLatencyStats = __webpack_require__(/*! ./networkqualitylatencystats */ "../../work/twilio-video.js/es5/stats/networkqualitylatencystats.js");
/**
 * Network quality statistics shared between {@link NetworkQualitySendStats} and
 * {@link NetworkQualityRecvStats} based on which a {@link Participant}'s
 * {@link NetworkQualityMediaStats}<code style="padding:0 0">#send</code> or
 * {@link NetworkQualityMediaStats}<code style="padding:0 0">#recv</code> is calculated.
 * @property {?NetworkQualityBandwidthStats} bandwidth - bandwidth statistics
 * @property {?NetworkQualityLatencyStats} latency - latency statistics
 * @property {?NetworkQualityFractionLostStats} fractionLost - fraction lost statistics
 */
var NetworkQualitySendOrRecvStats = /** @class */ (function () {
    /**
     * Construct a {@link NetworkQualitySendOrRecvStats}.
     * @param {SendOrRecvStats} sendOrRecvStats
     */
    function NetworkQualitySendOrRecvStats(_a) {
        var _b = _a.bandwidth, bandwidth = _b === void 0 ? null : _b, _c = _a.fractionLost, fractionLost = _c === void 0 ? null : _c, _d = _a.latency, latency = _d === void 0 ? null : _d;
        Object.defineProperties(this, {
            bandwidth: {
                value: bandwidth ? new NetworkQualityBandwidthStats(bandwidth) : null,
                enumerable: true
            },
            fractionLost: {
                value: fractionLost ? new NetworkQualityFractionLostStats(fractionLost) : null,
                enumerable: true
            },
            latency: {
                value: latency ? new NetworkQualityLatencyStats(latency) : null,
                enumerable: true
            }
        });
    }
    return NetworkQualitySendOrRecvStats;
}());
module.exports = NetworkQualitySendOrRecvStats;
//# sourceMappingURL=networkqualitysendorrecvstats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/networkqualitysendstats.js":
/*!************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/networkqualitysendstats.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NetworkQualitySendOrRecvStats = __webpack_require__(/*! ./networkqualitysendorrecvstats */ "../../work/twilio-video.js/es5/stats/networkqualitysendorrecvstats.js");
/**
 * {@link NetworkQualitySendOrRecvStats} based on which a {@link Participant}'s
 * {@link NetworkQualityMediaStats}<code style="padding:0 0">#send</code> is calculated.
 */
var NetworkQualitySendStats = /** @class */ (function (_super) {
    __extends(NetworkQualitySendStats, _super);
    /**
     * Construct a {@link NetworkQualitySendStats}.
     * @param {SendOrRecvStats} sendOrRecvStats
     */
    function NetworkQualitySendStats(sendOrRecvStats) {
        return _super.call(this, sendOrRecvStats) || this;
    }
    return NetworkQualitySendStats;
}(NetworkQualitySendOrRecvStats));
module.exports = NetworkQualitySendStats;
//# sourceMappingURL=networkqualitysendstats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/networkqualitystats.js":
/*!********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/networkqualitystats.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NetworkQualityAudioStats = __webpack_require__(/*! ./networkqualityaudiostats */ "../../work/twilio-video.js/es5/stats/networkqualityaudiostats.js");
var NetworkQualityVideoStats = __webpack_require__(/*! ./networkqualityvideostats */ "../../work/twilio-video.js/es5/stats/networkqualityvideostats.js");
/**
 * Network quality statistics for a {@link Participant}.
 * @property {NetworkQualityLevel} level - {@link NetworkQualityLevel} of the {@link Participant}
 * @property {?NetworkQualityAudioStats} audio - {@link NetworkQualityMediaStats}
 *   for audio; <code>null</code> if {@link NetworkQualityVerbosity} is {@link NetworkQualityVerbosity}<code style="padding:0 0">#minimal</code>
 *   or below
 * @property {?NetworkQualityVideoStats} video - {@link NetworkQualityMediaStats}
 *   for video; <code>null</code> if {@link NetworkQualityVerbosity} is {@link NetworkQualityVerbosity}<code style="padding:0 0">#minimal</code>
 *   or below
 */
var NetworkQualityStats = /** @class */ (function () {
    /**
     * Construct a {@link NetworkQualityStats}.
     * @param {NetworkQualityLevels} networkQualityLevels
     */
    function NetworkQualityStats(_a) {
        var level = _a.level, audio = _a.audio, video = _a.video;
        Object.defineProperties(this, {
            level: {
                value: level,
                enumerable: true
            },
            audio: {
                value: audio ? new NetworkQualityAudioStats(audio) : null,
                enumerable: true
            },
            video: {
                value: video ? new NetworkQualityVideoStats(video) : null,
                enumerable: true
            }
        });
    }
    return NetworkQualityStats;
}());
module.exports = NetworkQualityStats;
//# sourceMappingURL=networkqualitystats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/networkqualityvideostats.js":
/*!*************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/networkqualityvideostats.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NetworkQualityMediaStats = __webpack_require__(/*! ./networkqualitymediastats */ "../../work/twilio-video.js/es5/stats/networkqualitymediastats.js");
/**
 * {@link NetworkQualityMediaStats} for a {@link Participant}'s video.
 */
var NetworkQualityVideoStats = /** @class */ (function (_super) {
    __extends(NetworkQualityVideoStats, _super);
    /**
     * Construct a {@link NetworkQualityVideoStats}.
     * @param {MediaLevels} mediaLevels
     */
    function NetworkQualityVideoStats(mediaLevels) {
        return _super.call(this, mediaLevels) || this;
    }
    return NetworkQualityVideoStats;
}(NetworkQualityMediaStats));
module.exports = NetworkQualityVideoStats;
//# sourceMappingURL=networkqualityvideostats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/peerconnectionreport.js":
/*!*********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/peerconnectionreport.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ReceiverReport = __webpack_require__(/*! ./receiverreport */ "../../work/twilio-video.js/es5/stats/receiverreport.js");
var SenderReport = __webpack_require__(/*! ./senderreport */ "../../work/twilio-video.js/es5/stats/senderreport.js");
/**
 * @interface SenderAndReceiverReports
 * @property {Array<SenderReport>} send
 * @property {Array<ReceiverReport>} recv
 */
/**
 * @interface SenderAndReceiverSummary
 * @property {SenderSummary} send
 * @property {ReceiverSummary} recv
 */
/**
 * @interface PeerConnectionSummary
 * @property {IceReport} ice
 * @property {SenderSummary} send
 * @property {ReceiverSummary} recv
 * @property {SenderAndReceiverSummary} audio
 * @property {SenderAndReceiverSummary} video
 */
/**
 * @property {IceReport} ice
 * @roperty {SenderAndReceiverReports} audio
 * @roperty {SenderAndReceiverReports} video
 */
var PeerConnectionReport = /** @class */ (function () {
    /**
     * Construct a {@link PeerConnectionReport}.
     * @param {IceReport} ice
     * @param {SenderAndReceiverReports} audio
     * @param {SenderAndReceiverReports} video
     */
    function PeerConnectionReport(ice, audio, video) {
        Object.defineProperties(this, {
            ice: {
                enumerable: true,
                value: ice
            },
            audio: {
                enumerable: true,
                value: audio
            },
            video: {
                enumerable: true,
                value: video
            }
        });
    }
    /**
     * Summarize the {@link PeerConnectionReport} by summarizing its
     * {@link SenderReport}s and {@link ReceiverReport}s.
     * @returns {PeerConnectionSummary}
     */
    PeerConnectionReport.prototype.summarize = function () {
        var senderReports = this.audio.send.concat(this.video.send);
        var send = SenderReport.summarize(senderReports);
        var receiverReports = this.audio.recv.concat(this.video.recv);
        var recv = ReceiverReport.summarize(receiverReports);
        return {
            ice: this.ice,
            send: send,
            recv: recv,
            audio: {
                send: SenderReport.summarize(this.audio.send),
                recv: ReceiverReport.summarize(this.audio.recv)
            },
            video: {
                send: SenderReport.summarize(this.video.send),
                recv: ReceiverReport.summarize(this.video.recv)
            }
        };
    };
    return PeerConnectionReport;
}());
module.exports = PeerConnectionReport;
//# sourceMappingURL=peerconnectionreport.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/peerconnectionreportfactory.js":
/*!****************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/peerconnectionreportfactory.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var guessBrowser = __webpack_require__(/*! @twilio/webrtc/lib/util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").guessBrowser;
var IceReportFactory = __webpack_require__(/*! ./icereportfactory */ "../../work/twilio-video.js/es5/stats/icereportfactory.js");
var PeerConnectionReport = __webpack_require__(/*! ./peerconnectionreport */ "../../work/twilio-video.js/es5/stats/peerconnectionreport.js");
var ReceiverReportFactory = __webpack_require__(/*! ./receiverreportfactory */ "../../work/twilio-video.js/es5/stats/receiverreportfactory.js");
var SenderReportFactory = __webpack_require__(/*! ./senderreportfactory */ "../../work/twilio-video.js/es5/stats/senderreportfactory.js");
/**
 * @typedef {string} TrackId
 */
/**
 * @typedef {string} StatsId
 */
/**
 * @interface SenderReportFactoriesByMediaType
 * @property {Map<StatsId, SenderReportFactory>} audio
 * @property {Map<StatsId, SenderReportFactory>} video
 */
/**
 * @interface ReceiverReportFactoriesByMediaType
 * @property {Map<StatsId, ReceiverReportFactory>} audio
 * @property {Map<StatsId, ReceiverReportFactory>} video
 */
/**
 * @interface SenderAndReceiverReportFactories
 * @property {Map<StatsId, SenderReportFactories>} send
 * @property {Map<StatsId, ReceiverReportFactories>} recv
 */
/**
 * @interface {StatsIdsByMediaType}
 * @property {Set<StatsId>} audio
 * @property {Set<StatsId>} video
 */
/**
 * @property {RTCPeerConnection} pc
 * @property {IceReportFactory} iceReportFactory
 * @property {SenderAndReceiverReportFactories} audio
 * @property {SenderAndReceiverReportFactories} video
 * @property {?PeerConnectionReport} lastReport
 */
var PeerConnectionReportFactory = /** @class */ (function () {
    /**
     * Construct a {@link PeerConnectionReportFactory}.
     * @param {RTCPeerConnection} pc
     */
    function PeerConnectionReportFactory(pc) {
        Object.defineProperties(this, {
            pc: {
                enumerable: true,
                value: pc
            },
            ice: {
                enumerable: true,
                value: new IceReportFactory()
            },
            audio: {
                enumerable: true,
                value: {
                    send: new Map(),
                    recv: new Map()
                }
            },
            video: {
                enumerable: true,
                value: {
                    send: new Map(),
                    recv: new Map()
                }
            },
            lastReport: {
                enumerable: true,
                value: null,
                writable: true
            }
        });
    }
    /**
     * Create a {@link PeerConnectionReport}.
     * @returns {Promise<PeerConnectionReport>}
     */
    PeerConnectionReportFactory.prototype.next = function () {
        var _this = this;
        var updatePromise = guessBrowser() === 'firefox'
            ? updateFirefox(this)
            : updateChrome(this);
        return updatePromise.then(function () {
            var audioSenderReportFactories = __spreadArray([], __read(_this.audio.send.values()));
            var videoSenderReportFactories = __spreadArray([], __read(_this.video.send.values()));
            var audioReceiverReportFactories = __spreadArray([], __read(_this.audio.recv.values()));
            var videoReceiverReportFactories = __spreadArray([], __read(_this.video.recv.values()));
            var report = new PeerConnectionReport(_this.ice.lastReport, {
                send: audioSenderReportFactories.map(function (factory) { return factory.lastReport; }).filter(function (report) { return report; }),
                recv: audioReceiverReportFactories.map(function (factory) { return factory.lastReport; }).filter(function (report) { return report; })
            }, {
                send: videoSenderReportFactories.map(function (factory) { return factory.lastReport; }).filter(function (report) { return report; }),
                recv: videoReceiverReportFactories.map(function (factory) { return factory.lastReport; }).filter(function (report) { return report; })
            });
            _this.lastReport = report;
            return report;
        });
    };
    return PeerConnectionReportFactory;
}());
/**
 * Construct a Map from MediaStreamTrack Ids to RTCStatsReports.
 * @param {Array<RTCRtpSender>|Array<RTCRtpReceiver>} sendersOrReceivers - each
 *   RTCRtpSender should have a non-null track
 * @returns {Promise<Map<TrackId, RTCStats>>}
 */
function getSenderOrReceiverReports(sendersOrReceivers) {
    return Promise.all(sendersOrReceivers.map(function (senderOrReceiver) {
        var trackId = senderOrReceiver.track.id;
        return senderOrReceiver.getStats().then(function (report) {
            var e_1, _a;
            try {
                // NOTE(mroberts): We have to rewrite Ids due to this bug:
                //
                //   https://bugzilla.mozilla.org/show_bug.cgi?id=1463430
                //
                for (var _b = __values(report.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var stats = _c.value;
                    if (stats.type === 'inbound-rtp') {
                        stats.id = trackId + "-" + stats.id;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return [trackId, report];
        });
    })).then(function (pairs) { return new Map(pairs); });
}
/**
 * @param {SenderReportFactory.constructor} SenderReportFactory
 * @param {SenderReportFactoriesByMediaType} sendersByMediaType
 * @param {RTCStatsReport} report
 * @param {RTCStats} stats
 * @param {TrackId} [trackId]
 * @returns {?SenderReportFactory}
 */ /**
* @param {ReceiverReportFactory.constructor} ReceiverReportFactory
* @param {ReceiverReportFactoriesByMediaType} receiversByMediaType
* @param {RTCStatsReport} report
* @param {RTCStats} stats
* @param {TrackId} [trackId]
* @returns {?ReceiverReportFactory}
*/
function getOrCreateSenderOrReceiverReportFactory(SenderOrReceiverReportFactory, sendersOrReceiversByMediaType, report, stats, trackId) {
    var sendersOrReceivers = sendersOrReceiversByMediaType[stats.mediaType];
    if (!trackId) {
        var trackStats = report.get(stats.trackId);
        if (trackStats) {
            trackId = trackStats.trackIdentifier;
        }
    }
    if (sendersOrReceivers && trackId) {
        if (sendersOrReceivers.has(stats.id)) {
            return sendersOrReceivers.get(stats.id);
        }
        var senderOrReceiverFactory = new SenderOrReceiverReportFactory(trackId, stats);
        sendersOrReceivers.set(stats.id, senderOrReceiverFactory);
    }
    return null;
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @returns {SenderReportFactoriesByMediaType}
 */
function getSenderReportFactoriesByMediaType(factory) {
    return { audio: factory.audio.send, video: factory.video.send };
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @returns {ReceiverReportFactoriesByMediaType}
 */
function getReceiverReportFactoriesByMediaType(factory) {
    return { audio: factory.audio.recv, video: factory.video.recv };
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @param {RTCStatsReport} report
 * @param {RTCStats} stats
 * @param {TrackId} [trackId]
 * @returns {?SenderReportFactory}
 */
function getOrCreateSenderReportFactory(factory, report, stats, trackId) {
    return getOrCreateSenderOrReceiverReportFactory(SenderReportFactory, getSenderReportFactoriesByMediaType(factory), report, stats, trackId);
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @param {RTCStatsReport} report
 * @param {RTCStats} stats
 * @param {TrackId} [trackId]
 * @returns {?ReceiverReportFactory}
 */
function getOrCreateReceiverReportFactory(factory, report, stats, trackId) {
    return getOrCreateSenderOrReceiverReportFactory(ReceiverReportFactory, getReceiverReportFactoriesByMediaType(factory), report, stats, trackId);
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @retuns {StatsIdsByMediaType}
 */
function getSenderReportFactoryIdsByMediaType(factory) {
    return {
        audio: new Set(factory.audio.send.keys()),
        video: new Set(factory.video.send.keys())
    };
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @retuns {StatsIdsByMediaType}
 */
function getReceiverReportFactoryIdsByMediaType(factory) {
    return {
        audio: new Set(factory.audio.recv.keys()),
        video: new Set(factory.video.recv.keys())
    };
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @param {RTCStatsReport} report
 * @param {StatsIdsByMediaType} senderReportFactoryIdsToDeleteByMediaType
 * @param {TrackId} [trackId]
 * @returns {void}
 */
function updateSenderReports(factory, report, senderReportFactoryIdsToDeleteByMediaType, trackId) {
    var e_2, _a;
    try {
        for (var _b = __values(report.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var stats = _c.value;
            if (stats.type === 'outbound-rtp' && !stats.isRemote) {
                if (guessBrowser() !== 'firefox' && !stats.trackId) {
                    continue;
                }
                var senderReportFactoryIdsToDelete = senderReportFactoryIdsToDeleteByMediaType[stats.mediaType];
                if (senderReportFactoryIdsToDelete) {
                    senderReportFactoryIdsToDelete.delete(stats.id);
                }
                var senderReportFactory = getOrCreateSenderReportFactory(factory, report, stats, trackId);
                if (senderReportFactory) {
                    var remoteInboundStats = report.get(stats.remoteId);
                    senderReportFactory.next(trackId || senderReportFactory.trackId, stats, remoteInboundStats);
                }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @param {RTCStatsReport} report
 * @param {StatsIdsByMediaType} receiverReportFactoryIdsToDeleteByMediaType
 * @param {TrackId} [trackId]
 * @returns {void}
 */
function updateReceiverReports(factory, report, receiverReportFactoryIdsToDeleteByMediaType, trackId) {
    var e_3, _a;
    try {
        for (var _b = __values(report.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var stats = _c.value;
            if (stats.type === 'inbound-rtp' && !stats.isRemote) {
                var receiverReportFactoryIdsToDelete = receiverReportFactoryIdsToDeleteByMediaType[stats.mediaType];
                if (receiverReportFactoryIdsToDelete) {
                    receiverReportFactoryIdsToDelete.delete(stats.id);
                }
                var receiverReportFactory = getOrCreateReceiverReportFactory(factory, report, stats, trackId);
                if (receiverReportFactory) {
                    receiverReportFactory.next(trackId || receiverReportFactory.trackId, stats);
                }
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_3) throw e_3.error; }
    }
}
/**
 * @param {SenderReportFactoriesByMediaType|ReceiverReportFactoriesByMediaType} senderOrReceiverReportFactoriesByMediaType
 * @param {StatsIdsByMediaType} senderOrReceiverReportFactoryIdsByMediaType
 * @returns {void}
 */
function deleteSenderOrReceiverReportFactories(senderOrReceiverReportFactoriesByMediaType, senderOrReceiverReportFactoryIdsByMediaType) {
    var _loop_1 = function (mediaType) {
        var senderOrReceiverReportFactories = senderOrReceiverReportFactoriesByMediaType[mediaType];
        var senderOrReceiverReportFactoryIds = senderOrReceiverReportFactoryIdsByMediaType[mediaType];
        senderOrReceiverReportFactoryIds.forEach(function (senderOrReceiverReportFactoryId) { return senderOrReceiverReportFactories.delete(senderOrReceiverReportFactoryId); });
    };
    for (var mediaType in senderOrReceiverReportFactoryIdsByMediaType) {
        _loop_1(mediaType);
    }
}
/**
 * @param {IceReportFactory} ice
 * @param {RTCStatsReport} report
 * @returns {void}
 */
function updateIceReport(ice, report) {
    var e_4, _a, e_5, _b;
    var selectedCandidatePair;
    try {
        for (var _c = __values(report.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var stats = _d.value;
            if (stats.type === 'transport') {
                selectedCandidatePair = report.get(stats.selectedCandidatePairId);
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_4) throw e_4.error; }
    }
    if (selectedCandidatePair) {
        ice.next(selectedCandidatePair);
        return;
    }
    try {
        for (var _e = __values(report.values()), _f = _e.next(); !_f.done; _f = _e.next()) {
            var stats = _f.value;
            if (stats.type === 'candidate-pair'
                && stats.nominated
                && ('selected' in stats ? stats.selected : true)) {
                ice.next(stats);
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_5) throw e_5.error; }
    }
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @returns {Promise<PeerConnectionReport>}
 */
function updateFirefox(factory) {
    var senders = factory.pc.getTransceivers()
        .filter(function (transceiver) { return transceiver.currentDirection && transceiver.currentDirection.match(/send/) && transceiver.sender.track; })
        .map(function (transceiver) { return transceiver.sender; });
    var receivers = factory.pc.getTransceivers()
        .filter(function (transceiver) { return transceiver.currentDirection && transceiver.currentDirection.match(/recv/); })
        .map(function (transceiver) { return transceiver.receiver; });
    return Promise.all([
        getSenderOrReceiverReports(senders),
        getSenderOrReceiverReports(receivers),
        factory.pc.getStats()
    ]).then(function (_a) {
        var _b = __read(_a, 3), senderReports = _b[0], receiverReports = _b[1], pcReport = _b[2];
        var senderReportFactoriesByMediaType = getSenderReportFactoriesByMediaType(factory);
        var senderReportFactoryIdsToDeleteByMediaType = getSenderReportFactoryIdsByMediaType(factory);
        senderReports.forEach(function (report, trackId) { return updateSenderReports(factory, report, senderReportFactoryIdsToDeleteByMediaType, trackId); });
        deleteSenderOrReceiverReportFactories(senderReportFactoriesByMediaType, senderReportFactoryIdsToDeleteByMediaType);
        var receiverReportFactoriesByMediaType = getReceiverReportFactoriesByMediaType(factory);
        var receiverReportFactoryIdsToDeleteByMediaType = getReceiverReportFactoryIdsByMediaType(factory);
        receiverReports.forEach(function (report, trackId) { return updateReceiverReports(factory, report, receiverReportFactoryIdsToDeleteByMediaType, trackId); });
        deleteSenderOrReceiverReportFactories(receiverReportFactoriesByMediaType, receiverReportFactoryIdsToDeleteByMediaType);
        updateIceReport(factory.ice, pcReport);
    });
}
/**
 * @param {PeerConnectionReportFactory} factory
 * @returns {Promise<PeerConnectionReport>}
 */
function updateChrome(factory) {
    return factory.pc.getStats().then(function (report) {
        var senderReportFactoriesByMediaType = getSenderReportFactoriesByMediaType(factory);
        var senderReportFactoryIdsToDeleteByMediaType = getSenderReportFactoryIdsByMediaType(factory);
        updateSenderReports(factory, report, senderReportFactoryIdsToDeleteByMediaType);
        deleteSenderOrReceiverReportFactories(senderReportFactoriesByMediaType, senderReportFactoryIdsToDeleteByMediaType);
        var receiverReportFactoriesByMediaType = getReceiverReportFactoriesByMediaType(factory);
        var receiverReportFactoryIdsToDeleteByMediaType = getReceiverReportFactoryIdsByMediaType(factory);
        updateReceiverReports(factory, report, receiverReportFactoryIdsToDeleteByMediaType);
        deleteSenderOrReceiverReportFactories(receiverReportFactoriesByMediaType, receiverReportFactoryIdsToDeleteByMediaType);
        updateIceReport(factory.ice, report);
    });
}
module.exports = PeerConnectionReportFactory;
//# sourceMappingURL=peerconnectionreportfactory.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/receiverreport.js":
/*!***************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/receiverreport.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var average = __webpack_require__(/*! ./average */ "../../work/twilio-video.js/es5/stats/average.js");
var SenderOrReceiverReport = __webpack_require__(/*! ./senderorreceiverreport */ "../../work/twilio-video.js/es5/stats/senderorreceiverreport.js");
var sum = __webpack_require__(/*! ./sum */ "../../work/twilio-video.js/es5/stats/sum.js");
/**
 * @interface ReceiverSummary
 * @property {number} bitrate
 * @property {number} fractionLost - 0–1
 * @property {number} [jitter] - s (undefined for video tracks in Chrome)
 */
/**
 * @extends SenderOrReceiverReport
 * @property {number} deltaPacketsLost
 * @property {number} deltaPacketsReceived
 * @property {number} [fractionLost] - 0–1 (undefined in Firefox)
 * @property {number} [jitter] - s (undefined for video tracks in Chrome)
 * @property {number} phonyPacketsLost - 0–1
 */
var ReceiverReport = /** @class */ (function (_super) {
    __extends(ReceiverReport, _super);
    /**
     * @param {StatsId} id
     * @param {TrackId} trackId
     * @param {number} bitrate - bps
     * @param {number} deltaPacketsLost
     * @param {number} deltaPacketsReceived
     * @param {number} [fractionLost] - 0–1 (undefined in Firefox)
     * @param {number} [jitter] - s (undefined for video tracks in Chrome)
     */
    function ReceiverReport(id, trackId, bitrate, deltaPacketsLost, deltaPacketsReceived, fractionLost, jitter) {
        var _this = _super.call(this, id, trackId, bitrate) || this;
        var phonyFractionLost = deltaPacketsReceived > 0
            ? deltaPacketsLost / deltaPacketsReceived
            : 0;
        Object.defineProperties(_this, {
            deltaPacketsLost: {
                enumerable: true,
                value: deltaPacketsLost
            },
            deltaPacketsReceived: {
                enumerable: true,
                value: deltaPacketsReceived
            },
            fractionLost: {
                enumerable: true,
                value: fractionLost
            },
            jitter: {
                enumerable: true,
                value: jitter
            },
            phonyFractionLost: {
                enumerable: true,
                value: phonyFractionLost
            }
        });
        return _this;
    }
    /**
     * Create a {@link ReceiverReport}.
     * @param {string} trackId
     * @param {RTCStats} olderStats
     * @param {RTCStats} newerStats
     * @returns {ReceiverReport}
     */
    ReceiverReport.of = function (trackId, olderStats, newerStats) {
        if (olderStats.id !== newerStats.id) {
            throw new Error('RTCStats IDs must match');
        }
        var secondsElapsed = (newerStats.timestamp - olderStats.timestamp) / 1000;
        var deltaBytesReceived = newerStats.bytesReceived - olderStats.bytesReceived;
        var bitrate = secondsElapsed > 0
            ? (deltaBytesReceived / secondsElapsed) * 8
            : 0;
        var deltaPacketsLost = Math.max(newerStats.packetsLost - olderStats.packetsLost, 0);
        var deltaPacketsReceived = newerStats.packetsReceived - olderStats.packetsReceived;
        var fractionLost = newerStats.fractionLost, jitter = newerStats.jitter;
        return new ReceiverReport(olderStats.id, trackId, bitrate, deltaPacketsLost, deltaPacketsReceived, fractionLost, jitter);
    };
    /**
     * Summarize {@link ReceiverReport}s by summing and averaging their values.
     * @param {Array<ReceiverReport>} reports
     * @returns {ReceiverSummary}
     */
    ReceiverReport.summarize = function (reports) {
        var summaries = reports.map(function (report) { return report.summarize(); });
        var bitrate = sum(summaries.map(function (summary) { return summary.bitrate; }));
        var fractionLost = average(summaries.map(function (summary) { return summary.fractionLost; }));
        var jitter = average(summaries.map(function (summary) { return summary.jitter; }));
        return {
            bitrate: bitrate,
            fractionLost: fractionLost,
            jitter: jitter
        };
    };
    /**
     * Summarize the {@link ReceiveReport}.
     * @returns {ReceiverSummary}
     */
    ReceiverReport.prototype.summarize = function () {
        return {
            bitrate: this.bitrate,
            fractionLost: typeof this.fractionLost === 'number' ? this.fractionLost : this.phonyFractionLost,
            jitter: this.jitter
        };
    };
    return ReceiverReport;
}(SenderOrReceiverReport));
module.exports = ReceiverReport;
//# sourceMappingURL=receiverreport.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/receiverreportfactory.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/receiverreportfactory.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ReceiverReport = __webpack_require__(/*! ./receiverreport */ "../../work/twilio-video.js/es5/stats/receiverreport.js");
var SenderOrReceiverReportFactory = __webpack_require__(/*! ./senderorreceiverreportfactory */ "../../work/twilio-video.js/es5/stats/senderorreceiverreportfactory.js");
/**
 * @extends SenderOrReceiverReportFactory
 * @param {?ReceiverReport} lastReport
 */
var ReceiverReportFactory = /** @class */ (function (_super) {
    __extends(ReceiverReportFactory, _super);
    /**
     * Construct a {@link ReceiverReportFactory}.
     * @param {TrackId} trackId
     * @param {RTCStats} initialStats
     */
    function ReceiverReportFactory(trackId, initialStats) {
        var _this = _super.call(this, initialStats.id, trackId, initialStats) || this;
        Object.defineProperties(_this, {
            lastReport: {
                enumerable: true,
                value: null,
                writable: true
            }
        });
        return _this;
    }
    /**
     * Create a {@link ReceiverReport}.
     * @param {TrackId} trackId
     * @param {RTCStats} newerStats
     * @returns {ReceiverReport}
     */
    ReceiverReportFactory.prototype.next = function (trackId, newerStats) {
        var olderStats = this.lastStats;
        this.lastStats = newerStats;
        this.trackId = trackId;
        var report = ReceiverReport.of(trackId, olderStats, newerStats);
        this.lastReport = report;
        return report;
    };
    return ReceiverReportFactory;
}(SenderOrReceiverReportFactory));
module.exports = ReceiverReportFactory;
//# sourceMappingURL=receiverreportfactory.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/remoteaudiotrackstats.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/remoteaudiotrackstats.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteTrackStats = __webpack_require__(/*! ./remotetrackstats */ "../../work/twilio-video.js/es5/stats/remotetrackstats.js");
/**
 * Statistics for an {@link AudioTrack}.
 * @extends RemoteTrackStats
 * @property {?AudioLevel} audioLevel - Output {@link AudioLevel}
 * @property {?number} jitter - Audio jitter in milliseconds
 */
var RemoteAudioTrackStats = /** @class */ (function (_super) {
    __extends(RemoteAudioTrackStats, _super);
    /**
     * @param {string} trackId - {@link AudioTrack} ID
     * @param {StandardizedTrackStatsReport} statsReport
     */
    function RemoteAudioTrackStats(trackId, statsReport) {
        var _this = _super.call(this, trackId, statsReport) || this;
        Object.defineProperties(_this, {
            audioLevel: {
                value: typeof statsReport.audioOutputLevel === 'number'
                    ? statsReport.audioOutputLevel
                    : null,
                enumerable: true
            },
            jitter: {
                value: typeof statsReport.jitter === 'number'
                    ? statsReport.jitter
                    : null,
                enumerable: true
            }
        });
        return _this;
    }
    return RemoteAudioTrackStats;
}(RemoteTrackStats));
module.exports = RemoteAudioTrackStats;
//# sourceMappingURL=remoteaudiotrackstats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/remotetrackstats.js":
/*!*****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/remotetrackstats.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TrackStats = __webpack_require__(/*! ./trackstats */ "../../work/twilio-video.js/es5/stats/trackstats.js");
/**
 * Statistics for a remote {@link Track}.
 * @extends TrackStats
 * @property {?number} bytesReceived - Number of bytes received
 * @property {?number} packetsReceived - Number of packets received
 */
var RemoteTrackStats = /** @class */ (function (_super) {
    __extends(RemoteTrackStats, _super);
    /*
     * @param {string} trackId - {@link Track} ID
     * @param {StandardizedTrackStatsReport} statsReport
     */
    function RemoteTrackStats(trackId, statsReport) {
        var _this = _super.call(this, trackId, statsReport) || this;
        Object.defineProperties(_this, {
            bytesReceived: {
                value: typeof statsReport.bytesReceived === 'number'
                    ? statsReport.bytesReceived
                    : null,
                enumerable: true
            },
            packetsReceived: {
                value: typeof statsReport.packetsReceived === 'number'
                    ? statsReport.packetsReceived
                    : null,
                enumerable: true
            }
        });
        return _this;
    }
    return RemoteTrackStats;
}(TrackStats));
module.exports = RemoteTrackStats;
//# sourceMappingURL=remotetrackstats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/remotevideotrackstats.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/remotevideotrackstats.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var RemoteTrackStats = __webpack_require__(/*! ./remotetrackstats */ "../../work/twilio-video.js/es5/stats/remotetrackstats.js");
/**
 * Statistics for a {@link VideoTrack}.
 * @extends RemoteTrackStats
 * @property {?VideoTrack#Dimensions} dimensions - Received video resolution
 * @property {?number} frameRate - Received video frame rate
 */
var RemoteVideoTrackStats = /** @class */ (function (_super) {
    __extends(RemoteVideoTrackStats, _super);
    /**
     * @param {string} trackId - {@link VideoTrack} ID
     * @param {StandardizedTrackStatsReport} statsReport
     */
    function RemoteVideoTrackStats(trackId, statsReport) {
        var _this = _super.call(this, trackId, statsReport) || this;
        var dimensions = null;
        if (typeof statsReport.frameWidthReceived === 'number' &&
            typeof statsReport.frameHeightReceived === 'number') {
            dimensions = {};
            Object.defineProperties(dimensions, {
                width: {
                    value: statsReport.frameWidthReceived,
                    enumerable: true
                },
                height: {
                    value: statsReport.frameHeightReceived,
                    enumerable: true
                }
            });
        }
        Object.defineProperties(_this, {
            dimensions: {
                value: dimensions,
                enumerable: true
            },
            frameRate: {
                value: typeof statsReport.frameRateReceived === 'number'
                    ? statsReport.frameRateReceived
                    : null,
                enumerable: true
            }
        });
        return _this;
    }
    return RemoteVideoTrackStats;
}(RemoteTrackStats));
module.exports = RemoteVideoTrackStats;
//# sourceMappingURL=remotevideotrackstats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/senderorreceiverreport.js":
/*!***********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/senderorreceiverreport.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @property {StatsId} id
 * @property {TrackId} trackId
 * @property {number} bitrate - bps
 */
var SenderOrReceiverReport = /** @class */ (function () {
    /**
     * Construct a {@link SenderOrReceiverReport}.
     * @param {StatsId} id
     * @param {TrackId} trackId
     * @param {number} bitrate - bps
     */
    function SenderOrReceiverReport(id, trackId, bitrate) {
        Object.defineProperties(this, {
            id: {
                enumerable: true,
                value: id
            },
            trackId: {
                enumerable: true,
                value: trackId
            },
            bitrate: {
                enumerable: true,
                value: bitrate
            }
        });
    }
    return SenderOrReceiverReport;
}());
module.exports = SenderOrReceiverReport;
//# sourceMappingURL=senderorreceiverreport.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/senderorreceiverreportfactory.js":
/*!******************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/senderorreceiverreportfactory.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @property {StatsId} id
 * @property {TrackId} trackId
 * @property {RTCStats} lastStats
 */
var SenderOrReceiverReportFactory = /** @class */ (function () {
    /**
     * @param {StatsId} id
     * @param {TrackId} trackId
     * @param {RTCStats} initialStats
     */
    function SenderOrReceiverReportFactory(id, trackId, initialStats) {
        Object.defineProperties(this, {
            id: {
                enumerable: true,
                value: id,
                writable: true
            },
            trackId: {
                enumerable: true,
                value: trackId,
                writable: true
            },
            lastStats: {
                enumerable: true,
                value: initialStats,
                writable: true
            }
        });
    }
    return SenderOrReceiverReportFactory;
}());
module.exports = SenderOrReceiverReportFactory;
//# sourceMappingURL=senderorreceiverreportfactory.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/senderreport.js":
/*!*************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/senderreport.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint no-undefined:0 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var average = __webpack_require__(/*! ./average */ "../../work/twilio-video.js/es5/stats/average.js");
var SenderOrReceiverReport = __webpack_require__(/*! ./senderorreceiverreport */ "../../work/twilio-video.js/es5/stats/senderorreceiverreport.js");
var sum = __webpack_require__(/*! ./sum */ "../../work/twilio-video.js/es5/stats/sum.js");
/**
 * @interface SenderSummary
 * @property {number} bitrate
 * @property {number} [rtt] - s (undefined in Chrome)
 */
/**
 * @extends SenderOrReceiverReport
 * @property {number} [rtt] - s (undefined in Chrome)
 */
var SenderReport = /** @class */ (function (_super) {
    __extends(SenderReport, _super);
    /**
     * Construct a {@link SenderReport}.
     * @param {StatsId} id
     * @param {TrackId} trackId
     * @param {number} bitrate - bps
     * @param {number} [rtt] - s
     */
    function SenderReport(id, trackId, bitrate, rtt) {
        var _this = _super.call(this, id, trackId, bitrate) || this;
        Object.defineProperties(_this, {
            rtt: {
                enumerable: true,
                value: rtt
            }
        });
        return _this;
    }
    /**
     * Create a {@link SenderReport}.
     * @param {string} trackId
     * @param {RTCStats} olderStats
     * @param {RTCStats} newerStats
     * @param {RTCRemoteInboundRtpStreamStats} [newerRemoteStats]
     * @returns {SenderReport}
     */
    SenderReport.of = function (trackId, olderStats, newerStats, newerRemoteStats) {
        if (olderStats.id !== newerStats.id) {
            throw new Error('RTCStats IDs must match');
        }
        var secondsElapsed = (newerStats.timestamp - olderStats.timestamp) / 1000;
        var deltaBytesSent = newerStats.bytesSent - olderStats.bytesSent;
        var bitrate = secondsElapsed > 0
            ? (deltaBytesSent / secondsElapsed) * 8
            : 0;
        var rtt = newerRemoteStats && typeof newerRemoteStats.roundTripTime === 'number'
            ? newerRemoteStats.roundTripTime / 1000
            : undefined;
        return new SenderReport(olderStats.id, trackId, bitrate, rtt);
    };
    /**
     * Summarize {@link SenderReport}s by summing and averaging their values.
     * @param {Array<SenderReport>} reports
     * @returns {SenderSummary}
     */
    SenderReport.summarize = function (reports) {
        var bitrate = sum(reports.map(function (report) { return report.bitrate; }));
        var rtt = average(reports.map(function (report) { return report.rtt; }));
        return {
            bitrate: bitrate,
            rtt: rtt
        };
    };
    return SenderReport;
}(SenderOrReceiverReport));
module.exports = SenderReport;
//# sourceMappingURL=senderreport.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/senderreportfactory.js":
/*!********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/senderreportfactory.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var SenderOrReceiverReportFactory = __webpack_require__(/*! ./senderorreceiverreportfactory */ "../../work/twilio-video.js/es5/stats/senderorreceiverreportfactory.js");
var SenderReport = __webpack_require__(/*! ./senderreport */ "../../work/twilio-video.js/es5/stats/senderreport.js");
/**
 * @extends {SenderOrReceiverReportFactory}
 * @property {?SenderReport} lastReport
 */
var SenderReportFactory = /** @class */ (function (_super) {
    __extends(SenderReportFactory, _super);
    /**
     * Construct a {@link SenderReportFactory}.
     * @param {TrackId} trackId
     * @param {RTCStats} initialStats
     */
    function SenderReportFactory(trackId, initialStats) {
        var _this = _super.call(this, initialStats.id, trackId, initialStats) || this;
        Object.defineProperties(_this, {
            lastReport: {
                enumerable: true,
                value: null,
                writable: true
            }
        });
        return _this;
    }
    /**
     * @param {TrackId} trackId
     * @param {RTCStats} newerStats
     * @param {RTCRemoteInboundRtpStreamStats} [newerRemoteStats]
     * @returns {SenderReport}
     */
    SenderReportFactory.prototype.next = function (trackId, newerStats, newerRemoteStats) {
        var olderStats = this.lastStats;
        this.lastStats = newerStats;
        this.trackId = trackId;
        var report = SenderReport.of(trackId, olderStats, newerStats, newerRemoteStats);
        this.lastReport = report;
        return report;
    };
    return SenderReportFactory;
}(SenderOrReceiverReportFactory));
module.exports = SenderReportFactory;
//# sourceMappingURL=senderreportfactory.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/statsreport.js":
/*!************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/statsreport.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LocalAudioTrackStats = __webpack_require__(/*! ./localaudiotrackstats */ "../../work/twilio-video.js/es5/stats/localaudiotrackstats.js");
var LocalVideoTrackStats = __webpack_require__(/*! ./localvideotrackstats */ "../../work/twilio-video.js/es5/stats/localvideotrackstats.js");
var RemoteAudioTrackStats = __webpack_require__(/*! ./remoteaudiotrackstats */ "../../work/twilio-video.js/es5/stats/remoteaudiotrackstats.js");
var RemoteVideoTrackStats = __webpack_require__(/*! ./remotevideotrackstats */ "../../work/twilio-video.js/es5/stats/remotevideotrackstats.js");
/**
 * Statistics report for an RTCPeerConnection.
 * @property {string} peerConnectionId - ID of the RTCPeerConnection
 * @property {Array<LocalAudioTrackStats>} localAudioTrackStats - List of {@link LocalAudioTrackStats}
 * @property {Array<LocalVideoTrackStats>} localVideoTrackStats - List of {@link LocalVideoTrackStats}
 * @property {Array<RemoteAudioTrackStats>} remoteAudioTrackStats - List of {@link RemoteAudioTrackStats}
 * @property {Array<RemoteVideoTrackStats>} remoteVideoTrackStats - List of {@link RemoteVideoTrackStats}
 */
var StatsReport = /** @class */ (function () {
    /**
     * @param {string} peerConnectionId - RTCPeerConnection ID
     * @param {StandardizedStatsResponse} statsResponse
     * @param {boolean} prepareForInsights - if report is being prepared to send to insights.
     */
    function StatsReport(peerConnectionId, statsResponse, prepareForInsights) {
        if (typeof peerConnectionId !== 'string') {
            throw new Error('RTCPeerConnection id must be a string');
        }
        Object.defineProperties(this, {
            peerConnectionId: {
                value: peerConnectionId,
                enumerable: true
            },
            localAudioTrackStats: {
                value: statsResponse.localAudioTrackStats.map(function (report) { return new LocalAudioTrackStats(report.trackId, report, prepareForInsights); }),
                enumerable: true
            },
            localVideoTrackStats: {
                value: statsResponse.localVideoTrackStats.map(function (report) { return new LocalVideoTrackStats(report.trackId, report, prepareForInsights); }),
                enumerable: true
            },
            remoteAudioTrackStats: {
                value: statsResponse.remoteAudioTrackStats.map(function (report) { return new RemoteAudioTrackStats(report.trackId, report); }),
                enumerable: true
            },
            remoteVideoTrackStats: {
                value: statsResponse.remoteVideoTrackStats.map(function (report) { return new RemoteVideoTrackStats(report.trackId, report); }),
                enumerable: true
            }
        });
    }
    return StatsReport;
}());
module.exports = StatsReport;
//# sourceMappingURL=statsreport.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/sum.js":
/*!****************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/sum.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @param {Array<number|undefined>} xs
 * @returns {number}
 */
function sum(xs) {
    return xs.reduce(function (y, x) { return typeof x === 'number' ? x + y : y; }, 0);
}
module.exports = sum;
//# sourceMappingURL=sum.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/stats/trackstats.js":
/*!***********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/stats/trackstats.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Statistics for a {@link Track}.
 * @property {Track.ID} trackId - The {@link Track} ID
 * @property {Track.SID} trackSid - The {@link Track}'s SID when published in
 *  in a {@link Room}
 * @property {number} timestamp - A Unix timestamp in milliseconds indicating
 *   when the {@link TrackStats} were gathered
 * @property {string} ssrc - The {@link Track}'s SSRC when transmitted over the
 *   RTCPeerConnection
 * @property {?number} packetsLost - The number of packets lost
 * @property {?string} codec - The name of the codec used to encode the
 *   {@link Track}'s media
 */
var TrackStats = /** @class */ (function () {
    /**
     * @param {string} trackId - {@link Track} ID
     * @param {StandardizedTrackStatsReport} statsReport
     */
    function TrackStats(trackId, statsReport) {
        if (typeof trackId !== 'string') {
            throw new Error('Track id must be a string');
        }
        Object.defineProperties(this, {
            trackId: {
                value: trackId,
                enumerable: true
            },
            trackSid: {
                value: statsReport.trackSid,
                enumerable: true
            },
            timestamp: {
                value: statsReport.timestamp,
                enumerable: true
            },
            ssrc: {
                value: statsReport.ssrc,
                enumerable: true
            },
            packetsLost: {
                value: typeof statsReport.packetsLost === 'number'
                    ? statsReport.packetsLost
                    : null,
                enumerable: true
            },
            codec: {
                value: typeof statsReport.codecName === 'string'
                    ? statsReport.codecName
                    : null,
                enumerable: true
            }
        });
    }
    return TrackStats;
}());
module.exports = TrackStats;
//# sourceMappingURL=trackstats.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/transceiver.js":
/*!******************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/transceiver.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
/**
 * A {@link TrackTransceiver} represents either one or more local RTCRtpSenders
 * or RTCDataChannels, or a single RTCRtpReceiver or remote RTCDataChannel.
 * @extends EventEmitter
 * @property {Track.ID} id
 * @property {Track.kind} kind
 */
var TrackTransceiver = /** @class */ (function (_super) {
    __extends(TrackTransceiver, _super);
    /**
     * Construct a {@link TrackTransceiver}.
     * @param {Track.ID} id
     * @param {Track.kind} kind
     */
    function TrackTransceiver(id, kind) {
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            id: {
                enumerable: true,
                value: id
            },
            kind: {
                enumerable: true,
                value: kind
            }
        });
        return _this;
    }
    /**
     * Stop the {@link TrackTransceiver}.
     * #emits TrackTransceiver#stopped
     * @returns {void}
     */
    TrackTransceiver.prototype.stop = function () {
        this.emit('stopped');
    };
    return TrackTransceiver;
}(EventEmitter));
/**
 * The {@link TrackTransceiver} was stopped.
 * @event TrackTransceiver#stopped
 */
module.exports = TrackTransceiver;
//# sourceMappingURL=transceiver.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/twilioconnection.js":
/*!***********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/twilioconnection.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var StateMachine = __webpack_require__(/*! ./statemachine */ "../../work/twilio-video.js/es5/statemachine.js");
var _a = __webpack_require__(/*! ./util */ "../../work/twilio-video.js/es5/util/index.js"), buildLogLevels = _a.buildLogLevels, makeUUID = _a.makeUUID;
var Log = __webpack_require__(/*! ./util/log */ "../../work/twilio-video.js/es5/util/log.js");
var NetworkMonitor = __webpack_require__(/*! ./util/networkmonitor */ "../../work/twilio-video.js/es5/util/networkmonitor.js");
var Timeout = __webpack_require__(/*! ./util/timeout */ "../../work/twilio-video.js/es5/util/timeout.js");
var nInstances = 0;
/*
  TwilioConnection states
  -----------------------

       ------------------------------------------
       |                                        |
       |                                        v
  +---------+       +--------------+       +----------+
  |  early  | ----> |  connecting  | ----> |  closed  |
  +---------+       +--------------+       +----------+
    ^                     | ^ |                 ^ ^
    | --------------------- | |                 | |
    | | --------------------- |                 | |
    | | | --------------------|------------------ |
    | v | |                   v                   |
  +----------+           +--------+               |
  | waiting  | --------> |  open  | ---------------
  +----------+           +--------+
 */
var states = {
    closed: [],
    connecting: ['closed', 'open', 'waiting'],
    early: ['closed', 'connecting'],
    open: ['closed'],
    waiting: ['closed', 'connecting', 'early', 'open']
};
var events = {
    closed: 'close',
    open: 'open',
    waiting: 'waiting'
};
var TCMP_VERSION = 2;
var DEFAULT_MAX_CONSECUTIVE_MISSED_HEARTBEATS = 3;
var DEFAULT_MAX_CONSECUTIVE_FAILED_HELLOS = 3;
var DEFAULT_MAX_REQUESTED_HEARTBEAT_TIMEOUT = 5000;
var DEFAULT_OPEN_TIMEOUT = 15000;
var DEFAULT_WELCOME_TIMEOUT = 5000;
var OUTGOING_HEARTBEAT_OFFSET = 200;
var WS_CLOSE_NORMAL = 1000;
var WS_CLOSE_WELCOME_TIMEOUT = 3000;
var WS_CLOSE_HEARTBEATS_MISSED = 3001;
var WS_CLOSE_HELLO_FAILED = 3002;
var WS_CLOSE_SEND_FAILED = 3003;
var WS_CLOSE_NETWORK_CHANGED = 3004;
var WS_CLOSE_BUSY_WAIT = 3005;
var WS_CLOSE_SERVER_BUSY = 3006;
var WS_CLOSE_OPEN_TIMEOUT = 3007;
var toplevel = global.window || global;
var WebSocket = toplevel.WebSocket ? toplevel.WebSocket : __webpack_require__(/*! ws */ "../../work/twilio-video.js/src/ws.js");
var CloseReason = {
    BUSY: 'busy',
    FAILED: 'failed',
    LOCAL: 'local',
    REMOTE: 'remote',
    TIMEOUT: 'timeout'
};
var wsCloseCodesToCloseReasons = new Map([
    [WS_CLOSE_WELCOME_TIMEOUT, CloseReason.TIMEOUT],
    [WS_CLOSE_HEARTBEATS_MISSED, CloseReason.TIMEOUT],
    [WS_CLOSE_HELLO_FAILED, CloseReason.FAILED],
    [WS_CLOSE_SEND_FAILED, CloseReason.FAILED],
    [WS_CLOSE_NETWORK_CHANGED, CloseReason.TIMEOUT],
    [WS_CLOSE_SERVER_BUSY, CloseReason.BUSY],
    [WS_CLOSE_OPEN_TIMEOUT, CloseReason.TIMEOUT]
]);
/**
 * A {@link TwilioConnection} represents a WebSocket connection
 * to a Twilio Connections Messaging Protocol (TCMP) server.
 * @fires TwilioConnection#close
 * @fires TwilioConnection#error
 * @fires TwilioConnection#message
 * @fires TwilioConnection#open
 * @fires TwilioConnection#waiting
 */
var TwilioConnection = /** @class */ (function (_super) {
    __extends(TwilioConnection, _super);
    /**
     * Construct a {@link TwilioConnection}.
     * @param {string} serverUrl - TCMP server url
     * @param {TwilioConnectionOptions} options - {@link TwilioConnection} options
     */
    function TwilioConnection(serverUrl, options) {
        var _this = _super.call(this, 'early', states) || this;
        options = Object.assign({
            helloBody: null,
            maxConsecutiveFailedHellos: DEFAULT_MAX_CONSECUTIVE_FAILED_HELLOS,
            maxConsecutiveMissedHeartbeats: DEFAULT_MAX_CONSECUTIVE_MISSED_HEARTBEATS,
            requestedHeartbeatTimeout: DEFAULT_MAX_REQUESTED_HEARTBEAT_TIMEOUT,
            openTimeout: DEFAULT_OPEN_TIMEOUT,
            welcomeTimeout: DEFAULT_WELCOME_TIMEOUT,
            Log: Log,
            WebSocket: WebSocket
        }, options);
        var logLevels = buildLogLevels(options.logLevel);
        var log = new options.Log('default', _this, logLevels, options.loggerName);
        var networkMonitor = options.networkMonitor ? new NetworkMonitor(function () {
            var type = networkMonitor.type;
            var reason = "Network changed" + (type ? " to " + type : '');
            log.debug(reason);
            _this._close({ code: WS_CLOSE_NETWORK_CHANGED, reason: reason });
        }) : null;
        Object.defineProperties(_this, {
            _busyWaitTimeout: {
                value: null,
                writable: true
            },
            _consecutiveHeartbeatsMissed: {
                value: 0,
                writable: true
            },
            _cookie: {
                value: null,
                writable: true
            },
            _eventObserver: {
                value: options.eventObserver
            },
            _heartbeatTimeout: {
                value: null,
                writable: true
            },
            _hellosLeft: {
                value: options.maxConsecutiveFailedHellos,
                writable: true
            },
            _instanceId: {
                value: ++nInstances
            },
            _log: {
                value: log
            },
            _messageQueue: {
                value: []
            },
            _networkMonitor: {
                value: networkMonitor
            },
            _options: {
                value: options
            },
            _openTimeout: {
                value: null,
                writable: true
            },
            _sendHeartbeatTimeout: {
                value: null,
                writable: true
            },
            _serverUrl: {
                value: serverUrl
            },
            _welcomeTimeout: {
                value: null,
                writable: true
            },
            _ws: {
                value: null,
                writable: true
            }
        });
        var eventsToLevels = {
            connecting: 'info',
            early: 'info',
            open: 'info',
            waiting: 'warning',
            closed: 'info'
        };
        _this.on('stateChanged', function (state) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (state in events) {
                _this.emit.apply(_this, __spreadArray([events[state]], __read(args)));
            }
            var event = { name: state, group: 'signaling', level: eventsToLevels[_this.state] };
            if (state === 'closed') {
                var _a = __read(args, 1), reason = _a[0];
                event.payload = { reason: reason };
                event.level = reason === CloseReason.LOCAL ? 'info' : 'error';
            }
            _this._eventObserver.emit('event', event);
        });
        _this._eventObserver.emit('event', { name: _this.state, group: 'signaling', level: eventsToLevels[_this.state] });
        _this._connect();
        return _this;
    }
    TwilioConnection.prototype.toString = function () {
        return "[TwilioConnection #" + this._instanceId + ": " + this._ws.url + "]";
    };
    /**
     * Close the {@link TwilioConnection}.
     * @param {{code: number, reason: string}} event
     * @private
     */
    TwilioConnection.prototype._close = function (_a) {
        var code = _a.code, reason = _a.reason;
        if (this.state === 'closed') {
            return;
        }
        if (this._openTimeout) {
            this._openTimeout.clear();
        }
        if (this._welcomeTimeout) {
            this._welcomeTimeout.clear();
        }
        if (this._heartbeatTimeout) {
            this._heartbeatTimeout.clear();
        }
        if (this._sendHeartbeatTimeout) {
            this._sendHeartbeatTimeout.clear();
        }
        if (this._networkMonitor) {
            this._networkMonitor.stop();
        }
        if (this._busyWaitTimeout && code !== WS_CLOSE_BUSY_WAIT) {
            this._busyWaitTimeout.clear();
        }
        this._messageQueue.splice(0);
        var log = this._log;
        if (code === WS_CLOSE_NORMAL) {
            log.debug('Closed');
            this.transition('closed', null, [CloseReason.LOCAL]);
        }
        else {
            log.warn("Closed: " + code + " - " + reason);
            if (code !== WS_CLOSE_BUSY_WAIT) {
                this.transition('closed', null, [
                    wsCloseCodesToCloseReasons.get(code) || CloseReason.REMOTE
                ]);
            }
        }
        var readyState = this._ws.readyState;
        var WebSocket = this._options.WebSocket;
        if (readyState !== WebSocket.CLOSING && readyState !== WebSocket.CLOSED) {
            this._ws.close(code, reason);
        }
    };
    /**
     * Connect to the TCMP server.
     * @private
     */
    TwilioConnection.prototype._connect = function () {
        var _this = this;
        var log = this._log;
        if (this.state === 'waiting') {
            this.transition('early');
        }
        else if (this.state !== 'early') {
            log.warn("Unexpected state \"" + this.state + "\" for connecting to the"
                + ' TCMP server.');
            return;
        }
        this._ws = new this._options.WebSocket(this._serverUrl);
        var ws = this._ws;
        log.debug('Created a new WebSocket:', ws);
        ws.addEventListener('close', function (event) { return _this._close(event); });
        var openTimeout = this._options.openTimeout;
        // Add a timeout for getting the onopen event on the WebSocket (15 sec). After that, attempt to reconnect only if this is not the first attempt.
        this._openTimeout = new Timeout(function () {
            var reason = "Failed to open in " + openTimeout + " ms";
            _this._close({ code: WS_CLOSE_OPEN_TIMEOUT, reason: reason });
        }, openTimeout);
        ws.addEventListener('open', function () {
            log.debug('WebSocket opened:', ws);
            _this._openTimeout.clear();
            _this._startHandshake();
            if (_this._networkMonitor) {
                _this._networkMonitor.start();
            }
        });
        ws.addEventListener('message', function (message) {
            log.debug("Incoming: " + message.data);
            try {
                message = JSON.parse(message.data);
            }
            catch (error) {
                _this.emit('error', error);
                return;
            }
            switch (message.type) {
                case 'bad':
                    _this._handleBad(message);
                    break;
                case 'busy':
                    _this._handleBusy(message);
                    break;
                case 'bye':
                    // Do nothing.
                    break;
                case 'msg':
                    _this._handleMessage(message);
                // NOTE(mpatwardhan): Each incoming message should be treated as an incoming
                // heartbeat intentionally falling through to 'heartbeat' case.
                // eslint-disable-next-line no-fallthrough
                case 'heartbeat':
                    _this._handleHeartbeat();
                    break;
                case 'welcome':
                    _this._handleWelcome(message);
                    break;
                default:
                    _this._log.debug("Unknown message type: " + message.type);
                    _this.emit('error', new Error("Unknown message type: " + message.type));
                    break;
            }
        });
    };
    /**
     * Handle an incoming "bad" message.
     * @param {{reason: string}} message
     * @private
     */
    TwilioConnection.prototype._handleBad = function (_a) {
        var reason = _a.reason;
        var log = this._log;
        if (!['connecting', 'open'].includes(this.state)) {
            log.warn("Unexpected state \"" + this.state + "\" for handling a \"bad\" message"
                + ' from the TCMP server.');
            return;
        }
        if (this.state === 'connecting') {
            log.warn("Closing: " + WS_CLOSE_HELLO_FAILED + " - " + reason);
            this._close({ code: WS_CLOSE_HELLO_FAILED, reason: reason });
            return;
        }
        log.debug("Error: " + reason);
        this.emit('error', new Error(reason));
    };
    /**
     * Handle an incoming "busy" message.
     * @param {{cookie: ?string, keepAlive: boolean, retryAfter: number}} message
     * @private
     */
    TwilioConnection.prototype._handleBusy = function (_a) {
        var _this = this;
        var cookie = _a.cookie, keepAlive = _a.keepAlive, retryAfter = _a.retryAfter;
        var log = this._log;
        if (!['connecting', 'waiting'].includes(this.state)) {
            log.warn("Unexpected state \"" + this.state + "\" for handling a \"busy\" message"
                + ' from the TCMP server.');
            return;
        }
        if (this._busyWaitTimeout) {
            this._busyWaitTimeout.clear();
        }
        if (this._welcomeTimeout) {
            this._welcomeTimeout.clear();
        }
        var reason = retryAfter < 0
            ? 'Received terminal "busy" message'
            : "Received \"busy\" message, retrying after " + retryAfter + " ms";
        if (retryAfter < 0) {
            log.warn("Closing: " + WS_CLOSE_SERVER_BUSY + " - " + reason);
            this._close({ code: WS_CLOSE_SERVER_BUSY, reason: reason });
            return;
        }
        var maxConsecutiveFailedHellos = this._options.maxConsecutiveFailedHellos;
        this._hellosLeft = maxConsecutiveFailedHellos;
        this._cookie = cookie || null;
        if (keepAlive) {
            log.warn(reason);
            this._busyWaitTimeout = new Timeout(function () { return _this._startHandshake(); }, retryAfter);
        }
        else {
            log.warn("Closing: " + WS_CLOSE_BUSY_WAIT + " - " + reason);
            this._close({ code: WS_CLOSE_BUSY_WAIT, reason: reason });
            this._busyWaitTimeout = new Timeout(function () { return _this._connect(); }, retryAfter);
        }
        this.transition('waiting', null, [keepAlive, retryAfter]);
    };
    /**
     * Handle an incoming "heartbeat" message.
     * @private
     */
    TwilioConnection.prototype._handleHeartbeat = function () {
        if (this.state !== 'open') {
            this._log.warn("Unexpected state \"" + this.state + "\" for handling a \"heartbeat\""
                + ' message from the TCMP server.');
            return;
        }
        this._heartbeatTimeout.reset();
    };
    /**
     * Handle a missed "heartbeat" message.
     * @private
     */
    TwilioConnection.prototype._handleHeartbeatTimeout = function () {
        if (this.state !== 'open') {
            return;
        }
        var log = this._log;
        var maxConsecutiveMissedHeartbeats = this._options.maxConsecutiveMissedHeartbeats;
        log.debug("Consecutive heartbeats missed: " + maxConsecutiveMissedHeartbeats);
        var reason = "Missed " + maxConsecutiveMissedHeartbeats + " \"heartbeat\" messages";
        log.warn("Closing: " + WS_CLOSE_HEARTBEATS_MISSED + " - " + reason);
        this._close({ code: WS_CLOSE_HEARTBEATS_MISSED, reason: reason });
    };
    /**
     * Handle an incoming "msg" message.
     * @param {{body: object}} message
     * @private
     */
    TwilioConnection.prototype._handleMessage = function (_a) {
        var body = _a.body;
        if (this.state !== 'open') {
            this._log.warn("Unexpected state \"" + this.state + "\" for handling a \"msg\" message"
                + ' from the TCMP server.');
            return;
        }
        this.emit('message', body);
    };
    /**
     * Handle an incoming "welcome" message.
     * @param {{ negotiatedTimeout: number }} message
     * @private
     */
    TwilioConnection.prototype._handleWelcome = function (_a) {
        var _this = this;
        var negotiatedTimeout = _a.negotiatedTimeout;
        var log = this._log;
        if (!['connecting', 'waiting'].includes(this.state)) {
            log.warn("Unexpected state \"" + this.state + "\" for handling a \"welcome\""
                + ' message from the TCMP server.');
            return;
        }
        if (this.state === 'waiting') {
            log.debug('Received "welcome" message, no need to retry connection.');
            this._busyWaitTimeout.clear();
        }
        var maxConsecutiveMissedHeartbeats = this._options.maxConsecutiveMissedHeartbeats;
        var heartbeatTimeout = negotiatedTimeout * maxConsecutiveMissedHeartbeats;
        var outgoingHeartbeatTimeout = negotiatedTimeout - OUTGOING_HEARTBEAT_OFFSET;
        this._welcomeTimeout.clear();
        this._heartbeatTimeout = new Timeout(function () { return _this._handleHeartbeatTimeout(); }, heartbeatTimeout);
        this._messageQueue.splice(0).forEach(function (message) { return _this._send(message); });
        this._sendHeartbeatTimeout = new Timeout(function () { return _this._sendHeartbeat(); }, outgoingHeartbeatTimeout);
        this.transition('open');
    };
    /**
     * Handle a missed "welcome" message.
     * @private
     */
    TwilioConnection.prototype._handleWelcomeTimeout = function () {
        if (this.state !== 'connecting') {
            return;
        }
        var log = this._log;
        if (this._hellosLeft <= 0) {
            var reason = 'All handshake attempts failed';
            log.warn("Closing: " + WS_CLOSE_WELCOME_TIMEOUT + " - " + reason);
            this._close({ code: WS_CLOSE_WELCOME_TIMEOUT, reason: reason });
            return;
        }
        var maxConsecutiveFailedHellos = this._options.maxConsecutiveFailedHellos;
        log.warn("Handshake attempt " + (maxConsecutiveFailedHellos - this._hellosLeft) + " failed");
        this._startHandshake();
    };
    /**
     * Send a message to the TCMP server.
     * @param {*} message
     * @private
     */
    TwilioConnection.prototype._send = function (message) {
        var readyState = this._ws.readyState;
        var WebSocket = this._options.WebSocket;
        if (readyState === WebSocket.OPEN) {
            var data = JSON.stringify(message);
            this._log.debug("Outgoing: " + data);
            try {
                this._ws.send(data);
                if (this._sendHeartbeatTimeout) {
                    // Each outgoing message is to be treated as an outgoing heartbeat.
                    this._sendHeartbeatTimeout.reset();
                }
            }
            catch (error) {
                var reason = 'Failed to send message';
                this._log.warn("Closing: " + WS_CLOSE_SEND_FAILED + " - " + reason);
                this._close({ code: WS_CLOSE_SEND_FAILED, reason: reason });
            }
        }
    };
    /**
     * Send a "heartbeat" message.
     * @private
     */
    TwilioConnection.prototype._sendHeartbeat = function () {
        if (this.state === 'closed') {
            return;
        }
        this._send({ type: 'heartbeat' });
    };
    /**
     * Send a "hello" message.
     * @private
     */
    TwilioConnection.prototype._sendHello = function () {
        var _a = this._options, helloBody = _a.helloBody, timeout = _a.requestedHeartbeatTimeout;
        var hello = {
            id: makeUUID(),
            timeout: timeout,
            type: 'hello',
            version: TCMP_VERSION
        };
        if (this._cookie) {
            hello.cookie = this._cookie;
        }
        if (helloBody) {
            hello.body = helloBody;
        }
        this._send(hello);
    };
    /**
     * Send or enqueue a message.
     * @param {*} message
     * @private
     */
    TwilioConnection.prototype._sendOrEnqueue = function (message) {
        var _this = this;
        if (this.state === 'closed') {
            return;
        }
        var sendOrEnqueue = this.state === 'open'
            ? function (message) { return _this._send(message); }
            : function (message) { return _this._messageQueue.push(message); };
        sendOrEnqueue(message);
    };
    /**
     * Start the TCMP handshake.
     * @private
     */
    TwilioConnection.prototype._startHandshake = function () {
        var _this = this;
        if (['early', 'waiting'].includes(this.state)) {
            this.transition('connecting');
        }
        if (this.state !== 'connecting') {
            return;
        }
        this._hellosLeft--;
        this._sendHello();
        var welcomeTimeout = this._options.welcomeTimeout;
        this._welcomeTimeout = new Timeout(function () { return _this._handleWelcomeTimeout(); }, welcomeTimeout);
    };
    /**
     * Close the {@link TwilioConnection}.
     * @returns {void}
     */
    TwilioConnection.prototype.close = function () {
        if (this.state === 'closed') {
            return;
        }
        this._sendOrEnqueue({ type: 'bye' });
        this._close({ code: WS_CLOSE_NORMAL, reason: 'Normal' });
    };
    /**
     * Send a "msg" message.
     * @param {*} body
     * @returns {void}
     */
    TwilioConnection.prototype.sendMessage = function (body) {
        this._sendOrEnqueue({ body: body, type: 'msg' });
    };
    return TwilioConnection;
}(StateMachine));
/**
 * A unique string depicting the reason for the {@link TwilioConnection} being closed.
 * @enum {string}
 */
TwilioConnection.CloseReason = CloseReason;
/**
 * A {@link TwilioConnection} was closed.
 * @event TwilioConnection#close
 * @param {CloseReason} reason - The reason for the {@link TwilioConnection} being closed
 */
/**
 * A {@link TwilioConnection} received an error from the TCMP server.
 * @event TwilioConnection#error
 * @param {Error} error - The TCMP server error
 */
/**
 * A {@link TwilioConnection} received a message from the TCMP server.
 * @event TwilioConnection#message
 * @param {*} body - Message body
 */
/**
 * A {@link TwilioConnection} completed a hello/welcome handshake with the TCMP server.
 * @event TwilioConnection#open
 */
/**
 * A {@link TwilioConnection} received a "busy" message from the TCMP server.
 * @event TwilioConnection#waiting
 * @param {boolean} keepAlive - true if the WebSocket connection is retained
 * @param {number} retryAfter - delay in milliseconds after which a retry is attempted
 */
/**
 * {@link TwilioConnection} options
 * @typedef {object} TwilioConnectionOptions
 * @property {EventObserver} [eventObserver] - Optional event observer
 * @property {*} [helloBody=null] - Optional body for "hello" message
 * @property {LogLevel} [logLevel=warn] - Log level of the {@link TwilioConnection}
 * @property {number} [maxConsecutiveFailedHellos=3] - Max. number of consecutive failed "hello"s
 * @property {number} [maxConsecutiveMissedHeartbeats=3] - Max. number of (effective) consecutive "heartbeat" messages that can be missed
 * @property {number} [requestedHeartbeatTimeout=5000] - "heartbeat" timeout (ms) requested by the {@link TwilioConnection}
 * @property {number} [welcomeTimeout=5000] - Time (ms) to wait for the "welcome" message after sending the "hello" message
 */
module.exports = TwilioConnection;
//# sourceMappingURL=twilioconnection.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../personal/twilio-video-api/node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/asyncvar.js":
/*!********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/asyncvar.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var defer = __webpack_require__(/*! ./ */ "../../work/twilio-video.js/es5/util/index.js").defer;
/**
 * An {@link AsyncVar} is an "asynchronous variable" which may or may not
 * contain a value of some type T. You can put a value into the {@link AsyncVar}
 * with {@link AsyncVar#put}. Callers can take a value out of the
 * {@link AsyncVar} by queueing up with {@link AsyncVar#take}. N calls to
 * {@link AsyncVar#take} require N calls to {@link AsyncVar#put} to resolve, and
 * they resolve in order.
 */
var AsyncVar = /** @class */ (function () {
    /**
     * Construct an {@link AsyncVar}.
     */
    function AsyncVar() {
        Object.defineProperties(this, {
            _deferreds: {
                value: []
            },
            _hasValue: {
                value: false,
                writable: true
            },
            _value: {
                value: null,
                writable: true
            }
        });
    }
    /**
     * Put a value into the {@link AsyncVar}.
     * @param {T} value
     * @returns {this}
     */
    AsyncVar.prototype.put = function (value) {
        this._hasValue = true;
        this._value = value;
        var deferred = this._deferreds.shift();
        if (deferred) {
            deferred.resolve(value);
        }
        return this;
    };
    /**
     * Take the value out of the {@link AsyncVar}.
     * @returns {Promise<T>}
     */
    AsyncVar.prototype.take = function () {
        var _this = this;
        if (this._hasValue && !this._deferreds.length) {
            this._hasValue = false;
            return Promise.resolve(this._value);
        }
        var deferred = defer();
        this._deferreds.push(deferred);
        return deferred.promise.then(function (value) {
            _this._hasValue = false;
            return value;
        });
    };
    return AsyncVar;
}());
module.exports = AsyncVar;
//# sourceMappingURL=asyncvar.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/cancelablepromise.js":
/*!*****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/cancelablepromise.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
/**
 * A Promise that can be canceled with {@link CancelablePromise#cancel}.
 * @extends Promise
*/
var CancelablePromise = /** @class */ (function () {
    /**
     * Construct a new {@link CancelablePromise}.
     * @param {CancelablePromise.OnCreate} onCreate
     * @param {CancelablePromise.OnCancel} onCancel
    */ /**
     * A function to be called on {@link CancelablePromise} creation
     * @typedef {function} CancelablePromise.OnCreate
     * @param {function(*)} resolve
     * @param {function(*)} reject
     * @param {function(): boolean} isCanceled
    */ /**
     * A function to be called when {@link CancelablePromise#cancel} is called
     * @typedef {function} CancelablePromise.OnCancel
     */
    function CancelablePromise(onCreate, onCancel) {
        var _this = this;
        /* istanbul ignore next */
        Object.defineProperties(this, {
            _isCancelable: {
                writable: true,
                value: true
            },
            _isCanceled: {
                writable: true,
                value: false
            },
            _onCancel: {
                value: onCancel
            }
        });
        Object.defineProperty(this, '_promise', {
            value: new Promise(function (resolve, reject) {
                onCreate(function (value) {
                    _this._isCancelable = false;
                    resolve(value);
                }, function (reason) {
                    _this._isCancelable = false;
                    reject(reason);
                }, function () { return _this._isCanceled; });
            })
        });
    }
    /**
     * Create a synchronously-rejected {@link CancelablePromise}.
     * @param {*} reason
     * @returns {Promise<*>}
     */
    CancelablePromise.reject = function (reason) {
        return new CancelablePromise(function rejected(resolve, reject) {
            reject(reason);
        }, function onCancel() {
            // Do nothing.
        });
    };
    /**
     * Create a synchronously-resolved {@link CancelablePromise}.
     * @param {*|Promise<*>|Thenable<*>} result
     * @returns {CancelablePromise<*>}
     */
    CancelablePromise.resolve = function (result) {
        return new CancelablePromise(function resolved(resolve) {
            resolve(result);
        }, function onCancel() {
            // Do nothing.
        });
    };
    /**
     * Attempt to cancel the {@link CancelablePromise}.
     * @returns {this}
     */
    CancelablePromise.prototype.cancel = function () {
        if (this._isCancelable) {
            this._isCanceled = true;
            this._onCancel();
        }
        return this;
    };
    /**
     * @param {function} onRejected
     * @returns {CancelablePromise}
     */
    CancelablePromise.prototype.catch = function () {
        var args = [].slice.call(arguments);
        var promise = this._promise;
        return new CancelablePromise(function onCreate(resolve, reject) {
            promise.catch.apply(promise, __spreadArray([], __read(args))).then(resolve, reject);
        }, this._onCancel);
    };
    /**
     * @param {?function} onResolved
     * @param {function} [onRejected]
     * @returns {CancelablePromise}
     */
    CancelablePromise.prototype.then = function () {
        var args = [].slice.call(arguments);
        var promise = this._promise;
        return new CancelablePromise(function onCreate(resolve, reject) {
            promise.then.apply(promise, __spreadArray([], __read(args))).then(resolve, reject);
        }, this._onCancel);
    };
    return CancelablePromise;
}());
module.exports = CancelablePromise;
//# sourceMappingURL=cancelablepromise.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/constants.js":
/*!*********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/constants.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports.DEFAULT_ENVIRONMENT = 'prod';
module.exports.DEFAULT_REALM = 'us1';
module.exports.DEFAULT_REGION = 'gll';
module.exports.DEFAULT_LOG_LEVEL = 'warn';
module.exports.DEFAULT_LOGGER_NAME = 'twilio-video';
module.exports.WS_SERVER = function (environment, region) {
    region = region === 'gll' ? 'global' : encodeURIComponent(region);
    return environment === 'prod'
        ? "wss://" + region + ".vss.twilio.com/signaling"
        : "wss://" + region + ".vss." + environment + ".twilio.com/signaling";
};
module.exports.PUBLISH_MAX_ATTEMPTS = 5;
module.exports.PUBLISH_BACKOFF_JITTER = 10;
module.exports.PUBLISH_BACKOFF_MS = 20;
/**
 * Returns the appropriate indefinite article ("a" | "an").
 * @param {string} word - The word which determines whether "a" | "an" is returned
 * @returns {string} "a" if word's first letter is a vowel, "an" otherwise
 */
function article(word) {
    // NOTE(mmalavalli): This will not be accurate for words like "hour",
    // which have consonants as their first character, but are pronounced like
    // vowels. We can address this issue if the need arises.
    return ['a', 'e', 'i', 'o', 'u'].includes(word.toLowerCase()[0]) ? 'an' : 'a';
}
module.exports.typeErrors = {
    ILLEGAL_INVOKE: function (name, context) {
        return new TypeError("Illegal call to " + name + ": " + context);
    },
    INVALID_TYPE: function (name, type) {
        return new TypeError(name + " must be " + article(type) + " " + type);
    },
    INVALID_VALUE: function (name, values) {
        return new RangeError(name + " must be one of " + values.join(', '));
    },
    REQUIRED_ARGUMENT: function (name) {
        return new TypeError(name + " must be specified");
    }
};
module.exports.DEFAULT_FRAME_RATE = 24;
module.exports.DEFAULT_VIDEO_PROCESSOR_STATS_INTERVAL_MS = 10000;
module.exports.DEFAULT_ICE_GATHERING_TIMEOUT_MS = 15000;
module.exports.DEFAULT_SESSION_TIMEOUT_SEC = 30;
module.exports.DEFAULT_NQ_LEVEL_LOCAL = 1;
module.exports.DEFAULT_NQ_LEVEL_REMOTE = 0;
module.exports.MAX_NQ_LEVEL = 3;
module.exports.ICE_ACTIVITY_CHECK_PERIOD_MS = 1000;
module.exports.ICE_INACTIVITY_THRESHOLD_MS = 3000;
module.exports.iceRestartBackoffConfig = {
    factor: 1.1,
    initialDelay: 1,
    maxDelay: module.exports.DEFAULT_SESSION_TIMEOUT_SEC * 1000,
    randomisationFactor: 0.5
};
module.exports.reconnectBackoffConfig = {
    factor: 1.5,
    initialDelay: 80,
    randomisationFactor: 0.5
};
module.exports.subscriptionMode = {
    MODE_COLLABORATION: 'collaboration',
    MODE_GRID: 'grid',
    MODE_PRESENTATION: 'presentation'
};
module.exports.trackSwitchOffMode = {
    MODE_DISABLED: 'disabled',
    MODE_DETECTED: 'detected',
    MODE_PREDICTED: 'predicted'
};
module.exports.trackPriority = {
    PRIORITY_HIGH: 'high',
    PRIORITY_LOW: 'low',
    PRIORITY_STANDARD: 'standard'
};
module.exports.clientTrackSwitchOffControl = {
    MODE_AUTO: 'auto',
    MODE_MANUAL: 'manual'
};
module.exports.videoContentPreferencesMode = {
    MODE_AUTO: 'auto',
    MODE_MANUAL: 'manual'
};
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/detectsilentaudio.js":
/*!*****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/detectsilentaudio.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var detectSilence = __webpack_require__(/*! ../webaudio/detectsilence */ "../../work/twilio-video.js/es5/webaudio/detectsilence.js");
var N_ATTEMPTS = 3;
var ATTEMPT_DURATION_MS = 250;
/**
 * Detect whether the audio stream rendered by the given HTMLVideoElement is silent.
 * @param {HTMLAudioElement} el
 * @returns {Promise<boolean>} true if silent, false if not.
 */
function detectSilentAudio(el) {
    // NOTE(mmalavalli): We have to delay require-ing AudioContextFactory, because
    // it exports a default instance whose constructor calls Object.assign.
    var AudioContextFactory = __webpack_require__(/*! ../webaudio/audiocontext */ "../../work/twilio-video.js/es5/webaudio/audiocontext.js");
    var holder = {};
    var audioContext = AudioContextFactory.getOrCreate(holder);
    var attemptsLeft = N_ATTEMPTS;
    function doCheckSilence() {
        attemptsLeft--;
        return detectSilence(audioContext, el.srcObject, ATTEMPT_DURATION_MS).then(function (isSilent) {
            if (!isSilent) {
                return false;
            }
            if (attemptsLeft > 0) {
                return doCheckSilence();
            }
            return true;
        }).catch(function () {
            // NOTE(mmalavalli): If an error is thrown while detect silence, the audio
            // stream is assumed to be silent.
            return true;
        });
    }
    // Resolve the returned Promise with true if 3 consecutive attempts
    // to detect silent audio are successful.
    return doCheckSilence().finally(function () {
        AudioContextFactory.release(holder);
    });
}
module.exports = detectSilentAudio;
//# sourceMappingURL=detectsilentaudio.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/detectsilentvideo.js":
/*!*****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/detectsilentvideo.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Cached copy of the <canvas> used to check silent video frames.
var canvas = null;
var N_SAMPLES = 3;
var SAMPLE_HEIGHT = 50;
var SAMPLE_INTERVAL_MS = 250;
var SAMPLE_WIDTH = 50;
/**
 * Check whether the current video frame is silent by selecting a 50x50
 * sample and calculating the max value of the pixel data. If it is 0, then
 * the frame is considered to be silent.
 * @private
 * @param {HTMLVideoElement} el
 * @returns {boolean} true if silent, false if not
 */
function checkSilence(el) {
    try {
        var context = canvas.getContext('2d');
        context.drawImage(el, 0, 0, SAMPLE_WIDTH, SAMPLE_HEIGHT);
        var frame = context.getImageData(0, 0, SAMPLE_WIDTH, SAMPLE_HEIGHT);
        var frameDataWithoutAlpha = frame.data.filter(function (item, i) { return (i + 1) % 4; });
        var max = Math.max.apply(Math, frameDataWithoutAlpha);
        return max === 0;
    }
    catch (ex) {
        // eslint-disable-next-line no-console
        console.log('Error checking silence: ', ex);
        return false;
    }
}
/**
 * Detect whether the video stream rendered by the given HTMLVideoElement is silent.
 * @param {HTMLVideoElement} el
 * @returns {Promise<boolean>} true if silent, false if not.
 */
function detectSilentVideo(el) {
    // Create the canvas when detectSilentVideo() is called for the
    // first time.
    canvas = canvas || document.createElement('canvas');
    // Resolve the returned Promise with true if 3 consecutive sample
    // frames from the video being played by the HTMLVideoElement are
    // silent.
    return new Promise(function (resolve) {
        var samplesLeft = N_SAMPLES;
        setTimeout(function doCheckSilence() {
            samplesLeft--;
            if (!checkSilence(el)) {
                return resolve(false);
            }
            if (samplesLeft > 0) {
                return setTimeout(doCheckSilence, SAMPLE_INTERVAL_MS);
            }
            return resolve(true);
        }, SAMPLE_INTERVAL_MS);
    });
}
module.exports = detectSilentVideo;
//# sourceMappingURL=detectsilentvideo.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/documentvisibilitymonitor.js":
/*!*************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/documentvisibilitymonitor.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * The {@link DocumentVisibilityMonitor} monitors the visibility state of the DOM
 * and executes the attached listeners in phase order when the DOM is visible.
 */
var DocumentVisibilityMonitor = /** @class */ (function () {
    /**
     * Constructor.
     * @param {number} [nPhases=1] - the number of phases
     */
    function DocumentVisibilityMonitor(nPhases) {
        var _this = this;
        if (nPhases === void 0) { nPhases = 1; }
        Object.defineProperties(this, {
            _listeners: {
                value: []
            },
            _onVisibilityChange: {
                value: function () {
                    _this._emitVisible(document.visibilityState === 'visible');
                }
            }
        });
        for (var i = 0; i < nPhases; i++) {
            this._listeners.push([]);
        }
    }
    /**
     * clears the state.
     */
    DocumentVisibilityMonitor.prototype.clear = function () {
        var nPhases = this._listeners.length;
        for (var i = 0; i < nPhases; i++) {
            this._listeners[i] = [];
        }
    };
    DocumentVisibilityMonitor.prototype._listenerCount = function () {
        return this._listeners.reduce(function (count, phaseListeners) { return count + phaseListeners.length; }, 0);
    };
    /**
     * Call all the listeners. Makes sure that all listeners for a given phase
     * are executed before calling the listeners of the next phase.
     * @private
     */
    DocumentVisibilityMonitor.prototype._emitVisible = function (isVisible) {
        var _this = this;
        var promise = Promise.resolve();
        var _loop_1 = function (phase) {
            promise = promise.then(function () { return _this._emitVisiblePhase(phase, isVisible); });
        };
        for (var phase = 1; phase <= this._listeners.length; phase++) {
            _loop_1(phase);
        }
        return promise;
    };
    /**
     * Call all the listeners for a given phase.
     * @private
     */
    DocumentVisibilityMonitor.prototype._emitVisiblePhase = function (phase, isVisible) {
        var phaseListeners = this._listeners[phase - 1];
        return Promise.all(phaseListeners.map(function (listener) {
            var ret = listener(isVisible);
            return ret instanceof Promise ? ret : Promise.resolve(ret);
        }));
    };
    /**
     * Start listening to the DOM visibility state change.
     * @private
     */
    DocumentVisibilityMonitor.prototype._start = function () {
        document.addEventListener('visibilitychange', this._onVisibilityChange);
    };
    /**
     * Stop listening to the DOM visibility state change.
     * @private
     */
    DocumentVisibilityMonitor.prototype._stop = function () {
        document.removeEventListener('visibilitychange', this._onVisibilityChange);
    };
    /**
     * Listen for the DOM visibility changes at the given phase.
     * @param {number} phase
     * @param {function} listener
     * @returns {this}
     */
    DocumentVisibilityMonitor.prototype.onVisibilityChange = function (phase, listener) {
        if (typeof phase !== 'number' || phase <= 0 || phase > this._listeners.length) {
            throw new Error('invalid phase: ', phase);
        }
        var phaseListeners = this._listeners[phase - 1];
        phaseListeners.push(listener);
        if (this._listenerCount() === 1) {
            this._start();
        }
        return this;
    };
    /**
     * Stop listening for the DOM visibility change at the given phase.
     * @param {number} phase
     * @param {function} listener
     * @returns {this}
     */
    DocumentVisibilityMonitor.prototype.offVisibilityChange = function (phase, listener) {
        if (typeof phase !== 'number' || phase <= 0 || phase > this._listeners.length) {
            throw new Error('invalid phase: ', phase);
        }
        var phaseListeners = this._listeners[phase - 1];
        var index = phaseListeners.indexOf(listener);
        if (index !== -1) {
            phaseListeners.splice(index, 1);
            if (this._listenerCount() === 0) {
                this._stop();
            }
        }
        return this;
    };
    return DocumentVisibilityMonitor;
}());
module.exports = new DocumentVisibilityMonitor(2);
//# sourceMappingURL=documentvisibilitymonitor.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/eventobserver.js":
/*!*************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/eventobserver.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable no-console */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var VALID_GROUPS = [
    'signaling',
    'room',
    'media',
    'quality',
    'video-processor'
];
var VALID_LEVELS = [
    'debug',
    'error',
    'info',
    'warning'
];
/**
 * EventObserver listens to SDK events and re-emits them on the
 * @link EventListener} with some additional information.
 * @extends EventEmitter
 * @emits EventObserver#event
 */
var EventObserver = /** @class */ (function (_super) {
    __extends(EventObserver, _super);
    /**
     * Constructor.
     * @param {number} connectTimestamp
     * @param {Log} log
     * @param {EventListener} [eventListener]
     */
    function EventObserver(connectTimestamp, log, eventListener) {
        if (eventListener === void 0) { eventListener = null; }
        var _this = _super.call(this) || this;
        Object.defineProperties(_this, {
            _publisher: {
                value: null,
                writable: true
            }
        });
        _this.on('event', function (_a) {
            var name = _a.name, group = _a.group, level = _a.level, payload = _a.payload;
            if (typeof name !== 'string') {
                throw new Error('Unexpected name: ', name);
            }
            if (!VALID_GROUPS.includes(group)) {
                throw new Error('Unexpected group: ', group);
            }
            if (!VALID_LEVELS.includes(level)) {
                throw new Error('Unexpected level: ', level);
            }
            var timestamp = Date.now();
            var elapsedTime = timestamp - connectTimestamp;
            if (_this._publisher) {
                var publisherPayload = Object.assign({ elapsedTime: elapsedTime, level: level }, payload ? payload : {});
                _this._publisher.publish(group, name, publisherPayload);
            }
            var event = Object.assign({
                elapsedTime: elapsedTime,
                group: group,
                level: level,
                name: name,
                timestamp: timestamp
            }, payload ? { payload: payload } : {});
            var logLevel = {
                debug: 'debug',
                error: 'error',
                info: 'info',
                warning: 'warn',
            }[level];
            log[logLevel]('event', event);
            if (eventListener && group === 'signaling') {
                eventListener.emit('event', event);
            }
        });
        return _this;
    }
    /**
     * sets the publisher object. Once set events will be sent to publisher.
     * @param {InsightsPublisher} publisher
    */
    EventObserver.prototype.setPublisher = function (publisher) {
        this._publisher = publisher;
    };
    return EventObserver;
}(EventEmitter));
/**
 * An SDK event.
 * @event EventObserver#event
 * @param {{name: string, payload: *}} event
 */
module.exports = EventObserver;
//# sourceMappingURL=eventobserver.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/filter.js":
/*!******************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/filter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Filter = /** @class */ (function () {
    function Filter(options) {
        options = Object.assign({
            getKey: function defaultGetKey(a) { return a; },
            getValue: function defaultGetValue(a) { return a; },
            isLessThanOrEqualTo: function defaultIsLessThanOrEqualTo(a, b) { return a <= b; }
        }, options);
        Object.defineProperties(this, {
            _getKey: {
                value: options.getKey
            },
            _getValue: {
                value: options.getValue
            },
            _isLessThanOrEqualTo: {
                value: options.isLessThanOrEqualTo
            },
            _map: {
                value: new Map()
            }
        });
    }
    Filter.prototype.toMap = function () {
        return new Map(this._map);
    };
    Filter.prototype.updateAndFilter = function (entries) {
        return entries.filter(this.update, this);
    };
    Filter.prototype.update = function (entry) {
        var key = this._getKey(entry);
        var value = this._getValue(entry);
        if (this._map.has(key) &&
            this._isLessThanOrEqualTo(value, this._map.get(key))) {
            return false;
        }
        this._map.set(key, value);
        return true;
    };
    return Filter;
}());
module.exports = Filter;
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/index.js":
/*!*****************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var constants = __webpack_require__(/*! ./constants */ "../../work/twilio-video.js/es5/util/constants.js");
var E = constants.typeErrors, trackPriority = constants.trackPriority;
var util = __webpack_require__(/*! @twilio/webrtc/lib/util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js");
/**
 * Return the given {@link LocalTrack} or a new {@link LocalTrack} for the
 * given MediaStreamTrack.
 * @param {LocalTrack|MediaStreamTrack} track
 * @param {object} options
 * @returns {LocalTrack}
 * @throws {TypeError}
 */
function asLocalTrack(track, options) {
    if (track instanceof options.LocalAudioTrack
        || track instanceof options.LocalVideoTrack
        || track instanceof options.LocalDataTrack) {
        return track;
    }
    if (track instanceof options.MediaStreamTrack) {
        return track.kind === 'audio'
            ? new options.LocalAudioTrack(track, options)
            : new options.LocalVideoTrack(track, options);
    }
    /* eslint new-cap:0 */
    throw E.INVALID_TYPE('track', 'LocalAudioTrack, LocalVideoTrack, LocalDataTrack, or MediaStreamTrack');
}
/**
 * Create a new {@link LocalTrackPublication} for the given {@link LocalTrack}.
 * @param {LocalTrack} track
 * @param {LocalTrackPublicationSignaling} signaling
 * @param {function(track: LocalTrackPublication): void} unpublish
 * @param {object} options
 */
function asLocalTrackPublication(track, signaling, unpublish, options) {
    var LocalTrackPublication = {
        audio: options.LocalAudioTrackPublication,
        video: options.LocalVideoTrackPublication,
        data: options.LocalDataTrackPublication
    }[track.kind];
    return new LocalTrackPublication(signaling, track, unpublish, options);
}
/**
 * Capitalize a word.
 * @param {string} word
 * @returns {string} capitalized
 */
function capitalize(word) {
    return word[0].toUpperCase() + word.slice(1);
}
/**
 * Log deprecation warnings for the given events of an EventEmitter.
 * @param {string} name
 * @param {EventEmitter} emitter
 * @param {Map<string, string>} events
 * @param {Log} log
 */
function deprecateEvents(name, emitter, events, log) {
    var warningsShown = new Set();
    emitter.on('newListener', function newListener(event) {
        if (events.has(event) && !warningsShown.has(event)) {
            log.deprecated(name + "#" + event + " has been deprecated and scheduled for removal in twilio-video.js@2.0.0." + (events.get(event)
                ? " Use " + name + "#" + events.get(event) + " instead."
                : ''));
            warningsShown.add(event);
        }
        if (warningsShown.size >= events.size) {
            emitter.removeListener('newListener', newListener);
        }
    });
}
/**
 * Finds the items in list1 that are not in list2.
 * @param {Array<*>|Map<*>|Set<*>} list1
 * @param {Array<*>|Map<*>|Set<*>} list2
 * @returns {Set}
 */
function difference(list1, list2) {
    list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());
    list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());
    var difference = new Set();
    list1.forEach(function (item) {
        if (!list2.has(item)) {
            difference.add(item);
        }
    });
    return difference;
}
/**
 * Filter out the keys in an object with a given value.
 * @param {object} object - Object to be filtered
 * @param {*} [filterValue] - Value to be filtered out; If not specified, then
 *   filters out all keys which have an explicit value of "undefined"
 * @returns {object} - Filtered object
 */
function filterObject(object, filterValue) {
    return Object.keys(object).reduce(function (filtered, key) {
        if (object[key] !== filterValue) {
            filtered[key] = object[key];
        }
        return filtered;
    }, {});
}
/**
 * Map a list to an array of arrays, and return the flattened result.
 * @param {Array<*>|Set<*>|Map<*>} list
 * @param {function(*): Array<*>} [mapFn]
 * @returns Array<*>
 */
function flatMap(list, mapFn) {
    var listArray = list instanceof Map || list instanceof Set
        ? Array.from(list.values())
        : list;
    mapFn = mapFn || function mapFn(item) {
        return item;
    };
    return listArray.reduce(function (flattened, item) {
        var mapped = mapFn(item);
        return flattened.concat(mapped);
    }, []);
}
/**
 * Get the user agent string, or return "Unknown".
 * @returns {string}
 */
function getUserAgent() {
    return typeof navigator !== 'undefined' && navigator.userAgent
        ? navigator.userAgent
        : 'Unknown';
}
/**
 * Get the platform component of the user agent string.
 * Example:
 *   Input - Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36
 *   Output - macintosh
 * @returns {string}
 */
function getPlatform() {
    var userAgent = getUserAgent();
    var _a = __read(userAgent.match(/\(([^)]+)\)/) || [], 2), _b = _a[1], match = _b === void 0 ? 'unknown' : _b;
    var _c = __read(match.split(';').map(function (entry) { return entry.trim(); }), 1), platform = _c[0];
    return platform.toLowerCase();
}
/**
 * Create a unique identifier.
 * @returns {string}
 */
function makeUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
/**
 * Ensure that the given function is called once per tick.
 * @param {function} fn - Function to be executed
 * @returns {function} - Schedules the given function to be called on the next tick
 */
function oncePerTick(fn) {
    var timeout = null;
    function nextTick() {
        timeout = null;
        fn();
    }
    return function scheduleNextTick() {
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(nextTick);
    };
}
function promiseFromEvents(operation, eventEmitter, successEvent, failureEvent) {
    return new Promise(function (resolve, reject) {
        function onSuccess() {
            var args = [].slice.call(arguments);
            if (failureEvent) {
                eventEmitter.removeListener(failureEvent, onFailure);
            }
            resolve.apply(void 0, __spreadArray([], __read(args)));
        }
        function onFailure() {
            var args = [].slice.call(arguments);
            eventEmitter.removeListener(successEvent, onSuccess);
            reject.apply(void 0, __spreadArray([], __read(args)));
        }
        eventEmitter.once(successEvent, onSuccess);
        if (failureEvent) {
            eventEmitter.once(failureEvent, onFailure);
        }
        operation();
    });
}
/**
 * Traverse down multiple nodes on an object and return null if
 * any link in the path is unavailable.
 * @param {Object} obj - Object to traverse
 * @param {String} path - Path to traverse. Period-separated.
 * @returns {Any|null}
 */
function getOrNull(obj, path) {
    return path.split('.').reduce(function (output, step) {
        if (!output) {
            return null;
        }
        return output[step];
    }, obj);
}
/**
 * @typedef {object} Deferred
 * @property {Promise} promise
 * @property {function} reject
 * @property {function} resolve
 */
/**
 * Create a {@link Deferred}.
 * @returns {Deferred}
 */
function defer() {
    var deferred = {};
    deferred.promise = new Promise(function (resolve, reject) {
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
    return deferred;
}
/**
 * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking
 * the method on the `wrapper` prototype will invoke the corresponding method
 * on an instance accessed by `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @param {string} methodName
 * @returns {undefined}
 */
function delegateMethod(source, wrapper, target, methodName) {
    if (methodName in wrapper) {
        // Skip any methods already set.
        return;
    }
    else if (methodName.match(/^on[a-z]+$/)) {
        // Skip EventHandlers (these are handled in the constructor).
        return;
    }
    var type;
    try {
        type = typeof source[methodName];
    }
    catch (error) {
        // NOTE(mroberts): Attempting to check the type of non-function members
        // on the prototype throws an error for some types.
    }
    if (type !== 'function') {
        // Skip non-function members.
        return;
    }
    /* eslint no-loop-func:0 */
    wrapper[methodName] = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = this[target])[methodName].apply(_a, __spreadArray([], __read(args)));
    };
}
/**
 * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking
 * the methods on the `wrapper` prototype will invoke the corresponding method
 * on an instance accessed by `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @returns {undefined}
 */
function delegateMethods(source, wrapper, target) {
    for (var methodName in source) {
        delegateMethod(source, wrapper, target, methodName);
    }
}
/**
 * Determine whether two values are deeply equal.
 * @param {*} val1
 * @param {*} val2
 * @returns {boolean}
 */
function isDeepEqual(val1, val2) {
    if (val1 === val2) {
        return true;
    }
    if (typeof val1 !== typeof val2) {
        return false;
    }
    if (val1 === null) {
        return val2 === null;
    }
    if (val2 === null) {
        return false;
    }
    if (Array.isArray(val1)) {
        return Array.isArray(val2)
            && val1.length === val2.length
            && val1.every(function (val, i) { return isDeepEqual(val, val2[i]); });
    }
    if (typeof val1 === 'object') {
        var val1Keys = Object.keys(val1).sort();
        var val2Keys = Object.keys(val2).sort();
        return !Array.isArray(val2)
            && isDeepEqual(val1Keys, val2Keys)
            && val1Keys.every(function (key) { return isDeepEqual(val1[key], val2[key]); });
    }
    return false;
}
/**
 * Whether the given argument is a non-array object.
 * @param {*} object
 * @return {boolean}
 */
function isNonArrayObject(object) {
    return typeof object === 'object' && !Array.isArray(object);
}
/**
 * For each property name on the `source` prototype, add getters and/or setters
 * to `wrapper` that proxy to `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @returns {undefined}
 */
function proxyProperties(source, wrapper, target) {
    Object.getOwnPropertyNames(source).forEach(function (propertyName) {
        proxyProperty(source, wrapper, target, propertyName);
    });
}
/**
 * For the property name on the `source` prototype, add a getter and/or setter
 * to `wrapper` that proxies to `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @param {string} propertyName
 * @returns {undefined}
 */
function proxyProperty(source, wrapper, target, propertyName) {
    if (propertyName in wrapper) {
        // Skip any properties already set.
        return;
    }
    else if (propertyName.match(/^on[a-z]+$/)) {
        Object.defineProperty(wrapper, propertyName, {
            value: null,
            writable: true
        });
        target.addEventListener(propertyName.slice(2), function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            wrapper.dispatchEvent.apply(wrapper, __spreadArray([], __read(args)));
        });
        return;
    }
    Object.defineProperty(wrapper, propertyName, {
        enumerable: true,
        get: function () {
            return target[propertyName];
        }
    });
}
/**
 * This is a function for turning a Promise into the kind referenced in the
 * Legacy Interface Extensions section of the WebRTC spec.
 * @param {Promise<*>} promise
 * @param {function<*>} onSuccess
 * @param {function<Error>} onFailure
 * @returns {Promise<undefined>}
 */
function legacyPromise(promise, onSuccess, onFailure) {
    if (onSuccess) {
        return promise.then(function (result) {
            onSuccess(result);
        }, function (error) {
            onFailure(error);
        });
    }
    return promise;
}
/**
 * Build the {@link LogLevels} object.
 * @param {String|LogLevel} logLevel - Log level name or object
 * @returns {LogLevels}
 */
function buildLogLevels(logLevel) {
    if (typeof logLevel === 'string') {
        return {
            default: logLevel,
            media: logLevel,
            signaling: logLevel,
            webrtc: logLevel
        };
    }
    return logLevel;
}
/**
 * Get the {@link Track}'s derived class name
 * @param {Track} track
 * @param {?boolean} [local=undefined]
 * @returns {string}
 */
function trackClass(track, local) {
    local = local ? 'Local' : '';
    return local + (track.kind || '').replace(/\w{1}/, function (m) { return m.toUpperCase(); }) + "Track";
}
/**
 * Get the {@link TrackPublication}'s derived class name
 * @param {TrackPublication} publication
 * @param {?boolean} [local=undefined]
 * @returns {string}
 */
function trackPublicationClass(publication, local) {
    local = local ? 'Local' : '';
    return local + (publication.kind || '').replace(/\w{1}/, function (m) { return m.toUpperCase(); }) + "TrackPublication";
}
/**
 * Sets all underscore-prefixed properties on `object` non-enumerable.
 * @param {Object} object
 * @returns {void}
 */
function hidePrivateProperties(object) {
    Object.getOwnPropertyNames(object).forEach(function (name) {
        if (name.startsWith('_')) {
            hideProperty(object, name);
        }
    });
}
/**
 * Creates a new subclass which, in the constructor, sets all underscore-prefixed
 * properties and the given public properties non-enumerable. This is useful for
 * patching up classes like EventEmitter which may set properties like `_events`
 * and `domain`.
 * @param {Function} klass
 * @param {Array<string>} props
 * @returns {Function} subclass
 */
function hidePrivateAndCertainPublicPropertiesInClass(klass, props) {
    // NOTE(mroberts): We do this to avoid giving the class a name.
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args))) || this;
            hidePrivateProperties(_this);
            hidePublicProperties(_this, props);
            return _this;
        }
        return class_1;
    }(klass));
}
/**
 * Hide a property of an object.
 * @param {object} object
 * @param {string} name
 */
function hideProperty(object, name) {
    var descriptor = Object.getOwnPropertyDescriptor(object, name);
    descriptor.enumerable = false;
    Object.defineProperty(object, name, descriptor);
}
/**
 * Hide the given public properties of an object.
 * @param {object} object
 * @param {Array<string>} [props=[]]
 */
function hidePublicProperties(object, props) {
    if (props === void 0) { props = []; }
    props.forEach(function (name) {
        // eslint-disable-next-line no-prototype-builtins
        if (object.hasOwnProperty(name)) {
            hideProperty(object, name);
        }
    });
}
/**
 * Convert an Array of values to an Array of JSON values by calling
 * `valueToJSON` on each value.
 * @param {Array<*>} array
 * @returns {Array<*>}
 */
function arrayToJSON(array) {
    return array.map(valueToJSON);
}
/**
 * Convert a Set of values to an Array of JSON values by calling `valueToJSON`
 * on each value.
 * @param {Set<*>} set
 * @returns {Array<*>}
 */
function setToJSON(set) {
    return arrayToJSON(__spreadArray([], __read(set)));
}
/**
 * Convert a Map from strings to values to an object of JSON values by calling
 * `valueToJSON` on each value.
 * @param {Map<string, *>} map
 * @returns {object}
 */
function mapToJSON(map) {
    return __spreadArray([], __read(map.entries())).reduce(function (json, _a) {
        var _b;
        var _c = __read(_a, 2), key = _c[0], value = _c[1];
        return Object.assign((_b = {}, _b[key] = valueToJSON(value), _b), json);
    }, {});
}
/**
 * Convert an object to a JSON value by calling `valueToJSON` on its enumerable
 * keys.
 * @param {object} object
 * @returns {object}
 */
function objectToJSON(object) {
    return Object.entries(object).reduce(function (json, _a) {
        var _b;
        var _c = __read(_a, 2), key = _c[0], value = _c[1];
        return Object.assign((_b = {}, _b[key] = valueToJSON(value), _b), json);
    }, {});
}
/**
 * Convert a value into a JSON value.
 * @param {*} value
 * @returns {*}
 */
function valueToJSON(value) {
    if (Array.isArray(value)) {
        return arrayToJSON(value);
    }
    else if (value instanceof Set) {
        return setToJSON(value);
    }
    else if (value instanceof Map) {
        return mapToJSON(value);
    }
    else if (value && typeof value === 'object') {
        return objectToJSON(value);
    }
    return value;
}
function createRoomConnectEventPayload(connectOptions) {
    function boolToString(val) {
        return val ? 'true' : 'false';
    }
    var payload = {
        // arrays props converted to lengths.
        iceServers: (connectOptions.iceServers || []).length,
        audioTracks: (connectOptions.tracks || []).filter(function (track) { return track.kind === 'audio'; }).length,
        videoTracks: (connectOptions.tracks || []).filter(function (track) { return track.kind === 'video'; }).length,
        dataTracks: (connectOptions.tracks || []).filter(function (track) { return track.kind === 'data'; }).length,
    };
    // boolean properties.
    [['audio'], ['automaticSubscription'], ['enableDscp'], ['eventListener'], ['preflight'], ['video'], ['dominantSpeaker', 'enableDominantSpeaker']].forEach(function (_a) {
        var _b = __read(_a, 2), prop = _b[0], eventProp = _b[1];
        eventProp = eventProp || prop;
        payload[eventProp] = boolToString(!!connectOptions[prop]);
    });
    // numbers and string properties.
    [['maxVideoBitrate'], ['maxAudioBitrate'], ['iceTransportPolicy'], ['region'], ['name', 'roomName']].forEach(function (_a) {
        var _b = __read(_a, 2), prop = _b[0], eventProp = _b[1];
        eventProp = eventProp || prop;
        if (typeof connectOptions[prop] === 'number' || typeof connectOptions[prop] === 'string') {
            payload[eventProp] = connectOptions[prop];
        }
    });
    // array props stringified.
    ['preferredAudioCodecs', 'preferredVideoCodecs'].forEach(function (prop) {
        if (prop in connectOptions) {
            payload[prop] = JSON.stringify(connectOptions[prop]);
        }
    });
    if ('networkQuality' in connectOptions) {
        payload.networkQualityConfiguration = {};
        if (isNonArrayObject(connectOptions.networkQuality)) {
            ['local', 'remote'].forEach(function (prop) {
                if (typeof connectOptions.networkQuality[prop] === 'number') {
                    payload.networkQualityConfiguration[prop] = connectOptions.networkQuality[prop];
                }
            });
        }
        else {
            payload.networkQualityConfiguration.remote = 0;
            payload.networkQualityConfiguration.local = connectOptions.networkQuality ? 1 : 0;
        }
    }
    if (connectOptions.bandwidthProfile && connectOptions.bandwidthProfile.video) {
        var videoBPOptions_1 = connectOptions.bandwidthProfile.video || {};
        payload.bandwidthProfileOptions = {};
        ['mode', 'maxTracks', 'trackSwitchOffMode', 'dominantSpeakerPriority', 'maxSubscriptionBitrate', 'renderDimensions', 'contentPreferencesMode', 'clientTrackSwitchOffControl'].forEach(function (prop) {
            if (typeof videoBPOptions_1[prop] === 'number' || typeof videoBPOptions_1[prop] === 'string') {
                payload.bandwidthProfileOptions[prop] = videoBPOptions_1[prop];
            }
            else if (typeof videoBPOptions_1[prop] === 'boolean') {
                payload.bandwidthProfileOptions[prop] = boolToString(videoBPOptions_1[prop]);
            }
            else if (typeof videoBPOptions_1[prop] === 'object') {
                payload.bandwidthProfileOptions[prop] = JSON.stringify(videoBPOptions_1[prop]);
            }
        });
    }
    return {
        group: 'room',
        name: 'connect',
        level: 'info',
        payload: payload
    };
}
/**
 * Create the bandwidth profile payload included in an RSP connect message.
 * @param {BandwidthProfileOptions} bandwidthProfile
 * @returns {object}
 */
function createBandwidthProfilePayload(bandwidthProfile) {
    return createRSPPayload(bandwidthProfile, [
        { prop: 'video', type: 'object', transform: createBandwidthProfileVideoPayload }
    ]);
}
/**
 * Create the bandwidth profile video payload included in an RSP connect message.
 * @param {VideoBandwidthProfileOptions} bandwidthProfileVideo
 * @returns {object}
 */
function createBandwidthProfileVideoPayload(bandwidthProfileVideo) {
    return createRSPPayload(bandwidthProfileVideo, [
        { prop: 'dominantSpeakerPriority', type: 'string', payloadProp: 'active_speaker_priority' },
        { prop: 'maxSubscriptionBitrate', type: 'number', payloadProp: 'max_subscription_bandwidth' },
        { prop: 'maxTracks', type: 'number', payloadProp: 'max_tracks' },
        { prop: 'mode', type: 'string' },
        { prop: 'renderDimensions', type: 'object', payloadProp: 'render_dimensions', transform: createRenderDimensionsPayload },
        { prop: 'trackSwitchOffMode', type: 'string', payloadProp: 'track_switch_off' }
    ]);
}
/**
 * Create the Media Signaling payload included in an RSP connect message.
 * @param {boolean} dominantSpeaker - whether to enable the Dominant Speaker
 *   protocol or not
 * @param {boolean} networkQuality - whether to enable the Network Quality
 *   protocol or not
 * @param {boolean} trackPriority - whether to enable the Track Priority
 *   protocol or not
 * @param {boolean} trackSwitchOff - whether to enable the Track Switch-Off
 *   protocol or not.
 * @param {boolean} renderHints - whether to enable the renderHints
 *   protocol or not.
 * @returns {object}
 */
function createMediaSignalingPayload(dominantSpeaker, networkQuality, trackPriority, trackSwitchOff, renderHints) {
    var transports = { transports: [{ type: 'data-channel' }] };
    return Object.assign(dominantSpeaker
        // eslint-disable-next-line
        ? { active_speaker: transports }
        : {}, networkQuality
        // eslint-disable-next-line
        ? { network_quality: transports }
        : {}, renderHints
        // eslint-disable-next-line
        ? { render_hints: transports, publisher_hints: transports }
        : {}, trackPriority
        // eslint-disable-next-line
        ? { track_priority: transports }
        : {}, trackSwitchOff
        // eslint-disable-next-line
        ? { track_switch_off: transports }
        : {});
}
/**
 * Create {@link VideoTrack.Dimensions} RSP payload.
 * @param {VideoTrack.Dimensions} [dimensions]
 * @returns {object}
 */
function createDimensionsPayload(dimensions) {
    return createRSPPayload(dimensions, [
        { prop: 'height', type: 'number' },
        { prop: 'width', type: 'number' }
    ]);
}
/**
 * Create {@link VideoRenderDimensions} RSP payload.
 * @param renderDimensions
 * @returns {object}
 */
function createRenderDimensionsPayload(renderDimensions) {
    var PRIORITY_HIGH = trackPriority.PRIORITY_HIGH, PRIORITY_LOW = trackPriority.PRIORITY_LOW, PRIORITY_STANDARD = trackPriority.PRIORITY_STANDARD;
    return createRSPPayload(renderDimensions, [
        { prop: PRIORITY_HIGH, type: 'object', transform: createDimensionsPayload },
        { prop: PRIORITY_LOW, type: 'object', transform: createDimensionsPayload },
        { prop: PRIORITY_STANDARD, type: 'object', transform: createDimensionsPayload }
    ]);
}
/**
 * Create an RSP payload for the given object.
 * @param {object} object - object for which RSP payload is to be generated
 * @param {Array<object>} propConversions - conversion rules for object properties;
 *   they specify how object properties should be converted to their corresponding
 *   RSP payload properties
 * @returns {object}
 */
function createRSPPayload(object, propConversions) {
    return propConversions.reduce(function (payload, _a) {
        var _b;
        var prop = _a.prop, type = _a.type, _c = _a.payloadProp, payloadProp = _c === void 0 ? prop : _c, _d = _a.transform, transform = _d === void 0 ? function (x) { return x; } : _d;
        return typeof object[prop] === type
            ? Object.assign((_b = {}, _b[payloadProp] = transform(object[prop]), _b), payload)
            : payload;
    }, {});
}
/**
 * Create the subscribe payload included in an RSP connect/update message.
 * @param {boolean} automaticSubscription - whether to subscribe to all RemoteTracks
 * @returns {object}
 */
function createSubscribePayload(automaticSubscription) {
    return {
        rules: [{
                type: automaticSubscription ? 'include' : 'exclude',
                all: true
            }],
        revision: 1
    };
}
/**
 * Add random jitter to a given value in the range [-jitter, jitter].
 * @private
 * @param {number} value
 * @param {number} jitter
 * @returns {number} value + random(-jitter, +jitter)
 */
function withJitter(value, jitter) {
    var rand = Math.random();
    return value - jitter + Math.floor(2 * jitter * rand + 0.5);
}
/**
 * Checks if the a number is in the range [min, max].
 * @private
 * @param {num} num
 * @param {number} min
 * @param {number} max
 * @return {boolean}
 */
function inRange(num, min, max) {
    return min <= num && num <= max;
}
/**
 * returns true if given MediaStreamTrack is a screen share track
 * @private
 * @param {MediaStreamTrack} track
 * @returns {boolean}
 */
function isChromeScreenShareTrack(track) {
    // NOTE(mpatwardhan): Chrome creates screen share tracks with label like: "screen:69734272*"
    // we will check for label that starts with "screen:D" where D being a digit.
    var isChrome = util.guessBrowser() === 'chrome';
    return isChrome && track.kind === 'video' && track.label && (/^screen:[0-9]+/.test(track.label) || /^web-contents-media-stream:[0-9/]+/.test(track.label) || /^window:[0-9]+/.test(track.label));
}
/**
 * Returns a promise that resolve after timeoutMS have passed.
 * @param {number} timeoutMS - time to wait in milliseconds.
 * @returns {Promise<void>}
 */
function waitForSometime(timeoutMS) {
    if (timeoutMS === void 0) { timeoutMS = 10; }
    return new Promise(function (resolve) { return setTimeout(resolve, timeoutMS); });
}
/**
 * Returns a promise that resolve after event is received
 * @returns {Promise<void>}
 */
function waitForEvent(eventTarget, event) {
    return new Promise(function (resolve) {
        eventTarget.addEventListener(event, function onevent(e) {
            eventTarget.removeEventListener(event, onevent);
            resolve(e);
        });
    });
}
exports.constants = constants;
exports.createBandwidthProfilePayload = createBandwidthProfilePayload;
exports.createMediaSignalingPayload = createMediaSignalingPayload;
exports.createRoomConnectEventPayload = createRoomConnectEventPayload;
exports.createSubscribePayload = createSubscribePayload;
exports.asLocalTrack = asLocalTrack;
exports.asLocalTrackPublication = asLocalTrackPublication;
exports.capitalize = capitalize;
exports.deprecateEvents = deprecateEvents;
exports.difference = difference;
exports.filterObject = filterObject;
exports.flatMap = flatMap;
exports.getPlatform = getPlatform;
exports.getUserAgent = getUserAgent;
exports.hidePrivateProperties = hidePrivateProperties;
exports.hidePrivateAndCertainPublicPropertiesInClass = hidePrivateAndCertainPublicPropertiesInClass;
exports.isDeepEqual = isDeepEqual;
exports.isNonArrayObject = isNonArrayObject;
exports.inRange = inRange;
exports.makeUUID = makeUUID;
exports.oncePerTick = oncePerTick;
exports.promiseFromEvents = promiseFromEvents;
exports.getOrNull = getOrNull;
exports.defer = defer;
exports.delegateMethods = delegateMethods;
exports.proxyProperties = proxyProperties;
exports.legacyPromise = legacyPromise;
exports.buildLogLevels = buildLogLevels;
exports.trackClass = trackClass;
exports.trackPublicationClass = trackPublicationClass;
exports.valueToJSON = valueToJSON;
exports.withJitter = withJitter;
exports.isChromeScreenShareTrack = isChromeScreenShareTrack;
exports.waitForSometime = waitForSometime;
exports.waitForEvent = waitForEvent;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/insightspublisher/index.js":
/*!***********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/insightspublisher/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var getUserAgent = __webpack_require__(/*! .. */ "../../work/twilio-video.js/es5/util/index.js").getUserAgent;
var MAX_RECONNECT_ATTEMPTS = 5;
var RECONNECT_INTERVAL_MS = 50;
var WS_CLOSE_NORMAL = 1000;
var toplevel = global.window || global;
var WebSocket = toplevel.WebSocket ? toplevel.WebSocket : __webpack_require__(/*! ws */ "../../work/twilio-video.js/src/ws.js");
var util = __webpack_require__(/*! ../../util */ "../../work/twilio-video.js/es5/util/index.js");
/**
 * Publish events to the Insights gateway.
 * @extends EventEmitter
 * @emits InsightsPublisher#connected
 * @emits InsightsPublisher#disconnected
 * @emits InsightsPublisher#reconnecting
 */
var InsightsPublisher = /** @class */ (function (_super) {
    __extends(InsightsPublisher, _super);
    /**
     * @param {string} token - Insights gateway token
     * @param {string} sdkName - Name of the SDK using the {@link InsightsPublisher}
     * @param {string} sdkVersion - Version of the SDK using the {@link InsightsPublisher}
     * @param {string} environment - One of 'dev', 'stage' or 'prod'
     * @param {string} realm - Region identifier
     * @param {InsightsPublisherOptions} options - Override default behavior
     */
    function InsightsPublisher(token, sdkName, sdkVersion, environment, realm, options) {
        var _this = _super.call(this) || this;
        options = Object.assign({
            gateway: createGateway(environment, realm) + "/v1/VideoEvents",
            maxReconnectAttempts: MAX_RECONNECT_ATTEMPTS,
            reconnectIntervalMs: RECONNECT_INTERVAL_MS,
            userAgent: getUserAgent(),
            WebSocket: WebSocket
        }, options);
        Object.defineProperties(_this, {
            _connectTimestamp: {
                value: 0,
                writable: true
            },
            _eventQueue: {
                value: []
            },
            _readyToConnect: {
                value: util.defer()
            },
            _reconnectAttemptsLeft: {
                value: options.maxReconnectAttempts,
                writable: true
            },
            _ws: {
                value: null,
                writable: true
            },
            _WebSocket: {
                value: options.WebSocket
            }
        });
        _this._readyToConnect.promise.then(function (_a) {
            var roomSid = _a.roomSid, participantSid = _a.participantSid;
            var self = _this;
            _this.on('disconnected', function maybeReconnect(error) {
                self._session = null;
                if (error && self._reconnectAttemptsLeft > 0) {
                    self.emit('reconnecting');
                    reconnect(self, token, sdkName, sdkVersion, roomSid, participantSid, options);
                    return;
                }
                self.removeListener('disconnected', maybeReconnect);
            });
            connect(_this, token, sdkName, sdkVersion, roomSid, participantSid, options);
        }).catch(function () {
            // ignore failures to connect
        });
        return _this;
    }
    /**
     * Start connecting to the Insights gateway.
     * @param {string} roomSid
     * @param {string} participantSid
     * @returns {void}
     */
    InsightsPublisher.prototype.connect = function (roomSid, participantSid) {
        this._readyToConnect.resolve({ roomSid: roomSid, participantSid: participantSid });
    };
    /**
     * Publish an event to the Insights gateway.
     * @private
     * @param {*} event
     */
    InsightsPublisher.prototype._publish = function (event) {
        event.session = this._session;
        this._ws.send(JSON.stringify(event));
    };
    /**
     * Disconnect from the Insights gateway.
     * @returns {boolean} true if called when connecting/open, false if not
     */
    InsightsPublisher.prototype.disconnect = function () {
        if (this._ws === null
            || this._ws.readyState === this._WebSocket.CLOSING
            || this._ws.readyState === this._WebSocket.CLOSED) {
            return false;
        }
        try {
            this._ws.close();
        }
        catch (error) {
            // Do nothing.
        }
        this.emit('disconnected');
        return true;
    };
    /**
     * Publish (or queue, if not connected) an event to the Insights gateway.
     * @param {string} groupName - Event group name
     * @param {string} eventName - Event name
     * @param {object} payload - Event payload
     * @returns {boolean} true if queued or published, false if disconnect() called
     */
    InsightsPublisher.prototype.publish = function (groupName, eventName, payload) {
        if (this._ws !== null
            && (this._ws.readyState === this._WebSocket.CLOSING
                || this._ws.readyState === this._WebSocket.CLOSED)) {
            return false;
        }
        var publishOrEnqueue = typeof this._session === 'string'
            ? this._publish.bind(this)
            : this._eventQueue.push.bind(this._eventQueue);
        publishOrEnqueue({
            group: groupName,
            name: eventName,
            payload: payload,
            timestamp: Date.now(),
            type: 'event',
            version: 1
        });
        return true;
    };
    return InsightsPublisher;
}(EventEmitter));
/**
 * Start connecting to the Insights gateway.
 * @private
 * @param {InsightsPublisher} publisher
 * @param {string} name
 * @param {string} token
 * @param {string} sdkName
 * @param {string} sdkVersion
 * @param {string} roomSid
 * @param {string} participantSid
 * @param {InsightsPublisherOptions} options
 */
function connect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options) {
    publisher._connectTimestamp = Date.now();
    publisher._reconnectAttemptsLeft--;
    publisher._ws = new options.WebSocket(options.gateway);
    var ws = publisher._ws;
    ws.addEventListener('close', function (event) {
        if (event.code === WS_CLOSE_NORMAL) {
            publisher.emit('disconnected');
            return;
        }
        publisher.emit('disconnected', new Error("WebSocket Error " + event.code + ": " + event.reason));
    });
    ws.addEventListener('message', function (message) {
        handleConnectResponse(publisher, JSON.parse(message.data), options);
    });
    ws.addEventListener('open', function () {
        var connectRequest = {
            type: 'connect',
            token: token,
            version: 1
        };
        connectRequest.publisher = {
            name: sdkName,
            sdkVersion: sdkVersion,
            userAgent: options.userAgent,
            participantSid: participantSid,
            roomSid: roomSid,
        };
        ws.send(JSON.stringify(connectRequest));
    });
}
/**
 * Create the Insights Websocket gateway URL.
 * @param {string} environment
 * @param {string} realm
 * @returns {string}
 */
function createGateway(environment, realm) {
    return environment === 'prod' ? "wss://sdkgw." + realm + ".twilio.com"
        : "wss://sdkgw." + environment + "-" + realm + ".twilio.com";
}
/**
 * Handle connect response from the Insights gateway.
 * @param {InsightsPublisher} publisher
 * @param {*} response
 * @param {InsightsPublisherOptions} options
 */
function handleConnectResponse(publisher, response, options) {
    switch (response.type) {
        case 'connected':
            publisher._session = response.session;
            publisher._reconnectAttemptsLeft = options.maxReconnectAttempts;
            publisher._eventQueue.splice(0).forEach(publisher._publish, publisher);
            publisher.emit('connected');
            break;
        case 'error':
            publisher._ws.close();
            publisher.emit('disconnected', new Error(response.message));
            break;
    }
}
/**
 * Start re-connecting to the Insights gateway with an appropriate delay based
 * on InsightsPublisherOptions#reconnectIntervalMs.
 * @private
 * @param {InsightsPublisher} publisher
 * @param {string} token
 * @param {string} sdkName
 * @param {string} sdkVersion
 * @param {string} roomSid
 * @param {string} participantSid
 * @param {InsightsPublisherOptions} options
 */
function reconnect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options) {
    var connectInterval = Date.now() - publisher._connectTimestamp;
    var timeToWait = options.reconnectIntervalMs - connectInterval;
    if (timeToWait > 0) {
        setTimeout(function () {
            connect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options);
        }, timeToWait);
        return;
    }
    connect(publisher, token, sdkName, sdkVersion, roomSid, participantSid, options);
}
/**
 * The {@link InsightsPublisher} is connected to the gateway.
 * @event InsightsPublisher#connected
 */
/**
 * The {@link InsightsPublisher} is disconnected from the gateway.
 * @event InsightsPublisher#disconnected
 * @param {Error} [error] - Optional error if disconnected unintentionally
 */
/**
 * The {@link InsightsPublisher} is re-connecting to the gateway.
 * @event InsightsPublisher#reconnecting
 */
/**
 * {@link InsightsPublisher} options.
 * @typedef {object} InsightsPublisherOptions
 * @property {string} [gateway=sdkgw.{environment}-{realm}.twilio.com] - Insights WebSocket gateway url
 * @property {number} [maxReconnectAttempts=5] - Max re-connect attempts
 * @property {number} [reconnectIntervalMs=50] - Re-connect interval in ms
 */
module.exports = InsightsPublisher;
//# sourceMappingURL=index.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../personal/twilio-video-api/node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/insightspublisher/null.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/insightspublisher/null.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// eslint-disable-next-line no-warning-comments
// TODO(mroberts): This should be described as implementing some
// InsightsPublisher interface.

/**
 * Null Insights publisher.
 */
var InsightsPublisher = /** @class */ (function () {
    function InsightsPublisher() {
        Object.defineProperties(this, {
            _connected: {
                writable: true,
                value: true
            }
        });
    }
    /**
     * Connect
     * @returns {void}
     */
    InsightsPublisher.prototype.connect = function () {
    };
    /**
     * Disconnect.
     * @returns {boolean}
     */
    InsightsPublisher.prototype.disconnect = function () {
        if (this._connected) {
            this._connected = false;
            return true;
        }
        return false;
    };
    /**
     * Publish.
     * @returns {boolean}
     */
    InsightsPublisher.prototype.publish = function () {
        return this._connected;
    };
    return InsightsPublisher;
}());
module.exports = InsightsPublisher;
//# sourceMappingURL=null.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/localmediarestartdeferreds.js":
/*!**************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/localmediarestartdeferreds.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var defer = __webpack_require__(/*! ./ */ "../../work/twilio-video.js/es5/util/index.js").defer;
/**
 * This is a pair of Deferreds that are set whenever local media is muted and
 * resolved whenever local media is unmuted/ended and restarted if necessary.
 */
var LocalMediaRestartDeferreds = /** @class */ (function () {
    /**
     * Constructor.
     */
    function LocalMediaRestartDeferreds() {
        Object.defineProperties(this, {
            _audio: {
                value: defer(),
                writable: true
            },
            _video: {
                value: defer(),
                writable: true
            }
        });
        // Initially, resolve both the Deferreds.
        this._audio.resolve();
        this._video.resolve();
    }
    /**
     * Resolve the Deferred for audio or video.
     * @param {'audio'|'video'} kind
     */
    LocalMediaRestartDeferreds.prototype.resolveDeferred = function (kind) {
        if (kind === 'audio') {
            this._audio.resolve();
        }
        else {
            this._video.resolve();
        }
    };
    /**
     * Start the Deferred for audio or video.
     * @param {'audio' | 'video'} kind
     */
    LocalMediaRestartDeferreds.prototype.startDeferred = function (kind) {
        if (kind === 'audio') {
            this._audio = defer();
        }
        else {
            this._video = defer();
        }
    };
    /**
     * Wait until the Deferred for audio or video is resolved.
     * @param {'audio'|'video'} kind
     * @returns {Promise<void>}
     */
    LocalMediaRestartDeferreds.prototype.whenResolved = function (kind) {
        return kind === 'audio' ? this._audio.promise : this._video.promise;
    };
    return LocalMediaRestartDeferreds;
}());
module.exports = new LocalMediaRestartDeferreds();
//# sourceMappingURL=localmediarestartdeferreds.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/log.js":
/*!***************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/log.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint new-cap:0 */

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var defaultGetLogger = __webpack_require__(/*! ../vendor/loglevel */ "../../work/twilio-video.js/es5/vendor/loglevel.js").getLogger;
var constants = __webpack_require__(/*! ./constants */ "../../work/twilio-video.js/es5/util/constants.js");
var DEFAULT_LOG_LEVEL = constants.DEFAULT_LOG_LEVEL, DEFAULT_LOGGER_NAME = constants.DEFAULT_LOGGER_NAME;
var E = __webpack_require__(/*! ./constants */ "../../work/twilio-video.js/es5/util/constants.js").typeErrors;
var deprecationWarningsByComponentConstructor;
function getDeprecationWarnings(componentConstructor) {
    deprecationWarningsByComponentConstructor = deprecationWarningsByComponentConstructor || new Map();
    if (deprecationWarningsByComponentConstructor.has(componentConstructor)) {
        return deprecationWarningsByComponentConstructor.get(componentConstructor);
    }
    var deprecationWarnings = new Set();
    deprecationWarningsByComponentConstructor.set(componentConstructor, deprecationWarnings);
    return deprecationWarnings;
}
/**
 * Selectively outputs messages to console based on specified minimum module
 * specific log levels.
 *
 * NOTE: The values in the logLevels object passed to the constructor is changed
 *       by subsequent calls to {@link Log#setLevels}.
 */
var Log = /** @class */ (function () {
    /**
     * Construct a new {@link Log} object.
     * @param {String} moduleName - Name of the logging module (webrtc/media/signaling)
     * @param {object} component - Component owning this instance of {@link Log}
     * @param {LogLevels} logLevels - Logging levels. See {@link LogLevels}
     * @param {String} loggerName - Name of the logger instance. Used when calling getLogger from loglevel module
     * @param {Function} [getLogger] - optional method used internally.
     */
    function Log(moduleName, component, logLevels, loggerName, getLogger) {
        if (typeof moduleName !== 'string') {
            throw E.INVALID_TYPE('moduleName', 'string');
        }
        if (!component) {
            throw E.REQUIRED_ARGUMENT('component');
        }
        if (typeof logLevels !== 'object') {
            logLevels = {};
        }
        getLogger = getLogger || defaultGetLogger;
        validateLogLevels(logLevels);
        /* istanbul ignore next */
        Object.defineProperties(this, {
            _component: {
                value: component
            },
            _logLevels: {
                value: logLevels
            },
            _warnings: {
                value: new Set()
            },
            _loggerName: {
                get: function get() {
                    var name = loggerName && typeof loggerName === 'string' ? loggerName : DEFAULT_LOGGER_NAME;
                    if (!this._logLevelsEqual) {
                        name = name + "-" + moduleName;
                    }
                    return name;
                }
            },
            _logger: {
                get: function get() {
                    var logger = getLogger(this._loggerName);
                    var level = this._logLevels[moduleName] || DEFAULT_LOG_LEVEL;
                    // There is no 'off' in the logger module. It uses 'silent' instead
                    level = level === 'off' ? 'silent' : level;
                    logger.setDefaultLevel(level);
                    return logger;
                }
            },
            _logLevelsEqual: {
                get: function get() {
                    // True if all levels are the same
                    return (new Set(Object.values(this._logLevels)).size) === 1;
                }
            },
            logLevel: {
                get: function get() {
                    return Log.getLevelByName(logLevels[moduleName] || DEFAULT_LOG_LEVEL);
                }
            },
            name: { get: component.toString.bind(component) }
        });
    }
    /**
     * Get the log level (number) by its name (string)
     * @param {String} name - Name of the log level
     * @returns {Number} Requested log level
     * @throws {TwilioError} INVALID_LOG_LEVEL (32056)
     * @public
     */
    Log.getLevelByName = function (name) {
        if (!isNaN(name)) {
            return parseInt(name, 10);
        }
        name = name.toUpperCase();
        validateLogLevel(name);
        return Log[name];
    };
    /**
     * Create a child {@link Log} instance with this._logLevels
     * @param moduleName - Name of the logging module
     * @param component - Component owning this instance of {@link Log}
     * @returns {Log} this
     */
    Log.prototype.createLog = function (moduleName, component) {
        var name = this._loggerName;
        // Grab the original logger name
        if (!this._logLevelsEqual) {
            name = name.substring(0, name.lastIndexOf('-'));
        }
        return new Log(moduleName, component, this._logLevels, name);
    };
    /**
     * Set new log levels.
     * This changes the levels for all its ancestors,
     * siblings, and children and descendants instances of {@link Log}.
     * @param {LogLevels} levels - New log levels
     * @throws {TwilioError} INVALID_ARGUMENT
     * @returns {Log} this
     */
    Log.prototype.setLevels = function (levels) {
        validateLogLevels(levels);
        Object.assign(this._logLevels, levels);
        return this;
    };
    /**
     * Log a message using the logger method appropriate for the specified logLevel
     * @param {Number} logLevel - Log level of the message being logged
     * @param {Array} messages - Message(s) to log
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.log = function (logLevel, messages) {
        var name = Log._levels[logLevel];
        // eslint-disable-next-line no-use-before-define
        if (!name) {
            throw E.INVALID_VALUE('logLevel', LOG_LEVEL_VALUES);
        }
        name = name.toLowerCase();
        var prefix = [new Date().toISOString(), name, this.name];
        (this._logger[name] || function noop() { }).apply(void 0, __spreadArray([], __read(prefix.concat(messages))));
        return this;
    };
    /**
     * Log a debug message
     * @param {...String} messages - Message(s) to pass to the logger
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.debug = function () {
        return this.log(Log.DEBUG, [].slice.call(arguments));
    };
    /**
     * Log a deprecation warning. Deprecation warnings are logged as warnings and
     * they are only ever logged once.
     * @param {String} deprecationWarning - The deprecation warning
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.deprecated = function (deprecationWarning) {
        var deprecationWarnings = getDeprecationWarnings(this._component.constructor);
        if (deprecationWarnings.has(deprecationWarning)) {
            return this;
        }
        deprecationWarnings.add(deprecationWarning);
        return this.warn(deprecationWarning);
    };
    /**
     * Log an info message
     * @param {...String} messages - Message(s) to pass to the logger
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.info = function () {
        return this.log(Log.INFO, [].slice.call(arguments));
    };
    /**
     * Log a warn message
     * @param {...String} messages - Message(s) to pass to the logger
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.warn = function () {
        return this.log(Log.WARN, [].slice.call(arguments));
    };
    /**
     * Log a warning once.
     * @param {String} warning
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.warnOnce = function (warning) {
        if (this._warnings.has(warning)) {
            return this;
        }
        this._warnings.add(warning);
        return this.warn(warning);
    };
    /**
     * Log an error message
     * @param {...String} messages - Message(s) to pass to the logger
     * @returns {Log} This instance of {@link Log}
     * @public
     */
    Log.prototype.error = function () {
        return this.log(Log.ERROR, [].slice.call(arguments));
    };
    /**
     * Log an error message and throw an exception
     * @param {TwilioError} error - Error to throw
     * @param {String} customMessage - Custom message for the error
     * @public
     */
    Log.prototype.throw = function (error, customMessage) {
        if (error.clone) {
            error = error.clone(customMessage);
        }
        this.log(Log.ERROR, error);
        throw error;
    };
    return Log;
}());
// Singleton Constants
/* eslint key-spacing:0 */
/* istanbul ignore next */
Object.defineProperties(Log, {
    DEBUG: { value: 0 },
    INFO: { value: 1 },
    WARN: { value: 2 },
    ERROR: { value: 3 },
    OFF: { value: 4 },
    _levels: {
        value: [
            'DEBUG',
            'INFO',
            'WARN',
            'ERROR',
            'OFF',
        ]
    }
});
var LOG_LEVELS_SET = {};
var LOG_LEVEL_VALUES = [];
var LOG_LEVEL_NAMES = Log._levels.map(function (level, i) {
    LOG_LEVELS_SET[level] = true;
    LOG_LEVEL_VALUES.push(i);
    return level;
});
function validateLogLevel(level) {
    if (!(level in LOG_LEVELS_SET)) {
        throw E.INVALID_VALUE('level', LOG_LEVEL_NAMES);
    }
}
function validateLogLevels(levels) {
    Object.keys(levels).forEach(function (moduleName) {
        validateLogLevel(levels[moduleName].toUpperCase());
    });
}
module.exports = Log;
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/movingaveragedelta.js":
/*!******************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/movingaveragedelta.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Calculates the moving average delta for the given pair ofsamples. A sample (S)
 * consists of a numerator (Sn) and a denominator (Sd).The moving average delta is
 * calculated as follows:
 *
 * MovingAvgDelta = (Sn[1] - Sn[0]) / (Sd[1] - Sd[0])
 */
var MovingAverageDelta = /** @class */ (function () {
    /**
     * Constructor.
     */
    function MovingAverageDelta() {
        Object.defineProperties(this, {
            _samples: {
                value: [
                    { denominator: 0, numerator: 0 },
                    { denominator: 0, numerator: 0 }
                ],
            }
        });
    }
    /**
     * Get the moving average delta.
     * @returns {number}
     */
    MovingAverageDelta.prototype.get = function () {
        var samples = this._samples;
        var denominatorDelta = (samples[1].denominator - samples[0].denominator) || Infinity;
        var numeratorDelta = samples[1].numerator - samples[0].numerator;
        return numeratorDelta / denominatorDelta;
    };
    /**
     * Put a sample and get rid of the older sample to maintain sample size of 2.
     * @param numerator
     * @param denominator
     */
    MovingAverageDelta.prototype.putSample = function (numerator, denominator) {
        var samples = this._samples;
        samples.shift();
        samples.push({ denominator: denominator, numerator: numerator });
    };
    return MovingAverageDelta;
}());
module.exports = MovingAverageDelta;
//# sourceMappingURL=movingaveragedelta.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/networkmonitor.js":
/*!**************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/networkmonitor.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Monitor the network connection status to detect interruptions and handoffs.
 */
var NetworkMonitor = /** @class */ (function () {
    /**
     * Construct a {@link NetworkMonitor}.
     * @param {function} onNetworkChanged
     * @param {*} [options]
     */
    function NetworkMonitor(onNetworkChanged, options) {
        var _this = this;
        options = Object.assign({
            navigator: navigator,
            window: window,
        }, options);
        var nav = options.navigator;
        var connection = nav.connection || { type: null };
        var type = connection.type;
        var _a = connection.type ? {
            _events: {
                value: ['change', 'typechange']
            },
            _listener: {
                value: function () {
                    var networkChanged = type !== _this.type && _this.isOnline;
                    type = _this.type;
                    if (networkChanged) {
                        onNetworkChanged();
                    }
                }
            },
            _target: {
                value: connection
            }
        } : {
            _events: {
                value: ['online']
            },
            _listener: {
                value: onNetworkChanged
            },
            _target: {
                value: options.window
            }
        }, _events = _a._events, _listener = _a._listener, _target = _a._target;
        Object.defineProperties(this, {
            isOnline: {
                enumerable: true,
                get: function () {
                    return typeof nav.onLine === 'boolean'
                        ? nav.onLine
                        : true;
                }
            },
            type: {
                enumerable: true,
                get: function () {
                    return connection.type || null;
                }
            },
            _listener: _listener,
            _events: _events,
            _target: _target
        });
    }
    /**
     * Start the {@link NetworkMonitor}.
     */
    NetworkMonitor.prototype.start = function () {
        var _this = this;
        this._events.forEach(function (event) {
            _this._target.addEventListener(event, _this._listener);
        });
    };
    /**
     * Stop the {@link NetworkMonitor}.
     */
    NetworkMonitor.prototype.stop = function () {
        var _this = this;
        this._events.forEach(function (event) {
            _this._target.removeEventListener(event, _this._listener);
        });
    };
    return NetworkMonitor;
}());
module.exports = NetworkMonitor;
//# sourceMappingURL=networkmonitor.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/nullobserver.js":
/*!************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/nullobserver.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable no-console */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NullObserver = /** @class */ (function () {
    function NullObserver(callback) {
        Object.defineProperties(this, {
            _callback: {
                value: callback
            }
        });
    }
    NullObserver.prototype.observe = function () {
    };
    NullObserver.prototype.unobserve = function () {
    };
    NullObserver.prototype.makeVisible = function (videoEl) {
        var visibleEntry = this._makeFakeEntry(videoEl, true);
        this._callback([visibleEntry]);
    };
    NullObserver.prototype.makeInvisible = function (videoEl) {
        var invisibleEntry = this._makeFakeEntry(videoEl, false);
        this._callback([invisibleEntry]);
    };
    NullObserver.prototype._makeFakeEntry = function (videoElement, isIntersecting) {
        return { target: videoElement, isIntersecting: isIntersecting };
    };
    return NullObserver;
}());
var NullIntersectionObserver = /** @class */ (function (_super) {
    __extends(NullIntersectionObserver, _super);
    function NullIntersectionObserver() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NullIntersectionObserver;
}(NullObserver));
var NullResizeObserver = /** @class */ (function (_super) {
    __extends(NullResizeObserver, _super);
    function NullResizeObserver() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NullResizeObserver.prototype.resize = function (videoEl) {
        var entry = this._makeFakeEntry(videoEl, true);
        this._callback([entry]);
    };
    return NullResizeObserver;
}(NullObserver));
module.exports = { NullIntersectionObserver: NullIntersectionObserver, NullResizeObserver: NullResizeObserver, NullObserver: NullObserver };
//# sourceMappingURL=nullobserver.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/sdp/index.js":
/*!*********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/sdp/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var _a = __webpack_require__(/*! ../ */ "../../work/twilio-video.js/es5/util/index.js"), difference = _a.difference, flatMap = _a.flatMap;
var setSimulcastInMediaSection = __webpack_require__(/*! ./simulcast */ "../../work/twilio-video.js/es5/util/sdp/simulcast.js");
var ptToFixedBitrateAudioCodecName = {
    0: 'PCMU',
    8: 'PCMA'
};
/**
 * A payload type
 * @typedef {number} PT
 */
/**
 * An {@link AudioCodec} or {@link VideoCodec}
 * @typedef {AudioCodec|VideoCodec} Codec
 */
// NOTE(mmalavalli): This value is derived from the IETF spec
// for JSEP, and it is used to convert a 'b=TIAS' value in bps
// to a 'b=AS' value in kbps.
// Spec: https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-21#section-5.9
var RTCP_BITRATE = 16000;
/**
 * Construct a b= line string for the given max bitrate in bps. If the modifier
 * is 'AS', then the max bitrate will be converted to kbps using the formula
 * specified in the IETF spec for JSEP mentioned above.
 * @param {string} modifier - 'AS' | 'TIAS'
 * @param {?number} maxBitrate - Max outgoing bitrate (bps)
 * @returns {?string} - If "maxBitrate" is null, then returns null;
 *   otherwise return the constructed b= line string
 */
function createBLine(modifier, maxBitrate) {
    if (!maxBitrate) {
        return null;
    }
    return "\r\nb=" + modifier + ":" + (modifier === 'AS'
        ? Math.round((maxBitrate + RTCP_BITRATE) / 950)
        : maxBitrate);
}
/**
 * Create a Codec Map for the given m= section.
 * @param {string} section - The given m= section
 * @returns {Map<Codec, Array<PT>>}
 */
function createCodecMapForMediaSection(section) {
    return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {
        var pt = pair[0];
        var codecName = pair[1];
        var pts = codecMap.get(codecName) || [];
        return codecMap.set(codecName, pts.concat(pt));
    }, new Map());
}
/**
 * Create a Map of MIDs to m= sections for the given SDP.
 * @param {string} sdp
 * @returns {Map<string, string>}
 */
function createMidToMediaSectionMap(sdp) {
    return getMediaSections(sdp).reduce(function (midsToMediaSections, mediaSection) {
        var mid = getMidForMediaSection(mediaSection);
        return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;
    }, new Map());
}
/**
 * Create a Map from PTs to codec names for the given m= section.
 * @param {string} mediaSection - The given m= section.
 * @returns {Map<PT, Codec>} ptToCodecName
 */
function createPtToCodecName(mediaSection) {
    return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {
        var rtpmapPattern = new RegExp("a=rtpmap:" + pt + " ([^/]+)");
        var matches = mediaSection.match(rtpmapPattern);
        var codecName = matches
            ? matches[1].toLowerCase()
            : ptToFixedBitrateAudioCodecName[pt]
                ? ptToFixedBitrateAudioCodecName[pt].toLowerCase()
                : '';
        return ptToCodecName.set(pt, codecName);
    }, new Map());
}
/**
 * Get the associated fmtp attributes for the given Payload Type in an m= section.
 * @param {PT} pt
 * @param {string} mediaSection
 * @returns {?object}
 */
function getFmtpAttributesForPt(pt, mediaSection) {
    // In "a=fmtp:<pt> <name>=<value>[;<name>=<value>]*", the regex matches the codec
    // profile parameters expressed as name/value pairs separated by ";".
    var fmtpRegex = new RegExp("^a=fmtp:" + pt + " (.+)$", 'm');
    var matches = mediaSection.match(fmtpRegex);
    return matches && matches[1].split(';').reduce(function (attrs, nvPair) {
        var _a = __read(nvPair.split('='), 2), name = _a[0], value = _a[1];
        attrs[name] = isNaN(value) ? value : parseInt(value, 10);
        return attrs;
    }, {});
}
/**
 * Get the MID for the given m= section.
 * @param {string} mediaSection
 * @return {?string}
 */
function getMidForMediaSection(mediaSection) {
    // In "a=mid:<mid>", the regex matches <mid>.
    var midMatches = mediaSection.match(/^a=mid:(.+)$/m);
    return midMatches && midMatches[1];
}
/**
 * Get the m= sections of a particular kind and direction from an sdp.
 * @param {string} sdp - SDP string
 * @param {string} [kind] - Pattern for matching kind
 * @param {string} [direction] - Pattern for matching direction
 * @returns {Array<string>} mediaSections
 */
function getMediaSections(sdp, kind, direction) {
    return sdp.replace(/\r\n\r\n$/, '\r\n').split('\r\nm=').slice(1).map(function (mediaSection) { return "m=" + mediaSection; }).filter(function (mediaSection) {
        var kindPattern = new RegExp("m=" + (kind || '.*'), 'gm');
        var directionPattern = new RegExp("a=" + (direction || '.*'), 'gm');
        return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);
    });
}
/**
 * Get the Codec Payload Types present in the first line of the given m= section
 * @param {string} section - The m= section
 * @returns {Array<PT>} Payload Types
 */
function getPayloadTypesInMediaSection(section) {
    var mLine = section.split('\r\n')[0];
    // In "m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>",
    // the regex matches <port> and the Payload Types.
    var matches = mLine.match(/([0-9]+)/g);
    // This should not happen, but in case there are no Payload Types in
    // the m= line, return an empty array.
    if (!matches) {
        return [];
    }
    // Since only the Payload Types are needed, we discard the <port>.
    return matches.slice(1).map(function (match) { return parseInt(match, 10); });
}
/**
 * Create the reordered Codec Payload Types based on the preferred Codec Names.
 * @param {Map<Codec, Array<PT>>} codecMap - Codec Map
 * @param {Array<AudioCodecSettings|VideoCodecSettings>} preferredCodecs - Preferred Codecs
 * @returns {Array<PT>} Reordered Payload Types
 */
function getReorderedPayloadTypes(codecMap, preferredCodecs) {
    preferredCodecs = preferredCodecs.map(function (_a) {
        var codec = _a.codec;
        return codec.toLowerCase();
    });
    var preferredPayloadTypes = flatMap(preferredCodecs, function (codecName) { return codecMap.get(codecName) || []; });
    var remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);
    var remainingPayloadTypes = flatMap(remainingCodecs, function (codecName) { return codecMap.get(codecName); });
    return preferredPayloadTypes.concat(remainingPayloadTypes);
}
/**
 * Set the specified max bitrate in the given m= section.
 * @param {string} modifier - 'AS' | 'TIAS'
 * @param {?number} maxBitrate - Max outgoing bitrate (bps)
 * @param {string} section - m= section string
 * @returns {string} The updated m= section
 */
function setBitrateInMediaSection(modifier, maxBitrate, section) {
    var bLine = createBLine(modifier, maxBitrate) || '';
    var bLinePattern = /\r\nb=(AS|TIAS):([0-9]+)/;
    var bLineMatched = section.match(bLinePattern);
    if (!bLineMatched) {
        return section.replace(/(\r\n)?$/, bLine + "$1");
    }
    var maxBitrateMatched = parseInt(bLineMatched[2], 10);
    maxBitrate = maxBitrate || Infinity;
    bLine = createBLine(modifier, Math.min(maxBitrateMatched, maxBitrate));
    return section.replace(bLinePattern, bLine);
}
/**
 * Set maximum bitrates to the media sections in a given sdp.
 * @param {string} sdp - sdp string
 * @param {string} modifier - 'AS' | 'TIAS"
 * @param {?number} maxAudioBitrate - Max outgoing audio bitrate (bps), null
 *   if no limit is to be applied
 * @param {?number} maxVideoBitrate - Max outgoing video bitrate (bps), null
 *   if no limit is to be applied
 * @returns {string} - The updated sdp string
 */
function setBitrateParameters(sdp, modifier, maxAudioBitrate, maxVideoBitrate) {
    var mediaSections = getMediaSections(sdp);
    var session = sdp.split('\r\nm=')[0];
    return [session].concat(mediaSections.map(function (section) {
        // Bitrate parameters should not be applied to m=application sections
        // or to m=(audio|video) sections that do not receive media.
        if (!/^m=(audio|video)/.test(section) || !/a=(recvonly|sendrecv)/.test(section)) {
            return section;
        }
        var kind = section.match(/^m=(audio|video)/)[1];
        var maxBitrate = kind === 'audio' ? maxAudioBitrate : maxVideoBitrate;
        return setBitrateInMediaSection(modifier, maxBitrate, section);
    })).join('\r\n');
}
/**
 * Set the given Codec Payload Types in the first line of the given m= section.
 * @param {Array<PT>} payloadTypes - Payload Types
 * @param {string} section - Given m= section
 * @returns {string} - Updated m= section
 */
function setPayloadTypesInMediaSection(payloadTypes, section) {
    var lines = section.split('\r\n');
    var mLine = lines[0];
    var otherLines = lines.slice(1);
    mLine = mLine.replace(/([0-9]+\s?)+$/, payloadTypes.join(' '));
    return [mLine].concat(otherLines).join('\r\n');
}
/**
 * Return a new SDP string with the re-ordered codec preferences.
 * @param {string} sdp
 * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order
 *   of audio codecs is preserved
 * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the
 *   existing order of video codecs is preserved
 * @returns {string} Updated SDP string
 */
function setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {
    var mediaSections = getMediaSections(sdp);
    var session = sdp.split('\r\nm=')[0];
    return [session].concat(mediaSections.map(function (section) {
        // Codec preferences should not be applied to m=application sections.
        if (!/^m=(audio|video)/.test(section)) {
            return section;
        }
        var kind = section.match(/^m=(audio|video)/)[1];
        var codecMap = createCodecMapForMediaSection(section);
        var preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs;
        var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);
        var newSection = setPayloadTypesInMediaSection(payloadTypes, section);
        var pcmaPayloadTypes = codecMap.get('pcma') || [];
        var pcmuPayloadTypes = codecMap.get('pcmu') || [];
        var fixedBitratePayloadTypes = kind === 'audio'
            ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes))
            : new Set();
        return fixedBitratePayloadTypes.has(payloadTypes[0])
            ? newSection.replace(/\r\nb=(AS|TIAS):([0-9]+)/g, '')
            : newSection;
    })).join('\r\n');
}
/**
 * Return a new SDP string with simulcast settings.
 * @param {string} sdp
 * @param {'planb' | 'unified'} sdpFormat
 * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes
 * @returns {string} Updated SDP string
 */
function setSimulcast(sdp, sdpFormat, trackIdsToAttributes) {
    var mediaSections = getMediaSections(sdp);
    var session = sdp.split('\r\nm=')[0];
    return [session].concat(mediaSections.map(function (section) {
        section = section.replace(/\r\n$/, '');
        if (!/^m=video/.test(section)) {
            return section;
        }
        var codecMap = createCodecMapForMediaSection(section);
        var payloadTypes = getPayloadTypesInMediaSection(section);
        var vp8PayloadTypes = new Set(codecMap.get('vp8') || []);
        var hasVP8PayloadType = payloadTypes.some(function (payloadType) { return vp8PayloadTypes.has(payloadType); });
        return hasVP8PayloadType
            ? setSimulcastInMediaSection(section, sdpFormat, trackIdsToAttributes)
            : section;
    })).concat('').join('\r\n');
}
/**
 * Get the matching Payload Types in a unified plan m= section for a particular peer codec.
 * @param {Codec} peerCodec
 * @param {PT} peerPt
 * @param {Map<Codec, PT>} codecsToPts
 * @param {string} section
 * @param {string} peerSection
 * @returns {Array<PT>}
 */
function unifiedPlanGetMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) {
    // If there is at most one local Payload Type that matches the remote codec, retain it.
    var matchingPts = codecsToPts.get(peerCodec) || [];
    if (matchingPts.length <= 1) {
        return matchingPts;
    }
    // If there are no fmtp attributes for the codec in the peer m= section, then we
    // cannot get a match in the  m= section. In that case, retain all matching Payload
    // Types.
    var peerFmtpAttrs = getFmtpAttributesForPt(peerPt, peerSection);
    if (!peerFmtpAttrs) {
        return matchingPts;
    }
    // Among the matched local Payload Types, find the one that matches the remote
    // fmtp attributes.
    var matchingPt = matchingPts.find(function (pt) {
        var fmtpAttrs = getFmtpAttributesForPt(pt, section);
        return fmtpAttrs && Object.keys(peerFmtpAttrs).every(function (attr) {
            return peerFmtpAttrs[attr] === fmtpAttrs[attr];
        });
    });
    // If none of the matched Payload Types also have matching fmtp attributes,
    // then retain all of them, otherwise retain only the Payload Type that
    // matches the peer fmtp attributes.
    return typeof matchingPt === 'number' ? [matchingPt] : matchingPts;
}
/**
 * Filter codecs in a unified plan m= section based on its peer m= section.
 * from the other peer.
 * @param {string} section
 * @param {Map<string, string>} peerMidsToMediaSections
 * @param {Array<string>} codecsToRemove
 * @returns {string}
 */
function unifiedPlanFilterCodecsInMediaSection(section, peerMidsToMediaSections, codecsToRemove) {
    // Do nothing if the m= section represents neither audio nor video.
    if (!/^m=(audio|video)/.test(section)) {
        return section;
    }
    // Do nothing if the m= section does not have an equivalent remote m= section.
    var mid = getMidForMediaSection(section);
    var peerSection = mid && peerMidsToMediaSections.get(mid);
    if (!peerSection) {
        return section;
    }
    // Construct a Map of the peer Payload Types to their codec names.
    var peerPtToCodecs = createPtToCodecName(peerSection);
    // Construct a Map of the codec names to their Payload Types.
    var codecsToPts = createCodecMapForMediaSection(section);
    // Maintain a list of non-rtx Payload Types to retain.
    var pts = flatMap(Array.from(peerPtToCodecs), function (_a) {
        var _b = __read(_a, 2), peerPt = _b[0], peerCodec = _b[1];
        return peerCodec !== 'rtx' && !codecsToRemove.includes(peerCodec)
            ? unifiedPlanGetMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection)
            : [];
    });
    // For each Payload Type that will be retained, retain their corresponding rtx
    // Payload Type if present.
    var rtxPts = codecsToPts.get('rtx') || [];
    // In "a=fmtp:<rtxPt> apt=<apt>", extract the codec PT <apt> associated with rtxPt.
    pts = pts.concat(rtxPts.filter(function (rtxPt) {
        var fmtpAttrs = getFmtpAttributesForPt(rtxPt, section);
        return fmtpAttrs && pts.includes(fmtpAttrs.apt);
    }));
    // Filter out the below mentioned attribute lines in the m= section that do not
    // belong to one of the Payload Types that are to be retained.
    // 1. "a=rtpmap:<pt> <codec>"
    // 2. "a=rtcp-fb:<pt> <attr>[ <attr>]*"
    // 3. "a=fmtp:<pt> <name>=<value>[;<name>=<value>]*"
    var lines = section.split('\r\n').filter(function (line) {
        var ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);
        var pt = ptMatches && ptMatches[2];
        return !ptMatches || (pt && pts.includes(parseInt(pt, 10)));
    });
    // Filter the list of Payload Types in the first line of the m= section.
    var orderedPts = getPayloadTypesInMediaSection(section).filter(function (pt) { return pts.includes(pt); });
    return setPayloadTypesInMediaSection(orderedPts, lines.join('\r\n'));
}
/**
 * Filter local codecs based on the remote unified plan SDP.
 * @param {string} localSdp
 * @param {string} remoteSdp
 * @returns {string} - Updated local SDP
 */
function unifiedPlanFilterLocalCodecs(localSdp, remoteSdp) {
    var localMediaSections = getMediaSections(localSdp);
    var localSession = localSdp.split('\r\nm=')[0];
    var remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);
    return [localSession].concat(localMediaSections.map(function (localSection) {
        return unifiedPlanFilterCodecsInMediaSection(localSection, remoteMidsToMediaSections, []);
    })).join('\r\n');
}
/**
 * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.
 * @param localSdp - simulcast enabled local sdp
 * @param localSdpWithoutSimulcast - local sdp before simulcast was set
 * @param remoteSdp - remote sdp
 * @return {string} Updated SDP string
 */
function revertSimulcastForNonVP8MediaSections(localSdp, localSdpWithoutSimulcast, remoteSdp) {
    var remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);
    var localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);
    var mediaSections = getMediaSections(localSdp);
    var session = localSdp.split('\r\nm=')[0];
    return [session].concat(mediaSections.map(function (section) {
        section = section.replace(/\r\n$/, '');
        if (!/^m=video/.test(section)) {
            return section;
        }
        var midMatches = section.match(/^a=mid:(.+)$/m);
        var mid = midMatches && midMatches[1];
        if (!mid) {
            return section;
        }
        var remoteSection = remoteMidToMediaSections.get(mid);
        var remotePtToCodecs = createPtToCodecName(remoteSection);
        var remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);
        var isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';
        return isVP8ThePreferredCodec ? section : localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\r\n$/, '');
    })).concat('').join('\r\n');
}
/**
 * Add or rewrite MSIDs for new m= sections in the given Unified Plan SDP with their
 * corresponding local MediaStreamTrack IDs. These can be different when previously
 * removed MediaStreamTracks are added back (or Track IDs may not be present in the
 * SDPs at all once browsers implement the latest WebRTC spec).
 * @param {string} sdp
 * @param {Map<string, Track.ID>} activeMidsToTrackIds
 * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind
 * @returns {string}
 */
function unifiedPlanAddOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {
    // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually
    // present after the m= sections for the existing MediaStreamTracks, in order
    // of addition.
    var newMidsToTrackIds = Array.from(trackIdsByKind).reduce(function (midsToTrackIds, _a) {
        var _b = __read(_a, 2), kind = _b[0], trackIds = _b[1];
        var mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');
        var newMids = mediaSections.map(getMidForMediaSection).filter(function (mid) { return !activeMidsToTrackIds.has(mid); });
        newMids.forEach(function (mid, i) { return midsToTrackIds.set(mid, trackIds[i]); });
        return midsToTrackIds;
    }, new Map());
    return unifiedPlanAddOrRewriteTrackIds(sdp, newMidsToTrackIds);
}
/**
 * Add or rewrite MSIDs in the given Unified Plan SDP with their corresponding local
 * MediaStreamTrack IDs. These IDs need not be the same (or Track IDs may not be
 * present in the SDPs at all once browsers implement the latest WebRTC spec).
 * @param {string} sdp
 * @param {Map<string, Track.ID>} midsToTrackIds
 * @returns {string}
 */
function unifiedPlanAddOrRewriteTrackIds(sdp, midsToTrackIds) {
    var mediaSections = getMediaSections(sdp);
    var session = sdp.split('\r\nm=')[0];
    return [session].concat(mediaSections.map(function (mediaSection) {
        // Do nothing if the m= section represents neither audio nor video.
        if (!/^m=(audio|video)/.test(mediaSection)) {
            return mediaSection;
        }
        // This shouldn't happen, but in case there is no MID for the m= section, do nothing.
        var mid = getMidForMediaSection(mediaSection);
        if (!mid) {
            return mediaSection;
        }
        // In case there is no Track ID for the given MID in the map, do nothing.
        var trackId = midsToTrackIds.get(mid);
        if (!trackId) {
            return mediaSection;
        }
        // This shouldn't happen, but in case there is no a=msid: line, do nothing.
        var attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];
        if (!attributes) {
            return mediaSection;
        }
        // If the a=msid: line contains the "appdata" field, then replace it with the Track ID,
        // otherwise append the Track ID.
        var _a = __read(attributes.split(' '), 2), msid = _a[0], trackIdToRewrite = _a[1];
        var msidRegex = new RegExp("msid:" + msid + (trackIdToRewrite ? " " + trackIdToRewrite : '') + "$", 'gm');
        return mediaSection.replace(msidRegex, "msid:" + msid + " " + trackId);
    })).join('\r\n');
}
/**
 * removes specified ssrc attributes from given sdp
 * @param {string} sdp
 * @param {Array<string>} ssrcAttributesToRemove
 * @returns {string}
 */
function removeSSRCAttributes(sdp, ssrcAttributesToRemove) {
    return sdp.split('\r\n').filter(function (line) {
        return !ssrcAttributesToRemove.find(function (srcAttribute) { return new RegExp('a=ssrc:.*' + srcAttribute + ':', 'g').test(line); });
    }).join('\r\n');
}
/**
 * Disable RTX in a given sdp.
 * @param {string} sdp
 * @returns {string} sdp without RTX
 */
function disableRtx(sdp) {
    var mediaSections = getMediaSections(sdp);
    var session = sdp.split('\r\nm=')[0];
    return [session].concat(mediaSections.map(function (mediaSection) {
        // Do nothing if the m= section does not represent a video track.
        if (!/^m=video/.test(mediaSection)) {
            return mediaSection;
        }
        // Create a map of codecs to payload types.
        var codecsToPts = createCodecMapForMediaSection(mediaSection);
        // Get the RTX payload types.
        var rtxPts = codecsToPts.get('rtx');
        // Do nothing if there are no RTX payload types.
        if (!rtxPts) {
            return mediaSection;
        }
        // Remove the RTX payload types.
        var pts = new Set(getPayloadTypesInMediaSection(mediaSection));
        rtxPts.forEach(function (rtxPt) { return pts.delete(rtxPt); });
        // Get the RTX SSRC.
        var rtxSSRCMatches = mediaSection.match(/a=ssrc-group:FID [0-9]+ ([0-9]+)/);
        var rtxSSRC = rtxSSRCMatches && rtxSSRCMatches[1];
        // Remove the following lines associated with the RTX payload types:
        // 1. "a=fmtp:<rtxPt> apt=<pt>"
        // 2. "a=rtpmap:<rtxPt> rtx/..."
        // 3. "a=ssrc:<rtxSSRC> cname:..."
        // 4. "a=ssrc-group:FID <SSRC> <rtxSSRC>"
        var filterRegexes = [
            /^a=fmtp:.+ apt=.+$/,
            /^a=rtpmap:.+ rtx\/.+$/,
            /^a=ssrc-group:.+$/
        ].concat(rtxSSRC
            ? [new RegExp("^a=ssrc:" + rtxSSRC + " .+$")]
            : []);
        mediaSection = mediaSection.split('\r\n')
            .filter(function (line) { return filterRegexes.every(function (regex) { return !regex.test(line); }); })
            .join('\r\n');
        // Reconstruct the m= section without the RTX payload types.
        return setPayloadTypesInMediaSection(Array.from(pts), mediaSection);
    })).join('\r\n');
}
/**
 * Generate an a=fmtp: line from the given payload type and attributes.
 * @param {PT} pt
 * @param {*} fmtpAttrs
 * @returns {string}
 */
function generateFmtpLineFromPtAndAttributes(pt, fmtpAttrs) {
    var serializedFmtpAttrs = Object.entries(fmtpAttrs).map(function (_a) {
        var _b = __read(_a, 2), name = _b[0], value = _b[1];
        return name + "=" + value;
    }).join(';');
    return "a=fmtp:" + pt + " " + serializedFmtpAttrs;
}
/**
 * Enable DTX for opus in the m= sections for the given MIDs.`
 * @param {string} sdp
 * @param {Array<string>} [mids] - If not specified, enables opus DTX for all
 *   audio m= lines.
 * @returns {string}
 */
function enableDtxForOpus(sdp, mids) {
    var mediaSections = getMediaSections(sdp);
    var session = sdp.split('\r\nm=')[0];
    mids = mids || mediaSections
        .filter(function (section) { return /^m=audio/.test(section); })
        .map(getMidForMediaSection);
    return [session].concat(mediaSections.map(function (section) {
        // Do nothing if the m= section is not audio.
        if (!/^m=audio/.test(section)) {
            return section;
        }
        // Build a map codecs to payload types.
        var codecsToPts = createCodecMapForMediaSection(section);
        // Do nothing if a payload type for opus does not exist.
        var opusPt = codecsToPts.get('opus');
        if (!opusPt) {
            return section;
        }
        // If no fmtp attributes are found for opus, do nothing.
        var opusFmtpAttrs = getFmtpAttributesForPt(opusPt, section);
        if (!opusFmtpAttrs) {
            return section;
        }
        // Add usedtx=1 to the a=fmtp: line for opus.
        var origOpusFmtpLine = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);
        var origOpusFmtpRegex = new RegExp(origOpusFmtpLine);
        // If the m= section's MID is in the list of MIDs, then enable dtx. Otherwise disable it.
        var mid = getMidForMediaSection(section);
        if (mids.includes(mid)) {
            opusFmtpAttrs.usedtx = 1;
        }
        else {
            delete opusFmtpAttrs.usedtx;
        }
        var opusFmtpLineWithDtx = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);
        return section.replace(origOpusFmtpRegex, opusFmtpLineWithDtx);
    })).join('\r\n');
}
exports.createCodecMapForMediaSection = createCodecMapForMediaSection;
exports.createPtToCodecName = createPtToCodecName;
exports.disableRtx = disableRtx;
exports.enableDtxForOpus = enableDtxForOpus;
exports.getMediaSections = getMediaSections;
exports.removeSSRCAttributes = removeSSRCAttributes;
exports.revertSimulcastForNonVP8MediaSections = revertSimulcastForNonVP8MediaSections;
exports.setBitrateParameters = setBitrateParameters;
exports.setCodecPreferences = setCodecPreferences;
exports.setSimulcast = setSimulcast;
exports.unifiedPlanFilterLocalCodecs = unifiedPlanFilterLocalCodecs;
exports.unifiedPlanAddOrRewriteNewTrackIds = unifiedPlanAddOrRewriteNewTrackIds;
exports.unifiedPlanAddOrRewriteTrackIds = unifiedPlanAddOrRewriteTrackIds;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/sdp/issue8329.js":
/*!*************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/sdp/issue8329.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var RTCSessionDescription = __webpack_require__(/*! @twilio/webrtc */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/index.js").RTCSessionDescription;
var createPtToCodecName = __webpack_require__(/*! ./ */ "../../work/twilio-video.js/es5/util/sdp/index.js").createPtToCodecName;
var getMediaSections = __webpack_require__(/*! ./ */ "../../work/twilio-video.js/es5/util/sdp/index.js").getMediaSections;
/**
 * An RTX payload type
 * @typedef {PT} RtxPT
 */
/**
 * A non-RTX payload type
 * @typedef {PT} NonRtxPT
 */
/**
 * A Set with at least one element
 * @typedef {Set} NonEmptySet
 */
/**
 * Apply the workaround for Issue 8329 to an RTCSessionDescriptionInit.
 * @param {RTCSessionDescriptionInit} description
 * @returns {RTCSessionDescription} newDescription
 */
function workaround(description) {
    var descriptionInit = { type: description.type };
    if (description.type !== 'rollback') {
        descriptionInit.sdp = sdpWorkaround(description.sdp);
    }
    return new RTCSessionDescription(descriptionInit);
}
/**
 * @param {string} sdp
 * @returns {string} newSdp
 */
function sdpWorkaround(sdp) {
    var mediaSections = getMediaSections(sdp);
    var session = sdp.split('\r\nm=')[0];
    return [session]
        .concat(mediaSections.map(mediaSectionWorkaround))
        .join('\r\n');
}
/**
 * @param {string} mediaSection
 * @returns {string} newMediaSection
 */
function mediaSectionWorkaround(mediaSection) {
    var ptToCodecName = createPtToCodecName(mediaSection);
    mediaSection = deleteDuplicateRtxPts(mediaSection, ptToCodecName);
    var codecNameToPts = createCodecNameToPts(ptToCodecName);
    var rtxPts = codecNameToPts.get('rtx') || new Set();
    var invalidRtxPts = new Set();
    var rtxPtToAssociatedPt = createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts);
    var associatedPtToRtxPt = createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts);
    var unassociatedRtxPts = Array.from(invalidRtxPts);
    // NOTE(mroberts): We normalize to lowercase.
    var knownCodecNames = ['h264', 'vp8', 'vp9'];
    var unassociatedPts = knownCodecNames.reduce(function (unassociatedPts, codecName) {
        var pts = codecNameToPts.get(codecName) || new Set();
        return Array.from(pts).reduce(function (unassociatedPts, pt) { return associatedPtToRtxPt.has(pt)
            ? unassociatedPts
            : unassociatedPts.add(pt); }, unassociatedPts);
    }, new Set());
    unassociatedPts.forEach(function (pt) {
        if (unassociatedRtxPts.length) {
            var rtxPt = unassociatedRtxPts.shift();
            mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);
            mediaSection = addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt);
        }
    });
    unassociatedRtxPts.forEach(function (rtxPt) {
        mediaSection = deleteFmtpAttributesForRtxPt(mediaSection, rtxPt);
        mediaSection = deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt);
    });
    return mediaSection;
}
/**
 * @param {string} mediaSection
 * @param {Map<PT, Codec>} ptToCodecName
 * @returns {string} newMediaSection
 */
function deleteDuplicateRtxPts(mediaSection, ptToCodecName) {
    // NOTE(syerrapragada): In some cases Chrome produces an offer/answer
    // with duplicate "rtx" payload mapping in media section. When applied,
    // Chrome rejects the SDP. We workaround this by deleting duplicate
    // "rtx" mappings found in SDP.
    return Array.from(ptToCodecName.keys()).reduce(function (section, pt) {
        var rtpmapRegex = new RegExp("^a=rtpmap:" + pt + " rtx.+$", 'gm');
        return (section.match(rtpmapRegex) || []).slice(ptToCodecName.get(pt) === 'rtx' ? 1 : 0).reduce(function (section, rtpmap) {
            var rtpmapRegex = new RegExp("\r\n" + rtpmap);
            var fmtpmapRegex = new RegExp("\r\na=fmtp:" + pt + " apt=[0-9]+");
            return section.replace(rtpmapRegex, '').replace(fmtpmapRegex, '');
        }, section);
    }, mediaSection);
}
/**
 * @param {Map<PT, Codec>} ptToCodecName
 * @returns {Map<string, NonEmptySet<PT>>} codecNameToPts
 */
function createCodecNameToPts(ptToCodecName) {
    var codecNameToPts = new Map();
    ptToCodecName.forEach(function (codecName, pt) {
        var pts = codecNameToPts.get(codecName) || new Set();
        return codecNameToPts.set(codecName, pts.add(pt));
    });
    return codecNameToPts;
}
/**
 * @param {string} mediaSection
 * @param {Map<PT, Codec>} ptToCodecName
 * @param {Set<RtxPT>} rtxPts
 * @param {Set<RtxPT>} invalidRtxPts
 * @returns {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt
 */
function createRtxPtToAssociatedPt(mediaSection, ptToCodecName, rtxPts, invalidRtxPts) {
    return Array.from(rtxPts).reduce(function (rtxPtToAssociatedPt, rtxPt) {
        var fmtpPattern = new RegExp("a=fmtp:" + rtxPt + " apt=(\\d+)");
        var matches = mediaSection.match(fmtpPattern);
        if (!matches) {
            invalidRtxPts.add(rtxPt);
            return rtxPtToAssociatedPt;
        }
        var pt = Number.parseInt(matches[1]);
        if (!ptToCodecName.has(pt)) {
            // This is Issue 8329.
            invalidRtxPts.add(rtxPt);
            return rtxPtToAssociatedPt;
        }
        var codecName = ptToCodecName.get(pt);
        if (codecName === 'rtx') {
            // Strange
            invalidRtxPts.add(rtxPt);
            return rtxPtToAssociatedPt;
        }
        return rtxPtToAssociatedPt.set(rtxPt, pt);
    }, new Map());
}
/**
 * @param {string} mediaSection
 * @param {Map<RtxPT, NonRtxPT>} rtxPtToAssociatedPt
 * @param {Set<RtxPT>} invalidRtxPts
 * @returns {Map<NonRtxPT, RtxPT>} associatedPtToRtxPt
 */
function createAssociatedPtToRtxPt(rtxPtToAssociatedPt, invalidRtxPts) {
    // First, we construct a Map<NonRtxPT, NonEmptySet<RtxPT>>.
    var associatedPtToRtxPts = Array.from(rtxPtToAssociatedPt).reduce(function (associatedPtToRtxPts, pair) {
        var rtxPt = pair[0];
        var pt = pair[1];
        var rtxPts = associatedPtToRtxPts.get(pt) || new Set();
        return associatedPtToRtxPts.set(pt, rtxPts.add(rtxPt));
    }, new Map());
    // Then, we filter down to a Map<NonRtxPT, RtxPt>. Any RtxPTs that map to the
    // same NonRtxPT are removed and added to invalidRtxPts.
    return Array.from(associatedPtToRtxPts).reduce(function (associatedPtToRtxPt, pair) {
        var pt = pair[0];
        var rtxPts = Array.from(pair[1]);
        if (rtxPts.length > 1) {
            rtxPts.forEach(function (rtxPt) {
                invalidRtxPts.add(rtxPt);
            });
            return associatedPtToRtxPt;
        }
        return associatedPtToRtxPt.set(pt, rtxPts[0]);
    }, new Map());
}
/**
 * @param {string} mediaSection
 * @param {RtxPT} rtxPt
 * @returns {string} newMediaSection
 */
function deleteFmtpAttributesForRtxPt(mediaSection, rtxPt) {
    var pattern = new RegExp("a=fmtp:" + rtxPt + ".*\r\n", 'gm');
    return mediaSection.replace(pattern, '');
}
/**
 * @param {string} mediaSection
 * @param {RtxPT} rtxPt
 * @returns {string} newMediaSection
 */
function deleteRtpmapAttributesForRtxPt(mediaSection, rtxPt) {
    var pattern = new RegExp("a=rtpmap:" + rtxPt + ".*\r\n", 'gm');
    return mediaSection.replace(pattern, '');
}
/**
 * @param {string} mediaSection
 * @param {RtxPT} rtxPt
 * @param {NonRtxPT} pt
 * @returns {string} newMediaSection
 */
function addFmtpAttributeForRtxPt(mediaSection, rtxPt, pt) {
    return mediaSection.endsWith('\r\n')
        ? mediaSection + "a=fmtp:" + rtxPt + " apt=" + pt + "\r\n"
        : mediaSection + "\r\na=fmtp:" + rtxPt + " apt=" + pt;
}
module.exports = workaround;
//# sourceMappingURL=issue8329.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/sdp/simulcast.js":
/*!*************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/sdp/simulcast.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var difference = __webpack_require__(/*! ../ */ "../../work/twilio-video.js/es5/util/index.js").difference;
var flatMap = __webpack_require__(/*! ../ */ "../../work/twilio-video.js/es5/util/index.js").flatMap;
/**
 * Create a random {@link SSRC}.
 * @returns {SSRC}
 */
function createSSRC() {
    var ssrcMax = 0xffffffff;
    return String(Math.floor(Math.random() * ssrcMax));
}
/**
 * @property {string} cName
 * @property {boolean} isSimulcastEnabled
 * @property {Map<RtxSSRC, PrimarySSRC>} rtxPairs
 * @property {Set<PrimarySSRC>} primarySSRCs
 * @property {string} streamId
 * @property {Track.ID} trackId
 */
var TrackAttributes = /** @class */ (function () {
    /**
     * Construct a {@link MediaStreamTrack} attribute store.
     * @param {Track.ID} trackId - The MediaStreamTrack ID
     * @param {MediaStreamID} streamId - The MediaStream ID
     * @param {string} cName - The MediaStream cname
     */
    function TrackAttributes(trackId, streamId, cName) {
        Object.defineProperties(this, {
            cName: {
                enumerable: true,
                value: cName
            },
            isSimulcastEnabled: {
                enumerable: true,
                value: false,
                writable: true
            },
            primarySSRCs: {
                enumerable: true,
                value: new Set()
            },
            rtxPairs: {
                enumerable: true,
                value: new Map()
            },
            streamId: {
                enumerable: true,
                value: streamId
            },
            trackId: {
                enumerable: true,
                value: trackId
            }
        });
    }
    /**
     * Add {@link SimSSRC}s to the {@link TrackAttributes}.
     * @returns {void}
     */
    TrackAttributes.prototype.addSimulcastSSRCs = function () {
        if (this.isSimulcastEnabled) {
            return;
        }
        var simulcastSSRCs = [createSSRC(), createSSRC()];
        simulcastSSRCs.forEach(function (ssrc) {
            this.primarySSRCs.add(ssrc);
        }, this);
        if (this.rtxPairs.size) {
            simulcastSSRCs.forEach(function (ssrc) {
                this.rtxPairs.set(createSSRC(), ssrc);
            }, this);
        }
    };
    /**
     * Add the given {@link PrimarySSRC} or {@link RtxSSRC} to the {@link TrackAttributes}
     * and update the "isSimulcastEnabled" flag if it is also a {@link SimSSRC}.
     * @param {SSRC} ssrc - The {@link SSRC} to be added
     * @param {?PrimarySSRC} primarySSRC - The {@link PrimarySSRC}; if the given
     *   {@link SSRC} itself is the {@link PrimarySSRC}, then this is set to null
     * @param {boolean} isSimSSRC - true if the given {@link SSRC} is a
     *   {@link SimSSRC}; false otherwise
     * @returns {void}
     */
    TrackAttributes.prototype.addSSRC = function (ssrc, primarySSRC, isSimSSRC) {
        if (primarySSRC) {
            this.rtxPairs.set(ssrc, primarySSRC);
        }
        else {
            this.primarySSRCs.add(ssrc);
        }
        this.isSimulcastEnabled = this.isSimulcastEnabled || isSimSSRC;
    };
    /**
     * Construct the SDP lines for the {@link TrackAttributes}.
     * @param {boolean} [excludeRtx=false]
     * @returns {Array<string>} Array of SDP lines
     */
    TrackAttributes.prototype.toSdpLines = function (excludeRtx) {
        var _this = this;
        var rtxPairs = excludeRtx
            ? []
            : Array.from(this.rtxPairs.entries()).map(function (rtxPair) { return rtxPair.reverse(); });
        var simSSRCs = Array.from(this.primarySSRCs.values());
        var ssrcs = rtxPairs.length ? flatMap(rtxPairs) : simSSRCs;
        var attrLines = flatMap(ssrcs, function (ssrc) { return [
            "a=ssrc:" + ssrc + " cname:" + _this.cName,
            "a=ssrc:" + ssrc + " msid:" + _this.streamId + " " + _this.trackId
        ]; });
        var rtxPairLines = rtxPairs.map(function (rtxPair) { return "a=ssrc-group:FID " + rtxPair.join(' '); });
        var simGroupLines = [
            "a=ssrc-group:SIM " + simSSRCs.join(' ')
        ];
        return rtxPairLines.concat(attrLines).concat(simGroupLines);
    };
    return TrackAttributes;
}());
/**
 * Get the matches for a given RegEx pattern.
 * @param {string} section - SDP media section
 * @param {string} pattern - RegEx pattern
 * @returns {Array<Array<string>>} - Array of pattern matches
 */
function getMatches(section, pattern) {
    var matches = section.match(new RegExp(pattern, 'gm')) || [];
    return matches.map(function (match) {
        var matches = match.match(new RegExp(pattern)) || [];
        return matches.slice(1);
    });
}
/**
 * Get the {@link SimSSRC}s that belong to a simulcast group.
 * @param {string} section - SDP media section
 * @returns {Set<SimSSRC>} Set of simulcast {@link SSRC}s
 */
function getSimulcastSSRCs(section) {
    var simGroupPattern = '^a=ssrc-group:SIM ([0-9]+) ([0-9]+) ([0-9]+)$';
    return new Set(flatMap(getMatches(section, simGroupPattern)));
}
/**
 * Get the value of the given attribute for an SSRC.
 * @param {string} section - SDP media section
 * @param {SSRC} ssrc - {@link SSRC} whose attribute's value is to be determinded
 * @param {string} attribute - {@link SSRC} attribute name
 * @param {string} - {@link SSRC} attribute value
 */
function getSSRCAttribute(section, ssrc, attribute) {
    var pattern = "a=ssrc:" + ssrc + " " + attribute + ":(.+)";
    return section.match(new RegExp(pattern))[1];
}
/**
 * Create a Map of {@link PrimarySSRC}s and their {@link RtxSSRC}s.
 * @param {string} section - SDP media section
 * @returns {Map<RtxSSRC, PrimarySSRC>} - Map of {@link RtxSSRC}s and their
 *   corresponding {@link PrimarySSRC}s
 */
function getSSRCRtxPairs(section) {
    var rtxPairPattern = '^a=ssrc-group:FID ([0-9]+) ([0-9]+)$';
    return new Map(getMatches(section, rtxPairPattern).map(function (pair) { return pair.reverse(); }));
}
/**
 * Create SSRC attribute tuples.
 * @param {string} section
 * @param {'planb' | 'unified'} sdpFormat
 * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}
 */
function createSSRCAttributeTuples(section, sdpFormat) {
    return {
        planb: createPlanBSSRCAttributeTuples,
        unified: createUnifiedPlanSSRCAttributeTuples
    }[sdpFormat](section);
}
/**
 * Create "plan-b" SSRC attribute tuples.
 * @param {string} section
 * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}
 */
function createPlanBSSRCAttributeTuples(section) {
    return getMatches(section, '^a=ssrc:([0-9]+) msid:([^\\s]+) ([^\\s]+)$');
}
/**
 * Create "unified-plan" SSRC attribute tuples.
 * @param {string} section
 * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}
 */
function createUnifiedPlanSSRCAttributeTuples(section) {
    var _a = __read(flatMap(getMatches(section, '^a=msid:(.+) (.+)$')), 2), streamId = _a[0], trackId = _a[1];
    var ssrcs = flatMap(getMatches(section, '^a=ssrc:(.+) cname:.+$'));
    return ssrcs.map(function (ssrc) { return [ssrc, streamId, trackId]; });
}
/**
 * Create a Map of MediaStreamTrack IDs and their {@link TrackAttributes}.
 * @param {string} section - SDP media section
 * @param {'planb' | 'unified'} sdpFormat
 * @returns {Map<Track.ID, TrackAttributes>}
 */
function createTrackIdsToAttributes(section, sdpFormat) {
    var simSSRCs = getSimulcastSSRCs(section);
    var rtxPairs = getSSRCRtxPairs(section);
    var ssrcAttrTuples = createSSRCAttributeTuples(section, sdpFormat);
    return ssrcAttrTuples.reduce(function (trackIdsToSSRCs, tuple) {
        var ssrc = tuple[0];
        var streamId = tuple[1];
        var trackId = tuple[2];
        var trackAttributes = trackIdsToSSRCs.get(trackId) || new TrackAttributes(trackId, streamId, getSSRCAttribute(section, ssrc, 'cname'));
        var primarySSRC = rtxPairs.get(ssrc) || null;
        trackAttributes.addSSRC(ssrc, primarySSRC, simSSRCs.has(ssrc));
        return trackIdsToSSRCs.set(trackId, trackAttributes);
    }, new Map());
}
/**
 * Apply simulcast settings to the given SDP media section.
 * @param {string} section - SDP media section
 * @param {'planb' | 'unified'} sdpFormat
 * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes - Existing
 *   map which will be updated for new MediaStreamTrack IDs
 * @returns {string} - The transformed SDP media section
 */
function setSimulcastInMediaSection(section, sdpFormat, trackIdsToAttributes) {
    var newTrackIdsToAttributes = createTrackIdsToAttributes(section, sdpFormat);
    var newTrackIds = Array.from(newTrackIdsToAttributes.keys());
    var trackIds = Array.from(trackIdsToAttributes.keys());
    var trackIdsToAdd = difference(newTrackIds, trackIds);
    var trackIdsToIgnore = difference(trackIds, newTrackIds);
    // Update "trackIdsToAttributes" with TrackAttributes for new
    // MediaStreamTrack IDs.
    var trackAttributesToAdd = flatMap(trackIdsToAdd, function (trackId) { return newTrackIdsToAttributes.get(trackId); });
    trackAttributesToAdd.forEach(function (trackAttributes) {
        trackAttributes.addSimulcastSSRCs();
        trackIdsToAttributes.set(trackAttributes.trackId, trackAttributes);
    });
    // Get the SDP lines of the relevant MediaStreamTrack IDs from
    // "trackIdsToAttributes".
    trackIds = Array.from(trackIdsToAttributes.keys());
    var relevantTrackIds = difference(trackIds, trackIdsToIgnore);
    var relevantTrackAttributes = flatMap(relevantTrackIds, function (trackId) { return trackIdsToAttributes.get(trackId); });
    var excludeRtx = !section.match(/a=rtpmap:[0-9]+ rtx/);
    var relevantSdpLines = flatMap(relevantTrackAttributes, function (trackAttributes) { return trackAttributes.toSdpLines(excludeRtx); });
    // Add the simulcast SSRC SDP lines to the media section. The Set ensures
    // that the duplicates of the SSRC SDP lines that are in both "section" and
    // "relevantSdpLines" are removed.
    var sectionLines = flatMap(new Set(section.split('\r\n').concat(relevantSdpLines)));
    var xGoogleFlagConference = 'a=x-google-flag:conference';
    if (!section.match(xGoogleFlagConference)) {
        sectionLines.push(xGoogleFlagConference);
    }
    return sectionLines.join('\r\n');
}
/**
 * String representing a MediaStream ID.
 * @typedef {string} MediaStreamID
 */
/**
 * String representing the SSRC of a MediaStreamTrack.
 * @typedef {string} SSRC
 */
/**
 * Primary SSRC.
 * @typedef {SSRC} PrimarySSRC
 */
/**
 * Retransmission SSRC.
 * @typedef {SSRC} RtxSSRC
 */
/**
 * Simulcast SSRC.
 * @typedef {SSRC} SimSSRC
 */
module.exports = setSimulcastInMediaSection;
//# sourceMappingURL=simulcast.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/sdp/trackmatcher/identity.js":
/*!*************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/sdp/trackmatcher/identity.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * An {@link IdentityTrackMatcher} matches RTCTrackEvents with their respective
 * MediaStreamTrack IDs.
 */
var IdentityTrackMatcher = /** @class */ (function () {
    function IdentityTrackMatcher() {
    }
    /**
    * Match a given MediaStreamTrack with its ID.
    * @param {RTCTrackEvent} event
    * @returns {Track.ID}
    */
    IdentityTrackMatcher.prototype.match = function (event) {
        return event.track.id;
    };
    /**
    * Update the {@link IdentityTrackMatcher} with a new SDP.
    * @param {string} sdp
    */
    IdentityTrackMatcher.prototype.update = function () { };
    return IdentityTrackMatcher;
}());
module.exports = IdentityTrackMatcher;
//# sourceMappingURL=identity.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/sdp/trackmatcher/mid.js":
/*!********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/sdp/trackmatcher/mid.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getMediaSections = __webpack_require__(/*! ../ */ "../../work/twilio-video.js/es5/util/sdp/index.js").getMediaSections;
/**
 * An {@link MIDTrackMatcher} matches an RTCTrackEvent with a MediaStreamTrack
 * ID based on the MID of the underlying RTCRtpTransceiver.
 */
var MIDTrackMatcher = /** @class */ (function () {
    /**
     * Construct an {@link MIDTrackMatcher}.
     */
    function MIDTrackMatcher() {
        Object.defineProperties(this, {
            _midsToTrackIds: {
                value: new Map(),
                writable: true
            }
        });
    }
    /**
     * Match a given MediaStreamTrack with its ID.
     * @param {RTCTrackEvent} event
     * @returns {?Track.ID}
     */
    MIDTrackMatcher.prototype.match = function (event) {
        return this._midsToTrackIds.get(event.transceiver.mid) || null;
    };
    /**
     * Update the {@link MIDTrackMatcher} with a new SDP.
     * @param {string} sdp
     */
    MIDTrackMatcher.prototype.update = function (sdp) {
        var sections = getMediaSections(sdp, '(audio|video)');
        this._midsToTrackIds = sections.reduce(function (midsToTrackIds, section) {
            var midMatches = section.match(/^a=mid:(.+)$/m) || [];
            var trackIdMatches = section.match(/^a=msid:.+ (.+)$/m) || [];
            var mid = midMatches[1];
            var trackId = trackIdMatches[1];
            return mid && trackId ? midsToTrackIds.set(mid, trackId) : midsToTrackIds;
        }, this._midsToTrackIds);
    };
    return MIDTrackMatcher;
}());
module.exports = MIDTrackMatcher;
//# sourceMappingURL=mid.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/sdp/trackmatcher/ordered.js":
/*!************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/sdp/trackmatcher/ordered.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util = __webpack_require__(/*! ../../ */ "../../work/twilio-video.js/es5/util/index.js");
var getMediaSections = __webpack_require__(/*! ../ */ "../../work/twilio-video.js/es5/util/sdp/index.js").getMediaSections;
// NOTE(mroberts): OrderedTrackMatcher is meant to solve the problem identified in
//
//   https://bugs.webkit.org/show_bug.cgi?id=174519
//
// Namely that, without MIDs, we cannot "correctly" identify MediaStreamTracks
// in Safari's current WebRTC implementation. So, this module tries to hack
// around this by making a possibly dangerous assumption: "track" events will
// be raised for MediaStreamTracks of a particular kind in the same order that
// those kinds' MSIDs appear in the SDP. By calling `update` with an
// RTCPeerConnection's `remoteDescription` and then invoking `match`, we ought
// to be able to dequeue MediaStreamTrack IDs in the correct order to be
// assigned to "track" events.
/**
 * @interface MatchedAndUnmatched
 * @property {Set<Track.ID>} matched
 * @property {Set<Track.ID>} unmatched
 */
/**
 * Create a new instance of {@link MatchedAndUnmatched}.
 * @returns {MatchedAndUnmatched}
 */
function create() {
    return {
        matched: new Set(),
        unmatched: new Set()
    };
}
/**
 * Attempt to match a MediaStreamTrack ID.
 * @param {MatchedAndUnmatched} mAndM
 * @returns {?Track.ID} id
 */
function match(mAndM) {
    var unmatched = Array.from(mAndM.unmatched);
    if (!unmatched.length) {
        return null;
    }
    var id = unmatched[0];
    mAndM.matched.add(id);
    mAndM.unmatched.delete(id);
    return id;
}
/**
 * Update a {@link MatchedAndUnmatched}'s MediaStreamTrack IDs.
 * @param {MatchedAndUnmatched} mAndM
 * @param {Set<Track.ID>} ids
 * @returns {void}
 */
function update(mAndM, ids) {
    ids = new Set(ids);
    var removedMatchedIds = util.difference(mAndM.matched, ids);
    removedMatchedIds.forEach(mAndM.matched.delete, mAndM.matched);
    mAndM.unmatched = util.difference(ids, mAndM.matched);
}
/**
 * Parse MediaStreamTrack IDs of a particular kind from an SDP.
 * @param {string} kind
 * @param {string} sdp
 * @returns {Set<Track.ID>} ids
 */
function parse(kind, sdp) {
    var mediaSections = getMediaSections(sdp, kind);
    var pattern = 'msid: ?(.+) +(.+) ?$';
    return new Set(util.flatMap(mediaSections, function (mediaSection) { return mediaSection.match(new RegExp(pattern, 'mg')) || []; }).map(function (msid) { return msid.match(new RegExp(pattern))[2]; }));
}
/**
 * A {@link OrderedTrackMatcher} is used to match RTCTrackEvents.
 * @property {MatchedAndUnmatched} audio
 * @property {MatchedAndUnmatched} video
 */
var OrderedTrackMatcher = /** @class */ (function () {
    function OrderedTrackMatcher() {
        if (!(this instanceof OrderedTrackMatcher)) {
            return new OrderedTrackMatcher();
        }
        Object.defineProperties(this, {
            audio: {
                enumerable: true,
                value: create()
            },
            video: {
                enumerable: true,
                value: create()
            }
        });
    }
    /**
     * Attempt to match a new MediaStreamTrack ID.
     * @param {RTCTrackEvent} event
     * @returns {?Track.ID} id
     */
    OrderedTrackMatcher.prototype.match = function (event) {
        return match(this[event.track.kind]);
    };
    /**
     * Update the {@link OrderedTrackMatcher} with a new SDP.
     * @param {string} sdp
     * @returns {void}
     */
    OrderedTrackMatcher.prototype.update = function (sdp) {
        ['audio', 'video'].forEach(function (kind) {
            update(this[kind], parse(kind, sdp));
        }, this);
    };
    return OrderedTrackMatcher;
}());
module.exports = OrderedTrackMatcher;
//# sourceMappingURL=ordered.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/support.js":
/*!*******************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/support.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals chrome, navigator */

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var _a = __webpack_require__(/*! @twilio/webrtc/lib/util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js"), guessBrowser = _a.guessBrowser, isWebRTCSupported = _a.support;
var SUPPORTED_CHROME_BASED_BROWSERS = [
    'edg',
    'edge',
    'electron',
    'headlesschrome'
];
var SUPPORTED_ANDROID_BROWSERS = [
    'chrome',
    'firefox'
];
var SUPPORTED_IOS_BROWSERS = [
    'safari'
];
// Currently none. Add 'brave', 'edg', and 'edge' here once we start supporting them
var SUPPORTED_MOBILE_WEBKIT_BASED_BROWSERS = [];
/**
 * Get the top level parenthesized substrings within a given string. Unmatched
 * parentheses are ignored.
 * Ex: "abc) (def) gh(ij) (kl (mn)o) (pqr" => ["(def)", "(ij)", "(kl (mn)o)"]
 * @param {string} string
 * @returns {string[]}
 */
function getParenthesizedSubstrings(string) {
    var openParenthesisPositions = [];
    var substrings = [];
    for (var i = 0; i < string.length; i++) {
        if (string[i] === '(') {
            openParenthesisPositions.push(i);
        }
        else if (string[i] === ')' && openParenthesisPositions.length > 0) {
            var openParenthesisPosition = openParenthesisPositions.pop();
            if (openParenthesisPositions.length === 0) {
                substrings.push(string.substring(openParenthesisPosition, i + 1));
            }
        }
    }
    return substrings;
}
/**
 * Check whether the current browser is a mobile browser
 * @param {string} userAgent
 * @returns {boolean}
 */
function isMobile(userAgent) {
    userAgent = userAgent || navigator.userAgent;
    return /Mobi/.test(userAgent);
}
/**
 * Check whether the current browser is non-Chromium Edge.
 * @param {string} browser
 * @returns {boolean}
 */
function isNonChromiumEdge(browser) {
    return browser === 'chrome' && /Edge/.test(navigator.userAgent) && (typeof chrome === 'undefined' || typeof chrome.runtime === 'undefined');
}
/**
 * Get the name of the rebranded Chromium browser, if any. Re-branded Chrome's user
 * agent has the following format:
 * <source>/<version> (<os>) <engine>/<version> (<engine_name>) Chrome/<version> [Mobile] Safari/<version>
 * @param browser
 * @returns {?string} Name of the rebranded Chrome browser, or null if the browser
 *   is either not Chrome or vanilla Chrome.
 */
function rebrandedChromeBrowser(browser) {
    // If the browser is not Chrome based, then it is not a rebranded Chrome browser.
    if (browser !== 'chrome') {
        return null;
    }
    // Latest desktop Brave browser has a "brave" property in navigator.
    if ('brave' in navigator) {
        return 'brave';
    }
    // Remove the "(.+)" entries from the user agent thereby retaining only the
    // <name>[/<version>] entries.
    var parenthesizedSubstrings = getParenthesizedSubstrings(navigator.userAgent);
    var nameAndVersions = parenthesizedSubstrings.reduce(function (userAgent, substring) { return userAgent.replace(substring, ''); }, navigator.userAgent);
    // Extract the potential browser <name>s by ignoring the first two names, which
    // point to <source> and <engine>.
    var matches = nameAndVersions.match(/[^\s]+/g) || [];
    var _a = __read(matches.map(function (nameAndVersion) {
        return nameAndVersion.split('/')[0].toLowerCase();
    })), browserNames = _a.slice(2);
    // Extract the <name> that is not expected to be present in the vanilla Chrome
    // browser, which indicates the rebranded name (ex: "edg[e]", "electron"). If null,
    // then this is a vanilla Chrome browser.
    return browserNames.find(function (name) {
        return !['chrome', 'mobile', 'safari'].includes(name);
    }) || null;
}
/**
 * Get the name of the mobile webkit based browser, if any.
 * @param browser
 * @returns {?string} Name of the mobile webkit based browser, or null if the browser
 *   is either not webkit based or mobile safari.
 */
function mobileWebKitBrowser(browser) {
    if (browser !== 'safari') {
        return null;
    }
    if ('brave' in navigator) {
        return 'brave';
    }
    return ['edge', 'edg'].find(function (name) {
        return navigator.userAgent.toLowerCase().includes(name);
    }) || null;
}
/**
 * Check if the current browser is officially supported by twilio-video.js.
 * @returns {boolean}
 */
function isSupported() {
    var browser = guessBrowser();
    // NOTE (csantos): Return right away if there is no browser detected
    // to prevent unnecessary checks which could lead to errors
    if (!browser) {
        return false;
    }
    var rebrandedChrome = rebrandedChromeBrowser(browser);
    var mobileWebKit = mobileWebKitBrowser(browser);
    var supportedMobileBrowsers = /android/.test(navigator.userAgent.toLowerCase()) ?
        SUPPORTED_ANDROID_BROWSERS : SUPPORTED_IOS_BROWSERS;
    return !!browser
        && isWebRTCSupported()
        && (!rebrandedChrome || SUPPORTED_CHROME_BASED_BROWSERS.includes(rebrandedChrome))
        && !isNonChromiumEdge(browser)
        && (!mobileWebKit || SUPPORTED_MOBILE_WEBKIT_BASED_BROWSERS.includes(mobileWebKit))
        && (!isMobile() || supportedMobileBrowsers.includes(browser));
}
module.exports = isSupported;
//# sourceMappingURL=support.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/timeout.js":
/*!*******************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/timeout.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A {@link Timeout} represents a resettable and clearable timeout.
 */
var Timeout = /** @class */ (function () {
    /**
     * Construct a {@link Timeout}.
     * @param {function} fn - Function to call
     * @param {number} delay - Delay in milliseconds
     * @param {boolean} [autoStart=true] - If true, then start the {@link Timeout}.
     */
    function Timeout(fn, delay, autoStart) {
        if (autoStart === void 0) { autoStart = true; }
        Object.defineProperties(this, {
            _delay: {
                value: delay,
                writable: true
            },
            _fn: {
                value: fn
            },
            _timeout: {
                value: null,
                writable: true
            }
        });
        if (autoStart) {
            this.start();
        }
    }
    Object.defineProperty(Timeout.prototype, "delay", {
        /**
         * The {@link Timeout} delay in milliseconds.
         * @property {number}
         */
        get: function () {
            return this._delay;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timeout.prototype, "isSet", {
        /**
         * Whether the {@link Timeout} is set.
         * @property {boolean}
         */
        get: function () {
            return !!this._timeout;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Update the {@link Timeout} delay.
     * @param {number} delay
     * @returns {void}
     */
    Timeout.prototype.setDelay = function (delay) {
        this._delay = delay;
    };
    /**
     * Start the {@link Timeout}, if not already started.
     * @returns {void}
     */
    Timeout.prototype.start = function () {
        var _this = this;
        if (!this.isSet) {
            this._timeout = setTimeout(function () {
                var fn = _this._fn;
                _this.clear();
                fn();
            }, this._delay);
        }
    };
    /**
     * Clear the {@link Timeout}.
     * @returns {void}
     */
    Timeout.prototype.clear = function () {
        clearTimeout(this._timeout);
        this._timeout = null;
    };
    /**
     * Reset the {@link Timeout}.
     * @returns {void}
     */
    Timeout.prototype.reset = function () {
        this.clear();
        this.start();
    };
    return Timeout;
}());
module.exports = Timeout;
//# sourceMappingURL=timeout.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/twilio-video-errors.js":
/*!*******************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/twilio-video-errors.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// NOTE: Do not edit this file. This code is auto-generated. Contact the
// Twilio SDK Team for more information.

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TwilioError = __webpack_require__(/*! ./twilioerror */ "../../work/twilio-video.js/es5/util/twilioerror.js");
var TwilioErrorByCode = {};
/**
 * Create a {@link TwilioError} for a given code and message.
 * @private
 * @param {number} [code] - Error code
 * @param {string} [message] - Error message
 * @returns {TwilioError}
 */
exports.createTwilioError = function createTwilioError(code, message) {
    code = typeof code === 'number' ? code : 0;
    message = typeof message === 'string' && message ? message : 'Unknown error';
    return TwilioErrorByCode[code] ? new TwilioErrorByCode[code]() : new TwilioError(code, message);
};
// Note(mpatwardhan): We derive twilio specific errors here. After typescript compiles to es5 `instanceof` does not work
// on objects that derive from Error/Array types. To workaround we call setPrototypeOf after calling super()
// more on this at: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
/**
 * @class AccessTokenInvalidError
 * @classdesc Raised whenever the AccessToken used for connecting to a Room is invalid.
 * @extends TwilioError
 * @property {number} code - 20101
 * @property {string} message - 'Invalid Access Token'
 */
var AccessTokenInvalidError = /** @class */ (function (_super) {
    __extends(AccessTokenInvalidError, _super);
    function AccessTokenInvalidError() {
        var _this = _super.call(this, 20101, 'Invalid Access Token') || this;
        Object.setPrototypeOf(_this, AccessTokenInvalidError.prototype);
        return _this;
    }
    return AccessTokenInvalidError;
}(TwilioError));
exports.AccessTokenInvalidError = AccessTokenInvalidError;
Object.defineProperty(TwilioErrorByCode, 20101, { value: AccessTokenInvalidError });
/**
 * @class AccessTokenHeaderInvalidError
 * @classdesc Raised whenever the AccessToken used for connecting to a Room has an invalid header.
 * @extends TwilioError
 * @property {number} code - 20102
 * @property {string} message - 'Invalid Access Token header'
 */
var AccessTokenHeaderInvalidError = /** @class */ (function (_super) {
    __extends(AccessTokenHeaderInvalidError, _super);
    function AccessTokenHeaderInvalidError() {
        var _this = _super.call(this, 20102, 'Invalid Access Token header') || this;
        Object.setPrototypeOf(_this, AccessTokenHeaderInvalidError.prototype);
        return _this;
    }
    return AccessTokenHeaderInvalidError;
}(TwilioError));
exports.AccessTokenHeaderInvalidError = AccessTokenHeaderInvalidError;
Object.defineProperty(TwilioErrorByCode, 20102, { value: AccessTokenHeaderInvalidError });
/**
 * @class AccessTokenIssuerInvalidError
 * @classdesc Raised whenever the AccessToken used for connecting to a Room contains an invalid issuer or subject.
 * @extends TwilioError
 * @property {number} code - 20103
 * @property {string} message - 'Invalid Access Token issuer/subject'
 */
var AccessTokenIssuerInvalidError = /** @class */ (function (_super) {
    __extends(AccessTokenIssuerInvalidError, _super);
    function AccessTokenIssuerInvalidError() {
        var _this = _super.call(this, 20103, 'Invalid Access Token issuer/subject') || this;
        Object.setPrototypeOf(_this, AccessTokenIssuerInvalidError.prototype);
        return _this;
    }
    return AccessTokenIssuerInvalidError;
}(TwilioError));
exports.AccessTokenIssuerInvalidError = AccessTokenIssuerInvalidError;
Object.defineProperty(TwilioErrorByCode, 20103, { value: AccessTokenIssuerInvalidError });
/**
 * @class AccessTokenExpiredError
 * @classdesc Raised whenever the AccessToken used for connecting, or reconnecting to a Room has expired.
 * @extends TwilioError
 * @property {number} code - 20104
 * @property {string} message - 'Access Token expired or expiration date invalid'
 */
var AccessTokenExpiredError = /** @class */ (function (_super) {
    __extends(AccessTokenExpiredError, _super);
    function AccessTokenExpiredError() {
        var _this = _super.call(this, 20104, 'Access Token expired or expiration date invalid') || this;
        Object.setPrototypeOf(_this, AccessTokenExpiredError.prototype);
        return _this;
    }
    return AccessTokenExpiredError;
}(TwilioError));
exports.AccessTokenExpiredError = AccessTokenExpiredError;
Object.defineProperty(TwilioErrorByCode, 20104, { value: AccessTokenExpiredError });
/**
 * @class AccessTokenNotYetValidError
 * @classdesc Raised whenever the AccessToken used for connecting to a Room is not yet valid.
 * @extends TwilioError
 * @property {number} code - 20105
 * @property {string} message - 'Access Token not yet valid'
 */
var AccessTokenNotYetValidError = /** @class */ (function (_super) {
    __extends(AccessTokenNotYetValidError, _super);
    function AccessTokenNotYetValidError() {
        var _this = _super.call(this, 20105, 'Access Token not yet valid') || this;
        Object.setPrototypeOf(_this, AccessTokenNotYetValidError.prototype);
        return _this;
    }
    return AccessTokenNotYetValidError;
}(TwilioError));
exports.AccessTokenNotYetValidError = AccessTokenNotYetValidError;
Object.defineProperty(TwilioErrorByCode, 20105, { value: AccessTokenNotYetValidError });
/**
 * @class AccessTokenGrantsInvalidError
 * @classdesc Raised whenever the AccessToken used for connecting to a Room has invalid grants.
 * @extends TwilioError
 * @property {number} code - 20106
 * @property {string} message - 'Invalid Access Token grants'
 */
var AccessTokenGrantsInvalidError = /** @class */ (function (_super) {
    __extends(AccessTokenGrantsInvalidError, _super);
    function AccessTokenGrantsInvalidError() {
        var _this = _super.call(this, 20106, 'Invalid Access Token grants') || this;
        Object.setPrototypeOf(_this, AccessTokenGrantsInvalidError.prototype);
        return _this;
    }
    return AccessTokenGrantsInvalidError;
}(TwilioError));
exports.AccessTokenGrantsInvalidError = AccessTokenGrantsInvalidError;
Object.defineProperty(TwilioErrorByCode, 20106, { value: AccessTokenGrantsInvalidError });
/**
 * @class AccessTokenSignatureInvalidError
 * @classdesc Raised whenever the AccessToken used for connecting to a Room has an invalid signature.
 * @extends TwilioError
 * @property {number} code - 20107
 * @property {string} message - 'Invalid Access Token signature'
 */
var AccessTokenSignatureInvalidError = /** @class */ (function (_super) {
    __extends(AccessTokenSignatureInvalidError, _super);
    function AccessTokenSignatureInvalidError() {
        var _this = _super.call(this, 20107, 'Invalid Access Token signature') || this;
        Object.setPrototypeOf(_this, AccessTokenSignatureInvalidError.prototype);
        return _this;
    }
    return AccessTokenSignatureInvalidError;
}(TwilioError));
exports.AccessTokenSignatureInvalidError = AccessTokenSignatureInvalidError;
Object.defineProperty(TwilioErrorByCode, 20107, { value: AccessTokenSignatureInvalidError });
/**
 * @class SignalingConnectionError
 * @classdesc Raised whenever a signaling connection error occurs that is not covered by a more specific error code.
 * @extends TwilioError
 * @property {number} code - 53000
 * @property {string} message - 'Signaling connection error'
 */
var SignalingConnectionError = /** @class */ (function (_super) {
    __extends(SignalingConnectionError, _super);
    function SignalingConnectionError() {
        var _this = _super.call(this, 53000, 'Signaling connection error') || this;
        Object.setPrototypeOf(_this, SignalingConnectionError.prototype);
        return _this;
    }
    return SignalingConnectionError;
}(TwilioError));
exports.SignalingConnectionError = SignalingConnectionError;
Object.defineProperty(TwilioErrorByCode, 53000, { value: SignalingConnectionError });
/**
 * @class SignalingConnectionDisconnectedError
 * @classdesc Raised whenever the signaling connection is unexpectedly disconnected.
 * @extends TwilioError
 * @property {number} code - 53001
 * @property {string} message - 'Signaling connection disconnected'
 */
var SignalingConnectionDisconnectedError = /** @class */ (function (_super) {
    __extends(SignalingConnectionDisconnectedError, _super);
    function SignalingConnectionDisconnectedError() {
        var _this = _super.call(this, 53001, 'Signaling connection disconnected') || this;
        Object.setPrototypeOf(_this, SignalingConnectionDisconnectedError.prototype);
        return _this;
    }
    return SignalingConnectionDisconnectedError;
}(TwilioError));
exports.SignalingConnectionDisconnectedError = SignalingConnectionDisconnectedError;
Object.defineProperty(TwilioErrorByCode, 53001, { value: SignalingConnectionDisconnectedError });
/**
 * @class SignalingConnectionTimeoutError
 * @classdesc Raised when connection liveliness checks fail, or when the signaling session expires.
 * @extends TwilioError
 * @property {number} code - 53002
 * @property {string} message - 'Signaling connection timed out'
 */
var SignalingConnectionTimeoutError = /** @class */ (function (_super) {
    __extends(SignalingConnectionTimeoutError, _super);
    function SignalingConnectionTimeoutError() {
        var _this = _super.call(this, 53002, 'Signaling connection timed out') || this;
        Object.setPrototypeOf(_this, SignalingConnectionTimeoutError.prototype);
        return _this;
    }
    return SignalingConnectionTimeoutError;
}(TwilioError));
exports.SignalingConnectionTimeoutError = SignalingConnectionTimeoutError;
Object.defineProperty(TwilioErrorByCode, 53002, { value: SignalingConnectionTimeoutError });
/**
 * @class SignalingIncomingMessageInvalidError
 * @classdesc Raised whenever the Client receives a message from the Server that the Client cannot handle.
 * @extends TwilioError
 * @property {number} code - 53003
 * @property {string} message - 'Client received an invalid signaling message'
 */
var SignalingIncomingMessageInvalidError = /** @class */ (function (_super) {
    __extends(SignalingIncomingMessageInvalidError, _super);
    function SignalingIncomingMessageInvalidError() {
        var _this = _super.call(this, 53003, 'Client received an invalid signaling message') || this;
        Object.setPrototypeOf(_this, SignalingIncomingMessageInvalidError.prototype);
        return _this;
    }
    return SignalingIncomingMessageInvalidError;
}(TwilioError));
exports.SignalingIncomingMessageInvalidError = SignalingIncomingMessageInvalidError;
Object.defineProperty(TwilioErrorByCode, 53003, { value: SignalingIncomingMessageInvalidError });
/**
 * @class SignalingOutgoingMessageInvalidError
 * @classdesc Raised whenever the Client sends a message to the Server that the Server cannot handle.
 * @extends TwilioError
 * @property {number} code - 53004
 * @property {string} message - 'Client sent an invalid signaling message'
 */
var SignalingOutgoingMessageInvalidError = /** @class */ (function (_super) {
    __extends(SignalingOutgoingMessageInvalidError, _super);
    function SignalingOutgoingMessageInvalidError() {
        var _this = _super.call(this, 53004, 'Client sent an invalid signaling message') || this;
        Object.setPrototypeOf(_this, SignalingOutgoingMessageInvalidError.prototype);
        return _this;
    }
    return SignalingOutgoingMessageInvalidError;
}(TwilioError));
exports.SignalingOutgoingMessageInvalidError = SignalingOutgoingMessageInvalidError;
Object.defineProperty(TwilioErrorByCode, 53004, { value: SignalingOutgoingMessageInvalidError });
/**
 * @class SignalingServerBusyError
 * @classdesc Raised when the server is too busy to accept new clients.
 * @extends TwilioError
 * @property {number} code - 53006
 * @property {string} message - 'Video server is busy'
 */
var SignalingServerBusyError = /** @class */ (function (_super) {
    __extends(SignalingServerBusyError, _super);
    function SignalingServerBusyError() {
        var _this = _super.call(this, 53006, 'Video server is busy') || this;
        Object.setPrototypeOf(_this, SignalingServerBusyError.prototype);
        return _this;
    }
    return SignalingServerBusyError;
}(TwilioError));
exports.SignalingServerBusyError = SignalingServerBusyError;
Object.defineProperty(TwilioErrorByCode, 53006, { value: SignalingServerBusyError });
/**
 * @class RoomNameInvalidError
 * @classdesc Raised whenever a Room name is invalid, and the scenario is not covered by a more specific error code.
 * @extends TwilioError
 * @property {number} code - 53100
 * @property {string} message - 'Room name is invalid'
 */
var RoomNameInvalidError = /** @class */ (function (_super) {
    __extends(RoomNameInvalidError, _super);
    function RoomNameInvalidError() {
        var _this = _super.call(this, 53100, 'Room name is invalid') || this;
        Object.setPrototypeOf(_this, RoomNameInvalidError.prototype);
        return _this;
    }
    return RoomNameInvalidError;
}(TwilioError));
exports.RoomNameInvalidError = RoomNameInvalidError;
Object.defineProperty(TwilioErrorByCode, 53100, { value: RoomNameInvalidError });
/**
 * @class RoomNameTooLongError
 * @classdesc Raised whenever a Room name is too long.
 * @extends TwilioError
 * @property {number} code - 53101
 * @property {string} message - 'Room name is too long'
 */
var RoomNameTooLongError = /** @class */ (function (_super) {
    __extends(RoomNameTooLongError, _super);
    function RoomNameTooLongError() {
        var _this = _super.call(this, 53101, 'Room name is too long') || this;
        Object.setPrototypeOf(_this, RoomNameTooLongError.prototype);
        return _this;
    }
    return RoomNameTooLongError;
}(TwilioError));
exports.RoomNameTooLongError = RoomNameTooLongError;
Object.defineProperty(TwilioErrorByCode, 53101, { value: RoomNameTooLongError });
/**
 * @class RoomNameCharsInvalidError
 * @classdesc Raised whenever a Room name contains invalid characters.
 * @extends TwilioError
 * @property {number} code - 53102
 * @property {string} message - 'Room name contains invalid characters'
 */
var RoomNameCharsInvalidError = /** @class */ (function (_super) {
    __extends(RoomNameCharsInvalidError, _super);
    function RoomNameCharsInvalidError() {
        var _this = _super.call(this, 53102, 'Room name contains invalid characters') || this;
        Object.setPrototypeOf(_this, RoomNameCharsInvalidError.prototype);
        return _this;
    }
    return RoomNameCharsInvalidError;
}(TwilioError));
exports.RoomNameCharsInvalidError = RoomNameCharsInvalidError;
Object.defineProperty(TwilioErrorByCode, 53102, { value: RoomNameCharsInvalidError });
/**
 * @class RoomCreateFailedError
 * @classdesc Raised whenever the Server is unable to create a Room.
 * @extends TwilioError
 * @property {number} code - 53103
 * @property {string} message - 'Unable to create Room'
 */
var RoomCreateFailedError = /** @class */ (function (_super) {
    __extends(RoomCreateFailedError, _super);
    function RoomCreateFailedError() {
        var _this = _super.call(this, 53103, 'Unable to create Room') || this;
        Object.setPrototypeOf(_this, RoomCreateFailedError.prototype);
        return _this;
    }
    return RoomCreateFailedError;
}(TwilioError));
exports.RoomCreateFailedError = RoomCreateFailedError;
Object.defineProperty(TwilioErrorByCode, 53103, { value: RoomCreateFailedError });
/**
 * @class RoomConnectFailedError
 * @classdesc Raised whenever a Client is unable to connect to a Room, and the scenario is not covered by a more specific error code.
 * @extends TwilioError
 * @property {number} code - 53104
 * @property {string} message - 'Unable to connect to Room'
 */
var RoomConnectFailedError = /** @class */ (function (_super) {
    __extends(RoomConnectFailedError, _super);
    function RoomConnectFailedError() {
        var _this = _super.call(this, 53104, 'Unable to connect to Room') || this;
        Object.setPrototypeOf(_this, RoomConnectFailedError.prototype);
        return _this;
    }
    return RoomConnectFailedError;
}(TwilioError));
exports.RoomConnectFailedError = RoomConnectFailedError;
Object.defineProperty(TwilioErrorByCode, 53104, { value: RoomConnectFailedError });
/**
 * @class RoomMaxParticipantsExceededError
 * @classdesc Raised whenever a Client is unable to connect to a Room because the Room contains too many Participants.
 * @extends TwilioError
 * @property {number} code - 53105
 * @property {string} message - 'Room contains too many Participants'
 */
var RoomMaxParticipantsExceededError = /** @class */ (function (_super) {
    __extends(RoomMaxParticipantsExceededError, _super);
    function RoomMaxParticipantsExceededError() {
        var _this = _super.call(this, 53105, 'Room contains too many Participants') || this;
        Object.setPrototypeOf(_this, RoomMaxParticipantsExceededError.prototype);
        return _this;
    }
    return RoomMaxParticipantsExceededError;
}(TwilioError));
exports.RoomMaxParticipantsExceededError = RoomMaxParticipantsExceededError;
Object.defineProperty(TwilioErrorByCode, 53105, { value: RoomMaxParticipantsExceededError });
/**
 * @class RoomNotFoundError
 * @classdesc Raised whenever attempting operation on a non-existent Room.
 * @extends TwilioError
 * @property {number} code - 53106
 * @property {string} message - 'Room not found'
 */
var RoomNotFoundError = /** @class */ (function (_super) {
    __extends(RoomNotFoundError, _super);
    function RoomNotFoundError() {
        var _this = _super.call(this, 53106, 'Room not found') || this;
        Object.setPrototypeOf(_this, RoomNotFoundError.prototype);
        return _this;
    }
    return RoomNotFoundError;
}(TwilioError));
exports.RoomNotFoundError = RoomNotFoundError;
Object.defineProperty(TwilioErrorByCode, 53106, { value: RoomNotFoundError });
/**
 * @class RoomMaxParticipantsOutOfRangeError
 * @classdesc Raised in the REST API when MaxParticipants is set out of range.
 * @extends TwilioError
 * @property {number} code - 53107
 * @property {string} message - 'MaxParticipants is out of range'
 */
var RoomMaxParticipantsOutOfRangeError = /** @class */ (function (_super) {
    __extends(RoomMaxParticipantsOutOfRangeError, _super);
    function RoomMaxParticipantsOutOfRangeError() {
        var _this = _super.call(this, 53107, 'MaxParticipants is out of range') || this;
        Object.setPrototypeOf(_this, RoomMaxParticipantsOutOfRangeError.prototype);
        return _this;
    }
    return RoomMaxParticipantsOutOfRangeError;
}(TwilioError));
exports.RoomMaxParticipantsOutOfRangeError = RoomMaxParticipantsOutOfRangeError;
Object.defineProperty(TwilioErrorByCode, 53107, { value: RoomMaxParticipantsOutOfRangeError });
/**
 * @class RoomTypeInvalidError
 * @classdesc Raised in the REST API when the user attempts to create a Room with an invalid RoomType
 * @extends TwilioError
 * @property {number} code - 53108
 * @property {string} message - 'RoomType is not valid'
 */
var RoomTypeInvalidError = /** @class */ (function (_super) {
    __extends(RoomTypeInvalidError, _super);
    function RoomTypeInvalidError() {
        var _this = _super.call(this, 53108, 'RoomType is not valid') || this;
        Object.setPrototypeOf(_this, RoomMaxParticipantsOutOfRangeError.prototype);
        return _this;
    }
    return RoomTypeInvalidError;
}(TwilioError));
exports.RoomTypeInvalidError = RoomTypeInvalidError;
Object.defineProperty(TwilioErrorByCode, 53108, { value: RoomTypeInvalidError });
/**
 * @class RoomTimeoutOutOfRangeError
 * @classdesc Raised in the REST API when Timeout is set out of range.
 * @extends TwilioError
 * @property {number} code - 53109
 * @property {string} message - 'Timeout is out of range'
 */
var RoomTimeoutOutOfRangeError = /** @class */ (function (_super) {
    __extends(RoomTimeoutOutOfRangeError, _super);
    function RoomTimeoutOutOfRangeError() {
        var _this = _super.call(this, 53109, 'Timeout is out of range') || this;
        Object.setPrototypeOf(_this, RoomTimeoutOutOfRangeError.prototype);
        return _this;
    }
    return RoomTimeoutOutOfRangeError;
}(TwilioError));
exports.RoomTimeoutOutOfRangeError = RoomTimeoutOutOfRangeError;
Object.defineProperty(TwilioErrorByCode, 53109, { value: RoomTimeoutOutOfRangeError });
/**
 * @class RoomStatusCallbackMethodInvalidError
 * @classdesc Raised in the REST API when StatusCallbackMethod is set to an invalid value.
 * @extends TwilioError
 * @property {number} code - 53110
 * @property {string} message - 'StatusCallbackMethod is invalid'
 */
var RoomStatusCallbackMethodInvalidError = /** @class */ (function (_super) {
    __extends(RoomStatusCallbackMethodInvalidError, _super);
    function RoomStatusCallbackMethodInvalidError() {
        var _this = _super.call(this, 53110, 'StatusCallbackMethod is invalid') || this;
        Object.setPrototypeOf(_this, RoomStatusCallbackMethodInvalidError.prototype);
        return _this;
    }
    return RoomStatusCallbackMethodInvalidError;
}(TwilioError));
exports.RoomStatusCallbackMethodInvalidError = RoomStatusCallbackMethodInvalidError;
Object.defineProperty(TwilioErrorByCode, 53110, { value: RoomStatusCallbackMethodInvalidError });
/**
 * @class RoomStatusCallbackInvalidError
 * @classdesc Raised in the REST API when StatusCallback is not a valid URL or the url is too long.
 * @extends TwilioError
 * @property {number} code - 53111
 * @property {string} message - 'StatusCallback is invalid'
 */
var RoomStatusCallbackInvalidError = /** @class */ (function (_super) {
    __extends(RoomStatusCallbackInvalidError, _super);
    function RoomStatusCallbackInvalidError() {
        var _this = _super.call(this, 53111, 'StatusCallback is invalid') || this;
        Object.setPrototypeOf(_this, RoomStatusCallbackInvalidError.prototype);
        return _this;
    }
    return RoomStatusCallbackInvalidError;
}(TwilioError));
exports.RoomStatusCallbackInvalidError = RoomStatusCallbackInvalidError;
Object.defineProperty(TwilioErrorByCode, 53111, { value: RoomStatusCallbackInvalidError });
/**
 * @class RoomStatusInvalidError
 * @classdesc Raised in the REST API when Status is not valid or the Room is not in-progress.
 * @extends TwilioError
 * @property {number} code - 53112
 * @property {string} message - 'Status is invalid'
 */
var RoomStatusInvalidError = /** @class */ (function (_super) {
    __extends(RoomStatusInvalidError, _super);
    function RoomStatusInvalidError() {
        var _this = _super.call(this, 53112, 'Status is invalid') || this;
        Object.setPrototypeOf(_this, RoomStatusInvalidError.prototype);
        return _this;
    }
    return RoomStatusInvalidError;
}(TwilioError));
exports.RoomStatusInvalidError = RoomStatusInvalidError;
Object.defineProperty(TwilioErrorByCode, 53112, { value: RoomStatusInvalidError });
/**
 * @class RoomRoomExistsError
 * @classdesc Raised in the REST API when the Room creation fails because a Room exists with the same name.
 * @extends TwilioError
 * @property {number} code - 53113
 * @property {string} message - 'Room exists'
 */
var RoomRoomExistsError = /** @class */ (function (_super) {
    __extends(RoomRoomExistsError, _super);
    function RoomRoomExistsError() {
        var _this = _super.call(this, 53113, 'Room exists') || this;
        Object.setPrototypeOf(_this, RoomRoomExistsError.prototype);
        return _this;
    }
    return RoomRoomExistsError;
}(TwilioError));
exports.RoomRoomExistsError = RoomRoomExistsError;
Object.defineProperty(TwilioErrorByCode, 53113, { value: RoomRoomExistsError });
/**
 * @class RoomInvalidParametersError
 * @classdesc Raised in the REST API when one or more Room creation parameter is incompatible with the Room type.
 * @extends TwilioError
 * @property {number} code - 53114
 * @property {string} message - 'Room creation parameter(s) incompatible with the Room type'
 */
var RoomInvalidParametersError = /** @class */ (function (_super) {
    __extends(RoomInvalidParametersError, _super);
    function RoomInvalidParametersError() {
        var _this = _super.call(this, 53114, 'Room creation parameter(s) incompatible with the Room type') || this;
        Object.setPrototypeOf(_this, RoomInvalidParametersError.prototype);
        return _this;
    }
    return RoomInvalidParametersError;
}(TwilioError));
exports.RoomInvalidParametersError = RoomInvalidParametersError;
Object.defineProperty(TwilioErrorByCode, 53114, { value: RoomInvalidParametersError });
/**
 * @class RoomMediaRegionInvalidError
 * @classdesc Raised in the REST API when MediaRegion is set to an invalid value.
 * @extends TwilioError
 * @property {number} code - 53115
 * @property {string} message - 'MediaRegion is invalid'
 */
var RoomMediaRegionInvalidError = /** @class */ (function (_super) {
    __extends(RoomMediaRegionInvalidError, _super);
    function RoomMediaRegionInvalidError() {
        var _this = _super.call(this, 53115, 'MediaRegion is invalid') || this;
        Object.setPrototypeOf(_this, RoomMediaRegionInvalidError.prototype);
        return _this;
    }
    return RoomMediaRegionInvalidError;
}(TwilioError));
exports.RoomMediaRegionInvalidError = RoomMediaRegionInvalidError;
Object.defineProperty(TwilioErrorByCode, 53115, { value: RoomMediaRegionInvalidError });
/**
 * @class RoomMediaRegionUnavailableError
 * @classdesc Raised in the REST API when MediaRegion is set to a valid value but no media servers are available.
 * @extends TwilioError
 * @property {number} code - 53116
 * @property {string} message - 'There are no media servers available in the MediaRegion'
 */
var RoomMediaRegionUnavailableError = /** @class */ (function (_super) {
    __extends(RoomMediaRegionUnavailableError, _super);
    function RoomMediaRegionUnavailableError() {
        var _this = _super.call(this, 53116, 'There are no media servers available in the MediaRegion') || this;
        Object.setPrototypeOf(_this, RoomMediaRegionUnavailableError.prototype);
        return _this;
    }
    return RoomMediaRegionUnavailableError;
}(TwilioError));
exports.RoomMediaRegionUnavailableError = RoomMediaRegionUnavailableError;
Object.defineProperty(TwilioErrorByCode, 53116, { value: RoomMediaRegionUnavailableError });
/**
 * @class RoomSubscriptionOperationNotSupportedError
 * @classdesc Raised whenever the subscription operation requested is not supported for the Room type.
 * @extends TwilioError
 * @property {number} code - 53117
 * @property {string} message - 'The subscription operation requested is not supported for the Room type'
 */
var RoomSubscriptionOperationNotSupportedError = /** @class */ (function (_super) {
    __extends(RoomSubscriptionOperationNotSupportedError, _super);
    function RoomSubscriptionOperationNotSupportedError() {
        var _this = _super.call(this, 53117, 'The subscription operation requested is not supported for the Room type') || this;
        Object.setPrototypeOf(_this, RoomSubscriptionOperationNotSupportedError.prototype);
        return _this;
    }
    return RoomSubscriptionOperationNotSupportedError;
}(TwilioError));
exports.RoomSubscriptionOperationNotSupportedError = RoomSubscriptionOperationNotSupportedError;
Object.defineProperty(TwilioErrorByCode, 53117, { value: RoomSubscriptionOperationNotSupportedError });
/**
 * @class RoomCompletedError
 * @classdesc Raised whenever a Room is completed via the REST API.
 * @extends TwilioError
 * @property {number} code - 53118
 * @property {string} message - 'Room completed'
 */
var RoomCompletedError = /** @class */ (function (_super) {
    __extends(RoomCompletedError, _super);
    function RoomCompletedError() {
        var _this = _super.call(this, 53118, 'Room completed') || this;
        Object.setPrototypeOf(_this, RoomCompletedError.prototype);
        return _this;
    }
    return RoomCompletedError;
}(TwilioError));
exports.RoomCompletedError = RoomCompletedError;
Object.defineProperty(TwilioErrorByCode, 53118, { value: RoomCompletedError });
/**
 * @class ParticipantIdentityInvalidError
 * @classdesc Raised whenever a Participant identity is invalid, and the scenario is not covered by a more specific error code.
 * @extends TwilioError
 * @property {number} code - 53200
 * @property {string} message - 'Participant identity is invalid'
 */
var ParticipantIdentityInvalidError = /** @class */ (function (_super) {
    __extends(ParticipantIdentityInvalidError, _super);
    function ParticipantIdentityInvalidError() {
        var _this = _super.call(this, 53200, 'Participant identity is invalid') || this;
        Object.setPrototypeOf(_this, ParticipantIdentityInvalidError.prototype);
        return _this;
    }
    return ParticipantIdentityInvalidError;
}(TwilioError));
exports.ParticipantIdentityInvalidError = ParticipantIdentityInvalidError;
Object.defineProperty(TwilioErrorByCode, 53200, { value: ParticipantIdentityInvalidError });
/**
 * @class ParticipantIdentityTooLongError
 * @classdesc Raised whenever a Participant identity is too long.
 * @extends TwilioError
 * @property {number} code - 53201
 * @property {string} message - 'Participant identity is too long'
 */
var ParticipantIdentityTooLongError = /** @class */ (function (_super) {
    __extends(ParticipantIdentityTooLongError, _super);
    function ParticipantIdentityTooLongError() {
        var _this = _super.call(this, 53201, 'Participant identity is too long') || this;
        Object.setPrototypeOf(_this, ParticipantIdentityTooLongError.prototype);
        return _this;
    }
    return ParticipantIdentityTooLongError;
}(TwilioError));
exports.ParticipantIdentityTooLongError = ParticipantIdentityTooLongError;
Object.defineProperty(TwilioErrorByCode, 53201, { value: ParticipantIdentityTooLongError });
/**
 * @class ParticipantIdentityCharsInvalidError
 * @classdesc Raised whenever a Participant identity contains invalid characters.
 * @extends TwilioError
 * @property {number} code - 53202
 * @property {string} message - 'Participant identity contains invalid characters'
 */
var ParticipantIdentityCharsInvalidError = /** @class */ (function (_super) {
    __extends(ParticipantIdentityCharsInvalidError, _super);
    function ParticipantIdentityCharsInvalidError() {
        var _this = _super.call(this, 53202, 'Participant identity contains invalid characters') || this;
        Object.setPrototypeOf(_this, ParticipantIdentityCharsInvalidError.prototype);
        return _this;
    }
    return ParticipantIdentityCharsInvalidError;
}(TwilioError));
exports.ParticipantIdentityCharsInvalidError = ParticipantIdentityCharsInvalidError;
Object.defineProperty(TwilioErrorByCode, 53202, { value: ParticipantIdentityCharsInvalidError });
/**
 * @class ParticipantMaxTracksExceededError
 * @classdesc Raised when the Room limit for published tracks has been reached and a Participant tries to publish a track to the Room.
 * @extends TwilioError
 * @property {number} code - 53203
 * @property {string} message - 'The maximum number of published tracks allowed in the Room at the same time has been reached'
 */
var ParticipantMaxTracksExceededError = /** @class */ (function (_super) {
    __extends(ParticipantMaxTracksExceededError, _super);
    function ParticipantMaxTracksExceededError() {
        var _this = _super.call(this, 53203, 'The maximum number of published tracks allowed in the Room at the same time has been reached') || this;
        Object.setPrototypeOf(_this, ParticipantMaxTracksExceededError.prototype);
        return _this;
    }
    return ParticipantMaxTracksExceededError;
}(TwilioError));
exports.ParticipantMaxTracksExceededError = ParticipantMaxTracksExceededError;
Object.defineProperty(TwilioErrorByCode, 53203, { value: ParticipantMaxTracksExceededError });
/**
 * @class ParticipantNotFoundError
 * @classdesc Raised whenever attempting an operation on a non-existent Participant.
 * @extends TwilioError
 * @property {number} code - 53204
 * @property {string} message - 'Participant not found'
 */
var ParticipantNotFoundError = /** @class */ (function (_super) {
    __extends(ParticipantNotFoundError, _super);
    function ParticipantNotFoundError() {
        var _this = _super.call(this, 53204, 'Participant not found') || this;
        Object.setPrototypeOf(_this, ParticipantNotFoundError.prototype);
        return _this;
    }
    return ParticipantNotFoundError;
}(TwilioError));
exports.ParticipantNotFoundError = ParticipantNotFoundError;
Object.defineProperty(TwilioErrorByCode, 53204, { value: ParticipantNotFoundError });
/**
 * @class ParticipantDuplicateIdentityError
 * @classdesc Raised by the server to the existing Participant when a new Participant joins a Room with the same identity as the existing Participant.
 * @extends TwilioError
 * @property {number} code - 53205
 * @property {string} message - 'Participant disconnected because of duplicate identity'
 */
var ParticipantDuplicateIdentityError = /** @class */ (function (_super) {
    __extends(ParticipantDuplicateIdentityError, _super);
    function ParticipantDuplicateIdentityError() {
        var _this = _super.call(this, 53205, 'Participant disconnected because of duplicate identity') || this;
        Object.setPrototypeOf(_this, ParticipantDuplicateIdentityError.prototype);
        return _this;
    }
    return ParticipantDuplicateIdentityError;
}(TwilioError));
exports.ParticipantDuplicateIdentityError = ParticipantDuplicateIdentityError;
Object.defineProperty(TwilioErrorByCode, 53205, { value: ParticipantDuplicateIdentityError });
/**
 * @class TrackInvalidError
 * @classdesc Raised whenever a Track is invalid, and the scenario is not covered by a more specific error code.
 * @extends TwilioError
 * @property {number} code - 53300
 * @property {string} message - 'Track is invalid'
 */
var TrackInvalidError = /** @class */ (function (_super) {
    __extends(TrackInvalidError, _super);
    function TrackInvalidError() {
        var _this = _super.call(this, 53300, 'Track is invalid') || this;
        Object.setPrototypeOf(_this, TrackInvalidError.prototype);
        return _this;
    }
    return TrackInvalidError;
}(TwilioError));
exports.TrackInvalidError = TrackInvalidError;
Object.defineProperty(TwilioErrorByCode, 53300, { value: TrackInvalidError });
/**
 * @class TrackNameInvalidError
 * @classdesc Raised whenever a Track name is invalid, and the scenario is not covered by a more specific error code.
 * @extends TwilioError
 * @property {number} code - 53301
 * @property {string} message - 'Track name is invalid'
 */
var TrackNameInvalidError = /** @class */ (function (_super) {
    __extends(TrackNameInvalidError, _super);
    function TrackNameInvalidError() {
        var _this = _super.call(this, 53301, 'Track name is invalid') || this;
        Object.setPrototypeOf(_this, TrackNameInvalidError.prototype);
        return _this;
    }
    return TrackNameInvalidError;
}(TwilioError));
exports.TrackNameInvalidError = TrackNameInvalidError;
Object.defineProperty(TwilioErrorByCode, 53301, { value: TrackNameInvalidError });
/**
 * @class TrackNameTooLongError
 * @classdesc Raised whenever a Track name is too long.
 * @extends TwilioError
 * @property {number} code - 53302
 * @property {string} message - 'Track name is too long'
 */
var TrackNameTooLongError = /** @class */ (function (_super) {
    __extends(TrackNameTooLongError, _super);
    function TrackNameTooLongError() {
        var _this = _super.call(this, 53302, 'Track name is too long') || this;
        Object.setPrototypeOf(_this, TrackNameTooLongError.prototype);
        return _this;
    }
    return TrackNameTooLongError;
}(TwilioError));
exports.TrackNameTooLongError = TrackNameTooLongError;
Object.defineProperty(TwilioErrorByCode, 53302, { value: TrackNameTooLongError });
/**
 * @class TrackNameCharsInvalidError
 * @classdesc Raised whenever a Track name contains invalid characters.
 * @extends TwilioError
 * @property {number} code - 53303
 * @property {string} message - 'Track name contains invalid characters'
 */
var TrackNameCharsInvalidError = /** @class */ (function (_super) {
    __extends(TrackNameCharsInvalidError, _super);
    function TrackNameCharsInvalidError() {
        var _this = _super.call(this, 53303, 'Track name contains invalid characters') || this;
        Object.setPrototypeOf(_this, TrackNameCharsInvalidError.prototype);
        return _this;
    }
    return TrackNameCharsInvalidError;
}(TwilioError));
exports.TrackNameCharsInvalidError = TrackNameCharsInvalidError;
Object.defineProperty(TwilioErrorByCode, 53303, { value: TrackNameCharsInvalidError });
/**
 * @class TrackNameIsDuplicatedError
 * @classdesc Raised whenever a Participant is currently publishing a Track with the same name.
 * @extends TwilioError
 * @property {number} code - 53304
 * @property {string} message - 'Track name is duplicated'
 */
var TrackNameIsDuplicatedError = /** @class */ (function (_super) {
    __extends(TrackNameIsDuplicatedError, _super);
    function TrackNameIsDuplicatedError() {
        var _this = _super.call(this, 53304, 'Track name is duplicated') || this;
        Object.setPrototypeOf(_this, TrackNameIsDuplicatedError.prototype);
        return _this;
    }
    return TrackNameIsDuplicatedError;
}(TwilioError));
exports.TrackNameIsDuplicatedError = TrackNameIsDuplicatedError;
Object.defineProperty(TwilioErrorByCode, 53304, { value: TrackNameIsDuplicatedError });
/**
 * @class TrackServerTrackCapacityReachedError
 * @classdesc The server does not have enough resources available to create a new Track.
 * @extends TwilioError
 * @property {number} code - 53305
 * @property {string} message - 'The server has reached capacity and cannot fulfill this request'
 */
var TrackServerTrackCapacityReachedError = /** @class */ (function (_super) {
    __extends(TrackServerTrackCapacityReachedError, _super);
    function TrackServerTrackCapacityReachedError() {
        var _this = _super.call(this, 53305, 'The server has reached capacity and cannot fulfill this request') || this;
        Object.setPrototypeOf(_this, TrackServerTrackCapacityReachedError.prototype);
        return _this;
    }
    return TrackServerTrackCapacityReachedError;
}(TwilioError));
exports.TrackServerTrackCapacityReachedError = TrackServerTrackCapacityReachedError;
Object.defineProperty(TwilioErrorByCode, 53305, { value: TrackServerTrackCapacityReachedError });
/**
 * @class MediaClientLocalDescFailedError
 * @classdesc Raised whenever a Client is unable to create or apply a local media description.
 * @extends TwilioError
 * @property {number} code - 53400
 * @property {string} message - 'Client is unable to create or apply a local media description'
 */
var MediaClientLocalDescFailedError = /** @class */ (function (_super) {
    __extends(MediaClientLocalDescFailedError, _super);
    function MediaClientLocalDescFailedError() {
        var _this = _super.call(this, 53400, 'Client is unable to create or apply a local media description') || this;
        Object.setPrototypeOf(_this, MediaClientLocalDescFailedError.prototype);
        return _this;
    }
    return MediaClientLocalDescFailedError;
}(TwilioError));
exports.MediaClientLocalDescFailedError = MediaClientLocalDescFailedError;
Object.defineProperty(TwilioErrorByCode, 53400, { value: MediaClientLocalDescFailedError });
/**
 * @class MediaServerLocalDescFailedError
 * @classdesc Raised whenever the Server is unable to create or apply a local media description.
 * @extends TwilioError
 * @property {number} code - 53401
 * @property {string} message - 'Server is unable to create or apply a local media description'
 */
var MediaServerLocalDescFailedError = /** @class */ (function (_super) {
    __extends(MediaServerLocalDescFailedError, _super);
    function MediaServerLocalDescFailedError() {
        var _this = _super.call(this, 53401, 'Server is unable to create or apply a local media description') || this;
        Object.setPrototypeOf(_this, MediaServerLocalDescFailedError.prototype);
        return _this;
    }
    return MediaServerLocalDescFailedError;
}(TwilioError));
exports.MediaServerLocalDescFailedError = MediaServerLocalDescFailedError;
Object.defineProperty(TwilioErrorByCode, 53401, { value: MediaServerLocalDescFailedError });
/**
 * @class MediaClientRemoteDescFailedError
 * @classdesc Raised whenever the Client receives a remote media description but is unable to apply it.
 * @extends TwilioError
 * @property {number} code - 53402
 * @property {string} message - 'Client is unable to apply a remote media description'
 */
var MediaClientRemoteDescFailedError = /** @class */ (function (_super) {
    __extends(MediaClientRemoteDescFailedError, _super);
    function MediaClientRemoteDescFailedError() {
        var _this = _super.call(this, 53402, 'Client is unable to apply a remote media description') || this;
        Object.setPrototypeOf(_this, MediaClientRemoteDescFailedError.prototype);
        return _this;
    }
    return MediaClientRemoteDescFailedError;
}(TwilioError));
exports.MediaClientRemoteDescFailedError = MediaClientRemoteDescFailedError;
Object.defineProperty(TwilioErrorByCode, 53402, { value: MediaClientRemoteDescFailedError });
/**
 * @class MediaServerRemoteDescFailedError
 * @classdesc Raised whenever the Server receives a remote media description but is unable to apply it.
 * @extends TwilioError
 * @property {number} code - 53403
 * @property {string} message - 'Server is unable to apply a remote media description'
 */
var MediaServerRemoteDescFailedError = /** @class */ (function (_super) {
    __extends(MediaServerRemoteDescFailedError, _super);
    function MediaServerRemoteDescFailedError() {
        var _this = _super.call(this, 53403, 'Server is unable to apply a remote media description') || this;
        Object.setPrototypeOf(_this, MediaServerRemoteDescFailedError.prototype);
        return _this;
    }
    return MediaServerRemoteDescFailedError;
}(TwilioError));
exports.MediaServerRemoteDescFailedError = MediaServerRemoteDescFailedError;
Object.defineProperty(TwilioErrorByCode, 53403, { value: MediaServerRemoteDescFailedError });
/**
 * @class MediaNoSupportedCodecError
 * @classdesc Raised whenever the intersection of codecs supported by the Client and the Server (or, in peer-to-peer, the Client and another Participant) is empty.
 * @extends TwilioError
 * @property {number} code - 53404
 * @property {string} message - 'No supported codec'
 */
var MediaNoSupportedCodecError = /** @class */ (function (_super) {
    __extends(MediaNoSupportedCodecError, _super);
    function MediaNoSupportedCodecError() {
        var _this = _super.call(this, 53404, 'No supported codec') || this;
        Object.setPrototypeOf(_this, MediaNoSupportedCodecError.prototype);
        return _this;
    }
    return MediaNoSupportedCodecError;
}(TwilioError));
exports.MediaNoSupportedCodecError = MediaNoSupportedCodecError;
Object.defineProperty(TwilioErrorByCode, 53404, { value: MediaNoSupportedCodecError });
/**
 * @class MediaConnectionError
 * @classdesc Raised by the Client or Server whenever a media connection fails or raised by the Client whenever it detects that media has stopped flowing.
 * @extends TwilioError
 * @property {number} code - 53405
 * @property {string} message - 'Media connection failed or Media activity ceased'
 */
var MediaConnectionError = /** @class */ (function (_super) {
    __extends(MediaConnectionError, _super);
    function MediaConnectionError() {
        var _this = _super.call(this, 53405, 'Media connection failed or Media activity ceased') || this;
        Object.setPrototypeOf(_this, MediaConnectionError.prototype);
        return _this;
    }
    return MediaConnectionError;
}(TwilioError));
exports.MediaConnectionError = MediaConnectionError;
Object.defineProperty(TwilioErrorByCode, 53405, { value: MediaConnectionError });
/**
 * @class MediaDTLSTransportFailedError
 * @classdesc There was a problem while negotiating with the remote DTLS peer. Therefore the Participant will not be able to publish or subscribe to Tracks.
 * @extends TwilioError
 * @property {number} code - 53407
 * @property {string} message - 'Media connection failed due to DTLS handshake failure'
 */
var MediaDTLSTransportFailedError = /** @class */ (function (_super) {
    __extends(MediaDTLSTransportFailedError, _super);
    function MediaDTLSTransportFailedError() {
        var _this = _super.call(this, 53407, 'Media connection failed due to DTLS handshake failure') || this;
        Object.setPrototypeOf(_this, MediaDTLSTransportFailedError.prototype);
        return _this;
    }
    return MediaDTLSTransportFailedError;
}(TwilioError));
exports.MediaDTLSTransportFailedError = MediaDTLSTransportFailedError;
Object.defineProperty(TwilioErrorByCode, 53407, { value: MediaDTLSTransportFailedError });
/**
 * @class ConfigurationAcquireFailedError
 * @classdesc Raised whenever the Client is unable to acquire configuration information from the Server.
 * @extends TwilioError
 * @property {number} code - 53500
 * @property {string} message - 'Unable to acquire configuration'
 */
var ConfigurationAcquireFailedError = /** @class */ (function (_super) {
    __extends(ConfigurationAcquireFailedError, _super);
    function ConfigurationAcquireFailedError() {
        var _this = _super.call(this, 53500, 'Unable to acquire configuration') || this;
        Object.setPrototypeOf(_this, ConfigurationAcquireFailedError.prototype);
        return _this;
    }
    return ConfigurationAcquireFailedError;
}(TwilioError));
exports.ConfigurationAcquireFailedError = ConfigurationAcquireFailedError;
Object.defineProperty(TwilioErrorByCode, 53500, { value: ConfigurationAcquireFailedError });
/**
 * @class ConfigurationAcquireTurnFailedError
 * @classdesc Raised whenever the Server is unable to return TURN credentials to the Client
 * @extends TwilioError
 * @property {number} code - 53501
 * @property {string} message - 'Unable to acquire TURN credentials'
 */
var ConfigurationAcquireTurnFailedError = /** @class */ (function (_super) {
    __extends(ConfigurationAcquireTurnFailedError, _super);
    function ConfigurationAcquireTurnFailedError() {
        var _this = _super.call(this, 53501, 'Unable to acquire TURN credentials') || this;
        Object.setPrototypeOf(_this, ConfigurationAcquireTurnFailedError.prototype);
        return _this;
    }
    return ConfigurationAcquireTurnFailedError;
}(TwilioError));
exports.ConfigurationAcquireTurnFailedError = ConfigurationAcquireTurnFailedError;
Object.defineProperty(TwilioErrorByCode, 53501, { value: ConfigurationAcquireTurnFailedError });
//# sourceMappingURL=twilio-video-errors.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/twilioerror.js":
/*!***********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/twilioerror.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
/**
 * @extends Error
 * @property {number} code - Error code
 */
var TwilioError = /** @class */ (function (_super) {
    __extends(TwilioError, _super);
    /**
     * Creates a new {@link TwilioError}
     * @param {number} code - Error code
     * @param {string} [message] - Error message
     * @param {string} [fileName] - Name of the script file where error was generated
     * @param {number} [lineNumber] - Line number of the script file where error was generated
     */
    function TwilioError(code) {
        var _this = this;
        var args = [].slice.call(arguments, 1);
        _this = _super.apply(this, __spreadArray([], __read(args))) || this;
        Object.setPrototypeOf(_this, TwilioError.prototype);
        var error = Error.apply(_this, args);
        error.name = 'TwilioError';
        Object.defineProperty(_this, 'code', {
            value: code,
            enumerable: true
        });
        Object.getOwnPropertyNames(error).forEach(function (prop) {
            Object.defineProperty(this, prop, {
                value: error[prop],
                enumerable: true
            });
        }, _this);
        return _this;
    }
    /**
     * Returns human readable string describing the error.
     * @returns {string}
     */
    TwilioError.prototype.toString = function () {
        var message = this.message ? ": " + this.message : '';
        return this.name + " " + this.code + message;
    };
    return TwilioError;
}(Error));
module.exports = TwilioError;
//# sourceMappingURL=twilioerror.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/util/validate.js":
/*!********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/util/validate.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isNonArrayObject = __webpack_require__(/*! ./ */ "../../work/twilio-video.js/es5/util/index.js").isNonArrayObject;
var _a = __webpack_require__(/*! ./constants */ "../../work/twilio-video.js/es5/util/constants.js"), E = _a.typeErrors, clientTrackSwitchOffControl = _a.clientTrackSwitchOffControl, videoContentPreferencesMode = _a.videoContentPreferencesMode, subscriptionMode = _a.subscriptionMode, trackPriority = _a.trackPriority, trackSwitchOffMode = _a.trackSwitchOffMode;
/**
 * Validate the {@link BandwidthProfileOptions} object.
 * @param {BandwidthProfileOptions} bandwidthProfile
 * @returns {?Error} - null if valid, Error if not.
 */
function validateBandwidthProfile(bandwidthProfile) {
    var error = validateObject(bandwidthProfile, 'options.bandwidthProfile');
    if (!bandwidthProfile || error) {
        return error;
    }
    error = validateObject(bandwidthProfile.video, 'options.bandwidthProfile.video', [
        { prop: 'contentPreferencesMode', values: Object.values(videoContentPreferencesMode) },
        { prop: 'dominantSpeakerPriority', values: Object.values(trackPriority) },
        { prop: 'maxSubscriptionBitrate', type: 'number' },
        { prop: 'maxTracks', type: 'number' },
        { prop: 'mode', values: Object.values(subscriptionMode) },
        { prop: 'clientTrackSwitchOffControl', values: Object.values(clientTrackSwitchOffControl) },
        { prop: 'trackSwitchOffMode', values: Object.values(trackSwitchOffMode) }
    ]);
    if (error) {
        return error;
    }
    if (bandwidthProfile.video) {
        // maxTracks is replaced by clientTrackSwitchOffControl.
        // throw an error if both are specified.
        if ('maxTracks' in bandwidthProfile.video && 'clientTrackSwitchOffControl' in bandwidthProfile.video) {
            return new TypeError('options.bandwidthProfile.video.maxTracks is deprecated. Use options.bandwidthProfile.video.clientTrackSwitchOffControl instead.');
        }
        // renderDimensions is replaced by contentPreferencesMode.
        // throw an error if both are specified.
        if ('renderDimensions' in bandwidthProfile.video && 'contentPreferencesMode' in bandwidthProfile.video) {
            return new TypeError('options.bandwidthProfile.video.renderDimensions is deprecated. Use options.bandwidthProfile.video.contentPreferencesMode instead.');
        }
        return validateRenderDimensions(bandwidthProfile.video.renderDimensions);
    }
    return null;
}
/**
 * Throw if the given track is not a {@link LocalAudioTrack}, a
 * {@link LocalVideoTrack} or a MediaStreamTrack.
 * @param {*} track
 * @param {object} options
 */
function validateLocalTrack(track, options) {
    if (!(track instanceof options.LocalAudioTrack
        || track instanceof options.LocalDataTrack
        || track instanceof options.LocalVideoTrack
        || track instanceof options.MediaStreamTrack)) {
        /* eslint new-cap:0 */
        throw E.INVALID_TYPE('track', 'LocalAudioTrack, LocalVideoTrack, LocalDataTrack, or MediaStreamTrack');
    }
}
/**
 * Validate an object. An object is valid if it is undefined or a non-null, non-array
 * object whose properties satisfy the specified data-type or value-range requirements.
 * @param {object} object - the object to be validated
 * @param {string} name - the object name to be used to build the error message, if invalid
 * @param {Array<object>} [propChecks] - optional data-type or value-range requirements
 *   for the object's properties
 * @returns {?Error} - null if object is valid, Error if not
 */
function validateObject(object, name, propChecks) {
    if (propChecks === void 0) { propChecks = []; }
    // NOTE(mmalavalli): We determine that an undefined object is valid because this
    // means the parent object does not contain this object as a property, which is
    // a valid scenario.
    if (typeof object === 'undefined') {
        return null;
    }
    // NOTE(mmalavalli): We determine that if the object is null, or an Array, or
    // any other non-object type, then it is invalid.
    if (object === null || !isNonArrayObject(object)) {
        return E.INVALID_TYPE(name, 'object');
    }
    // NOTE(mmalavalli): We determine that the object is invalid if at least one of
    // its properties does not satisfy its data-type or value-range requirement.
    return propChecks.reduce(function (error, _a) {
        var prop = _a.prop, type = _a.type, values = _a.values;
        if (error || !(prop in object)) {
            return error;
        }
        var value = object[prop];
        if (type && typeof value !== type) {
            return E.INVALID_TYPE(name + "." + prop, type);
        }
        if (type === 'number' && isNaN(value)) {
            return E.INVALID_TYPE(name + "." + prop, type);
        }
        if (Array.isArray(values) && !values.includes(value)) {
            return E.INVALID_VALUE(name + "." + prop, values);
        }
        return error;
    }, null);
}
/**
 * Validates the renderDimensions field to be "auto" or {@link VideoRenderDimensions} object.
 * @param {string|VideoRenderDimensions} renderDimensions
 * @returns {?Error} - null if valid, Error if not.
 */
function validateRenderDimensions(renderDimensions) {
    var name = 'options.bandwidthProfile.video.renderDimensions';
    var error = validateObject(renderDimensions, name);
    return renderDimensions ? error || Object.values(trackPriority).reduce(function (error, prop) {
        return error || validateObject(renderDimensions[prop], name + "." + prop, [
            { prop: 'height', type: 'number' },
            { prop: 'width', type: 'number' }
        ]);
    }, null) : error;
}
exports.validateBandwidthProfile = validateBandwidthProfile;
exports.validateLocalTrack = validateLocalTrack;
exports.validateObject = validateObject;
//# sourceMappingURL=validate.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/vendor/loglevel.js":
/*!**********************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/vendor/loglevel.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2013 Tim Perry
 * Licensed under the MIT license.
 *
 * Copied from https://github.com/pimterry/loglevel (1.7.0)
 * and modified to remove browser and AMD module support, while keeping CommonJS.
 * It was causing a conflict when this is bundled using CommonJS, and then loaded via RequireJS.
 * The proper way to fix this module is to have a build that outputs CommonJS and AMD separately
 * which needs to be submitted to the original module's repo.
 */
/* istanbul ignore file */
/* eslint-disable */
// Slightly dubious tricks to cut down minimized file size
var noop = function () { };
var undefinedType = "undefined";
var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (/Trident\/|MSIE /.test(window.navigator.userAgent));
var logMethods = [
    "trace",
    "debug",
    "info",
    "warn",
    "error"
];
// Cross-browser bind equivalent that works at least back to IE6
function bindMethod(obj, methodName) {
    var method = obj[methodName];
    if (typeof method.bind === 'function') {
        return method.bind(obj);
    }
    else {
        try {
            return Function.prototype.bind.call(method, obj);
        }
        catch (e) {
            // Missing bind shim or IE8 + Modernizr, fallback to wrapping
            return function () {
                return Function.prototype.apply.apply(method, [obj, arguments]);
            };
        }
    }
}
// Trace() doesn't print the message in IE, so for that case we need to wrap it
function traceForIE() {
    if (console.log) {
        if (console.log.apply) {
            console.log.apply(console, arguments);
        }
        else {
            // In old IE, native console methods themselves don't have apply().
            Function.prototype.apply.apply(console.log, [console, arguments]);
        }
    }
    if (console.trace)
        console.trace();
}
// Build the best logging method possible for this env
// Wherever possible we want to bind, not wrap, to preserve stack traces
function realMethod(methodName) {
    if (methodName === 'debug') {
        methodName = 'log';
    }
    if (typeof console === undefinedType) {
        return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
    }
    else if (methodName === 'trace' && isIE) {
        return traceForIE;
    }
    else if (console[methodName] !== undefined) {
        return bindMethod(console, methodName);
    }
    else if (console.log !== undefined) {
        return bindMethod(console, 'log');
    }
    else {
        return noop;
    }
}
// These private functions always need `this` to be set properly
function replaceLoggingMethods(level, loggerName) {
    /*jshint validthis:true */
    for (var i = 0; i < logMethods.length; i++) {
        var methodName = logMethods[i];
        this[methodName] = (i < level) ?
            noop :
            this.methodFactory(methodName, level, loggerName);
    }
    // Define log.log as an alias for log.debug
    this.log = this.debug;
}
// In old IE versions, the console isn't present until you first open it.
// We build realMethod() replacements here that regenerate logging methods
function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
    return function () {
        if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this, level, loggerName);
            this[methodName].apply(this, arguments);
        }
    };
}
// By default, we use closely bound real methods wherever possible, and
// otherwise we wait for a console to appear, and then try again.
function defaultMethodFactory(methodName, level, loggerName) {
    /*jshint validthis:true */
    return realMethod(methodName) ||
        enableLoggingWhenConsoleArrives.apply(this, arguments);
}
function Logger(name, defaultLevel, factory) {
    var self = this;
    var currentLevel;
    var storageKey = "loglevel";
    if (typeof name === "string") {
        storageKey += ":" + name;
    }
    else if (typeof name === "symbol") {
        storageKey = undefined;
    }
    function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || 'silent').toUpperCase();
        if (typeof window === undefinedType || !storageKey)
            return;
        // Use localStorage if available
        try {
            window.localStorage[storageKey] = levelName;
            return;
        }
        catch (ignore) { }
        // Use session cookie as fallback
        try {
            window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
        }
        catch (ignore) { }
    }
    function getPersistedLevel() {
        var storedLevel;
        if (typeof window === undefinedType || !storageKey)
            return;
        try {
            storedLevel = window.localStorage[storageKey];
        }
        catch (ignore) { }
        // Fallback to cookies if local storage gives us nothing
        if (typeof storedLevel === undefinedType) {
            try {
                var cookie = window.document.cookie;
                var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");
                if (location !== -1) {
                    storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                }
            }
            catch (ignore) { }
        }
        // If the stored level is not valid, treat it as if nothing was stored.
        if (self.levels[storedLevel] === undefined) {
            storedLevel = undefined;
        }
        return storedLevel;
    }
    /*
     *
     * Public logger API - see https://github.com/pimterry/loglevel for details
     *
     */
    self.name = name;
    self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
        "ERROR": 4, "SILENT": 5 };
    self.methodFactory = factory || defaultMethodFactory;
    self.getLevel = function () {
        return currentLevel;
    };
    self.setLevel = function (level, persist) {
        if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
            level = self.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
            currentLevel = level;
            if (persist !== false) { // defaults to true
                persistLevelIfPossible(level);
            }
            replaceLoggingMethods.call(self, level, name);
            if (typeof console === undefinedType && level < self.levels.SILENT) {
                return "No console available for logging";
            }
        }
        else {
            throw "log.setLevel() called with invalid level: " + level;
        }
    };
    self.setDefaultLevel = function (level) {
        if (!getPersistedLevel()) {
            self.setLevel(level, false);
        }
    };
    self.enableAll = function (persist) {
        self.setLevel(self.levels.TRACE, persist);
    };
    self.disableAll = function (persist) {
        self.setLevel(self.levels.SILENT, persist);
    };
    // Initialize with the right level
    var initialLevel = getPersistedLevel();
    if (initialLevel == null) {
        initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
    }
    self.setLevel(initialLevel, false);
}
/*
 *
 * Top-level API
 *
 */
var defaultLogger = new Logger();
var _loggersByName = {};
defaultLogger.getLogger = function getLogger(name) {
    if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
        throw new TypeError("You must supply a name when creating a logger.");
    }
    var logger = _loggersByName[name];
    if (!logger) {
        logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);
    }
    return logger;
};
// Grab the current global log variable in case of overwrite
var _log = (typeof window !== undefinedType) ? window.log : undefined;
defaultLogger.noConflict = function () {
    if (typeof window !== undefinedType &&
        window.log === defaultLogger) {
        window.log = _log;
    }
    return defaultLogger;
};
defaultLogger.getLoggers = function getLoggers() {
    return _loggersByName;
};
// ES6 default export, for compatibility
defaultLogger['default'] = defaultLogger;
module.exports = defaultLogger;
//# sourceMappingURL=loglevel.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/webaudio/audiocontext.js":
/*!****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/webaudio/audiocontext.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals webkitAudioContext, AudioContext */

var NativeAudioContext = typeof AudioContext !== 'undefined'
    ? AudioContext
    : typeof webkitAudioContext !== 'undefined'
        ? webkitAudioContext
        : null;
/**
 * @interface AudioContextFactoryOptions
 * @property {AudioContext} [AudioContext] - The AudioContext constructor
 */
/**
 * {@link AudioContextFactory} ensures we construct at most one AudioContext
 * at a time, and that it is eventually closed when we no longer need it.
 * @property {AudioContextFactory} AudioContextFactory - The
 *   {@link AudioContextFactory} constructor
 */
var AudioContextFactory = /** @class */ (function () {
    /**
     * @param {AudioContextFactoryOptions} [options]
     */
    function AudioContextFactory(options) {
        options = Object.assign({
            AudioContext: NativeAudioContext
        }, options);
        Object.defineProperties(this, {
            _AudioContext: {
                value: options.AudioContext
            },
            _audioContext: {
                value: null,
                writable: true
            },
            _holders: {
                value: new Set()
            },
            AudioContextFactory: {
                enumerable: true,
                value: AudioContextFactory
            }
        });
    }
    /**
     * Each call to {@link AudioContextFactory#getOrCreate} should be paired with a
     * call to {@link AudioContextFactory#release}. Calling this increments an
     * internal reference count.
     * @param {*} holder - The object to hold a reference to the AudioContext
     * @returns {?AudioContext}
     */
    AudioContextFactory.prototype.getOrCreate = function (holder) {
        if (!this._holders.has(holder)) {
            this._holders.add(holder);
            if (this._AudioContext && !this._audioContext) {
                try {
                    this._audioContext = new this._AudioContext();
                }
                catch (error) {
                    // Do nothing;
                }
            }
        }
        return this._audioContext;
    };
    /**
     * Decrement the internal reference count. If it reaches zero, close and destroy
     * the AudioContext.
     * @param {*} holder - The object that held a reference to the AudioContext
     * @returns {void}
     */
    AudioContextFactory.prototype.release = function (holder) {
        if (this._holders.has(holder)) {
            this._holders.delete(holder);
            if (!this._holders.size && this._audioContext) {
                this._audioContext.close();
                this._audioContext = null;
            }
        }
    };
    return AudioContextFactory;
}());
module.exports = new AudioContextFactory();
//# sourceMappingURL=audiocontext.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/webaudio/detectsilence.js":
/*!*****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/webaudio/detectsilence.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Return a Promise that resolves after `timeout` milliseconds.
 * @param {?number} [timeout=0]
 * @returns {Promise<void>}
 */
function delay(timeout) {
    timeout = typeof timeout === 'number' ? timeout : 0;
    return new Promise(function (resolve) { return setTimeout(resolve, timeout); });
}
/**
 * Attempt to detect silence. The Promise returned by this function returns
 * false as soon as audio is detected or true after `timeout` milliseconds.
 * @param {AudioContext} audioContext
 * @param {MediaStream} stream
 * @param {?number} [timeout=250]
 * @returns {Promise<boolean>}
 */
function detectSilence(audioContext, stream, timeout) {
    timeout = typeof timeout === 'number' ? timeout : 250;
    var source = audioContext.createMediaStreamSource(stream);
    var analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    source.connect(analyser);
    var samples = new Uint8Array(analyser.fftSize);
    var timeoutDidFire = false;
    setTimeout(function () { timeoutDidFire = true; }, timeout);
    /**
     * We can't use async/await yet, so I need to factor this out.
     * @returns {Promise<boolean>}
     */
    function doDetectSilence() {
        if (timeoutDidFire) {
            return Promise.resolve(true);
        }
        analyser.getByteTimeDomainData(samples);
        // NOTE(mpatwardhan): An audio MediaStreamTrack can be silent either due to all samples
        // being equal to 128 or all samples being equal to 0.
        return samples.some(function (sample) { return sample !== 128 && sample !== 0; })
            ? Promise.resolve(false)
            : delay().then(doDetectSilence);
    }
    return doDetectSilence().then(function (isSilent) {
        source.disconnect();
        return isSilent;
    }, function (error) {
        source.disconnect();
        throw error;
    });
}
module.exports = detectSilence;
//# sourceMappingURL=detectsilence.js.map

/***/ }),

/***/ "../../work/twilio-video.js/es5/webaudio/workaround180748.js":
/*!********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/es5/webaudio/workaround180748.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var detectSilence = __webpack_require__(/*! ./detectsilence */ "../../work/twilio-video.js/es5/webaudio/detectsilence.js");
/**
 * This function attempts to workaround WebKit Bug 180748. It does so by
 *
 *   1. Calling `getUserMedia`, and
 *   2. Checking to see if the resulting MediaStream is silent.
 *   3. If so, repeat Step 1; otherwise, return the MediaStream.
 *
 * The function only repeats up to `n` times, and it only waits `timeout`
 * milliseconds when detecting silence. Assuming `getUserMedia` is
 * instantaneous, in the best case, this function returns a Promise that
 * resolves immediately; in the worst case, this function returns a Promise that
 * resolves in `n` * `timeout` milliseconds.
 *
 * @param {Log} log
 * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia
 * @param {MediaStreamConstraints} constraints
 * @param {number} [n=3]
 * @param {number} [timeout=250]
 * @returns Promise<MediaStream>
 */
function workaround(log, getUserMedia, constraints, n, timeout) {
    n = typeof n === 'number' ? n : 3;
    var retry = 0;
    // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because
    // it exports a default instance whose constructor calls Object.assign.
    var AudioContextFactory = __webpack_require__(/*! ./audiocontext */ "../../work/twilio-video.js/es5/webaudio/audiocontext.js");
    var holder = {};
    var audioContext = AudioContextFactory.getOrCreate(holder);
    /**
     * We can't use async/await yet, so I need to factor this out.
     * @returns {Promise<MediaStream>}
     */
    function doWorkaround() {
        return getUserMedia(constraints).then(function (stream) {
            var isSilentPromise = constraints.audio
                ? detectSilence(audioContext, stream, timeout).catch(function (err) {
                    log.warn('Encountered an error while detecting silence', err);
                    return true;
                })
                : Promise.resolve(false);
            return isSilentPromise.then(function (isSilent) {
                if (!isSilent) {
                    log.info('Got a non-silent audio MediaStreamTrack; returning it.');
                    return stream;
                }
                else if (n <= 0) {
                    log.warn('Got a silent audio MediaStreamTrack. Normally we would try \
to get a new one, but we\'ve run out of retries; returning it anyway.');
                    return stream;
                }
                log.warn("Got a silent audio MediaStreamTrack. Stopping all MediaStreamTracks and calling getUserMedia again. This is retry #" + ++retry + ".");
                stream.getTracks().forEach(function (track) { return track.stop(); });
                n--;
                return doWorkaround();
            });
        });
    }
    return doWorkaround().then(function (stream) {
        AudioContextFactory.release(holder);
        return stream;
    }, function (error) {
        AudioContextFactory.release(holder);
        throw error;
    });
}
module.exports = workaround;
//# sourceMappingURL=workaround180748.js.map

/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/getstats.js":
/*!*******************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/getstats.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var flatMap = __webpack_require__(/*! ./util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").flatMap;
var guessBrowser = __webpack_require__(/*! ./util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").guessBrowser;
var guessBrowserVersion = __webpack_require__(/*! ./util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").guessBrowserVersion;
var getSdpFormat = __webpack_require__(/*! ./util/sdp */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/sdp.js").getSdpFormat;

var guess = guessBrowser();
var guessVersion = guessBrowserVersion();
var isChrome = guess === 'chrome';
var isFirefox = guess === 'firefox';
var isSafari = guess === 'safari';

var chromeMajorVersion = isChrome ? guessVersion.major : null;

var CHROME_LEGACY_MAX_AUDIO_LEVEL = 32767;

/**
 * Get the standardized {@link RTCPeerConnection} statistics.
 * @param {RTCPeerConnection} peerConnection
 * @param {object} [options] - Used for testing
 * @returns {Promise.<StandardizedStatsResponse>}
 */
function getStats(peerConnection, options) {
  if (!(peerConnection && typeof peerConnection.getStats === 'function')) {
    return Promise.reject(new Error('Given PeerConnection does not support getStats'));
  }
  return _getStats(peerConnection, options);
}

/**
 * getStats() implementation.
 * @param {RTCPeerConnection} peerConnection
 * @param {object} [options] - Used for testing
 * @returns {Promise.<StandardizedStatsResponse>}
 */
function _getStats(peerConnection, options) {
  var localAudioTracks = getTracks(peerConnection, 'audio', 'local');
  var localVideoTracks = getTracks(peerConnection, 'video', 'local');
  var remoteAudioTracks = getTracks(peerConnection, 'audio');
  var remoteVideoTracks = getTracks(peerConnection, 'video');

  var statsResponse = {
    activeIceCandidatePair: null,
    localAudioTrackStats: [],
    localVideoTrackStats: [],
    remoteAudioTrackStats: [],
    remoteVideoTrackStats: []
  };

  var trackStatsPromises = flatMap([
    [localAudioTracks, 'localAudioTrackStats', false],
    [localVideoTracks, 'localVideoTrackStats', false],
    [remoteAudioTracks, 'remoteAudioTrackStats', true],
    [remoteVideoTracks, 'remoteVideoTrackStats', true]
  ], function(triple) {
    var tracks = triple[0];
    var statsArrayName = triple[1];
    var isRemote = triple[2];
    return tracks.map(function(track) {
      return getTrackStats(peerConnection, track, Object.assign({
        isRemote: isRemote
      }, options)).then(function(trackStatsArray) {
        trackStatsArray.forEach(function(trackStats) {
          trackStats.trackId = track.id;
          statsResponse[statsArrayName].push(trackStats);
        });
      });
    });
  });

  return Promise.all(trackStatsPromises).then(function() {
    return getActiveIceCandidatePairStats(peerConnection, options);
  }).then(function(activeIceCandidatePairStatsReport) {
    statsResponse.activeIceCandidatePair = activeIceCandidatePairStatsReport;
    return statsResponse;
  });
}

/**
 * Generate the {@link StandardizedActiveIceCandidatePairStatsReport} for the
 * {@link RTCPeerConnection}.
 * @param {RTCPeerConnection} peerConnection
 * @param {object} [options]
 * @returns {Promise<StandardizedActiveIceCandidatePairStatsReport>}
 */
function getActiveIceCandidatePairStats(peerConnection, options) {
  options = options || {};

  if (typeof options.testForChrome !== 'undefined' || isChrome
    || typeof options.testForSafari  !== 'undefined' || isSafari) {
    return peerConnection.getStats().then(
      standardizeChromeOrSafariActiveIceCandidatePairStats);
  }
  if (typeof options.testForFirefox !== 'undefined' || isFirefox) {
    return peerConnection.getStats().then(standardizeFirefoxActiveIceCandidatePairStats);
  }
  return Promise.reject(new Error('RTCPeerConnection#getStats() not supported'));
}

/**
 * Standardize the active RTCIceCandidate pair's statistics in Chrome or Safari.
 * @param {RTCStatsReport} stats
 * @returns {?StandardizedActiveIceCandidatePairStatsReport}
 */
function standardizeChromeOrSafariActiveIceCandidatePairStats(stats) {
  var activeCandidatePairStats = Array.from(stats.values()).find(function(stat) {
    return stat.type === 'candidate-pair' && stat.nominated;
  });

  if (!activeCandidatePairStats) {
    return null;
  }

  var activeLocalCandidateStats = stats.get(activeCandidatePairStats.localCandidateId);
  var activeRemoteCandidateStats = stats.get(activeCandidatePairStats.remoteCandidateId);

  var standardizedCandidateStatsKeys = [
    { key: 'candidateType', type: 'string' },
    { key: 'ip', type: 'string' },
    { key: 'port', type: 'number' },
    { key: 'priority', type: 'number' },
    { key: 'protocol', type: 'string' },
    { key: 'url', type: 'string' }
  ];

  var standardizedLocalCandidateStatsKeys = standardizedCandidateStatsKeys.concat([
    { key: 'deleted', type: 'boolean' },
    { key: 'relayProtocol', type: 'string' }
  ]);

  var standatdizedLocalCandidateStatsReport = activeLocalCandidateStats
    ? standardizedLocalCandidateStatsKeys.reduce(function(report, keyInfo) {
      report[keyInfo.key] = typeof activeLocalCandidateStats[keyInfo.key] === keyInfo.type
        ? activeLocalCandidateStats[keyInfo.key]
        : keyInfo.key === 'deleted' ? false : null;
      return report;
    }, {})
    : null;

  var standardizedRemoteCandidateStatsReport = activeRemoteCandidateStats
    ? standardizedCandidateStatsKeys.reduce(function(report, keyInfo) {
      report[keyInfo.key] = typeof activeRemoteCandidateStats[keyInfo.key] === keyInfo.type
        ? activeRemoteCandidateStats[keyInfo.key]
        : null;
      return report;
    }, {})
    : null;

  return [
    { key: 'availableIncomingBitrate', type: 'number' },
    { key: 'availableOutgoingBitrate', type: 'number' },
    { key: 'bytesReceived', type: 'number' },
    { key: 'bytesSent', type: 'number' },
    { key: 'consentRequestsSent', type: 'number' },
    { key: 'currentRoundTripTime', type: 'number' },
    { key: 'lastPacketReceivedTimestamp', type: 'number' },
    { key: 'lastPacketSentTimestamp', type: 'number' },
    { key: 'nominated', type: 'boolean' },
    { key: 'priority', type: 'number' },
    { key: 'readable', type: 'boolean' },
    { key: 'requestsReceived', type: 'number' },
    { key: 'requestsSent', type: 'number' },
    { key: 'responsesReceived', type: 'number' },
    { key: 'responsesSent', type: 'number' },
    { key: 'retransmissionsReceived', type: 'number' },
    { key: 'retransmissionsSent', type: 'number' },
    { key: 'state', type: 'string', fixup: function(state) { return state === 'inprogress' ? 'in-progress' : state; } },
    { key: 'totalRoundTripTime', type: 'number' },
    { key: 'transportId', type: 'string' },
    { key: 'writable', type: 'boolean' }
  ].reduce(function(report, keyInfo) {
    report[keyInfo.key] = typeof activeCandidatePairStats[keyInfo.key] === keyInfo.type
      ? (keyInfo.fixup ? keyInfo.fixup(activeCandidatePairStats[keyInfo.key]) : activeCandidatePairStats[keyInfo.key])
      : null;
    return report;
  }, {
    localCandidate: standatdizedLocalCandidateStatsReport,
    remoteCandidate: standardizedRemoteCandidateStatsReport
  });
}

/**
 * Standardize the active RTCIceCandidate pair's statistics in Firefox.
 * @param {RTCStatsReport} stats
 * @returns {?StandardizedActiveIceCandidatePairStatsReport}
 */
function standardizeFirefoxActiveIceCandidatePairStats(stats) {
  var activeCandidatePairStats = Array.from(stats.values()).find(function(stat) {
    return stat.type === 'candidate-pair' && stat.nominated;
  });

  if (!activeCandidatePairStats) {
    return null;
  }

  var activeLocalCandidateStats = stats.get(activeCandidatePairStats.localCandidateId);
  var activeRemoteCandidateStats = stats.get(activeCandidatePairStats.remoteCandidateId);

  var standardizedCandidateStatsKeys = [
    { key: 'candidateType', type: 'string' },
    { key: 'ip', ffKeys: ['address', 'ipAddress'], type: 'string' },
    { key: 'port', ffKeys: ['portNumber'], type: 'number' },
    { key: 'priority', type: 'number' },
    { key: 'protocol', ffKeys: ['transport'], type: 'string' },
    { key: 'url', type: 'string' }
  ];

  var standardizedLocalCandidateStatsKeys = standardizedCandidateStatsKeys.concat([
    { key: 'deleted', type: 'boolean' },
    { key: 'relayProtocol', type: 'string' }
  ]);

  var candidateTypes = {
    host: 'host',
    peerreflexive: 'prflx',
    relayed: 'relay',
    serverreflexive: 'srflx'
  };

  var standatdizedLocalCandidateStatsReport = activeLocalCandidateStats
    ? standardizedLocalCandidateStatsKeys.reduce(function(report, keyInfo) {
      var key = keyInfo.ffKeys && keyInfo.ffKeys.find(function(key) {
        return key in activeLocalCandidateStats;
      }) || keyInfo.key;
      report[keyInfo.key] = typeof activeLocalCandidateStats[key] === keyInfo.type
        ? key === 'candidateType'
          ? candidateTypes[activeLocalCandidateStats[key]] || activeLocalCandidateStats[key]
          : activeLocalCandidateStats[key]
        : key === 'deleted' ? false : null;
      return report;
    }, {})
    : null;

  var standardizedRemoteCandidateStatsReport = activeRemoteCandidateStats
    ? standardizedCandidateStatsKeys.reduce(function(report, keyInfo) {
      var key = keyInfo.ffKeys && keyInfo.ffKeys.find(function(key) {
        return key in activeRemoteCandidateStats;
      }) || keyInfo.key;
      report[keyInfo.key] = typeof activeRemoteCandidateStats[key] === keyInfo.type
        ? key === 'candidateType'
          ? candidateTypes[activeRemoteCandidateStats[key]] || activeRemoteCandidateStats[key]
          : activeRemoteCandidateStats[key]
        : null;
      return report;
    }, {})
    : null;

  return [
    { key: 'availableIncomingBitrate', type: 'number' },
    { key: 'availableOutgoingBitrate', type: 'number' },
    { key: 'bytesReceived', type: 'number' },
    { key: 'bytesSent', type: 'number' },
    { key: 'consentRequestsSent', type: 'number' },
    { key: 'currentRoundTripTime', type: 'number' },
    { key: 'lastPacketReceivedTimestamp', type: 'number' },
    { key: 'lastPacketSentTimestamp', type: 'number' },
    { key: 'nominated', type: 'boolean' },
    { key: 'priority', type: 'number' },
    { key: 'readable', type: 'boolean' },
    { key: 'requestsReceived', type: 'number' },
    { key: 'requestsSent', type: 'number' },
    { key: 'responsesReceived', type: 'number' },
    { key: 'responsesSent', type: 'number' },
    { key: 'retransmissionsReceived', type: 'number' },
    { key: 'retransmissionsSent', type: 'number' },
    { key: 'state', type: 'string' },
    { key: 'totalRoundTripTime', type: 'number' },
    { key: 'transportId', type: 'string' },
    { key: 'writable', type: 'boolean' }
  ].reduce(function(report, keyInfo) {
    report[keyInfo.key] = typeof activeCandidatePairStats[keyInfo.key] === keyInfo.type
      ? activeCandidatePairStats[keyInfo.key]
      : null;
    return report;
  }, {
    localCandidate: standatdizedLocalCandidateStatsReport,
    remoteCandidate: standardizedRemoteCandidateStatsReport
  });
}

/**
 * Get local/remote audio/video MediaStreamTracks.
 * @param {RTCPeerConnection} peerConnection - The RTCPeerConnection
 * @param {string} kind - 'audio' or 'video'
 * @param {string} [localOrRemote] - 'local' or 'remote'
 * @returns {Array<MediaStreamTrack>}
 */
function getTracks(peerConnection, kind, localOrRemote) {
  var getSendersOrReceivers = localOrRemote === 'local' ? 'getSenders' : 'getReceivers';
  if (peerConnection[getSendersOrReceivers]) {
    return peerConnection[getSendersOrReceivers]().map(function(senderOrReceiver) {
      return senderOrReceiver.track;
    }).filter(function(track) {
      return track && track.kind === kind;
    });
  }
  var getStreams = localOrRemote === 'local' ? 'getLocalStreams' : 'getRemoteStreams';
  return flatMap(peerConnection[getStreams](), function(stream) {
    var getTracks = kind === 'audio' ? 'getAudioTracks' : 'getVideoTracks';
    return stream[getTracks]();
  });
}

/**
 * Get the standardized statistics for a particular MediaStreamTrack.
 * @param {RTCPeerConnection} peerConnection
 * @param {MediaStreamTrack} track
 * @param {object} [options] - Used for testing
 * @returns {Promise.<Array<StandardizedTrackStatsReport>>}
 */
function getTrackStats(peerConnection, track, options) {
  options = options || {};

  if (typeof options.testForChrome !== 'undefined' || isChrome) {
    return chromeOrSafariGetTrackStats(peerConnection, track);
  }
  if (typeof options.testForFirefox  !== 'undefined' || isFirefox) {
    return firefoxGetTrackStats(peerConnection, track, options.isRemote);
  }
  if (typeof options.testForSafari  !== 'undefined' || isSafari) {
    if (typeof options.testForSafari  !== 'undefined' || getSdpFormat() === 'unified') {
      return chromeOrSafariGetTrackStats(peerConnection, track);
    }
    // NOTE(syerrapragada): getStats() is not supported on
    // Safari versions where plan-b is the SDP format
    // due to this bug: https://bugs.webkit.org/show_bug.cgi?id=192601
    return Promise.reject(new Error([
      'getStats() is not supported on this version of Safari',
      'due to this bug: https://bugs.webkit.org/show_bug.cgi?id=192601'
    ].join(' ')));
  }
  return Promise.reject(new Error('RTCPeerConnection#getStats() not supported'));
}

/**
 * Get the standardized statistics for a particular MediaStreamTrack in Chrome or Safari.
 * @param {RTCPeerConnection} peerConnection
 * @param {MediaStreamTrack} track
 * @returns {Promise.<Array<StandardizedTrackStatsReport>>}
 */
function chromeOrSafariGetTrackStats(peerConnection, track) {
  return new Promise(function(resolve, reject) {
    if (chromeMajorVersion && chromeMajorVersion < 67) {
      peerConnection.getStats(function(response) {
        resolve([standardizeChromeLegacyStats(response, track)]);
      }, null, reject);
      return;
    }
    peerConnection.getStats(track).then(function(response) {
      resolve(standardizeChromeOrSafariStats(response));
    }, reject);
  });
}

/**
 * Get the standardized statistics for a particular MediaStreamTrack in Firefox.
 * @param {RTCPeerConnection} peerConnection
 * @param {MediaStreamTrack} track
 * @param {boolean} isRemote
 * @returns {Promise.<Array<StandardizedTrackStatsReport>>}
 */
function firefoxGetTrackStats(peerConnection, track, isRemote) {
  return new Promise(function(resolve, reject) {
    peerConnection.getStats(track).then(function(response) {
      resolve([standardizeFirefoxStats(response, isRemote)]);
    }, reject);
  });
}

/**
 * Standardize the MediaStreamTrack's legacy statistics in Chrome.
 * @param {RTCStatsResponse} response
 * @param {MediaStreamTrack} track
 * @returns {StandardizedTrackStatsReport}
 */
function standardizeChromeLegacyStats(response, track) {
  var ssrcReport = response.result().find(function(report) {
    return report.type === 'ssrc' && report.stat('googTrackId') === track.id;
  });

  var standardizedStats = {};

  if (ssrcReport) {
    standardizedStats.timestamp = Math.round(Number(ssrcReport.timestamp));
    standardizedStats = ssrcReport.names().reduce(function(stats, name) {
      switch (name) {
        case 'googCodecName':
          stats.codecName = ssrcReport.stat(name);
          break;
        case 'googRtt':
          stats.roundTripTime = Number(ssrcReport.stat(name));
          break;
        case 'googJitterReceived':
          stats.jitter = Number(ssrcReport.stat(name));
          break;
        case 'googFrameWidthInput':
          stats.frameWidthInput = Number(ssrcReport.stat(name));
          break;
        case 'googFrameHeightInput':
          stats.frameHeightInput = Number(ssrcReport.stat(name));
          break;
        case 'googFrameWidthSent':
          stats.frameWidthSent = Number(ssrcReport.stat(name));
          break;
        case 'googFrameHeightSent':
          stats.frameHeightSent = Number(ssrcReport.stat(name));
          break;
        case 'googFrameWidthReceived':
          stats.frameWidthReceived = Number(ssrcReport.stat(name));
          break;
        case 'googFrameHeightReceived':
          stats.frameHeightReceived = Number(ssrcReport.stat(name));
          break;
        case 'googFrameRateInput':
          stats.frameRateInput = Number(ssrcReport.stat(name));
          break;
        case 'googFrameRateSent':
          stats.frameRateSent = Number(ssrcReport.stat(name));
          break;
        case 'googFrameRateReceived':
          stats.frameRateReceived = Number(ssrcReport.stat(name));
          break;
        case 'ssrc':
          stats[name] = ssrcReport.stat(name);
          break;
        case 'bytesReceived':
        case 'bytesSent':
        case 'packetsLost':
        case 'packetsReceived':
        case 'packetsSent':
        case 'audioInputLevel':
        case 'audioOutputLevel':
          stats[name] = Number(ssrcReport.stat(name));
          break;
      }

      return stats;
    }, standardizedStats);
  }

  return standardizedStats;
}

/**
 * Standardize the MediaStreamTrack's statistics in Chrome or Safari.
 * @param {RTCStatsResponse} response
 * @returns {Array<StandardizedTrackStatsReport>}
 */
function standardizeChromeOrSafariStats(response) {
  var inbound = null;

  // NOTE(mpatwardhan): We should expect more than one "outbound-rtp" stats for a
  // VP8 simulcast MediaStreamTrack.
  var outbound = [];

  var remoteInbound = null;
  var remoteOutbound = null;
  var track = null;
  var codec = null;

  response.forEach(function(stat) {
    switch (stat.type) {
      case 'inbound-rtp':
        inbound = stat;
        break;
      case 'outbound-rtp':
        outbound.push(stat);
        break;
      case 'track':
        track = stat;
        break;
      case 'codec':
        codec = stat;
        break;
      case 'remote-inbound-rtp':
        remoteInbound = stat;
        break;
      case 'remote-outbound-rtp':
        remoteOutbound = stat;
        break;
    }
  });

  var isRemote = track && track.remoteSource;
  var mainSources = isRemote ? [inbound] : outbound;
  var stats = [];
  var remoteSource = isRemote ? remoteOutbound : remoteInbound; // remote rtp stats

  mainSources.forEach(function(source) {
    var standardizedStats = {};
    var statSources = [
      source, // local rtp stats
      track,
      codec,
      remoteSource && remoteSource.ssrc === source.ssrc ? remoteSource : null, // remote rtp stats
    ];

    function getStatValue(name) {
      var sourceFound = statSources.find(function(statSource) {
        return statSource && typeof statSource[name] !== 'undefined';
      }) || null;

      return sourceFound ? sourceFound[name] : null;
    }

    var ssrc = getStatValue('ssrc');
    if (typeof ssrc === 'number') {
      standardizedStats.ssrc = String(ssrc);
    }

    var timestamp = getStatValue('timestamp');
    standardizedStats.timestamp = Math.round(timestamp);

    var mimeType = getStatValue('mimeType');
    if (typeof mimeType === 'string') {
      mimeType = mimeType.split('/');
      standardizedStats.codecName = mimeType[mimeType.length - 1];
    }

    var roundTripTime = getStatValue('roundTripTime');
    if (typeof roundTripTime === 'number') {
      standardizedStats.roundTripTime = Math.round(roundTripTime * 1000);
    }

    var jitter = getStatValue('jitter');
    if (typeof jitter === 'number') {
      standardizedStats.jitter = Math.round(jitter * 1000);
    }

    var frameWidth = getStatValue('frameWidth');
    if (typeof frameWidth === 'number') {
      if (isRemote) {
        standardizedStats.frameWidthReceived = frameWidth;
      } else {
        standardizedStats.frameWidthSent = frameWidth;
      }
    }

    var frameHeight = getStatValue('frameHeight');
    if (typeof frameHeight === 'number') {
      if (isRemote) {
        standardizedStats.frameHeightReceived = frameHeight;
      } else {
        standardizedStats.frameHeightSent = frameHeight;
      }
    }

    var framesPerSecond = getStatValue('framesPerSecond');
    if (typeof framesPerSecond === 'number') {
      standardizedStats.frameRateSent = framesPerSecond;
    }

    var bytesReceived = getStatValue('bytesReceived');
    if (typeof bytesReceived === 'number') {
      standardizedStats.bytesReceived = bytesReceived;
    }

    var bytesSent = getStatValue('bytesSent');
    if (typeof bytesSent === 'number') {
      standardizedStats.bytesSent = bytesSent;
    }

    var packetsLost = getStatValue('packetsLost');
    if (typeof packetsLost === 'number') {
      standardizedStats.packetsLost = packetsLost;
    }

    var packetsReceived = getStatValue('packetsReceived');
    if (typeof packetsReceived === 'number') {
      standardizedStats.packetsReceived = packetsReceived;
    }

    var packetsSent = getStatValue('packetsSent');
    if (typeof packetsSent === 'number') {
      standardizedStats.packetsSent = packetsSent;
    }

    var audioLevel = getStatValue('audioLevel');
    if (typeof audioLevel === 'number') {
      audioLevel = Math.round(audioLevel * CHROME_LEGACY_MAX_AUDIO_LEVEL);
      if (isRemote) {
        standardizedStats.audioOutputLevel = audioLevel;
      } else {
        standardizedStats.audioInputLevel = audioLevel;
      }
    }

    var totalPacketSendDalay = getStatValue('totalPacketSendDelay');
    if (typeof totalPacketSendDalay === 'number') {
      standardizedStats.totalPacketSendDelay = totalPacketSendDalay;
    }

    var totalEncodeTime = getStatValue('totalEncodeTime');
    if (typeof totalEncodeTime === 'number') {
      standardizedStats.totalEncodeTime = totalEncodeTime;
    }

    var framesEncoded = getStatValue('framesEncoded');
    if (typeof framesEncoded === 'number') {
      standardizedStats.framesEncoded = framesEncoded;
    }

    var estimatedPlayoutTimestamp = getStatValue('estimatedPlayoutTimestamp');
    if (typeof estimatedPlayoutTimestamp === 'number') {
      standardizedStats.estimatedPlayoutTimestamp = estimatedPlayoutTimestamp;
    }

    var totalDecodeTime = getStatValue('totalDecodeTime');
    if (typeof totalDecodeTime === 'number') {
      standardizedStats.totalDecodeTime = totalDecodeTime;
    }

    var framesDecoded = getStatValue('framesDecoded');
    if (typeof framesDecoded === 'number') {
      standardizedStats.framesDecoded = framesDecoded;
    }

    var jitterBufferDelay = getStatValue('jitterBufferDelay');
    if (typeof jitterBufferDelay === 'number') {
      standardizedStats.jitterBufferDelay = jitterBufferDelay;
    }

    var jitterBufferEmittedCount = getStatValue('jitterBufferEmittedCount');
    if (typeof jitterBufferEmittedCount === 'number') {
      standardizedStats.jitterBufferEmittedCount = jitterBufferEmittedCount;
    }

    stats.push(standardizedStats);
  });

  return stats;
}

/**
 * Standardize the MediaStreamTrack's statistics in Firefox.
 * @param {RTCStatsReport} response
 * @param {boolean} isRemote
 * @returns {StandardizedTrackStatsReport}
 */
function standardizeFirefoxStats(response, isRemote) {
  // NOTE(mroberts): If getStats is called on a closed RTCPeerConnection,
  // Firefox returns undefined instead of an RTCStatsReport. We workaround this
  // here. See the following bug for more details:
  //
  //   https://bugzilla.mozilla.org/show_bug.cgi?id=1377225
  //
  response = response || new Map();

  var inbound = null;
  var outbound = null;

  // NOTE(mmalavalli): Starting from Firefox 63, RTC{Inbound, Outbound}RTPStreamStats.isRemote
  // will be deprecated, followed by its removal in Firefox 66. Also, trying to
  // access members of the remote RTC{Inbound, Outbound}RTPStreamStats without
  // using RTCStatsReport.get(remoteId) will trigger console warnings. So, we
  // no longer depend on "isRemote", and we call RTCStatsReport.get(remoteId)
  // to access the remote RTC{Inbound, Outbound}RTPStreamStats.
  //
  // Source: https://blog.mozilla.org/webrtc/getstats-isremote-65/
  //
  response.forEach(function(stat) {
    if (stat.isRemote) {
      return;
    }
    switch (stat.type) {
      case 'inbound-rtp':
        inbound = stat;
        outbound = response.get(stat.remoteId);
        break;
      case 'outbound-rtp':
        outbound = stat;
        inbound = response.get(stat.remoteId);
        break;
    }
  });

  var first = isRemote ? inbound : outbound;
  var second = isRemote ? outbound : inbound;

  function getStatValue(name) {
    if (first && typeof first[name] !== 'undefined') {
      return first[name];
    }
    if (second && typeof second[name] !== 'undefined') {
      return second[name];
    }
    return null;
  }

  var standardizedStats = {};
  var timestamp = getStatValue('timestamp');
  standardizedStats.timestamp = Math.round(timestamp);

  var ssrc = getStatValue('ssrc');
  if (typeof ssrc === 'number') {
    standardizedStats.ssrc = String(ssrc);
  }

  var bytesSent = getStatValue('bytesSent');
  if (typeof bytesSent === 'number') {
    standardizedStats.bytesSent = bytesSent;
  }

  var packetsLost = getStatValue('packetsLost');
  if (typeof packetsLost === 'number') {
    standardizedStats.packetsLost = packetsLost;
  }

  var packetsSent = getStatValue('packetsSent');
  if (typeof packetsSent === 'number') {
    standardizedStats.packetsSent = packetsSent;
  }

  var roundTripTime = getStatValue('roundTripTime');
  if (typeof roundTripTime === 'number') {
    // roundTripTime is double - measured in seconds.
    // https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteinboundrtpstreamstats-roundtriptime
    // cover it to milliseconds (and make it integer)
    standardizedStats.roundTripTime = Math.round(roundTripTime * 1000);
  }

  var jitter = getStatValue('jitter');
  if (typeof jitter === 'number') {
    standardizedStats.jitter = Math.round(jitter * 1000);
  }

  var frameRateSent = getStatValue('framerateMean');
  if (typeof frameRateSent === 'number') {
    standardizedStats.frameRateSent = Math.round(frameRateSent);
  }

  var bytesReceived = getStatValue('bytesReceived');
  if (typeof bytesReceived === 'number') {
    standardizedStats.bytesReceived = bytesReceived;
  }

  var packetsReceived = getStatValue('packetsReceived');
  if (typeof packetsReceived === 'number') {
    standardizedStats.packetsReceived = packetsReceived;
  }

  var frameRateReceived = getStatValue('framerateMean');
  if (typeof frameRateReceived === 'number') {
    standardizedStats.frameRateReceived = Math.round(frameRateReceived);
  }

  var totalPacketSendDalay = getStatValue('totalPacketSendDelay');
  if (typeof totalPacketSendDalay === 'number') {
    standardizedStats.totalPacketSendDelay = totalPacketSendDalay;
  }

  var totalEncodeTime = getStatValue('totalEncodeTime');
  if (typeof totalEncodeTime === 'number') {
    standardizedStats.totalEncodeTime = totalEncodeTime;
  }

  var framesEncoded = getStatValue('framesEncoded');
  if (typeof framesEncoded === 'number') {
    standardizedStats.framesEncoded = framesEncoded;
  }

  var estimatedPlayoutTimestamp = getStatValue('estimatedPlayoutTimestamp');
  if (typeof estimatedPlayoutTimestamp === 'number') {
    standardizedStats.estimatedPlayoutTimestamp = estimatedPlayoutTimestamp;
  }

  var totalDecodeTime = getStatValue('totalDecodeTime');
  if (typeof totalDecodeTime === 'number') {
    standardizedStats.totalDecodeTime = totalDecodeTime;
  }

  var framesDecoded = getStatValue('framesDecoded');
  if (typeof framesDecoded === 'number') {
    standardizedStats.framesDecoded = framesDecoded;
  }

  var jitterBufferDelay = getStatValue('jitterBufferDelay');
  if (typeof jitterBufferDelay === 'number') {
    standardizedStats.jitterBufferDelay = jitterBufferDelay;
  }

  var jitterBufferEmittedCount = getStatValue('jitterBufferEmittedCount');
  if (typeof jitterBufferEmittedCount === 'number') {
    standardizedStats.jitterBufferEmittedCount = jitterBufferEmittedCount;
  }

  return standardizedStats;
}

/**
 * Standardized RTCIceCandidate statistics.
 * @typedef {object} StandardizedIceCandidateStatsReport
 * @property {'host'|'prflx'|'relay'|'srflx'} candidateType
 * @property {string} ip
 * @property {number} port
 * @property {number} priority
 * @property {'tcp'|'udp'} protocol
 * @property {string} url
 */

/**
 * Standardized local RTCIceCandidate statistics.
 * @typedef {StandardizedIceCandidateStatsReport} StandardizedLocalIceCandidateStatsReport
 * @property {boolean} [deleted=false]
 * @property {'tcp'|'tls'|'udp'} relayProtocol
 */

/**
 * Standardized active RTCIceCandidate pair statistics.
 * @typedef {object} StandardizedActiveIceCandidatePairStatsReport
 * @property {number} availableIncomingBitrate
 * @property {number} availableOutgoingBitrate
 * @property {number} bytesReceived
 * @property {number} bytesSent
 * @property {number} consentRequestsSent
 * @property {number} currentRoundTripTime
 * @property {number} lastPacketReceivedTimestamp
 * @property {number} lastPacketSentTimestamp
 * @property {StandardizedLocalIceCandidateStatsReport} localCandidate
 * @property {boolean} nominated
 * @property {number} priority
 * @property {boolean} readable
 * @property {StandardizedIceCandidateStatsReport} remoteCandidate
 * @property {number} requestsReceived
 * @property {number} requestsSent
 * @property {number} responsesReceived
 * @property {number} responsesSent
 * @property {number} retransmissionsReceived
 * @property {number} retransmissionsSent
 * @property {'frozen'|'waiting'|'in-progress'|'failed'|'succeeded'} state
 * @property {number} totalRoundTripTime
 * @property {string} transportId
 * @property {boolean} writable
 */

/**
 * Standardized {@link RTCPeerConnection} statistics.
 * @typedef {Object} StandardizedStatsResponse
 * @property {StandardizedActiveIceCandidatePairStatsReport} activeIceCandidatePair - Stats for active ICE candidate pair
 * @property Array<StandardizedTrackStatsReport> localAudioTrackStats - Stats for local audio MediaStreamTracks
 * @property Array<StandardizedTrackStatsReport> localVideoTrackStats - Stats for local video MediaStreamTracks
 * @property Array<StandardizedTrackStatsReport> remoteAudioTrackStats - Stats for remote audio MediaStreamTracks
 * @property Array<StandardizedTrackStatsReport> remoteVideoTrackStats - Stats for remote video MediaStreamTracks
 */

/**
 * Standardized MediaStreamTrack statistics.
 * @typedef {Object} StandardizedTrackStatsReport
 * @property {string} trackId - MediaStreamTrack ID
 * @property {string} ssrc - SSRC of the MediaStreamTrack
 * @property {number} timestamp - The Unix timestamp in milliseconds
 * @property {string} [codecName] - Name of the codec used to encode the MediaStreamTrack's media
 * @property {number} [roundTripTime] - Round trip time in milliseconds
 * @property {number} [jitter] - Jitter in milliseconds
 * @property {number} [frameWidthInput] - Width in pixels of the local video MediaStreamTrack's captured frame
 * @property {number} [frameHeightInput] - Height in pixels of the local video MediaStreamTrack's captured frame
 * @property {number} [frameWidthSent] - Width in pixels of the local video MediaStreamTrack's encoded frame
 * @property {number} [frameHeightSent] - Height in pixels of the local video MediaStreamTrack's encoded frame
 * @property {number} [frameWidthReceived] - Width in pixels of the remote video MediaStreamTrack's received frame
 * @property {number} [frameHeightReceived] - Height in pixels of the remote video MediaStreamTrack's received frame
 * @property {number} [frameRateInput] - Captured frames per second of the local video MediaStreamTrack
 * @property {number} [frameRateSent] - Frames per second of the local video MediaStreamTrack's encoded video
 * @property {number} [frameRateReceived] - Frames per second of the remote video MediaStreamTrack's received video
 * @property {number} [bytesReceived] - Number of bytes of the remote MediaStreamTrack's media received
 * @property {number} [bytesSent] - Number of bytes of the local MediaStreamTrack's media sent
 * @property {number} [packetsLost] - Number of packets of the MediaStreamTrack's media lost
 * @property {number} [packetsReceived] - Number of packets of the remote MediaStreamTrack's media received
 * @property {number} [packetsSent] - Number of packets of the local MediaStreamTrack's media sent
 * @property {number} [totalPacketSendDelay] - The total number of seconds that the local MediaStreamTrack's packets
 *  have spent buffered locally before being sent over the network
 * @property {number} [totalEncodeTime] - The total number of seconds spent on encoding the local MediaStreamTrack's frames
 * @property {number} [framesEncoded] - The total number of frames of the local MediaStreamTrack that have been encoded sor far
 * @property {number} [estimatedPlayoutTimestamp] - The estimated playout time of the remote MediaStreamTrack
 * @property {number} [totalDecodeTime] - The total number of seconds spent on decoding the remote MediaStreamTrack's frames
 * @property {number} [framesDecoded] - The total number of frames of the remote MediaStreamTrack that have been decoded sor far
 * @property {number} [jitterBufferDelay] - The sum of the time, in seconds, each audio sample or a video frame of the remote
 *   MediaStreamTrack takes from the time the first packet is received by the jitter buffer to the time it exits the jitter buffer
 * @property {number} [jitterBufferEmittedCount] - The total number of audio samples or video frames that have come out of the jitter buffer
 * @property {AudioLevel} [audioInputLevel] - The {@link AudioLevel} of the local audio MediaStreamTrack
 * @property {AudioLevel} [audioOutputLevel] - The {@link AudioLevel} of the remote video MediaStreamTrack
 */

module.exports = getStats;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/getusermedia.js":
/*!***********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/getusermedia.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals navigator */


/**
 * This function is very similar to <code>navigator.mediaDevices.getUserMedia</code>
 * except that if no MediaStreamConstraints are provided, then bot audio and video
 * are requested.
 * @function getUserMedia
 * @param {MediaStreamConstraints} [constraints={audio:true,video:true}] - the
 *   MediaStreamConstraints object specifying what kind of MediaStream to
 *   request from the browser (by default both audio and video)
 * @returns Promise<MediaStream>
 */
function getUserMedia(constraints) {
  if (typeof navigator === 'object'
    && typeof navigator.mediaDevices === 'object'
    && typeof navigator.mediaDevices.getUserMedia === 'function') {
    constraints = constraints || { audio: true, video: true };
    return navigator.mediaDevices.getUserMedia(constraints);
  }
  return Promise.reject(new Error('getUserMedia is not supported'));
}

module.exports = getUserMedia;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/index.js":
/*!****************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var WebRTC = {};

Object.defineProperties(WebRTC, {
  getStats: {
    enumerable: true,
    value: __webpack_require__(/*! ./getstats */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/getstats.js")
  },
  getUserMedia: {
    enumerable: true,
    value: __webpack_require__(/*! ./getusermedia */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/getusermedia.js")
  },
  MediaStream: {
    enumerable: true,
    value: __webpack_require__(/*! ./mediastream */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/mediastream.js")
  },
  MediaStreamTrack: {
    enumerable: true,
    value: __webpack_require__(/*! ./mediastreamtrack */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/mediastreamtrack.js")
  },
  RTCIceCandidate: {
    enumerable: true,
    value: __webpack_require__(/*! ./rtcicecandidate */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcicecandidate.js")
  },
  RTCPeerConnection: {
    enumerable: true,
    value: __webpack_require__(/*! ./rtcpeerconnection */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcpeerconnection/index.js")
  },
  RTCSessionDescription: {
    enumerable: true,
    value: __webpack_require__(/*! ./rtcsessiondescription */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcsessiondescription/index.js")
  },
  version: {
    enumerable: true,
    value: __webpack_require__(/*! ../package.json */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/package.json").version
  }
});

module.exports = WebRTC;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/mediastream.js":
/*!**********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/mediastream.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals MediaStream */


if (typeof MediaStream === 'function') {
  module.exports = MediaStream;
} else {
  module.exports = function MediaStream() {
    throw new Error('MediaStream is not supported');
  };
}


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/mediastreamtrack.js":
/*!***************************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/mediastreamtrack.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global MediaStreamTrack */


if (typeof MediaStreamTrack === 'function') {
  module.exports = MediaStreamTrack;
} else {
  module.exports = function MediaStreamTrack() {
    throw new Error('MediaStreamTrack is not supported');
  };
}


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcicecandidate.js":
/*!**************************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcicecandidate.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global RTCIceCandidate */


if (typeof RTCIceCandidate === 'function') {
  module.exports = RTCIceCandidate;
} else {
  module.exports = function RTCIceCandidate() {
    throw new Error('RTCIceCandidate is not supported');
  };
}


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcpeerconnection/chrome.js":
/*!***********************************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcpeerconnection/chrome.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCDataChannel, RTCPeerConnection, RTCSessionDescription */


var ChromeRTCSessionDescription = __webpack_require__(/*! ../rtcsessiondescription/chrome */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcsessiondescription/chrome.js");
var EventTarget = __webpack_require__(/*! ../util/eventtarget */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/eventtarget.js");
var inherits = __webpack_require__(/*! util */ "./node_modules/util/util.js").inherits;
var Latch = __webpack_require__(/*! ../util/latch */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/latch.js");
var MediaStream = __webpack_require__(/*! ../mediastream */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/mediastream.js");
var RTCRtpSenderShim = __webpack_require__(/*! ../rtcrtpsender */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcrtpsender.js");
var sdpUtils = __webpack_require__(/*! ../util/sdp */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/sdp.js");
var util = __webpack_require__(/*! ../util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js");
var isIOSChrome = __webpack_require__(/*! ../util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").isIOSChrome;

var isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified';

// NOTE(mroberts): This class wraps Chrome's RTCPeerConnection implementation.
// It provides some functionality not currently present in Chrome, namely the
// abilities to
//
//   1. Rollback, per the workaround suggested here:
//      https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3
//
//   2. Listen for track events, per the adapter.js workaround.
//
//   3. Set iceTransportPolicy.
//
function ChromeRTCPeerConnection(configuration, constraints) {
  if (!(this instanceof ChromeRTCPeerConnection)) {
    return new ChromeRTCPeerConnection(configuration, constraints);
  }

  EventTarget.call(this);

  configuration = configuration || {};
  var newConfiguration = Object.assign(configuration.iceTransportPolicy
    ? { iceTransports: configuration.iceTransportPolicy }
    : {}, configuration);

  util.interceptEvent(this, 'datachannel');
  util.interceptEvent(this, 'signalingstatechange');

  var sdpFormat = sdpUtils.getSdpFormat(newConfiguration.sdpSemantics);
  var peerConnection = new RTCPeerConnection(newConfiguration, constraints);

  Object.defineProperties(this, {
    _appliedTracksToSSRCs: {
      value: new Map(),
      writable: true
    },
    _localStream: {
      value: new MediaStream()
    },
    _peerConnection: {
      value: peerConnection
    },
    _pendingLocalOffer: {
      value: null,
      writable: true
    },
    _pendingRemoteOffer: {
      value: null,
      writable: true
    },
    _rolledBackTracksToSSRCs: {
      value: new Map(),
      writable: true
    },
    _sdpFormat: {
      value: sdpFormat
    },
    _senders: {
      value: new Map()
    },
    _signalingStateLatch: {
      value: new Latch()
    },
    _tracksToSSRCs: {
      value: new Map(),
      writable: true
    },
    localDescription: {
      enumerable: true,
      get: function() {
        return this._pendingLocalOffer ? this._pendingLocalOffer : peerConnection.localDescription;
      }
    },
    remoteDescription: {
      enumerable: true,
      get: function() {
        return this._pendingRemoteOffer ? this._pendingRemoteOffer : peerConnection.remoteDescription;
      }
    },
    signalingState: {
      enumerable: true,
      get: function() {
        if (this._pendingLocalOffer) {
          return 'have-local-offer';
        } else if (this._pendingRemoteOffer) {
          return 'have-remote-offer';
        }
        return peerConnection.signalingState;
      }
    }
  });

  var self = this;

  peerConnection.addEventListener('datachannel', function ondatachannel(event) {
    shimDataChannel(event.channel);
    self.dispatchEvent(event);
  });

  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {
    if (peerConnection.signalingState === 'stable') {
      self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);
    }
    if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {
      self.dispatchEvent.apply(self, arguments);
    }
  });

  peerConnection.ontrack = function ontrack() {
    // NOTE(mroberts): adapter.js's "track" event shim only kicks off if we set
    // the ontrack property of the RTCPeerConnection.
  };

  if (typeof RTCPeerConnection.prototype.addTrack !== 'function') {
    peerConnection.addStream(this._localStream);
  }
  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);
}

inherits(ChromeRTCPeerConnection, EventTarget);

if (typeof RTCPeerConnection.prototype.addTrack !== 'function') {
  // NOTE(mmalavalli): This shim supports our limited case of adding
  // all MediaStreamTracks to one MediaStream. It has been implemented this
  // keeping in mind that this is to be maintained only until "addTrack" is
  // supported natively in Chrome.
  ChromeRTCPeerConnection.prototype.addTrack = function addTrack() {
    var args = [].slice.call(arguments);
    var track = args[0];
    if (this._peerConnection.signalingState === 'closed') {
      throw new Error('Cannot add MediaStreamTrack [' + track.id + ', '
        + track.kind + ']: RTCPeerConnection is closed');
    }

    var sender = this._senders.get(track);
    if (sender && sender.track) {
      throw new Error('Cannot add MediaStreamTrack [' + track.id + ', '
        + track.kind + ']: RTCPeerConnection already has it');
    }
    this._peerConnection.removeStream(this._localStream);
    this._localStream.addTrack(track);
    this._peerConnection.addStream(this._localStream);

    sender = new RTCRtpSenderShim(track);
    this._senders.set(track, sender);
    return sender;
  };

  // NOTE(mmalavalli): This shim supports our limited case of removing
  // MediaStreamTracks from one MediaStream. It has been implemented this
  // keeping in mind that this is to be maintained only until "removeTrack" is
  // supported natively in Chrome.
  ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    if (this._peerConnection.signalingState === 'closed') {
      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');
    }

    var track = sender.track;
    if (!track) {
      return;
    }
    sender = this._senders.get(track);
    if (sender && sender.track) {
      sender.track = null;
      this._peerConnection.removeStream(this._localStream);
      this._localStream.removeTrack(track);
      this._peerConnection.addStream(this._localStream);
    }
  };

  ChromeRTCPeerConnection.prototype.getSenders = function getSenders() {
    return Array.from(this._senders.values());
  };
} else {
  ChromeRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    if (this._peerConnection.signalingState === 'closed') {
      throw new Error('Cannot remove MediaStreamTrack: RTCPeerConnection is closed');
    }
    try {
      this._peerConnection.removeTrack(sender);
    } catch (e) {
      // NOTE(mhuynh): Do nothing. In Chrome, will throw if a 'sender was not
      // created by this peer connection'. This behavior does not seem to be
      // spec compliant, so a temporary shim is introduced. A bug has been filed,
      // and is tracked here:
      // https://bugs.chromium.org/p/chromium/issues/detail?id=860853
    }
  };
}

ChromeRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {
  var args = [].slice.call(arguments);
  var promise;
  var self = this;

  if (this.signalingState === 'have-remote-offer') {
    // NOTE(mroberts): Because the ChromeRTCPeerConnection simulates the
    // "have-remote-offer" signalingStates, we only want to invoke the true
    // addIceCandidates method when the remote description has been applied.
    promise = this._signalingStateLatch.when('low').then(function signalingStatesResolved() {
      return self._peerConnection.addIceCandidate(candidate);
    });
  } else {
    promise = this._peerConnection.addIceCandidate(candidate);
  }

  return args.length > 1
    ? util.legacyPromise(promise, args[1], args[2])
    : promise;
};

// NOTE(mroberts): The WebRTC spec does not specify that close should throw an
// Error; however, in Chrome it does. We workaround this by checking the
// signalingState manually.
ChromeRTCPeerConnection.prototype.close = function close() {
  if (this.signalingState !== 'closed') {
    this._pendingLocalOffer = null;
    this._pendingRemoteOffer = null;
    this._peerConnection.close();
  }
};

// NOTE(mroberts): Because we workaround Chrome's lack of rollback support by
// "faking" setRemoteDescription, we cannot create an answer until we actually
// apply the remote description. This means, once you call createAnswer, you
// can no longer rollback. This is acceptable for our use case because we will
// apply the newly-created answer almost immediately; however, this may be
// unacceptable for other use cases.
ChromeRTCPeerConnection.prototype.createAnswer = function createAnswer() {
  var args = [].slice.call(arguments);
  var promise;
  var self = this;

  if (this._pendingRemoteOffer) {
    promise = this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {
      // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection
      // and the underlying RTCPeerConnection implementation have converged. We
      // can unblock any pending calls to addIceCandidate now.
      self._signalingStateLatch.lower();
      return self._peerConnection.createAnswer();
    }).then(function createAnswerSucceeded(answer) {
      self._pendingRemoteOffer = null;

      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no
      // longer need to retain the rolled back tracks to SSRCs Map.
      self._rolledBackTracksToSSRCs.clear();

      return new ChromeRTCSessionDescription({
        type: 'answer',
        sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)
      });
    }, function setRemoteDescriptionOrCreateAnswerFailed(error) {
      self._pendingRemoteOffer = null;
      throw error;
    });
  } else {
    promise = this._peerConnection.createAnswer().then(function(answer) {
      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no
      // longer need to retain the rolled back tracks to SSRCs Map.
      self._rolledBackTracksToSSRCs.clear();

      return new ChromeRTCSessionDescription({
        type: 'answer',
        sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, answer.sdp)
      });
    });
  }

  return args.length > 1
    ? util.legacyPromise(promise, args[0], args[1])
    : promise;
};

ChromeRTCPeerConnection.prototype.createOffer = function createOffer() {
  var args = [].slice.call(arguments);
  var options = (args.length > 1 ? args[2] : args[0]) || {};
  var self = this;

  if (isIOSChrome()) {
    // NOTE (joma): From SafariRTCPeerConnection in order to support iOS Chrome.
    if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {
      delete options.offerToReceiveAudio;
      try {
        this._audioTransceiver = isUnifiedPlan
          ? this.addTransceiver('audio', { direction: 'recvonly' })
          : this.addTransceiver('audio');
      } catch (e) {
        return Promise.reject(e);
      }
    }

    if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {
      delete options.offerToReceiveVideo;
      try {
        this._videoTransceiver = isUnifiedPlan
          ? this.addTransceiver('video', { direction: 'recvonly' })
          : this.addTransceiver('video');
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }

  var promise = this._peerConnection.createOffer(options).then(function(offer) {
    // NOTE(mmalavalli): If createOffer() is called immediately after rolling back, then we no
    // longer need to retain the rolled back tracks to SSRCs Map.
    self._rolledBackTracksToSSRCs.clear();

    return new ChromeRTCSessionDescription({
      type: offer.type,
      sdp: updateTrackIdsToSSRCs(self._sdpFormat, self._tracksToSSRCs, offer.sdp)
    });
  });

  return args.length > 1
    ? util.legacyPromise(promise, args[0], args[1])
    : promise;
};

ChromeRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {
  dataChannelDict = shimDataChannelInit(dataChannelDict);
  var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);
  shimDataChannel(dataChannel);
  return dataChannel;
};

ChromeRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
  var args = [].slice.call(arguments);
  var description = args[0];

  // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,
  // then we need to restore the rolled back tracks to SSRCs Map.
  if (this._rolledBackTracksToSSRCs.size > 0) {
    this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);
    this._rolledBackTracksToSSRCs.clear();
  }

  var promise = setDescription(this, true, description);
  return args.length > 1
    ? util.legacyPromise(promise, args[1], args[2])
    : promise;
};

ChromeRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
  var args = [].slice.call(arguments);
  var description = args[0];

  // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,
  // then we no longer need to retain the rolled back tracks to SSRCs Map.
  this._rolledBackTracksToSSRCs.clear();

  var promise = setDescription(this, false, description);
  return args.length > 1
    ? util.legacyPromise(promise, args[1], args[2])
    : promise;
};

util.delegateMethods(
  RTCPeerConnection.prototype,
  ChromeRTCPeerConnection.prototype,
  '_peerConnection');

// NOTE(mroberts): We workaround Chrome's lack of rollback support, per the
// workaround suggested here: https://bugs.chromium.org/p/webrtc/issues/detail?id=5738#c3
// Namely, we "fake" setting the local or remote description and instead buffer
// it. If we receive or create an answer, then we will actually apply the
// description. Until we receive or create an answer, we will be able to
// "rollback" by simply discarding the buffer description.
function setDescription(peerConnection, local, description) {
  function setPendingLocalOffer(offer) {
    if (local) {
      peerConnection._pendingLocalOffer = offer;
    } else {
      peerConnection._pendingRemoteOffer = offer;
    }
  }

  function clearPendingLocalOffer() {
    if (local) {
      peerConnection._pendingLocalOffer = null;
    } else {
      peerConnection._pendingRemoteOffer = null;
    }
  }

  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;
  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;
  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';
  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';
  var promise;

  if (!local && pendingRemoteOffer && description.type === 'answer') {
    promise = setRemoteAnswer(peerConnection, description);
  } else if (description.type === 'offer') {
    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {
      // NOTE(mroberts): Error message copied from Firefox.
      return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') +
        ' offer in state ' + peerConnection.signalingState));
    }

    // We need to save this local offer in case of a rollback. We also need to
    // check to see if the signalingState between the ChromeRTCPeerConnection
    // and the underlying RTCPeerConnection implementation are about to diverge.
    // If so, we need to ensure subsequent calls to addIceCandidate will block.
    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {
      peerConnection._signalingStateLatch.raise();
    }
    var previousSignalingState = peerConnection.signalingState;
    setPendingLocalOffer(unwrap(description));
    promise = Promise.resolve();

    // Only dispatch a signalingstatechange event if we transitioned.
    if (peerConnection.signalingState !== previousSignalingState) {
      promise.then(function dispatchSignalingStateChangeEvent() {
        peerConnection.dispatchEvent(new Event('signalingstatechange'));
      });
    }

  } else if (description.type === 'rollback') {
    if (peerConnection.signalingState !== intermediateState) {
      // NOTE(mroberts): Error message copied from Firefox.
      promise = Promise.reject(new Error('Cannot rollback ' +
        (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));
    } else {
      // Reset the pending offer.
      clearPendingLocalOffer();

      // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case
      // setLocalDescription() is called immediately after a rollback (without calling
      // createOffer() or createAnswer()), in which case this roll back is not due to a
      // glare scenario and this Map should be restored.
      peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);
      peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);

      promise = Promise.resolve();
      promise.then(function dispatchSignalingStateChangeEvent() {
        peerConnection.dispatchEvent(new Event('signalingstatechange'));
      });
    }
  }

  return promise || peerConnection._peerConnection[setLocalDescription](unwrap(description));
}

function setRemoteAnswer(peerConnection, answer) {
  // Apply the pending local offer.
  var pendingLocalOffer = peerConnection._pendingLocalOffer;
  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {
    peerConnection._pendingLocalOffer = null;
    return peerConnection.setRemoteDescription(answer);
  }).then(function setRemoteAnswerSucceeded() {
    // NOTE(mroberts): The signalingStates between the ChromeRTCPeerConnection
    // and the underlying RTCPeerConnection implementation have converged. We
    // can unblock any pending calls to addIceCandidate now.
    peerConnection._signalingStateLatch.lower();
  });
}

/**
 * Whether a ChromeRTCPeerConnection has any RTCRtpReceivers(s) for the given
 * MediaStreamTrack kind.
 * @param {ChromeRTCPeerConnection} peerConnection
 * @param {'audio' | 'video'} kind
 * @returns {boolean}
 */
 function hasReceiversForTracksOfKind(peerConnection, kind) {
  return !!peerConnection.getTransceivers().find(function(transceiver) {
    return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;
  });
}

function unwrap(description) {
  if (description instanceof ChromeRTCSessionDescription) {
    if (description._description) {
      return description._description;
    }
  }
  return new RTCSessionDescription(description);
}

/**
 * Check whether or not we need to apply our maxPacketLifeTime shim. We are
 * pretty conservative: we'll only apply it if the legacy maxRetransmitTime
 * property is available _and_ the standard maxPacketLifeTime property is _not_
 * available (the thinking being that Chrome will land the standards-compliant
 * property).
 * @returns {boolean}
 */
function needsMaxPacketLifeTimeShim() {
  return 'maxRetransmitTime' in RTCDataChannel.prototype
    && !('maxPacketLifeTime' in RTCDataChannel.prototype);
}

/**
 * Shim an RTCDataChannelInit dictionary (if necessary). This function returns
 * a copy of the original RTCDataChannelInit.
 * @param {RTCDataChannelInit} dataChannelDict
 * @returns {RTCDataChannelInit}
 */
function shimDataChannelInit(dataChannelDict) {
  dataChannelDict = Object.assign({}, dataChannelDict);
  if (needsMaxPacketLifeTimeShim() && 'maxPacketLifeTime' in dataChannelDict) {
    dataChannelDict.maxRetransmitTime = dataChannelDict.maxPacketLifeTime;
  }
  return dataChannelDict;
}

/**
 * Shim an RTCDataChannel (if necessary). This function mutates the
 * RTCDataChannel.
 * @param {RTCDataChannel} dataChannel
 * @returns {RTCDataChannel}
 */
function shimDataChannel(dataChannel) {
  Object.defineProperty(dataChannel, 'maxRetransmits', {
    value: dataChannel.maxRetransmits === 65535
      ? null
      : dataChannel.maxRetransmits
  });
  if (needsMaxPacketLifeTimeShim()) {
    // NOTE(mroberts): We can rename `maxRetransmitTime` to `maxPacketLifeTime`.
    //
    //   https://bugs.chromium.org/p/chromium/issues/detail?id=696681
    //
    Object.defineProperty(dataChannel, 'maxPacketLifeTime', {
      value: dataChannel.maxRetransmitTime === 65535
        ? null
        : dataChannel.maxRetransmitTime
    });
  }
  return dataChannel;
}

/**
 * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both
 * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method
 * ensures that SSRCs never change once announced.
 * @param {'planb'|'unified'} sdpFormat
 * @param {Map<string, Set<string>>} tracksToSSRCs
 * @param {string} sdp - an SDP whose format is determined by `sdpSemantics`
 * @returns {string} updatedSdp - updated SDP
 */
function updateTrackIdsToSSRCs(sdpFormat, tracksToSSRCs, sdp) {
  return sdpFormat === 'unified'
    ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs(tracksToSSRCs, sdp)
    : sdpUtils.updatePlanBTrackIdsToSSRCs(tracksToSSRCs, sdp);
}

module.exports = ChromeRTCPeerConnection;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcpeerconnection/firefox.js":
/*!************************************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcpeerconnection/firefox.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCPeerConnection */


var EventTarget = __webpack_require__(/*! ../util/eventtarget */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/eventtarget.js");
var FirefoxRTCSessionDescription = __webpack_require__(/*! ../rtcsessiondescription/firefox */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcsessiondescription/firefox.js");
var inherits = __webpack_require__(/*! util */ "./node_modules/util/util.js").inherits;
var updateTracksToSSRCs = __webpack_require__(/*! ../util/sdp */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/sdp.js").updateUnifiedPlanTrackIdsToSSRCs;
var util = __webpack_require__(/*! ../util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js");

// NOTE(mroberts): This is a short-lived workaround. Checking the user agent
// string might not fix every affected Firefox instance, but it should be good
// enough for this bug.
var needsWorkaroundForBug1480277 = typeof navigator === 'object'
  && navigator.userAgent
  && (navigator.userAgent.match(/Firefox\/61/) || navigator.userAgent.match(/Firefox\/62/));

// NOTE(mroberts): This class wraps Firefox's RTCPeerConnection implementation.
// It provides some functionality not currently present in Firefox, namely the
// abilities to
//
//   1. Call setLocalDescription and setRemoteDescription with new offers in
//      signalingStates "have-local-offer" and "have-remote-offer",
//      respectively.
//
//   2. The ability to call createOffer in signalingState "have-local-offer".
//
// Both of these are implemented using rollbacks to workaround the following
// bug:
//
//   https://bugzilla.mozilla.org/show_bug.cgi?id=1072388
//
// We also provide a workaround for a bug where Firefox may change the
// previously-negotiated DTLS role in an answer, which breaks Chrome:
//
//     https://bugzilla.mozilla.org/show_bug.cgi?id=1240897
//
function FirefoxRTCPeerConnection(configuration) {
  if (!(this instanceof FirefoxRTCPeerConnection)) {
    return new FirefoxRTCPeerConnection(configuration);
  }

  EventTarget.call(this);

  util.interceptEvent(this, 'signalingstatechange');

  /* eslint new-cap:0 */
  var peerConnection = new RTCPeerConnection(configuration);

  Object.defineProperties(this, {
    _initiallyNegotiatedDtlsRole: {
      value: null,
      writable: true
    },
    _isClosed: {
      value: false,
      writable: true
    },
    _peerConnection: {
      value: peerConnection
    },
    _rollingBack: {
      value: false,
      writable: true
    },
    _tracksToSSRCs: {
      value: new Map()
    },
    iceGatheringState: {
      enumerable: true,
      get: function() {
        return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;
      }
    },
    localDescription: {
      enumerable: true,
      get: function() {
        return overwriteWithInitiallyNegotiatedDtlsRole(this._peerConnection.localDescription, this._initiallyNegotiatedDtlsRole);
      }
    },
    signalingState: {
      enumerable: true,
      get: function() {
        return this._isClosed ? 'closed' : this._peerConnection.signalingState;
      }
    }
  });

  var self = this;
  var previousSignalingState;

  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {
    if (!self._rollingBack && self.signalingState !== previousSignalingState) {
      previousSignalingState = self.signalingState;

      // NOTE(mmalavalli): In Firefox, 'signalingstatechange' event is
      // triggered synchronously in the same tick after
      // RTCPeerConnection#close() is called. So we mimic Chrome's behavior
      // by triggering 'signalingstatechange' on the next tick.
      var dispatchEventToSelf = self.dispatchEvent.apply.bind(self.dispatchEvent, self, arguments);
      if (self._isClosed) {
        setTimeout(dispatchEventToSelf);
      } else {
        dispatchEventToSelf();
      }
    }
  });

  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);
}

inherits(FirefoxRTCPeerConnection, EventTarget);

// NOTE(mmalavalli): Firefox throws a TypeError when the PeerConnection's
// prototype's "peerIdentity" property is accessed. In order to overcome
// this, we ignore this property while delegating methods.
// Reference: https://bugzilla.mozilla.org/show_bug.cgi?id=1363815
Object.defineProperty(FirefoxRTCPeerConnection.prototype, 'peerIdentity', {
  enumerable: true,
  value: Promise.resolve({
    idp: '',
    name: ''
  })
});

if (needsWorkaroundForBug1480277) {
  FirefoxRTCPeerConnection.prototype.addTrack = function addTrack() {
    var track = arguments[0];
    var sender = this._peerConnection.addTrack.apply(this._peerConnection, arguments);
    sender.replaceTrack(track);
    return sender;
  };
}

FirefoxRTCPeerConnection.prototype.createAnswer = function createAnswer() {
  var args = [].slice.call(arguments);
  var promise;
  var self = this;

  promise = this._peerConnection.createAnswer().then(function createAnswerSucceeded(answer) {
    saveInitiallyNegotiatedDtlsRole(self, answer);
    return overwriteWithInitiallyNegotiatedDtlsRole(answer, self._initiallyNegotiatedDtlsRole);
  });

  return typeof args[0] === 'function'
    ? util.legacyPromise(promise, args[0], args[1])
    : promise;
};

// NOTE(mroberts): The WebRTC spec allows you to call createOffer from any
// signalingState other than "closed"; however, Firefox has not yet implemented
// this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388). We workaround
// this by rolling back if we are in state "have-local-offer" or
// "have-remote-offer". This is acceptable for our use case because we will
// apply the newly-created offer almost immediately; however, this may be
// unacceptable for other use cases.
FirefoxRTCPeerConnection.prototype.createOffer = function createOffer() {
  var args = [].slice.call(arguments);
  var options = (args.length > 1 ? args[2] : args[0]) || {};
  var promise;
  var self = this;

  if (this.signalingState === 'have-local-offer' ||
      this.signalingState === 'have-remote-offer') {
    var local = this.signalingState === 'have-local-offer';
    promise = rollback(this, local, function rollbackSucceeded() {
      return self.createOffer(options);
    });
  } else {
    promise = self._peerConnection.createOffer(options);
  }

  promise = promise.then(function(offer) {
    return new FirefoxRTCSessionDescription({
      type: offer.type,
      sdp: updateTracksToSSRCs(self._tracksToSSRCs, offer.sdp)
    });
  });

  return args.length > 1
    ? util.legacyPromise(promise, args[0], args[1])
    : promise;
};

// NOTE(mroberts): While Firefox will reject the Promise returned by
// setLocalDescription when called from signalingState "have-local-offer" with
// an answer, it still updates the .localDescription property. We workaround
// this by explicitly handling this case.
FirefoxRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
  var args = [].slice.call(arguments);
  var description = args[0];
  var promise;

  if (description && description.type === 'answer' && this.signalingState === 'have-local-offer') {
    promise = Promise.reject(new Error('Cannot set local answer in state have-local-offer'));
  }

  if (promise) {
    return args.length > 1
      ? util.legacyPromise(promise, args[1], args[2])
      : promise;
  }

  return this._peerConnection.setLocalDescription.apply(this._peerConnection, args);
};

// NOTE(mroberts): The WebRTC spec allows you to call setRemoteDescription with
// an offer multiple times in signalingState "have-remote-offer"; however,
// Firefox has not yet implemented this (https://bugzilla.mozilla.org/show_bug.cgi?id=1072388).
// We workaround this by rolling back if we are in state "have-remote-offer".
// This is acceptable for our use case; however, this may be unacceptable for
// other use cases.
//
// While Firefox will reject the Promise returned by setRemoteDescription when
// called from signalingState "have-remote-offer" with an answer, it sill
// updates the .remoteDescription property. We workaround this by explicitly
// handling this case.
FirefoxRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
  var args = [].slice.call(arguments);
  var description = args[0];
  var promise;
  var self = this;

  if (description && this.signalingState === 'have-remote-offer') {
    if (description.type === 'answer') {
      promise = Promise.reject(new Error('Cannot set remote answer in state have-remote-offer'));
    } else if (description.type === 'offer') {
      promise = rollback(this, false, function rollbackSucceeded() {
        return self._peerConnection.setRemoteDescription(description);
      });
    }
  }

  if (!promise) {
    promise = this._peerConnection.setRemoteDescription(description);
  }

  promise = promise.then(function setRemoteDescriptionSucceeded() {
    saveInitiallyNegotiatedDtlsRole(self, description, true);
  });

  return args.length > 1
    ? util.legacyPromise(promise, args[1], args[2])
    : promise;
};

// NOTE(mroberts): The WebRTC spec specifies that the PeerConnection's internal
// isClosed slot should immediately be set to true; however, in Firefox it
// occurs in the next tick. We workaround this by tracking isClosed manually.
FirefoxRTCPeerConnection.prototype.close = function close() {
  if (this.signalingState !== 'closed') {
    this._isClosed = true;
    this._peerConnection.close();
  }
};

util.delegateMethods(
  RTCPeerConnection.prototype,
  FirefoxRTCPeerConnection.prototype,
  '_peerConnection');

function rollback(peerConnection, local, onceRolledBack) {
  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';
  peerConnection._rollingBack = true;
  return peerConnection._peerConnection[setLocalDescription](new FirefoxRTCSessionDescription({
    type: 'rollback'
  })).then(onceRolledBack).then(function onceRolledBackSucceeded(result) {
    peerConnection._rollingBack = false;
    return result;
  }, function rollbackOrOnceRolledBackFailed(error) {
    peerConnection._rollingBack = false;
    throw error;
  });
}

/**
 * Extract the initially negotiated DTLS role out of an RTCSessionDescription's
 * sdp property and save it on the FirefoxRTCPeerConnection if and only if
 *
 *   1. A DTLS role was not already saved on the FirefoxRTCPeerConnection, and
 *   2. The description is an answer.
 *
 * @private
 * @param {FirefoxRTCPeerConnection} peerConnection
 * @param {RTCSessionDescription} description
 * @param {boolean} [remote=false] - if true, save the inverse of the DTLS role,
 *   e.g. "active" instead of "passive" and vice versa
 * @returns {undefined}
 */
function saveInitiallyNegotiatedDtlsRole(peerConnection, description, remote) {
  // NOTE(mroberts): JSEP specifies that offers always offer "actpass" as the
  // DTLS role. We need to inspect answers to figure out the negotiated DTLS
  // role.
  if (peerConnection._initiallyNegotiatedDtlsRole || description.type === 'offer') {
    return;
  }

  var match = description.sdp.match(/a=setup:([a-z]+)/);
  if (!match) {
    return;
  }

  var dtlsRole = match[1];
  peerConnection._initiallyNegotiatedDtlsRole = remote ? {
    active: 'passive',
    passive: 'active'
  }[dtlsRole] : dtlsRole;
}

/**
 * Overwrite the DTLS role in the sdp property of an RTCSessionDescription if
 * and only if
 *
 *   1. The description is an answer, and
 *   2. A DTLS role is provided.
 *
 * @private
 * @param {RTCSessionDescription} [description]
 * @param {string} [dtlsRole] - one of "active" or "passive"
 * @returns {?RTCSessionDescription} description
 */
function overwriteWithInitiallyNegotiatedDtlsRole(description, dtlsRole) {
  if (description && description.type === 'answer' && dtlsRole) {
    return new FirefoxRTCSessionDescription({
      type: description.type,
      sdp: description.sdp.replace(/a=setup:[a-z]+/g, 'a=setup:' + dtlsRole)
    });
  }
  return description;
}

module.exports = FirefoxRTCPeerConnection;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcpeerconnection/index.js":
/*!**********************************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcpeerconnection/index.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (typeof RTCPeerConnection === 'function') {
  var guessBrowser = __webpack_require__(/*! ../util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").guessBrowser;
  switch (guessBrowser()) {
    case 'chrome':
      module.exports = __webpack_require__(/*! ./chrome */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcpeerconnection/chrome.js");
      break;
    case 'firefox':
      module.exports = __webpack_require__(/*! ./firefox */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcpeerconnection/firefox.js");
      break;
    case 'safari':
      module.exports = __webpack_require__(/*! ./safari */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcpeerconnection/safari.js");
      break;
    default:
      module.exports = RTCPeerConnection;
      break;
  }
} else {
  module.exports = function RTCPeerConnection() {
    throw new Error('RTCPeerConnection is not supported');
  };
}


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcpeerconnection/safari.js":
/*!***********************************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcpeerconnection/safari.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCPeerConnection, RTCSessionDescription */


var EventTarget = __webpack_require__(/*! ../util/eventtarget */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/eventtarget.js");
var inherits = __webpack_require__(/*! util */ "./node_modules/util/util.js").inherits;
var Latch = __webpack_require__(/*! ../util/latch */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/latch.js");
var sdpUtils = __webpack_require__(/*! ../util/sdp */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/sdp.js");
var util = __webpack_require__(/*! ../util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js");

var isUnifiedPlan = sdpUtils.getSdpFormat() === 'unified';

var updateTrackIdsToSSRCs = isUnifiedPlan
  ? sdpUtils.updateUnifiedPlanTrackIdsToSSRCs
  : sdpUtils.updatePlanBTrackIdsToSSRCs;

function SafariRTCPeerConnection(configuration) {
  if (!(this instanceof SafariRTCPeerConnection)) {
    return new SafariRTCPeerConnection(configuration);
  }

  EventTarget.call(this);

  util.interceptEvent(this, 'datachannel');
  util.interceptEvent(this, 'iceconnectionstatechange');
  util.interceptEvent(this, 'signalingstatechange');
  util.interceptEvent(this, 'track');

  var peerConnection = new RTCPeerConnection(configuration);

  Object.defineProperties(this, {
    _appliedTracksToSSRCs: {
      value: new Map(),
      writable: true
    },
    _audioTransceiver: {
      value: null,
      writable: true
    },
    _isClosed: {
      value: false,
      writable: true
    },
    _peerConnection: {
      value: peerConnection
    },
    _pendingLocalOffer: {
      value: null,
      writable: true
    },
    _pendingRemoteOffer: {
      value: null,
      writable: true
    },
    _rolledBackTracksToSSRCs: {
      value: new Map(),
      writable: true
    },
    _signalingStateLatch: {
      value: new Latch()
    },
    _tracksToSSRCs: {
      value: new Map(),
      writable: true
    },
    _videoTransceiver: {
      value: null,
      writable: true
    },
    localDescription: {
      enumerable: true,
      get: function() {
        return this._pendingLocalOffer || this._peerConnection.localDescription;
      }
    },
    iceConnectionState: {
      enumerable: true,
      get: function() {
        return this._isClosed ? 'closed' : this._peerConnection.iceConnectionState;
      }
    },
    iceGatheringState: {
      enumerable: true,
      get: function() {
        return this._isClosed ? 'complete' : this._peerConnection.iceGatheringState;
      }
    },
    remoteDescription: {
      enumerable: true,
      get: function() {
        return this._pendingRemoteOffer || this._peerConnection.remoteDescription;
      }
    },
    signalingState: {
      enumerable: true,
      get: function() {
        if (this._isClosed) {
          return 'closed';
        } else if (this._pendingLocalOffer) {
          return 'have-local-offer';
        } else if (this._pendingRemoteOffer) {
          return 'have-remote-offer';
        }
        return this._peerConnection.signalingState;
      }
    }
  });

  var self = this;

  peerConnection.addEventListener('datachannel', function ondatachannel(event) {
    shimDataChannel(event.channel);
    self.dispatchEvent(event);
  });

  peerConnection.addEventListener('iceconnectionstatechange', function oniceconnectionstatechange() {
    if (self._isClosed) {
      return;
    }
    self.dispatchEvent.apply(self, arguments);
  });

  peerConnection.addEventListener('signalingstatechange', function onsignalingstatechange() {
    if (self._isClosed) {
      return;
    }
    if (peerConnection.signalingState === 'stable') {
      self._appliedTracksToSSRCs = new Map(self._tracksToSSRCs);
    }
    if (!self._pendingLocalOffer && !self._pendingRemoteOffer) {
      self.dispatchEvent.apply(self, arguments);
    }
  });

  // NOTE(syerrapragada): This ensures that SafariRTCPeerConnection's "remoteDescription", when accessed
  // in an RTCTrackEvent listener, will point to the underlying RTCPeerConnection's
  // "remoteDescription". Before this fix, this was still pointing to "_pendingRemoteOffer"
  // even though a new remote RTCSessionDescription had already been applied.
  peerConnection.addEventListener('track', function ontrack(event) {
    self._pendingRemoteOffer = null;
    self.dispatchEvent(event);
  });

  util.proxyProperties(RTCPeerConnection.prototype, this, peerConnection);
}

inherits(SafariRTCPeerConnection, EventTarget);

SafariRTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate) {
  var self = this;
  if (this.signalingState === 'have-remote-offer') {
    return this._signalingStateLatch.when('low').then(function signalingStatesResolved() {
      return self._peerConnection.addIceCandidate(candidate);
    });
  }
  return this._peerConnection.addIceCandidate(candidate);
};

SafariRTCPeerConnection.prototype.createOffer = function createOffer(options) {
  options = Object.assign({}, options);
  var self = this;

  // NOTE(mroberts): In general, this is not the way to do this; however, it's
  // good enough for our application.
  if (options.offerToReceiveVideo && !this._audioTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'audio'))) {
    delete options.offerToReceiveAudio;
    try {
      this._audioTransceiver = isUnifiedPlan
        ? this.addTransceiver('audio', { direction: 'recvonly' })
        : this.addTransceiver('audio');
    } catch (e) {
      return Promise.reject(e);
    }
  }

  if (options.offerToReceiveVideo && !this._videoTransceiver && !(isUnifiedPlan && hasReceiversForTracksOfKind(this, 'video'))) {
    delete options.offerToReceiveVideo;
    try {
      this._videoTransceiver = isUnifiedPlan
        ? this.addTransceiver('video', { direction: 'recvonly' })
        : this.addTransceiver('video');
    } catch (e) {
      return Promise.reject(e);
    }
  }

  return this._peerConnection.createOffer(options).then(function(offer) {
    // NOTE(mmalavalli): If createOffer() is called immediately after rolling back,
    // then we no longer need to retain the rolled back tracks to SSRCs Map.
    self._rolledBackTracksToSSRCs.clear();

    return new RTCSessionDescription({
      type: offer.type,
      sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, offer.sdp)
    });
  });
};

SafariRTCPeerConnection.prototype.createAnswer = function createAnswer(options) {
  var self = this;

  if (this._pendingRemoteOffer) {
    return this._peerConnection.setRemoteDescription(this._pendingRemoteOffer).then(function setRemoteDescriptionSucceeded() {
      self._signalingStateLatch.lower();
      return self._peerConnection.createAnswer();
    }).then(function createAnswerSucceeded(answer) {
      self._pendingRemoteOffer = null;

      // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no
      // longer need to retain the rolled back tracks to SSRCs Map.
      self._rolledBackTracksToSSRCs.clear();

      return isUnifiedPlan ? new RTCSessionDescription({
        type: answer.type,
        sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)
      }) : answer;
    }, function setRemoteDescriptionOrCreateAnswerFailed(error) {
      self._pendingRemoteOffer = null;
      throw error;
    });
  }

  return this._peerConnection.createAnswer(options).then(function createAnswerSucceeded(answer) {
    // NOTE(mmalavalli): If createAnswer() is called immediately after rolling back, then we no
    // longer need to retain the rolled back tracks to SSRCs Map.
    self._rolledBackTracksToSSRCs.clear();

    return isUnifiedPlan ? new RTCSessionDescription({
      type: answer.type,
      sdp: updateTrackIdsToSSRCs(self._tracksToSSRCs, answer.sdp)
    }) : answer;
  });
};

SafariRTCPeerConnection.prototype.createDataChannel = function createDataChannel(label, dataChannelDict) {
  var dataChannel = this._peerConnection.createDataChannel(label, dataChannelDict);
  shimDataChannel(dataChannel);
  return dataChannel;
};

SafariRTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
  sender.replaceTrack(null);
  this._peerConnection.removeTrack(sender);
};

SafariRTCPeerConnection.prototype.setLocalDescription = function setLocalDescription(description) {
  // NOTE(mmalavalli): If setLocalDescription() is called immediately after rolling back,
  // then we need to restore the rolled back tracks to SSRCs Map.
  if (this._rolledBackTracksToSSRCs.size > 0) {
    this._tracksToSSRCs = new Map(this._rolledBackTracksToSSRCs);
    this._rolledBackTracksToSSRCs.clear();
  }
  return setDescription(this, true, description);
};

SafariRTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(description) {
  // NOTE(mmalavalli): If setRemoteDescription() is called immediately after rolling back,
  // then we no longer need to retain the rolled back tracks to SSRCs Map.
  this._rolledBackTracksToSSRCs.clear();
  return setDescription(this, false, description);
};

SafariRTCPeerConnection.prototype.close = function close() {
  if (this._isClosed) {
    return;
  }
  this._isClosed = true;
  this._peerConnection.close();
  var self = this;
  setTimeout(function() {
    self.dispatchEvent(new Event('iceconnectionstatechange'));
    self.dispatchEvent(new Event('signalingstatechange'));
  });
};

util.delegateMethods(
  RTCPeerConnection.prototype,
  SafariRTCPeerConnection.prototype,
  '_peerConnection');

function setDescription(peerConnection, local, description) {
  function setPendingLocalOffer(offer) {
    if (local) {
      peerConnection._pendingLocalOffer = offer;
    } else {
      peerConnection._pendingRemoteOffer = offer;
    }
  }

  function clearPendingLocalOffer() {
    if (local) {
      peerConnection._pendingLocalOffer = null;
    } else {
      peerConnection._pendingRemoteOffer = null;
    }
  }

  var pendingLocalOffer = local ? peerConnection._pendingLocalOffer : peerConnection._pendingRemoteOffer;
  var pendingRemoteOffer = local ? peerConnection._pendingRemoteOffer : peerConnection._pendingLocalOffer;
  var intermediateState = local ? 'have-local-offer' : 'have-remote-offer';
  var setLocalDescription = local ? 'setLocalDescription' : 'setRemoteDescription';

  if (!local && pendingRemoteOffer && description.type === 'answer') {
    return setRemoteAnswer(peerConnection, description);
  } else if (description.type === 'offer') {
    if (peerConnection.signalingState !== intermediateState && peerConnection.signalingState !== 'stable') {
      return Promise.reject(new Error('Cannot set ' + (local ? 'local' : 'remote') +
        ' offer in state ' + peerConnection.signalingState));
    }

    if (!pendingLocalOffer && peerConnection._signalingStateLatch.state === 'low') {
      peerConnection._signalingStateLatch.raise();
    }
    var previousSignalingState = peerConnection.signalingState;
    setPendingLocalOffer(description);

    // Only dispatch a signalingstatechange event if we transitioned.
    if (peerConnection.signalingState !== previousSignalingState) {
      return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {
        peerConnection.dispatchEvent(new Event('signalingstatechange'));
      });
    }

    return Promise.resolve();
  } else if (description.type === 'rollback') {
    if (peerConnection.signalingState !== intermediateState) {
      return Promise.reject(new Error('Cannot rollback ' +
        (local ? 'local' : 'remote') + ' description in ' + peerConnection.signalingState));
    }
    clearPendingLocalOffer();

    // NOTE(mmalavalli): We store the rolled back tracks to SSRCs Map here in case
    // setLocalDescription() is called immediately aftera rollback (without calling
    // createOffer() or createAnswer()), in which case this roll back is not due to
    // a glare scenario and this Map should be restored.
    peerConnection._rolledBackTracksToSSRCs = new Map(peerConnection._tracksToSSRCs);
    peerConnection._tracksToSSRCs = new Map(peerConnection._appliedTracksToSSRCs);

    return Promise.resolve().then(function dispatchSignalingStateChangeEvent() {
      peerConnection.dispatchEvent(new Event('signalingstatechange'));
    });
  }

  return peerConnection._peerConnection[setLocalDescription](description);
}

function setRemoteAnswer(peerConnection, answer) {
  var pendingLocalOffer = peerConnection._pendingLocalOffer;
  return peerConnection._peerConnection.setLocalDescription(pendingLocalOffer).then(function setLocalOfferSucceeded() {
    peerConnection._pendingLocalOffer = null;
    return peerConnection.setRemoteDescription(answer);
  }).then(function setRemoteAnswerSucceeded() {
    peerConnection._signalingStateLatch.lower();
  });
}

/**
 * Whether a SafariRTCPeerConnection has any RTCRtpReceivers(s) for the given
 * MediaStreamTrack kind.
 * @param {SafariRTCPeerConnection} peerConnection
 * @param {'audio' | 'video'} kind
 * @returns {boolean}
 */
function hasReceiversForTracksOfKind(peerConnection, kind) {
  return !!peerConnection.getTransceivers().find(function(transceiver) {
    return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === kind;
  });
}

/**
 * Shim an RTCDataChannel. This function mutates the RTCDataChannel.
 * @param {RTCDataChannel} dataChannel
 * @returns {RTCDataChannel}
 */
function shimDataChannel(dataChannel) {
  return Object.defineProperties(dataChannel, {
    maxPacketLifeTime: {
      value: dataChannel.maxPacketLifeTime === 65535
        ? null
        : dataChannel.maxPacketLifeTime
    },
    maxRetransmits: {
      value: dataChannel.maxRetransmits === 65535
        ? null
        : dataChannel.maxRetransmits
    }
  });
}

module.exports = SafariRTCPeerConnection;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcrtpsender.js":
/*!***********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcrtpsender.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * RTCRtpSender shim.
 * @param {MediaStreamTrack} track
 * @property {MediaStreamTrack} track
 */
function RTCRtpSenderShim(track) {
  Object.defineProperties(this, {
    track: {
      enumerable: true,
      value: track,
      writable: true
    }
  });
}

// NOTE(mmalavalli): Because of the way we will be using this shim, there
// are a couple of use cases that will not be covered:
//
// /* Case 1 */
// const sender = pc.addTrack(track);
// assert.equal(sender.track, track);
// pc.removeTrack(sender);
// assert.equal(sender.track, null); /* Error */
//
// /* Case 2 */
// const sender = pc.addTrack(track);
// const senders1 = new Set(pc.getSenders());
// assert(senders1.has(sender));
// pc.removeTrack(track);
// const senders2 = new Set(pc.getSenders());
// assert(senders2.has(sender)); /* Error */
//
// For now, since we only use senders for passing them to RTCPeerConnection#removeTrack(),
// we will omit handling these use cases for now, and revisit them when we start
// using the RTCRtpSender APIs.

module.exports = RTCRtpSenderShim;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcsessiondescription/chrome.js":
/*!***************************************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcsessiondescription/chrome.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCSessionDescription */


// This class wraps Chrome's RTCSessionDescription implementation. It provides
// one piece of functionality not currently present in Chrome, namely
//
//   1. Rollback support
//      https://bugs.chromium.org/p/webrtc/issues/detail?id=4676
//
function ChromeRTCSessionDescription(descriptionInitDict) {
  if (!(this instanceof ChromeRTCSessionDescription)) {
    return new ChromeRTCSessionDescription(descriptionInitDict);
  }

  // If this constructor is called with an object with a .type property set to
  // "rollback", we should not call Chrome's RTCSessionDescription constructor,
  // because this would throw an RTCSdpType error.
  var description = descriptionInitDict && descriptionInitDict.type === 'rollback'
    ? null
    : new RTCSessionDescription(descriptionInitDict);

  Object.defineProperties(this, {
    _description: {
      get: function() {
        return description;
      }
    },
    sdp: {
      enumerable: true,
      value: description ? description.sdp : descriptionInitDict.sdp
    },
    type: {
      enumerable: true,
      value: description ? description.type : descriptionInitDict.type
    }
  });
}

module.exports = ChromeRTCSessionDescription;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcsessiondescription/firefox.js":
/*!****************************************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcsessiondescription/firefox.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCSessionDescription */


module.exports = RTCSessionDescription;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcsessiondescription/index.js":
/*!**************************************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcsessiondescription/index.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCSessionDescription */


if (typeof RTCSessionDescription === 'function') {
  var guessBrowser = __webpack_require__(/*! ../util */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").guessBrowser;
  switch (guessBrowser()) {
    case 'chrome':
      module.exports = __webpack_require__(/*! ./chrome */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcsessiondescription/chrome.js");
      break;
    case 'firefox':
      module.exports = __webpack_require__(/*! ./firefox */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/rtcsessiondescription/firefox.js");
      break;
    default:
      module.exports = RTCSessionDescription;
      break;
  }
} else {
  module.exports = function RTCSessionDescription() {
    throw new Error('RTCSessionDescription is not supported');
  };
}


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/eventtarget.js":
/*!***************************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/eventtarget.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

/**
 * Event target.
 * @class
 */
function EventTarget() {
  Object.defineProperties(this, {
    _eventEmitter: {
      value: new EventEmitter()
    }
  });
}

/**
 * Dispatch an Event to the {@link EventTarget}.
 * @param {Event} event
 */
EventTarget.prototype.dispatchEvent = function dispatchEvent(event) {
  return this._eventEmitter.emit(event.type, event);
};

/**
 * Add an Event listener to the {@link EventTarget}.
 */
EventTarget.prototype.addEventListener = function addEventListener() {
  return this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
};

/**
 * Remove an Event listener to the {@link EventTarget}.
 */
EventTarget.prototype.removeEventListener = function removeEventListener() {
  return this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
};

module.exports = EventTarget;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js":
/*!*********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Create a {@link Deferred}.
 * @returns {Deferred}
 */
function defer() {
  var deferred = {};
  deferred.promise = new Promise(function(resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

/**
 * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking
 * the method on the `wrapper` prototype will invoke the corresponding method
 * on an instance accessed by `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @param {string} methodName
 * @returns {undefined}
 */
function delegateMethod(source, wrapper, target, methodName) {
  if (methodName in wrapper) {
    // Skip any methods already set.
    return;
  } else if (methodName.match(/^on[a-z]+$/)) {
    // Skip EventHandlers (these are handled in the constructor).
    return;
  }


  var isProperty = false;
  try {
    var propDesc = Object.getOwnPropertyDescriptor(source, methodName);
    isProperty = propDesc && !!propDesc.get;
  } catch (error) {
    // its okay to eat failure here.
  }

  // NOTE(mpatwardhan):skip properties. we are only interested in overriding
  // functions. we do not even want to evaluate  `typeof source[methodName]` for properties
  // because getter would get invoked, and they might have side effects.
  // For example RTCPeerConnection.peerIdentity is a property that returns a promise.
  // calling typeof RTCPeerConnection.peerIdentity, would leak a promise, and in case it rejects
  // we see errors.
  if (isProperty) {
    return;
  }

  var type;
  try {
    type = typeof source[methodName];
  } catch (error) {
    // NOTE(mroberts): Attempting to check the type of non-function members
    // on the prototype throws an error for some types.
  }

  if (type !== 'function') {
    // Skip non-function members.
    return;
  }

  /* eslint no-loop-func:0 */
  wrapper[methodName] = function() {
    return this[target][methodName].apply(this[target], arguments);
  };
}

/**
 * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking
 * the methods on the `wrapper` prototype will invoke the corresponding method
 * on an instance accessed by `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @returns {undefined}
 */
function delegateMethods(source, wrapper, target) {
  for (var methodName in source) {
    delegateMethod(source, wrapper, target, methodName);
  }
}

/**
 * Finds the items in list1 that are not in list2.
 * @param {Array<*>|Map<*>|Set<*>} list1
 * @param {Array<*>|Map<*>|Set<*>} list2
 * @returns {Set}
 */
function difference(list1, list2) {
  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());
  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());

  var difference = new Set();

  list1.forEach(function(item) {
    if (!list2.has(item)) {
      difference.add(item);
    }
  });

  return difference;
}

/**
 * Map a list to an array of arrays, and return the flattened result.
 * @param {Array<*>|Set<*>|Map<*>} list
 * @param {function(*): Array<*>} mapFn
 * @returns Array<*>
 */
function flatMap(list, mapFn) {
  var listArray = list instanceof Map || list instanceof Set
    ? Array.from(list.values())
    : list;

  return listArray.reduce(function(flattened, item) {
    var mapped = mapFn(item);
    return flattened.concat(mapped);
  }, []);
}

/**
 * Get the browser's user agent, if available.
 * @returns {?string}
 */
function getUserAgent() {
  return typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string'
    ? navigator.userAgent
    : null;
}

/**
 * Guess the browser.
 * @param {string} [userAgent=navigator.userAgent]
 * @returns {?string} browser - "chrome", "firefox", "safari", or null
 */
function guessBrowser(userAgent) {
  if (typeof userAgent === 'undefined') {
    userAgent = getUserAgent();
  }
  if (/Chrome|CriOS/.test(userAgent)) {
    return 'chrome';
  }
  if (/Firefox|FxiOS/.test(userAgent)) {
    return 'firefox';
  }
  if (/Safari/.test(userAgent)) {
    return 'safari';
  }
  return null;
}

/**
 * Guess the browser version.
 * @param {string} [userAgent=navigator.userAgent]
 * @returns {?{major: number, minor: number}}
 */
function guessBrowserVersion(userAgent) {
  if (typeof userAgent === 'undefined') {
    userAgent = getUserAgent();
  }
  var prefix = {
    chrome: 'Chrome|CriOS',
    firefox: 'Firefox|FxiOS',
    safari: 'Version'
  }[guessBrowser(userAgent)];

  if (!prefix) {
    return null;
  }
  var regex = new RegExp('(' + prefix + ')/([^\\s]+)');
  var match = (userAgent.match(regex) || [])[2];

  if (!match) {
    return null;
  }
  var versions = match.split('.').map(Number);
  return {
    major: isNaN(versions[0]) ? null : versions[0],
    minor: isNaN(versions[1]) ? null : versions[1]
  };
}

/**
 * Check whether the current browser is iOS Chrome.
 * @param {string} [userAgent=navigator.userAgent]
 * @returns {boolean}
 */
function isIOSChrome(userAgent) {
  if (typeof userAgent === 'undefined') {
    userAgent = getUserAgent();
  }
  return (/Mobi/.test(userAgent) && guessBrowser() === 'chrome' && /iPad|iPhone|iPod/.test(userAgent));
}

/**
 * Intercept an event that might otherwise be proxied on an EventTarget.
 * @param {EventTarget} target
 * @param {string} type
 * @returns {void}
 */
function interceptEvent(target, type) {
  var currentListener = null;
  Object.defineProperty(target, 'on' + type, {
    get: function() {
      return currentListener;
    },
    set: function(newListener) {
      if (currentListener) {
        this.removeEventListener(type, currentListener);
      }

      if (typeof newListener === 'function') {
        currentListener = newListener;
        this.addEventListener(type, currentListener);
      } else {
        currentListener = null;
      }
    }
  });
}

/**
 * This is a function for turning a Promise into the kind referenced in the
 * Legacy Interface Extensions section of the WebRTC spec.
 * @param {Promise<*>} promise
 * @param {function<*>} onSuccess
 * @param {function<Error>} onFailure
 * @returns {Promise<undefined>}
 */
function legacyPromise(promise, onSuccess, onFailure) {
  if (onSuccess) {
    return promise.then(function(result) {
      onSuccess(result);
    }, function(error) {
      onFailure(error);
    });
  }
  return promise;
}

/**
 * Make a unique ID.
 * @return {string}
 */
function makeUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0;
    var v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

/**
 * For each property name on the `source` prototype, add getters and/or setters
 * to `wrapper` that proxy to `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @returns {undefined}
 */
function proxyProperties(source, wrapper, target) {
  Object.getOwnPropertyNames(source).forEach(function(propertyName) {
    proxyProperty(source, wrapper, target, propertyName);
  });
}

/**
 * For the property name on the `source` prototype, add a getter and/or setter
 * to `wrapper` that proxies to `target`.
 * @param {object} source
 * @param {object} wrapper
 * @param {string} target
 * @param {string} propertyName
 * @returns {undefined}
 */
function proxyProperty(source, wrapper, target, propertyName) {
  if (propertyName in wrapper) {
    // Skip any properties already set.
    return;
  } else if (propertyName.match(/^on[a-z]+$/)) {
    Object.defineProperty(wrapper, propertyName, {
      value: null,
      writable: true
    });

    target.addEventListener(propertyName.slice(2), function() {
      wrapper.dispatchEvent.apply(wrapper, arguments);
    });

    return;
  }

  Object.defineProperty(wrapper, propertyName, {
    enumerable: true,
    get: function() {
      return target[propertyName];
    }
  });
}

/**
 * Check whether native WebRTC APIs are supported.
 * @returns {boolean}
 */
function support() {
  return typeof navigator === 'object'
    && typeof navigator.mediaDevices === 'object'
    && typeof navigator.mediaDevices.getUserMedia === 'function'
    && typeof RTCPeerConnection === 'function';
}

/**
 * @typedef {object} Deferred
 * @property {Promise} promise
 * @property {function} reject
 * @property {function} resolve
 */

exports.defer = defer;
exports.delegateMethods = delegateMethods;
exports.difference = difference;
exports.flatMap = flatMap;
exports.guessBrowser = guessBrowser;
exports.guessBrowserVersion = guessBrowserVersion;
exports.isIOSChrome = isIOSChrome;
exports.interceptEvent = interceptEvent;
exports.legacyPromise = legacyPromise;
exports.makeUUID = makeUUID;
exports.proxyProperties = proxyProperties;
exports.support = support;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/latch.js":
/*!*********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/latch.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defer = __webpack_require__(/*! ./ */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").defer;

var states = {
  high: new Set(['low']),
  low: new Set(['high'])
};

/**
 * Construct a {@link Latch}.
 * @class
 * @classdesc A {@link Latch} has two states ("high" and "low") and methods for
 * transitioning between them ({@link Latch#raise} and {@link Latch#lower}).
 * @param {string} [initialState="low"] - either "high" or "low"
 */
function Latch(initialState) {
  if (!(this instanceof Latch)) {
    return new Latch(initialState);
  }
  var state = initialState || 'low';
  Object.defineProperties(this, {
    _state: {
      set: function(_state) {
        if (state !== _state) {
          state = _state;
          var whenDeferreds = this._whenDeferreds.get(state);
          whenDeferreds.forEach(function(deferred) {
            deferred.resolve(this);
          }, this);
          whenDeferreds.clear();
        }
      },
      get: function() {
        return state;
      }
    },
    _whenDeferreds: {
      value: new Map([
        ['high', new Set()],
        ['low', new Set()]
      ])
    },
    state: {
      enumerable: true,
      get: function() {
        return this._state;
      }
    }
  });
}

/**
 * Transition to "low".
 * @returns {this}
 * @throws {Error}
 */
Latch.prototype.lower = function lower() {
  return this.transition('low');
};

/**
 * Transition to "high".
 * @returns {this}
 * @throws {Error}
 */
Latch.prototype.raise = function raise() {
  return this.transition('high');
};

/**
 * Transition to a new state.
 * @param {string} newState
 * @returns {this}
 * @throws {Error}
 */
Latch.prototype.transition = function transition(newState) {
  if (!states[this.state].has(newState)) {
    throw createUnreachableStateError(this.state, newState);
  }
  this._state = newState;
  return this;
};

/**
 * Return a Promise that resolves when the {@link Latch} transitions to
 * the specified state.
 * @param {string} state
 * @returns {Promise<this>}
 */
Latch.prototype.when = function when(state) {
  if (this.state === state) {
    return Promise.resolve(this);
  }
  if (!states[this.state].has(state)) {
    return Promise.reject(createUnreachableStateError(this.state, state));
  }
  var deferred = defer();
  this._whenDeferreds.get(state).add(deferred);
  return deferred.promise;
};

/**
 * Create an unreachable state Error.
 * @param {string} from - state to be transitioned from
 * @param {string} to - state to be transitioned to
 * @return {Error}
 */
function createUnreachableStateError(from, to) {
  return new Error('Cannot transition from "' + from + '" to "' + to + '"');
}

module.exports = Latch;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/sdp.js":
/*!*******************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/sdp.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* globals RTCPeerConnection, RTCRtpTransceiver */



var flatMap = __webpack_require__(/*! ./ */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").flatMap;
var guessBrowser = __webpack_require__(/*! ./ */ "../../work/twilio-video.js/node_modules/@twilio/webrtc/lib/util/index.js").guessBrowser;

// NOTE(mmalavalli): We cache Chrome's sdpSemantics support in order to prevent
// instantiation of more than one RTCPeerConnection.
var isSdpSemanticsSupported = null;

/**
 * Check if Chrome supports specifying sdpSemantics for an RTCPeerConnection.
 * @return {boolean}
 */
function checkIfSdpSemanticsIsSupported() {
  if (typeof isSdpSemanticsSupported === 'boolean') {
    return isSdpSemanticsSupported;
  }
  if (typeof RTCPeerConnection === 'undefined') {
    isSdpSemanticsSupported = false;
    return isSdpSemanticsSupported;
  }
  try {
    new RTCPeerConnection({ sdpSemantics: 'foo' });
    isSdpSemanticsSupported = false;
  } catch (e) {
    isSdpSemanticsSupported = true;
  }
  return isSdpSemanticsSupported;
}

// NOTE(mmalavalli): We cache Chrome's SDP format in order to prevent
// instantiation of more than one RTCPeerConnection.
var chromeSdpFormat = null;

/**
 * Get Chrome's default SDP format.
 * @returns {'planb'|'unified'}
 */
function getChromeDefaultSdpFormat() {
  if (!chromeSdpFormat) {
    if (typeof RTCPeerConnection !== 'undefined'
      && 'addTransceiver' in RTCPeerConnection.prototype) {
      try {
        new RTCPeerConnection().addTransceiver('audio');
        chromeSdpFormat = 'unified';
      } catch (e) {
        chromeSdpFormat = 'planb';
      }
    } else {
      chromeSdpFormat = 'planb';
    }
  }
  return chromeSdpFormat;
}

/**
 * Get Chrome's SDP format.
 * @param {'plan-b'|'unified-plan'} [sdpSemantics]
 * @returns {'planb'|'unified'}
 */
function getChromeSdpFormat(sdpSemantics) {
  if (!sdpSemantics || !checkIfSdpSemanticsIsSupported()) {
    return getChromeDefaultSdpFormat();
  }
  return {
    'plan-b': 'planb',
    'unified-plan': 'unified'
  }[sdpSemantics];
}

/**
 * Get Safari's default SDP format.
 * @returns {'planb'|'unified'}
 */
function getSafariSdpFormat() {
  return typeof RTCRtpTransceiver !== 'undefined'
    && 'currentDirection' in RTCRtpTransceiver.prototype
      ? 'unified'
      : 'planb';
}

/**
 * Get the browser's default SDP format.
 * @param {'plan-b'|'unified-plan'} [sdpSemantics]
 * @returns {'planb'|'unified'}
 */
function getSdpFormat(sdpSemantics) {
  return {
    chrome: getChromeSdpFormat(sdpSemantics),
    firefox: 'unified',
    safari: getSafariSdpFormat()
  }[guessBrowser()] || null;
}

/**
 * Match a pattern across lines, returning the first capture group for any
 * matches.
 * @param {string} pattern
 * @param {string} lines
 * @returns {Set<string>} matches
 */
function getMatches(pattern, lines) {
  var matches = lines.match(new RegExp(pattern, 'gm')) || [];
  return matches.reduce(function(results, line) {
    var match = line.match(new RegExp(pattern));
    return match ? results.add(match[1]) : results;
  }, new Set());
}

/**
 * Get a Set of MediaStreamTrack IDs from an SDP.
 * @param {string} pattern
 * @param {string} sdp
 * @returns {Set<string>}
 */
function getTrackIds(pattern, sdp) {
  return getMatches(pattern, sdp);
}

/**
 * Get a Set of MediaStreamTrack IDs from a Plan B SDP.
 * @param {string} sdp - Plan B SDP
 * @returns {Set<string>} trackIds
 */
function getPlanBTrackIds(sdp) {
  return getTrackIds('^a=ssrc:[0-9]+ +msid:.+ +(.+) *$', sdp);
}

/**
 * Get a Set of MediaStreamTrack IDs from a Unified Plan SDP.
 * @param {string} sdp - Unified Plan SDP
 * @returns {Set<string>} trackIds
 */
function getUnifiedPlanTrackIds(sdp) {
  return getTrackIds('^a=msid:.+ +(.+) *$', sdp);
}

/**
 * Get a Set of SSRCs for a MediaStreamTrack from a Plan B SDP.
 * @param {string} sdp - Plan B SDP
 * @param {string} trackId - MediaStreamTrack ID
 * @returns {Set<string>}
 */
function getPlanBSSRCs(sdp, trackId) {
  var pattern = '^a=ssrc:([0-9]+) +msid:[^ ]+ +' + trackId + ' *$';
  return getMatches(pattern, sdp);
}

/**
 * Get the m= sections of a particular kind and direction from an sdp.
 * @param {string} sdp -  sdp string
 * @param {string} [kind] - Pattern for matching kind
 * @param {string} [direction] - Pattern for matching direction
 * @returns {Array<string>} mediaSections
 */
function getMediaSections(sdp, kind, direction) {
  kind = kind || '.*';
  direction = direction || '.*';
  return sdp.split('\r\nm=').slice(1).map(function(mediaSection) {
    return 'm=' + mediaSection;
  }).filter(function(mediaSection) {
    var kindPattern = new RegExp('m=' + kind, 'gm');
    var directionPattern = new RegExp('a=' + direction, 'gm');
    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);
  });
}

/**
 * Get the Set of SSRCs announced in a MediaSection.
 * @param {string} mediaSection
 * @returns {Array<string>} ssrcs
 */
function getMediaSectionSSRCs(mediaSection) {
  return Array.from(getMatches('^a=ssrc:([0-9]+) +.*$', mediaSection));
}

/**
 * Get a Set of SSRCs for a MediaStreamTrack from a Unified Plan SDP.
 * @param {string} sdp - Unified Plan SDP
 * @param {string} trackId - MediaStreamTrack ID
 * @returns {Set<string>}
 */
function getUnifiedPlanSSRCs(sdp, trackId) {
  var mediaSections = getMediaSections(sdp);

  var msidAttrRegExp = new RegExp('^a=msid:[^ ]+ +' + trackId + ' *$', 'gm');
  var matchingMediaSections = mediaSections.filter(function(mediaSection) {
    return mediaSection.match(msidAttrRegExp);
  });

  return new Set(flatMap(matchingMediaSections, getMediaSectionSSRCs));
}

/**
 * Get a Map from MediaStreamTrack IDs to SSRCs from an SDP.
 * @param {function(string): Set<string>} getTrackIds
 * @param {function(string, string): Set<string>} getSSRCs
 * @param {string} sdp - SDP
 * @returns {Map<string, Set<string>>} trackIdsToSSRCs
 */
function getTrackIdsToSSRCs(getTrackIds, getSSRCs, sdp) {
  return new Map(Array.from(getTrackIds(sdp)).map(function(trackId) {
    return [trackId, getSSRCs(sdp, trackId)];
  }));
}

/**
 * Get a Map from MediaStreamTrack IDs to SSRCs from a Plan B SDP.
 * @param {string} sdp - Plan B SDP
 * @returns {Map<string, Set<string>>} trackIdsToSSRCs
 */
function getPlanBTrackIdsToSSRCs(sdp) {
  return getTrackIdsToSSRCs(getPlanBTrackIds, getPlanBSSRCs, sdp);
}

/**
 * Get a Map from MediaStreamTrack IDs to SSRCs from a Plan B SDP.
 * @param {string} sdp - Plan B SDP
 * @returns {Map<string, Set<string>>} trackIdsToSSRCs
 */
function getUnifiedPlanTrackIdsToSSRCs(sdp) {
  return getTrackIdsToSSRCs(getUnifiedPlanTrackIds, getUnifiedPlanSSRCs, sdp);
}

/**
 * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both
 * the Map from MediaStreamTrack IDs to SSRCs and the SDP itself. This method
 * ensures that SSRCs never change once announced.
 * @param {function(string): Map<string, Set<string>>} getTrackIdsToSSRCs
 * @param {Map<string, Set<string>>} trackIdsToSSRCs
 * @param {string} sdp - SDP
 * @returns {strinng} updatedSdp - updated SDP
 */
function updateTrackIdsToSSRCs(getTrackIdsToSSRCs, trackIdsToSSRCs, sdp) {
  var newTrackIdsToSSRCs = getTrackIdsToSSRCs(sdp);
  var newSSRCsToOldSSRCs = new Map();

  // NOTE(mroberts): First, update a=ssrc attributes.
  newTrackIdsToSSRCs.forEach(function(ssrcs, trackId) {
    if (!trackIdsToSSRCs.has(trackId)) {
      trackIdsToSSRCs.set(trackId, ssrcs);
      return;
    }
    var oldSSRCs = Array.from(trackIdsToSSRCs.get(trackId));
    var newSSRCs = Array.from(ssrcs);
    oldSSRCs.forEach(function(oldSSRC, i) {
      var newSSRC = newSSRCs[i];
      newSSRCsToOldSSRCs.set(newSSRC, oldSSRC);
      var pattern = '^a=ssrc:' + newSSRC + ' (.*)$';
      var replacement = 'a=ssrc:' + oldSSRC + ' $1';
      sdp = sdp.replace(new RegExp(pattern, 'gm'), replacement);
    });
  });

  // NOTE(mroberts): Then, update a=ssrc-group attributes.
  var pattern = '^(a=ssrc-group:[^ ]+ +)(.*)$';
  var matches = sdp.match(new RegExp(pattern, 'gm')) || [];
  matches.forEach(function(line) {
    var match = line.match(new RegExp(pattern));
    if (!match) {
      return;
    }
    var prefix = match[1];
    var newSSRCs = match[2];
    var oldSSRCs = newSSRCs.split(' ').map(function(newSSRC) {
      var oldSSRC = newSSRCsToOldSSRCs.get(newSSRC);
      return oldSSRC ? oldSSRC : newSSRC;
    }).join(' ');
    sdp = sdp.replace(match[0], prefix + oldSSRCs);
  });

  return sdp;
}

/**
 * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both
 * the Map from MediaStreamTrack IDs to SSRCs and the Plan B SDP itself. This
 * method ensures that SSRCs never change once announced.
 * @param {Map<string, Set<string>>} trackIdsToSSRCs
 * @param {string} sdp - Plan B SDP
 * @returns {string} updatedSdp - updated Plan B SDP
 */
function updatePlanBTrackIdsToSSRCs(trackIdsToSSRCs, sdp) {
  return updateTrackIdsToSSRCs(getPlanBTrackIdsToSSRCs, trackIdsToSSRCs, sdp);
}

/**
 * Update the mappings from MediaStreamTrack IDs to SSRCs as indicated by both
 * the Map from MediaStreamTrack IDs to SSRCs and the Plan B SDP itself. This
 * method ensures that SSRCs never change once announced.
 * @param {Map<string, Set<string>>} trackIdsToSSRCs
 * @param {string} sdp - Plan B SDP
 * @returns {string} updatedSdp - updated Plan B SDP
 */
function updateUnifiedPlanTrackIdsToSSRCs(trackIdsToSSRCs, sdp) {
  return updateTrackIdsToSSRCs(getUnifiedPlanTrackIdsToSSRCs, trackIdsToSSRCs, sdp);
}

exports.getSdpFormat = getSdpFormat;
exports.getMediaSections = getMediaSections;
exports.getPlanBTrackIds = getPlanBTrackIds;
exports.getUnifiedPlanTrackIds = getUnifiedPlanTrackIds;
exports.getPlanBSSRCs = getPlanBSSRCs;
exports.getUnifiedPlanSSRCs = getUnifiedPlanSSRCs;
exports.updatePlanBTrackIdsToSSRCs = updatePlanBTrackIdsToSSRCs;
exports.updateUnifiedPlanTrackIdsToSSRCs = updateUnifiedPlanTrackIdsToSSRCs;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/@twilio/webrtc/package.json":
/*!****************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/@twilio/webrtc/package.json ***!
  \****************************************************************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, bugs, bundleDependencies, contributors, deprecated, description, devDependencies, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"_from\":\"@twilio/webrtc@4.5.1\",\"_id\":\"@twilio/webrtc@4.5.1\",\"_inBundle\":false,\"_integrity\":\"sha512-0GwnffxJ71jm/7sYD8MYHzZRCR59p7KYqiMO8/Fmny7S4L0s8Ms36ghUUfCE7x/XuWjAC4FU6L/DkFN1Ewuu8Q==\",\"_location\":\"/@twilio/webrtc\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"@twilio/webrtc@4.5.1\",\"name\":\"@twilio/webrtc\",\"escapedName\":\"@twilio%2fwebrtc\",\"scope\":\"@twilio\",\"rawSpec\":\"4.5.1\",\"saveSpec\":null,\"fetchSpec\":\"4.5.1\"},\"_requiredBy\":[\"/\"],\"_resolved\":\"https://registry.npmjs.org/@twilio/webrtc/-/webrtc-4.5.1.tgz\",\"_shasum\":\"9a69b8f3709624b215e9481097626b1d3ae879ba\",\"_spec\":\"@twilio/webrtc@4.5.1\",\"_where\":\"/Users/mpatwardhan/work/twilio-video.js\",\"author\":{\"name\":\"Manjesh Malavalli\",\"email\":\"mmalavalli@twilio.com\"},\"bugs\":{\"url\":\"https://github.com/twilio/twilio-webrtc.js/issues\"},\"bundleDependencies\":false,\"contributors\":[{\"name\":\"Mark Roberts\",\"email\":\"mroberts@twilio.com\"},{\"name\":\"Ryan Rowland\",\"email\":\"rrowland@twilio.com\"},{\"name\":\"Makarand Patwardhan\",\"email\":\"mpatwardhan@twilio.com\"}],\"deprecated\":false,\"description\":\"WebRTC-related APIs and shims used by twilio-video.js\",\"devDependencies\":{\"browserify\":\"^14.4.0\",\"electron\":\"9.4.0\",\"envify\":\"^4.1.0\",\"eslint\":\"^4.4.1\",\"is-docker\":\"^2.0.0\",\"istanbul\":\"^0.4.5\",\"karma\":\"^6.3.4\",\"karma-browserify\":\"^8.1.0\",\"karma-chrome-launcher\":\"^2.2.0\",\"karma-edgium-launcher\":\"^4.0.0-0\",\"karma-electron\":\"^6.1.0\",\"karma-firefox-launcher\":\"^1.0.1\",\"karma-htmlfile-reporter\":\"^0.3.8\",\"karma-junit-reporter\":\"^1.2.0\",\"karma-mocha\":\"^2.0.1\",\"karma-safari-launcher\":\"~0.1\",\"karma-spec-reporter\":\"0.0.31\",\"mocha\":\"^9.1.1\",\"npm-run-all\":\"^4.0.2\",\"rimraf\":\"^2.6.1\",\"simple-git\":\"^2.4.0\",\"twilio-release-tool\":\"^1.0.0\",\"watchify\":\"^4.0.0\",\"webrtc-adapter\":\"^6.4.8\"},\"homepage\":\"https://github.com/twilio/twilio-webrtc.js#readme\",\"keywords\":[\"shim\",\"twilio\",\"video\",\"webrtc\"],\"license\":\"BSD-3-Clause\",\"main\":\"./lib/index.js\",\"name\":\"@twilio/webrtc\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/twilio/twilio-webrtc.js.git\"},\"scripts\":{\"build\":\"npm-run-all clean lint test\",\"clean\":\"rimraf coverage\",\"lint\":\"eslint ./lib\",\"test\":\"npm-run-all test:*\",\"test:integration\":\"npm-run-all test:integration:*\",\"test:integration:adapter\":\"karma start karma/integration.adapter.conf.js\",\"test:integration:native\":\"karma start karma/integration.conf.js\",\"test:unit\":\"istanbul cover node_modules/mocha/bin/_mocha -- ./test/unit/index.js\"},\"version\":\"4.5.1\"}");

/***/ }),

/***/ "../../work/twilio-video.js/node_modules/backoff/index.js":
/*!*****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/backoff/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var Backoff = __webpack_require__(/*! ./lib/backoff */ "../../work/twilio-video.js/node_modules/backoff/lib/backoff.js");
var ExponentialBackoffStrategy = __webpack_require__(/*! ./lib/strategy/exponential */ "../../work/twilio-video.js/node_modules/backoff/lib/strategy/exponential.js");
var FibonacciBackoffStrategy = __webpack_require__(/*! ./lib/strategy/fibonacci */ "../../work/twilio-video.js/node_modules/backoff/lib/strategy/fibonacci.js");
var FunctionCall = __webpack_require__(/*! ./lib/function_call.js */ "../../work/twilio-video.js/node_modules/backoff/lib/function_call.js");

module.exports.Backoff = Backoff;
module.exports.FunctionCall = FunctionCall;
module.exports.FibonacciStrategy = FibonacciBackoffStrategy;
module.exports.ExponentialStrategy = ExponentialBackoffStrategy;

// Constructs a Fibonacci backoff.
module.exports.fibonacci = function(options) {
    return new Backoff(new FibonacciBackoffStrategy(options));
};

// Constructs an exponential backoff.
module.exports.exponential = function(options) {
    return new Backoff(new ExponentialBackoffStrategy(options));
};

// Constructs a FunctionCall for the given function and arguments.
module.exports.call = function(fn, vargs, callback) {
    var args = Array.prototype.slice.call(arguments);
    fn = args[0];
    vargs = args.slice(1, args.length - 1);
    callback = args[args.length - 1];
    return new FunctionCall(fn, vargs, callback);
};


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/backoff/lib/backoff.js":
/*!***********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/backoff/lib/backoff.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var events = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var precond = __webpack_require__(/*! precond */ "../../work/twilio-video.js/node_modules/precond/index.js");
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

// A class to hold the state of a backoff operation. Accepts a backoff strategy
// to generate the backoff delays.
function Backoff(backoffStrategy) {
    events.EventEmitter.call(this);

    this.backoffStrategy_ = backoffStrategy;
    this.maxNumberOfRetry_ = -1;
    this.backoffNumber_ = 0;
    this.backoffDelay_ = 0;
    this.timeoutID_ = -1;

    this.handlers = {
        backoff: this.onBackoff_.bind(this)
    };
}
util.inherits(Backoff, events.EventEmitter);

// Sets a limit, greater than 0, on the maximum number of backoffs. A 'fail'
// event will be emitted when the limit is reached.
Backoff.prototype.failAfter = function(maxNumberOfRetry) {
    precond.checkArgument(maxNumberOfRetry > 0,
        'Expected a maximum number of retry greater than 0 but got %s.',
        maxNumberOfRetry);

    this.maxNumberOfRetry_ = maxNumberOfRetry;
};

// Starts a backoff operation. Accepts an optional parameter to let the
// listeners know why the backoff operation was started.
Backoff.prototype.backoff = function(err) {
    precond.checkState(this.timeoutID_ === -1, 'Backoff in progress.');

    if (this.backoffNumber_ === this.maxNumberOfRetry_) {
        this.emit('fail', err);
        this.reset();
    } else {
        this.backoffDelay_ = this.backoffStrategy_.next();
        this.timeoutID_ = setTimeout(this.handlers.backoff, this.backoffDelay_);
        this.emit('backoff', this.backoffNumber_, this.backoffDelay_, err);
    }
};

// Handles the backoff timeout completion.
Backoff.prototype.onBackoff_ = function() {
    this.timeoutID_ = -1;
    this.emit('ready', this.backoffNumber_, this.backoffDelay_);
    this.backoffNumber_++;
};

// Stops any backoff operation and resets the backoff delay to its inital value.
Backoff.prototype.reset = function() {
    this.backoffNumber_ = 0;
    this.backoffStrategy_.reset();
    clearTimeout(this.timeoutID_);
    this.timeoutID_ = -1;
};

module.exports = Backoff;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/backoff/lib/function_call.js":
/*!*****************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/backoff/lib/function_call.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var events = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var precond = __webpack_require__(/*! precond */ "../../work/twilio-video.js/node_modules/precond/index.js");
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

var Backoff = __webpack_require__(/*! ./backoff */ "../../work/twilio-video.js/node_modules/backoff/lib/backoff.js");
var FibonacciBackoffStrategy = __webpack_require__(/*! ./strategy/fibonacci */ "../../work/twilio-video.js/node_modules/backoff/lib/strategy/fibonacci.js");

// Wraps a function to be called in a backoff loop.
function FunctionCall(fn, args, callback) {
    events.EventEmitter.call(this);

    precond.checkIsFunction(fn, 'Expected fn to be a function.');
    precond.checkIsArray(args, 'Expected args to be an array.');
    precond.checkIsFunction(callback, 'Expected callback to be a function.');

    this.function_ = fn;
    this.arguments_ = args;
    this.callback_ = callback;
    this.lastResult_ = [];
    this.numRetries_ = 0;

    this.backoff_ = null;
    this.strategy_ = null;
    this.failAfter_ = -1;
    this.retryPredicate_ = FunctionCall.DEFAULT_RETRY_PREDICATE_;

    this.state_ = FunctionCall.State_.PENDING;
}
util.inherits(FunctionCall, events.EventEmitter);

// States in which the call can be.
FunctionCall.State_ = {
    // Call isn't started yet.
    PENDING: 0,
    // Call is in progress.
    RUNNING: 1,
    // Call completed successfully which means that either the wrapped function
    // returned successfully or the maximal number of backoffs was reached.
    COMPLETED: 2,
    // The call was aborted.
    ABORTED: 3
};

// The default retry predicate which considers any error as retriable.
FunctionCall.DEFAULT_RETRY_PREDICATE_ = function(err) {
  return true;
};

// Checks whether the call is pending.
FunctionCall.prototype.isPending = function() {
    return this.state_ == FunctionCall.State_.PENDING;
};

// Checks whether the call is in progress.
FunctionCall.prototype.isRunning = function() {
    return this.state_ == FunctionCall.State_.RUNNING;
};

// Checks whether the call is completed.
FunctionCall.prototype.isCompleted = function() {
    return this.state_ == FunctionCall.State_.COMPLETED;
};

// Checks whether the call is aborted.
FunctionCall.prototype.isAborted = function() {
    return this.state_ == FunctionCall.State_.ABORTED;
};

// Sets the backoff strategy to use. Can only be called before the call is
// started otherwise an exception will be thrown.
FunctionCall.prototype.setStrategy = function(strategy) {
    precond.checkState(this.isPending(), 'FunctionCall in progress.');
    this.strategy_ = strategy;
    return this; // Return this for chaining.
};

// Sets the predicate which will be used to determine whether the errors
// returned from the wrapped function should be retried or not, e.g. a
// network error would be retriable while a type error would stop the
// function call.
FunctionCall.prototype.retryIf = function(retryPredicate) {
    precond.checkState(this.isPending(), 'FunctionCall in progress.');
    this.retryPredicate_ = retryPredicate;
    return this;
};

// Returns all intermediary results returned by the wrapped function since
// the initial call.
FunctionCall.prototype.getLastResult = function() {
    return this.lastResult_.concat();
};

// Returns the number of times the wrapped function call was retried.
FunctionCall.prototype.getNumRetries = function() {
    return this.numRetries_;
};

// Sets the backoff limit.
FunctionCall.prototype.failAfter = function(maxNumberOfRetry) {
    precond.checkState(this.isPending(), 'FunctionCall in progress.');
    this.failAfter_ = maxNumberOfRetry;
    return this; // Return this for chaining.
};

// Aborts the call.
FunctionCall.prototype.abort = function() {
    if (this.isCompleted() || this.isAborted()) {
      return;
    }

    if (this.isRunning()) {
        this.backoff_.reset();
    }

    this.state_ = FunctionCall.State_.ABORTED;
    this.lastResult_ = [new Error('Backoff aborted.')];
    this.emit('abort');
    this.doCallback_();
};

// Initiates the call to the wrapped function. Accepts an optional factory
// function used to create the backoff instance; used when testing.
FunctionCall.prototype.start = function(backoffFactory) {
    precond.checkState(!this.isAborted(), 'FunctionCall is aborted.');
    precond.checkState(this.isPending(), 'FunctionCall already started.');

    var strategy = this.strategy_ || new FibonacciBackoffStrategy();

    this.backoff_ = backoffFactory ?
        backoffFactory(strategy) :
        new Backoff(strategy);

    this.backoff_.on('ready', this.doCall_.bind(this, true /* isRetry */));
    this.backoff_.on('fail', this.doCallback_.bind(this));
    this.backoff_.on('backoff', this.handleBackoff_.bind(this));

    if (this.failAfter_ > 0) {
        this.backoff_.failAfter(this.failAfter_);
    }

    this.state_ = FunctionCall.State_.RUNNING;
    this.doCall_(false /* isRetry */);
};

// Calls the wrapped function.
FunctionCall.prototype.doCall_ = function(isRetry) {
    if (isRetry) {
        this.numRetries_++;
    }
    var eventArgs = ['call'].concat(this.arguments_);
    events.EventEmitter.prototype.emit.apply(this, eventArgs);
    var callback = this.handleFunctionCallback_.bind(this);
    this.function_.apply(null, this.arguments_.concat(callback));
};

// Calls the wrapped function's callback with the last result returned by the
// wrapped function.
FunctionCall.prototype.doCallback_ = function() {
    this.callback_.apply(null, this.lastResult_);
};

// Handles wrapped function's completion. This method acts as a replacement
// for the original callback function.
FunctionCall.prototype.handleFunctionCallback_ = function() {
    if (this.isAborted()) {
        return;
    }

    var args = Array.prototype.slice.call(arguments);
    this.lastResult_ = args; // Save last callback arguments.
    events.EventEmitter.prototype.emit.apply(this, ['callback'].concat(args));

    var err = args[0];
    if (err && this.retryPredicate_(err)) {
        this.backoff_.backoff(err);
    } else {
        this.state_ = FunctionCall.State_.COMPLETED;
        this.doCallback_();
    }
};

// Handles the backoff event by reemitting it.
FunctionCall.prototype.handleBackoff_ = function(number, delay, err) {
    this.emit('backoff', number, delay, err);
};

module.exports = FunctionCall;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/backoff/lib/strategy/exponential.js":
/*!************************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/backoff/lib/strategy/exponential.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");
var precond = __webpack_require__(/*! precond */ "../../work/twilio-video.js/node_modules/precond/index.js");

var BackoffStrategy = __webpack_require__(/*! ./strategy */ "../../work/twilio-video.js/node_modules/backoff/lib/strategy/strategy.js");

// Exponential backoff strategy.
function ExponentialBackoffStrategy(options) {
    BackoffStrategy.call(this, options);
    this.backoffDelay_ = 0;
    this.nextBackoffDelay_ = this.getInitialDelay();
    this.factor_ = ExponentialBackoffStrategy.DEFAULT_FACTOR;

    if (options && options.factor !== undefined) {
        precond.checkArgument(options.factor > 1,
            'Exponential factor should be greater than 1 but got %s.',
            options.factor);
        this.factor_ = options.factor;
    }
}
util.inherits(ExponentialBackoffStrategy, BackoffStrategy);

// Default multiplication factor used to compute the next backoff delay from
// the current one. The value can be overridden by passing a custom factor as
// part of the options.
ExponentialBackoffStrategy.DEFAULT_FACTOR = 2;

ExponentialBackoffStrategy.prototype.next_ = function() {
    this.backoffDelay_ = Math.min(this.nextBackoffDelay_, this.getMaxDelay());
    this.nextBackoffDelay_ = this.backoffDelay_ * this.factor_;
    return this.backoffDelay_;
};

ExponentialBackoffStrategy.prototype.reset_ = function() {
    this.backoffDelay_ = 0;
    this.nextBackoffDelay_ = this.getInitialDelay();
};

module.exports = ExponentialBackoffStrategy;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/backoff/lib/strategy/fibonacci.js":
/*!**********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/backoff/lib/strategy/fibonacci.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

var BackoffStrategy = __webpack_require__(/*! ./strategy */ "../../work/twilio-video.js/node_modules/backoff/lib/strategy/strategy.js");

// Fibonacci backoff strategy.
function FibonacciBackoffStrategy(options) {
    BackoffStrategy.call(this, options);
    this.backoffDelay_ = 0;
    this.nextBackoffDelay_ = this.getInitialDelay();
}
util.inherits(FibonacciBackoffStrategy, BackoffStrategy);

FibonacciBackoffStrategy.prototype.next_ = function() {
    var backoffDelay = Math.min(this.nextBackoffDelay_, this.getMaxDelay());
    this.nextBackoffDelay_ += this.backoffDelay_;
    this.backoffDelay_ = backoffDelay;
    return backoffDelay;
};

FibonacciBackoffStrategy.prototype.reset_ = function() {
    this.nextBackoffDelay_ = this.getInitialDelay();
    this.backoffDelay_ = 0;
};

module.exports = FibonacciBackoffStrategy;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/backoff/lib/strategy/strategy.js":
/*!*********************************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/backoff/lib/strategy/strategy.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//      Copyright (c) 2012 Mathieu Turcotte
//      Licensed under the MIT license.

var events = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

function isDef(value) {
    return value !== undefined && value !== null;
}

// Abstract class defining the skeleton for the backoff strategies. Accepts an
// object holding the options for the backoff strategy:
//
//  * `randomisationFactor`: The randomisation factor which must be between 0
//     and 1 where 1 equates to a randomization factor of 100% and 0 to no
//     randomization.
//  * `initialDelay`: The backoff initial delay in milliseconds.
//  * `maxDelay`: The backoff maximal delay in milliseconds.
function BackoffStrategy(options) {
    options = options || {};

    if (isDef(options.initialDelay) && options.initialDelay < 1) {
        throw new Error('The initial timeout must be greater than 0.');
    } else if (isDef(options.maxDelay) && options.maxDelay < 1) {
        throw new Error('The maximal timeout must be greater than 0.');
    }

    this.initialDelay_ = options.initialDelay || 100;
    this.maxDelay_ = options.maxDelay || 10000;

    if (this.maxDelay_ <= this.initialDelay_) {
        throw new Error('The maximal backoff delay must be ' +
                        'greater than the initial backoff delay.');
    }

    if (isDef(options.randomisationFactor) &&
        (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {
        throw new Error('The randomisation factor must be between 0 and 1.');
    }

    this.randomisationFactor_ = options.randomisationFactor || 0;
}

// Gets the maximal backoff delay.
BackoffStrategy.prototype.getMaxDelay = function() {
    return this.maxDelay_;
};

// Gets the initial backoff delay.
BackoffStrategy.prototype.getInitialDelay = function() {
    return this.initialDelay_;
};

// Template method that computes and returns the next backoff delay in
// milliseconds.
BackoffStrategy.prototype.next = function() {
    var backoffDelay = this.next_();
    var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;
    var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);
    return randomizedDelay;
};

// Computes and returns the next backoff delay. Intended to be overridden by
// subclasses.
BackoffStrategy.prototype.next_ = function() {
    throw new Error('BackoffStrategy.next_() unimplemented.');
};

// Template method that resets the backoff delay to its initial value.
BackoffStrategy.prototype.reset = function() {
    this.reset_();
};

// Resets the backoff delay to its initial value. Intended to be overridden by
// subclasses.
BackoffStrategy.prototype.reset_ = function() {
    throw new Error('BackoffStrategy.reset_() unimplemented.');
};

module.exports = BackoffStrategy;


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/precond/index.js":
/*!*****************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/precond/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright (c) 2012 Mathieu Turcotte
 * Licensed under the MIT license.
 */

module.exports = __webpack_require__(/*! ./lib/checks */ "../../work/twilio-video.js/node_modules/precond/lib/checks.js");

/***/ }),

/***/ "../../work/twilio-video.js/node_modules/precond/lib/checks.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/precond/lib/checks.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright (c) 2012 Mathieu Turcotte
 * Licensed under the MIT license.
 */

var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

var errors = module.exports = __webpack_require__(/*! ./errors */ "../../work/twilio-video.js/node_modules/precond/lib/errors.js");

function failCheck(ExceptionConstructor, callee, messageFormat, formatArgs) {
    messageFormat = messageFormat || '';
    var message = util.format.apply(this, [messageFormat].concat(formatArgs));
    var error = new ExceptionConstructor(message);
    Error.captureStackTrace(error, callee);
    throw error;
}

function failArgumentCheck(callee, message, formatArgs) {
    failCheck(errors.IllegalArgumentError, callee, message, formatArgs);
}

function failStateCheck(callee, message, formatArgs) {
    failCheck(errors.IllegalStateError, callee, message, formatArgs);
}

module.exports.checkArgument = function(value, message) {
    if (!value) {
        failArgumentCheck(arguments.callee, message,
            Array.prototype.slice.call(arguments, 2));
    }
};

module.exports.checkState = function(value, message) {
    if (!value) {
        failStateCheck(arguments.callee, message,
            Array.prototype.slice.call(arguments, 2));
    }
};

module.exports.checkIsDef = function(value, message) {
    if (value !== undefined) {
        return value;
    }

    failArgumentCheck(arguments.callee, message ||
        'Expected value to be defined but was undefined.',
        Array.prototype.slice.call(arguments, 2));
};

module.exports.checkIsDefAndNotNull = function(value, message) {
    // Note that undefined == null.
    if (value != null) {
        return value;
    }

    failArgumentCheck(arguments.callee, message ||
        'Expected value to be defined and not null but got "' +
        typeOf(value) + '".', Array.prototype.slice.call(arguments, 2));
};

// Fixed version of the typeOf operator which returns 'null' for null values
// and 'array' for arrays.
function typeOf(value) {
    var s = typeof value;
    if (s == 'object') {
        if (!value) {
            return 'null';
        } else if (value instanceof Array) {
            return 'array';
        }
    }
    return s;
}

function typeCheck(expect) {
    return function(value, message) {
        var type = typeOf(value);

        if (type == expect) {
            return value;
        }

        failArgumentCheck(arguments.callee, message ||
            'Expected "' + expect + '" but got "' + type + '".',
            Array.prototype.slice.call(arguments, 2));
    };
}

module.exports.checkIsString = typeCheck('string');
module.exports.checkIsArray = typeCheck('array');
module.exports.checkIsNumber = typeCheck('number');
module.exports.checkIsBoolean = typeCheck('boolean');
module.exports.checkIsFunction = typeCheck('function');
module.exports.checkIsObject = typeCheck('object');


/***/ }),

/***/ "../../work/twilio-video.js/node_modules/precond/lib/errors.js":
/*!**********************************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/node_modules/precond/lib/errors.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright (c) 2012 Mathieu Turcotte
 * Licensed under the MIT license.
 */

var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

function IllegalArgumentError(message) {
    Error.call(this, message);
    this.message = message;
}
util.inherits(IllegalArgumentError, Error);

IllegalArgumentError.prototype.name = 'IllegalArgumentError';

function IllegalStateError(message) {
    Error.call(this, message);
    this.message = message;
}
util.inherits(IllegalStateError, Error);

IllegalStateError.prototype.name = 'IllegalStateError';

module.exports.IllegalStateError = IllegalStateError;
module.exports.IllegalArgumentError = IllegalArgumentError;

/***/ }),

/***/ "../../work/twilio-video.js/package.json":
/*!************************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/package.json ***!
  \************************************************************/
/*! exports provided: name, title, description, version, homepage, author, contributors, keywords, repository, devDependencies, engines, license, main, types, scripts, dependencies, browser, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"twilio-video\",\"title\":\"Twilio Video\",\"description\":\"Twilio Video JavaScript Library\",\"version\":\"2.16.1-dev\",\"homepage\":\"https://twilio.com\",\"author\":\"Mark Andrus Roberts <mroberts@twilio.com>\",\"contributors\":[\"Ryan Rowland <rrowland@twilio.com>\",\"Manjesh Malavalli <mmalavalli@twilio.com>\",\"Makarand Patwardhan <mpatwardhan@twilio.com>\"],\"keywords\":[\"twilio\",\"webrtc\",\"library\",\"javascript\",\"video\",\"rooms\"],\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/twilio/twilio-video.js.git\"},\"devDependencies\":{\"@babel/core\":\"^7.14.2\",\"@babel/preset-env\":\"^7.14.2\",\"@babel/preset-typescript\":\"^7.13.0\",\"@types/express\":\"^4.11.0\",\"@types/node\":\"^8.5.1\",\"@types/selenium-webdriver\":\"^3.0.8\",\"@types/ws\":\"^3.2.1\",\"@typescript-eslint/eslint-plugin\":\"^4.13.0\",\"@typescript-eslint/parser\":\"^4.0.0\",\"babel-cli\":\"^6.26.0\",\"babel-preset-es2015\":\"^6.24.1\",\"browserify\":\"^17.0.0\",\"cheerio\":\"^0.22.0\",\"cors\":\"^2.8.5\",\"electron\":\"^9.1.0\",\"envify\":\"^4.0.0\",\"eslint\":\"^6.2.1\",\"eslint-config-standard\":\"^14.0.0\",\"eslint-plugin-import\":\"^2.18.2\",\"eslint-plugin-node\":\"^9.1.0\",\"eslint-plugin-promise\":\"^4.2.1\",\"eslint-plugin-standard\":\"^4.0.1\",\"express\":\"^4.16.2\",\"glob\":\"^7.1.7\",\"ink-docstrap\":\"^1.3.2\",\"inquirer\":\"^7.0.0\",\"is-docker\":\"^2.0.0\",\"jsdoc\":\"^3.5.5\",\"jsdoc-babel\":\"^0.5.0\",\"json-loader\":\"^0.5.7\",\"karma\":\"^5.0.2\",\"karma-browserify\":\"^8.0.0\",\"karma-chrome-launcher\":\"^2.0.0\",\"karma-edgium-launcher\":\"^4.0.0-0\",\"karma-electron\":\"^6.1.0\",\"karma-firefox-launcher\":\"^1.3.0\",\"karma-htmlfile-reporter\":\"^0.3.8\",\"karma-junit-reporter\":\"^1.2.0\",\"karma-mocha\":\"^1.3.0\",\"karma-safari-launcher\":\"^1.0.0\",\"karma-spec-reporter\":\"0.0.32\",\"karma-typescript\":\"^5.5.1\",\"karma-typescript-es6-transform\":\"^5.5.1\",\"mocha\":\"^3.2.0\",\"mock-require\":\"^3.0.3\",\"ncp\":\"^2.0.0\",\"node-http-server\":\"^8.1.2\",\"npm-run-all\":\"^4.0.2\",\"nyc\":\"^15.1.0\",\"requirejs\":\"^2.3.3\",\"rimraf\":\"^2.6.1\",\"simple-git\":\"^1.126.0\",\"sinon\":\"^4.0.1\",\"ts-node\":\"4.0.1\",\"tslint\":\"5.8.0\",\"twilio\":\"^3.49.0\",\"twilio-release-tool\":\"^1.0.2\",\"typescript\":\"^4.0.5\",\"uglify-js\":\"^2.8.22\",\"vinyl-fs\":\"^2.4.4\",\"vinyl-source-stream\":\"^1.1.0\",\"watchify\":\"^3.11.1\",\"webrtc-adapter\":\"^4.1.1\"},\"engines\":{\"node\":\">=0.12\"},\"license\":\"BSD-3-Clause\",\"main\":\"./es5/index.js\",\"types\":\"./tsdef/index.d.ts\",\"scripts\":{\"lint:js\":\"eslint ./lib ./test/*.js ./docker/**/*.js ./test/framework/*.js ./test/lib/*.js ./test/integration/** ./test/unit/** \",\"lint:ts\":\"eslint ./tsdef/*.ts ./lib/**/*.ts\",\"lint\":\"npm-run-all lint:js lint:ts\",\"test:unit\":\"npm-run-all build:es5 test:unit:js test:unit:ts\",\"test:unit:js\":\"nyc --report-dir=./coverage/js --extension=.js --include=lib/**/* --reporter=html --reporter=lcov --reporter=text mocha ./test/unit/index.js\",\"test:unit:ts\":\"nyc --report-dir=./coverage/ts --extension=.ts --include=lib/**/* --reporter=html --reporter=lcov --reporter=text mocha -r ts-node/register ./test/unit/index.ts\",\"test:serversiderender\":\"mocha ./test/serversiderender/index.js\",\"test:integration:adapter\":\"node ./scripts/karma.js karma/integration.adapter.conf.js\",\"test:integration\":\"npm run build:es5 && node ./scripts/karma.js karma/integration.conf.js\",\"test:umd:install\":\"npm install puppeteer@5.5.0\",\"test:umd\":\"mocha ./test/umd/index.js\",\"test:crossbrowser:build:clean\":\"rimraf ./test/crossbrowser/lib ./test/crossbrowser/src/browser/index.js\",\"test:crossbrowser:build:lint\":\"cd ./test/crossbrowser && tslint --project tsconfig.json\",\"test:crossbrowser:build:tsc\":\"cd ./test/crossbrowser && tsc\",\"test:crossbrowser:build:browser\":\"cd ./test/crossbrowser && browserify lib/crossbrowser/src/browser/index.js > src/browser/index.js\",\"test:crossbrowser:build\":\"npm-run-all test:crossbrowser:build:*\",\"test:crossbrowser:test\":\"cd ./test/crossbrowser && mocha --compilers ts:ts-node/register test/integration/spec/**/*.ts\",\"test:crossbrowser\":\"npm-run-all test:crossbrowser:*\",\"test:sdkdriver:build:clean\":\"rimraf ./test/lib/sdkdriver/lib ./test/lib/sdkdriver/test/integration/browser/index.js\",\"test:sdkdriver:build:lint\":\"cd ./test/lib/sdkdriver && tslint --project tsconfig.json\",\"test:sdkdriver:build:tsc\":\"cd ./test/lib/sdkdriver && tsc --rootDir src\",\"test:sdkdriver:build\":\"npm-run-all test:sdkdriver:build:*\",\"test:sdkdriver:test:unit\":\"cd ./test/lib/sdkdriver && mocha --compilers ts:ts-node/register test/unit/spec/**/*.ts\",\"test:sdkdriver:test:integration:browser\":\"cd ./test/lib/sdkdriver/test/integration && browserify browser/browser.js > browser/index.js\",\"test:sdkdriver:test:integration:run\":\"cd ./test/lib/sdkdriver && mocha --compilers ts:ts-node/register test/integration/spec/**/*.ts\",\"test:sdkdriver:test:integration\":\"npm-run-all test:sdkdriver:test:integration:*\",\"test:sdkdriver:test\":\"npm-run-all test:sdkdriver:test:*\",\"test:sdkdriver\":\"npm-run-all test:sdkdriver:*\",\"test:framework:angular:install\":\"cd ./test/framework/twilio-video-angular && rimraf ./node_modules package-lock.json && npm install\",\"test:framework:angular:run\":\"mocha ./test/framework/twilio-video-angular.js\",\"test:framework:angular\":\"npm-run-all test:framework:angular:*\",\"test:framework:no-framework:run\":\"mocha ./test/framework/twilio-video-no-framework.js\",\"test:framework:no-framework\":\"npm-run-all test:framework:no-framework:*\",\"test:framework:react:install\":\"cd ./test/framework/twilio-video-react && rimraf ./node_modules package-lock.json && npm install\",\"test:framework:react:test\":\"node ./scripts/framework.js twilio-video-react\",\"test:framework:react:build\":\"cd ./test/framework/twilio-video-react && npm run build\",\"test:framework:react:run\":\"mocha ./test/framework/twilio-video-react.js\",\"test:framework:react\":\"npm-run-all test:framework:react:*\",\"test:framework:install\":\"npm install chromedriver && npm install selenium-webdriver && npm install geckodriver && npm install puppeteer\",\"test:framework\":\"npm-run-all test:framework:install test:framework:no-framework test:framework:react\",\"test\":\"npm-run-all test:unit test:integration\",\"build:es5\":\"rimraf ./es5 && tsc tsdef/twilio-video-tests.ts --noEmit && tsc\",\"build:js\":\"node ./scripts/build.js ./src/twilio-video.js ./LICENSE.md ./dist/twilio-video.js\",\"build:min.js\":\"uglifyjs ./dist/twilio-video.js -o ./dist/twilio-video.min.js --comments \\\"/^! twilio-video.js/\\\" -b beautify=false,ascii_only=true\",\"build\":\"npm-run-all clean lint docs test:unit test:integration build:es5 build:js build:min.js test:umd\",\"build:quick\":\"npm-run-all clean lint docs build:es5 build:js build:min.js\",\"docs\":\"node ./scripts/docs.js ./dist/docs\",\"watch\":\"tsc -w\",\"clean\":\"rimraf ./coverage ./es5 ./dist\"},\"dependencies\":{\"@twilio/webrtc\":\"4.4.0\",\"backoff\":\"^2.5.0\",\"ws\":\"^7.4.6\",\"xmlhttprequest\":\"^1.8.0\"},\"browser\":{\"ws\":\"./src/ws.js\",\"xmlhttprequest\":\"./src/xmlhttprequest.js\"}}");

/***/ }),

/***/ "../../work/twilio-video.js/src/ws.js":
/*!*********************************************************!*\
  !*** /Users/mpatwardhan/work/twilio-video.js/src/ws.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = WebSocket;


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayLikeToArray; });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayWithoutHoles; });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _assertThisInitialized; });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _createClass; });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _extends; });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _inheritsLoose; });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  Object(_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _iterableToArray; });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _nonIterableSpread; });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutPropertiesLoose; });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _setPrototypeOf; });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _toConsumableArray; });
/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return Object(_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || Object(_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arr) || Object(_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arr) || Object(_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _unsupportedIterableToArray; });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
}

/***/ }),

/***/ "./node_modules/css-vendor/dist/css-vendor.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/css-vendor/dist/css-vendor.esm.js ***!
  \********************************************************/
/*! exports provided: prefix, supportedKeyframes, supportedProperty, supportedValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prefix", function() { return prefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportedKeyframes", function() { return supportedKeyframes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportedProperty", function() { return supportedProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportedValue", function() { return supportedValue; });
/* harmony import */ var is_in_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-in-browser */ "./node_modules/is-in-browser/dist/module.js");
/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");



// Export javascript style and css style vendor prefixes.
var js = '';
var css = '';
var vendor = '';
var browser = '';
var isTouch = is_in_browser__WEBPACK_IMPORTED_MODULE_0__["default"] && 'ontouchstart' in document.documentElement; // We should not do anything if required serverside.

if (is_in_browser__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  // Order matters. We need to check Webkit the last one because
  // other vendors use to add Webkit prefixes to some properties
  var jsCssMap = {
    Moz: '-moz-',
    ms: '-ms-',
    O: '-o-',
    Webkit: '-webkit-'
  };

  var _document$createEleme = document.createElement('p'),
      style = _document$createEleme.style;

  var testProp = 'Transform';

  for (var key in jsCssMap) {
    if (key + testProp in style) {
      js = key;
      css = jsCssMap[key];
      break;
    }
  } // Correctly detect the Edge browser.


  if (js === 'Webkit' && 'msHyphens' in style) {
    js = 'ms';
    css = jsCssMap.ms;
    browser = 'edge';
  } // Correctly detect the Safari browser.


  if (js === 'Webkit' && '-apple-trailing-word' in style) {
    vendor = 'apple';
  }
}
/**
 * Vendor prefix string for the current browser.
 *
 * @type {{js: String, css: String, vendor: String, browser: String}}
 * @api public
 */


var prefix = {
  js: js,
  css: css,
  vendor: vendor,
  browser: browser,
  isTouch: isTouch
};

/**
 * Test if a keyframe at-rule should be prefixed or not
 *
 * @param {String} vendor prefix string for the current browser.
 * @return {String}
 * @api public
 */

function supportedKeyframes(key) {
  // Keyframes is already prefixed. e.g. key = '@-webkit-keyframes a'
  if (key[1] === '-') return key; // No need to prefix IE/Edge. Older browsers will ignore unsupported rules.
  // https://caniuse.com/#search=keyframes

  if (prefix.js === 'ms') return key;
  return "@" + prefix.css + "keyframes" + key.substr(10);
}

// https://caniuse.com/#search=appearance

var appearence = {
  noPrefill: ['appearance'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'appearance') return false;
    if (prefix.js === 'ms') return "-webkit-" + prop;
    return prefix.css + prop;
  }
};

// https://caniuse.com/#search=color-adjust

var colorAdjust = {
  noPrefill: ['color-adjust'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'color-adjust') return false;
    if (prefix.js === 'Webkit') return prefix.css + "print-" + prop;
    return prop;
  }
};

var regExp = /[-\s]+(.)?/g;
/**
 * Replaces the letter with the capital letter
 *
 * @param {String} match
 * @param {String} c
 * @return {String}
 * @api private
 */

function toUpper(match, c) {
  return c ? c.toUpperCase() : '';
}
/**
 * Convert dash separated strings to camel-cased.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */


function camelize(str) {
  return str.replace(regExp, toUpper);
}

/**
 * Convert dash separated strings to pascal cased.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function pascalize(str) {
  return camelize("-" + str);
}

// but we can use a longhand property instead.
// https://caniuse.com/#search=mask

var mask = {
  noPrefill: ['mask'],
  supportedProperty: function supportedProperty(prop, style) {
    if (!/^mask/.test(prop)) return false;

    if (prefix.js === 'Webkit') {
      var longhand = 'mask-image';

      if (camelize(longhand) in style) {
        return prop;
      }

      if (prefix.js + pascalize(longhand) in style) {
        return prefix.css + prop;
      }
    }

    return prop;
  }
};

// https://caniuse.com/#search=text-orientation

var textOrientation = {
  noPrefill: ['text-orientation'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'text-orientation') return false;

    if (prefix.vendor === 'apple' && !prefix.isTouch) {
      return prefix.css + prop;
    }

    return prop;
  }
};

// https://caniuse.com/#search=transform

var transform = {
  noPrefill: ['transform'],
  supportedProperty: function supportedProperty(prop, style, options) {
    if (prop !== 'transform') return false;

    if (options.transform) {
      return prop;
    }

    return prefix.css + prop;
  }
};

// https://caniuse.com/#search=transition

var transition = {
  noPrefill: ['transition'],
  supportedProperty: function supportedProperty(prop, style, options) {
    if (prop !== 'transition') return false;

    if (options.transition) {
      return prop;
    }

    return prefix.css + prop;
  }
};

// https://caniuse.com/#search=writing-mode

var writingMode = {
  noPrefill: ['writing-mode'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'writing-mode') return false;

    if (prefix.js === 'Webkit' || prefix.js === 'ms' && prefix.browser !== 'edge') {
      return prefix.css + prop;
    }

    return prop;
  }
};

// https://caniuse.com/#search=user-select

var userSelect = {
  noPrefill: ['user-select'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'user-select') return false;

    if (prefix.js === 'Moz' || prefix.js === 'ms' || prefix.vendor === 'apple') {
      return prefix.css + prop;
    }

    return prop;
  }
};

// https://caniuse.com/#search=multicolumn
// https://github.com/postcss/autoprefixer/issues/491
// https://github.com/postcss/autoprefixer/issues/177

var breakPropsOld = {
  supportedProperty: function supportedProperty(prop, style) {
    if (!/^break-/.test(prop)) return false;

    if (prefix.js === 'Webkit') {
      var jsProp = "WebkitColumn" + pascalize(prop);
      return jsProp in style ? prefix.css + "column-" + prop : false;
    }

    if (prefix.js === 'Moz') {
      var _jsProp = "page" + pascalize(prop);

      return _jsProp in style ? "page-" + prop : false;
    }

    return false;
  }
};

// See https://github.com/postcss/autoprefixer/issues/324.

var inlineLogicalOld = {
  supportedProperty: function supportedProperty(prop, style) {
    if (!/^(border|margin|padding)-inline/.test(prop)) return false;
    if (prefix.js === 'Moz') return prop;
    var newProp = prop.replace('-inline', '');
    return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
  }
};

// Camelization is required because we can't test using.
// CSS syntax for e.g. in FF.

var unprefixed = {
  supportedProperty: function supportedProperty(prop, style) {
    return camelize(prop) in style ? prop : false;
  }
};

var prefixed = {
  supportedProperty: function supportedProperty(prop, style) {
    var pascalized = pascalize(prop); // Return custom CSS variable without prefixing.

    if (prop[0] === '-') return prop; // Return already prefixed value without prefixing.

    if (prop[0] === '-' && prop[1] === '-') return prop;
    if (prefix.js + pascalized in style) return prefix.css + prop; // Try webkit fallback.

    if (prefix.js !== 'Webkit' && "Webkit" + pascalized in style) return "-webkit-" + prop;
    return false;
  }
};

// https://caniuse.com/#search=scroll-snap

var scrollSnap = {
  supportedProperty: function supportedProperty(prop) {
    if (prop.substring(0, 11) !== 'scroll-snap') return false;

    if (prefix.js === 'ms') {
      return "" + prefix.css + prop;
    }

    return prop;
  }
};

// https://caniuse.com/#search=overscroll-behavior

var overscrollBehavior = {
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'overscroll-behavior') return false;

    if (prefix.js === 'ms') {
      return prefix.css + "scroll-chaining";
    }

    return prop;
  }
};

var propMap = {
  'flex-grow': 'flex-positive',
  'flex-shrink': 'flex-negative',
  'flex-basis': 'flex-preferred-size',
  'justify-content': 'flex-pack',
  order: 'flex-order',
  'align-items': 'flex-align',
  'align-content': 'flex-line-pack' // 'align-self' is handled by 'align-self' plugin.

}; // Support old flex spec from 2012.

var flex2012 = {
  supportedProperty: function supportedProperty(prop, style) {
    var newProp = propMap[prop];
    if (!newProp) return false;
    return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
  }
};

var propMap$1 = {
  flex: 'box-flex',
  'flex-grow': 'box-flex',
  'flex-direction': ['box-orient', 'box-direction'],
  order: 'box-ordinal-group',
  'align-items': 'box-align',
  'flex-flow': ['box-orient', 'box-direction'],
  'justify-content': 'box-pack'
};
var propKeys = Object.keys(propMap$1);

var prefixCss = function prefixCss(p) {
  return prefix.css + p;
}; // Support old flex spec from 2009.


var flex2009 = {
  supportedProperty: function supportedProperty(prop, style, _ref) {
    var multiple = _ref.multiple;

    if (propKeys.indexOf(prop) > -1) {
      var newProp = propMap$1[prop];

      if (!Array.isArray(newProp)) {
        return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
      }

      if (!multiple) return false;

      for (var i = 0; i < newProp.length; i++) {
        if (!(prefix.js + pascalize(newProp[0]) in style)) {
          return false;
        }
      }

      return newProp.map(prefixCss);
    }

    return false;
  }
};

// plugins = [
//   ...plugins,
//    breakPropsOld,
//    inlineLogicalOld,
//    unprefixed,
//    prefixed,
//    scrollSnap,
//    flex2012,
//    flex2009
// ]
// Plugins without 'noPrefill' value, going last.
// 'flex-*' plugins should be at the bottom.
// 'flex2009' going after 'flex2012'.
// 'prefixed' going after 'unprefixed'

var plugins = [appearence, colorAdjust, mask, textOrientation, transform, transition, writingMode, userSelect, breakPropsOld, inlineLogicalOld, unprefixed, prefixed, scrollSnap, overscrollBehavior, flex2012, flex2009];
var propertyDetectors = plugins.filter(function (p) {
  return p.supportedProperty;
}).map(function (p) {
  return p.supportedProperty;
});
var noPrefill = plugins.filter(function (p) {
  return p.noPrefill;
}).reduce(function (a, p) {
  a.push.apply(a, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(p.noPrefill));
  return a;
}, []);

var el;
var cache = {};

if (is_in_browser__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  el = document.createElement('p'); // We test every property on vendor prefix requirement.
  // Once tested, result is cached. It gives us up to 70% perf boost.
  // http://jsperf.com/element-style-object-access-vs-plain-object
  //
  // Prefill cache with known css properties to reduce amount of
  // properties we need to feature test at runtime.
  // http://davidwalsh.name/vendor-prefix

  var computed = window.getComputedStyle(document.documentElement, '');

  for (var key$1 in computed) {
    // eslint-disable-next-line no-restricted-globals
    if (!isNaN(key$1)) cache[computed[key$1]] = computed[key$1];
  } // Properties that cannot be correctly detected using the
  // cache prefill method.


  noPrefill.forEach(function (x) {
    return delete cache[x];
  });
}
/**
 * Test if a property is supported, returns supported property with vendor
 * prefix if required. Returns `false` if not supported.
 *
 * @param {String} prop dash separated
 * @param {Object} [options]
 * @return {String|Boolean}
 * @api public
 */


function supportedProperty(prop, options) {
  if (options === void 0) {
    options = {};
  }

  // For server-side rendering.
  if (!el) return prop; // Remove cache for benchmark tests or return property from the cache.

  if ( true && cache[prop] != null) {
    return cache[prop];
  } // Check if 'transition' or 'transform' natively supported in browser.


  if (prop === 'transition' || prop === 'transform') {
    options[prop] = prop in el.style;
  } // Find a plugin for current prefix property.


  for (var i = 0; i < propertyDetectors.length; i++) {
    cache[prop] = propertyDetectors[i](prop, el.style, options); // Break loop, if value found.

    if (cache[prop]) break;
  } // Reset styles for current property.
  // Firefox can even throw an error for invalid properties, e.g., "0".


  try {
    el.style[prop] = '';
  } catch (err) {
    return false;
  }

  return cache[prop];
}

var cache$1 = {};
var transitionProperties = {
  transition: 1,
  'transition-property': 1,
  '-webkit-transition': 1,
  '-webkit-transition-property': 1
};
var transPropsRegExp = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g;
var el$1;
/**
 * Returns prefixed value transition/transform if needed.
 *
 * @param {String} match
 * @param {String} p1
 * @param {String} p2
 * @return {String}
 * @api private
 */

function prefixTransitionCallback(match, p1, p2) {
  if (p1 === 'var') return 'var';
  if (p1 === 'all') return 'all';
  if (p2 === 'all') return ', all';
  var prefixedValue = p1 ? supportedProperty(p1) : ", " + supportedProperty(p2);
  if (!prefixedValue) return p1 || p2;
  return prefixedValue;
}

if (is_in_browser__WEBPACK_IMPORTED_MODULE_0__["default"]) el$1 = document.createElement('p');
/**
 * Returns prefixed value if needed. Returns `false` if value is not supported.
 *
 * @param {String} property
 * @param {String} value
 * @return {String|Boolean}
 * @api public
 */

function supportedValue(property, value) {
  // For server-side rendering.
  var prefixedValue = value;
  if (!el$1 || property === 'content') return value; // It is a string or a number as a string like '1'.
  // We want only prefixable values here.
  // eslint-disable-next-line no-restricted-globals

  if (typeof prefixedValue !== 'string' || !isNaN(parseInt(prefixedValue, 10))) {
    return prefixedValue;
  } // Create cache key for current value.


  var cacheKey = property + prefixedValue; // Remove cache for benchmark tests or return value from cache.

  if ( true && cache$1[cacheKey] != null) {
    return cache$1[cacheKey];
  } // IE can even throw an error in some cases, for e.g. style.content = 'bar'.


  try {
    // Test value as it is.
    el$1.style[property] = prefixedValue;
  } catch (err) {
    // Return false if value not supported.
    cache$1[cacheKey] = false;
    return false;
  } // If 'transition' or 'transition-property' property.


  if (transitionProperties[property]) {
    prefixedValue = prefixedValue.replace(transPropsRegExp, prefixTransitionCallback);
  } else if (el$1.style[property] === '') {
    // Value with a vendor prefix.
    prefixedValue = prefix.css + prefixedValue; // Hardcode test to convert "flex" to "-ms-flexbox" for IE10.

    if (prefixedValue === '-ms-flex') el$1.style[property] = '-ms-flexbox'; // Test prefixed value.

    el$1.style[property] = prefixedValue; // Return false if value not supported.

    if (el$1.style[property] === '') {
      cache$1[cacheKey] = false;
      return false;
    }
  } // Reset styles for current property.


  el$1.style[property] = ''; // Write current value to cache.

  cache$1[cacheKey] = prefixedValue;
  return cache$1[cacheKey];
}




/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/hyphenate-style-name/index.js":
/*!****************************************************!*\
  !*** ./node_modules/hyphenate-style-name/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* eslint-disable no-var, prefer-template */
var uppercasePattern = /[A-Z]/g
var msPattern = /^ms-/
var cache = {}

function toHyphenLower(match) {
  return '-' + match.toLowerCase()
}

function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) {
    return cache[name]
  }

  var hName = name.replace(uppercasePattern, toHyphenLower)
  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
}

/* harmony default export */ __webpack_exports__["default"] = (hyphenateStyleName);


/***/ }),

/***/ "./node_modules/is-in-browser/dist/module.js":
/*!***************************************************!*\
  !*** ./node_modules/is-in-browser/dist/module.js ***!
  \***************************************************/
/*! exports provided: isBrowser, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

/* harmony default export */ __webpack_exports__["default"] = (isBrowser);


/***/ }),

/***/ "./node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hyphenate-style-name */ "./node_modules/hyphenate-style-name/index.js");


/**
 * Convert camel cased property names to dash separated.
 *
 * @param {Object} style
 * @return {Object}
 */

function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    var key = prop.indexOf('--') === 0 ? prop : Object(hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__["default"])(prop);
    converted[key] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}
/**
 * Allow camel cased property names by converting them back to dasherized.
 *
 * @param {Rule} rule
 */


function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }

      return style;
    }

    return convertCase(style);
  }

  function onChangeValue(value, prop, rule) {
    if (prop.indexOf('--') === 0) {
      return value;
    }

    var hyphenatedProp = Object(hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__["default"])(prop); // There was no camel case in place

    if (prop === hyphenatedProp) return value;
    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

    return null;
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

/* harmony default export */ __webpack_exports__["default"] = (camelCase);


/***/ }),

/***/ "./node_modules/jss-plugin-compose/dist/jss-plugin-compose.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/jss-plugin-compose/dist/jss-plugin-compose.esm.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");


/**
 * Set selector.
 *
 * @param {Object} original rule
 * @param {String} className class string
 * @return {Boolean} flag, indicating function was successfull or not
 */
function registerClass(rule, className) {
  // Skip falsy values
  if (!className) return true; // Support array of class names `{composes: ['foo', 'bar']}`

  if (Array.isArray(className)) {
    for (var index = 0; index < className.length; index++) {
      var isSetted = registerClass(rule, className[index]);
      if (!isSetted) return false;
    }

    return true;
  } // Support space separated class names `{composes: 'foo bar'}`


  if (className.indexOf(' ') > -1) {
    return registerClass(rule, className.split(' '));
  }

  var _ref = rule.options,
      parent = _ref.parent; // It is a ref to a local rule.

  if (className[0] === '$') {
    var refRule = parent.getRule(className.substr(1));

    if (!refRule) {
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_0__["default"])(false, "[JSS] Referenced rule is not defined. \n" + rule.toString()) : undefined;
      return false;
    }

    if (refRule === rule) {
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_0__["default"])(false, "[JSS] Cyclic composition detected. \n" + rule.toString()) : undefined;
      return false;
    }

    parent.classes[rule.key] += " " + parent.classes[refRule.key];
    return true;
  }

  parent.classes[rule.key] += " " + className;
  return true;
}
/**
 * Convert compose property to additional class, remove property from original styles.
 *
 * @param {Rule} rule
 * @api public
 */


function jssCompose() {
  function onProcessStyle(style, rule) {
    if (!('composes' in style)) return style;
    registerClass(rule, style.composes); // Remove composes property to prevent infinite loop.

    delete style.composes;
    return style;
  }

  return {
    onProcessStyle: onProcessStyle
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssCompose);


/***/ }),

/***/ "./node_modules/jss-plugin-default-unit/dist/jss-plugin-default-unit.esm.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/jss-plugin-default-unit/dist/jss-plugin-default-unit.esm.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jss */ "./node_modules/jss/dist/jss.esm.js");


var px = jss__WEBPACK_IMPORTED_MODULE_0__["hasCSSTOMSupport"] && CSS ? CSS.px : 'px';
var ms = jss__WEBPACK_IMPORTED_MODULE_0__["hasCSSTOMSupport"] && CSS ? CSS.ms : 'ms';
var percent = jss__WEBPACK_IMPORTED_MODULE_0__["hasCSSTOMSupport"] && CSS ? CSS.percent : '%';
/**
 * Generated jss-plugin-default-unit CSS property units
 *
 * @type object
 */

var defaultUnits = {
  // Animation properties
  'animation-delay': ms,
  'animation-duration': ms,
  // Background properties
  'background-position': px,
  'background-position-x': px,
  'background-position-y': px,
  'background-size': px,
  // Border Properties
  border: px,
  'border-bottom': px,
  'border-bottom-left-radius': px,
  'border-bottom-right-radius': px,
  'border-bottom-width': px,
  'border-left': px,
  'border-left-width': px,
  'border-radius': px,
  'border-right': px,
  'border-right-width': px,
  'border-top': px,
  'border-top-left-radius': px,
  'border-top-right-radius': px,
  'border-top-width': px,
  'border-width': px,
  'border-block': px,
  'border-block-end': px,
  'border-block-end-width': px,
  'border-block-start': px,
  'border-block-start-width': px,
  'border-block-width': px,
  'border-inline': px,
  'border-inline-end': px,
  'border-inline-end-width': px,
  'border-inline-start': px,
  'border-inline-start-width': px,
  'border-inline-width': px,
  'border-start-start-radius': px,
  'border-start-end-radius': px,
  'border-end-start-radius': px,
  'border-end-end-radius': px,
  // Margin properties
  margin: px,
  'margin-bottom': px,
  'margin-left': px,
  'margin-right': px,
  'margin-top': px,
  'margin-block': px,
  'margin-block-end': px,
  'margin-block-start': px,
  'margin-inline': px,
  'margin-inline-end': px,
  'margin-inline-start': px,
  // Padding properties
  padding: px,
  'padding-bottom': px,
  'padding-left': px,
  'padding-right': px,
  'padding-top': px,
  'padding-block': px,
  'padding-block-end': px,
  'padding-block-start': px,
  'padding-inline': px,
  'padding-inline-end': px,
  'padding-inline-start': px,
  // Mask properties
  'mask-position-x': px,
  'mask-position-y': px,
  'mask-size': px,
  // Width and height properties
  height: px,
  width: px,
  'min-height': px,
  'max-height': px,
  'min-width': px,
  'max-width': px,
  // Position properties
  bottom: px,
  left: px,
  top: px,
  right: px,
  inset: px,
  'inset-block': px,
  'inset-block-end': px,
  'inset-block-start': px,
  'inset-inline': px,
  'inset-inline-end': px,
  'inset-inline-start': px,
  // Shadow properties
  'box-shadow': px,
  'text-shadow': px,
  // Column properties
  'column-gap': px,
  'column-rule': px,
  'column-rule-width': px,
  'column-width': px,
  // Font and text properties
  'font-size': px,
  'font-size-delta': px,
  'letter-spacing': px,
  'text-decoration-thickness': px,
  'text-indent': px,
  'text-stroke': px,
  'text-stroke-width': px,
  'word-spacing': px,
  // Motion properties
  motion: px,
  'motion-offset': px,
  // Outline properties
  outline: px,
  'outline-offset': px,
  'outline-width': px,
  // Perspective properties
  perspective: px,
  'perspective-origin-x': percent,
  'perspective-origin-y': percent,
  // Transform properties
  'transform-origin': percent,
  'transform-origin-x': percent,
  'transform-origin-y': percent,
  'transform-origin-z': percent,
  // Transition properties
  'transition-delay': ms,
  'transition-duration': ms,
  // Alignment properties
  'vertical-align': px,
  'flex-basis': px,
  // Some random properties
  'shape-margin': px,
  size: px,
  gap: px,
  // Grid properties
  grid: px,
  'grid-gap': px,
  'row-gap': px,
  'grid-row-gap': px,
  'grid-column-gap': px,
  'grid-template-rows': px,
  'grid-template-columns': px,
  'grid-auto-rows': px,
  'grid-auto-columns': px,
  // Not existing properties.
  // Used to avoid issues with jss-plugin-expand integration.
  'box-shadow-x': px,
  'box-shadow-y': px,
  'box-shadow-blur': px,
  'box-shadow-spread': px,
  'font-line-height': px,
  'text-shadow-x': px,
  'text-shadow-y': px,
  'text-shadow-blur': px
};

/**
 * Clones the object and adds a camel cased property version.
 */
function addCamelCasedVersion(obj) {
  var regExp = /(-[a-z])/g;

  var replace = function replace(str) {
    return str[1].toUpperCase();
  };

  var newObj = {};

  for (var _key in obj) {
    newObj[_key] = obj[_key];
    newObj[_key.replace(regExp, replace)] = obj[_key];
  }

  return newObj;
}

var units = addCamelCasedVersion(defaultUnits);
/**
 * Recursive deep style passing function
 */

function iterate(prop, value, options) {
  if (value == null) return value;

  if (Array.isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      value[i] = iterate(prop, value[i], options);
    }
  } else if (typeof value === 'object') {
    if (prop === 'fallbacks') {
      for (var innerProp in value) {
        value[innerProp] = iterate(innerProp, value[innerProp], options);
      }
    } else {
      for (var _innerProp in value) {
        value[_innerProp] = iterate(prop + "-" + _innerProp, value[_innerProp], options);
      }
    } // eslint-disable-next-line no-restricted-globals

  } else if (typeof value === 'number' && isNaN(value) === false) {
    var unit = options[prop] || units[prop]; // Add the unit if available, except for the special case of 0px.

    if (unit && !(value === 0 && unit === px)) {
      return typeof unit === 'function' ? unit(value).toString() : "" + value + unit;
    }

    return value.toString();
  }

  return value;
}
/**
 * Add unit to numeric values.
 */


function defaultUnit(options) {
  if (options === void 0) {
    options = {};
  }

  var camelCasedOptions = addCamelCasedVersion(options);

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    for (var prop in style) {
      style[prop] = iterate(prop, style[prop], camelCasedOptions);
    }

    return style;
  }

  function onChangeValue(value, prop) {
    return iterate(prop, value, camelCasedOptions);
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

/* harmony default export */ __webpack_exports__["default"] = (defaultUnit);


/***/ }),

/***/ "./node_modules/jss-plugin-expand/dist/jss-plugin-expand.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jss-plugin-expand/dist/jss-plugin-expand.esm.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A scheme for converting properties from array to regular style.
 * All properties listed below will be transformed to a string separated by space.
 */
var propArray = {
  'background-size': true,
  'background-position': true,
  border: true,
  'border-bottom': true,
  'border-left': true,
  'border-top': true,
  'border-right': true,
  'border-radius': true,
  'border-image': true,
  'border-width': true,
  'border-style': true,
  'border-color': true,
  'box-shadow': true,
  flex: true,
  margin: true,
  padding: true,
  outline: true,
  'transform-origin': true,
  transform: true,
  transition: true
  /**
   * A scheme for converting arrays to regular styles inside of objects.
   * For e.g.: "{position: [0, 0]}" => "background-position: 0 0;".
   */

};
var propArrayInObj = {
  position: true,
  // background-position
  size: true // background-size

  /**
   * A scheme for parsing and building correct styles from passed objects.
   */

};
var propObj = {
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  margin: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  background: {
    attachment: null,
    color: null,
    image: null,
    position: null,
    repeat: null
  },
  border: {
    width: null,
    style: null,
    color: null
  },
  'border-top': {
    width: null,
    style: null,
    color: null
  },
  'border-right': {
    width: null,
    style: null,
    color: null
  },
  'border-bottom': {
    width: null,
    style: null,
    color: null
  },
  'border-left': {
    width: null,
    style: null,
    color: null
  },
  outline: {
    width: null,
    style: null,
    color: null
  },
  'list-style': {
    type: null,
    position: null,
    image: null
  },
  transition: {
    property: null,
    duration: null,
    'timing-function': null,
    timingFunction: null,
    // Needed for avoiding comilation issues with jss-plugin-camel-case
    delay: null
  },
  animation: {
    name: null,
    duration: null,
    'timing-function': null,
    timingFunction: null,
    // Needed to avoid compilation issues with jss-plugin-camel-case
    delay: null,
    'iteration-count': null,
    iterationCount: null,
    // Needed to avoid compilation issues with jss-plugin-camel-case
    direction: null,
    'fill-mode': null,
    fillMode: null,
    // Needed to avoid compilation issues with jss-plugin-camel-case
    'play-state': null,
    playState: null // Needed to avoid compilation issues with jss-plugin-camel-case

  },
  'box-shadow': {
    x: 0,
    y: 0,
    blur: 0,
    spread: 0,
    color: null,
    inset: null
  },
  'text-shadow': {
    x: 0,
    y: 0,
    blur: null,
    color: null
  }
  /**
   * A scheme for converting non-standart properties inside object.
   * For e.g.: include 'border-radius' property inside 'border' object.
   */

};
var customPropObj = {
  border: {
    radius: 'border-radius',
    image: 'border-image',
    width: 'border-width',
    style: 'border-style',
    color: 'border-color'
  },
  'border-bottom': {
    width: 'border-bottom-width',
    style: 'border-bottom-style',
    color: 'border-bottom-color'
  },
  'border-top': {
    width: 'border-top-width',
    style: 'border-top-style',
    color: 'border-top-color'
  },
  'border-left': {
    width: 'border-left-width',
    style: 'border-left-style',
    color: 'border-left-color'
  },
  'border-right': {
    width: 'border-right-width',
    style: 'border-right-style',
    color: 'border-right-color'
  },
  background: {
    size: 'background-size',
    image: 'background-image'
  },
  font: {
    style: 'font-style',
    variant: 'font-variant',
    weight: 'font-weight',
    stretch: 'font-stretch',
    size: 'font-size',
    family: 'font-family',
    lineHeight: 'line-height',
    // Needed to avoid compilation issues with jss-plugin-camel-case
    'line-height': 'line-height'
  },
  flex: {
    grow: 'flex-grow',
    basis: 'flex-basis',
    direction: 'flex-direction',
    wrap: 'flex-wrap',
    flow: 'flex-flow',
    shrink: 'flex-shrink'
  },
  align: {
    self: 'align-self',
    items: 'align-items',
    content: 'align-content'
  },
  grid: {
    'template-columns': 'grid-template-columns',
    templateColumns: 'grid-template-columns',
    'template-rows': 'grid-template-rows',
    templateRows: 'grid-template-rows',
    'template-areas': 'grid-template-areas',
    templateAreas: 'grid-template-areas',
    template: 'grid-template',
    'auto-columns': 'grid-auto-columns',
    autoColumns: 'grid-auto-columns',
    'auto-rows': 'grid-auto-rows',
    autoRows: 'grid-auto-rows',
    'auto-flow': 'grid-auto-flow',
    autoFlow: 'grid-auto-flow',
    row: 'grid-row',
    column: 'grid-column',
    'row-start': 'grid-row-start',
    rowStart: 'grid-row-start',
    'row-end': 'grid-row-end',
    rowEnd: 'grid-row-end',
    'column-start': 'grid-column-start',
    columnStart: 'grid-column-start',
    'column-end': 'grid-column-end',
    columnEnd: 'grid-column-end',
    area: 'grid-area',
    gap: 'grid-gap',
    'row-gap': 'grid-row-gap',
    rowGap: 'grid-row-gap',
    'column-gap': 'grid-column-gap',
    columnGap: 'grid-column-gap'
  }
};

/* eslint-disable no-use-before-define */

/**
 * Map values by given prop.
 *
 * @param {Array} array of values
 * @param {String} original property
 * @param {String} original rule
 * @return {String} mapped values
 */
function mapValuesByProp(value, prop, rule) {
  return value.map(function (item) {
    return objectToArray(item, prop, rule, false, true);
  });
}
/**
 * Convert array to nested array, if needed
 */


function processArray(value, prop, scheme, rule) {
  if (scheme[prop] == null) return value;
  if (value.length === 0) return [];
  if (Array.isArray(value[0])) return processArray(value[0], prop, scheme, rule);

  if (typeof value[0] === 'object') {
    return mapValuesByProp(value, prop, rule);
  }

  return [value];
}
/**
 * Convert object to array.
 */


function objectToArray(value, prop, rule, isFallback, isInArray) {
  if (!(propObj[prop] || customPropObj[prop])) return [];
  var result = []; // Check if exists any non-standard property

  if (customPropObj[prop]) {
    // eslint-disable-next-line no-param-reassign
    value = customPropsToStyle(value, rule, customPropObj[prop], isFallback);
  } // Pass throught all standart props


  if (Object.keys(value).length) {
    for (var baseProp in propObj[prop]) {
      if (value[baseProp]) {
        if (Array.isArray(value[baseProp])) {
          result.push(propArrayInObj[baseProp] === null ? value[baseProp] : value[baseProp].join(' '));
        } else result.push(value[baseProp]);

        continue;
      } // Add default value from props config.


      if (propObj[prop][baseProp] != null) {
        result.push(propObj[prop][baseProp]);
      }
    }
  }

  if (!result.length || isInArray) return result;
  return [result];
}
/**
 * Convert custom properties values to styles adding them to rule directly
 */


function customPropsToStyle(value, rule, customProps, isFallback) {
  for (var prop in customProps) {
    var propName = customProps[prop]; // If current property doesn't exist already in rule - add new one

    if (typeof value[prop] !== 'undefined' && (isFallback || !rule.prop(propName))) {
      var _styleDetector;

      var appendedValue = styleDetector((_styleDetector = {}, _styleDetector[propName] = value[prop], _styleDetector), rule)[propName]; // Add style directly in rule

      if (isFallback) rule.style.fallbacks[propName] = appendedValue;else rule.style[propName] = appendedValue;
    } // Delete converted property to avoid double converting


    delete value[prop];
  }

  return value;
}
/**
 * Detect if a style needs to be converted.
 */


function styleDetector(style, rule, isFallback) {
  for (var prop in style) {
    var value = style[prop];

    if (Array.isArray(value)) {
      // Check double arrays to avoid recursion.
      if (!Array.isArray(value[0])) {
        if (prop === 'fallbacks') {
          for (var index = 0; index < style.fallbacks.length; index++) {
            style.fallbacks[index] = styleDetector(style.fallbacks[index], rule, true);
          }

          continue;
        }

        style[prop] = processArray(value, prop, propArray, rule); // Avoid creating properties with empty values

        if (!style[prop].length) delete style[prop];
      }
    } else if (typeof value === 'object') {
      if (prop === 'fallbacks') {
        style.fallbacks = styleDetector(style.fallbacks, rule, true);
        continue;
      }

      style[prop] = objectToArray(value, prop, rule, isFallback); // Avoid creating properties with empty values

      if (!style[prop].length) delete style[prop];
    } // Maybe a computed value resulting in an empty string
    else if (style[prop] === '') delete style[prop];
  }

  return style;
}
/**
 * Adds possibility to write expanded styles.
 */


function jssExpand() {
  function onProcessStyle(style, rule) {
    if (!style || rule.type !== 'style') return style;

    if (Array.isArray(style)) {
      // Pass rules one by one and reformat them
      for (var index = 0; index < style.length; index++) {
        style[index] = styleDetector(style[index], rule);
      }

      return style;
    }

    return styleDetector(style, rule);
  }

  return {
    onProcessStyle: onProcessStyle
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssExpand);


/***/ }),

/***/ "./node_modules/jss-plugin-extend/dist/jss-plugin-extend.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jss-plugin-extend/dist/jss-plugin-extend.esm.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");



var isObject = function isObject(obj) {
  return obj && typeof obj === 'object' && !Array.isArray(obj);
};

var valueNs = "extendCurrValue" + Date.now();

function mergeExtend(style, rule, sheet, newStyle) {
  var extendType = typeof style.extend; // Extend using a rule name.

  if (extendType === 'string') {
    if (!sheet) return;
    var refRule = sheet.getRule(style.extend);
    if (!refRule) return;

    if (refRule === rule) {
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_1__["default"])(false, "[JSS] A rule tries to extend itself \n" + rule.toString()) : undefined;
      return;
    }

    var parent = refRule.options.parent;

    if (parent) {
      var originalStyle = parent.rules.raw[style.extend];
      extend(originalStyle, rule, sheet, newStyle);
    }

    return;
  } // Extend using an array.


  if (Array.isArray(style.extend)) {
    for (var index = 0; index < style.extend.length; index++) {
      var singleExtend = style.extend[index];
      var singleStyle = typeof singleExtend === 'string' ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, style, {
        extend: singleExtend
      }) : style.extend[index];
      extend(singleStyle, rule, sheet, newStyle);
    }

    return;
  } // Extend is a style object.


  for (var prop in style.extend) {
    if (prop === 'extend') {
      extend(style.extend.extend, rule, sheet, newStyle);
      continue;
    }

    if (isObject(style.extend[prop])) {
      if (!(prop in newStyle)) newStyle[prop] = {};
      extend(style.extend[prop], rule, sheet, newStyle[prop]);
      continue;
    }

    newStyle[prop] = style.extend[prop];
  }
}

function mergeRest(style, rule, sheet, newStyle) {
  // Copy base style.
  for (var prop in style) {
    if (prop === 'extend') continue;

    if (isObject(newStyle[prop]) && isObject(style[prop])) {
      extend(style[prop], rule, sheet, newStyle[prop]);
      continue;
    }

    if (isObject(style[prop])) {
      newStyle[prop] = extend(style[prop], rule, sheet);
      continue;
    }

    newStyle[prop] = style[prop];
  }
}
/**
 * Recursively extend styles.
 */


function extend(style, rule, sheet, newStyle) {
  if (newStyle === void 0) {
    newStyle = {};
  }

  mergeExtend(style, rule, sheet, newStyle);
  mergeRest(style, rule, sheet, newStyle);
  return newStyle;
}
/**
 * Handle `extend` property.
 *
 * @param {Rule} rule
 * @api public
 */


function jssExtend() {
  function onProcessStyle(style, rule, sheet) {
    if ('extend' in style) return extend(style, rule, sheet);
    return style;
  }

  function onChangeValue(value, prop, rule) {
    if (prop !== 'extend') return value; // Value is empty, remove properties set previously.

    if (value == null || value === false) {
      // $FlowFixMe[prop-missing]
      for (var key in rule[valueNs]) {
        rule.prop(key, null);
      } // $FlowFixMe[prop-missing] Flow complains because there is no indexer property in StyleRule


      rule[valueNs] = null;
      return null;
    }

    if (typeof value === 'object') {
      // $FlowFixMe[invalid-in-rhs] This will be an object
      for (var _key in value) {
        // $FlowFixMe[incompatible-use] This will be an object
        rule.prop(_key, value[_key]);
      } // $FlowFixMe[prop-missing] Flow complains because there is no indexer property in StyleRule


      rule[valueNs] = value;
    } // Make sure we don't set the value in the core.


    return null;
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssExtend);


/***/ }),

/***/ "./node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss */ "./node_modules/jss/dist/jss.esm.js");



var at = '@global';
var atPrefix = '@global ';

var GlobalContainerRule =
/*#__PURE__*/
function () {
  function GlobalContainerRule(key, styles, options) {
    this.type = 'global';
    this.at = at;
    this.rules = void 0;
    this.options = void 0;
    this.key = void 0;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    this.rules = new jss__WEBPACK_IMPORTED_MODULE_1__["RuleList"](Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = GlobalContainerRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (rule) this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString() {
    return this.rules.toString();
  };

  return GlobalContainerRule;
}();

var GlobalPrefixedRule =
/*#__PURE__*/
function () {
  function GlobalPrefixedRule(key, style, options) {
    this.type = 'global';
    this.at = at;
    this.options = void 0;
    this.rule = void 0;
    this.isProcessed = false;
    this.key = void 0;
    this.key = key;
    this.options = options;
    var selector = key.substr(atPrefix.length);
    this.rule = options.jss.createRule(selector, style, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));
  }

  var _proto2 = GlobalPrefixedRule.prototype;

  _proto2.toString = function toString(options) {
    return this.rule ? this.rule.toString(options) : '';
  };

  return GlobalPrefixedRule;
}();

var separatorRegExp = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp);
  var scoped = '';

  for (var i = 0; i < parts.length; i++) {
    scoped += scope + " " + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }

  return scoped;
}

function handleNestedGlobalContainerRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;
  var rules = style ? style[at] : null;
  if (!rules) return;

  for (var name in rules) {
    sheet.addRule(name, rules[name], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[at];
}

function handlePrefixedGlobalRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    sheet.addRule(selector, style[prop], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}
/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */


function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (!name) return null;

    if (name === at) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;

    if (parent) {
      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
        options.scoped = false;
      }
    }

    if (options.scoped === false) {
      options.selector = name;
    }

    return null;
  }

  function onProcessRule(rule, sheet) {
    if (rule.type !== 'style' || !sheet) return;
    handleNestedGlobalContainerRule(rule, sheet);
    handlePrefixedGlobalRule(rule, sheet);
  }

  return {
    onCreateRule: onCreateRule,
    onProcessRule: onProcessRule
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssGlobal);


/***/ }),

/***/ "./node_modules/jss-plugin-nested/dist/jss-plugin-nested.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jss-plugin-nested/dist/jss-plugin-nested.esm.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");



var separatorRegExp = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp = /\$([\w-]+)/g;
/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */

function jssNested() {
  // Get a function to be used for $ref replacement.
  function getReplaceRef(container, sheet) {
    return function (match, key) {
      var rule = container.getRule(key) || sheet && sheet.getRule(key);

      if (rule) {
        rule = rule;
        return rule.selector;
      }

       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_1__["default"])(false, "[JSS] Could not find the referenced rule \"" + key + "\" in \"" + (container.options.meta || container.toString()) + "\".") : undefined;
      return key;
    };
  }

  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp);
    var nestedSelectors = nestedProp.split(separatorRegExp);
    var result = '';

    for (var i = 0; i < parentSelectors.length; i++) {
      var parent = parentSelectors[i];

      for (var j = 0; j < nestedSelectors.length; j++) {
        var nested = nestedSelectors[j];
        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.

        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
      }
    }

    return result;
  }

  function getOptions(rule, container, prevOptions) {
    // Options has been already created, now we only increase index.
    if (prevOptions) return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, prevOptions, {
      index: prevOptions.index + 1 // $FlowFixMe[prop-missing]

    });
    var nestingLevel = rule.options.nestingLevel;
    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

    var options = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, rule.options, {
      nestingLevel: nestingLevel,
      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.

    });

    delete options.name;
    return options;
  }

  function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style') return style;
    var styleRule = rule;
    var container = styleRule.options.parent;
    var options;
    var replaceRef;

    for (var prop in style) {
      var isNested = prop.indexOf('&') !== -1;
      var isNestedConditional = prop[0] === '@';
      if (!isNested && !isNestedConditional) continue;
      options = getOptions(styleRule, container, options);

      if (isNested) {
        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
        // all nested rules within the sheet.

        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.

        selector = selector.replace(refRegExp, replaceRef);
        container.addRule(selector, style[prop], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
          selector: selector
        }));
      } else if (isNestedConditional) {
        // Place conditional right after the parent rule to ensure right ordering.
        container.addRule(prop, {}, options) // Flow expects more options but they aren't required
        // And flow doesn't know this will always be a StyleRule which has the addRule method
        // $FlowFixMe[incompatible-use]
        // $FlowFixMe[prop-missing]
        .addRule(styleRule.key, style[prop], {
          selector: styleRule.selector
        });
      }

      delete style[prop];
    }

    return style;
  }

  return {
    onProcessStyle: onProcessStyle
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssNested);


/***/ }),

/***/ "./node_modules/jss-plugin-props-sort/dist/jss-plugin-props-sort.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/jss-plugin-props-sort/dist/jss-plugin-props-sort.esm.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Sort props by length.
 */
function jssPropsSort() {
  var sort = function sort(prop0, prop1) {
    if (prop0.length === prop1.length) {
      return prop0 > prop1 ? 1 : -1;
    }

    return prop0.length - prop1.length;
  };

  return {
    onProcessStyle: function onProcessStyle(style, rule) {
      if (rule.type !== 'style') return style;
      var newStyle = {};
      var props = Object.keys(style).sort(sort);

      for (var i = 0; i < props.length; i++) {
        newStyle[props[i]] = style[props[i]];
      }

      return newStyle;
    }
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssPropsSort);


/***/ }),

/***/ "./node_modules/jss-plugin-rule-value-function/dist/jss-plugin-rule-value-function.esm.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/jss-plugin-rule-value-function/dist/jss-plugin-rule-value-function.esm.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss */ "./node_modules/jss/dist/jss.esm.js");



var now = Date.now();
var fnValuesNs = "fnValues" + now;
var fnRuleNs = "fnStyle" + ++now;

var functionPlugin = function functionPlugin() {
  return {
    onCreateRule: function onCreateRule(name, decl, options) {
      if (typeof decl !== 'function') return null;
      var rule = Object(jss__WEBPACK_IMPORTED_MODULE_1__["createRule"])(name, {}, options);
      rule[fnRuleNs] = decl;
      return rule;
    },
    onProcessStyle: function onProcessStyle(style, rule) {
      // We need to extract function values from the declaration, so that we can keep core unaware of them.
      // We need to do that only once.
      // We don't need to extract functions on each style update, since this can happen only once.
      // We don't support function values inside of function rules.
      if (fnValuesNs in rule || fnRuleNs in rule) return style;
      var fnValues = {};

      for (var prop in style) {
        var value = style[prop];
        if (typeof value !== 'function') continue;
        delete style[prop];
        fnValues[prop] = value;
      } // $FlowFixMe[prop-missing]


      rule[fnValuesNs] = fnValues;
      return style;
    },
    onUpdate: function onUpdate(data, rule, sheet, options) {
      var styleRule = rule; // $FlowFixMe[prop-missing]

      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object
      // will be returned from that function.

      if (fnRule) {
        // Empty object will remove all currently defined props
        // in case function rule returns a falsy value.
        styleRule.style = fnRule(data) || {};

        if (true) {
          for (var prop in styleRule.style) {
            if (typeof styleRule.style[prop] === 'function') {
               true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_0__["default"])(false, '[JSS] Function values inside function rules are not supported.') : undefined;
              break;
            }
          }
        }
      } // $FlowFixMe[prop-missing]


      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.

      if (fnValues) {
        for (var _prop in fnValues) {
          styleRule.prop(_prop, fnValues[_prop](data), options);
        }
      }
    }
  };
};

/* harmony default export */ __webpack_exports__["default"] = (functionPlugin);


/***/ }),

/***/ "./node_modules/jss-plugin-rule-value-observable/dist/jss-plugin-rule-value-observable.esm.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/jss-plugin-rule-value-observable/dist/jss-plugin-rule-value-observable.esm.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! symbol-observable */ "./node_modules/symbol-observable/es/index.js");
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss */ "./node_modules/jss/dist/jss.esm.js");



var isObservable = function isObservable(value) {
  return value && value[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]] && value === value[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]]();
};

var observablePlugin = function observablePlugin(updateOptions) {
  return {
    onCreateRule: function onCreateRule(name, decl, options) {
      if (!isObservable(decl)) return null; // Cast `decl` to `Observable`, since it passed the type guard.

      var style$ = decl;
      var rule = Object(jss__WEBPACK_IMPORTED_MODULE_1__["createRule"])(name, {}, options); // TODO
      // Call `stream.subscribe()` returns a subscription, which should be explicitly
      // unsubscribed from when we know this sheet is no longer needed.

      style$.subscribe(function (style) {
        for (var prop in style) {
          rule.prop(prop, style[prop], updateOptions);
        }
      });
      return rule;
    },
    onProcessRule: function onProcessRule(rule) {
      if (rule && rule.type !== 'style') return;
      var styleRule = rule;
      var style = styleRule.style;

      var _loop = function _loop(prop) {
        var value = style[prop];
        if (!isObservable(value)) return "continue";
        delete style[prop];
        value.subscribe({
          next: function next(nextValue) {
            styleRule.prop(prop, nextValue, updateOptions);
          }
        });
      };

      for (var prop in style) {
        var _ret = _loop(prop);

        if (_ret === "continue") continue;
      }
    }
  };
};

/* harmony default export */ __webpack_exports__["default"] = (observablePlugin);


/***/ }),

/***/ "./node_modules/jss-plugin-template/dist/jss-plugin-template.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jss-plugin-template/dist/jss-plugin-template.esm.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");


var semiWithNl = /;\n/;

/**
 * Naive CSS parser.
 * - Supports only rule body (no selectors)
 * - Requires semicolon and new line after the value (except of last line)
 * - No nested rules support
 */
var parse = function parse(cssText) {
  var style = {};
  var split = cssText.split(semiWithNl);

  for (var i = 0; i < split.length; i++) {
    var decl = (split[i] || '').trim();
    if (!decl) continue;
    var colonIndex = decl.indexOf(':');

    if (colonIndex === -1) {
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_0__["default"])(false, "[JSS] Malformed CSS string \"" + decl + "\"") : undefined;
      continue;
    }

    var prop = decl.substr(0, colonIndex).trim();
    var value = decl.substr(colonIndex + 1).trim();
    style[prop] = value;
  }

  return style;
};

var onProcessRule = function onProcessRule(rule) {
  if (typeof rule.style === 'string') {
    // $FlowFixMe[prop-missing] We can safely assume that rule has the style property
    rule.style = parse(rule.style);
  }
};

function templatePlugin() {
  return {
    onProcessRule: onProcessRule
  };
}

/* harmony default export */ __webpack_exports__["default"] = (templatePlugin);


/***/ }),

/***/ "./node_modules/jss-plugin-vendor-prefixer/dist/jss-plugin-vendor-prefixer.esm.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/jss-plugin-vendor-prefixer/dist/jss-plugin-vendor-prefixer.esm.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var css_vendor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! css-vendor */ "./node_modules/css-vendor/dist/css-vendor.esm.js");
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss */ "./node_modules/jss/dist/jss.esm.js");



/**
 * Add vendor prefix to a property name when needed.
 *
 * @api public
 */

function jssVendorPrefixer() {
  function onProcessRule(rule) {
    if (rule.type === 'keyframes') {
      var atRule = rule;
      atRule.at = Object(css_vendor__WEBPACK_IMPORTED_MODULE_0__["supportedKeyframes"])(atRule.at);
    }
  }

  function prefixStyle(style) {
    for (var prop in style) {
      var value = style[prop];

      if (prop === 'fallbacks' && Array.isArray(value)) {
        style[prop] = value.map(prefixStyle);
        continue;
      }

      var changeProp = false;
      var supportedProp = Object(css_vendor__WEBPACK_IMPORTED_MODULE_0__["supportedProperty"])(prop);
      if (supportedProp && supportedProp !== prop) changeProp = true;
      var changeValue = false;
      var supportedValue$1 = Object(css_vendor__WEBPACK_IMPORTED_MODULE_0__["supportedValue"])(supportedProp, Object(jss__WEBPACK_IMPORTED_MODULE_1__["toCssValue"])(value));
      if (supportedValue$1 && supportedValue$1 !== value) changeValue = true;

      if (changeProp || changeValue) {
        if (changeProp) delete style[prop];
        style[supportedProp || prop] = supportedValue$1 || value;
      }
    }

    return style;
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;
    return prefixStyle(style);
  }

  function onChangeValue(value, prop) {
    return Object(css_vendor__WEBPACK_IMPORTED_MODULE_0__["supportedValue"])(prop, Object(jss__WEBPACK_IMPORTED_MODULE_1__["toCssValue"])(value)) || value;
  }

  return {
    onProcessRule: onProcessRule,
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

/* harmony default export */ __webpack_exports__["default"] = (jssVendorPrefixer);


/***/ }),

/***/ "./node_modules/jss-preset-default/dist/jss-preset-default.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/jss-preset-default/dist/jss-preset-default.esm.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jss_plugin_rule_value_function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jss-plugin-rule-value-function */ "./node_modules/jss-plugin-rule-value-function/dist/jss-plugin-rule-value-function.esm.js");
/* harmony import */ var jss_plugin_rule_value_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss-plugin-rule-value-observable */ "./node_modules/jss-plugin-rule-value-observable/dist/jss-plugin-rule-value-observable.esm.js");
/* harmony import */ var jss_plugin_template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jss-plugin-template */ "./node_modules/jss-plugin-template/dist/jss-plugin-template.esm.js");
/* harmony import */ var jss_plugin_global__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jss-plugin-global */ "./node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js");
/* harmony import */ var jss_plugin_extend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! jss-plugin-extend */ "./node_modules/jss-plugin-extend/dist/jss-plugin-extend.esm.js");
/* harmony import */ var jss_plugin_nested__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jss-plugin-nested */ "./node_modules/jss-plugin-nested/dist/jss-plugin-nested.esm.js");
/* harmony import */ var jss_plugin_compose__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! jss-plugin-compose */ "./node_modules/jss-plugin-compose/dist/jss-plugin-compose.esm.js");
/* harmony import */ var jss_plugin_camel_case__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! jss-plugin-camel-case */ "./node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js");
/* harmony import */ var jss_plugin_default_unit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! jss-plugin-default-unit */ "./node_modules/jss-plugin-default-unit/dist/jss-plugin-default-unit.esm.js");
/* harmony import */ var jss_plugin_expand__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! jss-plugin-expand */ "./node_modules/jss-plugin-expand/dist/jss-plugin-expand.esm.js");
/* harmony import */ var jss_plugin_vendor_prefixer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! jss-plugin-vendor-prefixer */ "./node_modules/jss-plugin-vendor-prefixer/dist/jss-plugin-vendor-prefixer.esm.js");
/* harmony import */ var jss_plugin_props_sort__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! jss-plugin-props-sort */ "./node_modules/jss-plugin-props-sort/dist/jss-plugin-props-sort.esm.js");













var create = function create(options) {
  if (options === void 0) {
    options = {};
  }

  return {
    plugins: [Object(jss_plugin_rule_value_function__WEBPACK_IMPORTED_MODULE_0__["default"])(), Object(jss_plugin_rule_value_observable__WEBPACK_IMPORTED_MODULE_1__["default"])(options.observable), Object(jss_plugin_template__WEBPACK_IMPORTED_MODULE_2__["default"])(), Object(jss_plugin_global__WEBPACK_IMPORTED_MODULE_3__["default"])(), Object(jss_plugin_extend__WEBPACK_IMPORTED_MODULE_4__["default"])(), Object(jss_plugin_nested__WEBPACK_IMPORTED_MODULE_5__["default"])(), Object(jss_plugin_compose__WEBPACK_IMPORTED_MODULE_6__["default"])(), Object(jss_plugin_camel_case__WEBPACK_IMPORTED_MODULE_7__["default"])(), Object(jss_plugin_default_unit__WEBPACK_IMPORTED_MODULE_8__["default"])(options.defaultUnit), Object(jss_plugin_expand__WEBPACK_IMPORTED_MODULE_9__["default"])(), Object(jss_plugin_vendor_prefixer__WEBPACK_IMPORTED_MODULE_10__["default"])(), Object(jss_plugin_props_sort__WEBPACK_IMPORTED_MODULE_11__["default"])()]
  };
};

/* harmony default export */ __webpack_exports__["default"] = (create);


/***/ }),

/***/ "./node_modules/jss/dist/jss.esm.js":
/*!******************************************!*\
  !*** ./node_modules/jss/dist/jss.esm.js ***!
  \******************************************/
/*! exports provided: default, RuleList, SheetsManager, SheetsRegistry, create, createGenerateId, createRule, getDynamicStyles, hasCSSTOMSupport, sheets, toCssValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RuleList", function() { return RuleList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SheetsManager", function() { return SheetsManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SheetsRegistry", function() { return SheetsRegistry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createGenerateId", function() { return createGenerateId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRule", function() { return createRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDynamicStyles", function() { return getDynamicStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasCSSTOMSupport", function() { return hasCSSTOMSupport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sheets", function() { return registry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toCssValue", function() { return toCssValue; });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var is_in_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-in-browser */ "./node_modules/is-in-browser/dist/module.js");
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");








var plainObjectConstrurctor = {}.constructor;
function cloneStyle(style) {
  if (style == null || typeof style !== 'object') return style;
  if (Array.isArray(style)) return style.map(cloneStyle);
  if (style.constructor !== plainObjectConstrurctor) return style;
  var newStyle = {};

  for (var name in style) {
    newStyle[name] = cloneStyle(style[name]);
  }

  return newStyle;
}

/**
 * Create a rule instance.
 */

function createRule(name, decl, options) {
  if (name === void 0) {
    name = 'unnamed';
  }

  var jss = options.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule; // It is an at-rule and it has no instance.

  if (name[0] === '@') {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] Unknown rule " + name) : undefined;
  }

  return null;
}

var join = function join(value, by) {
  var result = '';

  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }

  return result;
};

/**
 * Converts array values to string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */
var toCssValue = function toCssValue(value, ignoreImportant) {
  if (ignoreImportant === void 0) {
    ignoreImportant = false;
  }

  if (!Array.isArray(value)) return value;
  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join(value[i], ' ');
    }
  } else cssValue = join(value, ', '); // Add !important, because it was ignored.


  if (!ignoreImportant && value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
};

/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */
function indentStr(str, indent) {
  var result = '';

  for (var index = 0; index < indent; index++) {
    result += '  ';
  }

  return result + str;
}
/**
 * Converts a Rule to CSS string.
 */


function toCss(selector, style, options) {
  if (options === void 0) {
    options = {};
  }

  var result = '';
  if (!style) return result;
  var _options = options,
      _options$indent = _options.indent,
      indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style.fallbacks;
  if (selector) indent++; // Apply fallbacks first.

  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];

        for (var prop in fallback) {
          var value = fallback[prop];

          if (value != null) {
            if (result) result += '\n';
            result += indentStr(prop + ": " + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      // Object syntax {fallbacks: {prop: value}}
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];

        if (_value != null) {
          if (result) result += '\n';
          result += indentStr(_prop + ": " + toCssValue(_value) + ";", indent);
        }
      }
    }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];

    if (_value2 != null && _prop2 !== 'fallbacks') {
      if (result) result += '\n';
      result += indentStr(_prop2 + ": " + toCssValue(_value2) + ";", indent);
    }
  } // Allow empty style in this case, because properties will be added dynamically.


  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

  if (!selector) return result;
  indent--;
  if (result) result = "\n" + result + "\n";
  return indentStr(selector + " {" + result, indent) + indentStr('}', indent);
}

var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
var escape = (function (str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
});

var BaseStyleRule =
/*#__PURE__*/
function () {
  function BaseStyleRule(key, style, options) {
    this.type = 'style';
    this.key = void 0;
    this.isProcessed = false;
    this.style = void 0;
    this.renderer = void 0;
    this.renderable = void 0;
    this.options = void 0;
    var sheet = options.sheet,
        Renderer = options.Renderer;
    this.key = key;
    this.options = options;
    this.style = style;
    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
  }
  /**
   * Get or set a style property.
   */


  var _proto = BaseStyleRule.prototype;

  _proto.prop = function prop(name, value, options) {
    // It's a getter.
    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

    var force = options ? options.force : false;
    if (!force && this.style[name] === value) return this;
    var newValue = value;

    if (!options || options.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
    }

    var isEmpty = newValue == null || newValue === false;
    var isDefined = name in this.style; // Value is empty and wasn't defined before.

    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

    var remove = isEmpty && isDefined;
    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

    if (this.renderable && this.renderer) {
      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
      return this;
    }

    var sheet = this.options.sheet;

    if (sheet && sheet.attached) {
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, '[JSS] Rule is not linked. Missing sheet option "link: true".') : undefined;
    }

    return this;
  };

  return BaseStyleRule;
}();
var StyleRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_4__["default"])(StyleRule, _BaseStyleRule);

  function StyleRule(key, style, options) {
    var _this;

    _this = _BaseStyleRule.call(this, key, style, options) || this;
    _this.selectorText = void 0;
    _this.id = void 0;
    _this.renderable = void 0;
    var selector = options.selector,
        scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;

    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__["default"])(_this)), sheet);
      _this.selectorText = "." + escape(_this.id);
    }

    return _this;
  }
  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  var _proto2 = StyleRule.prototype;

  /**
   * Apply rule to an element inline.
   */
  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;

    if (renderer) {
      var json = this.toJSON();

      for (var prop in json) {
        renderer.setProperty(renderable, prop, json[prop]);
      }
    }

    return this;
  }
  /**
   * Returns JSON representation of the rule.
   * Fallbacks are not supported.
   * Useful for inline styles.
   */
  ;

  _proto2.toJSON = function toJSON() {
    var json = {};

    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
    }

    return json;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto2.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.selectorText, this.style, opts);
  };

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(StyleRule, [{
    key: "selector",
    set: function set(selector) {
      if (selector === this.selectorText) return;
      this.selectorText = selector;
      var renderer = this.renderer,
          renderable = this.renderable;
      if (!renderable || !renderer) return;
      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    }
    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}(BaseStyleRule);
var pluginStyleRule = {
  onCreateRule: function onCreateRule(name, style, options) {
    if (name[0] === '@' || options.parent && options.parent.type === 'keyframes') {
      return null;
    }

    return new StyleRule(name, style, options);
  }
};

var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
/**
 * Conditional rule for @media, @supports
 */

var ConditionalRule =
/*#__PURE__*/
function () {
  function ConditionalRule(key, styles, options) {
    this.type = 'conditional';
    this.at = void 0;
    this.key = void 0;
    this.query = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    var atMatch = key.match(atRegExp);
    this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

    this.query = options.name || "@" + this.at;
    this.options = options;
    this.rules = new RuleList(Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = ConditionalRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions;
    }

    if (options.indent == null) options.indent = defaultToStringOptions.indent;
    if (options.children == null) options.children = defaultToStringOptions.children;

    if (options.children === false) {
      return this.query + " {}";
    }

    var children = this.rules.toString(options);
    return children ? this.query + " {\n" + children + "\n}" : '';
  };

  return ConditionalRule;
}();
var keyRegExp = /@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule(key, styles, options) {
    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
  }
};

var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
/**
 * Rule for @keyframes
 */

var KeyframesRule =
/*#__PURE__*/
function () {
  function KeyframesRule(key, frames, options) {
    this.type = 'keyframes';
    this.at = '@keyframes';
    this.key = void 0;
    this.name = void 0;
    this.id = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    var nameMatch = key.match(nameRegExp);

    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = 'noname';
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] Bad keyframes name " + key) : undefined;
    }

    this.key = this.type + "-" + this.name;
    this.options = options;
    var scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;
    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
    this.rules = new RuleList(Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      parent: this
    }));

    for (var name in frames) {
      this.rules.add(name, frames[name], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
        parent: this
      }));
    }

    this.rules.process();
  }
  /**
   * Generates a CSS string.
   */


  var _proto = KeyframesRule.prototype;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions$1;
    }

    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
    if (options.children == null) options.children = defaultToStringOptions$1.children;

    if (options.children === false) {
      return this.at + " " + this.id + " {}";
    }

    var children = this.rules.toString(options);
    if (children) children = "\n" + children + "\n";
    return this.at + " " + this.id + " {" + children + "}";
  };

  return KeyframesRule;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp = /\$([\w-]+)/g;

var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
  if (typeof val === 'string') {
    return val.replace(refRegExp, function (match, name) {
      if (name in keyframes) {
        return keyframes[name];
      }

       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] Referenced keyframes rule \"" + name + "\" is not defined.") : undefined;
      return match;
    });
  }

  return val;
};
/**
 * Replace the reference for a animation name.
 */


var replaceRef = function replaceRef(style, prop, keyframes) {
  var value = style[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes);

  if (refKeyframe !== value) {
    style[prop] = refKeyframe;
  }
};

var plugin = {
  onCreateRule: function onCreateRule(key, frames, options) {
    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style' || !sheet) return style;
    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
    return style;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;

    if (!sheet) {
      return val;
    }

    switch (prop) {
      case 'animation':
        return findReferencedKeyframe(val, sheet.keyframes);

      case 'animation-name':
        return findReferencedKeyframe(val, sheet.keyframes);

      default:
        return val;
    }
  }
};

var KeyframeRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_4__["default"])(KeyframeRule, _BaseStyleRule);

  function KeyframeRule() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BaseStyleRule.call.apply(_BaseStyleRule, [this].concat(args)) || this;
    _this.renderable = void 0;
    return _this;
  }

  var _proto = KeyframeRule.prototype;

  /**
   * Generates a CSS string.
   */
  _proto.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.key, this.style, opts);
  };

  return KeyframeRule;
}(BaseStyleRule);
var pluginKeyframeRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (options.parent && options.parent.type === 'keyframes') {
      return new KeyframeRule(key, style, options);
    }

    return null;
  }
};

var FontFaceRule =
/*#__PURE__*/
function () {
  function FontFaceRule(key, style, options) {
    this.type = 'font-face';
    this.at = '@font-face';
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = FontFaceRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.style)) {
      var str = '';

      for (var index = 0; index < this.style.length; index++) {
        str += toCss(this.at, this.style[index]);
        if (this.style[index + 1]) str += '\n';
      }

      return str;
    }

    return toCss(this.at, this.style, options);
  };

  return FontFaceRule;
}();
var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
  }
};

var ViewportRule =
/*#__PURE__*/
function () {
  function ViewportRule(key, style, options) {
    this.type = 'viewport';
    this.at = '@viewport';
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = ViewportRule.prototype;

  _proto.toString = function toString(options) {
    return toCss(this.key, this.style, options);
  };

  return ViewportRule;
}();
var pluginViewportRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
  }
};

var SimpleRule =
/*#__PURE__*/
function () {
  function SimpleRule(key, value, options) {
    this.type = 'simple';
    this.key = void 0;
    this.value = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.value = value;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  var _proto = SimpleRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.value)) {
      var str = '';

      for (var index = 0; index < this.value.length; index++) {
        str += this.key + " " + this.value[index] + ";";
        if (this.value[index + 1]) str += '\n';
      }

      return str;
    }

    return this.key + " " + this.value + ";";
  };

  return SimpleRule;
}();
var keysMap = {
  '@charset': true,
  '@import': true,
  '@namespace': true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule(key, value, options) {
    return key in keysMap ? new SimpleRule(key, value, options) : null;
  }
};

var plugins = [pluginStyleRule, pluginConditionalRule, plugin, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];

var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */

};

var RuleList =
/*#__PURE__*/
function () {
  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.
  // Original styles object.
  // Used to ensure correct rules order.
  function RuleList(options) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.counter = 0;
    this.options = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.options = options;
    this.classes = options.classes;
    this.keyframes = options.keyframes;
  }
  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  var _proto = RuleList.prototype;

  _proto.add = function add(name, decl, ruleOptions) {
    var _this$options = this.options,
        parent = _this$options.parent,
        sheet = _this$options.sheet,
        jss = _this$options.jss,
        Renderer = _this$options.Renderer,
        generateId = _this$options.generateId,
        scoped = _this$options.scoped;

    var options = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
      classes: this.classes,
      parent: parent,
      sheet: sheet,
      jss: jss,
      Renderer: Renderer,
      generateId: generateId,
      scoped: scoped,
      name: name,
      keyframes: this.keyframes,
      selector: undefined
    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
    // we need to make the key unique within this RuleList instance scope.


    var key = name;

    if (name in this.raw) {
      key = name + "-d" + this.counter++;
    } // We need to save the original decl before creating the rule
    // because cache plugin needs to use it as a key to return a cached rule.


    this.raw[key] = decl;

    if (key in this.classes) {
      // E.g. rules inside of @media container
      options.selector = "." + escape(this.classes[key]);
    }

    var rule = createRule(key, decl, options);
    if (!rule) return null;
    this.register(rule);
    var index = options.index === undefined ? this.index.length : options.index;
    this.index.splice(index, 0, rule);
    return rule;
  }
  /**
   * Get a rule.
   */
  ;

  _proto.get = function get(name) {
    return this.map[name];
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.remove = function remove(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.index.indexOf(rule), 1);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.index.indexOf(rule);
  }
  /**
   * Run `onProcessRule()` plugins on every rule.
   */
  ;

  _proto.process = function process() {
    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
    // we end up with very hard-to-track-down side effects.

    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
  }
  /**
   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
   */
  ;

  _proto.register = function register(rule) {
    this.map[rule.key] = rule;

    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id) this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  }
  /**
   * Unregister a rule.
   */
  ;

  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];

    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var name;
    var data;
    var options;

    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      name = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe[invalid-tuple-index]

      data = arguments.length <= 1 ? undefined : arguments[1]; // $FlowFixMe[invalid-tuple-index]

      options = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      data = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe[invalid-tuple-index]

      options = arguments.length <= 1 ? undefined : arguments[1];
      name = null;
    }

    if (name) {
      this.updateOne(this.map[name], data, options);
    } else {
      for (var index = 0; index < this.index.length; index++) {
        this.updateOne(this.index[index], data, options);
      }
    }
  }
  /**
   * Execute plugins, update rule props.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    if (options === void 0) {
      options = defaultUpdateOptions;
    }

    var _this$options2 = this.options,
        plugins = _this$options2.jss.plugins,
        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

    if (rule.rules instanceof RuleList) {
      rule.rules.update(data, options);
      return;
    }

    var styleRule = rule;
    var style = styleRule.style;
    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

    if (options.process && style && style !== styleRule.style) {
      // We need to run the plugins in case new `style` relies on syntax plugins.
      plugins.onProcessStyle(styleRule.style, styleRule, sheet); // Update and add props.

      for (var prop in styleRule.style) {
        var nextValue = styleRule.style[prop];
        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (nextValue !== prevValue) {
          styleRule.prop(prop, nextValue, forceUpdateOptions);
        }
      } // Remove props.


      for (var _prop in style) {
        var _nextValue = styleRule.style[_prop];
        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (_nextValue == null && _nextValue !== _prevValue) {
          styleRule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    var str = '';
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;

    for (var index = 0; index < this.index.length; index++) {
      var rule = this.index[index];
      var css = rule.toString(options); // No need to render an empty rule.

      if (!css && !link) continue;
      if (str) str += '\n';
      str += css;
    }

    return str;
  };

  return RuleList;
}();

var StyleSheet =
/*#__PURE__*/
function () {
  function StyleSheet(styles, options) {
    this.options = void 0;
    this.deployed = void 0;
    this.attached = void 0;
    this.rules = void 0;
    this.renderer = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.queue = void 0;
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });

    if (options.Renderer) {
      this.renderer = new options.Renderer(this);
    }

    this.rules = new RuleList(this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Attach renderable to the render tree.
   */


  var _proto = StyleSheet.prototype;

  _proto.attach = function attach() {
    if (this.attached) return this;
    if (this.renderer) this.renderer.attach();
    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

    if (!this.deployed) this.deploy();
    return this;
  }
  /**
   * Remove renderable from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.attached) return this;
    if (this.renderer) this.renderer.detach();
    this.attached = false;
    return this;
  }
  /**
   * Add a rule to the current stylesheet.
   * Will insert a rule also after the stylesheet has been rendered first time.
   */
  ;

  _proto.addRule = function addRule(name, decl, options) {
    var queue = this.queue; // Plugins can create rules.
    // In order to preserve the right order, we need to queue all `.addRule` calls,
    // which happen after the first `rules.add()` call.

    if (this.attached && !queue) this.queue = [];
    var rule = this.rules.add(name, decl, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);

    if (this.attached) {
      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (queue) queue.push(rule);else {
        this.insertRule(rule);

        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = undefined;
        }
      }
      return rule;
    } // We can't add rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return rule;
  }
  /**
   * Insert rule into the StyleSheet
   */
  ;

  _proto.insertRule = function insertRule(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  }
  /**
   * Create and add rules.
   * Will render also after Style Sheet was rendered the first time.
   */
  ;

  _proto.addRules = function addRules(styles, options) {
    var added = [];

    for (var name in styles) {
      var rule = this.addRule(name, styles[name], options);
      if (rule) added.push(rule);
    }

    return added;
  }
  /**
   * Get a rule by name.
   */
  ;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Delete a rule by name.
   * Returns `true`: if rule has been deleted from the DOM.
   */
  ;

  _proto.deleteRule = function deleteRule(name) {
    var rule = typeof name === 'object' ? name : this.rules.get(name);

    if (!rule || // Style sheet was created without link: true and attached, in this case we
    // won't be able to remove the CSS rule from the DOM.
    this.attached && !rule.renderable) {
      return false;
    }

    this.rules.remove(rule);

    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }

    return true;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Deploy pure CSS string to a renderable.
   */
  ;

  _proto.deploy = function deploy() {
    if (this.renderer) this.renderer.deploy();
    this.deployed = true;
    return this;
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var _this$rules;

    (_this$rules = this.rules).update.apply(_this$rules, arguments);

    return this;
  }
  /**
   * Updates a single rule.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    this.rules.updateOne(rule, data, options);
    return this;
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return StyleSheet;
}();

var PluginsRegistry =
/*#__PURE__*/
function () {
  function PluginsRegistry() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = void 0;
  }

  var _proto = PluginsRegistry.prototype;

  /**
   * Call `onCreateRule` hooks and return an object if returned by a hook.
   */
  _proto.onCreateRule = function onCreateRule(name, decl, options) {
    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
      var rule = this.registry.onCreateRule[i](name, decl, options);
      if (rule) return rule;
    }

    return null;
  }
  /**
   * Call `onProcessRule` hooks.
   */
  ;

  _proto.onProcessRule = function onProcessRule(rule) {
    if (rule.isProcessed) return;
    var sheet = rule.options.sheet;

    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
      this.registry.onProcessRule[i](rule, sheet);
    }

    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  }
  /**
   * Call `onProcessStyle` hooks.
   */
  ;

  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
      // $FlowFixMe[prop-missing]
      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    }
  }
  /**
   * Call `onProcessSheet` hooks.
   */
  ;

  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
      this.registry.onProcessSheet[i](sheet);
    }
  }
  /**
   * Call `onUpdate` hooks.
   */
  ;

  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
    for (var i = 0; i < this.registry.onUpdate.length; i++) {
      this.registry.onUpdate[i](data, rule, sheet, options);
    }
  }
  /**
   * Call `onChangeValue` hooks.
   */
  ;

  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
    var processedValue = value;

    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
    }

    return processedValue;
  }
  /**
   * Register a plugin.
   */
  ;

  _proto.use = function use(newPlugin, options) {
    if (options === void 0) {
      options = {
        queue: 'external'
      };
    }

    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

    if (plugins.indexOf(newPlugin) !== -1) {
      return;
    }

    plugins.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
      for (var name in plugin) {
        if (name in registry) {
          registry[name].push(plugin[name]);
        } else {
           true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] Unknown hook \"" + name + "\".") : undefined;
        }
      }

      return registry;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };

  return PluginsRegistry;
}();

/**
 * Sheets registry to access them all at one place.
 */
var SheetsRegistry =
/*#__PURE__*/
function () {
  function SheetsRegistry() {
    this.registry = [];
  }

  var _proto = SheetsRegistry.prototype;

  /**
   * Register a Style Sheet.
   */
  _proto.add = function add(sheet) {
    var registry = this.registry;
    var index = sheet.options.index;
    if (registry.indexOf(sheet) !== -1) return;

    if (registry.length === 0 || index >= this.index) {
      registry.push(sheet);
      return;
    } // Find a position.


    for (var i = 0; i < registry.length; i++) {
      if (registry[i].options.index > index) {
        registry.splice(i, 0, sheet);
        return;
      }
    }
  }
  /**
   * Reset the registry.
   */
  ;

  _proto.reset = function reset() {
    this.registry = [];
  }
  /**
   * Remove a Style Sheet.
   */
  ;

  _proto.remove = function remove(sheet) {
    var index = this.registry.indexOf(sheet);
    this.registry.splice(index, 1);
  }
  /**
   * Convert all attached sheets to a CSS string.
   */
  ;

  _proto.toString = function toString(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        attached = _ref.attached,
        options = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_6__["default"])(_ref, ["attached"]);

    var css = '';

    for (var i = 0; i < this.registry.length; i++) {
      var sheet = this.registry[i];

      if (attached != null && sheet.attached !== attached) {
        continue;
      }

      if (css) css += '\n';
      css += sheet.toString(options);
    }

    return css;
  };

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(SheetsRegistry, [{
    key: "index",

    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();

/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */

var registry = new SheetsRegistry();

/* eslint-disable */

/**
 * Now that `globalThis` is available on most platforms
 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
 * we check for `globalThis` first. `globalThis` is necessary for jss
 * to run in Agoric's secure version of JavaScript (SES). Under SES,
 * `globalThis` exists, but `window`, `self`, and `Function('return
 * this')()` are all undefined for security reasons.
 *
 * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
 */
var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();

var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.

var moduleId = globalThis$1[ns]++;

var maxRules = 1e10;

/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */
var createGenerateId = function createGenerateId(options) {
  if (options === void 0) {
    options = {};
  }

  var ruleCounter = 0;

  var generateId = function generateId(rule, sheet) {
    ruleCounter += 1;

    if (ruleCounter > maxRules) {
       true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] You might have a memory leak. Rule counter is at " + ruleCounter + ".") : undefined;
    }

    var jssId = '';
    var prefix = '';

    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix = sheet.options.classNamePrefix;
      }

      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }

    if (options.minify) {
      // Using "c" because a number can't be the first char in a class name.
      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
    }

    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
  };

  return generateId;
};

/**
 * Cache the value from the first time a function is called.
 */
var memoize = function memoize(fn) {
  var value;
  return function () {
    if (!value) value = fn();
    return value;
  };
};

/**
 * Get a style property value.
 */
var getPropertyValue = function getPropertyValue(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }

    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
};

/**
 * Set a style property.
 */
var setProperty = function setProperty(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = toCssValue(value, true);

      if (value[value.length - 1] === '!important') {
        cssRule.style.setProperty(prop, cssValue, 'important');
        return true;
      }
    } // Support CSSTOM.


    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      cssRule.style.setProperty(prop, cssValue);
    }
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }

  return true;
};

/**
 * Remove a style property.
 */
var removeProperty = function removeProperty(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] DOMException \"" + err.message + "\" was thrown. Tried to remove property \"" + prop + "\".") : undefined;
  }
};

/**
 * Set the selector.
 */
var setSelector = function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText; // Return false if setter was not successful.
  // Currently works in chrome only.

  return cssRule.selectorText === selectorText;
};
/**
 * Gets the `head` element upon the first call and caches it.
 * We assume it can't be null.
 */


var getHead = memoize(function () {
  return document.querySelector('head');
});
/**
 * Find attached sheet with an index higher than the passed one.
 */

function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find attached sheet with the highest index.
 */


function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find a comment with "jss" inside.
 */


function findCommentNode(text) {
  var head = getHead();

  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];

    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }

  return null;
}

/**
 * Find a node before which we can insert the sheet.
 */
function findPrevNode(options) {
  var registry$1 = registry.registry;

  if (registry$1.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry$1, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    } // Otherwise insert after the last attached.


    sheet = findHighestSheet(registry$1, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  } // Try to find a comment placeholder if registry is empty.


  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);

    if (comment) {
      return {
        parent: comment.parentNode,
        node: comment.nextSibling
      };
    } // If user specifies an insertion point and it can't be found in the document -
    // bad specificity issues may appear.


     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] Insertion point \"" + insertionPoint + "\" not found.") : undefined;
  }

  return false;
}
/**
 * Insert style element into the DOM.
 */


function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;
  var nextNode = findPrevNode(options);

  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style, nextNode.node);
    return;
  } // Works with iframes and any node types.


  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    // https://stackoverflow.com/questions/41328728/force-casting-in-flow
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);else  true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, '[JSS] Insertion point is not in the DOM.') : undefined;
    return;
  }

  getHead().appendChild(style);
}
/**
 * Read jss nonce setting from the page if the user has set it.
 */


var getNonce = memoize(function () {
  var node = document.querySelector('meta[property="csp-nonce"]');
  return node ? node.getAttribute('content') : null;
});

var _insertRule = function insertRule(container, rule, index) {
  try {
    if ('insertRule' in container) {
      var c = container;
      c.insertRule(rule, index);
    } // Keyframes rule.
    else if ('appendRule' in container) {
        var _c = container;

        _c.appendRule(rule);
      }
  } catch (err) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] " + err.message) : undefined;
    return false;
  }

  return container.cssRules[index];
};

var getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

  if (index === undefined || index > maxIndex) {
    // eslint-disable-next-line no-param-reassign
    return maxIndex;
  }

  return index;
};

var createStyle = function createStyle() {
  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
  // insert rules after we insert the style tag.
  // It seems to kick-off the source order specificity algorithm.

  el.textContent = '\n';
  return el;
};

var DomRenderer =
/*#__PURE__*/
function () {
  // HTMLStyleElement needs fixing https://github.com/facebook/flow/issues/2696
  // Will be empty if link: true option is not set, because
  // it is only for use together with insertRule API.
  function DomRenderer(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.element = void 0;
    this.sheet = void 0;
    this.hasInsertedRules = false;
    this.cssRules = [];
    // There is no sheet when the renderer is used from a standalone StyleRule.
    if (sheet) registry.add(sheet);
    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || createStyle();
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    var nonce = getNonce();
    if (nonce) this.element.setAttribute('nonce', nonce);
  }
  /**
   * Insert style element into render tree.
   */


  var _proto = DomRenderer.prototype;

  _proto.attach = function attach() {
    // In the case the element node is external and it is already in the DOM.
    if (this.element.parentNode || !this.sheet) return;
    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
    // most browsers create a new CSSStyleSheet, except of all IEs.

    var deployed = Boolean(this.sheet && this.sheet.deployed);

    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  }
  /**
   * Remove style element from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.sheet) return;
    var parentNode = this.element.parentNode;
    if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
    // Though IE will keep them and we need a consistent behavior.

    if (this.sheet.options.link) {
      this.cssRules = [];
      this.element.textContent = '\n';
    }
  }
  /**
   * Inject CSS string into element.
   */
  ;

  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet) return;

    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }

    this.element.textContent = "\n" + sheet.toString() + "\n";
  }
  /**
   * Insert RuleList into an element.
   */
  ;

  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i = 0; i < rules.index.length; i++) {
      this.insertRule(rules.index[i], i, nativeParent);
    }
  }
  /**
   * Insert a rule into element.
   */
  ;

  _proto.insertRule = function insertRule(rule, index, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }

    if (rule.rules) {
      var parent = rule;
      var latestNativeParent = nativeParent;

      if (rule.type === 'conditional' || rule.type === 'keyframes') {
        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.


        latestNativeParent = _insertRule(nativeParent, parent.toString({
          children: false
        }), _insertionIndex);

        if (latestNativeParent === false) {
          return false;
        }

        this.refCssRule(rule, _insertionIndex, latestNativeParent);
      }

      this.insertRules(parent.rules, latestNativeParent);
      return latestNativeParent;
    }

    var ruleStr = rule.toString();
    if (!ruleStr) return false;
    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);

    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);

    if (nativeRule === false) {
      return false;
    }

    this.hasInsertedRules = true;
    this.refCssRule(rule, insertionIndex, nativeRule);
    return nativeRule;
  };

  _proto.refCssRule = function refCssRule(rule, index, cssRule) {
    rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
    // like rules inside media queries or keyframes

    if (rule.options.parent instanceof StyleSheet) {
      this.cssRules[index] = cssRule;
    }
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return true;
  }
  /**
   * Get index of a CSS Rule.
   */
  ;

  _proto.indexOf = function indexOf(cssRule) {
    return this.cssRules.indexOf(cssRule);
  }
  /**
   * Generate a new CSS rule and replace the existing one.
   *
   * Only used for some old browsers because they can't set a selector.
   */
  ;

  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    this.element.sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return this.insertRule(rule, index);
  }
  /**
   * Get all rules elements.
   */
  ;

  _proto.getRules = function getRules() {
    return this.element.sheet.cssRules;
  };

  return DomRenderer;
}();

var instanceCounter = 0;

var Jss =
/*#__PURE__*/
function () {
  function Jss(options) {
    this.id = instanceCounter++;
    this.version = "10.7.1";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId: createGenerateId,
      Renderer: is_in_browser__WEBPACK_IMPORTED_MODULE_1__["default"] ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });

    for (var i = 0; i < plugins.length; i++) {
      this.plugins.use(plugins[i], {
        queue: 'internal'
      });
    }

    this.setup(options);
  }
  /**
   * Prepares various options, applies plugins.
   * Should not be used twice on the same instance, because there is no plugins
   * deduplication logic.
   */


  var _proto = Jss.prototype;

  _proto.setup = function setup(options) {
    if (options === void 0) {
      options = {};
    }

    if (options.createGenerateId) {
      this.options.createGenerateId = options.createGenerateId;
    }

    if (options.id) {
      this.options.id = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, this.options.id, options.id);
    }

    if (options.createGenerateId || options.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }

    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

    if ('Renderer' in options) {
      this.options.Renderer = options.Renderer;
    } // eslint-disable-next-line prefer-spread


    if (options.plugins) this.use.apply(this, options.plugins);
    return this;
  }
  /**
   * Create a Style Sheet.
   */
  ;

  _proto.createStyleSheet = function createStyleSheet(styles, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        index = _options.index;

    if (typeof index !== 'number') {
      index = registry.index === 0 ? 0 : registry.index + 1;
    }

    var sheet = new StyleSheet(styles, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      jss: this,
      generateId: options.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  }
  /**
   * Detach the Style Sheet and remove it from the registry.
   */
  ;

  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    registry.remove(sheet);
    return this;
  }
  /**
   * Create a rule without a Style Sheet.
   * [Deprecated] will be removed in the next major version.
   */
  ;

  _proto.createRule = function createRule$1(name, style, options) {
    if (style === void 0) {
      style = {};
    }

    if (options === void 0) {
      options = {};
    }

    // Enable rule without name for inline styles.
    if (typeof name === 'object') {
      // $FlowFixMe[incompatible-call]
      return this.createRule(undefined, name, style);
    } // $FlowFixMe[incompatible-type]


    var ruleOptions = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, options, {
      name: name,
      jss: this,
      Renderer: this.options.Renderer
    });

    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes) ruleOptions.classes = {};
    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};

    var rule = createRule(name, style, ruleOptions);

    if (rule) this.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Register plugin. Passed function will be invoked with a rule instance.
   */
  ;

  _proto.use = function use() {
    var _this = this;

    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    plugins.forEach(function (plugin) {
      _this.plugins.use(plugin);
    });
    return this;
  };

  return Jss;
}();

/**
 * Extracts a styles object with only props that contain function values.
 */
function getDynamicStyles(styles) {
  var to = null;

  for (var key in styles) {
    var value = styles[key];
    var type = typeof value;

    if (type === 'function') {
      if (!to) to = {};
      to[key] = value;
    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);

      if (extracted) {
        if (!to) to = {};
        to[key] = extracted;
      }
    }
  }

  return to;
}

/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 */
var SheetsManager =
/*#__PURE__*/
function () {
  function SheetsManager() {
    this.length = 0;
    this.sheets = new WeakMap();
  }

  var _proto = SheetsManager.prototype;

  _proto.get = function get(key) {
    var entry = this.sheets.get(key);
    return entry && entry.sheet;
  };

  _proto.add = function add(key, sheet) {
    if (this.sheets.has(key)) return;
    this.length++;
    this.sheets.set(key, {
      sheet: sheet,
      refs: 0
    });
  };

  _proto.manage = function manage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs === 0) {
        entry.sheet.attach();
      }

      entry.refs++;
      return entry.sheet;
    }

    Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "[JSS] SheetsManager: can't find sheet to manage");
    return undefined;
  };

  _proto.unmanage = function unmanage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs > 0) {
        entry.refs--;
        if (entry.refs === 0) entry.sheet.detach();
      }
    } else {
      Object(tiny_warning__WEBPACK_IMPORTED_MODULE_2__["default"])(false, "SheetsManager: can't find sheet to unmanage");
    }
  };

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(SheetsManager, [{
    key: "size",
    get: function get() {
      return this.length;
    }
  }]);

  return SheetsManager;
}();

/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */

/**
 * Export a constant indicating if this browser has CSSTOM support.
 * https://developers.google.com/web/updates/2018/03/cssom
 */
var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;
/**
 * Creates a new instance of Jss.
 */

var create = function create(options) {
  return new Jss(options);
};
/**
 * A global Jss instance.
 */

var jss = create();

/* harmony default export */ __webpack_exports__["default"] = (jss);



/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/symbol-observable/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/symbol-observable/es/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ "./node_modules/symbol-observable/es/ponyfill.js");
/* global window */


var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {}

var result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__["default"])(root);
/* harmony default export */ __webpack_exports__["default"] = (result);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/symbol-observable/es/ponyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/symbol-observable/es/ponyfill.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return symbolObservablePonyfill; });
function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};


/***/ }),

/***/ "./node_modules/tiny-warning/dist/tiny-warning.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/tiny-warning/dist/tiny-warning.esm.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var isProduction = "development" === 'production';
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

/* harmony default export */ __webpack_exports__["default"] = (warning);


/***/ }),

/***/ "./node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/util/node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb, null, ret) },
            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var twilio_video__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! twilio-video */ "../../work/twilio-video.js/es5/index.js");
/* harmony import */ var twilio_video__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(twilio_video__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _demo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./demo */ "./src/demo.ts");
// import * as Video from 'twilio-video';


Object(_demo__WEBPACK_IMPORTED_MODULE_1__["demo"])(twilio_video__WEBPACK_IMPORTED_MODULE_0___default.a, document.body);


/***/ }),

/***/ "./src/components/button.ts":
/*!**********************************!*\
  !*** ./src/components/button.ts ***!
  \**********************************/
/*! exports provided: createButton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createButton", function() { return createButton; });
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../jss */ "./src/jss.ts");
;

// Create your style.
var style = {
    button: {
        height: '2em',
        margin: '2px',
    },
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_0__["default"].createStyleSheet(style);
sheet.attach();
function createButton(text, container, onClick) {
    var btn = document.createElement('button');
    btn.classList.add(sheet.classes.button);
    btn.innerHTML = text;
    btn.onclick = onClick;
    container.appendChild(btn);
    return {
        btn: btn,
        show: function (visible) { btn.style.display = visible ? 'inline-block' : 'none'; },
        text: function (newText) { btn.innerHTML = newText; },
        click: function () { return onClick(); },
        enable: function () { btn.disabled = false; },
        disable: function () { btn.disabled = true; }
    };
}


/***/ }),

/***/ "./src/components/createCollapsibleDiv.ts":
/*!************************************************!*\
  !*** ./src/components/createCollapsibleDiv.ts ***!
  \************************************************/
/*! exports provided: createCollapsibleDiv_1, createCollapsibleDiv_2, createCollapsibleDiv, createFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCollapsibleDiv_1", function() { return createCollapsibleDiv_1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCollapsibleDiv_2", function() { return createCollapsibleDiv_2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCollapsibleDiv", function() { return createCollapsibleDiv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFieldSet", function() { return createFieldSet; });
/* harmony import */ var _button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./button */ "./src/components/button.ts");
/* harmony import */ var _createDiv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createDiv */ "./src/components/createDiv.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../jss */ "./src/jss.ts");
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};



// Create your style.
var style = {
    roomHeaderDiv: {
        all: 'flex'
    },
    displayContents: {
        display: 'contents'
    },
    legendStyle: {
        overflow: 'hidden',
        'text-align': 'left',
        'background-color': 'black',
        color: 'white',
        padding: "3px 6px"
    },
    nonCollapsedStyle: {
        // border: 'none',
        padding: 0,
    },
    collapsedStyle: {
        border: 'none',
        padding: 0,
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_2__["default"].createStyleSheet(style);
sheet.attach();
function createCollapsibleDiv_1(_a) {
    var container = _a.container, headerText = _a.headerText, divClass = _a.divClass;
    var collapsibleDiv = Object(_createDiv__WEBPACK_IMPORTED_MODULE_1__["createDiv"])(container, ['collapsible']);
    var headerDiv = Object(_createDiv__WEBPACK_IMPORTED_MODULE_1__["createDiv"])(collapsibleDiv, sheet.classes.roomHeaderDiv);
    var innerDiv = Object(_createDiv__WEBPACK_IMPORTED_MODULE_1__["createDiv"])(collapsibleDiv, divClass);
    var display = 'none';
    var showHideButton = Object(_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])("- " + headerText, headerDiv, function () {
        if (innerDiv.style.display === 'none') {
            innerDiv.style.display = display;
            showHideButton.text("- " + headerText);
        }
        else {
            display = innerDiv.style.display;
            innerDiv.style.display = 'none';
            showHideButton.text("+ " + headerText);
        }
    });
    return {
        innerDiv: innerDiv,
        outerDiv: collapsibleDiv
    };
}
function createCollapsibleDiv_2(_a) {
    var container = _a.container, headerText = _a.headerText, divClass = _a.divClass, _b = _a.startHidden, startHidden = _b === void 0 ? false : _b;
    // NOTE: on safari - if the fieldset is styled with display:flex, the legend onClick does not work.
    // we need to remove the display flex from the
    var divClasses = Array.isArray(divClass) ? __spreadArray(__spreadArray([], divClass), [sheet.classes.nonCollapsedStyle]) : [divClass, sheet.classes.nonCollapsedStyle];
    var _c = createFieldSet({ container: container, headerText: headerText, divClasses: divClasses, legendClasses: [sheet.classes.legendStyle] }), collapsibleDiv = _c.fieldset, legend = _c.legend;
    var innerDivDisplayStyle = 'none';
    legend.addEventListener('click', function () {
        var _a, _b;
        console.log('makarand: click');
        if (innerDiv.style.display === 'none') {
            // show
            innerDiv.style.display = innerDivDisplayStyle;
            collapsibleDiv.classList.remove(sheet.classes.collapsedStyle);
            (_a = collapsibleDiv.classList).add.apply(_a, divClasses);
        }
        else {
            // hide
            innerDivDisplayStyle = innerDiv.style.display;
            innerDiv.style.display = 'none';
            (_b = collapsibleDiv.classList).remove.apply(_b, divClasses);
            collapsibleDiv.classList.add(sheet.classes.collapsedStyle);
        }
    });
    var innerDiv = Object(_createDiv__WEBPACK_IMPORTED_MODULE_1__["createDiv"])(collapsibleDiv, [sheet.classes.displayContents]);
    innerDivDisplayStyle = innerDiv.style.display;
    if (startHidden) {
        legend.click();
    }
    return {
        innerDiv: innerDiv,
        outerDiv: collapsibleDiv
    };
}
function createCollapsibleDiv(_a) {
    var container = _a.container, headerText = _a.headerText, divClass = _a.divClass, _b = _a.startHidden, startHidden = _b === void 0 ? false : _b;
    // NOTE: on safari - if the fieldset is styled with display:flex, the legend onClick does not work.
    // we need to remove the display flex from the
    var divClasses = Array.isArray(divClass) ? __spreadArray([], divClass) : [divClass, sheet.classes.nonCollapsedStyle];
    var _c = createFieldSet({ container: container, headerText: "- " + headerText, divClasses: [sheet.classes.nonCollapsedStyle], legendClasses: [sheet.classes.legendStyle] }), collapsibleDiv = _c.fieldset, legend = _c.legend;
    var innerDivDisplayStyle = 'none';
    legend.addEventListener('click', function () {
        if (innerDiv.style.display === 'none') {
            // show
            innerDiv.style.display = innerDivDisplayStyle;
            collapsibleDiv.classList.remove(sheet.classes.collapsedStyle);
            collapsibleDiv.classList.add(sheet.classes.nonCollapsedStyle);
            legend.innerHTML = "- " + headerText;
        }
        else {
            // hide
            innerDivDisplayStyle = innerDiv.style.display;
            innerDiv.style.display = 'none';
            collapsibleDiv.classList.remove(sheet.classes.nonCollapsedStyle);
            collapsibleDiv.classList.add(sheet.classes.collapsedStyle);
            legend.innerHTML = "+ " + headerText;
        }
    });
    var innerDiv = Object(_createDiv__WEBPACK_IMPORTED_MODULE_1__["createDiv"])(collapsibleDiv, divClasses);
    innerDivDisplayStyle = innerDiv.style.display;
    if (startHidden) {
        legend.click();
    }
    return {
        innerDiv: innerDiv,
        outerDiv: collapsibleDiv
    };
}
function createFieldSet(_a) {
    var _b, _c;
    var container = _a.container, headerText = _a.headerText, divClasses = _a.divClasses, _d = _a.legendClasses, legendClasses = _d === void 0 ? [] : _d;
    var fieldset = document.createElement('fieldset');
    var legend = document.createElement("legend");
    legend.innerHTML = headerText;
    (_b = legend.classList).add.apply(_b, legendClasses);
    fieldset.appendChild(legend);
    container.appendChild(fieldset);
    (_c = fieldset.classList).add.apply(_c, divClasses);
    return { fieldset: fieldset, legend: legend };
}


/***/ }),

/***/ "./src/components/createDiv.ts":
/*!*************************************!*\
  !*** ./src/components/createDiv.ts ***!
  \*************************************/
/*! exports provided: createDiv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDiv", function() { return createDiv; });
/* harmony import */ var _createElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createElement */ "./src/components/createElement.ts");

function createDiv(container, divClass, id) {
    divClass = Array.isArray(divClass) ? divClass : [divClass];
    return Object(_createElement__WEBPACK_IMPORTED_MODULE_0__["createElement"])({ container: container, type: 'div', classNames: divClass, id: id });
}


/***/ }),

/***/ "./src/components/createElement.ts":
/*!*****************************************!*\
  !*** ./src/components/createElement.ts ***!
  \*****************************************/
/*! exports provided: createElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return createElement; });
function createElement(_a) {
    var _b;
    var container = _a.container, type = _a.type, id = _a.id, classNames = _a.classNames, style = _a.style, innerHtml = _a.innerHtml;
    var el = document.createElement(type);
    if (id) {
        el.id = id;
    }
    if (classNames) {
        (_b = el.classList).add.apply(_b, classNames);
    }
    if (style) {
        el.setAttribute('style', style);
    }
    if (innerHtml) {
        el.innerHTML = innerHtml;
    }
    container.appendChild(el);
    return el;
}


/***/ }),

/***/ "./src/components/createLabeledCheckbox.ts":
/*!*************************************************!*\
  !*** ./src/components/createLabeledCheckbox.ts ***!
  \*************************************************/
/*! exports provided: createLabeledCheckbox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLabeledCheckbox", function() { return createLabeledCheckbox; });
/* harmony import */ var _createElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createElement */ "./src/components/createElement.ts");

function createLabeledCheckbox(_a) {
    var container = _a.container, labelText = _a.labelText, id = _a.id;
    var checkbox = Object(_createElement__WEBPACK_IMPORTED_MODULE_0__["createElement"])({ container: container, type: 'input', id: id });
    checkbox.setAttribute('type', 'checkbox');
    var label = Object(_createElement__WEBPACK_IMPORTED_MODULE_0__["createElement"])({ container: container, type: 'label', innerHtml: labelText });
    label.setAttribute('for', id);
    return checkbox;
}


/***/ }),

/***/ "./src/components/createLabeledInput.ts":
/*!**********************************************!*\
  !*** ./src/components/createLabeledInput.ts ***!
  \**********************************************/
/*! exports provided: createLabeledInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLabeledInput", function() { return createLabeledInput; });
/* harmony import */ var _createElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createElement */ "./src/components/createElement.ts");

function createLabeledInput(_a) {
    var container = _a.container, labelText = _a.labelText, placeHolder = _a.placeHolder, initialValue = _a.initialValue, _b = _a.labelClasses, labelClasses = _b === void 0 ? [] : _b, _c = _a.inputType, inputType = _c === void 0 ? 'input' : _c, _d = _a.inputClasses, inputClasses = _d === void 0 ? [] : _d;
    var identityLabel = null;
    if (typeof labelText === 'string') {
        identityLabel = Object(_createElement__WEBPACK_IMPORTED_MODULE_0__["createElement"])({ container: container, type: 'label', classNames: labelClasses, innerHtml: labelText });
    }
    else {
        identityLabel = labelText;
    }
    var inputElement = Object(_createElement__WEBPACK_IMPORTED_MODULE_0__["createElement"])({ container: container, type: inputType, classNames: inputClasses });
    inputElement.placeholder = placeHolder;
    if (initialValue) {
        inputElement.value = initialValue;
    }
    return inputElement;
}


/***/ }),

/***/ "./src/components/createLink.ts":
/*!**************************************!*\
  !*** ./src/components/createLink.ts ***!
  \**************************************/
/*! exports provided: createLink */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLink", function() { return createLink; });
/* harmony import */ var _createElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createElement */ "./src/components/createElement.ts");

function createLink(_a) {
    var container = _a.container, linkText = _a.linkText, linkUrl = _a.linkUrl, _b = _a.newTab, newTab = _b === void 0 ? false : _b;
    var a = Object(_createElement__WEBPACK_IMPORTED_MODULE_0__["createElement"])({ container: container, type: 'a' });
    a.appendChild(document.createTextNode(linkText));
    a.title = linkText;
    a.href = linkUrl;
    if (newTab) {
        a.target = '_blank';
    }
    return a;
}


/***/ }),

/***/ "./src/components/createSelection.ts":
/*!*******************************************!*\
  !*** ./src/components/createSelection.ts ***!
  \*******************************************/
/*! exports provided: createSelection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSelection", function() { return createSelection; });
function createSelection(_a) {
    var _b;
    var id = _a.id, container = _a.container, _c = _a.options, options = _c === void 0 ? ['dog', 'cat', 'parrot', 'rabbit'] : _c, _d = _a.title, title = _d === void 0 ? 'Pets' : _d, _e = _a.labelClasses, labelClasses = _e === void 0 ? [] : _e, _f = _a.onChange, onChange = _f === void 0 ? function () { } : _f;
    var select = document.createElement('select');
    if (id) {
        select.id = id;
    }
    for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
        var val = options_1[_i];
        var option = document.createElement('option');
        option.value = val;
        option.text = val;
        select.appendChild(option);
    }
    var label = document.createElement('label');
    label.innerHTML = title;
    label.htmlFor = select.id;
    (_b = label.classList).add.apply(_b, labelClasses);
    select.addEventListener('change', onChange);
    container.appendChild(label).appendChild(select);
    return {
        select: select,
        getValue: function () { return select.value; },
        setValue: function (value) { select.value = value; /* not if the value is not one of the options then a blank value gets selected */ }
    };
}


/***/ }),

/***/ "./src/components/getAudioContext.ts":
/*!*******************************************!*\
  !*** ./src/components/getAudioContext.ts ***!
  \*******************************************/
/*! exports provided: getAudioContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAudioContext", function() { return getAudioContext; });
var audioContext = null;
function getAudioContext() {
    if (!audioContext) {
        audioContext = typeof AudioContext !== 'undefined'
            ? new AudioContext()
            : new window.webkitAudioContext();
    }
    if (!audioContext) {
        throw new Error('Could not create audioContext');
    }
    return audioContext;
}


/***/ }),

/***/ "./src/components/getBooleanUrlParam.ts":
/*!**********************************************!*\
  !*** ./src/components/getBooleanUrlParam.ts ***!
  \**********************************************/
/*! exports provided: getBooleanUrlParam */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBooleanUrlParam", function() { return getBooleanUrlParam; });
function getBooleanUrlParam(paramName, defaultValue) {
    var urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has(paramName)) {
        var paramValue = urlParams.get(paramName);
        if (paramValue === null) {
            return defaultValue;
        }
        else if (paramValue.length === 0) {
            // when url=www.foo.com?autoJoin&bar
            // urlParams.get('autoJoin') returns ''
            // ?autoJoin&foo should return autoJoin = true;
            return true;
        }
        else if (!paramValue || paramValue.toLowerCase() === 'false') {
            return false;
        }
        else {
            return true;
        }
    }
    return defaultValue;
}


/***/ }),

/***/ "./src/components/labeledstat.ts":
/*!***************************************!*\
  !*** ./src/components/labeledstat.ts ***!
  \***************************************/
/*! exports provided: createLabeledStat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLabeledStat", function() { return createLabeledStat; });
/* harmony import */ var _createElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createElement */ "./src/components/createElement.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../jss */ "./src/jss.ts");


// Create your style.
var style = {
    labeledStat: {
        background: 'solid green 2px',
        margin: '2px'
    },
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_1__["default"].createStyleSheet(style);
sheet.attach();
;
function createLabeledStat(_a) {
    var container = _a.container, label = _a.label, id = _a.id, valueMapper = _a.valueMapper;
    var classNames = [sheet.classes.labeledStat];
    var el = Object(_createElement__WEBPACK_IMPORTED_MODULE_0__["createElement"])({ container: container, type: 'p', id: id, classNames: classNames });
    var lastClass;
    return {
        element: el,
        setLabel: function (newLabel) {
            label = newLabel;
        },
        setText: function (text) {
            if (lastClass) {
                el.classList.remove(lastClass);
            }
            el.textContent = label + ': ' + text;
            if (valueMapper) {
                lastClass = valueMapper(text);
                if (lastClass) {
                    el.classList.add(lastClass);
                }
            }
        }
    };
}


/***/ }),

/***/ "./src/components/log.ts":
/*!*******************************!*\
  !*** ./src/components/log.ts ***!
  \*******************************/
/*! exports provided: createLog, log */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLog", function() { return createLog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony import */ var _button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./button */ "./src/components/button.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../jss */ "./src/jss.ts");
/* eslint-disable no-console */


// Create your style.
var style = {
    logDiv: {
        height: '15em',
        padding: '1.5em',
        'min-height': '100%',
        'max-height': '100%',
        'margin-top': '3.125em',
        'text-align': 'left',
        'overflow-y': 'scroll',
    },
    logP: {
        color: '#686865',
        width: '90%',
        'font-family': '\'Share Tech Mono\', \'Courier New\', Courier, fixed-width',
        'font-size': '1.25em',
        'line-height': '1.25em',
        'margin-left': '1em',
        'text-indent': '-1.25em',
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_1__["default"].createStyleSheet(style);
sheet.attach();
var logClearBtn;
var realLogDiv;
function createLog(logDiv) {
    if (!logClearBtn) {
        if (!logDiv) {
            logDiv = document.createElement('div');
            logDiv.classList.add(sheet.classes.logDiv);
            document.body.appendChild(logDiv);
        }
        logClearBtn = Object(_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('clear log', logDiv, function () {
            realLogDiv.innerHTML = '';
        });
        realLogDiv = document.createElement('div');
        logDiv.appendChild(realLogDiv);
    }
}
function log() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    createLog();
    var message = args.map(function (arg) { return String(arg); }).join(', ');
    realLogDiv.innerHTML += '<p>' + message + '</p>';
    realLogDiv.scrollTop = realLogDiv.scrollHeight;
    console.log.apply(console, args);
}


/***/ }),

/***/ "./src/components/syntheticaudio.ts":
/*!******************************************!*\
  !*** ./src/components/syntheticaudio.ts ***!
  \******************************************/
/*! exports provided: syntheticAudio */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "syntheticAudio", function() { return syntheticAudio; });
/* harmony import */ var _getAudioContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getAudioContext */ "./src/components/getAudioContext.ts");

function syntheticAudio() {
    var audioContext = Object(_getAudioContext__WEBPACK_IMPORTED_MODULE_0__["getAudioContext"])();
    var oscillator = audioContext.createOscillator();
    var dst = oscillator.connect(audioContext.createMediaStreamDestination());
    oscillator.start();
    var track = dst.stream.getAudioTracks()[0];
    var originalStop = track.stop;
    track.stop = function () {
        originalStop.call(track);
    };
    return track;
}


/***/ }),

/***/ "./src/components/syntheticvideo.ts":
/*!******************************************!*\
  !*** ./src/components/syntheticvideo.ts ***!
  \******************************************/
/*! exports provided: syntheticVideo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "syntheticVideo", function() { return syntheticVideo; });
function syntheticVideo(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.width, width = _c === void 0 ? 640 : _c, _d = _b.height, height = _d === void 0 ? 480 : _d, _e = _b.word, word = _e === void 0 ? 'hello' : _e;
    var canvas = Object.assign(document.createElement('canvas'), { width: width, height: height });
    var ctx = canvas.getContext('2d');
    ctx.fillStyle = 'green';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    // const wordWidth = ctx.measureText(word).width;
    var r = 0;
    var i = 0;
    var stopped = false;
    requestAnimationFrame(function animate() {
        r += Math.PI / 180;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(r);
        ctx.font = '30px Verdana';
        ctx.textAlign = 'center';
        ctx.fillText(word + "-" + i, 0, 0);
        i++;
        ctx.restore();
        if (!stopped) {
            requestAnimationFrame(animate);
        }
    });
    var stream = canvas.captureStream(10);
    var track = stream.getTracks()[0];
    var originalStop = track.stop;
    track.stop = function () {
        stopped = true;
        originalStop.call(track);
    };
    return track;
}


/***/ }),

/***/ "./src/components/waveform.ts":
/*!************************************!*\
  !*** ./src/components/waveform.ts ***!
  \************************************/
/*! exports provided: waveform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "waveform", function() { return waveform; });
/* harmony import */ var _getAudioContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getAudioContext */ "./src/components/getAudioContext.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../jss */ "./src/jss.ts");

var FFT_SIZE = 512;

// Create your style.
var style = {
    background_gray: {
        background: '#bbbbbb'
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_1__["default"].createStyleSheet(style);
sheet.attach();
function waveform(_a) {
    var _b = _a.width, width = _b === void 0 ? 200 : _b, _c = _a.height, height = _c === void 0 ? 150 : _c, mediaStream = _a.mediaStream;
    var stopped = false;
    var canvas = Object.assign(document.createElement('canvas'), { width: width, height: height });
    canvas.classList.add(sheet.classes.background_gray);
    // To manipulate the canvas, we use its context. The canvas refers to the DOM element itself,
    // while the canvas refers to the underlying implementation which can be drawn to.
    var canvasContext = canvas.getContext('2d');
    canvasContext.lineWidth = 4;
    canvasContext.strokeStyle = 'rgb(0, 0, 0)';
    // We will get the frequency data by using an AnalyserNode, a feature of the AudioContext APIs.
    var audioContext = Object(_getAudioContext__WEBPACK_IMPORTED_MODULE_0__["getAudioContext"])();
    var analyser = audioContext.createAnalyser();
    // The FFT (fast fourier transform) takes a size parameter, which determines how many frequency
    // bins the audio is dissected into. Each frame, we will analyze the audio, and AnalyserNode
    // will update our buffer array. We can then inspect the array to see and render the specific
    // data values.
    analyser.fftSize = FFT_SIZE;
    var dataArray = new Uint8Array(analyser.frequencyBinCount);
    function renderFrame() {
        if (stopped) {
            return;
        }
        var bufferLength = analyser.frequencyBinCount;
        var canvasCtx = canvasContext;
        // Ask the browser to run this function again on the next animation frame. The frames
        // drawn per second here depend on browser, but generally this is 30 or 60 fps.
        requestAnimationFrame(renderFrame);
        // Get the current frequency data from the audio stream.
        analyser.getByteTimeDomainData(dataArray);
        // Reset the canvas
        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
        canvasCtx.beginPath();
        // Each byte of frequency will be drawn to the canvas, so each byte of frequency represents
        // a certain slice of the full width of the canvas.
        var sliceWidth = width / bufferLength;
        // For each byte of frequency, draw a slice to the canvas. Together, the canvas will be
        // covered by the resulting slices from left to right.
        var x = 0;
        for (var i = 0; i < bufferLength; i++) {
            var v = dataArray[i] / 128.0;
            v *= v;
            var y = v * height / 2;
            if (i === 0) {
                canvasCtx.moveTo(x, y);
            }
            else {
                canvasCtx.lineTo(x, y);
            }
            x += sliceWidth;
        }
        // End the line at the middle right, and draw the line.
        canvasCtx.lineTo(canvas.width, canvas.height / 2);
        canvasCtx.stroke();
    }
    audioContext.resume().then(function () {
        // Create a new audio source for the passed stream, and connect it to the analyser.
        var audioSource = audioContext.createMediaStreamSource(mediaStream);
        audioSource.connect(analyser);
        // Start the render loop
        renderFrame();
    });
    return {
        element: canvas,
        stop: function () {
            stopped = true;
        }
    };
}


/***/ }),

/***/ "./src/createLocalTracksControls.ts":
/*!******************************************!*\
  !*** ./src/createLocalTracksControls.ts ***!
  \******************************************/
/*! exports provided: createLocalTracksControls */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLocalTracksControls", function() { return createLocalTracksControls; });
/* harmony import */ var _components_button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/button */ "./src/components/button.ts");
/* harmony import */ var _components_createDiv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/createDiv */ "./src/components/createDiv.ts");
/* harmony import */ var _components_syntheticaudio__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/syntheticaudio */ "./src/components/syntheticaudio.ts");
/* harmony import */ var _components_syntheticvideo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/syntheticvideo */ "./src/components/syntheticvideo.ts");
/* harmony import */ var _components_getBooleanUrlParam__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/getBooleanUrlParam */ "./src/components/getBooleanUrlParam.ts");
/* harmony import */ var _getDeviceSelectionOptions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDeviceSelectionOptions */ "./src/getDeviceSelectionOptions.ts");
/* harmony import */ var _renderLocalTrack__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderLocalTrack */ "./src/renderLocalTrack.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./jss */ "./src/jss.ts");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/* eslint-disable no-console */








// Create your style.
var style = {
    localTracksDiv: {
        width: 'inherit',
    },
    trackRenders: {
        display: 'flex',
        'flex-wrap': 'wrap',
    },
    trackButtonsContainer: {
        'text-align': 'left',
        'display': 'flex',
        'flex-flow': 'row wrap'
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_7__["default"].createStyleSheet(style);
sheet.attach();
function createLocalTracksControls(_a) {
    var _this = this;
    var buttonContainer = _a.buttonContainer, container = _a.container, rooms = _a.rooms, Video = _a.Video, localTracks = _a.localTracks, shouldAutoAttach = _a.shouldAutoAttach, shouldAutoPublish = _a.shouldAutoPublish;
    var number = 0;
    var autoAudio = Object(_components_getBooleanUrlParam__WEBPACK_IMPORTED_MODULE_4__["getBooleanUrlParam"])('autoAudio', false);
    var autoVideo = Object(_components_getBooleanUrlParam__WEBPACK_IMPORTED_MODULE_4__["getBooleanUrlParam"])('autoVideo', false);
    var localTrackButtonsContainer = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_1__["createDiv"])(buttonContainer, sheet.classes.trackButtonsContainer);
    var localTracksContainer = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_1__["createDiv"])(container, sheet.classes.trackRenders);
    var renderedTracks = new Map();
    function renderLocalTrack2(track, videoDevices) {
        if (videoDevices === void 0) { videoDevices = []; }
        localTracks.push(track);
        renderedTracks.set(track, Object(_renderLocalTrack__WEBPACK_IMPORTED_MODULE_6__["renderLocalTrack"])({
            container: localTracksContainer,
            rooms: rooms,
            track: track,
            videoDevices: videoDevices,
            autoAttach: shouldAutoAttach(),
            autoPublish: shouldAutoPublish(),
            onClosed: function () {
                var index = localTracks.indexOf(track);
                if (index > -1) {
                    localTracks.splice(index, 1);
                }
                renderedTracks.delete(track);
            }
        }));
    }
    function renderStandAloneMediaStreamTrack(_a) {
        var msTrack = _a.msTrack, _b = _a.autoAttach, autoAttach = _b === void 0 ? true : _b;
        var localTrack = msTrack.kind === 'video' ?
            new Video.LocalVideoTrack(msTrack, { logLevel: 'warn', name: 'my-video', workaroundWebKitBug1208516: false }) :
            new Video.LocalAudioTrack(msTrack, { logLevel: 'warn', name: 'my-audio', workaroundWebKitBug1208516: false });
        Object(_renderLocalTrack__WEBPACK_IMPORTED_MODULE_6__["renderLocalTrack"])({ container: localTracksContainer, rooms: [], track: localTrack, videoDevices: [], autoAttach: autoAttach, autoPublish: false, onClosed: function () { } });
    }
    // eslint-disable-next-line no-unused-vars
    var btnPreviewAudio = Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('+ Local Audio', localTrackButtonsContainer, function () { return __awaiter(_this, void 0, void 0, function () {
        var thisTrackName, localTrack;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    thisTrackName = 'mic-' + number++;
                    return [4 /*yield*/, Video.createLocalAudioTrack({ logLevel: 'warn', name: thisTrackName })];
                case 1:
                    localTrack = _a.sent();
                    renderLocalTrack2(localTrack);
                    return [2 /*return*/];
            }
        });
    }); });
    // eslint-disable-next-line no-unused-vars
    var btnSyntheticAudio = Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('+ Synthetic Audio', localTrackButtonsContainer, function () { return __awaiter(_this, void 0, void 0, function () {
        var thisTrackName, msTrack, localTrack;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    thisTrackName = 'Audio-' + number++;
                    return [4 /*yield*/, Object(_components_syntheticaudio__WEBPACK_IMPORTED_MODULE_2__["syntheticAudio"])()];
                case 1:
                    msTrack = _a.sent();
                    localTrack = new Video.LocalAudioTrack(msTrack, { logLevel: 'warn', name: thisTrackName });
                    renderLocalTrack2(localTrack);
                    return [2 /*return*/];
            }
        });
    }); });
    // eslint-disable-next-line no-unused-vars
    var btnPreviewVideo = Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('+ Local Video', localTrackButtonsContainer, function () { return __awaiter(_this, void 0, void 0, function () {
        var thisTrackName, localTrack;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    thisTrackName = 'camera-' + number++;
                    return [4 /*yield*/, Video.createLocalVideoTrack({ width: 1280, height: 720, logLevel: 'warn', name: thisTrackName })];
                case 1:
                    localTrack = _a.sent();
                    renderLocalTrack2(localTrack);
                    return [2 /*return*/];
            }
        });
    }); });
    var btnSyntheticVideo = Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('+ Synthetic Video', localTrackButtonsContainer, function () { return __awaiter(_this, void 0, void 0, function () {
        var thisTrackName, msTrack, localTrack;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    thisTrackName = 'V-' + number++;
                    return [4 /*yield*/, Object(_components_syntheticvideo__WEBPACK_IMPORTED_MODULE_3__["syntheticVideo"])({ width: 640, height: 360, word: thisTrackName })];
                case 1:
                    msTrack = _a.sent();
                    localTrack = new Video.LocalVideoTrack(msTrack, { logLevel: 'warn', name: thisTrackName });
                    renderLocalTrack2(localTrack);
                    return [2 /*return*/];
            }
        });
    }); });
    var btnScreenShare = Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('+ Screen Share', localTrackButtonsContainer, function () { return __awaiter(_this, void 0, void 0, function () {
        var thisTrackName, screenStream, localTrack;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    thisTrackName = 'screen-' + number++;
                    return [4 /*yield*/, navigator.mediaDevices.getDisplayMedia({
                            video: { width: 1920, height: 1080, frameRate: 15 }
                        })];
                case 1:
                    screenStream = _a.sent();
                    localTrack = new Video.LocalVideoTrack(screenStream.getTracks()[0], { logLevel: 'warn', name: thisTrackName });
                    renderLocalTrack2(localTrack);
                    return [2 /*return*/];
            }
        });
    }); });
    // eslint-disable-next-line no-unused-vars
    var enumerateBtn = Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('Enumerate Cameras', localTrackButtonsContainer, function () { return __awaiter(_this, void 0, void 0, function () {
        var devices;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    enumerateBtn.disable();
                    return [4 /*yield*/, Object(_getDeviceSelectionOptions__WEBPACK_IMPORTED_MODULE_5__["getDeviceSelectionOptions"])()];
                case 1:
                    devices = _a.sent();
                    devices.videoinput.forEach(function (device, i, videoDevices) {
                        Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])(device.label, localTrackButtonsContainer, function () { return __awaiter(_this, void 0, void 0, function () {
                            var videoConstraints, thisTrackName, localTrack;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        videoConstraints = {
                                            deviceId: { exact: device.deviceId },
                                            // height: 480, width: 640, frameRate: 24
                                        };
                                        thisTrackName = 'camera-' + number++;
                                        return [4 /*yield*/, Video.createLocalVideoTrack(__assign({ logLevel: 'warn', name: thisTrackName }, videoConstraints))];
                                    case 1:
                                        localTrack = _a.sent();
                                        renderLocalTrack2(localTrack, videoDevices);
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    if (autoAudio) {
        btnPreviewAudio.click();
    }
    if (autoVideo) {
        btnPreviewVideo.click();
    }
    return {
        roomAdded: function (room) {
            renderedTracks.forEach((function (renderedTrack) { return renderedTrack.roomAdded(room); }));
        },
        roomRemoved: function (room) {
            renderedTracks.forEach((function (renderedTrack) { return renderedTrack.roomRemoved(room); }));
        },
        renderStandAloneMediaStreamTrack: renderStandAloneMediaStreamTrack,
    };
}


/***/ }),

/***/ "./src/createRoomControls.ts":
/*!***********************************!*\
  !*** ./src/createRoomControls.ts ***!
  \***********************************/
/*! exports provided: createRoomControls */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRoomControls", function() { return createRoomControls; });
/* harmony import */ var _randomName__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./randomName */ "./src/randomName.ts");
/* harmony import */ var _components_button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/button */ "./src/components/button.ts");
/* harmony import */ var _components_createDiv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/createDiv */ "./src/components/createDiv.ts");
/* harmony import */ var _components_createElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/createElement */ "./src/components/createElement.ts");
/* harmony import */ var _components_createLabeledCheckbox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/createLabeledCheckbox */ "./src/components/createLabeledCheckbox.ts");
/* harmony import */ var _components_createLabeledInput__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/createLabeledInput */ "./src/components/createLabeledInput.ts");
/* harmony import */ var _components_createLink__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/createLink */ "./src/components/createLink.ts");
/* harmony import */ var _components_createSelection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/createSelection */ "./src/components/createSelection.ts");
/* harmony import */ var _components_getBooleanUrlParam__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/getBooleanUrlParam */ "./src/components/getBooleanUrlParam.ts");
/* harmony import */ var _components_log__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/log */ "./src/components/log.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./jss */ "./src/jss.ts");
/* harmony import */ var _components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/createCollapsibleDiv */ "./src/components/createCollapsibleDiv.ts");
/* harmony import */ var _getCreds__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getCreds */ "./src/getCreds.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/* eslint-disable no-console */













/*
You can override any of the SDP function by specifying a console override like a one below before connecting to the room:
window.sdpTransform = function (override, description, pc) {
  console.log(`overriding ${override} for ${description.type}  of length ${description.sdp.length} in peerConnection:`,  pc );
  return description;
}
*/
var overridesSet = false;
function setupLocalDescriptionOverride() {
    // @ts-ignore
    var transform = window.sdpTransform;
    if (!overridesSet && typeof transform === 'function') {
        overridesSet = true;
        var origSetLocalDescription_1 = RTCPeerConnection.prototype.setLocalDescription;
        var origSetRemoteDescription_1 = RTCPeerConnection.prototype.setRemoteDescription;
        var origCreateOffer_1 = RTCPeerConnection.prototype.createOffer;
        var origCreateAnswer_1 = RTCPeerConnection.prototype.createAnswer;
        RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription(description) {
            return origSetLocalDescription_1.call(this, transform('setLocalDescription', description, this));
        };
        RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(description) {
            return origSetRemoteDescription_1.call(this, transform('setRemoteDescription', description, this));
        };
        RTCPeerConnection.prototype.createOffer = function createOffer(options) {
            var _this = this;
            return origCreateOffer_1.call(this, options).then(function (offer) {
                return transform('createOffer', offer, _this);
            });
        };
        RTCPeerConnection.prototype.createAnswer = function createAnswer(options) {
            var _this = this;
            return origCreateAnswer_1.call(this, options).then(function (answer) {
                return transform('createAnswer', answer, _this);
            });
        };
    }
}
// Create your style.
var style = {
    roomControls: {
        width: '300px',
        display: 'flex',
        padding: '5px',
        // border: 'solid black 1px',
        'flex-direction': 'column',
        'flex-wrap': 'wrap',
        'background-color': '#fff',
    },
    moreRoomControls: {
        display: 'flex',
        padding: '5px',
        // border: 'solid black 1px',
        'flex-direction': 'column',
        'flex-wrap': 'wrap',
        'background-color': '#fff',
    },
    roomControlsInput: {
        padding: '0.5em',
        'text-align': 'center',
    },
    roomControlsLabel: {
        'margin-top': '10px',
        'margin-right': '10px',
    },
    roomControlsButton: {
        'text-align': 'center'
    },
    joinRoomButton: {
        height: '3em',
    },
    controlOptions: {
        display: 'flex',
        'flex-flow': 'row wrap',
        'margin-top': '10px',
        'justify-content': 'center',
        'align-items': 'center',
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_10__["default"].createStyleSheet(style);
sheet.attach();
function handleSDKLogs(logger) {
    var localDataTrack = null;
    var localIdentity = null;
    var originalFactory = logger.methodFactory;
    logger.methodFactory = function (methodName, level, loggerName) {
        var method = originalFactory(methodName, level, loggerName);
        return function (dateTime, logLevel, component, message, data) {
            method(dateTime, logLevel, component, message, data);
            if (localDataTrack) {
                localDataTrack.send(JSON.stringify({
                    localIdentity: localIdentity,
                    dateTime: dateTime,
                    logLevel: logLevel,
                    component: component,
                    message: message,
                    data: data
                }));
            }
            // check for signaling events that previously used to be
            // emitted on (now deprecated) eventListener
            // they are fired with message = `event`, and group == `signaling`
            if (message === 'event' && data.group === 'signaling') {
                // console.log(`makarand EventListenerAPI | ${data.name}`);
            }
        };
    };
    // returns a function that allows sending logs to data channel.
    return {
        setLocalDataTrack: function (dataTrack, identity) {
            localDataTrack = dataTrack;
            localIdentity = identity;
        }
    };
}
;
function createRoomControls(container, Video, localTracks, roomJoined) {
    var _this = this;
    var urlParams = new URLSearchParams(window.location.search);
    var _a = Object(_components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_11__["createCollapsibleDiv"])({ container: container, headerText: 'Controls', divClass: sheet.classes.roomControls }), innerDiv = _a.innerDiv, outerDiv = _a.outerDiv;
    Object(_components_createElement__WEBPACK_IMPORTED_MODULE_3__["createElement"])({ container: innerDiv, type: 'h3', id: 'twilioVideoVersion', innerHtml: 'Twilio-Video@' + Video.version });
    var localIdentity = Object(_components_createLabeledInput__WEBPACK_IMPORTED_MODULE_5__["createLabeledInput"])({
        container: innerDiv,
        labelText: 'Identity: ',
        placeHolder: 'Enter identity or random one will be generated',
        labelClasses: [sheet.classes.roomControlsLabel],
        inputClasses: [sheet.classes.roomControlsInput]
    });
    var roomNameInput = Object(_components_createLabeledInput__WEBPACK_IMPORTED_MODULE_5__["createLabeledInput"])({
        container: innerDiv,
        labelText: 'Room: ',
        placeHolder: 'Enter room name or random name will be generated',
        labelClasses: [sheet.classes.roomControlsLabel],
        inputClasses: [sheet.classes.roomControlsInput]
    });
    var moreOptionsDiv = Object(_components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_11__["createCollapsibleDiv"])({ container: innerDiv, headerText: 'More...', divClass: sheet.classes.moreRoomControls, startHidden: true }).innerDiv;
    var topologySelect = Object(_components_createSelection__WEBPACK_IMPORTED_MODULE_7__["createSelection"])({
        id: 'topology',
        container: moreOptionsDiv,
        options: ['group-small', 'peer-to-peer', 'group', 'go'],
        title: 'topology',
        labelClasses: [sheet.classes.roomControlsLabel],
        onChange: function () { return Object(_components_log__WEBPACK_IMPORTED_MODULE_9__["log"])('topology change:', topologySelect.getValue()); }
    });
    var extraConnectOptions;
    var envSelect = Object(_components_createSelection__WEBPACK_IMPORTED_MODULE_7__["createSelection"])({
        id: 'env',
        container: moreOptionsDiv,
        options: ['dev', 'stage', 'prod'],
        title: 'env',
        labelClasses: [sheet.classes.roomControlsLabel],
        onChange: function () {
            var newEnv = envSelect.getValue();
            if (newEnv === 'dev') {
                // eslint-disable-next-line no-use-before-define
                var devOptions = Object.assign({}, defaultOptions, { wsServer: 'wss://us2.vss.dev.twilio.com/signaling' });
                extraConnectOptions.value = urlParams.get('connectOptions') || JSON.stringify(devOptions);
            }
            Object(_components_log__WEBPACK_IMPORTED_MODULE_9__["log"])('env change:', newEnv);
        }
    });
    //
    // TODO: besides server also allow to use token created from: 'https://www.twilio.com/console/video/project/testing-tools'
    var labelText = Object(_components_createLink__WEBPACK_IMPORTED_MODULE_6__["createLink"])({ container: moreOptionsDiv, linkText: 'ServerUrl', linkUrl: 'https://github.com/makarandp0/twilio-video-api#usage', newTab: true });
    labelText.classList.add(sheet.classes.roomControlsLabel);
    var tokenServerUrlInput = Object(_components_createLabeledInput__WEBPACK_IMPORTED_MODULE_5__["createLabeledInput"])({
        container: moreOptionsDiv,
        labelText: labelText,
        placeHolder: 'Enter server url',
        labelClasses: [sheet.classes.roomControlsLabel],
        inputClasses: [sheet.classes.roomControlsInput]
    });
    extraConnectOptions = Object(_components_createLabeledInput__WEBPACK_IMPORTED_MODULE_5__["createLabeledInput"])({
        container: moreOptionsDiv,
        labelText: 'ConnectOptions: ',
        placeHolder: 'connectOptions as json here',
        labelClasses: [sheet.classes.roomControlsLabel],
        inputType: 'textarea'
    });
    var maxParticipantsInput = Object(_components_createLabeledInput__WEBPACK_IMPORTED_MODULE_5__["createLabeledInput"])({
        container: moreOptionsDiv,
        labelText: 'MaxParticipants: ',
        placeHolder: 'optional (51+ makes large room)]',
        labelClasses: [sheet.classes.roomControlsLabel],
        inputClasses: [sheet.classes.roomControlsInput]
    });
    var controlOptionsDiv = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_2__["createDiv"])(moreOptionsDiv, sheet.classes.controlOptions, 'control-options');
    // container, labelText, id
    var autoPublish = Object(_components_createLabeledCheckbox__WEBPACK_IMPORTED_MODULE_4__["createLabeledCheckbox"])({ container: controlOptionsDiv, labelText: 'Auto Publish', id: 'autoPublish' });
    var autoAttach = Object(_components_createLabeledCheckbox__WEBPACK_IMPORTED_MODULE_4__["createLabeledCheckbox"])({ container: controlOptionsDiv, labelText: 'Auto Attach', id: 'autoAttach' });
    var autoJoin = Object(_components_createLabeledCheckbox__WEBPACK_IMPORTED_MODULE_4__["createLabeledCheckbox"])({ container: controlOptionsDiv, labelText: 'Auto Join', id: 'autoJoin' });
    var autoRecord = Object(_components_createLabeledCheckbox__WEBPACK_IMPORTED_MODULE_4__["createLabeledCheckbox"])({ container: controlOptionsDiv, labelText: 'Record Participant', id: 'recordParticipant' });
    var extraInfo = Object(_components_createLabeledCheckbox__WEBPACK_IMPORTED_MODULE_4__["createLabeledCheckbox"])({ container: controlOptionsDiv, labelText: 'extra Info', id: 'extraInfo' });
    var sendLogs = Object(_components_createLabeledCheckbox__WEBPACK_IMPORTED_MODULE_4__["createLabeledCheckbox"])({ container: controlOptionsDiv, labelText: 'send logs', id: 'sendLogs' });
    // process parameters.
    roomNameInput.value = urlParams.get('room') || Object(_randomName__WEBPACK_IMPORTED_MODULE_0__["randomRoomName"])();
    localIdentity.value = urlParams.get('identity') || Object(_randomName__WEBPACK_IMPORTED_MODULE_0__["randomParticipantName"])(); // randomName();
    tokenServerUrlInput.value = urlParams.get('server') || 'http://localhost:3000';
    maxParticipantsInput.value = urlParams.get('maxParticipants') || '';
    // for working with dev env use:
    // const defaultOptions = { wsServer: "wss://us2.vss.dev.twilio.com/signaling" };
    // for simulcast use:
    // { preferredVideoCodecs: [ { codec: "VP8", "simulcast": true }] }
    // const defaultOptions = { networkQuality: { local: 3, remote: 0 } };
    // const defaultOptions = {
    //   "preferredVideoCodecs": [{"codec":"H264"}],
    //   "iceTransportPolicy" : "relay"
    // };
    var defaultOptions = {
        networkQuality: { local: 1, remote: 0 },
        dominantSpeaker: true,
        preferredAudioCodecs: [{ codec: 'opus', dtx: false }],
        preferredVideoCodecs: [{ codec: "VP8", "simulcast": true }],
        bandwidthProfile: {
            video: {
                clientTrackSwitchOffControl: 'manual',
                contentPreferencesMode: 'manual',
            }
        }
    };
    extraConnectOptions.value = urlParams.get('connectOptions') || JSON.stringify(defaultOptions, null, 4);
    autoJoin.checked = urlParams.has('room') && urlParams.has('autoJoin');
    autoAttach.checked = Object(_components_getBooleanUrlParam__WEBPACK_IMPORTED_MODULE_8__["getBooleanUrlParam"])('autoAttach', true);
    autoPublish.checked = Object(_components_getBooleanUrlParam__WEBPACK_IMPORTED_MODULE_8__["getBooleanUrlParam"])('autoPublish', true);
    autoRecord.checked = Object(_components_getBooleanUrlParam__WEBPACK_IMPORTED_MODULE_8__["getBooleanUrlParam"])('record', false);
    extraInfo.checked = Object(_components_getBooleanUrlParam__WEBPACK_IMPORTED_MODULE_8__["getBooleanUrlParam"])('extraInfo', false);
    sendLogs.checked = Object(_components_getBooleanUrlParam__WEBPACK_IMPORTED_MODULE_8__["getBooleanUrlParam"])('sendLogs', false);
    topologySelect.setValue(urlParams.get('topology') || 'group-small');
    envSelect.setValue(urlParams.get('env') || 'prod');
    function getRoomCredentials() {
        return __awaiter(this, void 0, void 0, function () {
            var identity, tokenServerUrl, topology, environment, roomName, recordParticipantsOnConnect, url, maxParticipants, tokenOptions, response, tokenResponse, ex_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        identity = localIdentity.value || Object(_randomName__WEBPACK_IMPORTED_MODULE_0__["randomParticipantName"])();
                        tokenServerUrl = tokenServerUrlInput.value;
                        topology = topologySelect.getValue();
                        environment = envSelect.getValue();
                        roomName = roomNameInput.value;
                        recordParticipantsOnConnect = autoRecord.checked ? 'true' : 'false';
                        url = new URL(tokenServerUrl + '/token');
                        maxParticipants = maxParticipantsInput.value;
                        tokenOptions = { environment: environment, topology: topology, roomName: roomName, identity: identity, recordParticipantsOnConnect: recordParticipantsOnConnect, maxParticipants: maxParticipants };
                        console.log('Getting Token For: ', tokenOptions);
                        url.search = (new URLSearchParams(tokenOptions)).toString();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 5, , 6]);
                        return [4 /*yield*/, fetch(url.toString())];
                    case 2:
                        response = _a.sent();
                        if (!response.ok) return [3 /*break*/, 4];
                        return [4 /*yield*/, response.json()];
                    case 3:
                        tokenResponse = _a.sent();
                        return [2 /*return*/, { token: tokenResponse.token, environment: environment }];
                    case 4: throw new Error("Failed to obtain token from " + url + ", Status: " + response.status);
                    case 5:
                        ex_1 = _a.sent();
                        throw new Error("Error fetching token " + url + ", " + ex_1.message);
                    case 6: return [2 /*return*/];
                }
            });
        });
    }
    function joinRoom(token, restCreds) {
        return __awaiter(this, void 0, void 0, function () {
            var roomName, additionalConnectOptions, loggerName, logger, publishLogsAsData, logProcessor, connectOptions, room, localDataTrack, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        roomName = roomNameInput.value;
                        if (!roomName) {
                            // eslint-disable-next-line no-alert
                            alert('Please enter a room name.');
                            return [2 /*return*/];
                        }
                        additionalConnectOptions = {};
                        if (extraConnectOptions.value !== '') {
                            try {
                                additionalConnectOptions = JSON.parse(extraConnectOptions.value);
                            }
                            catch (e) {
                                console.warn('failed to parse additional connect options.', e);
                                return [2 /*return*/];
                            }
                        }
                        loggerName = "[" + localIdentity.value + "]:";
                        logger = Video.Logger.getLogger(loggerName);
                        publishLogsAsData = sendLogs.checked;
                        logProcessor = handleSDKLogs(logger);
                        connectOptions = Object.assign({
                            loggerName: loggerName,
                            tracks: autoPublish.checked ? localTracks : [],
                            name: roomName,
                            environment: envSelect.getValue()
                        }, additionalConnectOptions);
                        // Join the Room with the token from the server and the
                        // LocalParticipant's Tracks.
                        Object(_components_log__WEBPACK_IMPORTED_MODULE_9__["log"])("Joining room " + roomName + " with " + JSON.stringify(connectOptions, null, 2) + " " + (autoPublish.checked ? 'with' : 'without') + " " + localTracks.length + " localTracks");
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 5, , 6]);
                        return [4 /*yield*/, Video.connect(token, connectOptions)];
                    case 2:
                        room = _a.sent();
                        roomJoined(room, logger, restCreds);
                        localIdentity.value = Object(_randomName__WEBPACK_IMPORTED_MODULE_0__["randomParticipantName"])(); // randomName();
                        if (!publishLogsAsData) return [3 /*break*/, 4];
                        localDataTrack = new Video.LocalDataTrack();
                        return [4 /*yield*/, room.localParticipant.publishTrack(localDataTrack)];
                    case 3:
                        _a.sent();
                        logProcessor.setLocalDataTrack(localDataTrack, loggerName);
                        _a.label = 4;
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        error_1 = _a.sent();
                        Object(_components_log__WEBPACK_IMPORTED_MODULE_9__["log"])('Could not connect to Twilio: ' + error_1.message);
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/];
                }
            });
        });
    }
    // eslint-disable-next-line consistent-return
    var btnJoin = Object(_components_button__WEBPACK_IMPORTED_MODULE_1__["createButton"])('Join', innerDiv, function () { return __awaiter(_this, void 0, void 0, function () {
        var token, restCreds, restError_1, ex_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    setupLocalDescriptionOverride();
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 7, , 8]);
                    return [4 /*yield*/, getRoomCredentials()];
                case 2:
                    token = (_a.sent()).token;
                    restCreds = null;
                    if (!extraInfo.checked) return [3 /*break*/, 6];
                    _a.label = 3;
                case 3:
                    _a.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, Object(_getCreds__WEBPACK_IMPORTED_MODULE_12__["getRestCreds"])(envSelect.getValue(), tokenServerUrlInput.value)];
                case 4:
                    restCreds = _a.sent();
                    return [3 /*break*/, 6];
                case 5:
                    restError_1 = _a.sent();
                    Object(_components_log__WEBPACK_IMPORTED_MODULE_9__["log"])('failed to get rest credentials:', restError_1);
                    return [3 /*break*/, 6];
                case 6: return [2 /*return*/, joinRoom(token, restCreds)];
                case 7:
                    ex_2 = _a.sent();
                    Object(_components_log__WEBPACK_IMPORTED_MODULE_9__["log"])('Failed: ', ex_2);
                    return [3 /*break*/, 8];
                case 8: return [2 /*return*/];
            }
        });
    }); });
    btnJoin.btn.classList.add(sheet.classes.joinRoomButton);
    if (autoJoin.checked) {
        btnJoin.click();
    }
    return {
        shouldAutoAttach: function () { return autoAttach.checked; },
        shouldAutoPublish: function () { return autoPublish.checked; },
        getRoomControlsDiv: function () { return innerDiv; },
        getRoomCredentials: getRoomCredentials,
    };
}


/***/ }),

/***/ "./src/createTrackStats.ts":
/*!*********************************!*\
  !*** ./src/createTrackStats.ts ***!
  \*********************************/
/*! exports provided: createTrackStats */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTrackStats", function() { return createTrackStats; });
/* harmony import */ var twilio_video__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! twilio-video */ "../../work/twilio-video.js/es5/index.js");
/* harmony import */ var twilio_video__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(twilio_video__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/createCollapsibleDiv */ "./src/components/createCollapsibleDiv.ts");
/* harmony import */ var _components_labeledstat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/labeledstat */ "./src/components/labeledstat.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jss */ "./src/jss.ts");




// Create your style.
var style = {
    background_red: {
        background: 'red',
    },
    background_green: {
        background: 'lightgreen',
    },
    background_yellow: {
        background: 'yellow',
    },
    audioTrack: {
        background: 'lightcoral',
    },
    videoTrack: {
        background: 'lightblue'
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_3__["default"].createStyleSheet(style);
sheet.attach();
function getClass(track) {
    if (track instanceof twilio_video__WEBPACK_IMPORTED_MODULE_0__["LocalAudioTrack"]) {
        return 'LocalAudioTrack';
    }
    else if (track instanceof twilio_video__WEBPACK_IMPORTED_MODULE_0__["LocalVideoTrack"]) {
        return 'LocalVideoTrack';
    }
    else if (track.kind === 'audio') {
        return 'RemoteAudioTrack';
    }
    else if (track.kind === 'video') {
        return 'RemoteVideoTrack';
    }
    else {
        return 'unknown';
    }
}
function createTrackStats(track, container) {
    var _a;
    var outerDiv;
    (_a = Object(_components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_1__["createCollapsibleDiv"])({ container: container, headerText: 'Track Details', startHidden: true, divClass: [] }), container = _a.innerDiv, outerDiv = _a.outerDiv);
    // container = createDiv(container, 'trackStats');
    function isVideoTrack(track) {
        return track.kind === 'video';
    }
    Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
        container: container,
        label: 'class'
    }).setText(getClass(track));
    var readyState = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
        container: container,
        label: 'readyState',
        valueMapper: function (text) { return text === 'ended' ? sheet.classes.background_red : undefined; }
    });
    var enabled = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
        container: container,
        label: 'enabled',
        valueMapper: function (text) { return text === 'false' ? sheet.classes.background_yellow : undefined; }
    });
    var muted = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
        container: container,
        label: 'muted',
        valueMapper: function (text) { return text === 'true' ? sheet.classes.background_yellow : undefined; }
    });
    var dimensions;
    var fps;
    if (isVideoTrack(track)) {
        dimensions = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({ container: container, label: 'dimensions' });
        track.on('dimensionsChanged', function () { return updateStats(); });
        fps = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({ container: container, label: 'FPS' });
    }
    else {
        // workaroundBackgroundNoiseWhenMuted(track as RemoteAudioTrack);
    }
    var started = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
        container: container,
        label: 'Track.started',
        valueMapper: function (text) { return text === 'false' ? sheet.classes.background_yellow : undefined; }
    });
    var trackEnabled = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
        container: container,
        label: 'Track.enabled',
        valueMapper: function (text) { return text === 'false' ? sheet.classes.background_yellow : undefined; }
    });
    function listenOnMSTrack(msTrack) {
        msTrack.addEventListener('ended', function () { return updateStats(); });
        msTrack.addEventListener('mute', function () { return updateStats(); });
        msTrack.addEventListener('unmute', function () { return updateStats(); });
    }
    track.on('disabled', function () { return updateStats(); });
    track.on('enabled', function () { return updateStats(); });
    track.on('stopped', function () { return updateStats(); });
    track.on('started', function () {
        updateStats();
        listenOnMSTrack(track.mediaStreamTrack);
    });
    function updateStats() {
        readyState.setText(track.mediaStreamTrack.readyState);
        enabled.setText("" + track.mediaStreamTrack.enabled);
        started.setText("" + track.isStarted);
        muted.setText("" + track.mediaStreamTrack.muted);
        trackEnabled.setText("" + track.isEnabled);
        if (isVideoTrack(track)) {
            var _a = track.dimensions, width = _a.width, height = _a.height;
            dimensions.setText("w" + width + " x h" + height);
            var frameRate = track.mediaStreamTrack.getSettings().frameRate;
            var frameRateText = typeof frameRate === 'number' ? String(Math.round(frameRate)) : '0';
            fps.setText(frameRateText);
        }
    }
    return { updateStats: updateStats };
}


/***/ }),

/***/ "./src/demo.ts":
/*!*********************!*\
  !*** ./src/demo.ts ***!
  \*********************/
/*! exports provided: demo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "demo", function() { return demo; });
/* harmony import */ var _components_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/log */ "./src/components/log.ts");
/* harmony import */ var _components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/createCollapsibleDiv */ "./src/components/createCollapsibleDiv.ts");
/* harmony import */ var _createLocalTracksControls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createLocalTracksControls */ "./src/createLocalTracksControls.ts");
/* harmony import */ var _createRoomControls__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createRoomControls */ "./src/createRoomControls.ts");
/* harmony import */ var _renderRoom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderRoom */ "./src/renderRoom.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./jss */ "./src/jss.ts");
/* harmony import */ var _components_createLink__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/createLink */ "./src/components/createLink.ts");
/* harmony import */ var _setupPreflight__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./setupPreflight */ "./src/setupPreflight.ts");
/* harmony import */ var _components_button__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/button */ "./src/components/button.ts");
/* eslint-disable no-undefined */
/* eslint-disable require-atomic-updates */
/* eslint-disable no-console */
/* eslint-disable quotes */

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};









// import { main } from '../../makarandp0.github.io/pcdemo/es6/pcdemo';
// Create your style.
var style = {
    mainDiv: {
        display: 'flex',
        height: 'auto',
        width: '100%',
        border: 'solid red 1px',
        padding: '2px',
        'box-sizing': 'border-box',
        'justify-content': 'flex-start',
        'flex-wrap': 'wrap',
        'background-color': '#fff',
        'text-align': 'center',
    },
    localControls: {
        display: 'flex',
        width: '100%',
        'background-color': '#fff',
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_5__["default"].createStyleSheet(style);
sheet.attach();
function checkVisibility() {
    document.addEventListener('visibilitychange', function () {
        Object(_components_log__WEBPACK_IMPORTED_MODULE_0__["log"])("document.visibilityState = " + document.visibilityState);
        console.log('makarand: document.visibilityState = ', document.visibilityState);
    });
}
// export function pcdemo(Video: typeof import('twilio-video'), containerDiv: HTMLElement) {
//   main(containerDiv);
// }
function demo(Video, containerDiv) {
    var _this = this;
    // link to source code
    Object(_components_createLink__WEBPACK_IMPORTED_MODULE_6__["createLink"])({ container: containerDiv, linkText: 'Twilio-Video-API-Demo', linkUrl: 'https://github.com/makarandp0/twilio-video-api', newTab: true });
    var container = Object(_components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_1__["createFieldSet"])({ container: containerDiv, headerText: '', divClasses: [sheet.classes.mainDiv] }).fieldset;
    Object(_components_log__WEBPACK_IMPORTED_MODULE_0__["createLog"])(containerDiv);
    Object(_components_log__WEBPACK_IMPORTED_MODULE_0__["log"])("Version: ", Video.version);
    Object(_components_log__WEBPACK_IMPORTED_MODULE_0__["log"])("IsSupported: ", Video.isSupported);
    Object(_components_log__WEBPACK_IMPORTED_MODULE_0__["log"])("UserAgent: ", navigator.userAgent);
    var localTracks = [];
    var rooms = [];
    // checkVisibility();
    // @ts-ignore
    window._TwilioVideo = { Video: Video, rooms: rooms };
    // @ts-ignore
    window.rooms = rooms;
    var _a = Object(_createRoomControls__WEBPACK_IMPORTED_MODULE_3__["createRoomControls"])(container, Video, localTracks, roomJoined), shouldAutoAttach = _a.shouldAutoAttach, shouldAutoPublish = _a.shouldAutoPublish, getRoomControlsDiv = _a.getRoomControlsDiv, getRoomCredentials = _a.getRoomCredentials;
    var buttonContainer = getRoomControlsDiv();
    var _b = Object(_createLocalTracksControls__WEBPACK_IMPORTED_MODULE_2__["createLocalTracksControls"])({
        buttonContainer: buttonContainer,
        container: container,
        Video: Video,
        localTracks: localTracks,
        rooms: rooms,
        shouldAutoAttach: shouldAutoAttach,
        shouldAutoPublish: shouldAutoPublish,
    }), roomAdded = _b.roomAdded, roomRemoved = _b.roomRemoved, renderStandAloneMediaStreamTrack = _b.renderStandAloneMediaStreamTrack;
    Object(_components_button__WEBPACK_IMPORTED_MODULE_8__["createButton"])('setupPreflight', buttonContainer, function () { return __awaiter(_this, void 0, void 0, function () {
        var creds;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, getRoomCredentials()];
                case 1:
                    creds = _a.sent();
                    Object(_setupPreflight__WEBPACK_IMPORTED_MODULE_7__["setupPreflight"])({
                        container: buttonContainer,
                        token: creds.token,
                        Video: Video,
                        environment: creds.environment,
                        renderMSTrack: function (msTrack) { return renderStandAloneMediaStreamTrack({ msTrack: msTrack, autoAttach: shouldAutoAttach() }); }
                    });
                    return [2 /*return*/];
            }
        });
    }); });
    // Successfully connected!
    function roomJoined(room, logger, restCreds) {
        logger = logger || Video.Logger.getLogger('twilio-video');
        rooms.push(room);
        roomAdded(room);
        Object(_components_log__WEBPACK_IMPORTED_MODULE_0__["log"])("Joined " + room.sid + " as \"" + room.localParticipant.identity + "\"");
        Object(_renderRoom__WEBPACK_IMPORTED_MODULE_4__["renderRoom"])({ room: room, container: container, shouldAutoAttach: shouldAutoAttach, restCreds: restCreds, logger: logger });
        room.on('disconnected', function (_, err) {
            Object(_components_log__WEBPACK_IMPORTED_MODULE_0__["log"])("Left " + room.sid + " as \"" + room.localParticipant.identity + "\"");
            if (err) {
                Object(_components_log__WEBPACK_IMPORTED_MODULE_0__["log"])('Error:', err);
            }
            var index = rooms.indexOf(room);
            if (index > -1) {
                rooms.splice(index, 1);
            }
            roomRemoved(room);
        });
    }
}


/***/ }),

/***/ "./src/getCreds.ts":
/*!*************************!*\
  !*** ./src/getCreds.ts ***!
  \*************************/
/*! exports provided: getRestCreds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRestCreds", function() { return getRestCreds; });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
// returns credentials to be used for rest calls.
function getRestCreds(environment, serverUrl) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, protocol, host, urlParams, url, response, jsonResponse, credentialsAt;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = window.location, protocol = _a.protocol, host = _a.host;
                    urlParams = new URLSearchParams(window.location.search);
                    url = new URL(serverUrl + '/getCreds');
                    url.search = (new URLSearchParams({ environment: environment })).toString();
                    return [4 /*yield*/, fetch(url.toString())];
                case 1:
                    response = _b.sent();
                    if (!response.ok) return [3 /*break*/, 3];
                    return [4 /*yield*/, response.json()];
                case 2:
                    jsonResponse = _b.sent();
                    credentialsAt = jsonResponse.signingKeySid + ":" + jsonResponse.signingKeySecret + "@";
                    jsonResponse.restUrl = environment === 'prod' ? "https://" + credentialsAt + "video.twilio.com" : "https://" + credentialsAt + "video." + environment + ".twilio.com";
                    ;
                    jsonResponse.restUrlNoCreds = environment === 'prod' ? 'https://video.twilio.com' : "https://video." + environment + ".twilio.com";
                    return [2 /*return*/, jsonResponse];
                case 3: throw new Error("Failed to obtain creds from from " + url + ", Status: " + response.status);
            }
        });
    });
}


/***/ }),

/***/ "./src/getDeviceSelectionOptions.ts":
/*!******************************************!*\
  !*** ./src/getDeviceSelectionOptions.ts ***!
  \******************************************/
/*! exports provided: getDevicesOfKind, ensureMediaPermissions, getDeviceSelectionOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDevicesOfKind", function() { return getDevicesOfKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ensureMediaPermissions", function() { return ensureMediaPermissions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDeviceSelectionOptions", function() { return getDeviceSelectionOptions; });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
function getDevicesOfKind(deviceInfos, kind) {
    return deviceInfos.filter(function (deviceInfo) {
        return deviceInfo.kind === kind;
    });
}
function ensureMediaPermissions() {
    return __awaiter(this, void 0, void 0, function () {
        var devices, shouldAskForMediaPermissions;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, navigator.mediaDevices.enumerateDevices()];
                case 1:
                    devices = _a.sent();
                    shouldAskForMediaPermissions = devices.every(function (device) {
                        return !(device.deviceId && device.label);
                    });
                    if (shouldAskForMediaPermissions) {
                        return [2 /*return*/, navigator.mediaDevices.getUserMedia({ audio: true, video: true }).then(function (mediaStream) {
                                mediaStream.getTracks().forEach(function (track) {
                                    track.stop();
                                });
                            })];
                    }
                    return [2 /*return*/];
            }
        });
    });
}
function getDeviceSelectionOptions() {
    return __awaiter(this, void 0, void 0, function () {
        var deviceInfos;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: 
                // before calling enumerateDevices, get media permissions (.getUserMedia)
                // w/o media permissions, browsers do not return device Ids and/or labels.
                return [4 /*yield*/, ensureMediaPermissions()];
                case 1:
                    // before calling enumerateDevices, get media permissions (.getUserMedia)
                    // w/o media permissions, browsers do not return device Ids and/or labels.
                    _a.sent();
                    return [4 /*yield*/, navigator.mediaDevices.enumerateDevices()];
                case 2:
                    deviceInfos = _a.sent();
                    return [2 /*return*/, {
                            audioinput: getDevicesOfKind(deviceInfos, 'audioinput'),
                            audiooutput: getDevicesOfKind(deviceInfos, 'audiooutput'),
                            videoinput: getDevicesOfKind(deviceInfos, 'videoinput'),
                        }];
            }
        });
    });
}


/***/ }),

/***/ "./src/jss.ts":
/*!********************!*\
  !*** ./src/jss.ts ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jss */ "./node_modules/jss/dist/jss.esm.js");
/* harmony import */ var jss_preset_default__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jss-preset-default */ "./node_modules/jss-preset-default/dist/jss-preset-default.esm.js");
/* eslint-disable no-undefined */
/* eslint-disable require-atomic-updates */
/* eslint-disable no-console */
/* eslint-disable quotes */



jss__WEBPACK_IMPORTED_MODULE_0__["default"].setup(Object(jss_preset_default__WEBPACK_IMPORTED_MODULE_1__["default"])());
/* harmony default export */ __webpack_exports__["default"] = (jss__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./src/randomItem.ts":
/*!***************************!*\
  !*** ./src/randomItem.ts ***!
  \***************************/
/*! exports provided: randomItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomItem", function() { return randomItem; });
function randomItem(array) {
    var randomIndex = Math.floor(Math.random() * array.length);
    return array[randomIndex];
}


/***/ }),

/***/ "./src/randomName.ts":
/*!***************************!*\
  !*** ./src/randomName.ts ***!
  \***************************/
/*! exports provided: randomParticipantName, randomName, randomRoomName */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomParticipantName", function() { return randomParticipantName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomName", function() { return randomName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomRoomName", function() { return randomRoomName; });
/* harmony import */ var _randomItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./randomItem */ "./src/randomItem.ts");

var callNumber = 0;
function randomParticipantName() {
    var names = ['Alice', 'Bob', 'Charlie', 'Delta', 'Echo', 'FoxTrot', 'Golf', 'Hotel', 'India',
        'Juliet', 'Kilo', 'Lima', 'Mike', 'November', 'Oscar', 'Papa', 'Quebec', 'Romeo', 'Sierra',
        'Tango', 'Uniform', 'Victor', 'Whiskey', 'X-ray', 'Yankee', 'Zulu'];
    var pick = names[callNumber];
    callNumber = (callNumber + 1) % 26;
    return pick;
}
function randomName() {
    var ADJECTIVES = [
        'Abrasive', 'Brash', 'Callous', 'Daft', 'Eccentric', 'Finest', 'Golden',
        'Holy', 'Ignominious', 'Jolted', 'Killer', 'Luscious', 'Mushy', 'Nasty',
        'OldSchool', 'Pompous', 'Quiet', 'Rowdy', 'Sneaky', 'Tawdry',
        'Unique', 'Vivacious', 'Wicked', 'Xenophobic', 'Yawning', 'Zesty'
    ];
    var FIRST_NAMES = [
        'Anna', 'Bobby', 'Cameron', 'Danny', 'Emmett', 'Frida', 'Gracie', 'Hannah',
        'Isaac', 'Jenna', 'Kendra', 'Landon', 'Mufasa', 'Nate', 'Owen', 'Penny',
        'Quincy', 'Ruddy', 'Samantha', 'Tammy', 'Ulysses', 'Victoria', 'Wendy',
        'Xander', 'Yolanda', 'Zelda'
    ];
    var LAST_NAMES = [
        'Anchorage', 'Berlin', 'Cucamonga', 'Davenport', 'Essex', 'Fresno',
        'Gunsight', 'Hanover', 'Indianapolis', 'Jamestown', 'Kane', 'Liberty',
        'Minneapolis', 'Nevis', 'Oakland', 'Portland', 'Quantico', 'Raleigh',
        'SaintPaul', 'Tulsa', 'Utica', 'Vail', 'Warsaw', 'XiaoJin', 'Yale',
        'Zimmerman'
    ];
    return Object(_randomItem__WEBPACK_IMPORTED_MODULE_0__["randomItem"])(ADJECTIVES) +
        Object(_randomItem__WEBPACK_IMPORTED_MODULE_0__["randomItem"])(FIRST_NAMES) +
        Object(_randomItem__WEBPACK_IMPORTED_MODULE_0__["randomItem"])(LAST_NAMES);
}
function randomRoomName() {
    var PLACES = [
        'Agra', 'Berlin', 'Cucamonga', 'Davenport', 'Essex', 'Fresno',
        'Gunsight', 'Hanover', 'Indore', 'Jamestown', 'Kalwa', 'Liberty',
        'Madras', 'Nevis', 'Oakland', 'Portland', 'Quantico', 'Redmond',
        'Seattle', 'Thane', 'Utica', 'Vail', 'Warsaw', 'XiaoJin', 'Yale',
        'Zimmerman'
    ];
    var COUNTRIES = [
        'Austria', 'Brazil', 'China', 'Denmark', 'Egypt', 'France',
        'Ghana', 'Holland', 'India', 'Jamaica', 'Kenya', 'Libya',
        'Mexico', 'Nepal', 'Oman', 'Peru', 'Qatar', 'Russia',
        'Spain', 'Turkey', 'Uganda', 'Vietnam', 'Wales', 'Xianbei', 'Yemen',
        'Zambia'
    ];
    return Object(_randomItem__WEBPACK_IMPORTED_MODULE_0__["randomItem"])(PLACES) +
        Object(_randomItem__WEBPACK_IMPORTED_MODULE_0__["randomItem"])(COUNTRIES);
}


/***/ }),

/***/ "./src/renderLocalTrack.ts":
/*!*********************************!*\
  !*** ./src/renderLocalTrack.ts ***!
  \*********************************/
/*! exports provided: updateLocalTrackStats, renderLocalTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateLocalTrackStats", function() { return updateLocalTrackStats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderLocalTrack", function() { return renderLocalTrack; });
/* harmony import */ var _components_button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/button */ "./src/components/button.ts");
/* harmony import */ var _components_createDiv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/createDiv */ "./src/components/createDiv.ts");
/* harmony import */ var _components_createElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/createElement */ "./src/components/createElement.ts");
/* harmony import */ var _components_labeledstat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/labeledstat */ "./src/components/labeledstat.ts");
/* harmony import */ var _components_log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/log */ "./src/components/log.ts");
/* harmony import */ var _renderTrack__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderTrack */ "./src/renderTrack.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./jss */ "./src/jss.ts");
/* harmony import */ var _components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/createCollapsibleDiv */ "./src/components/createCollapsibleDiv.ts");
/* harmony import */ var _renderLocalTrackStats__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./renderLocalTrackStats */ "./src/renderLocalTrackStats.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/* eslint-disable no-console */









var round = function (num) { return Math.round((num + Number.EPSILON) * 10) / 10; };
// Create your style.
var style = {
    background_gray: {
        background: 'gray',
    },
    background_green: {
        background: 'lightgreen',
    },
    localTrackControls: {
        /* since it attaches to track container */
        /* does not need top border */
        'border-bottom': 'solid 1px black',
        'border-left': 'solid 1px black',
        'border-right': 'solid 1px black',
    },
    localTrackContainer: {
        resize: 'both',
        // border: 'solid 1px black',
        overflow: 'auto',
        'overflow-y': 'scroll',
        // padding: '5px',
        width: '300px'
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_6__["default"].createStyleSheet(style);
sheet.attach();
var publishControls = new Map();
function updateLocalTrackStats(room, trackStats) {
    if (trackStats.length > 0) {
        var trackPublishControls = publishControls.get(trackStats[0].trackId);
        if (trackPublishControls) {
            var publishControl = trackPublishControls.get(room);
            if (publishControl) {
                publishControl.updateLocalTrackStats(trackStats);
            }
        }
    }
}
// creates buttons to publish unpublish track in a given room.
function createRoomPublishControls(container, room, track, shouldAutoPublish) {
    var _this = this;
    container = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_1__["createDiv"])(container, sheet.classes.localTrackControls, 'localTrackControls');
    var roomSid = Object(_components_createElement__WEBPACK_IMPORTED_MODULE_2__["createElement"])({ container: container, type: 'h8', classNames: ['roomHeader'], innerHtml: room.localParticipant.identity });
    var priorityButtons = [];
    var unPublishBtn;
    var publishBtn;
    var priority;
    var trackPublication = Array.from(room.localParticipant.tracks.values()).find(function (trackPub) { return trackPub.track === track; }) || null;
    var updateControls = function () {
        // show priority buttons only when trackPublication is available.
        priorityButtons.forEach(function (priButton) { return priButton.show(!!trackPublication); });
        publishBtn.show(!trackPublication);
        unPublishBtn.show(!!trackPublication);
        priority.setText("" + (trackPublication === null || trackPublication === void 0 ? void 0 : trackPublication.priority));
    };
    var localTrackStatRender = Object(_renderLocalTrackStats__WEBPACK_IMPORTED_MODULE_8__["renderLocalTrackStats"])(container);
    publishBtn = Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('publish', container, function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    publishBtn.disable();
                    if (!!trackPublication) return [3 /*break*/, 2];
                    return [4 /*yield*/, room.localParticipant.publishTrack(track)];
                case 1:
                    // eslint-disable-next-line require-atomic-updates
                    trackPublication = _a.sent();
                    updateControls();
                    _a.label = 2;
                case 2:
                    publishBtn.enable();
                    return [2 /*return*/];
            }
        });
    }); });
    unPublishBtn = Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('unpublish', container, function () {
        if (trackPublication) {
            trackPublication.unpublish();
            trackPublication = null;
            localTrackStatRender.stopRendering();
            updateControls();
        }
    });
    priority = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_3__["createLabeledStat"])({
        container: container,
        label: 'publish priority'
    });
    // set publish priority.
    ['high', 'standard', 'low'].forEach(function (priorityText) {
        var button = Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])(priorityText, container, function () {
            trackPublication === null || trackPublication === void 0 ? void 0 : trackPublication.setPriority(priorityText);
            updateControls();
        });
        priorityButtons.push(button);
    });
    updateControls();
    if (shouldAutoPublish) {
        publishBtn.click();
    }
    return {
        unPublishBtn: unPublishBtn,
        updateLocalTrackStats: function (trackStats) {
            if (trackPublication && trackPublication.trackSid === trackStats[0].trackSid) {
                localTrackStatRender.updateLocalTrackStats(trackStats);
            }
        },
        stopRendering: function () {
            localTrackStatRender.stopRendering();
            container.remove();
        }
    };
}
function renderLocalTrack(_a) {
    var rooms = _a.rooms, track = _a.track, container = _a.container, autoAttach = _a.autoAttach, autoPublish = _a.autoPublish, onClosed = _a.onClosed, _b = _a.videoDevices, videoDevices = _b === void 0 ? [] : _b;
    var _c = Object(_components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_7__["createCollapsibleDiv"])({ container: container, headerText: 'LocalTrack', divClass: sheet.classes.localTrackContainer }), localTrackContainer = _c.innerDiv, outerDiv = _c.outerDiv;
    var stopRendering = Object(_renderTrack__WEBPACK_IMPORTED_MODULE_5__["renderTrack"])({ track: track, container: localTrackContainer, autoAttach: autoAttach }).stopRendering;
    var localTrackControls = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_1__["createDiv"])(localTrackContainer, sheet.classes.localTrackControls);
    Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('disable', localTrackControls, function () { return track.disable(); });
    Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('enable', localTrackControls, function () { return track.enable(); });
    Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('stop', localTrackControls, function () {
        Object(_components_log__WEBPACK_IMPORTED_MODULE_4__["log"])('stopping track');
        track.stop();
        Object(_components_log__WEBPACK_IMPORTED_MODULE_4__["log"])('done stopping track');
    });
    Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('restart', localTrackControls, function () {
        track.restart().catch(function (err) {
            console.log('track.restart failed', err);
        });
    });
    videoDevices.forEach(function (device) {
        Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])("restart: " + device.label, localTrackControls, function () {
            var videoConstraints = {
                deviceId: { exact: device.deviceId },
            };
            console.log('calling restart with: ', videoConstraints);
            track.restart(videoConstraints).catch(function (err) {
                console.log('track.restart failed', err);
            });
        });
    });
    var trackPublishControls = new Map();
    publishControls.set(track.id, trackPublishControls);
    // for existing rooms, publish track if shouldAutoPublish
    rooms.forEach(function (room) {
        trackPublishControls.set(room, createRoomPublishControls(localTrackContainer, room, track, autoPublish));
    });
    var roomAdded = function (room) {
        if (!trackPublishControls.get(room)) {
            // for any rooms that are joined after track - do not auto publish,
            // as room starts of ith tracks depending on auto publish.
            trackPublishControls.set(room, createRoomPublishControls(localTrackContainer, room, track, false));
        }
    };
    var roomRemoved = function (room) {
        var roomPublishControl = trackPublishControls.get(room);
        if (roomPublishControl) {
            roomPublishControl.stopRendering();
            trackPublishControls.delete(room);
        }
    };
    Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('close', localTrackControls, function () {
        trackPublishControls.forEach(function (roomPublishControl, room) {
            roomPublishControl.unPublishBtn.click();
            roomPublishControl.stopRendering();
            trackPublishControls.delete(room);
        });
        stopRendering();
        track.stop();
        // localTrackContainer.remove();
        outerDiv.remove();
        onClosed();
    });
    return {
        roomAdded: roomAdded,
        roomRemoved: roomRemoved
    };
}


/***/ }),

/***/ "./src/renderLocalTrackStats.ts":
/*!**************************************!*\
  !*** ./src/renderLocalTrackStats.ts ***!
  \**************************************/
/*! exports provided: renderLocalTrackStats */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderLocalTrackStats", function() { return renderLocalTrackStats; });
/* harmony import */ var _components_labeledstat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/labeledstat */ "./src/components/labeledstat.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jss */ "./src/jss.ts");


// Create your style.
var style = {
    background_gray: {
        background: 'gray',
    },
    background_green: {
        background: 'lightgreen',
    },
    localTrackControls: {
        /* since it attaches to track container */
        /* does not need top border */
        'border-bottom': 'solid 1px black',
        'border-left': 'solid 1px black',
        'border-right': 'solid 1px black',
    },
    localTrackContainer: {
        resize: 'both',
        // border: 'solid 1px black',
        overflow: 'auto',
        'overflow-y': 'scroll',
        // padding: '5px',
        width: '300px'
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_1__["default"].createStyleSheet(style);
sheet.attach();
function renderSSRC(container) {
    var ssrc = "unknown";
    var previousTime = 0;
    var previousBytes = 0;
    var statDisplay = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_0__["createLabeledStat"])({
        container: container,
        label: 'sent (kbps)',
        valueMapper: function (text) { return text === '0' ? sheet.classes.background_gray : sheet.classes.background_green; }
    });
    statDisplay.setText('0');
    function isVideoTrackStats(track) {
        return 'dimensions' in track || 'frameRate' in track;
    }
    return {
        ssrc: ssrc,
        stopRendering: function () {
            statDisplay.element.remove();
        },
        update: function (trackStats) {
            ssrc = trackStats.ssrc;
            if (isVideoTrackStats(trackStats)) {
                if (trackStats.dimensions !== null) {
                    var _a = trackStats.dimensions, width = _a.width, height = _a.height;
                    var frameRate = trackStats.frameRate || 0;
                    statDisplay.setLabel(width + "x" + height + "x" + frameRate);
                }
            }
            var newBytesSent = trackStats.bytesSent || 0;
            var newTimestamp = trackStats.timestamp;
            var round = function (num) { return Math.round((num + Number.EPSILON) * 10) / 10; };
            var kBitsPerSecond = round((newBytesSent - previousBytes) / (newTimestamp - previousTime)) * 10;
            statDisplay.setText(kBitsPerSecond.toString());
            previousTime = newTimestamp;
            previousBytes = newBytesSent;
        }
    };
}
function renderLocalTrackStats(container) {
    var ssrcDisplayMap = new Map();
    return {
        updateLocalTrackStats: function (trackStats) {
            trackStats.forEach(function (trackStat) {
                var ssrcRender = ssrcDisplayMap.get(trackStat.ssrc);
                if (ssrcRender) {
                    ssrcRender.update(trackStat);
                }
                else {
                    var ssrcRender_1 = renderSSRC(container);
                    ssrcRender_1.update(trackStat);
                    ssrcDisplayMap.set(trackStat.ssrc, ssrcRender_1);
                }
            });
        },
        stopRendering: function () {
            ssrcDisplayMap.forEach(function (ssrcRenderer) { return ssrcRenderer.stopRendering(); });
            ssrcDisplayMap.clear();
        }
    };
}


/***/ }),

/***/ "./src/renderRemoteMediaTrack.ts":
/*!***************************************!*\
  !*** ./src/renderRemoteMediaTrack.ts ***!
  \***************************************/
/*! exports provided: renderRemoteMediaTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderRemoteMediaTrack", function() { return renderRemoteMediaTrack; });
/* harmony import */ var _components_button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/button */ "./src/components/button.ts");
/* harmony import */ var _components_createDiv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/createDiv */ "./src/components/createDiv.ts");
/* harmony import */ var _components_labeledstat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/labeledstat */ "./src/components/labeledstat.ts");
/* harmony import */ var _renderTrack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderTrack */ "./src/renderTrack.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jss */ "./src/jss.ts");





// Create your style.
var style = {
    background_gray: {
        background: 'gray',
    },
    background_yellow: {
        background: 'yellow',
    },
    background_green: {
        background: 'lightgreen',
    },
    background_red: {
        background: 'red',
    },
    remoteTrackControls: {
    /* since it attaches to track container */
    /* does not need top border */
    // 'border-bottom': 'solid 1px black',
    // 'border-left': 'solid 1px black',
    // 'border-right': 'solid 1px black',
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_4__["default"].createStyleSheet(style);
sheet.attach();
function renderRemoteMediaTrack(track, trackPublication, container, autoAttach) {
    var trackFPS;
    var trackAudioLevel;
    var videoTrack = track.kind === 'video' ? track : null;
    var renderedTrack = Object(_renderTrack__WEBPACK_IMPORTED_MODULE_3__["renderTrack"])({ track: track, container: container, autoAttach: autoAttach });
    var trackBytesDiv = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_1__["createDiv"])(container, sheet.classes.remoteTrackControls, 'remoteTrackControls');
    var statBytes = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
        container: trackBytesDiv,
        label: 'received kbps',
        valueMapper: function (text) { return text === '0' ? sheet.classes.background_yellow : undefined; }
    });
    statBytes.setText('0');
    if (videoTrack) {
        trackFPS = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
            container: trackBytesDiv,
            label: 'fps',
            valueMapper: function (text) { return text === '0' ? sheet.classes.background_yellow : undefined; }
        });
    }
    else {
        trackAudioLevel = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
            container: trackBytesDiv,
            label: 'audioLevel',
            valueMapper: function (text) { return text === '0' ? sheet.classes.background_yellow : undefined; }
        });
    }
    var publisherPriority = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({ container: trackBytesDiv, label: 'publisher priority' });
    publisherPriority.setText("" + trackPublication.publishPriority);
    trackPublication.on('publishPriorityChanged', function () {
        publisherPriority.setText("" + trackPublication.publishPriority);
    });
    var switchOffState = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
        container: trackBytesDiv,
        label: 'Switched',
        valueMapper: function (text) { return text === 'Off' ? sheet.classes.background_yellow : undefined; }
    });
    var updateSwitchOffState = function () { return switchOffState.setText(track.isSwitchedOff ? 'Off' : 'On'); };
    track.on('switchedOff', updateSwitchOffState);
    track.on('switchedOn', updateSwitchOffState);
    updateSwitchOffState();
    // buttons to set subscriber priority.
    var priority = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({ container: trackBytesDiv, label: 'subscriber priority' });
    priority.setText("" + track.priority);
    Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('High', trackBytesDiv, function () {
        track.setPriority('high');
        priority.setText("" + track.priority);
    });
    Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('Standard', trackBytesDiv, function () {
        track.setPriority('standard');
        priority.setText("" + track.priority);
    });
    Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('Low', trackBytesDiv, function () {
        track.setPriority('low');
        priority.setText("" + track.priority);
    });
    Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('Null', trackBytesDiv, function () {
        track.setPriority(null);
        priority.setText("" + track.priority);
    });
    if (videoTrack) {
        var renderHint_1 = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({ container: trackBytesDiv, label: 'renderHint' });
        renderHint_1.setText("none");
        Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('switchOff', trackBytesDiv, function () {
            videoTrack.switchOff();
            renderHint_1.setText("off");
        });
        Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('switchOn', trackBytesDiv, function () {
            videoTrack.switchOn();
            renderHint_1.setText("on");
        });
        Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('160x120', trackBytesDiv, function () {
            var renderDimensions = { width: 160, height: 120 };
            videoTrack.setContentPreferences({ renderDimensions: renderDimensions });
            renderHint_1.setText("renderDimensions=160x120");
        });
        Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('1280x720', trackBytesDiv, function () {
            var renderDimensions = { width: 1280, height: 720 };
            videoTrack.setContentPreferences({ renderDimensions: renderDimensions });
            renderHint_1.setText("renderDimensions=1280x720");
        });
    }
    var previousBytes = 0;
    var previousTime = 0;
    return {
        setBytesReceived: function (bytesReceived, timeStamp) {
            if (statBytes) {
                var round = function (num) { return Math.round((num + Number.EPSILON) * 10) / 10; };
                var kBitsPerSecond = round((bytesReceived - previousBytes) / (timeStamp - previousTime)) * 10;
                previousBytes = bytesReceived;
                previousTime = timeStamp;
                statBytes.setText(kBitsPerSecond.toString());
            }
        },
        setFPS: function (fps) {
            trackFPS.setText(fps.toString());
        },
        setAudioLevel: function (audioLevel) {
            trackAudioLevel.setText(audioLevel.toString());
        },
        stopRendering: function () {
            renderedTrack.stopRendering();
            trackBytesDiv.remove();
        }
    };
}


/***/ }),

/***/ "./src/renderRemoteParticipant.ts":
/*!****************************************!*\
  !*** ./src/renderRemoteParticipant.ts ***!
  \****************************************/
/*! exports provided: renderRemoteParticipant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderRemoteParticipant", function() { return renderRemoteParticipant; });
/* harmony import */ var _components_createDiv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/createDiv */ "./src/components/createDiv.ts");
/* harmony import */ var _renderRemoteTrackPublication__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderRemoteTrackPublication */ "./src/renderRemoteTrackPublication.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jss */ "./src/jss.ts");
/* harmony import */ var _components_labeledstat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/labeledstat */ "./src/components/labeledstat.ts");
/* harmony import */ var _components_button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/button */ "./src/components/button.ts");
/* harmony import */ var _components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/createCollapsibleDiv */ "./src/components/createCollapsibleDiv.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};






// Create your style.
var style = {
    background_gray: {
        background: 'gray',
    },
    background_yellow: {
        background: 'yellow',
    },
    background_green: {
        background: 'lightgreen',
    },
    background_red: {
        background: 'red',
    },
    remoteParticipants: {
        display: 'flex',
        height: 'auto',
        margin: 'auto',
        width: '100%',
        'justify-content': 'flex-start',
        'flex-wrap': 'wrap',
        'background-color': '#fff',
        'text-align': 'center',
    },
    roomContainer: {
        display: 'flex',
        margin: '5px',
        'flex-direction': 'column',
        // border: 'solid black 1px',
    },
    remoteTrackControls: {
        /* since it attaches to track container */
        /* does not need top border */
        'border-bottom': 'solid 1px black',
        'border-left': 'solid 1px black',
        'border-right': 'solid 1px black',
    },
    participantDiv: {
        margin: '2px',
        // border: 'solid 1px black'
    },
    participantMediaDiv: {
        padding: '5px',
        display: 'flex',
        'flex-wrap': 'wrap'
    },
    publication: {
        padding: '5px'
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_2__["default"].createStyleSheet(style);
sheet.attach();
function remoteParticipantRestAPI(participant, container, room, restCreds) {
    var _this = this;
    Object(_components_button__WEBPACK_IMPORTED_MODULE_4__["createButton"])('copy exclude participant', container, function () {
        var command = "curl -X POST '" + restCreds.restUrl + "/v1/Rooms/" + room.sid + "/Participants/" + room.localParticipant.sid + "/SubscribeRules'     -u '" + restCreds.signingKeySid + ":" + restCreds.signingKeySecret + "'     -H \"Content-Type: application/x-www-form-urlencoded\"     -d 'Rules=[{\"type\": \"include\", \"all\": true},{\"type\": \"exclude\", \"publisher\": \"" + participant.sid + "\"}]'";
        navigator.clipboard.writeText(command);
    });
    Object(_components_button__WEBPACK_IMPORTED_MODULE_4__["createButton"])('exclude participant', container, function () { return __awaiter(_this, void 0, void 0, function () {
        var fetchResult, json, ex_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 5, , 6]);
                    return [4 /*yield*/, fetch(restCreds.restUrlNoCreds + "/v1/Rooms/" + room.sid + "/Participants/" + room.localParticipant.sid + "/SubscribeRules", {
                            body: "Rules=[{\"type\": \"include\", \"all\": true},{\"type\": \"exclude\", \"publisher\": \"" + participant.sid + "\"}]",
                            headers: {
                                "authorization": 'Basic ' + btoa(restCreds.signingKeySid + ":" + restCreds.signingKeySecret),
                                "content-type": "application/x-www-form-urlencoded",
                                "sec-fetch-mode": "cors",
                                "sec-fetch-site": "cross-site"
                            },
                            method: "POST"
                        })];
                case 1:
                    fetchResult = _a.sent();
                    if (!fetchResult.ok) return [3 /*break*/, 3];
                    return [4 /*yield*/, fetchResult.json()];
                case 2:
                    json = _a.sent();
                    console.log('fetchResult.json = ', json);
                    return [3 /*break*/, 4];
                case 3:
                    console.log('Failed to exclude participant: ', fetchResult);
                    throw new Error('exclude participant error');
                case 4: return [3 /*break*/, 6];
                case 5:
                    ex_1 = _a.sent();
                    console.log('Failed to fetch:', ex_1);
                    throw new Error('Failed to fetch: ' + ex_1);
                case 6: return [2 /*return*/];
            }
        });
    }); });
}
function renderRemoteParticipant(participant, container, room, restCreds, shouldAutoAttach) {
    var _a;
    var outerDiv;
    (_a = Object(_components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_5__["createCollapsibleDiv"])({ container: container, headerText: participant.identity, divClass: sheet.classes.participantDiv }), container = _a.innerDiv, outerDiv = _a.outerDiv);
    // container = createDiv(container, sheet.classes.participantDiv, `participantContainer-${participant.identity}`);
    // createLabeledStat({ container, label: 'class' }).setText('RemoteParticipant');
    // createLabeledStat({ container, label: 'identity' }).setText(participant.identity);
    Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_3__["createLabeledStat"])({ container: container, label: 'sid' }).setText(participant.sid);
    if (restCreds !== null) {
        remoteParticipantRestAPI(participant, container, room, restCreds);
    }
    var participantMedia = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_0__["createDiv"])(container, sheet.classes.participantMediaDiv);
    var renderedPublications = new Map();
    participant.tracks.forEach(function (publication) {
        var rendered = Object(_renderRemoteTrackPublication__WEBPACK_IMPORTED_MODULE_1__["renderRemoteTrackPublication"])(publication, participantMedia, shouldAutoAttach());
        renderedPublications.set(publication.trackSid, rendered);
    });
    participant.on('trackPublished', function (publication) {
        var rendered = Object(_renderRemoteTrackPublication__WEBPACK_IMPORTED_MODULE_1__["renderRemoteTrackPublication"])(publication, participantMedia, shouldAutoAttach());
        renderedPublications.set(publication.trackSid, rendered);
    });
    participant.on('trackUnpublished', function (publication) {
        var rendered = renderedPublications.get(publication.trackSid);
        if (rendered) {
            rendered.stopRendering();
            renderedPublications.delete(publication.trackSid);
        }
    });
    return {
        container: container,
        updateStats: function (_a) {
            var trackSid = _a.trackSid, bytesReceived = _a.bytesReceived, timestamp = _a.timestamp, fps = _a.fps, audioLevel = _a.audioLevel;
            renderedPublications.forEach(function (renderedTrackpublication, renderedTrackSid) {
                if (trackSid === renderedTrackSid) {
                    renderedTrackpublication.setBytesReceived(bytesReceived, timestamp);
                    if (fps !== null) {
                        console.log('TrackFPS: ', fps);
                        renderedTrackpublication.setFPS(fps);
                    }
                    if (audioLevel !== null) {
                        renderedTrackpublication.setAudioLevel(audioLevel);
                    }
                }
            });
        },
        stopRendering: function () {
            renderedPublications.forEach(function (renderedTrackpublication, renderedTrackSid) {
                renderedTrackpublication.stopRendering();
                renderedPublications.delete(renderedTrackSid);
            });
            // container.remove();
            outerDiv.remove();
        }
    };
}


/***/ }),

/***/ "./src/renderRemoteTrackPublication.ts":
/*!*********************************************!*\
  !*** ./src/renderRemoteTrackPublication.ts ***!
  \*********************************************/
/*! exports provided: renderRemoteTrackPublication */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderRemoteTrackPublication", function() { return renderRemoteTrackPublication; });
/* harmony import */ var _components_createDiv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/createDiv */ "./src/components/createDiv.ts");
/* harmony import */ var _components_labeledstat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/labeledstat */ "./src/components/labeledstat.ts");
/* harmony import */ var _components_log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/log */ "./src/components/log.ts");
/* harmony import */ var _renderRemoteMediaTrack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderRemoteMediaTrack */ "./src/renderRemoteMediaTrack.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jss */ "./src/jss.ts");





// Create your style.
var style = {
    background_gray: {
        background: 'gray',
    },
    background_yellow: {
        background: 'yellow',
    },
    background_green: {
        background: 'lightgreen',
    },
    background_red: {
        background: 'red',
    },
    publication: {
        border: 'solid 1px black',
        resize: 'both',
        overflow: 'auto',
        'overflow-y': 'scroll',
        width: '300px',
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_4__["default"].createStyleSheet(style);
sheet.attach();
function renderRemoteTrackPublication(trackPublication, container, autoAttach) {
    var trackContainerId = 'trackPublication_' + trackPublication.trackSid;
    container = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_0__["createDiv"])(container, sheet.classes.publication, trackContainerId);
    Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_1__["createLabeledStat"])({ container: container, label: 'class' }).setText('RemoteTrackPublication');
    Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_1__["createLabeledStat"])({ container: container, label: 'kind' }).setText(trackPublication.kind);
    Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_1__["createLabeledStat"])({ container: container, label: 'trackSid' }).setText(trackPublication.trackSid);
    var renderedTrack;
    function canRenderTrack(track) {
        return track;
    }
    function renderRemoteDataTrack() {
        var track = trackPublication.track;
        track === null || track === void 0 ? void 0 : track.on('message', function (message) {
            console.log(JSON.parse(message)); // { x: <number>, y: <number> }
        });
    }
    function renderRemoteTrack() {
        var track = trackPublication.track;
        if (trackPublication.kind === 'data') {
            renderRemoteDataTrack();
        }
        else {
            if (canRenderTrack(track)) {
                renderedTrack = Object(_renderRemoteMediaTrack__WEBPACK_IMPORTED_MODULE_3__["renderRemoteMediaTrack"])(track, trackPublication, container, autoAttach);
            }
            else {
                console.warn('CanRender returned false for ', track);
            }
        }
    }
    if (trackPublication.isSubscribed) {
        renderRemoteTrack();
    }
    trackPublication.on('subscribed', function (track) {
        Object(_components_log__WEBPACK_IMPORTED_MODULE_2__["log"])("Subscribed to " + trackPublication.kind + ":" + track.name);
        renderRemoteTrack();
    });
    trackPublication.on('unsubscribed', function () {
        renderedTrack === null || renderedTrack === void 0 ? void 0 : renderedTrack.stopRendering();
        renderedTrack = null;
    });
    return {
        setBytesReceived: function (bytesReceived, timeStamp) {
            if (renderedTrack) {
                renderedTrack.setBytesReceived(bytesReceived, timeStamp);
            }
        },
        setFPS: function (fps) {
            if (renderedTrack) {
                renderedTrack.setFPS(fps);
            }
        },
        setAudioLevel: function (audioLevel) {
            if (renderedTrack) {
                renderedTrack.setAudioLevel(audioLevel);
            }
        },
        trackPublication: trackPublication,
        container: container,
        stopRendering: function () {
            if (renderedTrack) {
                renderedTrack.stopRendering();
                renderedTrack = null;
            }
            container.remove();
        }
    };
}


/***/ }),

/***/ "./src/renderRoom.ts":
/*!***************************!*\
  !*** ./src/renderRoom.ts ***!
  \***************************/
/*! exports provided: renderRoomDetails, renderRoom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderRoomDetails", function() { return renderRoomDetails; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderRoom", function() { return renderRoom; });
/* harmony import */ var _components_button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/button */ "./src/components/button.ts");
/* harmony import */ var _components_createDiv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/createDiv */ "./src/components/createDiv.ts");
/* harmony import */ var _components_labeledstat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/labeledstat */ "./src/components/labeledstat.ts");
/* harmony import */ var _components_createLink__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/createLink */ "./src/components/createLink.ts");
/* harmony import */ var _components_createSelection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/createSelection */ "./src/components/createSelection.ts");
/* harmony import */ var _components_log__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/log */ "./src/components/log.ts");
/* harmony import */ var _renderLocalTrack__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderLocalTrack */ "./src/renderLocalTrack.ts");
/* harmony import */ var _renderRemoteParticipant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./renderRemoteParticipant */ "./src/renderRemoteParticipant.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./jss */ "./src/jss.ts");
/* harmony import */ var _components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/createCollapsibleDiv */ "./src/components/createCollapsibleDiv.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/* eslint-disable no-console */










// Create your style.
var style = {
    background_gray: {
        background: 'gray',
    },
    background_yellow: {
        background: 'yellow',
    },
    background_green: {
        background: 'lightgreen',
    },
    background_red: {
        background: 'red',
    },
    remoteParticipants: {
        display: 'flex',
        height: 'auto',
        margin: 'auto',
        width: '100%',
        'justify-content': 'flex-start',
        'flex-wrap': 'wrap',
        'background-color': '#fff',
        'text-align': 'center',
    },
    roomContainer: {
        display: 'flex',
        margin: '5px',
        'flex-direction': 'column',
        // border: 'solid black 1px',
    },
    remoteTrackControls: {
        /* since it attaches to track container */
        /* does not need top border */
        'border-bottom': 'solid 1px black',
        'border-left': 'solid 1px black',
        'border-right': 'solid 1px black',
    },
    participantDiv: {
        margin: '2px',
    },
    participantMediaDiv: {
        padding: '5px',
        display: 'flex',
        'flex-wrap': 'wrap'
    },
    roomHeaderDiv: {
        display: 'flex'
    },
    publication: {
        padding: '5px'
    },
    collapsibleArea: {
        all: 'inherit'
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_8__["default"].createStyleSheet(style);
sheet.attach();
function renderExtraRoomInformation(_a) {
    var room = _a.room, container = _a.container, restCreds = _a.restCreds;
    return __awaiter(this, void 0, void 0, function () {
        var credentialsAt, baseUrl;
        return __generator(this, function (_b) {
            credentialsAt = restCreds.signingKeySid + ":" + restCreds.signingKeySecret + "@";
            baseUrl = restCreds.restUrl;
            Object(_components_createLink__WEBPACK_IMPORTED_MODULE_3__["createLink"])({ container: container, linkText: 'RecordingRules', linkUrl: baseUrl + "/v1/Rooms/" + room.sid + "/RecordingRules", newTab: true });
            Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('copy start recording', container, function () {
                var command = "curl -X POST '" + baseUrl + "/v1/Rooms/" + room.sid + "/RecordingRules'     -u '" + restCreds.signingKeySid + ":" + restCreds.signingKeySecret + "'     -H \"Content-Type: application/x-www-form-urlencoded\"     -d 'Rules=[{\"type\": \"include\", \"all\": \"true\"}]'";
                navigator.clipboard.writeText(command);
            });
            Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('copy stop recording', container, function () {
                var command = "curl -X POST '" + baseUrl + "/v1/Rooms/" + room.sid + "/RecordingRules'     -u '" + restCreds.signingKeySid + ":" + restCreds.signingKeySecret + "'     -H \"Content-Type: application/x-www-form-urlencoded\"     -d 'Rules=[{\"type\": \"exclude\", \"all\": \"true\"}]'";
                navigator.clipboard.writeText(command);
            });
            Object(_components_createLink__WEBPACK_IMPORTED_MODULE_3__["createLink"])({ container: container, linkText: "/v1/Rooms/" + room.sid, linkUrl: baseUrl + "/v1/Rooms/" + room.sid, newTab: true });
            return [2 /*return*/];
        });
    });
}
function getCurrentLoggerLevelAsString(logger) {
    var currentLevel = logger.getLevel();
    console.log('logger currentLevel = ', currentLevel);
    var levelNumToString = new Map();
    levelNumToString.set(logger.levels.TRACE, 'TRACE');
    levelNumToString.set(logger.levels.DEBUG, 'DEBUG');
    levelNumToString.set(logger.levels.INFO, 'INFO');
    levelNumToString.set(logger.levels.WARN, 'WARN');
    levelNumToString.set(logger.levels.ERROR, 'ERROR');
    levelNumToString.set(logger.levels.SILENT, 'SILENT');
    var currentLevelStr = levelNumToString.get(currentLevel);
    return currentLevelStr;
}
function renderRoomDetails(_a) {
    var room = _a.room, container = _a.container, restCreds = _a.restCreds, logger = _a.logger;
    return __awaiter(this, void 0, void 0, function () {
        var _b, innerDiv, collapsible, options, currentLevel, logLevelSelect, roomState, recording, dominantSpeaker, updateDominantSpeaker, networkQuality, updateNetworkQuality, updateRecordingState, updateRoomState, mosScore, updateMos;
        return __generator(this, function (_c) {
            _b = Object(_components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_9__["createCollapsibleDiv"])({ container: container, headerText: "Room Details", divClass: sheet.classes.roomContainer, startHidden: true }), innerDiv = _b.innerDiv, collapsible = _b.outerDiv;
            container = innerDiv;
            options = Object.keys(logger.levels);
            currentLevel = getCurrentLoggerLevelAsString(logger);
            logLevelSelect = Object(_components_createSelection__WEBPACK_IMPORTED_MODULE_4__["createSelection"])({
                id: 'logLevel',
                container: container,
                options: options,
                title: 'logLevel',
                onChange: function () {
                    Object(_components_log__WEBPACK_IMPORTED_MODULE_5__["log"])("setting logLevel: " + logLevelSelect.getValue() + " for " + room.localParticipant.identity + " in " + room.sid);
                    logger.setLevel(logLevelSelect.getValue());
                }
            });
            logLevelSelect.setValue(currentLevel);
            if (restCreds !== null) {
                renderExtraRoomInformation({ room: room, container: container, restCreds: restCreds });
            }
            Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({ container: container, label: 'room.sid' }).setText(room.sid);
            Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({ container: container, label: 'localParticipant.sid' }).setText(room.localParticipant.sid);
            roomState = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
                container: container,
                label: 'state',
                valueMapper: function (text) {
                    switch (text) {
                        case 'connected': return undefined;
                        case 'reconnecting': return sheet.classes.background_yellow;
                        case 'disconnected': return sheet.classes.background_red;
                        default:
                            return sheet.classes.background_red;
                    }
                }
            });
            recording = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
                container: container,
                label: 'isRecording',
                valueMapper: function (text) { return text === 'true' ? sheet.classes.background_red : undefined; }
            });
            dominantSpeaker = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({ container: container, label: 'dominantSpeaker' });
            updateDominantSpeaker = function () { return dominantSpeaker.setText(room.dominantSpeaker ? room.dominantSpeaker.identity : 'none'); };
            room.on('dominantSpeakerChanged', updateDominantSpeaker);
            updateDominantSpeaker();
            networkQuality = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
                container: container,
                label: 'localParticipant.networkQualityLevel',
                valueMapper: function (text) {
                    switch (text) {
                        case 'null':
                            return sheet.classes.background_gray;
                        case '0':
                        case '1':
                            return sheet.classes.background_red;
                        case '2':
                        case '3':
                            return sheet.classes.background_yellow;
                        case '4':
                        case '5':
                            return undefined;
                        default:
                            return sheet.classes.background_red;
                    }
                }
            });
            updateNetworkQuality = function () { return networkQuality.setText("" + room.localParticipant.networkQualityLevel); };
            room.localParticipant.addListener('networkQualityLevelChanged', updateNetworkQuality);
            updateRecordingState = function () { return recording.setText("" + room.isRecording); };
            updateRoomState = function () { return roomState.setText(room.state); };
            mosScore = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_2__["createLabeledStat"])({
                container: container,
                label: 'mos',
            });
            mosScore.setText('null');
            updateMos = function () {
                // @ts-ignore
                var mos = room.mosScore;
                console.log('room.mosScore: ', mos);
                mosScore.setText("" + mos);
            };
            room.addListener('mosScoreChanged', updateMos);
            room.addListener('disconnected', updateRoomState);
            room.addListener('reconnected', updateRoomState);
            room.addListener('reconnecting', updateRoomState);
            room.addListener('recordingStarted', function () {
                Object(_components_log__WEBPACK_IMPORTED_MODULE_5__["log"])('recordingStarted');
                updateRecordingState();
            });
            room.addListener('recordingStopped', function () {
                Object(_components_log__WEBPACK_IMPORTED_MODULE_5__["log"])('recordingStopped');
                updateRecordingState();
            });
            updateRoomState();
            updateRecordingState();
            updateNetworkQuality();
            return [2 /*return*/];
        });
    });
}
function renderRoom(_a) {
    var room = _a.room, container = _a.container, shouldAutoAttach = _a.shouldAutoAttach, restCreds = _a.restCreds, logger = _a.logger;
    return __awaiter(this, void 0, void 0, function () {
        var _b, innerDiv, collapsible, btnDisconnect, isDisconnected, renderedParticipants, remoteParticipantsContainer, statUpdater;
        var _this = this;
        return __generator(this, function (_c) {
            _b = Object(_components_createCollapsibleDiv__WEBPACK_IMPORTED_MODULE_9__["createCollapsibleDiv"])({ container: container, headerText: room.localParticipant.identity, divClass: sheet.classes.roomContainer }), innerDiv = _b.innerDiv, collapsible = _b.outerDiv;
            container = innerDiv;
            // createLabeledStat({ container, label: 'class' }).setText('Room');
            renderRoomDetails({ room: room, container: container, restCreds: restCreds, logger: logger });
            btnDisconnect = Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('disconnect', container, function () {
                room.disconnect();
                collapsible.remove();
            });
            isDisconnected = room.state === 'disconnected';
            // When we are about to transition away from this page, disconnect
            // from the room, if joined.
            window.addEventListener('beforeunload', function () { return room.disconnect(); });
            btnDisconnect.show(!isDisconnected);
            renderedParticipants = new Map();
            remoteParticipantsContainer = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_1__["createDiv"])(container, sheet.classes.remoteParticipants, 'remote-participants');
            room.participants.forEach(function (participant) {
                renderedParticipants.set(participant.sid, Object(_renderRemoteParticipant__WEBPACK_IMPORTED_MODULE_7__["renderRemoteParticipant"])(participant, remoteParticipantsContainer, room, restCreds, shouldAutoAttach));
            });
            // When a Participant joins the Room, log the event.
            room.on('participantConnected', function (participant) {
                renderedParticipants.set(participant.sid, Object(_renderRemoteParticipant__WEBPACK_IMPORTED_MODULE_7__["renderRemoteParticipant"])(participant, remoteParticipantsContainer, room, restCreds, shouldAutoAttach));
            });
            // When a Participant leaves the Room, detach its Tracks.
            room.on('participantDisconnected', function (participant) {
                var rendered = renderedParticipants.get(participant.sid);
                if (rendered) {
                    rendered.stopRendering();
                    renderedParticipants.delete(participant.sid);
                }
            });
            statUpdater = setInterval(function () { return __awaiter(_this, void 0, void 0, function () {
                var statReports;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, room.getStats()];
                        case 1:
                            statReports = _a.sent();
                            statReports.forEach(function (statReport) {
                                // statReport.localVideoTrackStats, can have multiple entries for a local video tracks when simulcast is enabled.
                                // fold them into single entry.
                                var videoTrackStats = new Map();
                                statReport.localVideoTrackStats.forEach(function (trackStat) {
                                    var statArray = videoTrackStats.get(trackStat.trackSid);
                                    if (statArray) {
                                        statArray.push(trackStat);
                                    }
                                    else {
                                        videoTrackStats.set(trackStat.trackSid, [trackStat]);
                                    }
                                });
                                Array.from(videoTrackStats.values()).forEach(function (statArray) { return Object(_renderLocalTrack__WEBPACK_IMPORTED_MODULE_6__["updateLocalTrackStats"])(room, statArray); });
                                // { room, trackId, trackSid, bytesSent, timestamp }
                                statReport.localAudioTrackStats.forEach(function (localAudioTrackStats) { return Object(_renderLocalTrack__WEBPACK_IMPORTED_MODULE_6__["updateLocalTrackStats"])(room, [localAudioTrackStats]); });
                                statReport.remoteAudioTrackStats.forEach(function (trackStat) {
                                    var trackSid = trackStat.trackSid, timestamp = trackStat.timestamp, audioLevel = trackStat.audioLevel;
                                    var bytesReceived = trackStat.bytesReceived || 0;
                                    renderedParticipants.forEach(function (renderedParticipant, participantSid) {
                                        renderedParticipant.updateStats({ trackSid: trackSid, bytesReceived: bytesReceived, timestamp: timestamp, audioLevel: audioLevel, fps: null });
                                    });
                                });
                                statReport.remoteVideoTrackStats.forEach(function (trackStat) {
                                    var trackSid = trackStat.trackSid, timestamp = trackStat.timestamp, frameRate = trackStat.frameRate;
                                    var bytesReceived = trackStat.bytesReceived || 0;
                                    renderedParticipants.forEach(function (renderedParticipant, participantSid) {
                                        renderedParticipant.updateStats({ trackSid: trackSid, bytesReceived: bytesReceived, timestamp: timestamp, audioLevel: null, fps: frameRate });
                                    });
                                });
                            });
                            return [2 /*return*/];
                    }
                });
            }); }, 1000);
            // Once the LocalParticipant leaves the room, detach the Tracks
            // of all Participants, including that of the LocalParticipant.
            room.on('disconnected', function () {
                clearInterval(statUpdater);
                renderedParticipants.forEach(function (renderedParticipant, participantSid) {
                    renderedParticipant.stopRendering();
                    renderedParticipants.delete(participantSid);
                });
            });
            return [2 /*return*/];
        });
    });
}


/***/ }),

/***/ "./src/renderTrack.ts":
/*!****************************!*\
  !*** ./src/renderTrack.ts ***!
  \****************************/
/*! exports provided: attachAudioTrack, attachVideoTrack, renderTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attachAudioTrack", function() { return attachAudioTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attachVideoTrack", function() { return attachVideoTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderTrack", function() { return renderTrack; });
/* harmony import */ var _components_waveform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/waveform */ "./src/components/waveform.ts");
/* harmony import */ var _components_button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/button */ "./src/components/button.ts");
/* harmony import */ var _components_createDiv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/createDiv */ "./src/components/createDiv.ts");
/* harmony import */ var _components_labeledstat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/labeledstat */ "./src/components/labeledstat.ts");
/* harmony import */ var _createTrackStats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createTrackStats */ "./src/createTrackStats.ts");
/* harmony import */ var _jss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./jss */ "./src/jss.ts");






// Create your style.
var style = {
    background_yellow: {
        background: 'yellow'
    },
    trackContainer: {
        // border: 'solid 1px black',
        padding: '5px',
    },
    videoElement: {
        display: 'block',
        'max-width': '100% !important',
        'max-height': '80% !important'
    }
};
// Compile styles, apply plugins.
var sheet = _jss__WEBPACK_IMPORTED_MODULE_5__["default"].createStyleSheet(style);
sheet.attach();
/**
 * Attach the AudioTrack to the HTMLAudioElement and start the Waveform.
 */
function attachAudioTrack(track, container) {
    var audioElement = container.appendChild(track.attach());
    var wave = Object(_components_waveform__WEBPACK_IMPORTED_MODULE_0__["waveform"])({ mediaStream: audioElement.srcObject, width: 200, height: 150 });
    var canvasContainer = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_2__["createDiv"])(container, 'canvasContainer');
    canvasContainer.appendChild(wave.element);
    return {
        mediaElement: audioElement,
        stop: function () { wave.stop(); }
    };
}
function attachVideoTrack(track, container) {
    var videoElement = track.attach();
    videoElement.classList.add(sheet.classes.videoElement);
    container.appendChild(videoElement);
    return {
        mediaElement: videoElement,
        stop: function () { }
    };
}
// Attach the Track to the DOM.
function renderTrack(_a) {
    var track = _a.track, container = _a.container, autoAttach = _a.autoAttach;
    var trackContainer = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_2__["createDiv"])(container, sheet.classes.trackContainer);
    var updateStats = Object(_createTrackStats__WEBPACK_IMPORTED_MODULE_4__["createTrackStats"])(track, trackContainer).updateStats;
    var controlContainer = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_2__["createDiv"])(trackContainer, 'trackControls');
    Object(_components_button__WEBPACK_IMPORTED_MODULE_1__["createButton"])('update', controlContainer, function () { return updateStats(); });
    var mediaControls = null;
    var stopMediaRender = function () { };
    var attachDetachBtn = Object(_components_button__WEBPACK_IMPORTED_MODULE_1__["createButton"])('attach', controlContainer, function () {
        if (mediaControls) {
            // track is already attached.
            track.detach().forEach(function (el) { return el.remove(); });
            mediaControls.remove();
            mediaControls = null;
            attachDetachBtn.text('attach');
        }
        else {
            // track is detached.
            mediaControls = Object(_components_createDiv__WEBPACK_IMPORTED_MODULE_2__["createDiv"])(trackContainer, 'mediaControls');
            var mediaRenderer_1 = track.kind === 'audio' ? attachAudioTrack(track, mediaControls) : attachVideoTrack(track, mediaControls);
            var audioVideoElement_1 = mediaRenderer_1.mediaElement;
            stopMediaRender = function () { return mediaRenderer_1.stop; };
            Object(_components_button__WEBPACK_IMPORTED_MODULE_1__["createButton"])('pause', mediaControls, function () { return audioVideoElement_1 === null || audioVideoElement_1 === void 0 ? void 0 : audioVideoElement_1.pause(); });
            Object(_components_button__WEBPACK_IMPORTED_MODULE_1__["createButton"])('play', mediaControls, function () { return audioVideoElement_1 === null || audioVideoElement_1 === void 0 ? void 0 : audioVideoElement_1.play(); });
            Object(_components_button__WEBPACK_IMPORTED_MODULE_1__["createButton"])('update', mediaControls, function () { return updateMediaElementState_1(); });
            var isPlaying_1 = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_3__["createLabeledStat"])({
                container: mediaControls,
                label: 'playing',
                valueMapper: function (text) { return text === 'false' ? sheet.classes.background_yellow : undefined; }
            });
            var volume_1 = Object(_components_labeledstat__WEBPACK_IMPORTED_MODULE_3__["createLabeledStat"])({
                container: mediaControls,
                label: 'volume'
            });
            // eslint-disable-next-line no-inner-declarations
            var updateMediaElementState_1 = function () {
                isPlaying_1.setText("" + !(audioVideoElement_1 === null || audioVideoElement_1 === void 0 ? void 0 : audioVideoElement_1.paused));
                volume_1.setText("" + (audioVideoElement_1 === null || audioVideoElement_1 === void 0 ? void 0 : audioVideoElement_1.volume));
            };
            audioVideoElement_1.addEventListener('pause', function () { return updateMediaElementState_1(); });
            audioVideoElement_1.addEventListener('play', function () { return updateMediaElementState_1(); });
            attachDetachBtn.text('detach');
            updateMediaElementState_1();
        }
    });
    if (autoAttach) {
        attachDetachBtn.click();
    }
    updateStats();
    return {
        trackContainer: trackContainer,
        track: track,
        updateStats: updateStats,
        stopRendering: function () {
            track.detach().forEach(function (element) {
                element.remove();
                element.srcObject = null;
            });
            trackContainer.remove();
            stopMediaRender();
        }
    };
}


/***/ }),

/***/ "./src/setupPreflight.ts":
/*!*******************************!*\
  !*** ./src/setupPreflight.ts ***!
  \*******************************/
/*! exports provided: setupPreflight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupPreflight", function() { return setupPreflight; });
/* harmony import */ var _components_button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/button */ "./src/components/button.ts");
/* harmony import */ var _components_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/log */ "./src/components/log.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


function setupPreflight(_a) {
    var _this = this;
    var container = _a.container, token = _a.token, Video = _a.Video, environment = _a.environment, renderMSTrack = _a.renderMSTrack;
    var runPreflight = Video.runPreflight;
    var preflightTest = null;
    var flightBtn = Object(_components_button__WEBPACK_IMPORTED_MODULE_0__["createButton"])('runPreflight', container, function () { return __awaiter(_this, void 0, void 0, function () {
        var logger, deferred_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!preflightTest) return [3 /*break*/, 1];
                    // stop on going preflight test
                    preflightTest.stop();
                    flightBtn.text('runPreflight');
                    preflightTest = null;
                    return [3 /*break*/, 3];
                case 1:
                    flightBtn.text('stop');
                    logger = Video.Logger.getLogger('twilio-video');
                    logger.setLevel('DEBUG');
                    console.log('starting runPreflight');
                    preflightTest = runPreflight(token, { duration: 10000, environment: environment });
                    deferred_1 = {};
                    deferred_1.promise = new Promise(function (resolve, reject) {
                        deferred_1.resolve = resolve;
                        deferred_1.reject = reject;
                    });
                    preflightTest.on('progress', function (progress) {
                        Object(_components_log__WEBPACK_IMPORTED_MODULE_1__["log"])('preflight progress:', progress);
                    });
                    preflightTest.on('failed', function (error) {
                        Object(_components_log__WEBPACK_IMPORTED_MODULE_1__["log"])('preflight error:', error);
                        console.error('preflight error:', error);
                        deferred_1.reject && deferred_1.reject(error);
                    });
                    preflightTest.on('completed', function (report) {
                        var _a, _b;
                        Object(_components_log__WEBPACK_IMPORTED_MODULE_1__["log"])("Test completed in " + report.testTiming.duration + " milliseconds.");
                        Object(_components_log__WEBPACK_IMPORTED_MODULE_1__["log"])(" It took " + ((_a = report.networkTiming.connect) === null || _a === void 0 ? void 0 : _a.duration) + " milliseconds to connect");
                        Object(_components_log__WEBPACK_IMPORTED_MODULE_1__["log"])(" It took " + ((_b = report.networkTiming.media) === null || _b === void 0 ? void 0 : _b.duration) + " milliseconds to receive media");
                        Object(_components_log__WEBPACK_IMPORTED_MODULE_1__["log"])('preflight completed:', report);
                        deferred_1.resolve && deferred_1.resolve(report);
                    });
                    // @ts-ignore
                    preflightTest.on('debug', function (payload) {
                        if (payload.localTracks) {
                            console.log('got debug localTracks:', payload.localTracks);
                            payload.localTracks.forEach(function (track) {
                                var msTrack = track;
                                renderMSTrack(msTrack);
                            });
                        }
                        if (payload.remoteTracks) {
                            console.log('got debug remoteTracks:', payload.remoteTracks);
                            payload.remoteTracks.forEach(function (track) {
                                var msTrack = track;
                                renderMSTrack(msTrack);
                            });
                        }
                    });
                    return [4 /*yield*/, deferred_1.promise];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3: return [2 /*return*/];
            }
        });
    }); });
}


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvY2FuY2VsYWJsZXJvb21wcm9taXNlLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvY3JlYXRlbG9jYWx0cmFjay5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9jcmVhdGVsb2NhbHRyYWNrcy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9kYXRhL3JlY2VpdmVyLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L2RhdGEvc2VuZGVyLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L2RhdGEvdHJhbnNjZWl2ZXIuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvZGF0YS90cmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvZW5jb2RpbmdwYXJhbWV0ZXJzLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L2V2ZW50ZW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9sb2NhbHBhcnRpY2lwYW50LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L21lZGlhL3RyYWNrL2F1ZGlvdHJhY2suanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvbWVkaWEvdHJhY2svZXM1L2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L21lZGlhL3RyYWNrL2VzNS9sb2NhbGF1ZGlvdHJhY2suanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvbWVkaWEvdHJhY2svZXM1L2xvY2FsZGF0YXRyYWNrLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L21lZGlhL3RyYWNrL2VzNS9sb2NhbHZpZGVvdHJhY2suanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvbWVkaWEvdHJhY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvbWVkaWEvdHJhY2svbG9jYWxhdWRpb3RyYWNrLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L21lZGlhL3RyYWNrL2xvY2FsYXVkaW90cmFja3B1YmxpY2F0aW9uLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L21lZGlhL3RyYWNrL2xvY2FsZGF0YXRyYWNrLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L21lZGlhL3RyYWNrL2xvY2FsZGF0YXRyYWNrcHVibGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvbWVkaWEvdHJhY2svbG9jYWxtZWRpYXRyYWNrLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L21lZGlhL3RyYWNrL2xvY2FsdHJhY2twdWJsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9tZWRpYS90cmFjay9sb2NhbHZpZGVvdHJhY2suanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvbWVkaWEvdHJhY2svbG9jYWx2aWRlb3RyYWNrcHVibGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvbWVkaWEvdHJhY2svbWVkaWF0cmFjay5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9tZWRpYS90cmFjay9yZWNlaXZlci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9tZWRpYS90cmFjay9yZW1vdGVhdWRpb3RyYWNrLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L21lZGlhL3RyYWNrL3JlbW90ZWF1ZGlvdHJhY2twdWJsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9tZWRpYS90cmFjay9yZW1vdGVkYXRhdHJhY2suanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvbWVkaWEvdHJhY2svcmVtb3RlZGF0YXRyYWNrcHVibGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvbWVkaWEvdHJhY2svcmVtb3RlbWVkaWF0cmFjay5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9tZWRpYS90cmFjay9yZW1vdGV0cmFja3B1YmxpY2F0aW9uLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L21lZGlhL3RyYWNrL3JlbW90ZXZpZGVvdHJhY2suanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvbWVkaWEvdHJhY2svcmVtb3RldmlkZW90cmFja3B1YmxpY2F0aW9uLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L21lZGlhL3RyYWNrL3NlbmRlci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9tZWRpYS90cmFjay90cmFja3B1YmxpY2F0aW9uLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L21lZGlhL3RyYWNrL3RyYW5zY2VpdmVyLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L21lZGlhL3RyYWNrL3ZpZGVvcHJvY2Vzc29yZXZlbnRvYnNlcnZlci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9tZWRpYS90cmFjay92aWRlb3RyYWNrLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L25ldHdvcmtxdWFsaXR5Y29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9wYXJ0aWNpcGFudC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9wcmVmbGlnaHQvZ2V0Q29tYmluZWRDb25uZWN0aW9uU3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvcHJlZmxpZ2h0L2dldHR1cm5jcmVkZW50aWFscy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9wcmVmbGlnaHQvbWFrZXN0YXQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvcHJlZmxpZ2h0L21vcy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9wcmVmbGlnaHQvcHJlZmxpZ2h0dGVzdC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9wcmVmbGlnaHQvc3ludGhldGljYXVkaW8uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvcHJlZmxpZ2h0L3N5bnRoZXRpY3ZpZGVvLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3ByZWZsaWdodC90aW1lci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9xdWV1ZWluZ2V2ZW50ZW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9yZW1vdGVwYXJ0aWNpcGFudC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9yb29tLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3NpZ25hbGluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvbG9jYWxwYXJ0aWNpcGFudC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvbG9jYWx0cmFja3B1YmxpY2F0aW9uLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3NpZ25hbGluZy9wYXJ0aWNpcGFudC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvcmVjb3JkaW5nLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3NpZ25hbGluZy9yZW1vdGVwYXJ0aWNpcGFudC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvcmVtb3RldHJhY2twdWJsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvcm9vbS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvdHJhY2suanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvc2lnbmFsaW5nL3YyL2NhbmNlbGFibGVyb29tc2lnbmFsaW5ncHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvdjIvZG9taW5hbnRzcGVha2Vyc2lnbmFsaW5nLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3NpZ25hbGluZy92Mi9pY2Vib3guanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvc2lnbmFsaW5nL3YyL2ljZWNvbm5lY3Rpb25tb25pdG9yLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3NpZ25hbGluZy92Mi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvdjIvbG9jYWxwYXJ0aWNpcGFudC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvdjIvbG9jYWx0cmFja3B1YmxpY2F0aW9uLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3NpZ25hbGluZy92Mi9tZWRpYXNpZ25hbGluZy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvdjIvbmV0d29ya3F1YWxpdHltb25pdG9yLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3NpZ25hbGluZy92Mi9uZXR3b3JrcXVhbGl0eXNpZ25hbGluZy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvdjIvcGVlcmNvbm5lY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvc2lnbmFsaW5nL3YyL3BlZXJjb25uZWN0aW9ubWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvdjIvcHVibGlzaGVyaGludHNpZ25hbGluZy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvdjIvcmVjb3JkaW5nLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3NpZ25hbGluZy92Mi9yZW1vdGVwYXJ0aWNpcGFudC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvdjIvcmVtb3RldHJhY2twdWJsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zaWduYWxpbmcvdjIvcmVuZGVyaGludHNzaWduYWxpbmcuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvc2lnbmFsaW5nL3YyL3Jvb20uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvc2lnbmFsaW5nL3YyL3RyYWNrcHJpb3JpdHlzaWduYWxpbmcuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvc2lnbmFsaW5nL3YyL3RyYWNrc3dpdGNob2Zmc2lnbmFsaW5nLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3NpZ25hbGluZy92Mi90d2lsaW9jb25uZWN0aW9udHJhbnNwb3J0LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3N0YXRlbWFjaGluZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9hdmVyYWdlLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3N0YXRzL2ljZXJlcG9ydC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9pY2VyZXBvcnRmYWN0b3J5LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3N0YXRzL2xvY2FsYXVkaW90cmFja3N0YXRzLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3N0YXRzL2xvY2FsdHJhY2tzdGF0cy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9sb2NhbHZpZGVvdHJhY2tzdGF0cy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9uZXR3b3JrcXVhbGl0eWF1ZGlvc3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvc3RhdHMvbmV0d29ya3F1YWxpdHliYW5kd2lkdGhzdGF0cy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9uZXR3b3JrcXVhbGl0eWZyYWN0aW9ubG9zdHN0YXRzLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3N0YXRzL25ldHdvcmtxdWFsaXR5bGF0ZW5jeXN0YXRzLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3N0YXRzL25ldHdvcmtxdWFsaXR5bWVkaWFzdGF0cy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9uZXR3b3JrcXVhbGl0eXJlY3ZzdGF0cy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9uZXR3b3JrcXVhbGl0eXNlbmRvcnJlY3ZzdGF0cy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9uZXR3b3JrcXVhbGl0eXNlbmRzdGF0cy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9uZXR3b3JrcXVhbGl0eXN0YXRzLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3N0YXRzL25ldHdvcmtxdWFsaXR5dmlkZW9zdGF0cy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9wZWVyY29ubmVjdGlvbnJlcG9ydC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9wZWVyY29ubmVjdGlvbnJlcG9ydGZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvc3RhdHMvcmVjZWl2ZXJyZXBvcnQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvc3RhdHMvcmVjZWl2ZXJyZXBvcnRmYWN0b3J5LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3N0YXRzL3JlbW90ZWF1ZGlvdHJhY2tzdGF0cy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9yZW1vdGV0cmFja3N0YXRzLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3N0YXRzL3JlbW90ZXZpZGVvdHJhY2tzdGF0cy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9zZW5kZXJvcnJlY2VpdmVycmVwb3J0LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3N0YXRzL3NlbmRlcm9ycmVjZWl2ZXJyZXBvcnRmYWN0b3J5LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3N0YXRzL3NlbmRlcnJlcG9ydC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy9zZW5kZXJyZXBvcnRmYWN0b3J5LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3N0YXRzL3N0YXRzcmVwb3J0LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3N0YXRzL3N1bS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS9zdGF0cy90cmFja3N0YXRzLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3RyYW5zY2VpdmVyLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3R3aWxpb2Nvbm5lY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvdXRpbC9hc3luY3Zhci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS91dGlsL2NhbmNlbGFibGVwcm9taXNlLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3V0aWwvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3V0aWwvZGV0ZWN0c2lsZW50YXVkaW8uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvdXRpbC9kZXRlY3RzaWxlbnR2aWRlby5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS91dGlsL2RvY3VtZW50dmlzaWJpbGl0eW1vbml0b3IuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvdXRpbC9ldmVudG9ic2VydmVyLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3V0aWwvZmlsdGVyLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3V0aWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvdXRpbC9pbnNpZ2h0c3B1Ymxpc2hlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS91dGlsL2luc2lnaHRzcHVibGlzaGVyL251bGwuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvdXRpbC9sb2NhbG1lZGlhcmVzdGFydGRlZmVycmVkcy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS91dGlsL2xvZy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS91dGlsL21vdmluZ2F2ZXJhZ2VkZWx0YS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS91dGlsL25ldHdvcmttb25pdG9yLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3V0aWwvbnVsbG9ic2VydmVyLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3V0aWwvc2RwL2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3V0aWwvc2RwL2lzc3VlODMyOS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS91dGlsL3NkcC9zaW11bGNhc3QuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvdXRpbC9zZHAvdHJhY2ttYXRjaGVyL2lkZW50aXR5LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3V0aWwvc2RwL3RyYWNrbWF0Y2hlci9taWQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvdXRpbC9zZHAvdHJhY2ttYXRjaGVyL29yZGVyZWQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvdXRpbC9zdXBwb3J0LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3V0aWwvdGltZW91dC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS91dGlsL3R3aWxpby12aWRlby1lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvdXRpbC90d2lsaW9lcnJvci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS91dGlsL3ZhbGlkYXRlLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvZXM1L3ZlbmRvci9sb2dsZXZlbC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS93ZWJhdWRpby9hdWRpb2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9lczUvd2ViYXVkaW8vZGV0ZWN0c2lsZW5jZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL2VzNS93ZWJhdWRpby93b3JrYXJvdW5kMTgwNzQ4LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvbm9kZV9tb2R1bGVzL0B0d2lsaW8vd2VicnRjL2xpYi9nZXRzdGF0cy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL25vZGVfbW9kdWxlcy9AdHdpbGlvL3dlYnJ0Yy9saWIvZ2V0dXNlcm1lZGlhLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvbm9kZV9tb2R1bGVzL0B0d2lsaW8vd2VicnRjL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL25vZGVfbW9kdWxlcy9AdHdpbGlvL3dlYnJ0Yy9saWIvbWVkaWFzdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9ub2RlX21vZHVsZXMvQHR3aWxpby93ZWJydGMvbGliL21lZGlhc3RyZWFtdHJhY2suanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9ub2RlX21vZHVsZXMvQHR3aWxpby93ZWJydGMvbGliL3J0Y2ljZWNhbmRpZGF0ZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL25vZGVfbW9kdWxlcy9AdHdpbGlvL3dlYnJ0Yy9saWIvcnRjcGVlcmNvbm5lY3Rpb24vY2hyb21lLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvbm9kZV9tb2R1bGVzL0B0d2lsaW8vd2VicnRjL2xpYi9ydGNwZWVyY29ubmVjdGlvbi9maXJlZm94LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvbm9kZV9tb2R1bGVzL0B0d2lsaW8vd2VicnRjL2xpYi9ydGNwZWVyY29ubmVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL25vZGVfbW9kdWxlcy9AdHdpbGlvL3dlYnJ0Yy9saWIvcnRjcGVlcmNvbm5lY3Rpb24vc2FmYXJpLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvbm9kZV9tb2R1bGVzL0B0d2lsaW8vd2VicnRjL2xpYi9ydGNydHBzZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9ub2RlX21vZHVsZXMvQHR3aWxpby93ZWJydGMvbGliL3J0Y3Nlc3Npb25kZXNjcmlwdGlvbi9jaHJvbWUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9ub2RlX21vZHVsZXMvQHR3aWxpby93ZWJydGMvbGliL3J0Y3Nlc3Npb25kZXNjcmlwdGlvbi9maXJlZm94LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvbm9kZV9tb2R1bGVzL0B0d2lsaW8vd2VicnRjL2xpYi9ydGNzZXNzaW9uZGVzY3JpcHRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9ub2RlX21vZHVsZXMvQHR3aWxpby93ZWJydGMvbGliL3V0aWwvZXZlbnR0YXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9ub2RlX21vZHVsZXMvQHR3aWxpby93ZWJydGMvbGliL3V0aWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9ub2RlX21vZHVsZXMvQHR3aWxpby93ZWJydGMvbGliL3V0aWwvbGF0Y2guanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9ub2RlX21vZHVsZXMvQHR3aWxpby93ZWJydGMvbGliL3V0aWwvc2RwLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvbm9kZV9tb2R1bGVzL2JhY2tvZmYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9ub2RlX21vZHVsZXMvYmFja29mZi9saWIvYmFja29mZi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL25vZGVfbW9kdWxlcy9iYWNrb2ZmL2xpYi9mdW5jdGlvbl9jYWxsLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvbm9kZV9tb2R1bGVzL2JhY2tvZmYvbGliL3N0cmF0ZWd5L2V4cG9uZW50aWFsLmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvbm9kZV9tb2R1bGVzL2JhY2tvZmYvbGliL3N0cmF0ZWd5L2ZpYm9uYWNjaS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL25vZGVfbW9kdWxlcy9iYWNrb2ZmL2xpYi9zdHJhdGVneS9zdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL25vZGVfbW9kdWxlcy9wcmVjb25kL2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvbXBhdHdhcmRoYW4vd29yay90d2lsaW8tdmlkZW8uanMvbm9kZV9tb2R1bGVzL3ByZWNvbmQvbGliL2NoZWNrcy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21wYXR3YXJkaGFuL3dvcmsvdHdpbGlvLXZpZGVvLmpzL25vZGVfbW9kdWxlcy9wcmVjb25kL2xpYi9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tcGF0d2FyZGhhbi93b3JrL3R3aWxpby12aWRlby5qcy9zcmMvd3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtdmVuZG9yL2Rpc3QvY3NzLXZlbmRvci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h5cGhlbmF0ZS1zdHlsZS1uYW1lL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy1pbi1icm93c2VyL2Rpc3QvbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLWNhbWVsLWNhc2UvZGlzdC9qc3MtcGx1Z2luLWNhbWVsLWNhc2UuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLWNvbXBvc2UvZGlzdC9qc3MtcGx1Z2luLWNvbXBvc2UuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLWRlZmF1bHQtdW5pdC9kaXN0L2pzcy1wbHVnaW4tZGVmYXVsdC11bml0LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1leHBhbmQvZGlzdC9qc3MtcGx1Z2luLWV4cGFuZC5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tZXh0ZW5kL2Rpc3QvanNzLXBsdWdpbi1leHRlbmQuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLWdsb2JhbC9kaXN0L2pzcy1wbHVnaW4tZ2xvYmFsLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1uZXN0ZWQvZGlzdC9qc3MtcGx1Z2luLW5lc3RlZC5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tcHJvcHMtc29ydC9kaXN0L2pzcy1wbHVnaW4tcHJvcHMtc29ydC5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tcnVsZS12YWx1ZS1mdW5jdGlvbi9kaXN0L2pzcy1wbHVnaW4tcnVsZS12YWx1ZS1mdW5jdGlvbi5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tcnVsZS12YWx1ZS1vYnNlcnZhYmxlL2Rpc3QvanNzLXBsdWdpbi1ydWxlLXZhbHVlLW9ic2VydmFibGUuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLXRlbXBsYXRlL2Rpc3QvanNzLXBsdWdpbi10ZW1wbGF0ZS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tdmVuZG9yLXByZWZpeGVyL2Rpc3QvanNzLXBsdWdpbi12ZW5kb3ItcHJlZml4ZXIuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MtcHJlc2V0LWRlZmF1bHQvZGlzdC9qc3MtcHJlc2V0LWRlZmF1bHQuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3MvZGlzdC9qc3MuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9lcy9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGlueS13YXJuaW5nL2Rpc3QvdGlueS13YXJuaW5nLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9hcHAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9uLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2NyZWF0ZUNvbGxhcHNpYmxlRGl2LnRzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2NyZWF0ZURpdi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9jcmVhdGVFbGVtZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2NyZWF0ZUxhYmVsZWRDaGVja2JveC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9jcmVhdGVMYWJlbGVkSW5wdXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvY3JlYXRlTGluay50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9jcmVhdGVTZWxlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvZ2V0QXVkaW9Db250ZXh0LnRzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2dldEJvb2xlYW5VcmxQYXJhbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9sYWJlbGVkc3RhdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9sb2cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvc3ludGhldGljYXVkaW8udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvc3ludGhldGljdmlkZW8udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvd2F2ZWZvcm0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NyZWF0ZUxvY2FsVHJhY2tzQ29udHJvbHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NyZWF0ZVJvb21Db250cm9scy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY3JlYXRlVHJhY2tTdGF0cy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGVtby50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2V0Q3JlZHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dldERldmljZVNlbGVjdGlvbk9wdGlvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmFuZG9tSXRlbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmFuZG9tTmFtZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyTG9jYWxUcmFjay50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyTG9jYWxUcmFja1N0YXRzLnRzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJSZW1vdGVNZWRpYVRyYWNrLnRzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJSZW1vdGVQYXJ0aWNpcGFudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyUmVtb3RlVHJhY2tQdWJsaWNhdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyUm9vbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyVHJhY2sudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHVwUHJlZmxpZ2h0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qs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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlDQUFpQyxFQUFFO0FBQzNFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMkNBQTJDLDJEQUEyRDtBQUN0RztBQUNBO0FBQ0EsaUJBQWlCLGdDQUFnQztBQUNqRDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLDBDQUEwQyxFQUFFO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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TztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELHVDQUF1QztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELHVDQUF1QztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELHFDQUFxQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELHVDQUF1QztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELDBDQUEwQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELGtDQUFrQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELDhDQUE4QztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELHlDQUF5QztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELDhDQUE4QztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELDhDQUE4QztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELGtDQUFrQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELDhCQUE4QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Es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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELHFDQUFxQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELHlDQUF5QztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELG9EQUFvRDtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELDRCQUE0QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELHlDQUF5QztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELHlDQUF5QztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELDhDQUE4QztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELDJDQUEyQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELGtDQUFrQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELDJDQUEyQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELDJCQUEyQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELCtCQUErQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELCtCQUErQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELG9DQUFvQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELG9DQUFvQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELDhDQUE4QztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELHlDQUF5QztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELHlDQUF5QztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELDBDQUEwQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELDBDQUEwQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaURBQWlELG9DQUFv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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscURBQXFELGtCQUFrQjtBQUN2RTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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LEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3QkFBd0I7QUFDbEU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdCQUF3QjtBQUNoRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQXdCO0FBQ2hFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDLHFDQUFxQzs7QUFFckM7QUFDQSxrRUFBa0U7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0IsNEZBQWtCO0FBQ3BDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBLElBQUkscURBQVc7QUFDZixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7O0FBRXZCLE1BQU0sS0FBb0M7QUFDMUM7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsaUJBQWlCLDhCQUE4QjtBQUMvQyxnRUFBZ0U7O0FBRWhFO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUkscURBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCwwQ0FBMEM7O0FBRTFDLE1BQU0sS0FBb0M7QUFDMUM7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLCtDQUErQzs7QUFFL0MsMkVBQTJFOztBQUUzRSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7O0FBRXlFOzs7Ozs7Ozs7Ozs7O0FDNWpCekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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QUFjLG9EQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsR0FBRztBQUNILDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSwwRUFBVyxFQUFDOzs7Ozs7Ozs7Ozs7O0FDM1AzQjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUIsK0JBQStCO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdB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Q3BELHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0ZBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGVBQWU7QUFDcEI7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEOztBQUU5RCw4REFBOEQ7O0FBRTlEO0FBQ0EsS0FBSztBQUNMLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrRkFBUSxHQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1Q0FBdUM7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHdDQUF3QztBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHlDQUF5QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHlDQUF5QztBQUM1RDtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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VUFBUSxDQUFDLE9BQU8sSUFBSSxVQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUMvQyxDQUFDLENBQUMsQ0FBQztvQkFFSCxhQUFhO29CQUNiLGFBQWEsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLGlCQUFPO3dCQUMvQixJQUFJLE9BQU8sQ0FBQyxXQUFXLEVBQUU7NEJBQ3ZCLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0JBQXdCLEVBQUUsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDOzRCQUMzRCxPQUFPLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxVQUFDLEtBQXVCO2dDQUNsRCxJQUFNLE9BQU8sR0FBRyxLQUF5QixDQUFDO2dDQUMxQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7NEJBQ3pCLENBQUMsQ0FBQyxDQUFDO3lCQUNKO3dCQUVELElBQUksT0FBTyxDQUFDLFlBQVksRUFBRTs0QkFDeEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyx5QkFBeUIsRUFBRSxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7NEJBQzdELE9BQU8sQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFVBQUMsS0FBdUI7Z0NBQ25ELElBQU0sT0FBTyxHQUFHLEtBQXlCLENBQUM7Z0NBQzFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQzs0QkFDekIsQ0FBQyxDQUFDLENBQUM7eUJBQ0o7b0JBQ0gsQ0FBQyxDQUFDLENBQUM7b0JBQ0gscUJBQU0sVUFBUSxDQUFDLE9BQU87O29CQUF0QixTQUFzQixDQUFDOzs7OztTQUUxQixDQUFDLENBQUM7QUFDTCxDQUFDIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2FwcC50c1wiKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBDYW5jZWxhYmxlUHJvbWlzZSA9IHJlcXVpcmUoJy4vdXRpbC9jYW5jZWxhYmxlcHJvbWlzZScpO1xuLyoqXG4gKiBDcmVhdGUgYSB7QGxpbmsgQ2FuY2VsYWJsZVByb21pc2U8Um9vbT59LlxuICogQHBhcmFtIHtmdW5jdGlvbihmdW5jdGlvbihBcnJheTxMb2NhbFRyYWNrPik6IENhbmNlbGFibGVQcm9taXNlPFJvb21TaWduYWxpbmc+KTpcbiAqICAgUHJvbWlzZTxmdW5jdGlvbigpOiBDYW5jZWxhYmxlUHJvbWlzZTxSb29tU2lnbmFsaW5nPj59IGdldExvY2FsVHJhY2tzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEFycmF5PExvY2FsVHJhY2s+KTogTG9jYWxQYXJ0aWNpcGFudH0gY3JlYXRlTG9jYWxQYXJ0aWNpcGFudFxuICogQHBhcmFtIHtmdW5jdGlvbihBcnJheTxMb2NhbFRyYWNrPik6IENhbmNlbGFibGVQcm9taXNlPFJvb21TaWduYWxpbmc+fSBjcmVhdGVSb29tU2lnbmFsaW5nXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKExvY2FsUGFydGljaXBhbnQsIFJvb21TaWduYWxpbmcpOiBSb29tfSBjcmVhdGVSb29tXG4gKiBAcmV0dXJucyBDYW5jZWxhYmxlUHJvbWlzZTxSb29tPlxuICovXG5mdW5jdGlvbiBjcmVhdGVDYW5jZWxhYmxlUm9vbVByb21pc2UoZ2V0TG9jYWxUcmFja3MsIGNyZWF0ZUxvY2FsUGFydGljaXBhbnQsIGNyZWF0ZVJvb21TaWduYWxpbmcsIGNyZWF0ZVJvb20pIHtcbiAgICB2YXIgY2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlO1xuICAgIHZhciBjYW5jZWxsYXRpb25FcnJvciA9IG5ldyBFcnJvcignQ2FuY2VsZWQnKTtcbiAgICByZXR1cm4gbmV3IENhbmNlbGFibGVQcm9taXNlKGZ1bmN0aW9uIG9uQ3JlYXRlKHJlc29sdmUsIHJlamVjdCwgaXNDYW5jZWxlZCkge1xuICAgICAgICB2YXIgbG9jYWxQYXJ0aWNpcGFudDtcbiAgICAgICAgZ2V0TG9jYWxUcmFja3MoZnVuY3Rpb24gZ2V0TG9jYWxUcmFja3NTdWNjZWVkZWQobG9jYWxUcmFja3MpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbmNlbGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FuY2VsYWJsZVByb21pc2UucmVqZWN0KGNhbmNlbGxhdGlvbkVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUGFydGljaXBhbnQgPSBjcmVhdGVMb2NhbFBhcnRpY2lwYW50KGxvY2FsVHJhY2tzKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVSb29tU2lnbmFsaW5nKGxvY2FsUGFydGljaXBhbnQpLnRoZW4oZnVuY3Rpb24gY3JlYXRlUm9vbVNpZ25hbGluZ1N1Y2NlZWRlZChnZXRDYW5jZWxhYmxlUm9vbVNpZ25hbGluZ1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDYW5jZWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNhbmNlbGxhdGlvbkVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlUm9vbVNpZ25hbGluZ1Byb21pc2UgPSBnZXRDYW5jZWxhYmxlUm9vbVNpZ25hbGluZ1Byb21pc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gcm9vbVNpZ25hbGluZ0Nvbm5lY3RlZChyb29tU2lnbmFsaW5nKSB7XG4gICAgICAgICAgICBpZiAoaXNDYW5jZWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcm9vbVNpZ25hbGluZy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgY2FuY2VsbGF0aW9uRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGNyZWF0ZVJvb20obG9jYWxQYXJ0aWNpcGFudCwgcm9vbVNpZ25hbGluZykpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiBvbkNhbmNlbCgpIHtcbiAgICAgICAgaWYgKGNhbmNlbGFibGVSb29tU2lnbmFsaW5nUHJvbWlzZSkge1xuICAgICAgICAgICAgY2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNhbmNlbGFibGVSb29tUHJvbWlzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbmNlbGFibGVyb29tcHJvbWlzZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgTWVkaWFTdHJlYW1UcmFjayA9IHJlcXVpcmUoJ0B0d2lsaW8vd2VicnRjJykuTWVkaWFTdHJlYW1UcmFjaztcbnZhciBfYSA9IHJlcXVpcmUoJ0B0d2lsaW8vd2VicnRjL2xpYi91dGlsJyksIGd1ZXNzQnJvd3NlciA9IF9hLmd1ZXNzQnJvd3NlciwgZ3Vlc3NCcm93c2VyVmVyc2lvbiA9IF9hLmd1ZXNzQnJvd3NlclZlcnNpb247XG52YXIgY3JlYXRlQ2FuY2VsYWJsZVJvb21Qcm9taXNlID0gcmVxdWlyZSgnLi9jYW5jZWxhYmxlcm9vbXByb21pc2UnKTtcbnZhciBjcmVhdGVMb2NhbFRyYWNrcyA9IHJlcXVpcmUoJy4vY3JlYXRlbG9jYWx0cmFja3MnKTtcbnZhciBFbmNvZGluZ1BhcmFtZXRlcnNJbXBsID0gcmVxdWlyZSgnLi9lbmNvZGluZ3BhcmFtZXRlcnMnKTtcbnZhciBMb2NhbFBhcnRpY2lwYW50ID0gcmVxdWlyZSgnLi9sb2NhbHBhcnRpY2lwYW50Jyk7XG52YXIgX2IgPSByZXF1aXJlKCcuL21lZGlhL3RyYWNrL2VzNScpLCBMb2NhbEF1ZGlvVHJhY2sgPSBfYi5Mb2NhbEF1ZGlvVHJhY2ssIExvY2FsRGF0YVRyYWNrID0gX2IuTG9jYWxEYXRhVHJhY2ssIExvY2FsVmlkZW9UcmFjayA9IF9iLkxvY2FsVmlkZW9UcmFjaztcbnZhciBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25JbXBsID0gcmVxdWlyZSgnLi9uZXR3b3JrcXVhbGl0eWNvbmZpZ3VyYXRpb24nKTtcbnZhciBSb29tID0gcmVxdWlyZSgnLi9yb29tJyk7XG52YXIgU2lnbmFsaW5nVjIgPSByZXF1aXJlKCcuL3NpZ25hbGluZy92MicpO1xudmFyIF9jID0gcmVxdWlyZSgnLi91dGlsJyksIGFzTG9jYWxUcmFjayA9IF9jLmFzTG9jYWxUcmFjaywgYnVpbGRMb2dMZXZlbHMgPSBfYy5idWlsZExvZ0xldmVscywgZmlsdGVyT2JqZWN0ID0gX2MuZmlsdGVyT2JqZWN0LCBpc05vbkFycmF5T2JqZWN0ID0gX2MuaXNOb25BcnJheU9iamVjdDtcbnZhciBfZCA9IHJlcXVpcmUoJy4vdXRpbC9jb25zdGFudHMnKSwgREVGQVVMVF9FTlZJUk9OTUVOVCA9IF9kLkRFRkFVTFRfRU5WSVJPTk1FTlQsIERFRkFVTFRfTE9HX0xFVkVMID0gX2QuREVGQVVMVF9MT0dfTEVWRUwsIERFRkFVTFRfTE9HR0VSX05BTUUgPSBfZC5ERUZBVUxUX0xPR0dFUl9OQU1FLCBERUZBVUxUX1JFQUxNID0gX2QuREVGQVVMVF9SRUFMTSwgREVGQVVMVF9SRUdJT04gPSBfZC5ERUZBVUxUX1JFR0lPTiwgV1NfU0VSVkVSID0gX2QuV1NfU0VSVkVSLCBFID0gX2QudHlwZUVycm9ycztcbnZhciBDYW5jZWxhYmxlUHJvbWlzZSA9IHJlcXVpcmUoJy4vdXRpbC9jYW5jZWxhYmxlcHJvbWlzZScpO1xudmFyIEV2ZW50T2JzZXJ2ZXIgPSByZXF1aXJlKCcuL3V0aWwvZXZlbnRvYnNlcnZlcicpO1xudmFyIERlZmF1bHRMb2cgPSByZXF1aXJlKCcuL3V0aWwvbG9nJyk7XG52YXIgdmFsaWRhdGVCYW5kd2lkdGhQcm9maWxlID0gcmVxdWlyZSgnLi91dGlsL3ZhbGlkYXRlJykudmFsaWRhdGVCYW5kd2lkdGhQcm9maWxlO1xudmFyIHNhZmFyaVZlcnNpb24gPSBndWVzc0Jyb3dzZXIoKSA9PT0gJ3NhZmFyaScgJiYgZ3Vlc3NCcm93c2VyVmVyc2lvbigpO1xuLy8gVGhpcyBpcyB1c2VkIHRvIG1ha2Ugb3V0IHdoaWNoIGNvbm5lY3QoKSBjYWxsIGEgcGFydGljdWxhciBMb2cgc3RhdGVtZW50XG4vLyBiZWxvbmdzIHRvLiBFYWNoIGNhbGwgdG8gY29ubmVjdCgpIGluY3JlbWVudHMgdGhpcyBjb3VudGVyLlxudmFyIGNvbm5lY3RDYWxscyA9IDA7XG52YXIgZGlkUHJpbnRTYWZhcmlXYXJuaW5nID0gZmFsc2U7XG52YXIgaXNTYWZhcmlXaXRob3V0VlA4U3VwcG9ydCA9IGZhbHNlO1xuaWYgKHNhZmFyaVZlcnNpb24pIHtcbiAgICB2YXIgc2FmYXJpTWFqb3JWZXJzaW9uID0gc2FmYXJpVmVyc2lvbi5tYWpvciwgc2FmYXJpTWlub3JWZXJzaW9uID0gc2FmYXJpVmVyc2lvbi5taW5vcjtcbiAgICBpc1NhZmFyaVdpdGhvdXRWUDhTdXBwb3J0ID0gc2FmYXJpTWFqb3JWZXJzaW9uIDwgMTIgfHwgKHNhZmFyaU1ham9yVmVyc2lvbiA9PT0gMTIgJiYgc2FmYXJpTWlub3JWZXJzaW9uIDwgMSk7XG59XG52YXIgZGVwcmVjYXRlZENvbm5lY3RPcHRpb25zUHJvcHMgPSBuZXcgU2V0KFtcbiAgICB7IGRpZFdhcm46IGZhbHNlLCBzaG91bGREZWxldGU6IHRydWUsIG5hbWU6ICdhYm9ydE9uSWNlU2VydmVyc1RpbWVvdXQnIH0sXG4gICAgeyBkaWRXYXJuOiBmYWxzZSwgc2hvdWxkRGVsZXRlOiB0cnVlLCBuYW1lOiAnZHNjcFRhZ2dpbmcnLCBuZXdOYW1lOiAnZW5hYmxlRHNjcCcgfSxcbiAgICB7IGRpZFdhcm46IGZhbHNlLCBzaG91bGREZWxldGU6IHRydWUsIG5hbWU6ICdpY2VTZXJ2ZXJzVGltZW91dCcgfSxcbiAgICB7IGRpZFdhcm46IGZhbHNlLCBzaG91bGREZWxldGU6IGZhbHNlLCBuYW1lOiAnZXZlbnRMaXN0ZW5lcicsIG5ld05hbWU6ICdWaWRlby5Mb2dnZXInIH0sXG4gICAgeyBkaWRXYXJuOiBmYWxzZSwgc2hvdWxkRGVsZXRlOiBmYWxzZSwgbmFtZTogJ2xvZ0xldmVsJywgbmV3TmFtZTogJ1ZpZGVvLkxvZ2dlcicgfSxcbl0pO1xudmFyIGRlcHJlY2F0ZWRCYW5kd2lkdGhQcm9maWxlT3B0aW9ucyA9IG5ldyBTZXQoW1xuICAgIHsgZGlkV2FybjogZmFsc2UsIHNob3VsZERlbGV0ZTogZmFsc2UsIG5hbWU6ICdtYXhUcmFja3MnLCBuZXdOYW1lOiAnYmFuZHdpZHRoUHJvZmlsZS52aWRlby5jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wnIH0sXG4gICAgeyBkaWRXYXJuOiBmYWxzZSwgc2hvdWxkRGVsZXRlOiBmYWxzZSwgbmFtZTogJ3JlbmRlckRpbWVuc2lvbnMnLCBuZXdOYW1lOiAnYmFuZHdpZHRoUHJvZmlsZS52aWRlby5jb250ZW50UHJlZmVyZW5jZXNNb2RlJyB9LFxuXSk7XG4vKipcbiAqIENvbm5lY3QgdG8gYSB7QGxpbmsgUm9vbX0uXG4gKiAgIDxicj48YnI+XG4gKiAgIEJ5IGRlZmF1bHQsIHRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IGFjcXVpcmUgYW4gYXJyYXkgY29udGFpbmluZyBhXG4gKiAgIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IGFuZCB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSBiZWZvcmUgY29ubmVjdGluZyB0b1xuICogICB0aGUge0BsaW5rIFJvb219LiBUaGVzZSB3aWxsIGJlIHN0b3BwZWQgd2hlbiB5b3UgZGlzY29ubmVjdCBmcm9tIHRoZVxuICogICB7QGxpbmsgUm9vbX0uXG4gKiAgIDxicj48YnI+XG4gKiAgIFlvdSBjYW4gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3IgYnkgc3BlY2lmeWluZ1xuICogICA8Y29kZT5vcHRpb25zPC9jb2RlPi4gRm9yIGV4YW1wbGUsIHJhdGhlciB0aGFuIGFjcXVpcmluZyBhXG4gKiAgIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IGFuZCB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSBhdXRvbWF0aWNhbGx5LCB5b3UgY2FuXG4gKiAgIHBhc3MgeW91ciBvd24gYXJyYXkgd2hpY2ggeW91IGNhbiBzdG9wIHlvdXJzZWxmLiBTZWUge0BsaW5rIENvbm5lY3RPcHRpb25zfVxuICogICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBhbGlhcyBtb2R1bGU6dHdpbGlvLXZpZGVvLmNvbm5lY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIFRoZSBBY2Nlc3MgVG9rZW4gc3RyaW5nXG4gKiBAcGFyYW0ge0Nvbm5lY3RPcHRpb25zfSBbb3B0aW9uc10gLSBPcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yLCBpbnZhbGlkIG9wdGlvbnMgYXJlIGlnbm9yZWQuXG4gKiBAcmV0dXJucyB7Q2FuY2VsYWJsZVByb21pc2U8Um9vbT59XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICogQHRocm93cyB7VHdpbGlvRXJyb3J9XG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKiBAZXhhbXBsZVxuICogdmFyIFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gKiB2YXIgdG9rZW4gPSBnZXRBY2Nlc3NUb2tlbigpO1xuICogVmlkZW8uY29ubmVjdCh0b2tlbiwge1xuICogICBuYW1lOiAnbXktY29vbC1yb29tJ1xuICogfSkudGhlbihmdW5jdGlvbihyb29tKSB7XG4gKiAgIHJvb20ub24oJ3BhcnRpY2lwYW50Q29ubmVjdGVkJywgZnVuY3Rpb24ocGFydGljaXBhbnQpIHtcbiAqICAgICBjb25zb2xlLmxvZyhwYXJ0aWNpcGFudC5pZGVudGl0eSArICcgaGFzIGNvbm5lY3RlZCcpO1xuICogICB9KTtcblxuICogICByb29tLm9uY2UoJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uKCkge1xuICogICAgIGNvbnNvbGUubG9nKCdZb3UgbGVmdCB0aGUgUm9vbTonLCByb29tLm5hbWUpO1xuICogICB9KTtcbiAqIH0pLmNhdGNoKGVycm9yID0+IHtcbiAqICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBjb25uZWN0IHRvIHRoZSBSb29tOicsIGVycm9yLm1lc3NhZ2UpO1xuICogfSk7XG4gKiBAZXhhbXBsZVxuICogdmFyIFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gKiB2YXIgdG9rZW4gPSBnZXRBY2Nlc3NUb2tlbigpO1xuICpcbiAqIC8vIENvbm5lY3Qgd2l0aCBhdWRpby1vbmx5XG4gKiBWaWRlby5jb25uZWN0KHRva2VuLCB7XG4gKiAgIG5hbWU6ICdteS1jb29sLXJvb20nLFxuICogICBhdWRpbzogdHJ1ZVxuICogfSkudGhlbihmdW5jdGlvbihyb29tKSB7XG4gKiAgIHJvb20ub24oJ3BhcnRpY2lwYW50Q29ubmVjdGVkJywgZnVuY3Rpb24ocGFydGljaXBhbnQpIHtcbiAqICAgICBjb25zb2xlLmxvZyhwYXJ0aWNpcGFudC5pZGVudGl0eSArICcgaGFzIGNvbm5lY3RlZCcpO1xuICogICB9KTtcbiAqXG4gKiAgIHJvb20ub25jZSgnZGlzY29ubmVjdGVkJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ1lvdSBsZWZ0IHRoZSBSb29tOicsIHJvb20ubmFtZSk7XG4gKiAgIH0pO1xuICogfSkuY2F0Y2goZXJyb3IgPT4ge1xuICogICBjb25zb2xlLmxvZygnQ291bGQgbm90IGNvbm5lY3QgdG8gdGhlIFJvb206JywgZXJyb3IubWVzc2FnZSk7XG4gKiB9KTtcbiAqIEBleGFtcGxlXG4gKiB2YXIgVmlkZW8gPSByZXF1aXJlKCd0d2lsaW8tdmlkZW8nKTtcbiAqIHZhciB0b2tlbiA9IGdldEFjY2Vzc1Rva2VuKCk7XG4gKlxuICogLy8gQ29ubmVjdCB3aXRoIG1lZGlhIGFjcXVpcmVkIHVzaW5nIGdldFVzZXJNZWRpYSgpXG4gKiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gKiAgIGF1ZGlvOiB0cnVlLFxuICogICB2aWRlbzogdHJ1ZVxuICogfSkudGhlbihmdW5jdGlvbihtZWRpYVN0cmVhbSkge1xuICogICByZXR1cm4gVmlkZW8uY29ubmVjdCh0b2tlbiwge1xuICogICAgIG5hbWU6ICdteS1jb29sLXJvb20nLFxuICogICAgIHRyYWNrczogbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKClcbiAqICAgfSk7XG4gKiB9KS50aGVuKGZ1bmN0aW9uKHJvb20pIHtcbiAqICAgcm9vbS5vbigncGFydGljaXBhbnRDb25uZWN0ZWQnLCBmdW5jdGlvbihwYXJ0aWNpcGFudCkge1xuICogICAgIGNvbnNvbGUubG9nKHBhcnRpY2lwYW50LmlkZW50aXR5ICsgJyBoYXMgY29ubmVjdGVkJyk7XG4gKiAgIH0pO1xuICpcbiAqICAgcm9vbS5vbmNlKCdkaXNjb25uZWN0ZWQnLCBmdW5jdGlvbigpIHtcbiAqICAgICBjb25zb2xlLmxvZygnWW91IGxlZnQgdGhlIFJvb206Jywgcm9vbS5uYW1lKTtcbiAqICAgfSk7XG4gKiB9KS5jYXRjaChlcnJvciA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdDb3VsZCBub3QgY29ubmVjdCB0byB0aGUgUm9vbTonLCBlcnJvci5tZXNzYWdlKTtcbiAqIH0pO1xuICogQGV4YW1wbGVcbiAqIHZhciBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICogdmFyIHRva2VuID0gZ2V0QWNjZXNzVG9rZW4oKTtcbiAqXG4gKiAvLyBDb25uZWN0IHdpdGggY3VzdG9tIG5hbWVzIGZvciBMb2NhbEF1ZGlvVHJhY2sgYW5kIExvY2FsVmlkZW9UcmFja1xuICogVmlkZW8uY29ubmVjdCh0b2tlbiwge1xuICogICBuYW1lOiAnbXktY29vbC1yb29tJ1xuICogICBhdWRpbzogeyBuYW1lOiAnbWljcm9waG9uZScgfSxcbiAqICAgdmlkZW86IHsgbmFtZTogJ2NhbWVyYScgfVxuICogfSkudGhlbihmdW5jdGlvbihyb29tKSB7XG4gKiAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudHMudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihwdWJsaWNhdGlvbikge1xuICogICAgIGNvbnNvbGUubG9nKCdUaGUgTG9jYWxUcmFjayBcIicgKyBwdWJsaWNhdGlvbi50cmFja05hbWUgKyAnXCIgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQnKTtcbiAqICAgfSk7XG4gKiB9KS5jYXRjaChlcnJvciA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdDb3VsZCBub3QgY29ubmVjdCB0byB0aGUgUm9vbTonLCBlcnJvci5tZXNzYWdlKTtcbiAqIH0pO1xuICogQGV4YW1wbGVcbiAqIC8vIEFjY2Vzc2luZyB0aGUgU0RLIGxvZ2dlclxuICogdmFyIHsgTG9nZ2VyLCBjb25uZWN0IH0gPSByZXF1aXJlKCd0d2lsaW8tdmlkZW8nKTtcbiAqIHZhciB0b2tlbiA9IGdldEFjY2Vzc1Rva2VuKCk7XG4gKlxuICogdmFyIGxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoJ3R3aWxpby12aWRlbycpO1xuICpcbiAqIC8vIExpc3RlbiBmb3IgbG9nc1xuICogdmFyIG9yaWdpbmFsRmFjdG9yeSA9IGxvZ2dlci5tZXRob2RGYWN0b3J5O1xuICogbG9nZ2VyLm1ldGhvZEZhY3RvcnkgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgbG9nTGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAqICAgdmFyIG1ldGhvZCA9IG9yaWdpbmFsRmFjdG9yeShtZXRob2ROYW1lLCBsb2dMZXZlbCwgbG9nZ2VyTmFtZSk7XG4gKlxuICogICByZXR1cm4gZnVuY3Rpb24gKGRhdGV0aW1lLCBsb2dMZXZlbCwgY29tcG9uZW50LCBtZXNzYWdlLCBkYXRhKSB7XG4gKiAgICAgbWV0aG9kKGRhdGV0aW1lLCBsb2dMZXZlbCwgY29tcG9uZW50LCBtZXNzYWdlLCBkYXRhKTtcbiAqICAgICAvLyBTZW5kIHRvIHlvdXIgb3duIHNlcnZlclxuICogICAgIHBvc3REYXRhVG9TZXJ2ZXIoYXJndW1lbnRzKTtcbiAqICAgfTtcbiAqIH07XG4gKiBsb2dnZXIuc2V0TGV2ZWwoJ2RlYnVnJyk7XG4gKlxuICogY29ubmVjdCh0b2tlbiwge1xuICogICBuYW1lOiAnbXktY29vbC1yb29tJ1xuICogfSkudGhlbihmdW5jdGlvbihyb29tKSB7XG4gKiAgIHJvb20ub24oJ3BhcnRpY2lwYW50Q29ubmVjdGVkJywgZnVuY3Rpb24ocGFydGljaXBhbnQpIHtcbiAqICAgICBjb25zb2xlLmxvZyhwYXJ0aWNpcGFudC5pZGVudGl0eSArICcgaGFzIGNvbm5lY3RlZCcpO1xuICogICB9KTtcbiAqIH0pLmNhdGNoKGVycm9yID0+IHtcbiAqICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBjb25uZWN0IHRvIHRoZSBSb29tOicsIGVycm9yLm1lc3NhZ2UpO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3QodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFpc05vbkFycmF5T2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBDYW5jZWxhYmxlUHJvbWlzZS5yZWplY3QoRS5JTlZBTElEX1RZUEUoJ29wdGlvbnMnLCAnb2JqZWN0JykpO1xuICAgIH1cbiAgICB2YXIgTG9nID0gb3B0aW9ucy5Mb2cgfHwgRGVmYXVsdExvZztcbiAgICB2YXIgbG9nZ2VyTmFtZSA9IG9wdGlvbnMubG9nZ2VyTmFtZSB8fCBERUZBVUxUX0xPR0dFUl9OQU1FO1xuICAgIHZhciBsb2dMZXZlbCA9IG9wdGlvbnMubG9nTGV2ZWwgfHwgREVGQVVMVF9MT0dfTEVWRUw7XG4gICAgdmFyIGxvZ0xldmVscyA9IGJ1aWxkTG9nTGV2ZWxzKGxvZ0xldmVsKTtcbiAgICB2YXIgbG9nQ29tcG9uZW50TmFtZSA9IFwiW2Nvbm5lY3QgI1wiICsgKytjb25uZWN0Q2FsbHMgKyBcIl1cIjtcbiAgICB2YXIgbG9nO1xuICAgIHRyeSB7XG4gICAgICAgIGxvZyA9IG5ldyBMb2coJ2RlZmF1bHQnLCBsb2dDb21wb25lbnROYW1lLCBsb2dMZXZlbHMsIGxvZ2dlck5hbWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIENhbmNlbGFibGVQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIC8vIE5PVEUoY3NhbnRvcyk6IExvZyBhIHdhcm5pbmcgZm9yIHRoZSBkZXByZWNhdGVkIENvbm5lY3RPcHRpb25zIHByb3BlcnRpZXMuXG4gICAgLy8gVGhlIHdhcm5pbmcgaXMgZGlzcGxheWVkIG9ubHkgZm9yIHRoZSBmaXJzdCBjYWxsIHRvIGNvbm5lY3QoKSBwZXIgYnJvd3NlciBzZXNzaW9uLlxuICAgIC8vIEFkZGl0aW9uYWxseSwgdGhlIG9wdGlvbnMgdGhhdCBhcmUgbm8gbG9uZ2VyIG5lZWRlZCB3aWxsIGJlIHJlbW92ZWQuXG4gICAgZGVwcmVjYXRlT3B0aW9ucyhvcHRpb25zLCBsb2csIGRlcHJlY2F0ZWRDb25uZWN0T3B0aW9uc1Byb3BzKTtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGF1dG9tYXRpY1N1YnNjcmlwdGlvbjogdHJ1ZSxcbiAgICAgICAgY3JlYXRlTG9jYWxUcmFja3M6IGNyZWF0ZUxvY2FsVHJhY2tzLFxuICAgICAgICBkb21pbmFudFNwZWFrZXI6IGZhbHNlLFxuICAgICAgICBlbmFibGVEc2NwOiBmYWxzZSxcbiAgICAgICAgZW52aXJvbm1lbnQ6IERFRkFVTFRfRU5WSVJPTk1FTlQsXG4gICAgICAgIGV2ZW50TGlzdGVuZXI6IG51bGwsXG4gICAgICAgIGluc2lnaHRzOiB0cnVlLFxuICAgICAgICBMb2NhbEF1ZGlvVHJhY2s6IExvY2FsQXVkaW9UcmFjayxcbiAgICAgICAgTG9jYWxEYXRhVHJhY2s6IExvY2FsRGF0YVRyYWNrLFxuICAgICAgICBMb2NhbFBhcnRpY2lwYW50OiBMb2NhbFBhcnRpY2lwYW50LFxuICAgICAgICBMb2NhbFZpZGVvVHJhY2s6IExvY2FsVmlkZW9UcmFjayxcbiAgICAgICAgTG9nOiBMb2csXG4gICAgICAgIE1lZGlhU3RyZWFtVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAgICAgIGxvZ2dlck5hbWU6IGxvZ2dlck5hbWUsXG4gICAgICAgIGxvZ0xldmVsOiBsb2dMZXZlbCxcbiAgICAgICAgbWF4QXVkaW9CaXRyYXRlOiBudWxsLFxuICAgICAgICBtYXhWaWRlb0JpdHJhdGU6IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgIG5ldHdvcmtNb25pdG9yOiB0cnVlLFxuICAgICAgICBuZXR3b3JrUXVhbGl0eTogZmFsc2UsXG4gICAgICAgIHByZWZlcnJlZEF1ZGlvQ29kZWNzOiBbXSxcbiAgICAgICAgcHJlZmVycmVkVmlkZW9Db2RlY3M6IFtdLFxuICAgICAgICByZWFsbTogREVGQVVMVF9SRUFMTSxcbiAgICAgICAgcmVnaW9uOiBERUZBVUxUX1JFR0lPTixcbiAgICAgICAgc2lnbmFsaW5nOiBTaWduYWxpbmdWMlxuICAgIH0sIGZpbHRlck9iamVjdChvcHRpb25zKSk7XG4gICAgLyogZXNsaW50IG5ldy1jYXA6MCAqL1xuICAgIHZhciB3c1NlcnZlciA9IFdTX1NFUlZFUihvcHRpb25zLmVudmlyb25tZW50LCBvcHRpb25zLnJlZ2lvbik7XG4gICAgdmFyIGV2ZW50T2JzZXJ2ZXIgPSBuZXcgRXZlbnRPYnNlcnZlcihEYXRlLm5vdygpLCBsb2csIG9wdGlvbnMuZXZlbnRMaXN0ZW5lcik7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBldmVudE9ic2VydmVyOiBldmVudE9ic2VydmVyLCB3c1NlcnZlcjogd3NTZXJ2ZXIgfSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy5sb2cgPSBsb2c7XG4gICAgLy8gTk9URShtcm9iZXJ0cyk6IFByaW50IHRoZSBTYWZhcmkgd2FybmluZyBvbmNlIGlmIHRoZSBsb2ctbGV2ZWwgaXMgYXQgbGVhc3RcbiAgICAvLyBcIndhcm5cIiwgaS5lLiBuZWl0aGVyIFwiZXJyb3JcIiBub3IgXCJvZmZcIi5cbiAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBQcmludCB0aGUgU2FmYXJpIHdhcm5pbmcgb25seSBmb3IgdmVyc2lvbnMgMTIuMCBhbmQgYmVsb3cuXG4gICAgaWYgKGlzU2FmYXJpV2l0aG91dFZQOFN1cHBvcnRcbiAgICAgICAgJiYgIWRpZFByaW50U2FmYXJpV2FybmluZ1xuICAgICAgICAmJiAobG9nLmxvZ0xldmVsICE9PSAnZXJyb3InICYmIGxvZy5sb2dMZXZlbCAhPT0gJ29mZicpKSB7XG4gICAgICAgIGRpZFByaW50U2FmYXJpV2FybmluZyA9IHRydWU7XG4gICAgICAgIGxvZy53YXJuKFtcbiAgICAgICAgICAgICdTdXBwb3J0IGZvciBTYWZhcmkgMTIuMCBhbmQgYmVsb3cgaXMgbGltaXRlZCBiZWNhdXNlIGl0IGRvZXMgbm90IHN1cHBvcnQgVlA4LicsXG4gICAgICAgICAgICAnVGhpcyBtZWFucyB5b3UgbWF5IGV4cGVyaWVuY2UgY29kZWMgaXNzdWVzIGluIEdyb3VwIFJvb21zLiBZb3UgbWF5IGFsc28nLFxuICAgICAgICAgICAgJ2V4cGVyaWVuY2UgY29kZWMgaXNzdWVzIGluIFBlZXItdG8tUGVlciAoUDJQKSBSb29tcyBjb250YWluaW5nIEFuZHJvaWQtIG9yJyxcbiAgICAgICAgICAgICdpT1MtYmFzZWQgUGFydGljaXBhbnRzIHdobyBkbyBub3Qgc3VwcG9ydCBILjI2NC4gSG93ZXZlciwgUDJQIFJvb21zJyxcbiAgICAgICAgICAgICd3aXRoIGJyb3dzZXItYmFzZWQgUGFydGljaXBhbnRzIHNob3VsZCB3b3JrLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcGxlYXNlJyxcbiAgICAgICAgICAgICdyZWZlciB0byB0aGlzIGd1aWRlOiBodHRwczovL3d3dy50d2lsaW8uY29tL2RvY3MvdmlkZW8vamF2YXNjcmlwdC12Mi1kZXZlbG9waW5nLXNhZmFyaS0xMSdcbiAgICAgICAgXS5qb2luKCcgJykpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gQ2FuY2VsYWJsZVByb21pc2UucmVqZWN0KEUuSU5WQUxJRF9UWVBFKCd0b2tlbicsICdzdHJpbmcnKSk7XG4gICAgfVxuICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFRoZSBSb29tIFwibmFtZVwiIGluIFwib3B0aW9uc1wiIHdhcyBiZWluZyB1c2VkXG4gICAgLy8gYXMgdGhlIExvY2FsVHJhY2sgbmFtZSBpbiBhc0xvY2FsVHJhY2soKS4gU28gd2UgcGFzcyBhIGNvcHkgb2ZcbiAgICAvLyBcIm9wdGlvbnNcIiB3aXRob3V0IHRoZSBcIm5hbWVcIi5cbiAgICB2YXIgbG9jYWxUcmFja09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBkZWxldGUgbG9jYWxUcmFja09wdGlvbnMubmFtZTtcbiAgICBpZiAoJ3RyYWNrcycgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy50cmFja3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2FuY2VsYWJsZVByb21pc2UucmVqZWN0KEUuSU5WQUxJRF9UWVBFKCdvcHRpb25zLnRyYWNrcycsICdBcnJheSBvZiBMb2NhbEF1ZGlvVHJhY2ssIExvY2FsVmlkZW9UcmFjayBvciBNZWRpYVN0cmVhbVRyYWNrJykpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvcHRpb25zLnRyYWNrcyA9IG9wdGlvbnMudHJhY2tzLm1hcChmdW5jdGlvbiAodHJhY2spIHsgcmV0dXJuIGFzTG9jYWxUcmFjayh0cmFjaywgbG9jYWxUcmFja09wdGlvbnMpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBDYW5jZWxhYmxlUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBlcnJvciA9IHZhbGlkYXRlQmFuZHdpZHRoUHJvZmlsZShvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGUpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gQ2FuY2VsYWJsZVByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgLy8gTm90ZShtcGF0d2FyZGhhbik6IFwiY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sXCIgYWxsb3dzIHRyYWNrcyB0byBiZSBzd2l0Y2hlZCBvZmZcbiAgICAvLyBhbmQgXCJjb250ZW50UHJlZmVyZW5jZXNNb2RlXCIgYWxsb3dzIHRyYWNrIGRpbWVuc2lvbnMgdG8gYmUgc3BlY2lmaWVkIGR5bmFtaWNhbGx5LlxuICAgIC8vIFRoZSBwcm9wZXJ0aWVzIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgdmFsdWVzIGludGVybmFsbHk6XG4gICAgLy8gMSkgXCJhdXRvXCIgPSBzZGsgd2lsbCBkZWNpZGUgYW5kIHNlbmQgdGhlIGhpbnRzLlxuICAgIC8vIDIpIFwibWFudWFsXCIgLSBhcHAgY2FuIHVzZSBhcGkgdG8gc2VuZCB0aGUgaGludHMuXG4gICAgLy8gMykgXCJkaXNhYmxlZFwiID0gZG8gbm90IGVuYWJsZSB0aGlzIGZlYXR1cmUuICh0aGlzIGlzIGludGVybmFsIG9ubHkgdmFsdWUpXG4gICAgLy8gJ2Rpc2FibGVkJyBpcyBuZWVkZWQgYmVjYXVzZSBjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgYW5kIGNvbnRlbnRQcmVmZXJlbmNlc01vZGUgYXJlIGluY29tcGF0aWJsZSB3aXRoXG4gICAgLy8gZGVwcmVjYXRlZCBwcm9wZXJ0aWVzIG1heFRyYWNrcyBhbmQgcmVuZGVyRGltZW5zaW9ucyByZXNwZWN0aXZlbHkuIG9uY2Ugd2UgbWFrZSBAYnJlYWtpbmdfdmVyc2lvbl9jaGFuZ2VcbiAgICAvLyB3ZSBjYW4gcmVtb3ZlICdkaXNhYmxlZCcgc3RhdGUgYWxvbmcgd2l0aCBtYXhUcmFja3MgYW5kIHJlbmRlckRpbWVuc2lvbnMuXG4gICAgb3B0aW9ucy5jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgPSAnZGlzYWJsZWQnOyAvLyBzaG91bGQgc2RrIHR1cm4gb2ZmIGlkbGUgdHJhY2tzIGF1dG9tYXRpY2FsbHk/XG4gICAgb3B0aW9ucy5jb250ZW50UHJlZmVyZW5jZXNNb2RlID0gJ2Rpc2FibGVkJzsgLy8gc2hvdWxkIHNkayAgdXNlIHZpZGVvIGVsZW1lbnQgZGltZW5zaW9ucyBmb3IgY29udGVudCBoaW50cz9cbiAgICBpZiAob3B0aW9ucy5iYW5kd2lkdGhQcm9maWxlKSB7XG4gICAgICAgIG9wdGlvbnMuY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sID0gJ2F1dG8nO1xuICAgICAgICBvcHRpb25zLmNvbnRlbnRQcmVmZXJlbmNlc01vZGUgPSAnYXV0byc7XG4gICAgICAgIGlmIChvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGUudmlkZW8pIHtcbiAgICAgICAgICAgIC8vIGxvZyBhbnkgd2FybmluZ3MgYWJvdXQgZGVwcmVjYXRlZCBid3Agb3B0aW9uc1xuICAgICAgICAgICAgZGVwcmVjYXRlT3B0aW9ucyhvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGUudmlkZW8sIGxvZywgZGVwcmVjYXRlZEJhbmR3aWR0aFByb2ZpbGVPcHRpb25zKTtcbiAgICAgICAgICAgIGlmICgnbWF4VHJhY2tzJyBpbiBvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGUudmlkZW8pIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGRlcHJlY2F0ZWQgbWF4VHJhY2tzIGlzIHNwZWNpZmllZC4gZGlzYWJsZSBjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2xcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCA9ICdkaXNhYmxlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGUudmlkZW8uY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sID09PSAnbWFudWFsJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sID0gJ21hbnVhbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCA9ICdhdXRvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgncmVuZGVyRGltZW5zaW9ucycgaW4gb3B0aW9ucy5iYW5kd2lkdGhQcm9maWxlLnZpZGVvKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb250ZW50UHJlZmVyZW5jZXNNb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlby5jb250ZW50UHJlZmVyZW5jZXNNb2RlID09PSAnbWFudWFsJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29udGVudFByZWZlcmVuY2VzTW9kZSA9ICdtYW51YWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb250ZW50UHJlZmVyZW5jZXNNb2RlID0gJ2F1dG8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBTaWduYWxpbmcgPSBvcHRpb25zLnNpZ25hbGluZztcbiAgICB2YXIgc2lnbmFsaW5nID0gbmV3IFNpZ25hbGluZyhvcHRpb25zLndzU2VydmVyLCBvcHRpb25zKTtcbiAgICBsb2cuaW5mbygnQ29ubmVjdGluZyB0byBhIFJvb20nKTtcbiAgICBsb2cuZGVidWcoJ09wdGlvbnM6Jywgb3B0aW9ucyk7XG4gICAgdmFyIGVuY29kaW5nUGFyYW1ldGVycyA9IG5ldyBFbmNvZGluZ1BhcmFtZXRlcnNJbXBsKHtcbiAgICAgICAgbWF4QXVkaW9CaXRyYXRlOiBvcHRpb25zLm1heEF1ZGlvQml0cmF0ZSxcbiAgICAgICAgbWF4VmlkZW9CaXRyYXRlOiBvcHRpb25zLm1heFZpZGVvQml0cmF0ZVxuICAgIH0pO1xuICAgIHZhciBwcmVmZXJyZWRDb2RlY3MgPSB7XG4gICAgICAgIGF1ZGlvOiBvcHRpb25zLnByZWZlcnJlZEF1ZGlvQ29kZWNzLm1hcChub3JtYWxpemVDb2RlY1NldHRpbmdzKSxcbiAgICAgICAgdmlkZW86IG9wdGlvbnMucHJlZmVycmVkVmlkZW9Db2RlY3MubWFwKG5vcm1hbGl6ZUNvZGVjU2V0dGluZ3MpXG4gICAgfTtcbiAgICB2YXIgbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uID0gbmV3IE5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbkltcGwoaXNOb25BcnJheU9iamVjdChvcHRpb25zLm5ldHdvcmtRdWFsaXR5KSA/IG9wdGlvbnMubmV0d29ya1F1YWxpdHkgOiB7fSk7XG4gICAgLy8gQ3JlYXRlIGEgQ2FuY2VsYWJsZVJvb21Qcm9taXNlPFJvb20+IHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlc2Ugc3RlcHM6XG4gICAgLy8gMSAtIEdldCB0aGUgTG9jYWxUcmFja3MuXG4gICAgLy8gMiAtIENyZWF0ZSB0aGUgTG9jYWxQYXJ0aWNpcGFudCB1c2luZyBvcHRpb25zLnRyYWNrcy5cbiAgICAvLyAzIC0gQ29ubmVjdCB0byBydGMtcm9vbS1zZXJ2aWNlIGFuZCBjcmVhdGUgdGhlIFJvb21TaWduYWxpbmcuXG4gICAgLy8gNCAtIENyZWF0ZSB0aGUgUm9vbSBhbmQgdGhlbiByZXNvbHZlIHRoZSBDYW5jZWxhYmxlUHJvbWlzZS5cbiAgICB2YXIgY2FuY2VsYWJsZVJvb21Qcm9taXNlID0gY3JlYXRlQ2FuY2VsYWJsZVJvb21Qcm9taXNlKGdldExvY2FsVHJhY2tzLmJpbmQobnVsbCwgb3B0aW9ucyksIGNyZWF0ZUxvY2FsUGFydGljaXBhbnQuYmluZChudWxsLCBzaWduYWxpbmcsIGxvZywgZW5jb2RpbmdQYXJhbWV0ZXJzLCBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24sIG9wdGlvbnMpLCBjcmVhdGVSb29tU2lnbmFsaW5nLmJpbmQobnVsbCwgdG9rZW4sIG9wdGlvbnMsIHNpZ25hbGluZywgZW5jb2RpbmdQYXJhbWV0ZXJzLCBwcmVmZXJyZWRDb2RlY3MpLCBjcmVhdGVSb29tLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICAgIGNhbmNlbGFibGVSb29tUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyb29tKSB7XG4gICAgICAgIGxvZy5pbmZvKCdDb25uZWN0ZWQgdG8gUm9vbTonLCByb29tLnRvU3RyaW5nKCkpO1xuICAgICAgICBsb2cuaW5mbygnUm9vbSBuYW1lOicsIHJvb20ubmFtZSk7XG4gICAgICAgIGxvZy5kZWJ1ZygnUm9vbTonLCByb29tKTtcbiAgICAgICAgcmV0dXJuIHJvb207XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmIChjYW5jZWxhYmxlUm9vbVByb21pc2UuX2lzQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgIGxvZy5pbmZvKCdBdHRlbXB0IHRvIGNvbm5lY3QgdG8gYSBSb29tIHdhcyBjYW5jZWxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nLmluZm8oJ0Vycm9yIHdoaWxlIGNvbm5lY3RpbmcgdG8gYSBSb29tOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjYW5jZWxhYmxlUm9vbVByb21pc2U7XG59XG4vKipcbiAqIFlvdSBtYXkgcGFzcyB0aGVzZSBvcHRpb25zIHRvIHtAbGluayBjb25uZWN0fSBpbiBvcmRlciB0byBvdmVycmlkZSB0aGVcbiAqIGRlZmF1bHQgYmVoYXZpb3IuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBDb25uZWN0T3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufENyZWF0ZUxvY2FsVHJhY2tPcHRpb25zfSBbYXVkaW89dHJ1ZV0gLSBXaGV0aGVyIG9yIG5vdCB0b1xuICogICBnZXQgbG9jYWwgYXVkaW8gd2l0aCA8Y29kZT5nZXRVc2VyTWVkaWE8L2NvZGU+IHdoZW4gPGNvZGU+dHJhY2tzPC9jb2RlPlxuICogICBhcmUgbm90IHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXV0b21hdGljU3Vic2NyaXB0aW9uPXRydWVdIC0gQnkgZGVmYXVsdCwgeW91IHdpbGwgc3Vic2NyaWJlXG4gKiAgIHRvIGFsbCBSZW1vdGVUcmFja3Mgc2hhcmVkIGJ5IG90aGVyIFBhcnRpY2lwYW50cyBpbiBhIFJvb20uIFlvdSBjYW4gbm93IG92ZXJyaWRlIHRoaXNcbiAqICAgYmVoYXZpb3IgYnkgc2V0dGluZyB0aGlzIGZsYWcgdG8gPGNvZGU+ZmFsc2U8L2NvZGU+LiBJdCB3aWxsIG1ha2Ugc3VyZSB0aGF0IHlvdSB3aWxsXG4gKiAgIG5vdCBzdWJzY3JpYmUgdG8gYW55IFJlbW90ZVRyYWNrIGluIGEgR3JvdXAgb3IgU21hbGwgR3JvdXAgUm9vbS4gU2V0dGluZyBpdCB0b1xuICogICA8Y29kZT50cnVlPC9jb2RlPiwgb3Igbm90IHNldHRpbmcgaXQgYXQgYWxsIHByZXNlcnZlcyB0aGUgZGVmYXVsdCBiZWhhdmlvci4gVGhpc1xuICogICBmbGFnIGRvZXMgbm90IGhhdmUgYW55IGVmZmVjdCBpbiBhIFBlZXItdG8tUGVlciBSb29tLlxuICogQHByb3BlcnR5IHtCYW5kd2lkdGhQcm9maWxlT3B0aW9uc30gW2JhbmR3aWR0aFByb2ZpbGVdIC0gWW91IGNhbiBvcHRpb25hbGx5IGNvbmZpZ3VyZVxuICogICBob3cgeW91ciBhdmFpbGFibGUgZG93bmxpbmsgYmFuZHdpZHRoIGlzIHNoYXJlZCBhbW9uZyB0aGUgUmVtb3RlVHJhY2tzIHlvdSBoYXZlIHN1YnNjcmliZWRcbiAqICAgdG8gaW4gYSBHcm91cCBSb29tLiBCeSBkZWZhdWx0LCBiYW5kd2lkdGggaXMgc2hhcmVkIGVxdWFsbHkgYW1vbmcgdGhlIFJlbW90ZVRyYWNrcy5cbiAqICAgVGhpcyBoYXMgbm8gZWZmZWN0IGluIFBlZXItdG8tUGVlciBSb29tcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RvbWluYW50U3BlYWtlcj1mYWxzZV0gLSBXaGV0aGVyIHRvIGVuYWJsZSB0aGUgRG9taW5hbnRcbiAqICAgU3BlYWtlciBBUEkgb3Igbm90LiBUaGlzIG9ubHkgdGFrZXMgZWZmZWN0IGluIEdyb3VwIFJvb21zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZHNjcFRhZ2dpbmc9ZmFsc2VdIC0gPGNvZGU+KGRlcHJlY2F0ZWQ6IHVzZSBcImVuYWJsZURzY3BcIiBpbnN0ZWFkKTwvY29kZT5cbiAqICAgRFNDUCB0YWdnaW5nIGFsbG93cyB5b3UgdG8gcmVxdWVzdCBlbmhhbmNlZCBRb1MgdHJlYXRtZW50IGZvciBSVFAgbWVkaWEgcGFja2V0cyBmcm9tIGFueVxuICogICBmaXJld2FsbCB0aGF0IHRoZSBjbGllbnQgbWF5IGJlIGJlaGluZC4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byA8Y29kZT50cnVlPC9jb2RlPiB3aWxsXG4gKiAgIHJlcXVlc3QgRFNDUCB0YWdnaW5nIGZvciBtZWRpYSBwYWNrZXRzIG9uIHN1cHBvcnRlZCBicm93c2VycyAob25seSBDaHJvbWUgc3VwcG9ydHMgdGhpc1xuICogICBhcyBvZiBub3cpLiBBdWRpbyBwYWNrZXRzIHdpbGwgYmUgc2VudCB3aXRoIERTQ1AgaGVhZGVyIHZhbHVlIHNldCB0byAweGI4IHdoaWNoIGNvcnJlc3BvbmRzXG4gKiAgIHRvIEV4cGVkaXRlZCBGb3J3YXJkaW5nIChFRikuIFZpZGVvIHBhY2tldHMgd2lsbCBiZSBzZW50IHdpdGggRFNDUCBoZWFkZXIgdmFsdWUgc2V0IHRvIDB4ODhcbiAqICAgd2hpY2ggY29ycmVzcG9uZHMgdG8gQXNzdXJlZCBGb3J3YXJkaW5nIChBRjQxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2VuYWJsZURzY3A9ZmFsc2VdIC0gRFNDUCB0YWdnaW5nIGFsbG93cyB5b3UgdG8gcmVxdWVzdCBlbmhhbmNlZFxuICogICBRb1MgdHJlYXRtZW50IGZvciBSVFAgbWVkaWEgcGFja2V0cyBmcm9tIGFueSBmaXJld2FsbCB0aGF0IHRoZSBjbGllbnQgbWF5IGJlIGJlaGluZC5cbiAqICAgU2V0dGluZyB0aGlzIG9wdGlvbiB0byA8Y29kZT50cnVlPC9jb2RlPiB3aWxsIHJlcXVlc3QgRFNDUCB0YWdnaW5nIGZvciBtZWRpYSBwYWNrZXRzXG4gKiAgIG9uIHN1cHBvcnRlZCBicm93c2VycyAob25seSBDaHJvbWUgc3VwcG9ydHMgdGhpcyBhcyBvZiBub3cpLiBBdWRpbyBwYWNrZXRzIHdpbGwgYmVcbiAqICAgc2VudCB3aXRoIERTQ1AgaGVhZGVyIHZhbHVlIHNldCB0byAweGI4IHdoaWNoIGNvcnJlc3BvbmRzIHRvIEV4cGVkaXRlZCBGb3J3YXJkaW5nIChFRikuXG4gKiAgIFZpZGVvIHBhY2tldHMgd2lsbCBiZSBzZW50IHdpdGggRFNDUCBoZWFkZXIgdmFsdWUgc2V0IHRvIDB4ODggd2hpY2ggY29ycmVzcG9uZHMgdG9cbiAqICAgQXNzdXJlZCBGb3J3YXJkaW5nIChBRjQxKS5cbiAqIEBwcm9wZXJ0eSB7RXZlbnRMaXN0ZW5lcn0gW2V2ZW50TGlzdGVuZXJdIC0gPGNvZGU+KGRlcHJlY2F0ZWQ6IHVzZSBbVmlkZW8uTG9nZ2VyXShtb2R1bGUtdHdpbGlvLXZpZGVvLmh0bWwpPC9jb2RlPlxuICogICB5b3UgY2FuIGxpc3RlbiB0byBmaW5lLWdyYWluZWQgZXZlbnRzIHJlbGF0ZWQgdG8gc2lnbmFsaW5nIGFuZCBtZWRpYSB0aGF0IGFyZVxuICogICBub3QgYXZhaWxhYmxlIGluIHRoZSBwdWJsaWMgQVBJcy4gVGhlc2UgZXZlbnRzIG1pZ2h0IGJlIHVzZWZ1bCBmb3IgeW91ciBvd24gcmVwb3J0aW5nXG4gKiAgIGFuZCBkaWFnbm9zdGljcy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8UlRDSWNlU2VydmVyPn0gaWNlU2VydmVycyAtIE92ZXJyaWRlIHRoZSBTVFVOIGFuZCBUVVJOXG4gKiAgIHNlcnZlcnMgdXNlZCB3aGVuIGNvbm5lY3RpbmcgdG8ge0BsaW5rIFJvb219c1xuICogQHByb3BlcnR5IHtSVENJY2VUcmFuc3BvcnRQb2xpY3l9IFtpY2VUcmFuc3BvcnRQb2xpY3k9XCJhbGxcIl0gLSBPdmVycmlkZSB0aGVcbiAqICAgSUNFIHRyYW5zcG9ydCBwb2xpY3kgdG8gYmUgb25lIG9mIFwicmVsYXlcIiBvciBcImFsbFwiXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnNpZ2h0cz10cnVlXSAtIFdoZXRoZXIgcHVibGlzaGluZyBldmVudHNcbiAqICAgdG8gdGhlIEluc2lnaHRzIGdhdGV3YXkgaXMgZW5hYmxlZCBvciBub3RcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gW21heEF1ZGlvQml0cmF0ZT1udWxsXSAtIE1heCBvdXRnb2luZyBhdWRpbyBiaXRyYXRlIChicHMpO1xuICogICBBIDxjb2RlPm51bGw8L2NvZGU+IG9yIGEgPGNvZGU+MDwvY29kZT4gdmFsdWUgZG9lcyBub3Qgc2V0IGFueSBiaXRyYXRlIGxpbWl0O1xuICogICBUaGlzIHZhbHVlIGlzIHNldCBhcyBhIGhpbnQgZm9yIHZhcmlhYmxlIGJpdHJhdGUgY29kZWNzLCBidXQgd2lsbCBub3QgdGFrZVxuICogICBlZmZlY3QgZm9yIGZpeGVkIGJpdHJhdGUgY29kZWNzOyBCYXNlZCBvbiBvdXIgdGVzdHMsIENocm9tZSwgRmlyZWZveCBhbmQgU2FmYXJpXG4gKiAgIHN1cHBvcnQgYSBiaXRyYXRlIHJhbmdlIG9mIDEyMDAwIGJwcyB0byAyNTYwMDAgYnBzIGZvciBPcHVzIGNvZGVjOyBUaGlzIHBhcmFtZXRlclxuICogICBoYXMgbm8gZWZmZWN0IG9uIGlTQUMsIFBDTVUgYW5kIFBDTUEgY29kZWNzXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IFttYXhWaWRlb0JpdHJhdGU9bnVsbF0gLSBNYXggb3V0Z29pbmcgdmlkZW8gYml0cmF0ZSAoYnBzKTtcbiAqICAgQSA8Y29kZT5udWxsPC9jb2RlPiBvciA8Y29kZT4wPC9jb2RlPiB2YWx1ZSBkb2VzIG5vdCBzZXQgYW55IGJpdHJhdGUgbGltaXQ7XG4gKiAgIFRoaXMgdmFsdWUgaXMgc2V0IGFzIGEgaGludCBmb3IgdmFyaWFibGUgYml0cmF0ZSBjb2RlY3MsIGJ1dCB3aWxsIG5vdCB0YWtlXG4gKiAgIGVmZmVjdCBmb3IgZml4ZWQgYml0cmF0ZSBjb2RlY3M7IEJhc2VkIG9uIG91ciB0ZXN0cywgQ2hyb21lLCBGaXJlZm94IGFuZCBTYWZhcmlcbiAqICAgYWxsIHNlZW0gdG8gc3VwcG9ydCBhbiBhdmVyYWdlIGJpdHJhdGUgcmFuZ2Ugb2YgMjAwMDAgYnBzICgyMCBrYnBzKSB0b1xuICogICA4MDAwMDAwIGJwcyAoOCBtYnBzKSBmb3IgYSA3MjBwIFZpZGVvVHJhY2tcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gW25hbWU9bnVsbF0gLSBTZXQgdG8gY29ubmVjdCB0byBhIHtAbGluayBSb29tfSBieSBuYW1lXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58TmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9ufSBbbmV0d29ya1F1YWxpdHk9ZmFsc2VdIC0gV2hldGhlciB0byBlbmFibGUgdGhlIE5ldHdvcmtcbiAqICAgUXVhbGl0eSBBUEkgb3Igbm90LiBUaGlzIG9ubHkgdGFrZXMgZWZmZWN0IGluIEdyb3VwIFJvb21zLiBQYXNzIGEge0BsaW5rIE5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbn1cbiAqICAgdG8gY29uZmlndXJlIHZlcmJvc2l0eSBsZXZlbHMgZm9yIG5ldHdvcmsgcXVhbGl0eSBpbmZvcm1hdGlvbiBmb3Ige0BsaW5rIExvY2FsUGFydGljaXBhbnR9XG4gKiAgIGFuZCB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9cy4gQSA8Y29kZT50cnVlPC9jb2RlPiB2YWx1ZSB3aWxsIHNldCB0aGUge0BsaW5rIE5ldHdvcmtRdWFsaXR5VmVyYm9zaXR5fVxuICogICBmb3IgdGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSB0byB7QGxpbmsgTmV0d29ya1F1YWxpdHlWZXJib3NpdHl9PGNvZGUgc3R5bGU9XCJwYWRkaW5nOjAgMFwiPiNtaW5pbWFsPC9jb2RlPlxuICogICBhbmQgdGhlIHtAbGluayBOZXR3b3JrUXVhbGl0eVZlcmJvc2l0eX0gZm9yIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH1zIHRvXG4gKiAgIHtAbGluayBOZXR3b3JrUXVhbGl0eVZlcmJvc2l0eX08Y29kZSBzdHlsZT1cInBhZGRpbmc6MCAwXCI+I25vbmU8L2NvZGU+LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtyZWdpb249J2dsbCddIC0gUHJlZmVycmVkIHNpZ25hbGluZyByZWdpb247IEJ5IGRlZmF1bHQsIHlvdSB3aWxsIGJlIGNvbm5lY3RlZCB0byB0aGVcbiAqICAgbmVhcmVzdCBzaWduYWxpbmcgc2VydmVyIGRldGVybWluZWQgYnkgbGF0ZW5jeSBiYXNlZCByb3V0aW5nLiBTZXR0aW5nIGEgdmFsdWUgb3RoZXJcbiAqICAgdGhhbiA8Y29kZSBzdHlsZT1cInBhZGRpbmc6MCAwXCI+Z2xsPC9jb2RlPiBieXBhc3NlcyByb3V0aW5nIGFuZCBndWFyYW50ZWVzIHRoYXQgc2lnbmFsaW5nIHRyYWZmaWMgd2lsbCBiZVxuICogICB0ZXJtaW5hdGVkIGluIHRoZSByZWdpb24gdGhhdCB5b3UgcHJlZmVyLiBQbGVhc2UgcmVmZXIgdG8gdGhpcyA8YSBocmVmPVwiaHR0cHM6Ly93d3cudHdpbGlvLmNvbS9kb2NzL3ZpZGVvL2lwLWFkZHJlc3Mtd2hpdGVsaXN0aW5nI3NpZ25hbGluZy1jb21tdW5pY2F0aW9uXCIgdGFyZ2V0PVwiX2JsYW5rXCI+dGFibGU8L2E+XG4gKiAgIGZvciB0aGUgbGlzdCBvZiBzdXBwb3J0ZWQgc2lnbmFsaW5nIHJlZ2lvbnMuXG4gKiBAcHJvcGVydHkge0FycmF5PEF1ZGlvQ29kZWN8QXVkaW9Db2RlY1NldHRpbmdzPn0gW3ByZWZlcnJlZEF1ZGlvQ29kZWNzPVtdXSAtIFByZWZlcnJlZCBhdWRpbyBjb2RlY3M7XG4gKiAgQW4gZW1wdHkgYXJyYXkgcHJlc2VydmVzIHRoZSBjdXJyZW50IGF1ZGlvIGNvZGVjIHByZWZlcmVuY2Ugb3JkZXIuXG4gKiBAcHJvcGVydHkge0FycmF5PFZpZGVvQ29kZWN8VmlkZW9Db2RlY1NldHRpbmdzPn0gW3ByZWZlcnJlZFZpZGVvQ29kZWNzPVtdXSAtXG4gKiAgUHJlZmVycmVkIHZpZGVvIGNvZGVjczsgQW4gZW1wdHkgYXJyYXkgcHJlc2VydmVzIHRoZSBjdXJyZW50IHZpZGVvIGNvZGVjXG4gKiAgcHJlZmVyZW5jZSBvcmRlci4gSWYgeW91IHdhbnQgdG8gc2V0IGEgcHJlZmVycmVkIHZpZGVvIGNvZGVjIG9uIGEgR3JvdXAgUm9vbSxcbiAqICB5b3Ugd2lsbCBuZWVkIHRvIGNyZWF0ZSB0aGUgUm9vbSB1c2luZyB0aGUgUkVTVCBBUEkgYW5kIHNldCB0aGVcbiAqICA8Y29kZT5WaWRlb0NvZGVjczwvY29kZT4gcHJvcGVydHkuXG4gKiAgU2VlIDxhIGhyZWY9XCJodHRwczovL3d3dy50d2lsaW8uY29tL2RvY3MvYXBpL3ZpZGVvL3Jvb21zLXJlc291cmNlI2NyZWF0ZS1yb29tXCI+XG4gKiAgaGVyZTwvYT4gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiBAcHJvcGVydHkge0xvZ0xldmVsfExvZ0xldmVsc30gW2xvZ0xldmVsPSd3YXJuJ10gLSA8Y29kZT4oZGVwcmVjYXRlZDogdXNlIFtWaWRlby5Mb2dnZXJdKG1vZHVsZS10d2lsaW8tdmlkZW8uaHRtbCkgaW5zdGVhZC5cbiAqICAgU2VlIFtleGFtcGxlc10obW9kdWxlLXR3aWxpby12aWRlby5odG1sIy5jb25uZWN0KSBmb3IgZGV0YWlscyk8L2NvZGU+XG4gKiAgIFNldCB0aGUgZGVmYXVsdCBsb2cgdmVyYm9zaXR5XG4gKiAgIG9mIGxvZ2dpbmcuIFBhc3NpbmcgYSB7QGxpbmsgTG9nTGV2ZWx9IHN0cmluZyB3aWxsIHVzZSB0aGUgc2FtZVxuICogICBsZXZlbCBmb3IgYWxsIGNvbXBvbmVudHMuIFBhc3MgYSB7QGxpbmsgTG9nTGV2ZWxzfSB0byBzZXQgc3BlY2lmaWMgbG9nXG4gKiAgIGxldmVscy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbG9nZ2VyTmFtZT0ndHdpbGlvLXZpZGVvJ10gLSBUaGUgbmFtZSBvZiB0aGUgbG9nZ2VyLiBVc2UgdGhpcyBuYW1lIHdoZW4gYWNjZXNzaW5nIHRoZSBsb2dnZXIgdXNlZCBieSB0aGUgU0RLLlxuICogICBTZWUgW2V4YW1wbGVzXShtb2R1bGUtdHdpbGlvLXZpZGVvLmh0bWwjLmNvbm5lY3QpIGZvciBkZXRhaWxzLlxuICogQHByb3BlcnR5IHtBcnJheTxMb2NhbFRyYWNrfE1lZGlhU3RyZWFtVHJhY2s+fSBbdHJhY2tzXSAtIFRoZVxuICogICB7QGxpbmsgTG9jYWxUcmFja31zIG9yIE1lZGlhU3RyZWFtVHJhY2tzIHdpdGggd2hpY2ggdG8gam9pbiB0aGVcbiAqICAge0BsaW5rIFJvb219LiBUaGVzZSB0cmFja3MgY2FuIGJlIG9idGFpbmVkIGVpdGhlciBieSBjYWxsaW5nXG4gKiAgIHtAbGluayBjcmVhdGVMb2NhbFRyYWNrc30sIG9yIGJ5IGNvbnN0cnVjdGluZyB0aGVtIGZyb20gdGhlIE1lZGlhU3RyZWFtXG4gKiAgIG9idGFpbmVkIGJ5IGNhbGxpbmcgPGNvZGU+Z2V0VXNlck1lZGlhKCk8L2NvZGU+LlxuICogQHByb3BlcnR5IHtib29sZWFufENyZWF0ZUxvY2FsVHJhY2tPcHRpb25zfSBbdmlkZW89dHJ1ZV0gLSBXaGV0aGVyIG9yIG5vdCB0b1xuICogICBnZXQgbG9jYWwgdmlkZW8gd2l0aCA8Y29kZT5nZXRVc2VyTWVkaWE8L2NvZGU+IHdoZW4gPGNvZGU+dHJhY2tzPC9jb2RlPlxuICogICBhcmUgbm90IHByb3ZpZGVkLlxuICovXG4vKipcbiAqIHtAbGluayBCYW5kd2lkdGhQcm9maWxlT3B0aW9uc30gYWxsb3dzIHlvdSB0byBjb25maWd1cmUgaG93IHlvdXIgYXZhaWxhYmxlIGRvd25saW5rXG4gKiBiYW5kd2lkdGggaXMgc2hhcmVkIGFtb25nIHRoZSBSZW1vdGVUcmFja3MgeW91IGhhdmUgc3Vic2NyaWJlZCB0byBpbiBhIEdyb3VwIFJvb20uXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBCYW5kd2lkdGhQcm9maWxlT3B0aW9uc1xuICogQHByb3BlcnR5IHtWaWRlb0JhbmR3aWR0aFByb2ZpbGVPcHRpb25zfSBbdmlkZW9dIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIGNvbmZpZ3VyZVxuICogICBob3cgeW91ciBhdmFpbGFibGUgZG93bmxpbmsgYmFuZHdpZHRoIGlzIHNoYXJlZCBhbW9uZyB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cyB5b3VcbiAqICAgaGF2ZSBzdWJzY3JpYmVkIHRvIGluIGEgR3JvdXAgUm9vbS5cbiAqL1xuLyoqXG4gKiB7QGxpbmsgVmlkZW9CYW5kd2lkdGhQcm9maWxlT3B0aW9uc30gYWxsb3dzIHlvdSB0byBjb25maWd1cmUgaG93IHlvdXIgYXZhaWxhYmxlIGRvd25saW5rXG4gKiBiYW5kd2lkdGggaXMgc2hhcmVkIGFtb25nIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zIHlvdSBoYXZlIHN1YnNjcmliZWQgdG8gaW4gYSBHcm91cCBSb29tLlxuICogQHR5cGVkZWYge29iamVjdH0gVmlkZW9CYW5kd2lkdGhQcm9maWxlT3B0aW9uc1xuICogQHByb3BlcnR5IHtUcmFjay5Qcmlvcml0eX0gW2RvbWluYW50U3BlYWtlclByaW9yaXR5PVwic3RhbmRhcmRcIl0gLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG9cbiAqICAgc3BlY2lmeSB0aGUgbWluaW11bSBzdWJzY3JpYmUge0BsaW5rIFRyYWNrLlByaW9yaXR5fSBvZiB0aGUgRG9taW5hbnQgU3BlYWtlcidzIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMuXG4gKiAgIFRoaXMgbWVhbnMgdGhhdCB0aGUgRG9taW5hbnQgU3BlYWtlcidzIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMgdGhhdCBhcmUgcHVibGlzaGVkIHdpdGhcbiAqICAgbG93ZXIge0BsaW5rIFRyYWNrLlByaW9yaXR5fSB3aWxsIGJlIHN1YnNjcmliZWQgdG8gd2l0aCB0aGUge0BsaW5rIFRyYWNrLlByaW9yaXR5fSBzcGVjaWZpZWQgaGVyZS5cbiAqICAgVGhpcyBoYXMgbm8gZWZmZWN0IG9uIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMgcHVibGlzaGVkIHdpdGggaGlnaGVyIHtAbGluayBUcmFjay5Qcmlvcml0eX0sIHdoaWNoIHdpbGxcbiAqICAgc3RpbGwgYmUgc3Vic2NyaWJlZCB0byB3aXRoIHdpdGggdGhlIHNhbWUge0BsaW5rIFRyYWNrLlByaW9yaXR5fS4gSWYgbm90IHNwZWNpZmllZCwgdGhpcyBkZWZhdWx0cyB0byBcInN0YW5kYXJkXCIuXG4gKiAgIFRoaXMgcGFyYW1ldGVyIG9ubHkgYXBwbGllcyB0byBhIEdyb3VwIFJvb20gUGFydGljaXBhbnQgd2hlbiB7QGxpbmsgQ29ubmVjdE9wdGlvbnN9LmRvbWluYW50U3BlYWtlciBpcyBzZXQgdG8gdHJ1ZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4U3Vic2NyaXB0aW9uQml0cmF0ZV0gLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgbWF4aW11bVxuICogICBkb3dubGluayB2aWRlbyBiYW5kd2lkdGggaW4gYml0cyBwZXIgc2Vjb25kIChicHMpLiBCeSBkZWZhdWx0LCB0aGVyZSBhcmUgbm8gbGltaXRzIG9uXG4gKiAgIHRoZSBkb3dubGluayB2aWRlbyBiYW5kd2lkdGguXG4gKiBAcHJvcGVydHkge0NsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbH0gW2NsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbD1cImF1dG9cIl0gLSBPcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBkZXRlcm1pbmVzXG4gKiAgICB3aGVuIHRvIHR1cm4gdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSBvbiBvciBvZmYuIFdoZW4gc2V0IHRvIFwiYXV0b1wiLCBTREsgd2lsbCB1c2UgdGhlIHZpc2liaWxpdHkgb2YgdGhlXG4gKiAgICBhdHRhY2hlZCBlbGVtZW50cyB0byBkZXRlcm1pbmUgaWYgdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSBzaG91bGQgYmUgdHVybmVkIG9mZiBvciBvbi4gV2hlbiB0aGUgYXR0YWNoZWQgdmlkZW8gZWxlbWVudHMgYmVjb21lIGludmlzaWJsZSB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHdpbGxcbiAqICAgIGJlIHR1cm5lZCBvZmYsIGFuZCB3aGVuIGVsZW1lbnRzIGJlY29tZSB2aXNpYmxlIHRoZXkgd2lsbCBiZSB0dXJuZWQgb24uIFdoZW4gc2V0IHRvIFwibWFudWFsXCIgeW91IGNhbiB0dXJuIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31cbiAqICAgIG9uIGFuZCBvZmYgdXNpbmcgdGhlIGFwaSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFjayNzd2l0Y2hPbn0gYW5kIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrI3N3aXRjaE9mZn0gcmVzcGVjdGl2ZWx5LlxuICogQHByb3BlcnR5IHtWaWRlb0NvbnRlbnRQcmVmZXJlbmNlc01vZGV9IFtjb250ZW50UHJlZmVyZW5jZXNNb2RlPVwiYXV0b1wiXSAtIFRoaXMgT3B0aW9uYWwgcGFyYW1ldGVyIGNvbmZpZ3VyZXNcbiAqICAgIHRoZSBtb2RlIGZvciBzcGVjaWZ5aW5nIGNvbnRlbnQgcHJlZmVyZW5jZXMgZm9yIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30uIFdoZW4gc2V0IHRvIFwiYXV0b1wiIHRoZVxuICogICAgU0RLIGRldGVybWluZXMgdGhlIHJlbmRlciBkaW1lbnNpb25zIGJ5IGluc3BlY3RpbmcgdGhlIGF0dGFjaGVkIHZpZGVvIGVsZW1lbnRzLiB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zIHJlbmRlcmVkIGluIHNtYWxsZXIgdmlkZW8gZWxlbWVudHNcbiAqICAgIHdpbGwgcmVjZWl2ZSBhIGxvd2VyIHJlc29sdXRpb24gc3RyZWFtIGNvbXBhcmVkIHRvIHRoZSB2aWRlbyByZW5kZXJlZCBpbiBsYXJnZXIgdmlkZW8gZWxlbWVudHMuIFdoZW4gc2V0IHRvIFwibWFudWFsXCIgeW91IGNhbiBzZXRcbiAqICAgIHRoZSBkaW1lbnNpb25zIHByb2dyYW1tYXRpY2FsbHkgYnkgY2FsbGluZyB7QGxpbmsgUmVtb3RlVmlkZW9UcmFjayNzZXRDb250ZW50UHJlZmVyZW5jZXN9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhUcmFja3NdIC0gPGNvZGU+KGRlcHJlY2F0ZWQ6IHVzZSBcImNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbFwiIGluc3RlYWQpPC9jb2RlPi4gT3B0aW9uYWxcbiAqICAgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIG1heGltdW0gbnVtYmVyIG9mIHZpc2libGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cywgd2hpY2ggd2lsbCBiZSBzZWxlY3RlZCBiYXNlZCBvblxuICogICB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IGFuZCBhbiBOLUxvdWRlc3QgcG9saWN5LiBCeSBkZWZhdWx0IHRoZXJlIGFyZSBubyBsaW1pdHMgb24gdGhlIG51bWJlciBvZiB2aXNpYmxlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMuXG4gKiAgIDAgb3IgYSBuZWdhdGl2ZSB2YWx1ZSB3aWxsIHJlbW92ZSBhbnkgbGltaXQgb24gdGhlIG1heGltdW0gbnVtYmVyIG9mIHZpc2libGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cy5cbiAqIEBwcm9wZXJ0eSB7QmFuZHdpZHRoUHJvZmlsZU1vZGV9IFttb2RlPVwiZ3JpZFwiXSAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IGhvdyB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cydcbiAqICAgVHJhY2tQcmlvcml0eSB2YWx1ZXMgYXJlIG1hcHBlZCB0byBiYW5kd2lkdGggYWxsb2NhdGlvbiBpbiBHcm91cCBSb29tcy4gVGhpcyBkZWZhdWx0cyB0byBcImdyaWRcIixcbiAqICAgd2hpY2ggcmVzdWx0cyBpbiBlcXVhbCBiYW5kd2lkdGggc2hhcmUgYWxsb2NhdGlvbiB0byBhbGwge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cy5cbiAqIEBwcm9wZXJ0eSB7VmlkZW9SZW5kZXJEaW1lbnNpb25zfSBbcmVuZGVyRGltZW5zaW9uc10gLSA8Y29kZT4oZGVwcmVjYXRlZDogdXNlIFwiY29udGVudFByZWZlcmVuY2VzTW9kZVwiIGluc3RlYWQpPC9jb2RlPi4gT3B0aW9uYWxcbiAqIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBkZXNpcmVkIHJlbmRlciBkaW1lbnNpb25zIG9mIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMuXG4gKiBAcHJvcGVydHkge1RyYWNrU3dpdGNoT2ZmTW9kZX0gW3RyYWNrU3dpdGNoT2ZmTW9kZT1cInByZWRpY3RlZFwiXSAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBjb25maWd1cmVcbiAqICAgaG93IHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMgYXJlIHN3aXRjaGVkIG9mZiBpbiByZXNwb25zZSB0byBiYW5kd2lkdGggcHJlc3N1cmUuIERlZmF1bHRzIHRvIFwicHJlZGljdGVkXCIuXG4gKi9cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqIHtAbGluayBWaWRlb1JlbmRlckRpbWVuc2lvbnN9IGFsbG93cyB5b3UgdG8gc3BlY2lmeSB0aGUgZGVzaXJlZCByZW5kZXIgZGltZW5zaW9ucyBvZiB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zLlxuICogWW91IGNhbiBzcGVjaWZ5ICdhdXRvJyBmb3IgdGhpcyBmaWVsZCAtIHdoaWNoIGlzIGFsc28gZGVmYXVsdCB2YWx1ZSAtICBiYXNlZCBvbiB7QGxpbmsgVHJhY2suUHJpb3JpdHl9LiBUaGUgYmFuZHdpZHRoIGFsbG9jYXRpb24gYWxnb3JpdGhtIHdpbGwgZGlzdHJpYnV0ZSB0aGUgYXZhaWxhYmxlIGRvd25saW5rIGJhbmR3aWR0aFxuICogcHJvcG9ydGlvbmFsIHRvIHRoZSByZXF1ZXN0ZWQgcmVuZGVyIGRpbWVuc2lvbnMuIFRoaXMgaXMganVzdCBhbiBpbnB1dCBmb3IgY2FsY3VsYXRpbmcgdGhlIGJhbmR3aWR0aCB0byBiZSBhbGxvY2F0ZWRcbiAqIGFuZCBkb2VzIG5vdCBhZmZlY3QgdGhlIGFjdHVhbCByZXNvbHV0aW9uIG9mIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zLlxuICogQHR5cGVkZWYge29iamVjdH0gVmlkZW9SZW5kZXJEaW1lbnNpb25zXG4gKiBAcHJvcGVydHkge1ZpZGVvVHJhY2suRGltZW5zaW9uc30gW2hpZ2hdIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIGRlc2lyZWQgcmVuZGVyaW5nIGRpbWVuc2lvbnMgb2ZcbiAqICAge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHdob3NlIHtAbGluayBUcmFjay5Qcmlvcml0eX0gaXMgXCJoaWdoXCIuIDAgb3IgYSBuZWdhdGl2ZSB2YWx1ZSB3aWxsIHJlc3VsdCBpbiB0aGUgbG93ZXN0XG4gKiAgIHBvc3NpYmxlIHJlc29sdXRpb24uIFRoaXMgZGVmYXVsdHMgdG8gMTI4MCB4IDcyMCAoSEQpLlxuICogQHByb3BlcnR5IHtWaWRlb1RyYWNrLkRpbWVuc2lvbnN9IFtsb3ddIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIGRlc2lyZWQgcmVuZGVyaW5nIGRpbWVuc2lvbnMgb2ZcbiAqICAge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHdob3NlIHtAbGluayBUcmFjay5Qcmlvcml0eX0gaXMgXCJsb3dcIi4gMCBvciBhIG5lZ2F0aXZlIHZhbHVlIHdpbGwgcmVzdWx0IGluIHRoZSBsb3dlc3RcbiAqICAgcG9zc2libGUgcmVzb2x1dGlvbi4gVGhpcyBkZWZhdWx0cyB0byAxNzYgeCAxNDQgKFFDSUYpLlxuICogQHByb3BlcnR5IHtWaWRlb1RyYWNrLkRpbWVuc2lvbnN9IFtzdGFuZGFyZF0gLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB0aGUgZGVzaXJlZCByZW5kZXJpbmcgZGltZW5zaW9ucyBvZlxuICogICB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gd2hvc2Uge0BsaW5rIFRyYWNrLlByaW9yaXR5fSBpcyBcInN0YW5kYXJkXCIuIDAgb3IgYSBuZWdhdGl2ZSB2YWx1ZSB3aWxsIHJlc3VsdCBpbiB0aGUgbG93ZXN0XG4gKiAgIHBvc3NpYmxlIHJlc29sdXRpb24uIFRoaXMgZGVmYXVsdHMgdG8gNjQwIHggNDgwIChWR0EpLlxuICovXG4vKipcbiAqIENvbmZpZ3VyZSB2ZXJib3NpdHkgbGV2ZWxzIGZvciBuZXR3b3JrIHF1YWxpdHkgaW5mb3JtYXRpb24gZm9yXG4gKiB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gYW5kIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH1zLlxuICogQHR5cGVkZWYge29iamVjdH0gTmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uXG4gKiBAcHJvcGVydHkge05ldHdvcmtRdWFsaXR5VmVyYm9zaXR5fSBbbG9jYWw9MV0gLSBWZXJib3NpdHkgbGV2ZWwgZm9yIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fVxuICogQHByb3BlcnR5IHtOZXR3b3JrUXVhbGl0eVZlcmJvc2l0eX0gW3JlbW90ZT0wXSAtIFZlcmJvc2l0eSBsZXZlbCBmb3Ige0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fXNcbiAqL1xuLyoqXG4gKiBZb3UgbWF5IHBhc3MgdGhlc2UgbGV2ZWxzIHRvIHtAbGluayBDb25uZWN0T3B0aW9uc30gdG8gb3ZlcnJpZGVcbiAqIGxvZyBsZXZlbHMgZm9yIGluZGl2aWR1YWwgY29tcG9uZW50cy5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IExvZ0xldmVsc1xuICogQHByb3BlcnR5IHtMb2dMZXZlbH0gW2RlZmF1bHQ9J3dhcm4nXSAtIExvZyBsZXZlbCBmb3IgJ2RlZmF1bHQnIG1vZHVsZXMuXG4gKiBAcHJvcGVydHkge0xvZ0xldmVsfSBbbWVkaWE9J3dhcm4nXSAtIExvZyBsZXZlbCBmb3IgJ21lZGlhJyBtb2R1bGVzLlxuICogQHByb3BlcnR5IHtMb2dMZXZlbH0gW3NpZ25hbGluZz0nd2FybiddIC0gTG9nIGxldmVsIGZvciAnc2lnbmFsaW5nJyBtb2R1bGVzLlxuICogQHByb3BlcnR5IHtMb2dMZXZlbH0gW3dlYnJ0Yz0nd2FybiddIC0gTG9nIGxldmVsIGZvciAnd2VicnRjJyBtb2R1bGVzLlxuICovXG4vKipcbiAqIEF1ZGlvIGNvZGVjIHNldHRpbmdzLlxuICogQHR5cGVkZWYge29iamVjdH0gQXVkaW9Db2RlY1NldHRpbmdzXG4gKiBAcHJvcGVydHkge0F1ZGlvQ29kZWN9IGNvZGVjIC0gQXVkaW8gY29kZWMgbmFtZVxuICovXG4vKipcbiAqIE9wdXMgY29kZWMgc2V0dGluZ3MuXG4gKiBAdHlwZWRlZiB7QXVkaW9Db2RlY1NldHRpbmdzfSBPcHVzQ29kZWNTZXR0aW5nc1xuICogQHByb3BlcnR5IHtBdWRpb0NvZGVjfSBuYW1lIC0gXCJvcHVzXCJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2R0eD10cnVlXSAtIEVuYWJsZS9kaXNhYmxlIGRpc2NvbnRpbnVvdXMgdHJhbnNtaXNzaW9uIChEVFgpO1xuICogICBJZiBlbmFibGVkIGFsbCBwdWJsaXNoZWQge0BsaW5rIExvY2FsQXVkaW9UcmFja31zIHdpbGwgcmVkdWNlIHRoZSBvdXRnb2luZyBiaXRyYXRlXG4gKiAgIHRvIG5lYXItemVybyB3aGVuZXZlciBzcGVlY2ggaXMgbm90IGRldGVjdGVkLCByZXN1bHRpbmcgaW4gYmFuZHdpZHRoIGFuZCBDUFUgc2F2aW5ncztcbiAqICAgSXQgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAqL1xuLyoqXG4gKiBWaWRlbyBjb2RlYyBzZXR0aW5ncy5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IFZpZGVvQ29kZWNTZXR0aW5nc1xuICogQHByb3BlcnR5IHtWaWRlb0NvZGVjfSBjb2RlYyAtIFZpZGVvIGNvZGVjIG5hbWVcbiAqL1xuLyoqXG4gKiBWUDggY29kZWMgc2V0dGluZ3MuXG4gKiBAdHlwZWRlZiB7VmlkZW9Db2RlY1NldHRpbmdzfSBWUDhDb2RlY1NldHRpbmdzXG4gKiBAcHJvcGVydHkge1ZpZGVvQ29kZWN9IG5hbWUgLSBcIlZQOFwiXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaW11bGNhc3Q9ZmFsc2VdIC0gRW5hYmxlL2Rpc2FibGUgVlA4IHNpbXVsY2FzdDsgSWZcbiAqICAgZW5hYmxlZCwgVHdpbGlvJ3MgVmlkZW8gU0RLIHdpbGwgc2VuZCB0aHJlZSB2aWRlbyBzdHJlYW1zIG9mIGRpZmZlcmVudFxuICogICBxdWFsaXRpZXNcbiAqL1xuLyoqXG4gKiBOYW1lcyBvZiB0aGUgc3VwcG9ydGVkIGF1ZGlvIGNvZGVjcy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIEF1ZGlvQ29kZWMgPSB7XG4gICAgaXNhYzogJ2lzYWMnLFxuICAgIG9wdXM6ICdvcHVzJyxcbiAgICBQQ01BOiAnUENNQScsXG4gICAgUENNVTogJ1BDTVUnXG59O1xuLyoqXG4gKiBOYW1lcyBvZiB0aGUgc3VwcG9ydGVkIHZpZGVvIGNvZGVjcy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIFZpZGVvQ29kZWMgPSB7XG4gICAgSDI2NDogJ0gyNjQnLFxuICAgIFZQODogJ1ZQOCdcbn07XG4vLyBWUDkgaXMgc3VwcG9ydGVkIGJ5IG1vc3QgYnJvd3NlcnMsIGJ1dCBiYWNrZW5kIGRvZXNuJ3QgYXQgdGhlIG1vbWVudC5cbi8vIEhpZGUgaXQgZnJvbSBwdWJsaWMgZG9jdW1lbnRhdGlvbiB1bnRpbCB0aGVuLlxuVmlkZW9Db2RlYy5WUDkgPSAnVlA5Jztcbi8qKlxuICogTGV2ZWxzIGZvciBsb2dnaW5nIHZlcmJvc2l0eS5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIExvZ0xldmVsID0ge1xuICAgIGRlYnVnOiAnZGVidWcnLFxuICAgIGluZm86ICdpbmZvJyxcbiAgICB3YXJuOiAnd2FybicsXG4gICAgZXJyb3I6ICdlcnJvcicsXG4gICAgb2ZmOiAnb2ZmJ1xufTtcbi8qKlxuICogVGhlIHZlcmJvc2l0eSBsZXZlbCBvZiBuZXR3b3JrIHF1YWxpdHkgaW5mb3JtYXRpb24gb2YgYSB7QGxpbmsgUGFydGljaXBhbnR9LlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG52YXIgTmV0d29ya1F1YWxpdHlWZXJib3NpdHkgPSB7XG4gICAgLyoqXG4gICAgICogTm90aGluZyBpcyByZXBvcnRlZCBmb3IgdGhlIHtAbGluayBQYXJ0aWNpcGFudH0uIFRoaXMgaGFzIG5vIGVmZmVjdCBhbmRcbiAgICAgKiBkZWZhdWx0cyB0byB7QGxpbmsgTmV0d29ya1F1YWxpdHlWZXJib3NpdHl9PGNvZGUgc3R5bGU9XCJwYWRkaW5nOjAgMFwiPiNtaW5pbWFsPC9jb2RlPlxuICAgICAqIGZvciB0aGUge0BsaW5rIExvY2FsUGFydGljaXBhbnR9LlxuICAgICAqL1xuICAgIG5vbmU6IDAsXG4gICAgLyoqXG4gICAgICogUmVwb3J0cyB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gZm9yIHRoZSB7QGxpbmsgUGFydGljaXBhbnR9LlxuICAgICAqL1xuICAgIG1pbmltYWw6IDEsXG4gICAgLyoqXG4gICAgICogUmVwb3J0cyB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gYW5kIHtAbGluayBOZXR3b3JrUXVhbGl0eVN0YXRzfSBmb3IgdGhlIHtAbGluayBQYXJ0aWNpcGFudH0uXG4gICAgICoge0BsaW5rIE5ldHdvcmtRdWFsaXR5U3RhdHN9IGlzIHBvcHVsYXRlZCB3aXRoIGF1ZGlvIGFuZCB2aWRlbyB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH1zXG4gICAgICogYmFzZWQgb24gd2hpY2ggdGhlIHtAbGluayBQYXJ0aWNpcGFudH0ncyB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gaXMgY2FsY3VsYXRlZC5cbiAgICAgKi9cbiAgICBtb2RlcmF0ZTogMixcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfSBhbmQge0BsaW5rIE5ldHdvcmtRdWFsaXR5U3RhdHN9IGZvciB0aGUge0BsaW5rIFBhcnRpY2lwYW50fS5cbiAgICAgKiB7QGxpbmsgTmV0d29ya1F1YWxpdHlTdGF0c30gaXMgcG9wdWxhdGVkIHdpdGggYXVkaW8gYW5kIFZpZGVvIHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfXNcbiAgICAgKiBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyB7QGxpbmsgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzfSBiYXNlZCBvbiB3aGljaCB0aGVcbiAgICAgKiB7QGxpbmsgUGFydGljaXBhbnR9J3Mge0BsaW5rIE5ldHdvcmtRdWFsaXR5TGV2ZWx9IGlzIGNhbGN1bGF0ZWQuXG4gICAgICovXG4gICAgZGV0YWlsZWQ6IDNcbn07XG4vKipcbiAqIHtAbGluayBUcmFja1N3aXRjaE9mZk1vZGV9IHNwZWNpZmllcyB3aGVuIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMnIGFyZSBzd2l0Y2hlZCBvZmYuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbnZhciBUcmFja1N3aXRjaE9mZk1vZGUgPSB7XG4gICAgLyoqXG4gICAgICogSW4gdGhpcyBtb2RlLCB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zIGFyZSBzd2l0Y2hlZCBvZmYgb25seSB3aGVuIG5ldHdvcmsgY29uZ2VzdGlvblxuICAgICAqIGlzIGRldGVjdGVkLlxuICAgICAqL1xuICAgIGRldGVjdGVkOiAnZGV0ZWN0ZWQnLFxuICAgIC8qKlxuICAgICAqIEluIHRoaXMgbW9kZSwge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cyBhcmUgcHJvLWFjdGl2ZWx5IHN3aXRjaGVkIG9mZiB3aGVuIG5ldHdvcmtcbiAgICAgKiBjb25nZXN0aW9uIGlzIHByZWRpY3RlZCBieSB0aGUgYmFuZHdpZHRoIGVzdGltYXRpb24gbWVjaGFuaXNtLlxuICAgICAqL1xuICAgIHByZWRpY3RlZDogJ3ByZWRpY3RlZCcsXG4gICAgLyoqXG4gICAgICogSW4gdGhpcyBtb2RlLCB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zIGFyZSBub3Qgc3dpdGNoZWQgb2ZmLiBJbnN0ZWFkIGluIHJlc3BvbnNlIHRvIG5ldHdvcmtcbiAgICAgKiBjb25nZXN0aW9uLCB0cmFja3Mgd2lsbCBiZSBhZGp1c3RlZCB0byBsb3dlciBxdWFsaXR5LlxuICAgICAqL1xuICAgIGRpc2FibGVkOiAnZGlzYWJsZWQnXG59O1xuLyoqXG4gKiB7QGxpbmsgQmFuZHdpZHRoUHJvZmlsZU1vZGV9IHNwZWNpZmllcyBob3cge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cycge0BsaW5rIFRyYWNrLlByaW9yaXR5fSB2YWx1ZXNcbiAqIGFyZSBtYXBwZWQgdG8gYmFuZHdpZHRoIGFsbG9jYXRpb24gaW4gR3JvdXAgUm9vbXMuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbnZhciBCYW5kd2lkdGhQcm9maWxlTW9kZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZGUgaXMgZm9yIHVzZSBjYXNlcyB3aGVyZSBhbGwgdGhlIHN1YnNjcmliZWQge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cyBhcmVcbiAgICAgKiBlcXVhbGx5IGltcG9ydGFudC4gVGhlIGJhbmR3aWR0aCBhbGxvY2F0aW9uIGFsZ29yaXRobSB3aWxsIHNoYXJlIHRoZSBhdmFpbGFibGVcbiAgICAgKiBkb3dubGluayBiYW5kd2lkdGggZXF1YWxseSBhbW9uZyB0aGUgc3Vic2NyaWJlZCB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zLCBpcnJlc3BlY3RpdmVcbiAgICAgKiBvZiB0aGVpciB7QGxpbmsgVHJhY2suUHJpb3JpdHl9LiBJbiBjYXNlIG9mIGluc3VmZmljaWVudCBkb3dubGluayBiYW5kd2lkdGgsIHRoZSBsb3dlclxuICAgICAqIHByaW9yaXR5IHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMgYXJlIHN3aXRjaGVkIG9mZi5cbiAgICAgKi9cbiAgICBncmlkOiAnZ3JpZCcsXG4gICAgLyoqXG4gICAgICogVGhpcyBtb2RlIGlzIGZvciB1c2UgY2FzZXMgd2hlcmUgc29tZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zIGFyZSBwcmlvcml0aXplZCBtb3JlIHRoYW5cbiAgICAgKiBvdGhlcnMuIEhvd2V2ZXIsIHRoZSBsb3dlciBwcmlvcml0eSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zIHN0aWxsIG5lZWQgdG8gYmUgdmlzaWJsZS5cbiAgICAgKiBUaGUgYmFuZHdpZHRoIGFsbG9jYXRpb24gYWxnb3JpdGhtIHdpbGwgc2hhcmUgdGhlIGF2YWlsYWJsZSBkb3dubGluayBiYW5kd2lkdGggcHJvcG9ydGlvbmFsXG4gICAgICogdG8gdGhlIHJlcXVlc3RlZCB7QGxpbmsgVmlkZW9SZW5kZXJEaW1lbnNpb25zfSBjb3JyZXNwb25kaW5nIHRvIHRoZWlyIHtAbGluayBUcmFjay5Qcmlvcml0eX0uXG4gICAgICogSW4gY2FzZSBvZiBpbnN1ZmZpY2llbnQgZG93bmxpbmsgYmFuZHdpZHRoLCB0aGUgcXVhbGl0eSBvZiBoaWdoZXIgcHJpb3JpdHkge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9c1xuICAgICAqIG1heSBiZSBkZWdyYWRlZCB0byBhdm9pZCBzd2l0Y2hpbmcgb2ZmIGxvd2VyIHByaW9yaXR5IHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMuXG4gICAgICovXG4gICAgY29sbGFib3JhdGlvbjogJ2NvbGxhYm9yYXRpb24nLFxuICAgIC8qKlxuICAgICAqIFRoaXMgbW9kZSBpcyBmb3IgdXNlIGNhc2VzIHdoZXJlIHNvbWUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cyBhcmUgZGVlbWVkIGNyaXRpY2FsIGFuZCBtdXN0XG4gICAgICogYmUgcHJlc2VydmVkIGF0IGFueSBjb3N0IG92ZXIgdGhlIG90aGVyIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMuIFRoZSBiYW5kd2lkdGggYWxsb2NhdGlvblxuICAgICAqIGFsZ29yaXRobSB3aWxsIGFsbG9jYXRlIGFzIGJpZyBhIHNoYXJlIG9mIHRoZSBhdmFpbGFibGUgZG93bmxpbmsgYmFuZHdpZHRoIGFzIGl0IHBvc3NpYmx5XG4gICAgICogY2FuIHRvIHRoZSBoaWdoZXIgcHJpb3JpdHkge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cywgYW5kIG9ubHkgdGhlbiBjb25zaWRlciB0aGUgbG93ZXIgcHJpb3JpdHlcbiAgICAgKiB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zLiBJbiBjYXNlIG9mIGluc3VmZmljaWVudCBkb3dubGluayBiYW5kd2lkdGgsIHRoZSBsb3dlciBwcmlvcml0eVxuICAgICAqIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMgYXJlIHN3aXRjaGVkIG9mZiBpbiBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgcXVhbGl0eSBvZiB0aGUgaGlnaGVyXG4gICAgICogcHJpb3JpdHkge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cy5cbiAgICAgKi9cbiAgICBwcmVzZW50YXRpb246ICdwcmVzZW50YXRpb24nXG59O1xuLyoqXG4gKiB7QGxpbmsgVmlkZW9Db250ZW50UHJlZmVyZW5jZXNNb2RlfSBzcGVjaWZpZXMgaG93IHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMnIHJlbmRlciBkaW1lbnNpb25zIGFyZVxuICogZGVjaWRlZCBieSB0aGUgU0RLLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG52YXIgVmlkZW9Db250ZW50UHJlZmVyZW5jZXNNb2RlID0ge1xuICAgIC8qKlxuICAgICAqIHdoZW4gc2V0IHRvIGF1dG8sIFNESyB1c2VzIHRoZSBzaXplcyBvZiB0aGUgdmlkZW8gZWxlbWVudHMgYXR0YWNoZWQgdG8gdGhlIHRvIHRoZSAge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IGR5bmFtaWNhbGx5IHRvXG4gICAgICogZGVjaWRlIHRoZSByZW5kZXIgZGltZW5zaW9ucy4ge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cyByZW5kZXJlZCBpbiBzbWFsbGVyIHZpZGVvIGVsZW1lbnRzIHdpbGwgYmUgZ2l2ZW4gc21hbGxlciBiYW5kd2lkdGggYWxsb2NhdGlvblxuICAgICAqIGNvbXBhcmVkIHRvIHRoZSB0cmFja3MgcmVuZGVyZWQgaW4gbGFyZ2UgdmlkZW8gZWxlbWVudHMuXG4gICAgICovXG4gICAgYXV0bzogJ2F1dG8nLFxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIG1hbnVhbCwgYXBwbGljYXRpb24gY2FuIHVzZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFjayNzZXRDb250ZW50UHJlZmVyZW5jZX0gdG8gc2V0IHRoZVxuICAgICAqIGRlc2lyZWQgcmVuZGVyIGRpbWVuc2lvbnMgZm9yIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30uXG4gICAgICovXG4gICAgbWFudWFsOiAnbWFudWFsJ1xufTtcbi8qKlxuICoge0BsaW5rIENsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbH0gc3BlY2lmaWVzIGhvdyB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31zJyB0dXJuZWQgb24gYW5kIG9mZlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG52YXIgQ2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sID0ge1xuICAgIC8qKlxuICAgICAqIHdoZW4gc2V0IHRvIGF1dG8sIFNESyB1c2VzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSB2aWRlbyBlbGVtZW50cyBhdHRhY2hlZCB0byB0aGUgdG8gdGhlICB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gdG8gZGVjaWRlLlxuICAgICAqIG9uIHR1cm5pbmcgdHJhY2tzIG9uIG9yIG9mZi4gVGhlIHRyYWNrIHRoYXQgYXJlIG5vdCBhdHRhY2hlZCB0byBhbnkgdmlkZW8gZWxlbWVudHMgb3Igbm90IHZpc2libGUgb24gdGhlIHNjcmVlbiB3aWxsIGJlIHR1cm5lZFxuICAgICAqIG9mZiBhdXRvbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGF1dG86ICdhdXRvJyxcbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBtYW51YWwsIGFwcGxpY2F0aW9uIGNhbiB1c2Uge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9cyBzd2l0Y2hPZmYgYW5kIHN3aXRjaE9uIGFwaXMgdG8gY29udHJvbCB0dXJuIHRoZSB0cmFjayBvbiBvciBvZmYuXG4gICAgICovXG4gICAgbWFudWFsOiAnbWFudWFsJ1xufTtcbi8qKlxuICogTmFtZXMgb2YgdGhlIHN1cHBvcnRlZCBsZXZlbHMgZm9yIHtAbGluayBFdmVudExpc3RlbmVyRXZlbnR9cy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIEV2ZW50TGlzdGVuZXJMZXZlbCA9IHtcbiAgICBkZWJ1ZzogJ2RlYnVnJyxcbiAgICBlcnJvcjogJ2Vycm9yJyxcbiAgICBpbmZvOiAnaW5mbycsXG4gICAgd2FybmluZzogJ3dhcm5pbmcnXG59O1xuLyoqXG4gKiBOYW1lcyBvZiB0aGUgc3VwcG9ydGVkIGdyb3VwcyBmb3Ige0BsaW5rIEV2ZW50TGlzdGVuZXJFdmVudH1zLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG52YXIgRXZlbnRMaXN0ZW5lckdyb3VwID0ge1xuICAgIC8qKlxuICAgICAqIEV2ZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbm5lY3Rpb24gdG8gVHdpbGlvJ3Mgc2lnbmFsaW5nIHNlcnZlclxuICAgICAqL1xuICAgIHNpZ25hbGluZzogJ3NpZ25hbGluZydcbn07XG4vKipcbiAqIEFuIHtAbGluayBFdmVudExpc3RlbmVyfSBhbGxvd3MgeW91IHRvIGxpc3RlbiB0byBmaW5lLWdyYWluZWQge0BsaW5rIEV2ZW50TGlzdGVuZXJFdmVudH1zIHJlbGF0ZWRcbiAqIHRvIHNpZ25hbGluZyBhbmQgbWVkaWEgdGhhdCBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgcHVibGljIEFQSXMsIHdoaWNoIG1pZ2h0IGJlIHVzZWZ1bCBmb3IgeW91ciBvd25cbiAqIHJlcG9ydGluZyBhbmQgZGlhZ25vc3RpY3MuXG4gKiBAdHlwZWRlZiB7RXZlbnRFbWl0dGVyfSBFdmVudExpc3RlbmVyXG4gKiBAZXhhbXBsZVxuICogY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuICogY29uc3QgeyBjb25uZWN0IH0gPSByZXF1aXJlKCd0d2lsaW8tdmlkZW8nKTtcbiAqXG4gKiBjb25zdCBldmVudExpc3RlbmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICogZXZlbnRMaXN0ZW5lci5vbignZXZlbnQnLCBmdW5jdGlvbihldmVudCkge1xuICogICBjb25zb2xlLmxvZygnVGhlIFNESyByYWlzZWQgYW4gZXZlbnQ6JywgZXZlbnQpO1xuICogfSk7XG4gKlxuICogY29ubmVjdCgndG9rZW4nLCB7XG4gKiAgIGV2ZW50TGlzdGVuZXI6IGV2ZW50TGlzdGVuZXJcbiAqIH0pO1xuICovXG4vKipcbiAqIFRoZSBTREsgcmFpc2VkIGFuIHtAbGluayBFdmVudExpc3RlbmVyRXZlbnR9LlxuICogQGV2ZW50IEV2ZW50TGlzdGVuZXIjZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lckV2ZW50fSBldmVudCAtIENvbnRleHQgYWJvdXQgdGhlIGV2ZW50IHJhaXNlZCBieSB0aGUgU0RLLlxuICogVGhpcyBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gKiAgKiB7QGxpbmsgRXZlbnRMaXN0ZW5lckNsb3NlZEV2ZW50fVxuICogICoge0BsaW5rIEV2ZW50TGlzdGVuZXJDb25uZWN0aW5nRXZlbnR9XG4gKiAgKiB7QGxpbmsgRXZlbnRMaXN0ZW5lckVhcmx5RXZlbnR9XG4gKiAgKiB7QGxpbmsgRXZlbnRMaXN0ZW5lck9wZW5FdmVudH1cbiAqICAqIHtAbGluayBFdmVudExpc3RlbmVyV2FpdGluZ0V2ZW50fVxuICovXG4vKipcbiAqIEFuIHtAbGluayBFdmVudExpc3RlbmVyRXZlbnR9IHByb3ZpZGVzIGNvbnRleHQgYWJvdXQgYW4gZXZlbnQgcmFpc2VkIGJ5IHRoZSBTREsgb24gdGhlXG4gKiB7QGxpbmsgRXZlbnRMaXN0ZW5lcn0uIEFwYXJ0IGZyb20gdGhlIHByb3BlcnRpZXMgbGlzdGVkIGhlcmUsIGl0IG1heSBhbHNvIGluY2x1ZGUgc29tZVxuICogZXZlbnQtc3BlY2lmaWMgZGF0YSB3aXRoaW4gYW4gb3B0aW9uYWwgXCJwYXlsb2FkXCIgcHJvcGVydHkuIFRoZSBkaWZmZXJlbnQgdHlwZXMgb2ZcbiAqIHtAbGluayBFdmVudExpc3RlbmVyRXZlbnR9cyBhcmUgbGlzdGVkIGJlbG93OlxuICogICoge0BsaW5rIEV2ZW50TGlzdGVuZXJDbG9zZWRFdmVudH1cbiAqICAqIHtAbGluayBFdmVudExpc3RlbmVyQ29ubmVjdGluZ0V2ZW50fVxuICogICoge0BsaW5rIEV2ZW50TGlzdGVuZXJFYXJseUV2ZW50fVxuICogICoge0BsaW5rIEV2ZW50TGlzdGVuZXJPcGVuRXZlbnR9XG4gKiAgKiB7QGxpbmsgRXZlbnRMaXN0ZW5lcldhaXRpbmdFdmVudH1cbiAqIEB0eXBlZGVmIHtvYmplY3R9IEV2ZW50TGlzdGVuZXJFdmVudFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVsYXBzZWRUaW1lIC0gVGhlIHRpbWUgZWxhcHNlZCBpbiBtaWxsaXNlY29uZHMgc2luY2UgY29ubmVjdCgpIHdhcyBjYWxsZWRcbiAqIEBwcm9wZXJ0eSB7RXZlbnRMaXN0ZW5lckdyb3VwfSBncm91cCAtIFRoZSBncm91cCB1bmRlciB3aGljaCB0aGUgZXZlbnQgaXMgY2xhc3NpZmllZFxuICogQHByb3BlcnR5IHtFdmVudExpc3RlbmVyTGV2ZWx9IGxldmVsIC0gVGhlIHZlcmJvc2l0eSBsZXZlbCBvZiB0aGUgZXZlbnQsIHdoaWNoIGNhbiBiZSBvbmUgb2YgXCJkZWJ1Z1wiLCBcImVycm9yXCIsIFwiaW5mb1wiLCBcIndhcm5pbmdcIlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAqIEBwcm9wZXJ0eSB7Kn0gW3BheWxvYWRdIC0gT3B0aW9uYWwgZXZlbnQtc3BlY2lmaWMgZGF0YVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVzdGFtcCAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyByZWxhdGl2ZSB0byB0aGUgVW5peCBFcG9jaCB3aGVuIHRoZSBldmVudCB3YXMgcmFpc2VkXG4gKi9cbi8qKlxuICogVGhlIGNvbm5lY3Rpb24gdG8gVHdpbGlvJ3Mgc2lnbmFsaW5nIHNlcnZlciB3YXMgY2xvc2VkLlxuICogQHR5cGVkZWYge0V2ZW50TGlzdGVuZXJFdmVudH0gRXZlbnRMaXN0ZW5lckNsb3NlZEV2ZW50XG4gKiBAcHJvcGVydHkge0V2ZW50TGlzdGVuZXJHcm91cH0gZ3JvdXA9J3NpZ25hbGluZydcbiAqIEBwcm9wZXJ0eSB7RXZlbnRMaXN0ZW5lckxldmVsfSBsZXZlbCAtICdpbmZvJyBpZiB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGJ5IHRoZSBjbGllbnQsICdlcnJvcicgb3RoZXJ3aXNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZT0nY2xvc2VkJ1xuICogQHByb3BlcnR5IHt7cmVhc29uOiBzdHJpbmd9fSBwYXlsb2FkIC0gUmVhc29uIGZvciB0aGUgY29ubmVjdGlvbiBiZWluZyBjbG9zZWQuIEl0IGNhbiBiZSBvbmUgb2ZcbiAqICAgJ2J1c3knLCAnZmFpbGVkJywgJ2xvY2FsJywgJ3JlbW90ZScgb3IgJ3RpbWVvdXQnXG4gKi9cbi8qKlxuICogVGhlIFNESyBpcyBjb25uZWN0aW5nIHRvIFR3aWxpbydzIHNpZ25hbGluZyBzZXJ2ZXIuXG4gKiBAdHlwZWRlZiB7RXZlbnRMaXN0ZW5lckV2ZW50fSBFdmVudExpc3RlbmVyQ29ubmVjdGluZ0V2ZW50XG4gKiBAcHJvcGVydHkge0V2ZW50TGlzdGVuZXJHcm91cH0gZ3JvdXA9J3NpZ25hbGluZydcbiAqIEBwcm9wZXJ0eSB7RXZlbnRMaXN0ZW5lckxldmVsfSBsZXZlbD0naW5mbydcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lPSdjb25uZWN0aW5nJ1xuICovXG4vKipcbiAqIFRoZSBTREsgaXMgYWJvdXQgdG8gY29ubmVjdCB0byBUd2lsaW8ncyBzaWduYWxpbmcgc2VydmVyLlxuICogQHR5cGVkZWYge0V2ZW50TGlzdGVuZXJFdmVudH0gRXZlbnRMaXN0ZW5lckVhcmx5RXZlbnRcbiAqIEBwcm9wZXJ0eSB7RXZlbnRMaXN0ZW5lckdyb3VwfSBncm91cD0nc2lnbmFsaW5nJ1xuICogQHByb3BlcnR5IHtFdmVudExpc3RlbmVyTGV2ZWx9IGxldmVsPSdpbmZvJ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWU9J2Vhcmx5J1xuICovXG4vKipcbiAqIFRoZSBTREsgaGFzIGVzdGFibGlzaGVkIGEgc2lnbmFsaW5nIGNvbm5lY3Rpb24gdG8gVHdpbGlvJ3Mgc2lnbmFsaW5nIHNlcnZlci5cbiAqIEB0eXBlZGVmIHtFdmVudExpc3RlbmVyRXZlbnR9IEV2ZW50TGlzdGVuZXJPcGVuRXZlbnRcbiAqIEBwcm9wZXJ0eSB7RXZlbnRMaXN0ZW5lckdyb3VwfSBncm91cD0nc2lnbmFsaW5nJ1xuICogQHByb3BlcnR5IHtFdmVudExpc3RlbmVyTGV2ZWx9IGxldmVsPSdpbmZvJ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWU9J29wZW4nXG4gKi9cbi8qKlxuICogVGhlIFNESyBpcyB3YWl0aW5nIHRvIHJldHJ5IGNvbm5lY3RpbmcgdGggVHdpbGlvJ3Mgc2lnbmFsaW5nIHNlcnZlci4gVGhpcyBjYW5cbiAqIGhhcHBlbiBpZiB0aGUgc2VydmVyIGlzIGJ1c3kgd2l0aCB0b28gbWFueSBjb25uZWN0aW9uIHJlcXVlc3RzLlxuICogQHR5cGVkZWYge0V2ZW50TGlzdGVuZXJFdmVudH0gRXZlbnRMaXN0ZW5lcldhaXRpbmdFdmVudFxuICogQHByb3BlcnR5IHtFdmVudExpc3RlbmVyR3JvdXB9IGdyb3VwPSdzaWduYWxpbmcnXG4gKiBAcHJvcGVydHkge0V2ZW50TGlzdGVuZXJMZXZlbH0gbGV2ZWw9J3dhcm5pbmcnXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZT0nd2FpdGluZydcbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlT3B0aW9ucyhvcHRpb25zLCBsb2csIGRlcHJlY2F0aW9uVGFibGUpIHtcbiAgICBkZXByZWNhdGlvblRhYmxlLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgdmFyIGRpZFdhcm4gPSBwcm9wLmRpZFdhcm4sIG5hbWUgPSBwcm9wLm5hbWUsIG5ld05hbWUgPSBwcm9wLm5ld05hbWUsIHNob3VsZERlbGV0ZSA9IHByb3Auc2hvdWxkRGVsZXRlO1xuICAgICAgICBpZiAobmFtZSBpbiBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zW25hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKG5ld05hbWUgJiYgc2hvdWxkRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1tuZXdOYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRpZFdhcm4gJiYgIVsnZXJyb3InLCAnb2ZmJ10uaW5jbHVkZXMobG9nLmxldmVsKSkge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiVGhlIENvbm5lY3RPcHRpb25zIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgXCIgKyAobmV3TmFtZVxuICAgICAgICAgICAgICAgICAgICA/IFwiZGVwcmVjYXRlZCBhbmQgc2NoZWR1bGVkIGZvciByZW1vdmFsLiBQbGVhc2UgdXNlIFxcXCJcIiArIG5ld05hbWUgKyBcIlxcXCIgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICAgICAgICA6ICdubyBsb25nZXIgYXBwbGljYWJsZSBhbmQgd2lsbCBiZSBpZ25vcmVkLicpKTtcbiAgICAgICAgICAgICAgICBwcm9wLmRpZFdhcm4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVMb2NhbFBhcnRpY2lwYW50KHNpZ25hbGluZywgbG9nLCBlbmNvZGluZ1BhcmFtZXRlcnMsIG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbiwgb3B0aW9ucywgbG9jYWxUcmFja3MpIHtcbiAgICB2YXIgbG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZyA9IHNpZ25hbGluZy5jcmVhdGVMb2NhbFBhcnRpY2lwYW50U2lnbmFsaW5nKGVuY29kaW5nUGFyYW1ldGVycywgbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uKTtcbiAgICBsb2cuZGVidWcoJ0NyZWF0aW5nIGEgbmV3IExvY2FsUGFydGljaXBhbnQ6JywgbG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZyk7XG4gICAgcmV0dXJuIG5ldyBvcHRpb25zLkxvY2FsUGFydGljaXBhbnQobG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZywgbG9jYWxUcmFja3MsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbShvcHRpb25zLCBsb2NhbFBhcnRpY2lwYW50LCByb29tU2lnbmFsaW5nKSB7XG4gICAgdmFyIHJvb20gPSBuZXcgUm9vbShsb2NhbFBhcnRpY2lwYW50LCByb29tU2lnbmFsaW5nLCBvcHRpb25zKTtcbiAgICB2YXIgbG9nID0gb3B0aW9ucy5sb2c7XG4gICAgbG9nLmRlYnVnKCdDcmVhdGluZyBhIG5ldyBSb29tOicsIHJvb20pO1xuICAgIHJvb21TaWduYWxpbmcub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICBsb2cuaW5mbygnRGlzY29ubmVjdGVkIGZyb20gUm9vbTonLCByb29tLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgcm9vbVNpZ25hbGluZy5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByb29tO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbVNpZ25hbGluZyh0b2tlbiwgb3B0aW9ucywgc2lnbmFsaW5nLCBlbmNvZGluZ1BhcmFtZXRlcnMsIHByZWZlcnJlZENvZGVjcywgbG9jYWxQYXJ0aWNpcGFudCkge1xuICAgIG9wdGlvbnMubG9nLmRlYnVnKCdDcmVhdGluZyBhIG5ldyBSb29tU2lnbmFsaW5nJyk7XG4gICAgcmV0dXJuIHNpZ25hbGluZy5jb25uZWN0KGxvY2FsUGFydGljaXBhbnQuX3NpZ25hbGluZywgdG9rZW4sIGVuY29kaW5nUGFyYW1ldGVycywgcHJlZmVycmVkQ29kZWNzLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGdldExvY2FsVHJhY2tzKG9wdGlvbnMsIGhhbmRsZUxvY2FsVHJhY2tzKSB7XG4gICAgdmFyIGxvZyA9IG9wdGlvbnMubG9nO1xuICAgIG9wdGlvbnMuc2hvdWxkU3RvcExvY2FsVHJhY2tzID0gIW9wdGlvbnMudHJhY2tzO1xuICAgIGlmIChvcHRpb25zLnNob3VsZFN0b3BMb2NhbFRyYWNrcykge1xuICAgICAgICBsb2cuaW5mbygnTG9jYWxUcmFja3Mgd2VyZSBub3QgcHJvdmlkZWQsIHNvIHRoZXkgd2lsbCBiZSBhY3F1aXJlZCAnXG4gICAgICAgICAgICArICdhdXRvbWF0aWNhbGx5IGJlZm9yZSBjb25uZWN0aW5nIHRvIHRoZSBSb29tLiBMb2NhbFRyYWNrcyB3aWxsICdcbiAgICAgICAgICAgICsgJ2JlIHJlbGVhc2VkIGlmIGNvbm5lY3RpbmcgdG8gdGhlIFJvb20gZmFpbHMgb3IgaWYgdGhlIFJvb20gJ1xuICAgICAgICAgICAgKyAnaXMgZGlzY29ubmVjdGVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2cuaW5mbygnR2V0dGluZyBMb2NhbFRyYWNrcycpO1xuICAgICAgICBsb2cuZGVidWcoJ09wdGlvbnM6Jywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmNyZWF0ZUxvY2FsVHJhY2tzKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gZ2V0TG9jYWxUcmFja3NTdWNjZWVkZWQobG9jYWxUcmFja3MpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBoYW5kbGVMb2NhbFRyYWNrcyhsb2NhbFRyYWNrcyk7XG4gICAgICAgIHByb21pc2UuY2F0Y2goZnVuY3Rpb24gaGFuZGxlTG9jYWxUcmFja3NGYWlsZWQoKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRTdG9wTG9jYWxUcmFja3MpIHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbygnVGhlIGF1dG9tYXRpY2FsbHkgYWNxdWlyZWQgTG9jYWxUcmFja3Mgd2lsbCBub3cgYmUgc3RvcHBlZCcpO1xuICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29kZWNTZXR0aW5ncyhuYW1lT3JTZXR0aW5ncykge1xuICAgIHZhciBzZXR0aW5ncyA9IHR5cGVvZiBuYW1lT3JTZXR0aW5ncyA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB7IGNvZGVjOiBuYW1lT3JTZXR0aW5ncyB9XG4gICAgICAgIDogbmFtZU9yU2V0dGluZ3M7XG4gICAgc3dpdGNoIChzZXR0aW5ncy5jb2RlYy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ29wdXMnOiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGR0eDogdHJ1ZSB9LCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndnA4Jzoge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBzaW11bGNhc3Q6IGZhbHNlIH0sIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgICAgIH1cbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZhdWx0Q3JlYXRlTG9jYWxUcmFja3MgPSByZXF1aXJlKCcuL2NyZWF0ZWxvY2FsdHJhY2tzJyk7XG52YXIgX2EgPSByZXF1aXJlKCcuL3V0aWwvY29uc3RhbnRzJyksIERFRkFVTFRfTE9HX0xFVkVMID0gX2EuREVGQVVMVF9MT0dfTEVWRUwsIERFRkFVTFRfTE9HR0VSX05BTUUgPSBfYS5ERUZBVUxUX0xPR0dFUl9OQU1FO1xuLyoqXG4gKiBSZXF1ZXN0IGEge0BsaW5rIExvY2FsQXVkaW9UcmFja30gb3Ige0BsaW5rIExvY2FsVmlkZW9UcmFja30uXG4gKiBAcGFyYW0ge1RyYWNrLktpbmR9IGtpbmQgLSBcImF1ZGlvXCIgb3IgXCJ2aWRlb1wiXG4gKiBAcGFyYW0ge0NyZWF0ZUxvY2FsVHJhY2tPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPExvY2FsQXVkaW9UcmFja3xMb2NhbFZpZGVvVHJhY2s+fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxUcmFjayhraW5kLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjcmVhdGVMb2NhbFRyYWNrczogZGVmYXVsdENyZWF0ZUxvY2FsVHJhY2tzLFxuICAgICAgICBsb2dnZXJOYW1lOiBERUZBVUxUX0xPR0dFUl9OQU1FLFxuICAgICAgICBsb2dMZXZlbDogREVGQVVMVF9MT0dfTEVWRUwsXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdmFyIGNyZWF0ZU9wdGlvbnMgPSB7fTtcbiAgICBjcmVhdGVPcHRpb25zLmxvZ2dlck5hbWUgPSBvcHRpb25zLmxvZ2dlck5hbWU7XG4gICAgY3JlYXRlT3B0aW9ucy5sb2dMZXZlbCA9IG9wdGlvbnMubG9nTGV2ZWw7XG4gICAgZGVsZXRlIG9wdGlvbnMubG9nZ2VyTmFtZTtcbiAgICBkZWxldGUgb3B0aW9ucy5sb2dMZXZlbDtcbiAgICB2YXIgY3JlYXRlTG9jYWxUcmFja3MgPSBvcHRpb25zLmNyZWF0ZUxvY2FsVHJhY2tzO1xuICAgIGRlbGV0ZSBvcHRpb25zLmNyZWF0ZUxvY2FsVHJhY2tzO1xuICAgIGNyZWF0ZU9wdGlvbnNba2luZF0gPSBPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPiAwID8gb3B0aW9ucyA6IHRydWU7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsVHJhY2tzKGNyZWF0ZU9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGxvY2FsVHJhY2tzKSB7IHJldHVybiBsb2NhbFRyYWNrc1swXTsgfSk7XG59XG4vKipcbiAqIFJlcXVlc3QgYSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfS5cbiAqIEBhbGlhcyBtb2R1bGU6dHdpbGlvLXZpZGVvLmNyZWF0ZUxvY2FsQXVkaW9UcmFja1xuICogQHBhcmFtIHtDcmVhdGVMb2NhbFRyYWNrT3B0aW9uc30gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgcmVxdWVzdGluZyBhIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxMb2NhbEF1ZGlvVHJhY2s+fVxuICogQGV4YW1wbGVcbiAqIHZhciBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICpcbiAqIC8vIENvbm5lY3QgdG8gdGhlIFJvb20gd2l0aCBqdXN0IHZpZGVvXG4gKiBWaWRlby5jb25uZWN0KCdteS10b2tlbicsIHtcbiAqICAgbmFtZTogJ215LWNvb2wtcm9vbScsXG4gKiAgIHZpZGVvOiB0cnVlXG4gKiB9KS50aGVuKGZ1bmN0aW9uKHJvb20pIHtcbiAqICAgLy8gQWRkIGF1ZGlvIGFmdGVyIGNvbm5lY3RpbmcgdG8gdGhlIFJvb21cbiAqICAgVmlkZW8uY3JlYXRlTG9jYWxBdWRpb1RyYWNrKCkudGhlbihmdW5jdGlvbihsb2NhbFRyYWNrKSB7XG4gKiAgICAgcm9vbS5sb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hUcmFjayhsb2NhbFRyYWNrKTtcbiAqICAgfSk7XG4gKiB9KTtcbiAqIEBleGFtcGxlXG4gKiB2YXIgVmlkZW8gPSByZXF1aXJlKCd0d2lsaW8tdmlkZW8nKTtcbiAqXG4gKiAvLyBSZXF1ZXN0IHRoZSBkZWZhdWx0IExvY2FsQXVkaW9UcmFjayB3aXRoIGEgY3VzdG9tIG5hbWVcbiAqIFZpZGVvLmNyZWF0ZUxvY2FsQXVkaW9UcmFjayh7IG5hbWU6ICdtaWNyb3Bob25lJyB9KS50aGVuKGZ1bmN0aW9uKGxvY2FsVHJhY2spIHtcbiAqICAgY29uc29sZS5sb2cobG9jYWxUcmFjay5uYW1lKTsgLy8gJ21pY3JvcGhvbmUnXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxBdWRpb1RyYWNrKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWxUcmFjaygnYXVkaW8nLCBvcHRpb25zKTtcbn1cbi8qKlxuICogUmVxdWVzdCBhIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9LiBOb3RlIHRoYXQgb24gbW9iaWxlIGJyb3dzZXJzLFxuICogdGhlIGNhbWVyYSBjYW4gYmUgcmVzZXJ2ZWQgYnkgb25seSBvbmUge0BsaW5rIExvY2FsVmlkZW9UcmFja30gYXQgYW55IGdpdmVuXG4gKiB0aW1lLiBJZiB5b3UgYXR0ZW1wdCB0byBjcmVhdGUgYSBzZWNvbmQge0BsaW5rIExvY2FsVmlkZW9UcmFja30sIHZpZGVvIGZyYW1lc1xuICogd2lsbCBubyBsb25nZXIgYmUgc3VwcGxpZWQgdG8gdGhlIGZpcnN0IHtAbGluayBMb2NhbFZpZGVvVHJhY2t9LlxuICogQGFsaWFzIG1vZHVsZTp0d2lsaW8tdmlkZW8uY3JlYXRlTG9jYWxWaWRlb1RyYWNrXG4gKiBAcGFyYW0ge0NyZWF0ZUxvY2FsVHJhY2tPcHRpb25zfSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciByZXF1ZXN0aW5nIGEge0BsaW5rIExvY2FsVmlkZW9UcmFja31cbiAqIEByZXR1cm5zIHtQcm9taXNlPExvY2FsVmlkZW9UcmFjaz59XG4gKiBAZXhhbXBsZVxuICogdmFyIFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gKlxuICogLy8gQ29ubmVjdCB0byB0aGUgUm9vbSB3aXRoIGp1c3QgYXVkaW9cbiAqIFZpZGVvLmNvbm5lY3QoJ215LXRva2VuJywge1xuICogICBuYW1lOiAnbXktY29vbC1yb29tJyxcbiAqICAgYXVkaW86IHRydWVcbiAqIH0pLnRoZW4oZnVuY3Rpb24ocm9vbSkge1xuICogICAvLyBBZGQgdmlkZW8gYWZ0ZXIgY29ubmVjdGluZyB0byB0aGUgUm9vbVxuICogICBWaWRlby5jcmVhdGVMb2NhbFZpZGVvVHJhY2soKS50aGVuKGZ1bmN0aW9uKGxvY2FsVHJhY2spIHtcbiAqICAgICByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKGxvY2FsVHJhY2spO1xuICogICB9KTtcbiAqIH0pO1xuICogQGV4YW1wbGVcbiAqIHZhciBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICpcbiAqIC8vIFJlcXVlc3QgdGhlIGRlZmF1bHQgTG9jYWxWaWRlb1RyYWNrIHdpdGggYSBjdXN0b20gbmFtZVxuICogVmlkZW8uY3JlYXRlTG9jYWxWaWRlb1RyYWNrKHsgbmFtZTogJ2NhbWVyYScgfSkudGhlbihmdW5jdGlvbihsb2NhbFRyYWNrKSB7XG4gKiAgIGNvbnNvbGUubG9nKGxvY2FsVHJhY2submFtZSk7IC8vICdjYW1lcmEnXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxWaWRlb1RyYWNrKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWxUcmFjaygndmlkZW8nLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlIHtAbGluayBMb2NhbFRyYWNrfSBvcHRpb25zLiBBcGFydCBmcm9tIHRoZSBwcm9wZXJ0aWVzIGxpc3RlZCBoZXJlLCB5b3UgY2FuXG4gKiBhbHNvIHNwZWNpZnkgYW55IG9mIHRoZSA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhVHJhY2tDb25zdHJhaW50c1wiIHRhcmdldD1cIl9ibGFua1wiPk1lZGlhVHJhY2tDb25zdHJhaW50czwvYT5cbiAqIHByb3BlcnRpZXMuXG4gKiBAdHlwZWRlZiB7TWVkaWFUcmFja0NvbnN0cmFpbnRzfSBDcmVhdGVMb2NhbFRyYWNrT3B0aW9uc1xuICogQHByb3BlcnR5IHtMb2dMZXZlbHxMb2dMZXZlbHN9IFtsb2dMZXZlbD0nd2FybiddIC0gPGNvZGU+KGRlcHJlY2F0ZWQ6IHVzZSBbVmlkZW8uTG9nZ2VyXShtb2R1bGUtdHdpbGlvLXZpZGVvLmh0bWwpIGluc3RlYWQuXG4gKiAgIFNlZSBbZXhhbXBsZXNdKG1vZHVsZS10d2lsaW8tdmlkZW8uaHRtbCMuY29ubmVjdCkgZm9yIGRldGFpbHMpPC9jb2RlPlxuICogICBTZXQgdGhlIGRlZmF1bHQgbG9nIHZlcmJvc2l0eVxuICogICBvZiBsb2dnaW5nLiBQYXNzaW5nIGEge0BsaW5rIExvZ0xldmVsfSBzdHJpbmcgd2lsbCB1c2UgdGhlIHNhbWVcbiAqICAgbGV2ZWwgZm9yIGFsbCBjb21wb25lbnRzLiBQYXNzIGEge0BsaW5rIExvZ0xldmVsc30gdG8gc2V0IHNwZWNpZmljIGxvZ1xuICogICBsZXZlbHMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xvZ2dlck5hbWU9J3R3aWxpby12aWRlbyddIC0gVGhlIG5hbWUgb2YgdGhlIGxvZ2dlci4gVXNlIHRoaXMgbmFtZSB3aGVuIGFjY2Vzc2luZyB0aGUgbG9nZ2VyIHVzZWQgYnkgdGhlIFNESy5cbiAqICAgU2VlIFtleGFtcGxlc10obW9kdWxlLXR3aWxpby12aWRlby5odG1sIy5jb25uZWN0KSBmb3IgZGV0YWlscy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gLSBUaGUge0BsaW5rIExvY2FsVHJhY2t9J3MgbmFtZTsgYnkgZGVmYXVsdCxcbiAqICAgaXQgaXMgc2V0IHRvIHRoZSB7QGxpbmsgTG9jYWxUcmFja30ncyBJRC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dvcmthcm91bmRXZWJLaXRCdWcxODA3NDg9ZmFsc2VdIC0gT25seSB2YWxpZCBmb3JcbiAqICAge0BsaW5rIExvY2FsQXVkaW9UcmFja31zOyBzZXR0aW5nIHRoaXMgYXR0ZW1wdHMgdG8gd29ya2Fyb3VuZCBXZWJLaXQgQnVnXG4gKiAgIDE4MDc0OCwgd2hlcmUsIGluIFNhZmFyaSwgZ2V0VXNlck1lZGlhIG1heSByZXR1cm4gYSBzaWxlbnQgYXVkaW9cbiAqICAgTWVkaWFTdHJlYW1UcmFjay5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXVkaW86IGNyZWF0ZUxvY2FsQXVkaW9UcmFjayxcbiAgICB2aWRlbzogY3JlYXRlTG9jYWxWaWRlb1RyYWNrXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlbG9jYWx0cmFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgYXNMb2NhbFRyYWNrID0gcmVxdWlyZSgnLi91dGlsJykuYXNMb2NhbFRyYWNrO1xudmFyIGJ1aWxkTG9nTGV2ZWxzID0gcmVxdWlyZSgnLi91dGlsJykuYnVpbGRMb2dMZXZlbHM7XG52YXIgZ2V0VXNlck1lZGlhID0gcmVxdWlyZSgnQHR3aWxpby93ZWJydGMnKS5nZXRVc2VyTWVkaWE7XG52YXIgX2EgPSByZXF1aXJlKCcuL21lZGlhL3RyYWNrL2VzNScpLCBMb2NhbEF1ZGlvVHJhY2sgPSBfYS5Mb2NhbEF1ZGlvVHJhY2ssIExvY2FsRGF0YVRyYWNrID0gX2EuTG9jYWxEYXRhVHJhY2ssIExvY2FsVmlkZW9UcmFjayA9IF9hLkxvY2FsVmlkZW9UcmFjaztcbnZhciBNZWRpYVN0cmVhbVRyYWNrID0gcmVxdWlyZSgnQHR3aWxpby93ZWJydGMnKS5NZWRpYVN0cmVhbVRyYWNrO1xudmFyIExvZyA9IHJlcXVpcmUoJy4vdXRpbC9sb2cnKTtcbnZhciBfYiA9IHJlcXVpcmUoJy4vdXRpbC9jb25zdGFudHMnKSwgREVGQVVMVF9MT0dfTEVWRUwgPSBfYi5ERUZBVUxUX0xPR19MRVZFTCwgREVGQVVMVF9MT0dHRVJfTkFNRSA9IF9iLkRFRkFVTFRfTE9HR0VSX05BTUU7XG52YXIgd29ya2Fyb3VuZDE4MDc0OCA9IHJlcXVpcmUoJy4vd2ViYXVkaW8vd29ya2Fyb3VuZDE4MDc0OCcpO1xuLy8gVGhpcyBpcyB1c2VkIHRvIG1ha2Ugb3V0IHdoaWNoIGNyZWF0ZUxvY2FsVHJhY2tzKCkgY2FsbCBhIHBhcnRpY3VsYXIgTG9nXG4vLyBzdGF0ZW1lbnQgYmVsb25ncyB0by4gRWFjaCBjYWxsIHRvIGNyZWF0ZUxvY2FsVHJhY2tzKCkgaW5jcmVtZW50cyB0aGlzXG4vLyBjb3VudGVyLlxudmFyIGNyZWF0ZUxvY2FsVHJhY2tDYWxscyA9IDA7XG4vKipcbiAqIFJlcXVlc3Qge0BsaW5rIExvY2FsVHJhY2t9cy4gQnkgZGVmYXVsdCwgaXQgcmVxdWVzdHMgYVxuICoge0BsaW5rIExvY2FsQXVkaW9UcmFja30gYW5kIGEge0BsaW5rIExvY2FsVmlkZW9UcmFja30uXG4gKiBOb3RlIHRoYXQgb24gbW9iaWxlIGJyb3dzZXJzLCB0aGUgY2FtZXJhIGNhbiBiZSByZXNlcnZlZCBieSBvbmx5IG9uZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfVxuICogYXQgYW55IGdpdmVuIHRpbWUuIElmIHlvdSBhdHRlbXB0IHRvIGNyZWF0ZSBhIHNlY29uZCB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSwgdmlkZW8gZnJhbWVzXG4gKiB3aWxsIG5vIGxvbmdlciBiZSBzdXBwbGllZCB0byB0aGUgZmlyc3Qge0BsaW5rIExvY2FsVmlkZW9UcmFja30uXG4gKiBAYWxpYXMgbW9kdWxlOnR3aWxpby12aWRlby5jcmVhdGVMb2NhbFRyYWNrc1xuICogQHBhcmFtIHtDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8TG9jYWxUcmFjaz4+fVxuICogQGV4YW1wbGVcbiAqIHZhciBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICogLy8gUmVxdWVzdCBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gKiBWaWRlby5jcmVhdGVMb2NhbFRyYWNrcygpLnRoZW4oZnVuY3Rpb24obG9jYWxUcmFja3MpIHtcbiAqICAgdmFyIGxvY2FsTWVkaWFDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9jYWwtbWVkaWEtY29udGFpbmVyLWlkJyk7XG4gKiAgIGxvY2FsVHJhY2tzLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAqICAgICBsb2NhbE1lZGlhQ29udGFpbmVyLmFwcGVuZENoaWxkKHRyYWNrLmF0dGFjaCgpKTtcbiAqICAgfSk7XG4gKiB9KTtcbiAqIEBleGFtcGxlXG4gKiB2YXIgVmlkZW8gPSByZXF1aXJlKCd0d2lsaW8tdmlkZW8nKTtcbiAqIC8vIFJlcXVlc3QganVzdCB0aGUgZGVmYXVsdCBhdWRpbyB0cmFja1xuICogVmlkZW8uY3JlYXRlTG9jYWxUcmFja3MoeyBhdWRpbzogdHJ1ZSB9KS50aGVuKGZ1bmN0aW9uKGxvY2FsVHJhY2tzKSB7XG4gKiAgIHJldHVybiBWaWRlby5jb25uZWN0KCdteS10b2tlbicsIHtcbiAqICAgICBuYW1lOiAnbXktY29vbC1yb29tJyxcbiAqICAgICB0cmFja3M6IGxvY2FsVHJhY2tzXG4gKiAgIH0pO1xuICogfSk7XG4gKiBAZXhhbXBsZVxuICogdmFyIFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gKiAvLyBSZXF1ZXN0IHRoZSBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzIHdpdGggY3VzdG9tIG5hbWVzXG4gKiBWaWRlby5jcmVhdGVMb2NhbFRyYWNrcyh7XG4gKiAgIGF1ZGlvOiB7IG5hbWU6ICdtaWNyb3Bob25lJyB9LFxuICogICB2aWRlbzogeyBuYW1lOiAnY2FtZXJhJyB9XG4gKiB9KS50aGVuKGZ1bmN0aW9uKGxvY2FsVHJhY2tzKSB7XG4gKiAgIGxvY2FsVHJhY2tzLmZvckVhY2goZnVuY3Rpb24obG9jYWxUcmFjaykge1xuICogICAgIGNvbnNvbGUubG9nKGxvY2FsVHJhY2submFtZSk7XG4gKiAgIH0pO1xuICogfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBWaWRlbyA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICogdmFyIGxvY2FsVHJhY2tzO1xuICpcbiAqIC8vIFByZS1hY3F1aXJlIHRyYWNrcyB0byBkaXNwbGF5IGNhbWVyYSBwcmV2aWV3LlxuICogVmlkZW8uY3JlYXRlTG9jYWxUcmFja3MoKS50aGVuKGZ1bmN0aW9uKHRyYWNrcykge1xuICogIGxvY2FsVHJhY2tzID0gdHJhY2tzO1xuICogIHZhciBsb2NhbFZpZGVvVHJhY2sgPSBsb2NhbFRyYWNrcy5maW5kKHRyYWNrID0+IHRyYWNrLmtpbmQgPT09ICd2aWRlbycpO1xuICogIGRpdkNvbnRhaW5lci5hcHBlbmRDaGlsZChsb2NhbFZpZGVvVHJhY2suYXR0YWNoKCkpO1xuICogfSlcbiAqXG4gKiAvLyBMYXRlciwgam9pbiB0aGUgUm9vbSB3aXRoIHRoZSBwcmUtYWNxdWlyZWQgTG9jYWxUcmFja3MuXG4gKiBWaWRlby5jb25uZWN0KCd0b2tlbicsIHtcbiAqICAgbmFtZTogJ215LWNvb2wtcm9vbScsXG4gKiAgIHRyYWNrczogbG9jYWxUcmFja3NcbiAqIH0pO1xuICpcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxUcmFja3Mob3B0aW9ucykge1xuICAgIHZhciBpc0F1ZGlvVmlkZW9BYnNlbnQgPSAhKG9wdGlvbnMgJiYgKCdhdWRpbycgaW4gb3B0aW9ucyB8fCAndmlkZW8nIGluIG9wdGlvbnMpKTtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGF1ZGlvOiBpc0F1ZGlvVmlkZW9BYnNlbnQsXG4gICAgICAgIGdldFVzZXJNZWRpYTogZ2V0VXNlck1lZGlhLFxuICAgICAgICBsb2dnZXJOYW1lOiBERUZBVUxUX0xPR0dFUl9OQU1FLFxuICAgICAgICBsb2dMZXZlbDogREVGQVVMVF9MT0dfTEVWRUwsXG4gICAgICAgIExvY2FsQXVkaW9UcmFjazogTG9jYWxBdWRpb1RyYWNrLFxuICAgICAgICBMb2NhbERhdGFUcmFjazogTG9jYWxEYXRhVHJhY2ssXG4gICAgICAgIExvY2FsVmlkZW9UcmFjazogTG9jYWxWaWRlb1RyYWNrLFxuICAgICAgICBNZWRpYVN0cmVhbVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgICBMb2c6IExvZyxcbiAgICAgICAgdmlkZW86IGlzQXVkaW9WaWRlb0Fic2VudFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHZhciBsb2dDb21wb25lbnROYW1lID0gXCJbY3JlYXRlTG9jYWxUcmFja3MgI1wiICsgKytjcmVhdGVMb2NhbFRyYWNrQ2FsbHMgKyBcIl1cIjtcbiAgICB2YXIgbG9nTGV2ZWxzID0gYnVpbGRMb2dMZXZlbHMob3B0aW9ucy5sb2dMZXZlbCk7XG4gICAgdmFyIGxvZyA9IG5ldyBvcHRpb25zLkxvZygnZGVmYXVsdCcsIGxvZ0NvbXBvbmVudE5hbWUsIGxvZ0xldmVscywgb3B0aW9ucy5sb2dnZXJOYW1lKTtcbiAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBUaGUgUm9vbSBcIm5hbWVcIiBpbiBcIm9wdGlvbnNcIiB3YXMgYmVpbmcgdXNlZFxuICAgIC8vIGFzIHRoZSBMb2NhbFRyYWNrIG5hbWUgaW4gYXNMb2NhbFRyYWNrKCkuIFNvIHdlIHBhc3MgYSBjb3B5IG9mXG4gICAgLy8gXCJvcHRpb25zXCIgd2l0aG91dCB0aGUgXCJuYW1lXCIuXG4gICAgdmFyIGxvY2FsVHJhY2tPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGxvZzogbG9nIH0sIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSBsb2NhbFRyYWNrT3B0aW9ucy5uYW1lO1xuICAgIGlmIChvcHRpb25zLmF1ZGlvID09PSBmYWxzZSAmJiBvcHRpb25zLnZpZGVvID09PSBmYWxzZSkge1xuICAgICAgICBsb2cuaW5mbygnTmVpdGhlciBhdWRpbyBub3IgdmlkZW8gcmVxdWVzdGVkLCBzbyByZXR1cm5pbmcgZW1wdHkgTG9jYWxUcmFja3MnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRyYWNrcykge1xuICAgICAgICBsb2cuaW5mbygnQWRkaW5nIHVzZXItcHJvdmlkZWQgTG9jYWxUcmFja3MnKTtcbiAgICAgICAgbG9nLmRlYnVnKCdMb2NhbFRyYWNrczonLCBvcHRpb25zLnRyYWNrcyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3B0aW9ucy50cmFja3MpO1xuICAgIH1cbiAgICB2YXIgZXh0cmFMb2NhbFRyYWNrT3B0aW9ucyA9IHtcbiAgICAgICAgYXVkaW86IG9wdGlvbnMuYXVkaW8gJiYgb3B0aW9ucy5hdWRpby5uYW1lXG4gICAgICAgICAgICA/IHsgbmFtZTogb3B0aW9ucy5hdWRpby5uYW1lIH1cbiAgICAgICAgICAgIDoge30sXG4gICAgICAgIHZpZGVvOiBvcHRpb25zLnZpZGVvICYmIG9wdGlvbnMudmlkZW8ubmFtZVxuICAgICAgICAgICAgPyB7IG5hbWU6IG9wdGlvbnMudmlkZW8ubmFtZSB9XG4gICAgICAgICAgICA6IHt9XG4gICAgfTtcbiAgICBleHRyYUxvY2FsVHJhY2tPcHRpb25zLmF1ZGlvLmlzQ3JlYXRlZEJ5Q3JlYXRlTG9jYWxUcmFja3MgPSB0cnVlO1xuICAgIGV4dHJhTG9jYWxUcmFja09wdGlvbnMudmlkZW8uaXNDcmVhdGVkQnlDcmVhdGVMb2NhbFRyYWNrcyA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMuYXVkaW8gJiYgdHlwZW9mIG9wdGlvbnMuYXVkaW8ud29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTYgPT09ICdib29sZWFuJykge1xuICAgICAgICBleHRyYUxvY2FsVHJhY2tPcHRpb25zLmF1ZGlvLndvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2ID0gb3B0aW9ucy5hdWRpby53b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudmlkZW8gJiYgdHlwZW9mIG9wdGlvbnMudmlkZW8ud29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTYgPT09ICdib29sZWFuJykge1xuICAgICAgICBleHRyYUxvY2FsVHJhY2tPcHRpb25zLnZpZGVvLndvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2ID0gb3B0aW9ucy52aWRlby53b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuYXVkaW8ubmFtZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudmlkZW8pIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMudmlkZW8ubmFtZTtcbiAgICB9XG4gICAgdmFyIG1lZGlhU3RyZWFtQ29uc3RyYWludHMgPSB7XG4gICAgICAgIGF1ZGlvOiBvcHRpb25zLmF1ZGlvLFxuICAgICAgICB2aWRlbzogb3B0aW9ucy52aWRlb1xuICAgIH07XG4gICAgdmFyIHdvcmthcm91bmRXZWJLaXRCdWcxODA3NDggPSBvcHRpb25zLmF1ZGlvICYmIG9wdGlvbnMuYXVkaW8ud29ya2Fyb3VuZFdlYktpdEJ1ZzE4MDc0ODtcbiAgICB2YXIgbWVkaWFTdHJlYW1Qcm9taXNlID0gd29ya2Fyb3VuZFdlYktpdEJ1ZzE4MDc0OFxuICAgICAgICA/IHdvcmthcm91bmQxODA3NDgobG9nLCBvcHRpb25zLmdldFVzZXJNZWRpYSwgbWVkaWFTdHJlYW1Db25zdHJhaW50cylcbiAgICAgICAgOiBvcHRpb25zLmdldFVzZXJNZWRpYShtZWRpYVN0cmVhbUNvbnN0cmFpbnRzKTtcbiAgICByZXR1cm4gbWVkaWFTdHJlYW1Qcm9taXNlLnRoZW4oZnVuY3Rpb24gKG1lZGlhU3RyZWFtKSB7XG4gICAgICAgIHZhciBtZWRpYVN0cmVhbVRyYWNrcyA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuY29uY2F0KG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCkpO1xuICAgICAgICBsb2cuaW5mbygnQ2FsbCB0byBnZXRVc2VyTWVkaWEgc3VjY2Vzc2Z1bDsgZ290IE1lZGlhU3RyZWFtVHJhY2tzOicsIG1lZGlhU3RyZWFtVHJhY2tzKTtcbiAgICAgICAgcmV0dXJuIG1lZGlhU3RyZWFtVHJhY2tzLm1hcChmdW5jdGlvbiAobWVkaWFTdHJlYW1UcmFjaykgeyByZXR1cm4gYXNMb2NhbFRyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIE9iamVjdC5hc3NpZ24oZXh0cmFMb2NhbFRyYWNrT3B0aW9uc1ttZWRpYVN0cmVhbVRyYWNrLmtpbmRdLCBsb2NhbFRyYWNrT3B0aW9ucykpOyB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgbG9nLndhcm4oJ0NhbGwgdG8gZ2V0VXNlck1lZGlhIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xufVxuLyoqXG4gKiB7QGxpbmsgY3JlYXRlTG9jYWxUcmFja3N9IG9wdGlvbnNcbiAqIEB0eXBlZGVmIHtvYmplY3R9IENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufENyZWF0ZUxvY2FsVHJhY2tPcHRpb25zfSBbYXVkaW89dHJ1ZV0gLSBXaGV0aGVyIG9yIG5vdCB0b1xuICogICBnZXQgbG9jYWwgYXVkaW8gd2l0aCA8Y29kZT5nZXRVc2VyTWVkaWE8L2NvZGU+IHdoZW4gPGNvZGU+dHJhY2tzPC9jb2RlPlxuICogICBhcmUgbm90IHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtMb2dMZXZlbHxMb2dMZXZlbHN9IFtsb2dMZXZlbD0nd2FybiddIC0gPGNvZGU+KGRlcHJlY2F0ZWQ6IHVzZSBbVmlkZW8uTG9nZ2VyXShtb2R1bGUtdHdpbGlvLXZpZGVvLmh0bWwpIGluc3RlYWQuXG4gKiAgIFNlZSBbZXhhbXBsZXNdKG1vZHVsZS10d2lsaW8tdmlkZW8uaHRtbCMuY29ubmVjdCkgZm9yIGRldGFpbHMpPC9jb2RlPlxuICogICBTZXQgdGhlIGRlZmF1bHQgbG9nIHZlcmJvc2l0eVxuICogICBvZiBsb2dnaW5nLiBQYXNzaW5nIGEge0BsaW5rIExvZ0xldmVsfSBzdHJpbmcgd2lsbCB1c2UgdGhlIHNhbWVcbiAqICAgbGV2ZWwgZm9yIGFsbCBjb21wb25lbnRzLiBQYXNzIGEge0BsaW5rIExvZ0xldmVsc30gdG8gc2V0IHNwZWNpZmljIGxvZ1xuICogICBsZXZlbHMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xvZ2dlck5hbWU9J3R3aWxpby12aWRlbyddIC0gVGhlIG5hbWUgb2YgdGhlIGxvZ2dlci4gVXNlIHRoaXMgbmFtZSB3aGVuIGFjY2Vzc2luZyB0aGUgbG9nZ2VyIHVzZWQgYnkgdGhlIFNESy5cbiAqICAgU2VlIFtleGFtcGxlc10obW9kdWxlLXR3aWxpby12aWRlby5odG1sIy5jb25uZWN0KSBmb3IgZGV0YWlscy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnxDcmVhdGVMb2NhbFRyYWNrT3B0aW9uc30gW3ZpZGVvPXRydWVdIC0gV2hldGhlciBvciBub3QgdG9cbiAqICAgZ2V0IGxvY2FsIHZpZGVvIHdpdGggPGNvZGU+Z2V0VXNlck1lZGlhPC9jb2RlPiB3aGVuIDxjb2RlPnRyYWNrczwvY29kZT5cbiAqICAgYXJlIG5vdCBwcm92aWRlZC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVMb2NhbFRyYWNrcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZWxvY2FsdHJhY2tzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgRGF0YVRyYWNrVHJhbnNjZWl2ZXIgPSByZXF1aXJlKCcuL3RyYW5zY2VpdmVyJyk7XG52YXIgRGF0YVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0Jyk7XG4vKipcbiAqIEEge0BsaW5rIERhdGFUcmFja1JlY2VpdmVyfSByZXByZXNlbnRzIGEge0BsaW5rIERhdGFUcmFja1RyYW5zY2VpdmVyfSBvdmVyXG4gKiB3aGljaCBkYXRhIGNhbiBiZSByZWNlaXZlZC4gSW50ZXJuYWxseSwgaXQgdXNlcnMgYSBzaW5nbGUgUlRDRGF0YUNoYW5uZWwgdG9cbiAqIHJlY2VpdmUgZGF0YS5cbiAqIEBleHRlbmRzIERhdGFUcmFja1RyYW5zY2VpdmVyXG4gKiBAZW1pdHMgRGF0YVRyYWNrUmVjZWl2ZXIjbWVzc2FnZVxuICogQGVtaXRzIERhdGFUcmFja1JlY2VpdmVyI2Nsb3NlXG4gKi9cbnZhciBEYXRhVHJhY2tSZWNlaXZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0YVRyYWNrUmVjZWl2ZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIHtAbGluayBEYXRhVHJhY2tSZWNlaXZlcn0uXG4gICAgICogQHBhcmFtIHtSVENEYXRhQ2hhbm5lbH0gZGF0YUNoYW5uZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhVHJhY2tSZWNlaXZlcihkYXRhQ2hhbm5lbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkYXRhQ2hhbm5lbC5sYWJlbCwgZGF0YUNoYW5uZWwubWF4UGFja2V0TGlmZVRpbWUsIGRhdGFDaGFubmVsLm1heFJldHJhbnNtaXRzLCBkYXRhQ2hhbm5lbC5vcmRlcmVkKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2RhdGFDaGFubmVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFDaGFubmVsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBJbiBGaXJlZm94LCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgXCJiaW5hcnlUeXBlXCIgaXMgXCJibG9iXCIuXG4gICAgICAgIC8vIFNvLCB3ZSBzZXQgaXQgdG8gXCJhcnJheWJ1ZmZlclwiIHRvIGVuc3VyZSB0aGF0IGl0IGlzIGNvbnNpc3RlbnQgd2l0aCBDaHJvbWVcbiAgICAgICAgLy8gYW5kIFNhZmFyaS5cbiAgICAgICAgZGF0YUNoYW5uZWwuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIGRhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ21lc3NhZ2UnLCBldmVudC5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGF0YVRyYWNrUmVjZWl2ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc3RvcC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEge0BsaW5rIERhdGFUcmFuc3BvcnR9IGZyb20gdGhlIHtAbGluayBEYXRhVHJhY2tSZWNlaXZlcn0uXG4gICAgICogQHJldHVybnMge0RhdGFUcmFuc3BvcnR9XG4gICAgICovXG4gICAgRGF0YVRyYWNrUmVjZWl2ZXIucHJvdG90eXBlLnRvRGF0YVRyYW5zcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhVHJhbnNwb3J0KHRoaXMuX2RhdGFDaGFubmVsKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRhVHJhY2tSZWNlaXZlcjtcbn0oRGF0YVRyYWNrVHJhbnNjZWl2ZXIpKTtcbi8qKlxuICogQGV2ZW50IERhdGFUcmFja1JlY2VpdmVyI21lc3NhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5QnVmZmVyfSBkYXRhXG4gKi9cbi8qKlxuICogQGV2ZW50IERhdGFUcmFja1JlY2VpdmVyI2Nsb3NlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gRGF0YVRyYWNrUmVjZWl2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNlaXZlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIERhdGFUcmFja1RyYW5zY2VpdmVyID0gcmVxdWlyZSgnLi90cmFuc2NlaXZlcicpO1xudmFyIG1ha2VVVUlEID0gcmVxdWlyZSgnLi4vdXRpbCcpLm1ha2VVVUlEO1xuLyoqXG4gKiBBIHtAbGluayBEYXRhVHJhY2tTZW5kZXJ9IHJlcHJlc2VudHMgYSB7QGxpbmsgRGF0YVRyYWNrVHJhbnNjZWl2ZXJ9IG92ZXJcbiAqIHdoaWNoIGRhdGEgY2FuIGJlIHNlbnQuIEludGVybmFsbHksIGl0IHVzZXMgYSBjb2xsZWN0aW9uIG9mIFJUQ0RhdGFDaGFubmVsc1xuICogdG8gc2VuZCBkYXRhLlxuICogQGV4dGVuZHMgRGF0YVRyYWNrVHJhbnNjZWl2ZXJcbiAqL1xudmFyIERhdGFUcmFja1NlbmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0YVRyYWNrU2VuZGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBEYXRhVHJhY2tTZW5kZXJ9LlxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gbWF4UGFja2V0TGlmZVRpbWVcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IG1heFJldHJhbnNtaXRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvcmRlcmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0YVRyYWNrU2VuZGVyKG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbXRpcywgb3JkZXJlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtYWtlVVVJRCgpLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc210aXMsIG9yZGVyZWQpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfY2xvbmVzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kYXRhQ2hhbm5lbHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFNldCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNsb25lZCB7QGxpbmsgRGF0YVRyYWNrU2VuZGVyfS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIERhdGFUcmFja1NlbmRlci5wcm90b3R5cGUuX2FkZENsb25lID0gZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgIHRoaXMuX2Nsb25lcy5hZGQoY2xvbmUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY2xvbmVkIHtAbGluayBEYXRhVHJhY2tTZW5kZXJ9LlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIERhdGFUcmFja1NlbmRlci5wcm90b3R5cGUucmVtb3ZlQ2xvbmUgPSBmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgdGhpcy5fY2xvbmVzLmRlbGV0ZShjbG9uZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gUlRDRGF0YUNoYW5uZWwgdG8gdGhlIHtAbGluayBEYXRhVHJhY2tTZW5kZXJ9LlxuICAgICAqIEBwYXJhbSB7UlRDRGF0YUNoYW5uZWx9IGRhdGFDaGFubmVsXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgRGF0YVRyYWNrU2VuZGVyLnByb3RvdHlwZS5hZGREYXRhQ2hhbm5lbCA9IGZ1bmN0aW9uIChkYXRhQ2hhbm5lbCkge1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbHMuYWRkKGRhdGFDaGFubmVsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcge0BsaW5rIERhdGFUcmFja1NlbmRlcn0uIEFueSBtZXNzYWdlIHNlbnQgb3ZlciB0aGlzXG4gICAgICoge0BsaW5rIERhdGFUcmFja1NlbmRlcn0gd2lsbCBhbHNvIGJlIHNlbnQgb3ZlciB0aGUgY2xvbmUuIFdoZW5ldmVyIHRoaXNcbiAgICAgKiB7QGxpbmsgRGF0YVRyYWNrU2VuZGVyfSBpcyBzdG9wcGVkLCBzbyB0byB3aWxsIHRoZSBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7RGF0YVRyYWNrU2VuZGVyfVxuICAgICAqL1xuICAgIERhdGFUcmFja1NlbmRlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjbG9uZSA9IG5ldyBEYXRhVHJhY2tTZW5kZXIodGhpcy5tYXhQYWNrZXRMaWZlVGltZSwgdGhpcy5tYXhSZXRyYW5zbWl0cywgdGhpcy5vcmRlcmVkKTtcbiAgICAgICAgdGhpcy5fYWRkQ2xvbmUoY2xvbmUpO1xuICAgICAgICBjbG9uZS5vbmNlKCdzdG9wcGVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVtb3ZlQ2xvbmUoY2xvbmUpOyB9KTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIFJUQ0RhdGFDaGFubmVsIGZyb20gdGhlIHtAbGluayBEYXRhVHJhY2tTZW5kZXJ9LlxuICAgICAqIEBwYXJhbSB7UlRDRGF0YUNoYW5uZWx9IGRhdGFDaGFubmVsXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgRGF0YVRyYWNrU2VuZGVyLnByb3RvdHlwZS5yZW1vdmVEYXRhQ2hhbm5lbCA9IGZ1bmN0aW9uIChkYXRhQ2hhbm5lbCkge1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbHMuZGVsZXRlKGRhdGFDaGFubmVsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgb3ZlciB0aGUge0BsaW5rIERhdGFUcmFja1NlbmRlcn0uIEludGVybmFsbHksIHRoaXMgY2FsbHNcbiAgICAgKiA8Y29kZT5zZW5kPC9jb2RlPiBvdmVyIGVhY2ggb2YgdGhlIHVuZGVybHlpbmcgUlRDRGF0YUNoYW5uZWxzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEJsb2J8QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBkYXRhXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgRGF0YVRyYWNrU2VuZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWxzLmZvckVhY2goZnVuY3Rpb24gKGRhdGFDaGFubmVsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGFDaGFubmVsLnNlbmQoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNsb25lLnNlbmQoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBEYXRhVHJhY2tTZW5kZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVscy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhQ2hhbm5lbCkgeyByZXR1cm4gZGF0YUNoYW5uZWwuY2xvc2UoKTsgfSk7XG4gICAgICAgIHRoaXMuX2Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkgeyByZXR1cm4gY2xvbmUuc3RvcCgpOyB9KTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zdG9wLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YVRyYWNrU2VuZGVyO1xufShEYXRhVHJhY2tUcmFuc2NlaXZlcikpO1xubW9kdWxlLmV4cG9ydHMgPSBEYXRhVHJhY2tTZW5kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW5kZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBUcmFja1RyYW5zY2VpdmVyID0gcmVxdWlyZSgnLi4vdHJhbnNjZWl2ZXInKTtcbi8qKlxuICogQSB7QGxpbmsgRGF0YVRyYWNrVHJhbnNjZWl2ZXJ9IHJlcHJlc2VudHMgZWl0aGVyIG9uZSBvciBtb3JlIGxvY2FsXG4gKiBSVENEYXRhQ2hhbm5lbHMgb3IgYSBzaW5nbGUgcmVtb3RlIFJUQ0RhdGFDaGFubmVsLiBJdCBjYW4gYmUgdXNlZCB0byBzZW5kIG9yXG4gKiByZWNlaXZlIGRhdGEuXG4gKiBAZXh0ZW5kcyBUcmFja1RyYW5zY2VpdmVyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBraW5kIC0gXCJkYXRhXCJcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gbWF4UGFja2V0TGlmZVRpbWVcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gbWF4UmV0cmFuc21pdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3JkZXJlZFxuICovXG52YXIgRGF0YVRyYWNrVHJhbnNjZWl2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERhdGFUcmFja1RyYW5zY2VpdmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBEYXRhVHJhY2tUcmFuc2NlaXZlcn0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBtYXhQYWNrZXRMaWZlVGltZVxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gbWF4UmV0cmFuc21pdHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9yZGVyZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhVHJhY2tUcmFuc2NlaXZlcihpZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBvcmRlcmVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGlkLCAnZGF0YScpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1heFBhY2tldExpZmVUaW1lXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtYXhSZXRyYW5zbWl0c1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9yZGVyZWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBvcmRlcmVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBEYXRhVHJhY2tUcmFuc2NlaXZlcjtcbn0oVHJhY2tUcmFuc2NlaXZlcikpO1xubW9kdWxlLmV4cG9ydHMgPSBEYXRhVHJhY2tUcmFuc2NlaXZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zY2VpdmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuLyoqXG4gKiBAY2xhc3NkZXNjIEEge0BsaW5rIERhdGFUcmFuc3BvcnR9IGltcGxlbWVudHMge0BsaW5rIE1lZGlhU2lnbmFsaW5nVHJhbnNwb3J0fVxuICogICBpbiB0ZXJtcyBvZiBhbiBSVENEYXRhQ2hhbm5lbC5cbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQGltcGxlbWVudHMgTWVkaWFTaWduYWxpbmdUcmFuc3BvcnRcbiAqIEBlbWl0cyBEYXRhVHJhbnNwb3J0I21lc3NhZ2VcbiAqL1xudmFyIERhdGFUcmFuc3BvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERhdGFUcmFuc3BvcnQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIERhdGFUcmFuc3BvcnR9LlxuICAgICAqIEBwYXJhbSB7UlRDRGF0YUNoYW5uZWx9IGRhdGFDaGFubmVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0YVRyYW5zcG9ydChkYXRhQ2hhbm5lbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2RhdGFDaGFubmVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFDaGFubmVsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21lc3NhZ2VRdWV1ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9tZXNzYWdlUXVldWUuc3BsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIF90aGlzLl9wdWJsaXNoKG1lc3NhZ2UpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gX2EuZGF0YTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5wdWJsaXNoKHsgdHlwZTogJ3JlYWR5JyB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRGF0YVRyYW5zcG9ydC5wcm90b3R5cGUuX3B1Ymxpc2ggPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuc2VuZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggYSBtZXNzYWdlLiBSZXR1cm5zIHRydWUgaWYgY2FsbGluZyB0aGUgbWV0aG9kIHJlc3VsdGVkIGluXG4gICAgICogcHVibGlzaGluZyAob3IgZXZlbnR1YWxseSBwdWJsaXNoaW5nKSB0aGUgdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtZXNzYWdlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgRGF0YVRyYW5zcG9ydC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBkYXRhQ2hhbm5lbCA9IHRoaXMuX2RhdGFDaGFubmVsO1xuICAgICAgICBpZiAoZGF0YUNoYW5uZWwucmVhZHlTdGF0ZSA9PT0gJ2Nsb3NpbmcnIHx8IGRhdGFDaGFubmVsLnJlYWR5U3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFDaGFubmVsLnJlYWR5U3RhdGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZVF1ZXVlLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wdWJsaXNoKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRhVHJhbnNwb3J0O1xufShFdmVudEVtaXR0ZXIpKTtcbi8qKlxuICogVGhlIHtAbGluayBEYXRhVHJhbnNwb3J0fSByZWNlaXZlZCBhIG1lc3NhZ2UuXG4gKiBAZXZlbnQgRGF0YVRyYW5zcG9ydCNtZXNzYWdlXG4gKiBAcGFyYW0ge29iamVjdH0gbWVzc2FnZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFUcmFuc3BvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc3BvcnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4vKipcbiAqIHtAbGluayBFbmNvZGluZ1BhcmFtZXRlcnNJbXBsfSByZXByZXNlbnRzIGFuIG9iamVjdCB3aGljaCBub3RpZmllcyBpdHNcbiAqIGxpc3RlbmVycyBvZiBhbnkgY2hhbmdlcyBpbiB0aGUgdmFsdWVzIG9mIGl0cyBwcm9wZXJ0aWVzLlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAaW1wbGVtZW50cyBFbmNvZGluZ1BhcmFtZXRlcnNcbiAqIEBlbWl0cyBFbmNvZGluZ1BhcmFtZXRlcnNJbXBsI2NoYW5nZWRcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gbWF4QXVkaW9CaXRyYXRlXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IG1heFZpZGVvQml0cmF0ZVxuICovXG52YXIgRW5jb2RpbmdQYXJhbWV0ZXJzSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW5jb2RpbmdQYXJhbWV0ZXJzSW1wbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4ge0BsaW5rIEVuY29kaW5nUGFyYW1ldGVyc0ltcGx9LlxuICAgICAqIEBwYXJhbSB7RW5jb2RpbmdQYXJhbXRlcnN9IGVuY29kaW5nUGFyYW1ldGVycyAtIEluaXRpYWwge0BsaW5rIEVuY29kaW5nUGFyYW1ldGVyc31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbmNvZGluZ1BhcmFtZXRlcnNJbXBsKGVuY29kaW5nUGFyYW1ldGVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIG1heEF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgICAgICAgICAgIG1heFZpZGVvQml0cmF0ZTogbnVsbFxuICAgICAgICB9LCBlbmNvZGluZ1BhcmFtZXRlcnMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgbWF4QXVkaW9CaXRyYXRlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGVuY29kaW5nUGFyYW1ldGVycy5tYXhBdWRpb0JpdHJhdGUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXhWaWRlb0JpdHJhdGU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZW5jb2RpbmdQYXJhbWV0ZXJzLm1heFZpZGVvQml0cmF0ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXRyYXRlIHZhbHVlcyBpbiBhbiB7QGxpbmsgRW5jb2RpbmdQYXJhbWV0ZXJzfS5cbiAgICAgKiBAcmV0dXJucyB7RW5jb2RpbmdQYXJhbWV0ZXJzfVxuICAgICAqL1xuICAgIEVuY29kaW5nUGFyYW1ldGVyc0ltcGwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1heEF1ZGlvQml0cmF0ZTogdGhpcy5tYXhBdWRpb0JpdHJhdGUsXG4gICAgICAgICAgICBtYXhWaWRlb0JpdHJhdGU6IHRoaXMubWF4VmlkZW9CaXRyYXRlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGJpdHJhdGUgdmFsdWVzIHdpdGggdGhvc2UgaW4gdGhlIGdpdmVuIHtAbGluayBFbmNvZGluZ1BhcmFtZXRlcnN9LlxuICAgICAqIEBwYXJhbSB7RW5jb2RpbmdQYXJhbWV0ZXJzfSBlbmNvZGluZ1BhcmFtZXRlcnMgLSBUaGUgbmV3IHtAbGluayBFbmNvZGluZ1BhcmFtZXRlcnN9XG4gICAgICogQGZpcmVzIEVuY29kaW5nUGFyYW1ldGVyc0ltcGwjY2hhbmdlZFxuICAgICAqL1xuICAgIEVuY29kaW5nUGFyYW1ldGVyc0ltcGwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmNvZGluZ1BhcmFtZXRlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBtYXhBdWRpb0JpdHJhdGU6IHRoaXMubWF4QXVkaW9CaXRyYXRlLFxuICAgICAgICAgICAgbWF4VmlkZW9CaXRyYXRlOiB0aGlzLm1heFZpZGVvQml0cmF0ZVxuICAgICAgICB9LCBlbmNvZGluZ1BhcmFtZXRlcnMpO1xuICAgICAgICB2YXIgc2hvdWxkRW1pdENoYW5nZWQgPSBbXG4gICAgICAgICAgICAnbWF4QXVkaW9CaXRyYXRlJyxcbiAgICAgICAgICAgICdtYXhWaWRlb0JpdHJhdGUnXG4gICAgICAgIF0ucmVkdWNlKGZ1bmN0aW9uIChzaG91bGRFbWl0Q2hhbmdlZCwgbWF4S2luZEJpdHJhdGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpc1ttYXhLaW5kQml0cmF0ZV0gIT09IGVuY29kaW5nUGFyYW1ldGVyc1ttYXhLaW5kQml0cmF0ZV0pIHtcbiAgICAgICAgICAgICAgICBfdGhpc1ttYXhLaW5kQml0cmF0ZV0gPSBlbmNvZGluZ1BhcmFtZXRlcnNbbWF4S2luZEJpdHJhdGVdO1xuICAgICAgICAgICAgICAgIHNob3VsZEVtaXRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaG91bGRFbWl0Q2hhbmdlZDtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICBpZiAoc2hvdWxkRW1pdENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRW5jb2RpbmdQYXJhbWV0ZXJzSW1wbDtcbn0oRXZlbnRFbWl0dGVyKSk7XG4vKipcbiAqIEF0IGxlYXN0IG9uZSBvZiB0aGUge0BsaW5rIEVuY29kaW5nUGFyYW1ldGVyc0ltcGx9J3MgYml0cmF0ZSB2YWx1ZXMgY2hhbmdlZC5cbiAqIEBldmVudCBFbmNvZGluZ1BhcmFtZXRlcnNJbXBsI2NoYW5nZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBFbmNvZGluZ1BhcmFtZXRlcnNJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jb2RpbmdwYXJhbWV0ZXJzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaGlkZVByaXZhdGVBbmRDZXJ0YWluUHVibGljUHJvcGVydGllc0luQ2xhc3MgPSByZXF1aXJlKCcuL3V0aWwnKS5oaWRlUHJpdmF0ZUFuZENlcnRhaW5QdWJsaWNQcm9wZXJ0aWVzSW5DbGFzcztcbm1vZHVsZS5leHBvcnRzID0gaGlkZVByaXZhdGVBbmRDZXJ0YWluUHVibGljUHJvcGVydGllc0luQ2xhc3MoRXZlbnRFbWl0dGVyLCBbJ2RvbWFpbiddKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50ZW1pdHRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZmxpZ2h0dGVzdF8xID0gcmVxdWlyZShcIi4vcHJlZmxpZ2h0L3ByZWZsaWdodHRlc3RcIik7XG52YXIgaW50ZXJuYWxzID0ge1xuICAgIGNvbm5lY3Q6IHJlcXVpcmUoJy4vY29ubmVjdCcpLFxuICAgIGNyZWF0ZUxvY2FsQXVkaW9UcmFjazogcmVxdWlyZSgnLi9jcmVhdGVsb2NhbHRyYWNrJykuYXVkaW8sXG4gICAgY3JlYXRlTG9jYWxUcmFja3M6IHJlcXVpcmUoJy4vY3JlYXRlbG9jYWx0cmFja3MnKSxcbiAgICBjcmVhdGVMb2NhbFZpZGVvVHJhY2s6IHJlcXVpcmUoJy4vY3JlYXRlbG9jYWx0cmFjaycpLnZpZGVvLFxuICAgIGlzU3VwcG9ydGVkOiByZXF1aXJlKCcuL3V0aWwvc3VwcG9ydCcpKCksXG4gICAgdmVyc2lvbjogcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbixcbiAgICBMb2dnZXI6IHJlcXVpcmUoJy4vdmVuZG9yL2xvZ2xldmVsJyksXG4gICAgTG9jYWxBdWRpb1RyYWNrOiByZXF1aXJlKCcuL21lZGlhL3RyYWNrL2VzNScpLkxvY2FsQXVkaW9UcmFjayxcbiAgICBMb2NhbERhdGFUcmFjazogcmVxdWlyZSgnLi9tZWRpYS90cmFjay9lczUnKS5Mb2NhbERhdGFUcmFjayxcbiAgICBMb2NhbFZpZGVvVHJhY2s6IHJlcXVpcmUoJy4vbWVkaWEvdHJhY2svZXM1JykuTG9jYWxWaWRlb1RyYWNrXG59O1xuZnVuY3Rpb24gY29ubmVjdCh0b2tlbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBpbnRlcm5hbHMuY29ubmVjdCh0b2tlbiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjcmVhdGVMb2NhbEF1ZGlvVHJhY2sob3B0aW9ucykge1xuICAgIHJldHVybiBpbnRlcm5hbHMuY3JlYXRlTG9jYWxBdWRpb1RyYWNrKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9jYWxUcmFja3Mob3B0aW9ucykge1xuICAgIHJldHVybiBpbnRlcm5hbHMuY3JlYXRlTG9jYWxUcmFja3Mob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjcmVhdGVMb2NhbFZpZGVvVHJhY2sob3B0aW9ucykge1xuICAgIHJldHVybiBpbnRlcm5hbHMuY3JlYXRlTG9jYWxWaWRlb1RyYWNrKG9wdGlvbnMpO1xufVxuLyoqXG4gKiBAbW9kdWxlIHR3aWxpby12aWRlb1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc1N1cHBvcnRlZCAtIHRydWUgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBpcyBvZmZpY2lhbGx5XG4gKiAgIHN1cHBvcnRlZCBieSB0d2lsaW8tdmlkZW8uanM7IEluIHRoaXMgY29udGV4dCwgXCJzdXBwb3J0ZWRcIiBtZWFucyB0aGF0XG4gKiAgIHR3aWxpby12aWRlby5qcyBoYXMgYmVlbiBleHRlbnNpdmVseSB0ZXN0ZWQgd2l0aCB0aGlzIGJyb3dzZXI7IFRoaXNcbiAqICAgPGEgaHJlZj1cImh0dHBzOi8vd3d3LnR3aWxpby5jb20vZG9jcy92aWRlby9qYXZhc2NyaXB0I3N1cHBvcnRlZC1icm93c2Vyc1wiIHRhcmdldD1cIl9ibGFua1wiPnRhYmxlPC9hPlxuICogICBzcGVjaWZpZXMgdGhlIGxpc3Qgb2Ygb2ZmaWNpYWxseSBzdXBwb3J0ZWQgYnJvd3NlcnMuXG4gKlxuICogQHByb3BlcnR5IHtvYmplY3R9IExvZ2dlciAtIFRoZSA8YSBocmVmPVwiaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbG9nbGV2ZWxcIiB0YXJnZXQ9XCJfYmxhbmtcIj5sb2dsZXZlbDwvYT5cbiAqICAgIG1vZHVsZSB1c2VkIGJ5IHRoZSBTREsuIFVzZSB0aGlzIG9iamVjdCB0byBhY2Nlc3MgdGhlIGludGVybmFsIGxvZ2dlcnMgYW5kIHBlcmZvcm0gYWN0aW9ucyBhcyBkZWZpbmVkIGJ5IHRoZVxuICogICA8YSBocmVmPVwiaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbG9nbGV2ZWxcIiB0YXJnZXQ9XCJfYmxhbmtcIj5sb2dsZXZlbDwvYT4gQVBJcy5cbiAqICAgU2VlIFtjb25uZWN0XSgjLmNvbm5lY3QpIGZvciBleGFtcGxlcy5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmVyc2lvbiAtIGN1cnJlbnQgdmVyc2lvbiBvZiB0d2lsaW8tdmlkZW8uanMuXG4gKi9cbnZhciBpc1N1cHBvcnRlZCA9IGludGVybmFscy5pc1N1cHBvcnRlZDtcbnZhciB2ZXJzaW9uID0gaW50ZXJuYWxzLnZlcnNpb247XG52YXIgTG9nZ2VyID0gaW50ZXJuYWxzLkxvZ2dlcjtcbnZhciBMb2NhbEF1ZGlvVHJhY2sgPSBpbnRlcm5hbHMuTG9jYWxBdWRpb1RyYWNrO1xudmFyIExvY2FsVmlkZW9UcmFjayA9IGludGVybmFscy5Mb2NhbFZpZGVvVHJhY2s7XG52YXIgTG9jYWxEYXRhVHJhY2sgPSBpbnRlcm5hbHMuTG9jYWxEYXRhVHJhY2s7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb25uZWN0OiBjb25uZWN0LFxuICAgIGNyZWF0ZUxvY2FsQXVkaW9UcmFjazogY3JlYXRlTG9jYWxBdWRpb1RyYWNrLFxuICAgIGNyZWF0ZUxvY2FsVHJhY2tzOiBjcmVhdGVMb2NhbFRyYWNrcyxcbiAgICBjcmVhdGVMb2NhbFZpZGVvVHJhY2s6IGNyZWF0ZUxvY2FsVmlkZW9UcmFjayxcbiAgICBydW5QcmVmbGlnaHQ6IHByZWZsaWdodHRlc3RfMS5ydW5QcmVmbGlnaHQsXG4gICAgaXNTdXBwb3J0ZWQ6IGlzU3VwcG9ydGVkLFxuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgTG9nZ2VyOiBMb2dnZXIsXG4gICAgTG9jYWxBdWRpb1RyYWNrOiBMb2NhbEF1ZGlvVHJhY2ssXG4gICAgTG9jYWxWaWRlb1RyYWNrOiBMb2NhbFZpZGVvVHJhY2ssXG4gICAgTG9jYWxEYXRhVHJhY2s6IExvY2FsRGF0YVRyYWNrXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBNZWRpYVN0cmVhbVRyYWNrID0gcmVxdWlyZSgnQHR3aWxpby93ZWJydGMnKS5NZWRpYVN0cmVhbVRyYWNrO1xudmFyIF9hID0gcmVxdWlyZSgnLi91dGlsJyksIGFzTG9jYWxUcmFjayA9IF9hLmFzTG9jYWxUcmFjaywgYXNMb2NhbFRyYWNrUHVibGljYXRpb24gPSBfYS5hc0xvY2FsVHJhY2tQdWJsaWNhdGlvbiwgdHJhY2tDbGFzcyA9IF9hLnRyYWNrQ2xhc3M7XG52YXIgX2IgPSByZXF1aXJlKCcuL3V0aWwvY29uc3RhbnRzJyksIEUgPSBfYi50eXBlRXJyb3JzLCB0cmFja1ByaW9yaXR5ID0gX2IudHJhY2tQcmlvcml0eTtcbnZhciB2YWxpZGF0ZUxvY2FsVHJhY2sgPSByZXF1aXJlKCcuL3V0aWwvdmFsaWRhdGUnKS52YWxpZGF0ZUxvY2FsVHJhY2s7XG52YXIgX2MgPSByZXF1aXJlKCcuL21lZGlhL3RyYWNrL2VzNScpLCBMb2NhbEF1ZGlvVHJhY2sgPSBfYy5Mb2NhbEF1ZGlvVHJhY2ssIExvY2FsRGF0YVRyYWNrID0gX2MuTG9jYWxEYXRhVHJhY2ssIExvY2FsVmlkZW9UcmFjayA9IF9jLkxvY2FsVmlkZW9UcmFjaztcbnZhciBMb2NhbEF1ZGlvVHJhY2tQdWJsaWNhdGlvbiA9IHJlcXVpcmUoJy4vbWVkaWEvdHJhY2svbG9jYWxhdWRpb3RyYWNrcHVibGljYXRpb24nKTtcbnZhciBMb2NhbERhdGFUcmFja1B1YmxpY2F0aW9uID0gcmVxdWlyZSgnLi9tZWRpYS90cmFjay9sb2NhbGRhdGF0cmFja3B1YmxpY2F0aW9uJyk7XG52YXIgTG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb24gPSByZXF1aXJlKCcuL21lZGlhL3RyYWNrL2xvY2FsdmlkZW90cmFja3B1YmxpY2F0aW9uJyk7XG52YXIgUGFydGljaXBhbnQgPSByZXF1aXJlKCcuL3BhcnRpY2lwYW50Jyk7XG4vKipcbiAqIEEge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IHJlcHJlc2VudHMgdGhlIGxvY2FsIHtAbGluayBQYXJ0aWNpcGFudH0gaW4gYVxuICoge0BsaW5rIFJvb219LlxuICogQGV4dGVuZHMgUGFydGljaXBhbnRcbiAqIEBwcm9wZXJ0eSB7TWFwPFRyYWNrLlNJRCwgTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb24+fSBhdWRpb1RyYWNrcyAtXG4gKiAgICBUaGUge0BsaW5rIExvY2FsUGFydGljaXBhbnR9J3Mge0BsaW5rIExvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9ufXNcbiAqIEBwcm9wZXJ0eSB7TWFwPFRyYWNrLlNJRCwgTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvbj59IGRhdGFUcmFja3MgLVxuICogICAgVGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSdzIHtAbGluayBMb2NhbERhdGFUcmFja1B1YmxpY2F0aW9ufXNcbiAqIEBwcm9wZXJ0eSB7TWFwPFRyYWNrLlNJRCwgTG9jYWxUcmFja1B1YmxpY2F0aW9uPn0gdHJhY2tzIC1cbiAqICAgIFRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0ncyB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9ufXNcbiAqIEBwcm9wZXJ0eSB7TWFwPFRyYWNrLlNJRCwgTG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb24+fSB2aWRlb1RyYWNrcyAtXG4gKiAgICBUaGUge0BsaW5rIExvY2FsUGFydGljaXBhbnR9J3Mge0BsaW5rIExvY2FsVmlkZW9UcmFja1B1YmxpY2F0aW9ufXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaWduYWxpbmdSZWdpb24gLSBUaGUgZ2VvZ3JhcGhpY2FsIHJlZ2lvbiBvZiB0aGVcbiAqICAgICBzaWduYWxpbmcgZWRnZSB0aGUge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IGlzIGNvbm5lY3RlZCB0by5cbiAqXG4gKiBAZW1pdHMgUmVtb3RlUGFydGljaXBhbnQjcmVjb25uZWN0ZWRcbiAqIEBlbWl0cyBSZW1vdGVQYXJ0aWNpcGFudCNyZWNvbm5lY3RpbmdcbiAqIEBlbWl0cyBMb2NhbFBhcnRpY2lwYW50I3RyYWNrRGltZW5zaW9uc0NoYW5nZWRcbiAqIEBlbWl0cyBMb2NhbFBhcnRpY2lwYW50I3RyYWNrRGlzYWJsZWRcbiAqIEBlbWl0cyBMb2NhbFBhcnRpY2lwYW50I3RyYWNrRW5hYmxlZFxuICogQGVtaXRzIExvY2FsUGFydGljaXBhbnQjdHJhY2tQdWJsaWNhdGlvbkZhaWxlZFxuICogQGVtaXRzIExvY2FsUGFydGljaXBhbnQjdHJhY2tQdWJsaXNoZWRcbiAqIEBlbWl0cyBMb2NhbFBhcnRpY2lwYW50I3RyYWNrU3RhcnRlZFxuICogQGVtaXRzIExvY2FsUGFydGljaXBhbnQjdHJhY2tTdG9wcGVkXG4gKi9cbnZhciBMb2NhbFBhcnRpY2lwYW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhbFBhcnRpY2lwYW50LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fS5cbiAgICAgKiBAcGFyYW0ge1BhcnRpY2lwYW50U2lnbmFsaW5nfSBzaWduYWxpbmdcbiAgICAgKiBAcGFyYW0ge0FycmF5PExvY2FsVHJhY2s+fSBsb2NhbFRyYWNrc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9jYWxQYXJ0aWNpcGFudChzaWduYWxpbmcsIGxvY2FsVHJhY2tzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIExvY2FsQXVkaW9UcmFjazogTG9jYWxBdWRpb1RyYWNrLFxuICAgICAgICAgICAgTG9jYWxWaWRlb1RyYWNrOiBMb2NhbFZpZGVvVHJhY2ssXG4gICAgICAgICAgICBMb2NhbERhdGFUcmFjazogTG9jYWxEYXRhVHJhY2ssXG4gICAgICAgICAgICBNZWRpYVN0cmVhbVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgICAgICAgTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb246IExvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9uLFxuICAgICAgICAgICAgTG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb246IExvY2FsVmlkZW9UcmFja1B1YmxpY2F0aW9uLFxuICAgICAgICAgICAgTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvbjogTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvbixcbiAgICAgICAgICAgIHNob3VsZFN0b3BMb2NhbFRyYWNrczogZmFsc2UsXG4gICAgICAgICAgICB0cmFja3M6IGxvY2FsVHJhY2tzXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgdHJhY2tzVG9TdG9wID0gb3B0aW9ucy5zaG91bGRTdG9wTG9jYWxUcmFja3NcbiAgICAgICAgICAgID8gbmV3IFNldChsb2NhbFRyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKGxvY2FsVHJhY2spIHsgcmV0dXJuIGxvY2FsVHJhY2sua2luZCAhPT0gJ2RhdGEnOyB9KSlcbiAgICAgICAgICAgIDogbmV3IFNldCgpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNpZ25hbGluZywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9ldmVudE9ic2VydmVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuZXZlbnRPYnNlcnZlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9Mb2NhbEF1ZGlvVHJhY2s6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5Mb2NhbEF1ZGlvVHJhY2tcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfTG9jYWxEYXRhVHJhY2s6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5Mb2NhbERhdGFUcmFja1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9Mb2NhbFZpZGVvVHJhY2s6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5Mb2NhbFZpZGVvVHJhY2tcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfTWVkaWFTdHJlYW1UcmFjazoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLk1lZGlhU3RyZWFtVHJhY2tcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5Mb2NhbEF1ZGlvVHJhY2tQdWJsaWNhdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9Mb2NhbERhdGFUcmFja1B1YmxpY2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9Mb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLkxvY2FsVmlkZW9UcmFja1B1YmxpY2F0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RyYWNrc1RvU3RvcDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0cmFja3NUb1N0b3BcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWduYWxpbmdSZWdpb246IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsaW5nLnNpZ25hbGluZ1JlZ2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5faGFuZGxlVHJhY2tTaWduYWxpbmdFdmVudHMoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TG9jYWxUcmFja30gdHJhY2tcbiAgICAgKiBAcGFyYW0ge1RyYWNrLklEfSBpZFxuICAgICAqIEBwYXJhbSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5XG4gICAgICogQHJldHVybnMgez9Mb2NhbFRyYWNrfVxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnQucHJvdG90eXBlLl9hZGRUcmFjayA9IGZ1bmN0aW9uICh0cmFjaywgaWQsIHByaW9yaXR5KSB7XG4gICAgICAgIHZhciBhZGRlZFRyYWNrID0gX3N1cGVyLnByb3RvdHlwZS5fYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjaywgaWQpO1xuICAgICAgICBpZiAoYWRkZWRUcmFjayAmJiB0aGlzLnN0YXRlICE9PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgdGhpcy5fYWRkTG9jYWxUcmFjayh0cmFjaywgcHJpb3JpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRlZFRyYWNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0xvY2FsVHJhY2t9IHRyYWNrXG4gICAgICogQHBhcmFtIHtUcmFjay5Qcmlvcml0eX0gcHJpb3JpdHlcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50LnByb3RvdHlwZS5fYWRkTG9jYWxUcmFjayA9IGZ1bmN0aW9uICh0cmFjaywgcHJpb3JpdHkpIHtcbiAgICAgICAgdGhpcy5fc2lnbmFsaW5nLmFkZFRyYWNrKHRyYWNrLl90cmFja1NlbmRlciwgdHJhY2submFtZSwgcHJpb3JpdHkpO1xuICAgICAgICB0aGlzLl9sb2cuaW5mbyhcIkFkZGVkIGEgbmV3IFwiICsgdHJhY2tDbGFzcyh0cmFjaywgdHJ1ZSkgKyBcIjpcIiwgdHJhY2suaWQpO1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcodHJhY2tDbGFzcyh0cmFjaywgdHJ1ZSkgKyBcIjpcIiwgdHJhY2spO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0xvY2FsVHJhY2t9IHRyYWNrXG4gICAgICogQHBhcmFtIHtUcmFjay5JRH0gaWRcbiAgICAgKiBAcmV0dXJucyB7P0xvY2FsVHJhY2t9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudC5wcm90b3R5cGUuX3JlbW92ZVRyYWNrID0gZnVuY3Rpb24gKHRyYWNrLCBpZCkge1xuICAgICAgICB2YXIgcmVtb3ZlZFRyYWNrID0gX3N1cGVyLnByb3RvdHlwZS5fcmVtb3ZlVHJhY2suY2FsbCh0aGlzLCB0cmFjaywgaWQpO1xuICAgICAgICBpZiAocmVtb3ZlZFRyYWNrICYmIHRoaXMuc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWxpbmcucmVtb3ZlVHJhY2sodHJhY2suX3RyYWNrU2VuZGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5pbmZvKFwiUmVtb3ZlZCBhIFwiICsgdHJhY2tDbGFzcyh0cmFjaywgdHJ1ZSkgKyBcIjpcIiwgdHJhY2suaWQpO1xuICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKHRyYWNrQ2xhc3ModHJhY2ssIHRydWUpICsgXCI6XCIsIHRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlZFRyYWNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB7QGxpbmsgTG9jYWxUcmFja30gZXZlbnRzIHRvIHJlLWVtaXQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8c3RyaW5nPj59IGV2ZW50c1xuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnQucHJvdG90eXBlLl9nZXRUcmFja0V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX2dldFRyYWNrRXZlbnRzLmNhbGwodGhpcykuY29uY2F0KFtcbiAgICAgICAgICAgIFsnZGlzYWJsZWQnLCAndHJhY2tEaXNhYmxlZCddLFxuICAgICAgICAgICAgWydlbmFibGVkJywgJ3RyYWNrRW5hYmxlZCddLFxuICAgICAgICAgICAgWydzdG9wcGVkJywgJ3RyYWNrU3RvcHBlZCddXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgTG9jYWxQYXJ0aWNpcGFudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltMb2NhbFBhcnRpY2lwYW50ICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyAodGhpcy5zaWQgPyBcIjogXCIgKyB0aGlzLnNpZCA6ICcnKSArIFwiXVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50LnByb3RvdHlwZS5faGFuZGxlVHJhY2tTaWduYWxpbmdFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaWduYWxpbmcgPSB0aGlzLl9zaWduYWxpbmc7XG4gICAgICAgIGZ1bmN0aW9uIGxvY2FsVHJhY2tEaXNhYmxlZChsb2NhbFRyYWNrKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tTaWduYWxpbmcgPSBzaWduYWxpbmcuZ2V0UHVibGljYXRpb24obG9jYWxUcmFjay5fdHJhY2tTZW5kZXIpO1xuICAgICAgICAgICAgaWYgKHRyYWNrU2lnbmFsaW5nKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tTaWduYWxpbmcuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIkRpc2FibGVkIHRoZSBcIiArIHRyYWNrQ2xhc3MobG9jYWxUcmFjaywgdHJ1ZSkgKyBcIjpcIiwgbG9jYWxUcmFjay5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9jYWxUcmFja0VuYWJsZWQobG9jYWxUcmFjaykge1xuICAgICAgICAgICAgdmFyIHRyYWNrU2lnbmFsaW5nID0gc2lnbmFsaW5nLmdldFB1YmxpY2F0aW9uKGxvY2FsVHJhY2suX3RyYWNrU2VuZGVyKTtcbiAgICAgICAgICAgIGlmICh0cmFja1NpZ25hbGluZykge1xuICAgICAgICAgICAgICAgIHRyYWNrU2lnbmFsaW5nLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIkVuYWJsZWQgdGhlIFwiICsgdHJhY2tDbGFzcyhsb2NhbFRyYWNrLCB0cnVlKSArIFwiOlwiLCBsb2NhbFRyYWNrLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb2NhbFRyYWNrU3RvcHBlZChsb2NhbFRyYWNrKSB7XG4gICAgICAgICAgICAvLyBOT1RFKG1yb2JlcnRzKTogV2Ugc2hvdWxkbid0IG5lZWQgdG8gY2hlY2sgZm9yIGBzdG9wYCwgc2luY2UgRGF0YVRyYWNrc1xuICAgICAgICAgICAgLy8gZG8gbm90IGVtaXQgXCJzdG9wcGVkXCIuXG4gICAgICAgICAgICB2YXIgdHJhY2tTaWduYWxpbmcgPSBzaWduYWxpbmcuZ2V0UHVibGljYXRpb24obG9jYWxUcmFjay5fdHJhY2tTZW5kZXIpO1xuICAgICAgICAgICAgaWYgKHRyYWNrU2lnbmFsaW5nKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tTaWduYWxpbmcuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYWNrU2lnbmFsaW5nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub24oJ3RyYWNrRGlzYWJsZWQnLCBsb2NhbFRyYWNrRGlzYWJsZWQpO1xuICAgICAgICB0aGlzLm9uKCd0cmFja0VuYWJsZWQnLCBsb2NhbFRyYWNrRW5hYmxlZCk7XG4gICAgICAgIHRoaXMub24oJ3RyYWNrU3RvcHBlZCcsIGxvY2FsVHJhY2tTdG9wcGVkKTtcbiAgICAgICAgdGhpcy5fdHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICBfdGhpcy5fYWRkTG9jYWxUcmFjayh0cmFjaywgdHJhY2tQcmlvcml0eS5QUklPUklUWV9TVEFOREFSRCk7XG4gICAgICAgICAgICBfdGhpcy5fZ2V0T3JDcmVhdGVMb2NhbFRyYWNrUHVibGljYXRpb24odHJhY2spLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEp1c3QgbG9nIGEgd2FybmluZyBmb3Igbm93LlxuICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiRmFpbGVkIHRvIGdldCBvciBjcmVhdGUgTG9jYWxUcmFja1B1YmxpY2F0aW9uIGZvciBcIiArIHRyYWNrICsgXCI6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzaWduYWxpbmcub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKCdUcmFuc2l0aW9uZWQgdG8gc3RhdGU6Jywgc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZygnUmVtb3ZpbmcgTG9jYWxUcmFjayBldmVudCBsaXN0ZW5lcnMnKTtcbiAgICAgICAgICAgICAgICBzaWduYWxpbmcucmVtb3ZlTGlzdGVuZXIoJ3N0YXRlQ2hhbmdlZCcsIHN0YXRlQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndHJhY2tEaXNhYmxlZCcsIGxvY2FsVHJhY2tEaXNhYmxlZCk7XG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndHJhY2tFbmFibGVkJywgbG9jYWxUcmFja0VuYWJsZWQpO1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3RyYWNrU3RvcHBlZCcsIGxvY2FsVHJhY2tTdG9wcGVkKTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBSZW1vdmUgdGhlIHN0YWxlIE1lZGlhVHJhY2tTZW5kZXIgY2xvbmVzIHNvIHRoYXQgd2VcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgY2FsbCByZXBsYWNlVHJhY2soKSBvbiB0aGVpciBSVENSdHBTZW5kZXJzLlxuICAgICAgICAgICAgICAgIHNlbGYuX3RyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2tTaWduYWxpbmcgPSBsb2NhbFRyYWNrU3RvcHBlZCh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja1NpZ25hbGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suX3RyYWNrU2VuZGVyLnJlbW92ZUNsb25lKHRyYWNrU2lnbmFsaW5nLl90cmFja1RyYW5zY2VpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiTG9jYWxQYXJ0aWNpcGFudCBkaXNjb25uZWN0ZWQuIFN0b3BwaW5nIFwiICsgc2VsZi5fdHJhY2tzVG9TdG9wLnNpemUgKyBcIiBhdXRvbWF0aWNhbGx5LWFjcXVpcmVkIExvY2FsVHJhY2tzXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuX3RyYWNrc1RvU3RvcC5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBBbnkgdHJhbnNpdGlvbiB0byBcImNvbm5lY3RlZFwiIGhlcmUgaXMgYSByZXN1bHQgb2ZcbiAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIHNpZ25hbGluZyByZWNvbm5lY3Rpb24sIGFuZCBub3QgYSBmaXJzdC10aW1lIGVzdGFibGlzaG1lbnRcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgbG9nLmluZm8oJ3JlY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IGBzdGF0ZUNoYW5nZWRgIGNhbiBnZXQgZW1pdHRlZCB3aXRoIFN0YXRlTWFjaGluZSBsb2NrZWQuXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHNpZ25hbCAgcHVibGljIGV2ZW50cyBzeW5jaHJvbm91c2x5IHdpdGggbG9jayBoZWxkLlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5lbWl0KCdyZWNvbm5lY3RlZCcpOyB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TG9jYWxUcmFja30gbG9jYWxUcmFja1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbj59XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudC5wcm90b3R5cGUuX2dldE9yQ3JlYXRlTG9jYWxUcmFja1B1YmxpY2F0aW9uID0gZnVuY3Rpb24gKGxvY2FsVHJhY2spIHtcbiAgICAgICAgdmFyIGxvY2FsVHJhY2tQdWJsaWNhdGlvbiA9IGdldFRyYWNrUHVibGljYXRpb24odGhpcy50cmFja3MsIGxvY2FsVHJhY2spO1xuICAgICAgICBpZiAobG9jYWxUcmFja1B1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxvY2FsVHJhY2tQdWJsaWNhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZyA9IHRoaXMuX2xvZztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdHJhY2tTaWduYWxpbmcgPSB0aGlzLl9zaWduYWxpbmcuZ2V0UHVibGljYXRpb24obG9jYWxUcmFjay5fdHJhY2tTZW5kZXIpO1xuICAgICAgICBpZiAoIXRyYWNrU2lnbmFsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiVW5leHBlY3RlZCBlcnJvcjogVGhlIFwiICsgbG9jYWxUcmFjayArIFwiIGNhbm5vdCBiZSBwdWJsaXNoZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVucHVibGlzaChwdWJsaWNhdGlvbikge1xuICAgICAgICAgICAgc2VsZi51bnB1Ymxpc2hUcmFjayhwdWJsaWNhdGlvbi50cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZWQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gdHJhY2tTaWduYWxpbmcuZXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrU2lnbmFsaW5nLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGVkJywgdXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiRmFpbGVkIHRvIHB1Ymxpc2ggdGhlIFwiICsgdHJhY2tDbGFzcyhsb2NhbFRyYWNrLCB0cnVlKSArIFwiOiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZW1vdmVUcmFjayhsb2NhbFRyYWNrLCBsb2NhbFRyYWNrLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ3RyYWNrUHVibGljYXRpb25GYWlsZWQnLCBlcnJvciwgbG9jYWxUcmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2VsZi5fdHJhY2tzLmhhcyhsb2NhbFRyYWNrLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja1NpZ25hbGluZy5yZW1vdmVMaXN0ZW5lcigndXBkYXRlZCcsIHVwZGF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGhlIFwiICsgbG9jYWxUcmFjayArIFwiIHdhcyB1bnB1Ymxpc2hlZFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNpZCA9IHRyYWNrU2lnbmFsaW5nLnNpZDtcbiAgICAgICAgICAgICAgICBpZiAoIXNpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNrU2lnbmFsaW5nLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGVkJywgdXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZzogbG9nLFxuICAgICAgICAgICAgICAgICAgICBMb2NhbEF1ZGlvVHJhY2tQdWJsaWNhdGlvbjogc2VsZi5fTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIExvY2FsRGF0YVRyYWNrUHVibGljYXRpb246IHNlbGYuX0xvY2FsRGF0YVRyYWNrUHVibGljYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIExvY2FsVmlkZW9UcmFja1B1YmxpY2F0aW9uOiBzZWxmLl9Mb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbG9jYWxUcmFja1B1YmxpY2F0aW9uID0gZ2V0VHJhY2tQdWJsaWNhdGlvbihzZWxmLnRyYWNrcywgbG9jYWxUcmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhbFRyYWNrUHVibGljYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxUcmFja1B1YmxpY2F0aW9uID0gYXNMb2NhbFRyYWNrUHVibGljYXRpb24obG9jYWxUcmFjaywgdHJhY2tTaWduYWxpbmcsIHVucHVibGlzaCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZFRyYWNrUHVibGljYXRpb24obG9jYWxUcmFja1B1YmxpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gc2VsZi5fc2lnbmFsaW5nLnN0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgc3RhdGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxUcmFjay5fcHJvY2Vzc29yRXZlbnRPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxUcmFjay5fcHJvY2Vzc29yRXZlbnRPYnNlcnZlci5vbignZXZlbnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9ldmVudE9ic2VydmVyLmVtaXQoJ2V2ZW50Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBldmVudC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBldmVudC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cDogJ3ZpZGVvLXByb2Nlc3NvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiAnaW5mbydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEUoY3NhbnRvcyk6IEZvciB0cmFja3MgY3JlYXRlZCBiZWZvcmUgam9pbmluZyBhIHJvb20gb3IgYWxyZWFkeSBqb2luZWQgYnV0IGFib3V0IHRvIHB1Ymxpc2ggaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsVHJhY2sucHJvY2Vzc2VkVHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsVHJhY2suX2NhcHR1cmVGcmFtZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsVHJhY2suX3NldFNlbmRlck1lZGlhU3RyZWFtVHJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgndHJhY2tQdWJsaXNoZWQnLCBsb2NhbFRyYWNrUHVibGljYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShsb2NhbFRyYWNrUHVibGljYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2tTaWduYWxpbmcub24oJ3VwZGF0ZWQnLCB1cGRhdGVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgYSB7QGxpbmsgTG9jYWxUcmFja30gdG8gdGhlIHtAbGluayBSb29tfS5cbiAgICAgKiBAcGFyYW0ge0xvY2FsVHJhY2t9IGxvY2FsVHJhY2sgLSBUaGUge0BsaW5rIExvY2FsVHJhY2t9IHRvIHB1Ymxpc2hcbiAgICAgKiBAcGFyYW0ge0xvY2FsVHJhY2tQdWJsaXNoT3B0aW9uc30gW29wdGlvbnNdIC0gVGhlIHtAbGluayBMb2NhbFRyYWNrUHVibGlzaE9wdGlvbnN9XG4gICAgICogICBmb3IgcHVibGlzaGluZyB0aGUge0BsaW5rIExvY2FsVHJhY2t9XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TG9jYWxUcmFja1B1YmxpY2F0aW9uPn0gLSBSZXNvbHZlcyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogICB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9ufSBpZiBzdWNjZXNzZnVsOyBJbiBhIExhcmdlIEdyb3VwIFJvb20gKE1heGltdW1cbiAgICAgKiAgIFBhcnRpY2lwYW50cyBncmVhdGVyIHRoYW4gNTApLCByZWplY3RzIHdpdGggYSB7QGxpbmsgUGFydGljaXBhbnRNYXhUcmFja3NFeGNlZWRlZEVycm9yfVxuICAgICAqICAgaWYgZWl0aGVyIHRoZSB0b3RhbCBudW1iZXIgb2YgcHVibGlzaGVkIFRyYWNrcyBpbiB0aGUgUm9vbSBleGNlZWRzIDE2LCBvciB0aGUge0BsaW5rIExvY2FsVHJhY2t9XG4gICAgICogICBpcyBwYXJ0IG9mIGEgc2V0IG9mIHtAbGluayBMb2NhbFRyYWNrfXMgd2hpY2ggYWxvbmcgd2l0aCB0aGUgcHVibGlzaGVkIFRyYWNrcyBleGNlZWRzIDE2LlxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gICAgICpcbiAgICAgKiBWaWRlby5jb25uZWN0KHRva2VuLCB7XG4gICAgICogICBuYW1lOiAnbXktY29vbC1yb29tJyxcbiAgICAgKiAgIGF1ZGlvOiB0cnVlXG4gICAgICogfSkudGhlbihmdW5jdGlvbihyb29tKSB7XG4gICAgICogICByZXR1cm4gVmlkZW8uY3JlYXRlTG9jYWxWaWRlb1RyYWNrKHtcbiAgICAgKiAgICAgbmFtZTogJ2NhbWVyYSdcbiAgICAgKiAgIH0pLnRoZW4oZnVuY3Rpb24obG9jYWxWaWRlb1RyYWNrKSB7XG4gICAgICogICAgIHJldHVybiByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKGxvY2FsVmlkZW9UcmFjaywge1xuICAgICAqICAgICAgIHByaW9yaXR5OiAnaGlnaCdcbiAgICAgKiAgICAgfSk7XG4gICAgICogICB9KTtcbiAgICAgKiB9KS50aGVuKGZ1bmN0aW9uKHB1YmxpY2F0aW9uKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnVGhlIExvY2FsVHJhY2sgXCInICsgcHVibGljYXRpb24udHJhY2tOYW1lXG4gICAgICogICAgICsgJ1wiIHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkIHdpdGggcHJpb3JpdHkgXCInXG4gICAgICogICAgICogcHVibGljYXRpb24ucHJpb3JpdHkgKyAnXCInKTtcbiAgICAgKiB9KTtcbiAgICAqLyAvKipcbiAgICAgKiBQdWJsaXNoZXMgYSBNZWRpYVN0cmVhbVRyYWNrIHRvIHRoZSB7QGxpbmsgUm9vbX0uXG4gICAgICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSBtZWRpYVN0cmVhbVRyYWNrIC0gVGhlIE1lZGlhU3RyZWFtVHJhY2tcbiAgICAgKiAgIHRvIHB1Ymxpc2g7IGlmIGEgY29ycmVzcG9uZGluZyB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSBvclxuICAgICAqICAge0BsaW5rIExvY2FsVmlkZW9UcmFja30gaGFzIG5vdCB5ZXQgYmVlbiBwdWJsaXNoZWQsIHRoaXMgbWV0aG9kIHdpbGxcbiAgICAgKiAgIGNvbnN0cnVjdCBvbmVcbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2tQdWJsaXNoT3B0aW9uc30gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMgZm9yIHB1Ymxpc2hpbmdcbiAgICAgKiAgIHRoZSBNZWRpYVN0cmVhbVRyYWNrXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TG9jYWxUcmFja1B1YmxpY2F0aW9uPn0gLSBSZXNvbHZlcyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogICB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9ufSBpZiBzdWNjZXNzZnVsOyBJbiBhIExhcmdlIEdyb3VwIFJvb20gKE1heGltdW1cbiAgICAgKiAgIFBhcnRpY2lwYW50cyBncmVhdGVyIHRoYW4gNTApLCByZWplY3RzIHdpdGggYSB7QGxpbmsgUGFydGljaXBhbnRNYXhUcmFja3NFeGNlZWRlZEVycm9yfVxuICAgICAqICAgaWYgdGhlIHRvdGFsIG51bWJlciBvZiBwdWJsaXNoZWQgVHJhY2tzIGluIHRoZSBSb29tIGV4Y2VlZHMgMTYsIG9yIHRoZSB7QGxpbmsgTG9jYWxUcmFja31cbiAgICAgKiAgIGlzIHBhcnQgb2YgYSBzZXQgb2Yge0BsaW5rIExvY2FsVHJhY2t9cyB3aGljaCBhbG9uZyB3aXRoIHRoZSBwdWJsaXNoZWQgVHJhY2tzIGV4Y2VlZHMgMTYuXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfVxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgVmlkZW8gPSByZXF1aXJlKCd0d2lsaW8tdmlkZW8nKTtcbiAgICAgKlxuICAgICAqIFZpZGVvLmNvbm5lY3QodG9rZW4sIHtcbiAgICAgKiAgIG5hbWU6ICdteS1jb29sLXJvb20nLFxuICAgICAqICAgYXVkaW86IHRydWVcbiAgICAgKiB9KS50aGVuKGZ1bmN0aW9uKHJvb20pIHtcbiAgICAgKiAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICogICAgIHZpZGVvOiB0cnVlXG4gICAgICogICB9KS50aGVuKGZ1bmN0aW9uKG1lZGlhU3RyZWFtKSB7XG4gICAgICogICAgIHZhciBtZWRpYVN0cmVhbVRyYWNrID0gbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKClbMF07XG4gICAgICogICAgIHJldHVybiByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIHtcbiAgICAgKiAgICAgICBuYW1lOiAnY2FtZXJhJyxcbiAgICAgKiAgICAgICBwcmlvcml0eTogJ2hpZ2gnXG4gICAgICogICAgIH0pO1xuICAgICAqICAgfSk7XG4gICAgICogfSkudGhlbihmdW5jdGlvbihwdWJsaWNhdGlvbikge1xuICAgICAqICAgY29uc29sZS5sb2coJ1RoZSBMb2NhbFRyYWNrIFwiJyArIHB1YmxpY2F0aW9uLnRyYWNrTmFtZVxuICAgICAqICAgICArICdcIiB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZCB3aXRoIHByaW9yaXR5IFwiJ1xuICAgICAqICAgICAqIHB1YmxpY2F0aW9uLnByaW9yaXR5ICsgJ1wiJyk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudC5wcm90b3R5cGUucHVibGlzaFRyYWNrID0gZnVuY3Rpb24gKGxvY2FsVHJhY2tPck1lZGlhU3RyZWFtVHJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRyYWNrUHVibGljYXRpb24gPSBnZXRUcmFja1B1YmxpY2F0aW9uKHRoaXMudHJhY2tzLCBsb2NhbFRyYWNrT3JNZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgaWYgKHRyYWNrUHVibGljYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJhY2tQdWJsaWNhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgbG9nOiB0aGlzLl9sb2csXG4gICAgICAgICAgICBwcmlvcml0eTogdHJhY2tQcmlvcml0eS5QUklPUklUWV9TVEFOREFSRCxcbiAgICAgICAgICAgIExvY2FsQXVkaW9UcmFjazogdGhpcy5fTG9jYWxBdWRpb1RyYWNrLFxuICAgICAgICAgICAgTG9jYWxEYXRhVHJhY2s6IHRoaXMuX0xvY2FsRGF0YVRyYWNrLFxuICAgICAgICAgICAgTG9jYWxWaWRlb1RyYWNrOiB0aGlzLl9Mb2NhbFZpZGVvVHJhY2ssXG4gICAgICAgICAgICBNZWRpYVN0cmVhbVRyYWNrOiB0aGlzLl9NZWRpYVN0cmVhbVRyYWNrXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgbG9jYWxUcmFjaztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsVHJhY2sgPSBhc0xvY2FsVHJhY2sobG9jYWxUcmFja09yTWVkaWFTdHJlYW1UcmFjaywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmlvcml0eVZhbHVlcyA9IE9iamVjdC52YWx1ZXModHJhY2tQcmlvcml0eSk7XG4gICAgICAgIGlmICghcHJpb3JpdHlWYWx1ZXMuaW5jbHVkZXMob3B0aW9ucy5wcmlvcml0eSkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoRS5JTlZBTElEX1ZBTFVFKCdMb2NhbFRyYWNrUHVibGlzaE9wdGlvbnMucHJpb3JpdHknLCBwcmlvcml0eVZhbHVlcykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZGRlZExvY2FsVHJhY2sgPSB0aGlzLl9hZGRUcmFjayhsb2NhbFRyYWNrLCBsb2NhbFRyYWNrLmlkLCBvcHRpb25zLnByaW9yaXR5KVxuICAgICAgICAgICAgfHwgdGhpcy5fdHJhY2tzLmdldChsb2NhbFRyYWNrLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTG9jYWxUcmFja1B1YmxpY2F0aW9uKGFkZGVkTG9jYWxUcmFjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgbXVsdGlwbGUge0BsaW5rIExvY2FsVHJhY2t9cyB0byB0aGUge0BsaW5rIFJvb219LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8TG9jYWxUcmFja3xNZWRpYVN0cmVhbVRyYWNrPn0gdHJhY2tzIC0gVGhlIHtAbGluayBMb2NhbFRyYWNrfXNcbiAgICAgKiAgIHRvIHB1Ymxpc2g7IGZvciBhbnkgTWVkaWFTdHJlYW1UcmFja3MgcHJvdmlkZWQsIGlmIGEgY29ycmVzcG9uZGluZ1xuICAgICAqICAge0BsaW5rIExvY2FsQXVkaW9UcmFja30gb3Ige0BsaW5rIExvY2FsVmlkZW9UcmFja30gaGFzIG5vdCB5ZXQgYmVlblxuICAgICAqICAgcHVibGlzaGVkLCB0aGlzIG1ldGhvZCB3aWxsIGNvbnN0cnVjdCBvbmVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxMb2NhbFRyYWNrUHVibGljYXRpb24+Pn0gLSBUaGUgcmVzdWx0aW5nXG4gICAgICogICB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9ufXMgaWYgc3VjY2Vzc2Z1bDsgSW4gYSBMYXJnZSBHcm91cCBSb29tIChNYXhpbXVtXG4gICAgICogICBQYXJ0aWNpcGFudHMgZ3JlYXRlciB0aGFuIDUwKSwgcmVqZWN0cyB3aXRoIGEge0BsaW5rIFBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvcn1cbiAgICAgKiAgIGlmIHRoZSB0b3RhbCBudW1iZXIgb2YgcHVibGlzaGVkIFRyYWNrcyBpbiB0aGUgUm9vbSBleGNlZWRzIDE2LCBvciB0aGUge0BsaW5rIExvY2FsVHJhY2t9c1xuICAgICAqICAgYWxvbmcgd2l0aCB0aGUgcHVibGlzaGVkIFRyYWNrcyBleGNlZWRzIDE2LlxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50LnByb3RvdHlwZS5wdWJsaXNoVHJhY2tzID0gZnVuY3Rpb24gKHRyYWNrcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodHJhY2tzKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgICAgICAgICAgIHRocm93IEUuSU5WQUxJRF9UWVBFKCd0cmFja3MnLCAnQXJyYXkgb2YgTG9jYWxBdWRpb1RyYWNrLCBMb2NhbFZpZGVvVHJhY2ssIExvY2FsRGF0YVRyYWNrLCBvciBNZWRpYVN0cmVhbVRyYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRyYWNrcy5tYXAodGhpcy5wdWJsaXNoVHJhY2ssIHRoaXMpKTtcbiAgICB9O1xuICAgIExvY2FsUGFydGljaXBhbnQucHJvdG90eXBlLnNldEJhbmR3aWR0aFByb2ZpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xvZy53YXJuKCdzZXRCYW5kd2lkdGhQcm9maWxlIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQgYW5kIG1heSBiZSBhdmFpbGFibGUgaW4gZnV0dXJlIHZlcnNpb25zIG9mIHR3aWxpby12aWRlby5qcycpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUge0BsaW5rIE5ldHdvcmtRdWFsaXR5VmVyYm9zaXR5fSBmb3IgdGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBhbmRcbiAgICAgKiB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9cy4gSXQgZG9lcyBub3RoaW5nIGlmIE5ldHdvcmsgUXVhbGl0eSBpcyBub3QgZW5hYmxlZFxuICAgICAqIHdoaWxlIGNhbGxpbmcge0BsaW5rIGNvbm5lY3R9LlxuICAgICAqIEBwYXJhbSB7TmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9ufSBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24gLSBUaGUgbmV3XG4gICAgICogICB7QGxpbmsgTmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9ufTsgSWYgZWl0aGVyIG9yIGJvdGggb2YgdGhlIGxvY2FsIGFuZFxuICAgICAqICAgcmVtb3RlIHtAbGluayBOZXR3b3JrUXVhbGl0eVZlcmJvc2l0eX0gdmFsdWVzIGFyZSBhYnNlbnQsIHRoZW4gdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgIGV4aXN0aW5nIHZhbHVlcyBhcmUgcmV0YWluZWRcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFVwZGF0ZSB2ZXJib3NpdHkgbGV2ZWxzIGZvciBib3RoIExvY2FsUGFydGljaXBhbnQgYW5kIFJlbW90ZVBhcnRpY2lwYW50c1xuICAgICAqIGxvY2FsUGFydGljaXBhbnQuc2V0TmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uKHtcbiAgICAgKiAgIGxvY2FsOiAxLFxuICAgICAqICAgcmVtb3RlOiAyXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBVcGRhdGUgdmVyYm9zaXR5IGxldmVsIGZvciBvbmx5IHRoZSBMb2NhbFBhcnRpY2lwYW50XG4gICAgICogbG9jYWxQYXJ0aWNpcGFudC5zZXROZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24oe1xuICAgICAqICAgbG9jYWw6IDFcbiAgICAgKiB9KTtcbiAgICAgKiAgQGV4YW1wbGVcbiAgICAgKiAvLyBVcGRhdGUgdmVyYm9zaXR5IGxldmVsIGZvciBvbmx5IHRoZSBSZW1vdGVQYXJ0aWNpcGFudHNcbiAgICAgKiBsb2NhbFBhcnRpY2lwYW50LnNldE5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbih7XG4gICAgICogICByZW1vdGU6IDJcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50LnByb3RvdHlwZS5zZXROZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiAobmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgfHwgbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgICAgICAgICAgdGhyb3cgRS5JTlZBTElEX1RZUEUoJ25ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbicsICdOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBbJ2xvY2FsJywgJ3JlbW90ZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbiAmJiAodHlwZW9mIG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbltwcm9wXSAhPT0gJ251bWJlcicgfHwgaXNOYU4obmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uW3Byb3BdKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgICAgICAgICAgICAgIHRocm93IEUuSU5WQUxJRF9UWVBFKFwibmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uLlwiICsgcHJvcCwgJ251bWJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2lnbmFsaW5nLnNldE5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbihuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUge0BsaW5rIExvY2FsUGFydGljaXBhbnR9J3Mge0BsaW5rIEVuY29kaW5nUGFyYW1ldGVyc30uXG4gICAgICogQHBhcmFtIHs/RW5jb2RpbmdQYXJhbWV0ZXJzfSBbZW5jb2RpbmdQYXJhbWV0ZXJzXSAtIFRoZSBuZXdcbiAgICAgKiAgIHtAbGluayBFbmNvZGluZ1BhcmFtZXRlcnN9OyBJZiBudWxsLCB0aGVuIHRoZSBiaXRyYXRlIGxpbWl0cyBhcmUgcmVtb3ZlZDtcbiAgICAgKiAgIElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gdGhlIGV4aXN0aW5nIGJpdHJhdGUgbGltaXRzIGFyZSBwcmVzZXJ2ZWRcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudC5wcm90b3R5cGUuc2V0UGFyYW1ldGVycyA9IGZ1bmN0aW9uIChlbmNvZGluZ1BhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZ1BhcmFtZXRlcnMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAmJiB0eXBlb2YgZW5jb2RpbmdQYXJhbWV0ZXJzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgICAgICAgICAgIHRocm93IEUuSU5WQUxJRF9UWVBFKCdlbmNvZGluZ1BhcmFtZXRlcnMnLCAnRW5jb2RpbmdQYXJhbWV0ZXJzLCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmNvZGluZ1BhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIFsnbWF4QXVkaW9CaXRyYXRlJywgJ21heFZpZGVvQml0cmF0ZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nUGFyYW1ldGVyc1twcm9wXSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgJiYgdHlwZW9mIGVuY29kaW5nUGFyYW1ldGVyc1twcm9wXSAhPT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgJiYgZW5jb2RpbmdQYXJhbWV0ZXJzW3Byb3BdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEUuSU5WQUxJRF9UWVBFKFwiZW5jb2RpbmdQYXJhbWV0ZXJzLlwiICsgcHJvcCwgJ251bWJlciwgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbmNvZGluZ1BhcmFtZXRlcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGVuY29kaW5nUGFyYW1ldGVycyA9IHsgbWF4QXVkaW9CaXRyYXRlOiBudWxsLCBtYXhWaWRlb0JpdHJhdGU6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaWduYWxpbmcuc2V0UGFyYW1ldGVycyhlbmNvZGluZ1BhcmFtZXRlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3BzIHB1Ymxpc2hpbmcgYSB7QGxpbmsgTG9jYWxUcmFja30gdG8gdGhlIHtAbGluayBSb29tfS5cbiAgICAgKiBAcGFyYW0ge0xvY2FsVHJhY2t8TWVkaWFTdHJlYW1UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIExvY2FsVHJhY2t9XG4gICAgICogICB0byBzdG9wIHB1Ymxpc2hpbmc7IGlmIGEgTWVkaWFTdHJlYW1UcmFjayBpcyBwcm92aWRlZCwgdGhpcyBtZXRob2RcbiAgICAgKiAgIGxvb2tzIHVwIHRoZSBjb3JyZXNwb25kaW5nIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IG9yXG4gICAgICogICB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSB0byBzdG9wIHB1Ymxpc2hpbmdcbiAgICAgKiBAcmV0dXJucyB7P0xvY2FsVHJhY2tQdWJsaWNhdGlvbn0gLSBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqICAge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn0gaWYgdGhlIHtAbGluayBMb2NhbFRyYWNrfSB3YXMgcHJldmlvdXNseVxuICAgICAqICAgcHVibGlzaGVkLCBudWxsIG90aGVyd2lzZVxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnQucHJvdG90eXBlLnVucHVibGlzaFRyYWNrID0gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHZhbGlkYXRlTG9jYWxUcmFjayh0cmFjaywge1xuICAgICAgICAgICAgTG9jYWxBdWRpb1RyYWNrOiB0aGlzLl9Mb2NhbEF1ZGlvVHJhY2ssXG4gICAgICAgICAgICBMb2NhbERhdGFUcmFjazogdGhpcy5fTG9jYWxEYXRhVHJhY2ssXG4gICAgICAgICAgICBMb2NhbFZpZGVvVHJhY2s6IHRoaXMuX0xvY2FsVmlkZW9UcmFjayxcbiAgICAgICAgICAgIE1lZGlhU3RyZWFtVHJhY2s6IHRoaXMuX01lZGlhU3RyZWFtVHJhY2tcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsb2NhbFRyYWNrID0gdGhpcy5fdHJhY2tzLmdldCh0cmFjay5pZCk7XG4gICAgICAgIGlmICghbG9jYWxUcmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYWNrU2lnbmFsaW5nID0gdGhpcy5fc2lnbmFsaW5nLmdldFB1YmxpY2F0aW9uKGxvY2FsVHJhY2suX3RyYWNrU2VuZGVyKTtcbiAgICAgICAgdHJhY2tTaWduYWxpbmcucHVibGlzaEZhaWxlZChuZXcgRXJyb3IoXCJUaGUgXCIgKyBsb2NhbFRyYWNrICsgXCIgd2FzIHVucHVibGlzaGVkXCIpKTtcbiAgICAgICAgbG9jYWxUcmFjayA9IHRoaXMuX3JlbW92ZVRyYWNrKGxvY2FsVHJhY2ssIGxvY2FsVHJhY2suaWQpO1xuICAgICAgICBpZiAoIWxvY2FsVHJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2NhbFRyYWNrUHVibGljYXRpb24gPSBnZXRUcmFja1B1YmxpY2F0aW9uKHRoaXMudHJhY2tzLCBsb2NhbFRyYWNrKTtcbiAgICAgICAgaWYgKGxvY2FsVHJhY2tQdWJsaWNhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVHJhY2tQdWJsaWNhdGlvbihsb2NhbFRyYWNrUHVibGljYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbFRyYWNrUHVibGljYXRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9wcyBwdWJsaXNoaW5nIG11bHRpcGxlIHtAbGluayBMb2NhbFRyYWNrfXMgdG8gdGhlIHtAbGluayBSb29tfS5cbiAgICAgKiBAcGFyYW0ge0FycmF5PExvY2FsVHJhY2t8TWVkaWFTdHJlYW1UcmFjaz59IHRyYWNrcyAtIFRoZSB7QGxpbmsgTG9jYWxUcmFja31zXG4gICAgICogICB0byBzdG9wIHB1Ymxpc2hpbmc7IGZvciBhbnkgTWVkaWFTdHJlYW1UcmFja3MgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIGxvb2tzXG4gICAgICogICB1cCB0aGUgY29ycmVzcG9uZGluZyB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSBvciB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSB0b1xuICAgICAqICAgc3RvcCBwdWJsaXNoaW5nXG4gICAgICogQHJldHVybnMge0FycmF5PExvY2FsVHJhY2tQdWJsaWNhdGlvbj59IC0gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb259cyB0aGF0IHdlcmUgc3VjY2Vzc2Z1bGx5IHVucHVibGlzaGVkXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfVxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnQucHJvdG90eXBlLnVucHVibGlzaFRyYWNrcyA9IGZ1bmN0aW9uICh0cmFja3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRyYWNrcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gICAgICAgICAgICB0aHJvdyBFLklOVkFMSURfVFlQRSgndHJhY2tzJywgJ0FycmF5IG9mIExvY2FsQXVkaW9UcmFjaywgTG9jYWxWaWRlb1RyYWNrLCBMb2NhbERhdGFUcmFjaywgb3IgTWVkaWFTdHJlYW1UcmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFja3MucmVkdWNlKGZ1bmN0aW9uICh1bnB1Ymxpc2hlZFRyYWNrcywgdHJhY2spIHtcbiAgICAgICAgICAgIHZhciB1bnB1Ymxpc2hlZFRyYWNrID0gX3RoaXMudW5wdWJsaXNoVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIHVucHVibGlzaGVkVHJhY2sgPyB1bnB1Ymxpc2hlZFRyYWNrcy5jb25jYXQodW5wdWJsaXNoZWRUcmFjaykgOiB1bnB1Ymxpc2hlZFRyYWNrcztcbiAgICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2FsUGFydGljaXBhbnQ7XG59KFBhcnRpY2lwYW50KSk7XG4vKipcbiAqIFRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gaGFzIHJlY29ubmVjdGVkIHRvIHRoZSB7QGxpbmsgUm9vbX0gYWZ0ZXIgYSBzaWduYWxpbmcgY29ubmVjdGlvbiBkaXNydXB0aW9uLlxuICogQGV2ZW50IExvY2FsUGFydGljaXBhbnQjcmVjb25uZWN0ZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IGlzIHJlY29ubmVjdGluZyB0byB0aGUge0BsaW5rIFJvb219IGFmdGVyIGEgc2lnbmFsaW5nIGNvbm5lY3Rpb24gZGlzcnVwdGlvbi5cbiAqIEBldmVudCBMb2NhbFBhcnRpY2lwYW50I3JlY29ubmVjdGluZ1xuICovXG4vKipcbiAqIE9uZSBvZiB0aGUge0BsaW5rIExvY2FsUGFydGljaXBhbnR9J3Mge0BsaW5rIExvY2FsVmlkZW9UcmFja30ncyBkaW1lbnNpb25zIGNoYW5nZWQuXG4gKiBAcGFyYW0ge0xvY2FsVmlkZW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIExvY2FsVmlkZW9UcmFja30gd2hvc2UgZGltZW5zaW9ucyBjaGFuZ2VkXG4gKiBAZXZlbnQgTG9jYWxQYXJ0aWNpcGFudCN0cmFja0RpbWVuc2lvbnNDaGFuZ2VkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgTG9jYWxUcmFja30gd2FzIGRpc2FibGVkIGJ5IHRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0uXG4gKiBAcGFyYW0ge0xvY2FsVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBMb2NhbFRyYWNrfSB0aGF0IHdhcyBkaXNhYmxlZFxuICogQGV2ZW50IExvY2FsUGFydGljaXBhbnQjdHJhY2tEaXNhYmxlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIExvY2FsVHJhY2t9IHdhcyBlbmFibGVkIGJ5IHRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0uXG4gKiBAcGFyYW0ge0xvY2FsVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBMb2NhbFRyYWNrfSB0aGF0IHdhcyBlbmFibGVkXG4gKiBAZXZlbnQgTG9jYWxQYXJ0aWNpcGFudCN0cmFja0VuYWJsZWRcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBMb2NhbFRyYWNrfSBmYWlsZWQgdG8gcHVibGlzaC4gQ2hlY2sgdGhlIGVycm9yIG1lc3NhZ2UgZm9yIG1vcmVcbiAqIGluZm9ybWF0aW9uLiBJbiBhIExhcmdlIEdyb3VwIFJvb20gKE1heGltdW0gUGFydGljaXBhbnRzIGdyZWF0ZXIgdGhhbiA1MCksXG4gKiB0aGlzIGV2ZW50IGlzIHJhaXNlZCB3aXRoIGEge0BsaW5rIFBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvcn0gZWl0aGVyXG4gKiB3aGVuIGF0dGVtcHRpbmcgdG8gcHVibGlzaCB0aGUge0BsaW5rIExvY2FsVHJhY2t9IHdpbGwgZXhjZWVkIHRoZSBNYXhpbXVtIFB1Ymxpc2hlZFxuICogVHJhY2tzIGxpbWl0IG9mIDE2LCBvciB0aGUge0BsaW5rIExvY2FsVHJhY2t9IGlzIHBhcnQgb2YgYSBzZXQgb2Yge0BsaW5rIExvY2FsVHJhY2t9c1xuICogd2hpY2ggYWxvbmcgd2l0aCB0aGUgcHVibGlzaGVkIFRyYWNrcyBleGNlZWRzIDE2LlxuICogQHBhcmFtIHtUd2lsaW9FcnJvcn0gZXJyb3IgLSBBIHtAbGluayBUd2lsaW9FcnJvcn0gZXhwbGFpbmluZyB3aHkgcHVibGljYXRpb25cbiAqICAgZmFpbGVkXG4gKiBAcGFyYW0ge0xvY2FsVHJhY2t9IGxvY2FsVHJhY2sgLSBUaGUge0BsaW5rIExvY2FsVHJhY2t9IHRoYXQgZmFpbGVkIHRvXG4gKiAgIHB1Ymxpc2hcbiAqIEBldmVudCBMb2NhbFBhcnRpY2lwYW50I3RyYWNrUHVibGljYXRpb25GYWlsZWRcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBMb2NhbFRyYWNrfSB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwYXJhbSB7TG9jYWxUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvbiAtIFRoZSByZXN1bHRpbmdcbiAqICAge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn0gZm9yIHRoZSBwdWJsaXNoZWQge0BsaW5rIExvY2FsVHJhY2t9XG4gKiBAZXZlbnQgTG9jYWxQYXJ0aWNpcGFudCN0cmFja1B1Ymxpc2hlZFxuICovXG4vKipcbiAqIE9uZSBvZiB0aGUge0BsaW5rIExvY2FsUGFydGljaXBhbnR9J3Mge0BsaW5rIExvY2FsVHJhY2t9cyBzdGFydGVkLlxuICogQHBhcmFtIHtMb2NhbFRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgTG9jYWxUcmFja30gdGhhdCBzdGFydGVkXG4gKiBAZXZlbnQgTG9jYWxQYXJ0aWNpcGFudCN0cmFja1N0YXJ0ZWRcbiAqL1xuLyoqXG4gKiBPbmUgb2YgdGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSdzIHtAbGluayBMb2NhbFRyYWNrfXMgc3RvcHBlZCwgZWl0aGVyXG4gKiBiZWNhdXNlIHtAbGluayBMb2NhbFRyYWNrI3N0b3B9IHdhcyBjYWxsZWQgb3IgYmVjYXVzZSB0aGUgdW5kZXJseWluZ1xuICogTWVkaWFTdHJlYW1UcmFjayBlbmRlZCkuXG4gKiBAcGFyYW0ge0xvY2FsVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBMb2NhbFRyYWNrfSB0aGF0IHN0b3BwZWRcbiAqIEBldmVudCBMb2NhbFBhcnRpY2lwYW50I3RyYWNrU3RvcHBlZFxuICovXG4vKipcbiAqIE91dGdvaW5nIG1lZGlhIGVuY29kaW5nIHBhcmFtZXRlcnMuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBFbmNvZGluZ1BhcmFtZXRlcnNcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gW21heEF1ZGlvQml0cmF0ZV0gLSBNYXggb3V0Z29pbmcgYXVkaW8gYml0cmF0ZSAoYnBzKTtcbiAqICAgSWYgbm90IHNwZWNpZmllZCwgcmV0YWlucyB0aGUgZXhpc3RpbmcgYml0cmF0ZSBsaW1pdDsgQSA8Y29kZT5udWxsPC9jb2RlPiBvciBhXG4gKiAgIDxjb2RlPjA8L2NvZGU+IHZhbHVlIHJlbW92ZXMgYW55IHByZXZpb3VzbHkgc2V0IGJpdHJhdGUgbGltaXQ7IFRoaXMgdmFsdWUgaXMgc2V0XG4gKiAgIGFzIGEgaGludCBmb3IgdmFyaWFibGUgYml0cmF0ZSBjb2RlY3MsIGJ1dCB3aWxsIG5vdCB0YWtlIGVmZmVjdCBmb3IgZml4ZWQgYml0cmF0ZVxuICogICBjb2RlY3M7IEJhc2VkIG9uIG91ciB0ZXN0cywgQ2hyb21lLCBGaXJlZm94IGFuZCBTYWZhcmkgc3VwcG9ydCBhIGJpdHJhdGUgcmFuZ2Ugb2ZcbiAqICAgMTIwMDAgYnBzIHRvIDI1NjAwMCBicHMgZm9yIE9wdXMgY29kZWM7IFRoaXMgcGFyYW1ldGVyIGhhcyBubyBlZmZlY3Qgb24gaVNBQywgUENNVVxuICogICBhbmQgUENNQSBjb2RlY3NcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gW21heFZpZGVvQml0cmF0ZV0gLSBNYXggb3V0Z29pbmcgdmlkZW8gYml0cmF0ZSAoYnBzKTtcbiAqICAgSWYgbm90IHNwZWNpZmllZCwgcmV0YWlucyB0aGUgZXhpc3RpbmcgYml0cmF0ZSBsaW1pdDsgQSA8Y29kZT5udWxsPC9jb2RlPiBvclxuICogICBhIDxjb2RlPjA8L2NvZGU+IHZhbHVlIHJlbW92ZXMgYW55IHByZXZpb3VzbHkgc2V0IGJpdHJhdGUgbGltaXQ7IFRoaXMgdmFsdWUgaXNcbiAqICAgc2V0IGFzIGEgaGludCBmb3IgdmFyaWFibGUgYml0cmF0ZSBjb2RlY3MsIGJ1dCB3aWxsIG5vdCB0YWtlIGVmZmVjdCBmb3IgZml4ZWRcbiAqICAgYml0cmF0ZSBjb2RlY3M7IEJhc2VkIG9uIG91ciB0ZXN0cywgQ2hyb21lLCBGaXJlZm94IGFuZCBTYWZhcmkgYWxsIHNlZW0gdG8gc3VwcG9ydFxuICogICBhbiBhdmVyYWdlIGJpdHJhdGUgcmFuZ2Ugb2YgMjAwMDAgYnBzICgyMCBrYnBzKSB0byA4MDAwMDAwIGJwcyAoOCBtYnBzKSBmb3IgYVxuICogICA3MjBwIFZpZGVvVHJhY2suXG4gKiAgIE5vdGU6IHRoaXMgbGltaXQgaXMgbm90IGFwcGxpZWQgZm9yIHNjcmVlbiBzaGFyZSB0cmFja3MgcHVibGlzaGVkIG9uIENocm9tZS5cbiAqL1xuLyoqXG4gKiBPcHRpb25zIGZvciBwdWJsaXNoaW5nIGEge0BsaW5rIExvY2FsVHJhY2t9LlxuICogQHR5cGVkZWYge29iamVjdH0gTG9jYWxUcmFja1B1Ymxpc2hPcHRpb25zXG4gKiBAcHJvcGVydHkge1RyYWNrLlByaW9yaXR5fSBbcHJpb3JpdHk9J3N0YW5kYXJkJ10gLSBUaGUgcHJpb3JpdHkgd2l0aCB3aGljaCB0aGUge0BsaW5rIExvY2FsVHJhY2t9XG4gKiAgIGlzIHRvIGJlIHB1Ymxpc2hlZDsgSW4gR3JvdXAgb3IgU21hbGwgR3JvdXAgUm9vbXMsIHRoZSBhcHByb3ByaWF0ZSBiYW5kd2lkdGggaXNcbiAqICAgYWxsb2NhdGVkIHRvIHRoZSB7QGxpbmsgTG9jYWxUcmFja30gYmFzZWQgb24gaXRzIHtAbGluayBUcmFjay5Qcmlvcml0eX07IEl0IGhhcyBub1xuICogICBlZmZlY3QgaW4gUGVlci10by1QZWVyIFJvb21zOyBJdCBkZWZhdWx0cyB0byBcInN0YW5kYXJkXCIgd2hlbiBub3QgcHJvdmlkZWRcbiAqL1xuLyoqXG4gKiBPcHRpb25zIGZvciBwdWJsaXNoaW5nIGEge0BsaW5rIE1lZGlhU3RyZWFtVHJhY2t9LlxuICogQHR5cGVkZWYge0xvY2FsVHJhY2tPcHRpb25zfSBNZWRpYVN0cmVhbVRyYWNrUHVibGlzaE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7VHJhY2suUHJpb3JpdHl9IFtwcmlvcml0eT0nc3RhbmRhcmQnXSAtIFRoZSBwcmlvcml0eSB3aXRoIHdoaWNoIHRoZSB7QGxpbmsgTG9jYWxUcmFja31cbiAqICAgaXMgdG8gYmUgcHVibGlzaGVkOyBJbiBHcm91cCBvciBTbWFsbCBHcm91cCBSb29tcywgdGhlIGFwcHJvcHJpYXRlIGJhbmR3aWR0aCBpc1xuICogICBhbGxvY2F0ZWQgdG8gdGhlIHtAbGluayBMb2NhbFRyYWNrfSBiYXNlZCBvbiBpdHMge0BsaW5rIFRyYWNrLlByaW9yaXR5fTsgSXQgaGFzIG5vXG4gKiAgIGVmZmVjdCBpbiBQZWVyLXRvLVBlZXIgUm9vbXM7IEl0IGRlZmF1bHRzIHRvIFwic3RhbmRhcmRcIiB3aGVuIG5vdCBwcm92aWRlZFxuICovXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge01hcDxUcmFjay5TSUQsIExvY2FsVHJhY2tQdWJsaWNhdGlvbj59IHRyYWNrUHVibGljYXRpb25zXG4gKiBAcGFyYW0ge0xvY2FsVHJhY2t8TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAqIEByZXR1cm5zIHs/TG9jYWxUcmFja1B1YmxpY2F0aW9ufSB0cmFja1B1YmxpY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFRyYWNrUHVibGljYXRpb24odHJhY2tQdWJsaWNhdGlvbnMsIHRyYWNrKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpLmZpbmQoZnVuY3Rpb24gKHRyYWNrUHVibGljYXRpb24pIHsgcmV0dXJuIHRyYWNrUHVibGljYXRpb24udHJhY2sgPT09IHRyYWNrXG4gICAgICAgIHx8IHRyYWNrUHVibGljYXRpb24udHJhY2subWVkaWFTdHJlYW1UcmFjayA9PT0gdHJhY2s7IH0pIHx8IG51bGw7XG59XG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsUGFydGljaXBhbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbHBhcnRpY2lwYW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTWVkaWFUcmFjayA9IHJlcXVpcmUoJy4vbWVkaWF0cmFjaycpO1xuLyoqXG4gKiBBbiB7QGxpbmsgQXVkaW9UcmFja30gaXMgYSB7QGxpbmsgVHJhY2t9IHJlcHJlc2VudGluZyBhdWRpby5cbiAqIEBleHRlbmRzIFRyYWNrXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU3RhcnRlZCAtIFdoZXRoZXIgb3Igbm90IHRoZSB7QGxpbmsgQXVkaW9UcmFja30gaGFzXG4gKiAgIHN0YXJ0ZWQ7IGlmIHRoZSB7QGxpbmsgQXVkaW9UcmFja30gc3RhcnRlZCwgdGhlcmUgaXMgZW5vdWdoIGF1ZGlvIGRhdGEgdG9cbiAqICAgYmVnaW4gcGxheWJhY2tcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNFbmFibGVkIC0gV2hldGhlciBvciBub3QgdGhlIHtAbGluayBBdWRpb1RyYWNrfSBpc1xuICogICBlbmFibGVkOyBpZiB0aGUge0BsaW5rIEF1ZGlvVHJhY2t9IGlzIG5vdCBlbmFibGVkLCBpdCBpcyBcIm11dGVkXCJcbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZCAtIFwiYXVkaW9cIlxuICogQHByb3BlcnR5IHtNZWRpYVN0cmVhbVRyYWNrfSBtZWRpYVN0cmVhbVRyYWNrIC0gQW4gYXVkaW8gTWVkaWFTdHJlYW1UcmFja1xuICogQHByb3BlcnR5IHs/TWVkaWFTdHJlYW1UcmFja30gcHJvY2Vzc2VkVHJhY2sgLSBUaGUgc291cmNlIG9mIHByb2Nlc3NlZCBhdWRpbyBzYW1wbGVzLlxuICogSXQgaXMgYWx3YXlzIG51bGwgYXMgYXVkaW8gcHJvY2Vzc2luZyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAqIEBlbWl0cyBBdWRpb1RyYWNrI2Rpc2FibGVkXG4gKiBAZW1pdHMgQXVkaW9UcmFjayNlbmFibGVkXG4gKiBAZW1pdHMgQXVkaW9UcmFjayNzdGFydGVkXG4gKi9cbnZhciBBdWRpb1RyYWNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBdWRpb1RyYWNrLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiB7QGxpbmsgQXVkaW9UcmFja30uXG4gICAgICogQHBhcmFtIHtNZWRpYVRyYWNrVHJhbnNjZWl2ZXJ9IG1lZGlhVHJhY2tUcmFuc2NlaXZlclxuICAgICAqIEBwYXJhbSB7e2xvZzogTG9nfX0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF1ZGlvVHJhY2sobWVkaWFUcmFja1RyYW5zY2VpdmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBtZWRpYVRyYWNrVHJhbnNjZWl2ZXIsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQXVkaW9UcmFjay5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9zdGFydC5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fZHVtbXlFbCkge1xuICAgICAgICAgICAgLy8gb25jZSBzdGFydGVkIGxldCBnbyBvZiBkdW1teSBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLl9kdW1teUVsLnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9kdW1teUVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIEhUTUxBdWRpb0VsZW1lbnQgYW5kIGF0dGFjaCB0aGUge0BsaW5rIEF1ZGlvVHJhY2t9IHRvIGl0LlxuICAgICAqXG4gICAgICogVGhlIEhUTUxBdWRpb0VsZW1lbnQncyA8Y29kZT5zcmNPYmplY3Q8L2NvZGU+IHdpbGwgYmUgc2V0IHRvIGEgbmV3XG4gICAgICogTWVkaWFTdHJlYW0gY29udGFpbmluZyB0aGUge0BsaW5rIEF1ZGlvVHJhY2t9J3MgTWVkaWFTdHJlYW1UcmFjay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtIVE1MQXVkaW9FbGVtZW50fSBhdWRpb0VsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gICAgICpcbiAgICAgKiBWaWRlby5jcmVhdGVMb2NhbEF1ZGlvVHJhY2soKS50aGVuKGZ1bmN0aW9uKGF1ZGlvVHJhY2spIHtcbiAgICAgKiAgIGNvbnN0IGF1ZGlvRWxlbWVudCA9IGF1ZGlvVHJhY2suYXR0YWNoKCk7XG4gICAgICogICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGF1ZGlvRWxlbWVudCk7XG4gICAgICogfSk7XG4gICAgKi8gLyoqXG4gICAgICogQXR0YWNoIHRoZSB7QGxpbmsgQXVkaW9UcmFja30gdG8gYW4gZXhpc3RpbmcgSFRNTE1lZGlhRWxlbWVudC4gVGhlXG4gICAgICogSFRNTE1lZGlhRWxlbWVudCBjb3VsZCBiZSBhbiBIVE1MQXVkaW9FbGVtZW50IG9yIGFuIEhUTUxWaWRlb0VsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgSFRNTE1lZGlhRWxlbWVudCdzIDxjb2RlPnNyY09iamVjdDwvY29kZT4gaXMgbm90IHNldCB0byBhIE1lZGlhU3RyZWFtLFxuICAgICAqIHRoaXMgbWV0aG9kIHNldHMgaXQgdG8gYSBuZXcgTWVkaWFTdHJlYW0gY29udGFpbmluZyB0aGUge0BsaW5rIEF1ZGlvVHJhY2t9J3NcbiAgICAgKiBNZWRpYVN0cmVhbVRyYWNrOyBvdGhlcndpc2UsIGl0IGFkZHMgdGhlIHtAbGluayBNZWRpYVRyYWNrfSdzXG4gICAgICogTWVkaWFTdHJlYW1UcmFjayB0byB0aGUgZXhpc3RpbmcgTWVkaWFTdHJlYW0uIEZpbmFsbHksIGlmIHRoZXJlIGFyZSBhbnkgb3RoZXJcbiAgICAgKiBNZWRpYVN0cmVhbVRyYWNrcyBvZiB0aGUgc2FtZSBraW5kIG9uIHRoZSBNZWRpYVN0cmVhbSwgdGhpcyBtZXRob2QgcmVtb3Zlc1xuICAgICAqIHRoZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhRWxlbWVudCAtIFRoZSBIVE1MTWVkaWFFbGVtZW50IHRvIGF0dGFjaCB0b1xuICAgICAqIEByZXR1cm5zIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYUVsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gICAgICpcbiAgICAgKiBjb25zdCB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAqIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodmlkZW9FbGVtZW50KTtcbiAgICAgKlxuICAgICAqIFZpZGVvLmNyZWF0ZUxvY2FsQXVkaW9UcmFjaygpLnRoZW4oZnVuY3Rpb24oYXVkaW9UcmFjaykge1xuICAgICAqICAgYXVkaW9UcmFjay5hdHRhY2godmlkZW9FbGVtZW50KTtcbiAgICAgKiB9KTtcbiAgICAqLyAvKipcbiAgICAgKiBBdHRhY2ggdGhlIHtAbGluayBBdWRpb1RyYWNrfSB0byBhbiBIVE1MTWVkaWFFbGVtZW50IHNlbGVjdGVkIGJ5XG4gICAgICogPGNvZGU+ZG9jdW1lbnQucXVlcnlTZWxlY3RvcjwvY29kZT4uIFRoZSBIVE1MTWVkaWFFbGVtZW50IGNvdWxkIGJlIGFuXG4gICAgICogSFRNTEF1ZGlvRWxlbWVudCBvciBhbiBIVE1MVmlkZW9FbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgdGhlIEhUTUxNZWRpYUVsZW1lbnQncyA8Y29kZT5zcmNPYmplY3Q8L2NvZGU+IGlzIG5vdCBzZXQgdG8gYSBNZWRpYVN0cmVhbSxcbiAgICAgKiB0aGlzIG1ldGhvZCBzZXRzIGl0IHRvIGEgbmV3IE1lZGlhU3RyZWFtIGNvbnRhaW5pbmcgdGhlIHtAbGluayBBdWRpb1RyYWNrfSdzXG4gICAgICogTWVkaWFTdHJlYW1UcmFjazsgb3RoZXJ3aXNlLCBpdCBhZGRzIHRoZSB7QGxpbmsgQXVkaW9UcmFja30nc1xuICAgICAqIE1lZGlhU3RyZWFtVHJhY2sgdG8gdGhlIGV4aXN0aW5nIE1lZGlhU3RyZWFtLiBGaW5hbGx5LCBpZiB0aGVyZSBhcmUgYW55IG90aGVyXG4gICAgICogTWVkaWFTdHJlYW1UcmFja3Mgb2YgdGhlIHNhbWUga2luZCBvbiB0aGUgTWVkaWFTdHJlYW0sIHRoaXMgbWV0aG9kIHJlbW92ZXNcbiAgICAgKiB0aGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gQSBxdWVyeSBzZWxlY3RvciBmb3IgdGhlIEhUTUxNZWRpYUVsZW1lbnQgdG9cbiAgICAgKiAgIGF0dGFjaCB0b1xuICAgICAqIEByZXR1cm5zIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYUVsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gICAgICpcbiAgICAgKiBjb25zdCB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAqIHZpZGVvRWxlbWVudC5pZCA9ICdteS12aWRlby1lbGVtZW50JztcbiAgICAgKiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHZpZGVvRWxlbWVudCk7XG4gICAgICpcbiAgICAgKiBWaWRlby5jcmVhdGVMb2NhbEF1ZGlvVHJhY2soKS50aGVuKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICogICB0cmFjay5hdHRhY2goJyNteS12aWRlby1lbGVtZW50Jyk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgQXVkaW9UcmFjay5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5hdHRhY2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaCB0aGUge0BsaW5rIEF1ZGlvVHJhY2t9IGZyb20gYWxsIHByZXZpb3VzbHkgYXR0YWNoZWQgSFRNTE1lZGlhRWxlbWVudHMuXG4gICAgICogQHJldHVybnMge0FycmF5PEhUTUxNZWRpYUVsZW1lbnQ+fSBtZWRpYUVsZW1lbnRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBtZWRpYUVsZW1lbnRzID0gYXVkaW9UcmFjay5kZXRhY2goKTtcbiAgICAgKiBtZWRpYUVsZW1lbnRzLmZvckVhY2gobWVkaWFFbGVtZW50ID0+IG1lZGlhRWxlbWVudC5yZW1vdmUoKSk7XG4gICAgKi8gLyoqXG4gICAgICogRGV0YWNoIHRoZSB7QGxpbmsgQXVkaW9UcmFja30gZnJvbSBhIHByZXZpb3VzbHkgYXR0YWNoZWQgSFRNTE1lZGlhRWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhRWxlbWVudCAtIE9uZSBvZiB0aGUgSFRNTE1lZGlhRWxlbWVudHMgdG9cbiAgICAgKiAgIHdoaWNoIHRoZSB7QGxpbmsgQXVkaW9UcmFja30gaXMgYXR0YWNoZWRcbiAgICAgKiBAcmV0dXJucyB7SFRNTE1lZGlhRWxlbWVudH0gbWVkaWFFbGVtZW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXktdmlkZW8tZWxlbWVudCcpO1xuICAgICAqIGF1ZGlvVHJhY2suZGV0YWNoKHZpZGVvRWxlbWVudCkucmVtb3ZlKCk7XG4gICAgKi8gLyoqXG4gICAgICogRGV0YWNoIHRoZSB7QGxpbmsgQXVkaW9UcmFja30gZnJvbSBhIHByZXZpb3VzbHkgYXR0YWNoZWQgSFRNTE1lZGlhRWxlbWVudFxuICAgICAqICAgc3BlY2lmaWVkIGJ5IDxjb2RlPmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3I8L2NvZGU+LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIFRoZSBxdWVyeSBzZWxlY3RvciBvZiBIVE1MTWVkaWFFbGVtZW50IHRvIHdoaWNoXG4gICAgICogICAgdGhlIHtAbGluayBBdWRpb1RyYWNrfSBpcyBhdHRhY2hlZFxuICAgICAqIEByZXR1cm5zIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYUVsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGF1ZGlvVHJhY2suZGV0YWNoKCcjbXktdmlkZW8tZWxlbWVudCcpLnJlbW92ZSgpO1xuICAgICAqL1xuICAgIEF1ZGlvVHJhY2sucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZGV0YWNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICByZXR1cm4gQXVkaW9UcmFjaztcbn0oTWVkaWFUcmFjaykpO1xuLyoqXG4gKiBUaGUge0BsaW5rIEF1ZGlvVHJhY2t9IHdhcyBkaXNhYmxlZCwgaS5lLiBcIm11dGVkXCIuXG4gKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBBdWRpb1RyYWNrfSB0aGF0IHdhcyBkaXNhYmxlZFxuICogQGV2ZW50IEF1ZGlvVHJhY2sjZGlzYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIEF1ZGlvVHJhY2t9IHdhcyBlbmFibGVkLCBpLmUuIFwidW5tdXRlZFwiLlxuICogQHBhcmFtIHtBdWRpb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgQXVkaW9UcmFja30gdGhhdCB3YXMgZW5hYmxlZFxuICogQGV2ZW50IEF1ZGlvVHJhY2sjZW5hYmxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgQXVkaW9UcmFja30gc3RhcnRlZC4gVGhpcyBtZWFucyB0aGVyZSBpcyBlbm91Z2ggYXVkaW8gZGF0YSB0b1xuICogYmVnaW4gcGxheWJhY2suXG4gKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBBdWRpb1RyYWNrfSB0aGF0IHN0YXJ0ZWRcbiAqIEBldmVudCBBdWRpb1RyYWNrI3N0YXJ0ZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBdWRpb1RyYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXVkaW90cmFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBMb2NhbEF1ZGlvVHJhY2s6IHJlcXVpcmUoJy4vbG9jYWxhdWRpb3RyYWNrJyksXG4gICAgTG9jYWxWaWRlb1RyYWNrOiByZXF1aXJlKCcuL2xvY2FsdmlkZW90cmFjaycpLFxuICAgIExvY2FsRGF0YVRyYWNrOiByZXF1aXJlKCcuL2xvY2FsZGF0YXRyYWNrJylcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8td2FybmluZy1jb21tZW50c1xuLy8gVE9ETyhtcm9iZXJ0cyk6IFJlbW92ZSB0aGlzIHdoZW4gd2UgZ28gdG8gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gVGhpcyBpc1xuLy8gb25seSBpbiBwbGFjZSBzbyB0aGF0IHdlIGNhbiBzdXBwb3J0IEVTNiBjbGFzc2VzIHdpdGhvdXQgcmVxdWlyaW5nIGBuZXdgLlxuJ3VzZSBzdHJpY3QnO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIExvY2FsQXVkaW9UcmFja0NsYXNzID0gcmVxdWlyZSgnLi4vbG9jYWxhdWRpb3RyYWNrJyk7XG5mdW5jdGlvbiBMb2NhbEF1ZGlvVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgb3B0aW9ucykge1xuICAgIHZhciB0cmFjayA9IG5ldyBMb2NhbEF1ZGlvVHJhY2tDbGFzcyhtZWRpYVN0cmVhbVRyYWNrLCBvcHRpb25zKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodHJhY2ssIExvY2FsQXVkaW9UcmFjay5wcm90b3R5cGUpO1xuICAgIHJldHVybiB0cmFjaztcbn1cbmluaGVyaXRzKExvY2FsQXVkaW9UcmFjaywgTG9jYWxBdWRpb1RyYWNrQ2xhc3MpO1xubW9kdWxlLmV4cG9ydHMgPSBMb2NhbEF1ZGlvVHJhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbGF1ZGlvdHJhY2suanMubWFwIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXdhcm5pbmctY29tbWVudHNcbi8vIFRPRE8obXJvYmVydHMpOiBSZW1vdmUgdGhpcyB3aGVuIHdlIGdvIHRvIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uIFRoaXMgaXNcbi8vIG9ubHkgaW4gcGxhY2Ugc28gdGhhdCB3ZSBjYW4gc3VwcG9ydCBFUzYgY2xhc3NlcyB3aXRob3V0IHJlcXVpcmluZyBgbmV3YC5cbid1c2Ugc3RyaWN0JztcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBMb2NhbERhdGFUcmFja0NsYXNzID0gcmVxdWlyZSgnLi4vbG9jYWxkYXRhdHJhY2snKTtcbmZ1bmN0aW9uIExvY2FsRGF0YVRyYWNrKG9wdGlvbnMpIHtcbiAgICB2YXIgdHJhY2sgPSBuZXcgTG9jYWxEYXRhVHJhY2tDbGFzcyhvcHRpb25zKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodHJhY2ssIExvY2FsRGF0YVRyYWNrLnByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHRyYWNrO1xufVxuaW5oZXJpdHMoTG9jYWxEYXRhVHJhY2ssIExvY2FsRGF0YVRyYWNrQ2xhc3MpO1xubW9kdWxlLmV4cG9ydHMgPSBMb2NhbERhdGFUcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsZGF0YXRyYWNrLmpzLm1hcCIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby13YXJuaW5nLWNvbW1lbnRzXG4vLyBUT0RPKG1yb2JlcnRzKTogUmVtb3ZlIHRoaXMgd2hlbiB3ZSBnbyB0byB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiBUaGlzIGlzXG4vLyBvbmx5IGluIHBsYWNlIHNvIHRoYXQgd2UgY2FuIHN1cHBvcnQgRVM2IGNsYXNzZXMgd2l0aG91dCByZXF1aXJpbmcgYG5ld2AuXG4ndXNlIHN0cmljdCc7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG52YXIgTG9jYWxWaWRlb1RyYWNrQ2xhc3MgPSByZXF1aXJlKCcuLi9sb2NhbHZpZGVvdHJhY2snKTtcbmZ1bmN0aW9uIExvY2FsVmlkZW9UcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIHRyYWNrID0gbmV3IExvY2FsVmlkZW9UcmFja0NsYXNzKG1lZGlhU3RyZWFtVHJhY2ssIG9wdGlvbnMpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0cmFjaywgTG9jYWxWaWRlb1RyYWNrLnByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHRyYWNrO1xufVxuaW5oZXJpdHMoTG9jYWxWaWRlb1RyYWNrLCBMb2NhbFZpZGVvVHJhY2tDbGFzcyk7XG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsVmlkZW9UcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsdmlkZW90cmFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50ZW1pdHRlcicpO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLCBidWlsZExvZ0xldmVscyA9IF9hLmJ1aWxkTG9nTGV2ZWxzLCB2YWx1ZVRvSlNPTiA9IF9hLnZhbHVlVG9KU09OO1xudmFyIERFRkFVTFRfTE9HX0xFVkVMID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25zdGFudHMnKS5ERUZBVUxUX0xPR19MRVZFTDtcbnZhciBMb2cgPSByZXF1aXJlKCcuLi8uLi91dGlsL2xvZycpO1xudmFyIG5JbnN0YW5jZXMgPSAwO1xuLyoqXG4gKiBBIHtAbGluayBUcmFja30gcmVwcmVzZW50cyBhIHN0cmVhbSBvZiBhdWRpbywgdmlkZW8sIG9yIGRhdGEuXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZCAtIFRoZSB7QGxpbmsgVHJhY2t9J3Mga2luZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUge0BsaW5rIFRyYWNrfSdzIG5hbWVcbiAqL1xudmFyIFRyYWNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFjaywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgVHJhY2t9LlxuICAgICAqIEBwYXJhbSB7VHJhY2suSUR9IGlkIC0gVGhlIHtAbGluayBUcmFja30ncyBJRFxuICAgICAqIEBwYXJhbSB7VHJhY2suS2luZH0ga2luZCAtIFRoZSB7QGxpbmsgVHJhY2t9J3Mga2luZFxuICAgICAqIEBwYXJhbSB7eyBsb2c6IExvZywgbmFtZTogP3N0cmluZyB9fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhY2soaWQsIGtpbmQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgbmFtZTogaWQsXG4gICAgICAgICAgICBsb2c6IG51bGwsXG4gICAgICAgICAgICBsb2dMZXZlbDogREVGQVVMVF9MT0dfTEVWRUxcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgdmFyIG5hbWUgPSBTdHJpbmcob3B0aW9ucy5uYW1lKTtcbiAgICAgICAgdmFyIGxvZ0xldmVscyA9IGJ1aWxkTG9nTGV2ZWxzKG9wdGlvbnMubG9nTGV2ZWwpO1xuICAgICAgICB2YXIgbG9nID0gb3B0aW9ucy5sb2dcbiAgICAgICAgICAgID8gb3B0aW9ucy5sb2cuY3JlYXRlTG9nKCdtZWRpYScsIF90aGlzKVxuICAgICAgICAgICAgOiBuZXcgTG9nKCdtZWRpYScsIF90aGlzLCBsb2dMZXZlbHMsIG9wdGlvbnMubG9nZ2VyTmFtZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfaW5zdGFuY2VJZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiArK25JbnN0YW5jZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9nOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGxvZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtpbmQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBraW5kXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVHJhY2sucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlVG9KU09OKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYWNrO1xufShFdmVudEVtaXR0ZXIpKTtcbi8qKlxuICogVGhlIHtAbGluayBUcmFja30gSUQgaXMgYSBzdHJpbmcgaWRlbnRpZmllciBmb3IgdGhlIHtAbGluayBUcmFja30uXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBUcmFjay5JRFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgVHJhY2t9IGtpbmQgaXMgZWl0aGVyIFwiYXVkaW9cIiwgXCJ2aWRlb1wiLCBvciBcImRhdGFcIi5cbiAqIEB0eXBlZGVmIHtzdHJpbmd9IFRyYWNrLktpbmRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFRyYWNrfSdzIHByaW9yaXR5IGNhbiBiZSBcImxvd1wiLCBcInN0YW5kYXJkXCIsIG9yIFwiaGlnaFwiLlxuICogQHR5cGVkZWYge3N0cmluZ30gVHJhY2suUHJpb3JpdHlcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFRyYWNrfSBTSUQgaXMgYSB1bmlxdWUgc3RyaW5nIGlkZW50aWZpZXIgZm9yIHRoZSB7QGxpbmsgVHJhY2t9XG4gKiB0aGF0IGlzIHB1Ymxpc2hlZCB0byBhIHtAbGluayBSb29tfS5cbiAqIEB0eXBlZGVmIHtzdHJpbmd9IFRyYWNrLlNJRFxuICovXG4vKipcbiAqIEEge0BsaW5rIERhdGFUcmFja30gaXMgYSB7QGxpbmsgTG9jYWxEYXRhVHJhY2t9IG9yIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9LlxuICogQHR5cGVkZWYge0xvY2FsRGF0YVRyYWNrfFJlbW90ZURhdGFUcmFja30gRGF0YVRyYWNrXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgTG9jYWxUcmFja30gaXMgYSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSwge0BsaW5rIExvY2FsVmlkZW9UcmFja30sXG4gKiBvciB7QGxpbmsgTG9jYWxEYXRhVHJhY2t9LlxuICogQHR5cGVkZWYge0xvY2FsQXVkaW9UcmFja3xMb2NhbFZpZGVvVHJhY2t8TG9jYWxEYXRhVHJhY2t9IExvY2FsVHJhY2tcbiAqL1xuLyoqXG4gKiB7QGxpbmsgTG9jYWxUcmFja30gb3B0aW9uc1xuICogQHR5cGVkZWYge29iamVjdH0gTG9jYWxUcmFja09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7TG9nTGV2ZWx8TG9nTGV2ZWxzfSBsb2dMZXZlbCAtIExvZyBsZXZlbCBmb3IgJ21lZGlhJyBtb2R1bGVzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIC0gVGhlIHtAbGluayBMb2NhbFRyYWNrfSdzIG5hbWU7IGJ5IGRlZmF1bHQsXG4gKiAgIGl0IGlzIHNldCB0byB0aGUge0BsaW5rIExvY2FsVHJhY2t9J3MgSUQuXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlVHJhY2t9IGlzIGEge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9LFxuICoge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9LCBvciB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfS5cbiAqIEB0eXBlZGVmIHtSZW1vdGVBdWRpb1RyYWNrfFJlbW90ZVZpZGVvVHJhY2t8UmVtb3RlRGF0YVRyYWNrfSBSZW1vdGVUcmFja1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFRyYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBBdWRpb1RyYWNrID0gcmVxdWlyZSgnLi9hdWRpb3RyYWNrJyk7XG52YXIgbWl4aW5Mb2NhbE1lZGlhVHJhY2sgPSByZXF1aXJlKCcuL2xvY2FsbWVkaWF0cmFjaycpO1xudmFyIExvY2FsTWVkaWFBdWRpb1RyYWNrID0gbWl4aW5Mb2NhbE1lZGlhVHJhY2soQXVkaW9UcmFjayk7XG4vKipcbiAqIEEge0BsaW5rIExvY2FsQXVkaW9UcmFja30gaXMgYW4ge0BsaW5rIEF1ZGlvVHJhY2t9IHJlcHJlc2VudGluZyBhdWRpbyB0aGF0XG4gKiB5b3VyIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBjYW4gcHVibGlzaCB0byBhIHtAbGluayBSb29tfS4gSXQgY2FuIGJlXG4gKiBlbmFibGVkIGFuZCBkaXNhYmxlZCB3aXRoIHtAbGluayBMb2NhbEF1ZGlvVHJhY2sjZW5hYmxlfSBhbmRcbiAqIHtAbGluayBMb2NhbEF1ZGlvVHJhY2sjZGlzYWJsZX0gb3Igc3RvcHBlZCBjb21wbGV0ZWx5IHdpdGhcbiAqIHtAbGluayBMb2NhbEF1ZGlvVHJhY2sjc3RvcH0uXG4gKiBAZXh0ZW5kcyBBdWRpb1RyYWNrXG4gKiBAcHJvcGVydHkge1RyYWNrLklEfSBpZCAtIFRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSdzIElEXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU3RvcHBlZCAtIFdoZXRoZXIgb3Igbm90IHRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSBpc1xuICogICBzdG9wcGVkXG4gKiBAZW1pdHMgTG9jYWxBdWRpb1RyYWNrI2Rpc2FibGVkXG4gKiBAZW1pdHMgTG9jYWxBdWRpb1RyYWNrI2VuYWJsZWRcbiAqIEBlbWl0cyBMb2NhbEF1ZGlvVHJhY2sjc3RhcnRlZFxuICogQGVtaXRzIExvY2FsQXVkaW9UcmFjayNzdG9wcGVkXG4gKi9cbnZhciBMb2NhbEF1ZGlvVHJhY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvY2FsQXVkaW9UcmFjaywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSBmcm9tIGEgTWVkaWFTdHJlYW1UcmFjay5cbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IG1lZGlhU3RyZWFtVHJhY2sgLSBBbiBhdWRpbyBNZWRpYVN0cmVhbVRyYWNrXG4gICAgICogQHBhcmFtIHtMb2NhbFRyYWNrT3B0aW9uc30gW29wdGlvbnNdIC0ge0BsaW5rIExvY2FsVHJhY2t9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2NhbEF1ZGlvVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbWVkaWFTdHJlYW1UcmFjaywgb3B0aW9ucykgfHwgdGhpcztcbiAgICB9XG4gICAgTG9jYWxBdWRpb1RyYWNrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW0xvY2FsQXVkaW9UcmFjayAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgdGhpcy5pZCArIFwiXVwiO1xuICAgIH07XG4gICAgTG9jYWxBdWRpb1RyYWNrLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwgPSBfc3VwZXIucHJvdG90eXBlLmF0dGFjaC5jYWxsKHRoaXMsIGVsKTtcbiAgICAgICAgZWwubXV0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIExvY2FsQXVkaW9UcmFjay5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB0aGUge0BsaW5rIExvY2FsQXVkaW9UcmFja30uIFRoaXMgaXMgZWZmZWN0aXZlbHkgXCJtdXRlXCIuXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGZpcmVzIExvY2FsQXVkaW9UcmFjayNkaXNhYmxlZFxuICAgICAqL1xuICAgIExvY2FsQXVkaW9UcmFjay5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZGlzYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfS4gVGhpcyBpcyBlZmZlY3RpdmVseSBcInVubXV0ZVwiLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBmaXJlcyBMb2NhbEF1ZGlvVHJhY2sjZW5hYmxlZFxuICAgICovIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfS4gVGhpcyBpcyBlZmZlY3RpdmVseSBcInVubXV0ZVwiXG4gICAgICogb3IgXCJtdXRlXCIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZW5hYmxlZF0gLSBTcGVjaWZ5IGZhbHNlIHRvIG11dGUgdGhlXG4gICAgICogICB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfVxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBmaXJlcyBMb2NhbEF1ZGlvVHJhY2sjZGlzYWJsZWRcbiAgICAgKiBAZmlyZXMgTG9jYWxBdWRpb1RyYWNrI2VuYWJsZWRcbiAgICAgKi9cbiAgICBMb2NhbEF1ZGlvVHJhY2sucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZW5hYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXN0YXJ0IHRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfS4gVGhpcyBzdG9wcyB0aGUgZXhpc3RpbmcgTWVkaWFTdHJlYW1UcmFja1xuICAgICAqIGFuZCBjcmVhdGVzIGEgbmV3IE1lZGlhU3RyZWFtVHJhY2suIElmIHRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSBpcyBiZWluZyBwdWJsaXNoZWRcbiAgICAgKiB0byBhIHtAbGluayBSb29tfSwgdGhlbiBhbGwgdGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH1zIHdpbGwgc3RhcnQgcmVjZWl2aW5nIG1lZGlhXG4gICAgICogZnJvbSB0aGUgbmV3bHkgY3JlYXRlZCBNZWRpYVN0cmVhbVRyYWNrLiBZb3UgY2FuIGFjY2VzcyB0aGUgbmV3IE1lZGlhU3RyZWFtVHJhY2sgdmlhXG4gICAgICogdGhlIDxjb2RlPm1lZGlhU3RyZWFtVHJhY2s8L2NvZGU+IHByb3BlcnR5LiBJZiB5b3Ugd2FudCB0byBsaXN0ZW4gdG8gZXZlbnRzIG9uXG4gICAgICogdGhlIE1lZGlhU3RyZWFtVHJhY2sgZGlyZWN0bHksIHBsZWFzZSBkbyBzbyBpbiB0aGUgXCJzdGFydGVkXCIgZXZlbnQgaGFuZGxlci4gQWxzbyxcbiAgICAgKiB0aGUge0BsaW5rIExvY2FsQXVkaW9UcmFja30ncyBJRCBpcyBubyBsb25nZXIgZ3VhcmFudGVlZCB0byBiZSB0aGUgc2FtZSBhcyB0aGVcbiAgICAgKiB1bmRlcmx5aW5nIE1lZGlhU3RyZWFtVHJhY2sncyBJRC5cbiAgICAgKiBAcGFyYW0ge01lZGlhVHJhY2tDb25zdHJhaW50c30gW2NvbnN0cmFpbnRzXSAtIFRoZSBvcHRpb25hbCA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhVHJhY2tDb25zdHJhaW50c1wiIHRhcmdldD1cIl9ibGFua1wiPk1lZGlhVHJhY2tDb25zdHJhaW50czwvYT5cbiAgICAgKiAgIGZvciByZXN0YXJ0aW5nIHRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfTsgSWYgbm90IHNwZWNpZmllZCwgdGhlbiB0aGUgY3VycmVudCBNZWRpYVRyYWNrQ29uc3RyYWludHNcbiAgICAgKiAgIHdpbGwgYmUgdXNlZDsgSWYgPGNvZGU+e308L2NvZGU+IChlbXB0eSBvYmplY3QpIGlzIHNwZWNpZmllZCwgdGhlbiB0aGUgZGVmYXVsdCBNZWRpYVRyYWNrQ29uc3RyYWludHNcbiAgICAgKiAgIHdpbGwgYmUgdXNlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZWplY3RzIHdpdGggYSBUeXBlRXJyb3IgaWYgdGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IHdhcyBub3QgY3JlYXRlZFxuICAgICAqICAgdXNpbmcgYW4gb25lIG9mIDxjb2RlPmNyZWF0ZUxvY2FsQXVkaW9UcmFjazwvY29kZT4sIDxjb2RlPmNyZWF0ZUxvY2FsVHJhY2tzPC9jb2RlPiBvciA8Y29kZT5jb25uZWN0PC9jb2RlPjtcbiAgICAgKiAgIEFsc28gcmVqZWN0cyB3aXRoIHRoZSA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhRGV2aWNlcy9nZXRVc2VyTWVkaWEjRXhjZXB0aW9uc1wiIHRhcmdldD1cIl9ibGFua1wiPkRPTUV4Y2VwdGlvbjwvYT5cbiAgICAgKiAgIHJhaXNlZCBieSA8Y29kZT5nZXRVc2VyTWVkaWE8L2NvZGU+IHdoZW4gaXQgZmFpbHNcbiAgICAgKiBAZmlyZXMgTG9jYWxBdWRpb1RyYWNrI3N0b3BwZWRcbiAgICAgKiBAZmlyZXMgTG9jYWxBdWRpb1RyYWNrI3N0YXJ0ZWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHsgY29ubmVjdCwgY3JlYXRlTG9jYWxBdWRpb1RyYWNrIH0gPSByZXF1aXJlKCd0d2lsaW8tdmlkZW8nKTtcbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBhIExvY2FsQXVkaW9UcmFjayB0aGF0IGNhcHR1cmVzIGF1ZGlvIGZyb20gYSBVU0IgbWljcm9waG9uZS5cbiAgICAgKiBjcmVhdGVMb2NhbEF1ZGlvVHJhY2soeyBkZXZpY2VJZDogJ3VzYi1taWMtaWQnIH0pLnRoZW4oZnVuY3Rpb24obG9jYWxBdWRpb1RyYWNrKSB7XG4gICAgICogICByZXR1cm4gY29ubmVjdCgndG9rZW4nLCB7XG4gICAgICogICAgIG5hbWU6ICdteS1jb29sLXJvb20nLFxuICAgICAqICAgICB0cmFja3M6IFtsb2NhbEF1ZGlvVHJhY2tdXG4gICAgICogICB9KTtcbiAgICAgKiB9KS50aGVuKGZ1bmN0aW9uKHJvb20pIHtcbiAgICAgKiAgIC8vIFJlc3RhcnQgdGhlIExvY2FsQXVkaW9UcmFjayB0byBjYXB0dXJlIGF1ZGlvIGZyb20gdGhlIGRlZmF1bHQgbWljcm9waG9uZS5cbiAgICAgKiAgIGNvbnN0IGxvY2FsQXVkaW9UcmFjayA9IEFycmF5LmZyb20ocm9vbS5sb2NhbFBhcnRpY2lwYW50LmF1ZGlvVHJhY2tzLnZhbHVlcygpKVswXS50cmFjaztcbiAgICAgKiAgIHJldHVybiBsb2NhbEF1ZGlvVHJhY2sucmVzdGFydCh7IGRldmljZUlkOiAnZGVmYXVsdC1taWMtaWQnIH0pO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIExvY2FsQXVkaW9UcmFjay5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVzdGFydC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbHMgc3RvcCBvbiB0aGUgdW5kZXJseWluZyBNZWRpYVN0cmVhbVRyYWNrLiBJZiB5b3UgY2hvb3NlIHRvIHN0b3AgYVxuICAgICAqIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9LCB5b3Ugc2hvdWxkIHVucHVibGlzaCBpdCBhZnRlciBzdG9wcGluZy5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAZmlyZXMgTG9jYWxBdWRpb1RyYWNrI3N0b3BwZWRcbiAgICAgKi9cbiAgICBMb2NhbEF1ZGlvVHJhY2sucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnN0b3AuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHJldHVybiBMb2NhbEF1ZGlvVHJhY2s7XG59KExvY2FsTWVkaWFBdWRpb1RyYWNrKSk7XG4vKipcbiAqIFRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSB3YXMgZGlzYWJsZWQsIGkuZS4gXCJtdXRlZFwiLlxuICogQHBhcmFtIHtMb2NhbEF1ZGlvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IHRoYXQgd2FzXG4gKiAgIGRpc2FibGVkXG4gKiBAZXZlbnQgTG9jYWxBdWRpb1RyYWNrI2Rpc2FibGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IHdhcyBlbmFibGVkLCBpLmUuIFwidW5tdXRlZFwiLlxuICogQHBhcmFtIHtMb2NhbEF1ZGlvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IHRoYXQgd2FzIGVuYWJsZWRcbiAqIEBldmVudCBMb2NhbEF1ZGlvVHJhY2sjZW5hYmxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSBzdGFydGVkLiBUaGlzIG1lYW5zIHRoZXJlIGlzIGVub3VnaCBhdWRpbyBkYXRhIHRvXG4gKiBiZWdpbiBwbGF5YmFjay5cbiAqIEBwYXJhbSB7TG9jYWxBdWRpb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSB0aGF0IHN0YXJ0ZWRcbiAqIEBldmVudCBMb2NhbEF1ZGlvVHJhY2sjc3RhcnRlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSBzdG9wcGVkLCBlaXRoZXIgYmVjYXVzZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrI3N0b3B9XG4gKiBvciB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrI3Jlc3RhcnR9IHdhcyBjYWxsZWQgb3IgYmVjYXVzZSB0aGUgdW5kZXJseWluZ1xuICogTWVkaWFTdHJlYW1UcmFjayBlbmRlZC5cbiAqIEBwYXJhbSB7TG9jYWxBdWRpb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrfSB0aGF0IHN0b3BwZWRcbiAqIEBldmVudCBMb2NhbEF1ZGlvVHJhY2sjc3RvcHBlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsQXVkaW9UcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsYXVkaW90cmFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIExvY2FsVHJhY2tQdWJsaWNhdGlvbiA9IHJlcXVpcmUoJy4vbG9jYWx0cmFja3B1YmxpY2F0aW9uJyk7XG4vKipcbiAqIEEge0BsaW5rIExvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9ufSBpcyBhIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IHRoYXQgaGFzXG4gKiBiZWVuIHB1Ymxpc2hlZCB0byBhIHtAbGluayBSb29tfS5cbiAqIEBleHRlbmRzIExvY2FsVHJhY2tQdWJsaWNhdGlvblxuICogQHByb3BlcnR5IHtUcmFjay5LaW5kfSBraW5kIC0gXCJhdWRpb1wiXG4gKiBAcHJvcGVydHkge0xvY2FsQXVkaW9UcmFja30gdHJhY2sgLSB0aGUge0BsaW5rIExvY2FsQXVkaW9UcmFja31cbiAqL1xudmFyIExvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhbEF1ZGlvVHJhY2tQdWJsaWNhdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb259LlxuICAgICAqIEBwYXJhbSB7TG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfSBzaWduYWxpbmcgLSBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqICAge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ31cbiAgICAgKiBAcGFyYW0ge0xvY2FsQXVkaW9UcmFja30gdHJhY2sgLSB0aGUge0BsaW5rIExvY2FsQXVkaW9UcmFja31cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKExvY2FsVHJhY2tQdWJsaWNhdGlvbik6IHZvaWR9IHVucHVibGlzaCAtIFRoZSBjYWxsYmFja1xuICAgICAqICAgIHRoYXQgdW5wdWJsaXNoZXMgdGhlIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb259XG4gICAgICogQHBhcmFtIHtUcmFja1B1YmxpY2F0aW9uT3B0aW9uc30gb3B0aW9ucyAtIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb259IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2NhbEF1ZGlvVHJhY2tQdWJsaWNhdGlvbihzaWduYWxpbmcsIHRyYWNrLCB1bnB1Ymxpc2gsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNpZ25hbGluZywgdHJhY2ssIHVucHVibGlzaCwgb3B0aW9ucykgfHwgdGhpcztcbiAgICB9XG4gICAgTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb24gI1wiICsgdGhpcy5faW5zdGFuY2VJZCArIFwiOiBcIiArIHRoaXMudHJhY2tTaWQgKyBcIl1cIjtcbiAgICB9O1xuICAgIHJldHVybiBMb2NhbEF1ZGlvVHJhY2tQdWJsaWNhdGlvbjtcbn0oTG9jYWxUcmFja1B1YmxpY2F0aW9uKSk7XG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsQXVkaW9UcmFja1B1YmxpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxhdWRpb3RyYWNrcHVibGljYXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBUcmFjayA9IHJlcXVpcmUoJy4vJyk7XG52YXIgRGVmYXVsdERhdGFUcmFja1NlbmRlciA9IHJlcXVpcmUoJy4uLy4uL2RhdGEvc2VuZGVyJyk7XG4vKipcbiAqIEEge0BsaW5rIExvY2FsRGF0YVRyYWNrfSBpcyBhIHtAbGluayBUcmFja30gcmVwcmVzZW50aW5nIGRhdGEgdGhhdCB5b3VyXG4gKiB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gY2FuIHB1Ymxpc2ggdG8gYSB7QGxpbmsgUm9vbX0uXG4gKiBAZXh0ZW5kcyBUcmFja1xuICogQHByb3BlcnR5IHtUcmFjay5JRH0gaWQgLSBUaGUge0BsaW5rIExvY2FsRGF0YVRyYWNrfSdzIElEXG4gKiBAcHJvcGVydHkge1RyYWNrLktpbmR9IGtpbmQgLSBcImRhdGFcIlxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBtYXhQYWNrZXRMaWZlVGltZSAtIElmIG5vbi1udWxsLCB0aGlzIHJlcHJlc2VudHMgYSB0aW1lXG4gKiAgIGxpbWl0IChpbiBtaWxsaXNlY29uZHMpIGR1cmluZyB3aGljaCB0aGUge0BsaW5rIExvY2FsRGF0YVRyYWNrfSB3aWxsIHNlbmRcbiAqICAgb3IgcmUtc2VuZCBkYXRhIGlmIG5vdCBhY2tub3dsZWRnZWQgb24gdGhlIHVuZGVybHlpbmcgUlRDRGF0YUNoYW5uZWwocykuXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IG1heFJldHJhbnNtaXRzIC0gSWYgbm9uLW51bGwsIHRoaXMgcmVwcmVzZW50cyB0aGUgbnVtYmVyXG4gKiAgIG9mIHRpbWVzIHRoZSB7QGxpbmsgTG9jYWxEYXRhVHJhY2t9IHdpbGwgcmVzZW5kIGRhdGEgaWYgbm90IHN1Y2Nlc3NmdWxseVxuICogICBkZWxpdmVyZWQgb24gdGhlIHVuZGVybHlpbmcgUlRDRGF0YUNoYW5uZWwocykuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9yZGVyZWQgLSB0cnVlIGlmIGRhdGEgb24gdGhlIHtAbGluayBMb2NhbERhdGFUcmFja30gaXNcbiAqICAgZ3VhcmFudGVlZCB0byBiZSBzZW50IGluIG9yZGVyLlxuICogQHByb3BlcnR5IHtib29sZWFufSByZWxpYWJsZSAtIFRoaXMgaXMgdHJ1ZSBpZiBib3RoXG4gKiAgIDxjb2RlPm1heFBhY2tldExpZmVUaW1lPC9jb2RlPiBhbmQgPGNvZGU+bWF4UmV0cmFuc21pdHM8L2NvZGU+IGFyZSBzZXQgdG9cbiAqICAgbnVsbC4gSW4gb3RoZXIgd29yZHMsIGlmIHRoaXMgaXMgdHJ1ZSwgdGhlcmUgaXMgbm8gYm91bmQgb24gcGFja2V0IGxpZmV0aW1lXG4gKiAgIG9yIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIHtAbGluayBMb2NhbERhdGFUcmFja30gd2lsbCBhdHRlbXB0IHRvIHNlbmRcbiAqICAgZGF0YSwgZW5zdXJpbmcgXCJyZWxpYWJsZVwiIHRyYW5zbWlzc2lvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgVmlkZW8gPSByZXF1aXJlKCd0d2lsaW8tdmlkZW8nKTtcbiAqXG4gKiB2YXIgbG9jYWxEYXRhVHJhY2sgPSBuZXcgVmlkZW8uTG9jYWxEYXRhVHJhY2soKTtcbiAqIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbihldmVudCkge1xuICogICBsb2NhbERhdGFUcmFjay5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAqICAgICB4OiBlLmNsaWVudFgsXG4gKiAgICAgeTogZS5jbGllbnRZXG4gKiAgIH0pKTtcbiAqIH0pO1xuICpcbiAqIHZhciB0b2tlbjEgPSBnZXRBY2Nlc3NUb2tlbigpO1xuICogVmlkZW8uY29ubmVjdCh0b2tlbjEsIHtcbiAqICAgbmFtZTogJ215LWNvb2wtcm9vbScsXG4gKiAgIHRyYWNrczogW2xvY2FsRGF0YVRyYWNrXVxuICogfSk7XG4gKlxuICogdmFyIHRva2VuMiA9IGdldEFjY2Vzc1Rva2VuKCk7XG4gKiBWaWRlby5jb25uZWN0KHRva2VuMiwge1xuICogICBuYW1lOiAnbXktY29vbC1yb29tJyxcbiAqICAgdHJhY2tzOiBbXVxuICogfSkudGhlbihmdW5jdGlvbihyb29tKSB7XG4gKiAgIHJvb20ub24oJ3RyYWNrU3Vic2NyaWJlZCcsIGZ1bmN0aW9uKHRyYWNrKSB7XG4gKiAgICAgdHJhY2sub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhKU09OLnBhcnNlKG1lc3NhZ2UpKTsgLy8geyB4OiA8bnVtYmVyPiwgeTogPG51bWJlcj4gfVxuICogICAgIH0pO1xuICogICB9KTtcbiAqIH0pO1xuICovXG52YXIgTG9jYWxEYXRhVHJhY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvY2FsRGF0YVRyYWNrLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBMb2NhbERhdGFUcmFja30uXG4gICAgICogQHBhcmFtIHtMb2NhbERhdGFUcmFja09wdGlvbnN9IFtvcHRpb25zXSAtIHtAbGluayBMb2NhbERhdGFUcmFja30gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvY2FsRGF0YVRyYWNrKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgRGF0YVRyYWNrU2VuZGVyOiBEZWZhdWx0RGF0YVRyYWNrU2VuZGVyLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IG51bGwsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0czogbnVsbCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IHRydWVcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBEYXRhVHJhY2tTZW5kZXIgPSBvcHRpb25zLkRhdGFUcmFja1NlbmRlcjtcbiAgICAgICAgdmFyIGRhdGFUcmFja1NlbmRlciA9IG5ldyBEYXRhVHJhY2tTZW5kZXIob3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSwgb3B0aW9ucy5tYXhSZXRyYW5zbWl0cywgb3B0aW9ucy5vcmRlcmVkKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkYXRhVHJhY2tTZW5kZXIuaWQsICdkYXRhJywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF90cmFja1NlbmRlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhVHJhY2tTZW5kZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFUcmFja1NlbmRlci5pZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5tYXhSZXRyYW5zbWl0c1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9yZGVyZWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLm9yZGVyZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWxpYWJsZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMubWF4UGFja2V0TGlmZVRpbWUgPT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgJiYgb3B0aW9ucy5tYXhSZXRyYW5zbWl0cyA9PT0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSBvdmVyIHRoZSB7QGxpbmsgTG9jYWxEYXRhVHJhY2t9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEJsb2J8QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBkYXRhXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgTG9jYWxEYXRhVHJhY2sucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLl90cmFja1NlbmRlci5zZW5kKGRhdGEpO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2FsRGF0YVRyYWNrO1xufShUcmFjaykpO1xuLyoqXG4gKiB7QGxpbmsgTG9jYWxEYXRhVHJhY2t9IG9wdGlvbnNcbiAqIEB0eXBlZGVmIHtMb2NhbFRyYWNrT3B0aW9uc30gTG9jYWxEYXRhVHJhY2tPcHRpb25zXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IFttYXhQYWNrZXRMaWZlVGltZT1udWxsXSAtIFNldCB0aGlzIHRvIGxpbWl0IHRoZSB0aW1lXG4gKiAgIChpbiBtaWxsaXNlY29uZHMpIGR1cmluZyB3aGljaCB0aGUgTG9jYWxEYXRhVHJhY2sgd2lsbCBzZW5kIG9yIHJlLXNlbmQgZGF0YVxuICogICBpZiBub3Qgc3VjY2Vzc2Z1bGx5IGRlbGl2ZXJlZCBvbiB0aGUgdW5kZXJseWluZyBSVENEYXRhQ2hhbm5lbChzKS4gSXQgaXMgYW5cbiAqICAgZXJyb3IgdG8gc3BlY2lmeSBib3RoIHRoaXMgYW5kIDxjb2RlPm1heFJldHJhbnNtaXRzPC9jb2RlPi5cbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gW21heFJldHJhbnNtaXRzPW51bGxdIC0gU2V0IHRoaXMgdG8gbGltaXQgdGhlIG51bWJlciBvZlxuICogICB0aW1lcyB0aGUge0BsaW5rIExvY2FsRGF0YVRyYWNrfSB3aWxsIHNlbmQgb3IgcmUtc2VuZCBkYXRhIGlmIG5vdFxuICogICBhY2tub3dsZWRnZWQgb24gdGhlIHVuZGVybHlpbmcgUlRDRGF0YUNoYW5uZWwocykuIEl0IGlzIGFuIGVycm9yIHRvIHNwZWNpZnlcbiAqICAgYm90aCB0aGlzIGFuZCA8Y29kZT5tYXhQYWNrZXRMaWZlVGltZTwvY29kZT4uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcmRlcmVkPXRydWVdIC0gU2V0IHRoaXMgdG8gZmFsc2UgdG8gYWxsb3cgZGF0YSBvbiB0aGVcbiAqICAgTG9jYWxEYXRhVHJhY2sgdG8gYmUgc2VudCBvdXQtb2Ytb3JkZXIuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxEYXRhVHJhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbGRhdGF0cmFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIExvY2FsVHJhY2tQdWJsaWNhdGlvbiA9IHJlcXVpcmUoJy4vbG9jYWx0cmFja3B1YmxpY2F0aW9uJyk7XG4vKipcbiAqIEEge0BsaW5rIExvY2FsRGF0YVRyYWNrUHVibGljYXRpb259IGlzIGEge0BsaW5rIExvY2FsRGF0YVRyYWNrfSB0aGF0IGhhcyBiZWVuXG4gKiBwdWJsaXNoZWQgdG8gYSB7QGxpbmsgUm9vbX0uXG4gKiBAZXh0ZW5kcyBMb2NhbFRyYWNrUHVibGljYXRpb25cbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZCAtIFwiZGF0YVwiXG4gKiBAcHJvcGVydHkge0xvY2FsRGF0YVRyYWNrfSB0cmFjayAtIHRoZSB7QGxpbmsgTG9jYWxEYXRhVHJhY2t9XG4gKi9cbnZhciBMb2NhbERhdGFUcmFja1B1YmxpY2F0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhbERhdGFUcmFja1B1YmxpY2F0aW9uLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBMb2NhbERhdGFUcmFja1B1YmxpY2F0aW9ufS5cbiAgICAgKiBAcGFyYW0ge0xvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ30gc2lnbmFsaW5nIC0gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9XG4gICAgICogQHBhcmFtIHtMb2NhbERhdGFUcmFja30gdHJhY2sgLSB0aGUge0BsaW5rIExvY2FsRGF0YVRyYWNrfVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oTG9jYWxUcmFja1B1YmxpY2F0aW9uKTogdm9pZH0gdW5wdWJsaXNoIC0gVGhlIGNhbGxiYWNrXG4gICAgICogICAgdGhhdCB1bnB1Ymxpc2hlcyB0aGUge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn1cbiAgICAgKiBAcGFyYW0ge1RyYWNrUHVibGljYXRpb25PcHRpb25zfSBvcHRpb25zIC0ge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvY2FsRGF0YVRyYWNrUHVibGljYXRpb24oc2lnbmFsaW5nLCB0cmFjaywgdW5wdWJsaXNoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzaWduYWxpbmcsIHRyYWNrLCB1bnB1Ymxpc2gsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgfVxuICAgIExvY2FsRGF0YVRyYWNrUHVibGljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvbiAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgdGhpcy50cmFja1NpZCArIFwiXVwiO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2FsRGF0YVRyYWNrUHVibGljYXRpb247XG59KExvY2FsVHJhY2tQdWJsaWNhdGlvbikpO1xubW9kdWxlLmV4cG9ydHMgPSBMb2NhbERhdGFUcmFja1B1YmxpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxkYXRhdHJhY2twdWJsaWNhdGlvbi5qcy5tYXAiLCIvKiBlc2xpbnQgbmV3LWNhcDowICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIGdldFVzZXJNZWRpYSA9IHJlcXVpcmUoJ0B0d2lsaW8vd2VicnRjJykuZ2V0VXNlck1lZGlhO1xudmFyIGd1ZXNzQnJvd3NlciA9IHJlcXVpcmUoJ0B0d2lsaW8vd2VicnRjL2xpYi91dGlsJykuZ3Vlc3NCcm93c2VyO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLCBjYXBpdGFsaXplID0gX2EuY2FwaXRhbGl6ZSwgZGVmZXIgPSBfYS5kZWZlciwgd2FpdEZvclNvbWV0aW1lID0gX2Eud2FpdEZvclNvbWV0aW1lLCB3YWl0Rm9yRXZlbnQgPSBfYS53YWl0Rm9yRXZlbnQ7XG52YXIgSUxMRUdBTF9JTlZPS0UgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbnN0YW50cycpLnR5cGVFcnJvcnMuSUxMRUdBTF9JTlZPS0U7XG52YXIgZGV0ZWN0U2lsZW50QXVkaW8gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RldGVjdHNpbGVudGF1ZGlvJyk7XG52YXIgZGV0ZWN0U2lsZW50VmlkZW8gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RldGVjdHNpbGVudHZpZGVvJyk7XG52YXIgZG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9jdW1lbnR2aXNpYmlsaXR5bW9uaXRvci5qcycpO1xudmFyIGxvY2FsTWVkaWFSZXN0YXJ0RGVmZXJyZWRzID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9sb2NhbG1lZGlhcmVzdGFydGRlZmVycmVkcycpO1xudmFyIGdVTVNpbGVudFRyYWNrV29ya2Fyb3VuZCA9IHJlcXVpcmUoJy4uLy4uL3dlYmF1ZGlvL3dvcmthcm91bmQxODA3NDgnKTtcbnZhciBNZWRpYVRyYWNrU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXInKTtcbmZ1bmN0aW9uIG1peGluTG9jYWxNZWRpYVRyYWNrKEF1ZGlvT3JWaWRlb1RyYWNrKSB7XG4gICAgLyoqXG4gICAgICogQSB7QGxpbmsgTG9jYWxNZWRpYVRyYWNrfSByZXByZXNlbnRzIGF1ZGlvIG9yIHZpZGVvIHRoYXQgeW91clxuICAgICAqIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBpcyBzZW5kaW5nIHRvIGEge0BsaW5rIFJvb219LiBBcyBzdWNoLCBpdCBjYW4gYmVcbiAgICAgKiBlbmFibGVkIGFuZCBkaXNhYmxlZCB3aXRoIHtAbGluayBMb2NhbE1lZGlhVHJhY2sjZW5hYmxlfSBhbmRcbiAgICAgKiB7QGxpbmsgTG9jYWxNZWRpYVRyYWNrI2Rpc2FibGV9IG9yIHN0b3BwZWQgY29tcGxldGVseSB3aXRoXG4gICAgICoge0BsaW5rIExvY2FsTWVkaWFUcmFjayNzdG9wfS5cbiAgICAgKiBAZW1pdHMgTG9jYWxNZWRpYVRyYWNrI3N0b3BwZWRcbiAgICAgKi9cbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoTG9jYWxNZWRpYVRyYWNrLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEge0BsaW5rIExvY2FsTWVkaWFUcmFja30gZnJvbSBhIE1lZGlhU3RyZWFtVHJhY2suXG4gICAgICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gbWVkaWFTdHJlYW1UcmFjayAtIFRoZSB1bmRlcmx5aW5nIE1lZGlhU3RyZWFtVHJhY2tcbiAgICAgICAgICogQHBhcmFtIHtMb2NhbFRyYWNrT3B0aW9uc30gW29wdGlvbnNdIC0ge0BsaW5rIExvY2FsVHJhY2t9IG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIExvY2FsTWVkaWFUcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IGJ5IGRlZmF1bHQgd29ya2Fyb3VuZCBmb3IgV2ViS2l0QnVnMTIwODUxNiB3aWxsIGJlIGVuYWJsZWQgb24gU2FmYXJpIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyBhbHRob3VnaCB0aGUgYnVnIGlzIHNlZW4gIG1haW5seSBvbiBpT1MgZGV2aWNlcywgd2UgZG8gbm90IGhhdmUgYSByZWxpYWJsZSB3YXkgdG8gdGVsbCBpT1MgZnJvbSBNYWNPc1xuICAgICAgICAgICAgLy8gdXNlckFnZW50IG9uIGlPUyBwcmV0ZW5kcyBpdHMgbWFjT3MgaWYgU2FmYXJpIGlzIHNldCB0byByZXF1ZXN0IGRlc2t0b3AgcGFnZXMuXG4gICAgICAgICAgICB2YXIgd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTYgPSBndWVzc0Jyb3dzZXIoKSA9PT0gJ3NhZmFyaSdcbiAgICAgICAgICAgICAgICAmJiB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgJiYgdHlwZW9mIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAmJiB0eXBlb2YgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnc3RyaW5nJztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBnZXRVc2VyTWVkaWE6IGdldFVzZXJNZWRpYSxcbiAgICAgICAgICAgICAgICBpc0NyZWF0ZWRCeUNyZWF0ZUxvY2FsVHJhY2tzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNjogd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTYsXG4gICAgICAgICAgICAgICAgZ1VNU2lsZW50VHJhY2tXb3JrYXJvdW5kOiBnVU1TaWxlbnRUcmFja1dvcmthcm91bmRcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIG1lZGlhVHJhY2tTZW5kZXIgPSBuZXcgTWVkaWFUcmFja1NlbmRlcihtZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgICAgIHZhciBraW5kID0gbWVkaWFUcmFja1NlbmRlci5raW5kO1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZWRpYVRyYWNrU2VuZGVyLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgICAgICBfY29uc3RyYWludHM6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR5cGVvZiBvcHRpb25zW2tpbmRdID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zW2tpbmRdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2dldFVzZXJNZWRpYToge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5nZXRVc2VyTWVkaWFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9nVU1TaWxlbnRUcmFja1dvcmthcm91bmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuZ1VNU2lsZW50VHJhY2tXb3JrYXJvdW5kXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTY6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMud29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTZcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF93b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNkNsZWFudXA6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZGlkQ2FsbEVuZDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfaXNDcmVhdGVkQnlDcmVhdGVMb2NhbFRyYWNrczoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5pc0NyZWF0ZWRCeUNyZWF0ZUxvY2FsVHJhY2tzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfdHJhY2tTZW5kZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1lZGlhVHJhY2tTZW5kZXJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZWRpYVRyYWNrU2VuZGVyLmlkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0VuYWJsZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVkaWFUcmFja1NlbmRlci5lbmFibGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1N0b3BwZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVkaWFUcmFja1NlbmRlci5yZWFkeVN0YXRlID09PSAnZW5kZWQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogQXMgYSB3b3JrYXJvdW5kIGZvciBXZWJLaXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NTE2LFxuICAgICAgICAgICAgLy8gdXBvbiBmb3JlZ3JvdW5kaW5nLCByZS1hY3F1aXJlIG5ldyBNZWRpYVN0cmVhbVRyYWNrIGlmIHRoZSBleGlzdGluZyBvbmUgaXMgZW5kZWQgb3IgbXV0ZWQuXG4gICAgICAgICAgICBpZiAoX3RoaXMuX3dvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3dvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2Q2xlYW51cCA9IHJlc3RhcnRXaGVuSW5hZHZlcnRlbnRseVN0b3BwZWQoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYWxNZWRpYVRyYWNrLnByb3RvdHlwZS5fZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RpZENhbGxFbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9lbmQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2RpZENhbGxFbmQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wcGVkJywgdGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYWxNZWRpYVRyYWNrLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaWRDYWxsRW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlkQ2FsbEVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5faW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIExvY2FsTWVkaWFUcmFjay5wcm90b3R5cGUuX3JlYWNxdWlyZVRyYWNrID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSB0aGlzLCBnZXRVc2VyTWVkaWEgPSBfYi5fZ2V0VXNlck1lZGlhLCBnVU1TaWxlbnRUcmFja1dvcmthcm91bmQgPSBfYi5fZ1VNU2lsZW50VHJhY2tXb3JrYXJvdW5kLCBsb2cgPSBfYi5fbG9nLCBraW5kID0gX2IubWVkaWFTdHJlYW1UcmFjay5raW5kO1xuICAgICAgICAgICAgbG9nLmluZm8oJ1JlLWFjcXVpcmluZyB0aGUgTWVkaWFTdHJlYW1UcmFjaycpO1xuICAgICAgICAgICAgbG9nLmRlYnVnKCdDb25zdHJhaW50czonLCBjb25zdHJhaW50cyk7XG4gICAgICAgICAgICB2YXIgZ1VNQ29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBhdWRpbzogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmlkZW86IGZhbHNlXG4gICAgICAgICAgICB9LCAoX2EgPSB7fSwgX2Fba2luZF0gPSBjb25zdHJhaW50cywgX2EpKTtcbiAgICAgICAgICAgIHZhciBnVU1Qcm9taXNlID0gdGhpcy5fd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTZDbGVhbnVwXG4gICAgICAgICAgICAgICAgPyBnVU1TaWxlbnRUcmFja1dvcmthcm91bmQobG9nLCBnZXRVc2VyTWVkaWEsIGdVTUNvbnN0cmFpbnRzKVxuICAgICAgICAgICAgICAgIDogZ2V0VXNlck1lZGlhKGdVTUNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBnVU1Qcm9taXNlLnRoZW4oZnVuY3Rpb24gKG1lZGlhU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhU3RyZWFtLmdldFRyYWNrcygpWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYWxNZWRpYVRyYWNrLnByb3RvdHlwZS5fcmVzdGFydCA9IGZ1bmN0aW9uIChjb25zdHJhaW50cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzIHx8IHRoaXMuX2NvbnN0cmFpbnRzO1xuICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogSWYgd2UgdHJ5IGFuZCByZXN0YXJ0IGEgc2lsZW50IE1lZGlhU3RyZWFtVHJhY2tcbiAgICAgICAgICAgIC8vIHdpdGhvdXQgc3RvcHBpbmcgaXQgZmlyc3QsIHRoZW4gYSBOb3RSZWFkYWJsZUVycm9yIGlzIHJhaXNlZCBpbiBjYXNlIG9mXG4gICAgICAgICAgICAvLyB2aWRlbywgb3IgdGhlIHJlc3RhcnRlZCBhdWRpbyB3aWxsIHN0aWxsIGJlIHNpbGVudC4gSGVuY2UsIHdlIHN0b3AgdGhlXG4gICAgICAgICAgICAvLyBNZWRpYVN0cmVhbVRyYWNrIGhlcmUuXG4gICAgICAgICAgICB0aGlzLl9zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhY3F1aXJlVHJhY2soY29uc3RyYWludHMpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcignRmFpbGVkIHRvIHJlLWFjcXVpcmUgdGhlIE1lZGlhU3RyZWFtVHJhY2s6JywgeyBlcnJvcjogZXJyb3IsIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50cyB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKG5ld01lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbygnUmUtYWNxdWlyZWQgdGhlIE1lZGlhU3RyZWFtVHJhY2snKTtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ01lZGlhU3RyZWFtVHJhY2s6JywgbmV3TWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NvbnN0cmFpbnRzID0gT2JqZWN0LmFzc2lnbih7fSwgY29uc3RyYWludHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2V0TWVkaWFTdHJlYW1UcmFjayhuZXdNZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIExvY2FsTWVkaWFUcmFjay5wcm90b3R5cGUuX3NldE1lZGlhU3RyZWFtVHJhY2sgPSBmdW5jdGlvbiAobWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBQcmVzZXJ2ZSB0aGUgdmFsdWUgb2YgdGhlIFwiZW5hYmxlZFwiIGZsYWcuXG4gICAgICAgICAgICBtZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSB0aGlzLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZDtcbiAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFN0b3AgdGhlIGN1cnJlbnQgTWVkaWFTdHJlYW1UcmFjay4gSWYgbm90IGFscmVhZHlcbiAgICAgICAgICAgIC8vIHN0b3BwZWQsIHRoaXMgc2hvdWxkIGZpcmUgYSBcInN0b3BwZWRcIiBldmVudC5cbiAgICAgICAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgICAgICAgIC8vIE5PVEUoY3NhbnRvcyk6IElmIHRoZXJlJ3MgYW4gdW5wcm9jZXNzZWRUcmFjaywgdGhpcyBtZWFucyBSVENSdHBTZW5kZXIgaGFzXG4gICAgICAgICAgICAvLyB0aGUgcHJvY2Vzc2VkVHJhY2sgYWxyZWFkeSBzZXQsIHdlIGRvbid0IHdhbnQgdG8gcmVwbGFjZSB0aGF0LlxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl91bnByb2Nlc3NlZFRyYWNrID8gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3VucHJvY2Vzc2VkVHJhY2sgPSBtZWRpYVN0cmVhbVRyYWNrO1xuICAgICAgICAgICAgfSkgOiB0aGlzLl90cmFja1NlbmRlci5zZXRNZWRpYVN0cmVhbVRyYWNrKG1lZGlhU3RyZWFtVHJhY2spLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9sb2cud2Fybignc2V0TWVkaWFTdHJlYW1UcmFjayBmYWlsZWQ6JywgeyBlcnJvcjogZXJyb3IsIG1lZGlhU3RyZWFtVHJhY2s6IG1lZGlhU3RyZWFtVHJhY2sgfSk7XG4gICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZ2V0QWxsQXR0YWNoZWRFbGVtZW50cygpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiBfdGhpcy5fYXR0YWNoKGVsKTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhbE1lZGlhVHJhY2sucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuX2VuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIExvY2FsTWVkaWFUcmFjay5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIGVuYWJsZWQgPSB0eXBlb2YgZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nID8gZW5hYmxlZCA6IHRydWU7XG4gICAgICAgICAgICBpZiAoZW5hYmxlZCAhPT0gdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuaW5mbygoZW5hYmxlZCA/ICdFbicgOiAnRGlzJykgKyBcImFibGluZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGVuYWJsZWQgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBMb2NhbE1lZGlhVHJhY2sucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmFibGUoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBMb2NhbE1lZGlhVHJhY2sucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAoY29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIga2luZCA9IHRoaXMua2luZDtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNDcmVhdGVkQnlDcmVhdGVMb2NhbFRyYWNrcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChJTExFR0FMX0lOVk9LRSgncmVzdGFydCcsICdjYW4gb25seSBiZSBjYWxsZWQgb24gYSdcbiAgICAgICAgICAgICAgICAgICAgKyAoXCIgTG9jYWxcIiArIGNhcGl0YWxpemUoa2luZCkgKyBcIlRyYWNrIHRoYXQgaXMgY3JlYXRlZCB1c2luZyBjcmVhdGVMb2NhbFRyYWNrc1wiKVxuICAgICAgICAgICAgICAgICAgICArIChcIiBvciBjcmVhdGVMb2NhbFwiICsgY2FwaXRhbGl6ZShraW5kKSArIFwiVHJhY2suXCIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTZDbGVhbnVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTZDbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTZDbGVhbnVwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcmVzdGFydChjb25zdHJhaW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTYpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3dvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2Q2xlYW51cCA9IHJlc3RhcnRXaGVuSW5hZHZlcnRlbnRseVN0b3BwZWQoX3RoaXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIExvY2FsTWVkaWFUcmFjay5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5pbmZvKCdTdG9wcGluZycpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2Q2xlYW51cCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2Q2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2Q2xlYW51cCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcCgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTG9jYWxNZWRpYVRyYWNrO1xuICAgIH0oQXVkaW9PclZpZGVvVHJhY2spKTtcbn1cbi8qKlxuICogUmVzdGFydCB0aGUgZ2l2ZW4ge0BsaW5rIExvY2FsTWVkaWFUcmFja30gaWYgaXQgaGFzIGJlZW4gaW5hZHZlcnRlbnRseSBzdG9wcGVkLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TG9jYWxBdWRpb1RyYWNrfExvY2FsVmlkZW9UcmFja30gbG9jYWxNZWRpYVRyYWNrXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IENsZWFuIHVwIGxpc3RlbmVycyBhdHRhY2hlZCBieSB0aGUgd29ya2Fyb3VuZFxuICovXG5mdW5jdGlvbiByZXN0YXJ0V2hlbkluYWR2ZXJ0ZW50bHlTdG9wcGVkKGxvY2FsTWVkaWFUcmFjaykge1xuICAgIHZhciBsb2cgPSBsb2NhbE1lZGlhVHJhY2suX2xvZywga2luZCA9IGxvY2FsTWVkaWFUcmFjay5raW5kO1xuICAgIHZhciBkZXRlY3RTaWxlbmNlID0geyBhdWRpbzogZGV0ZWN0U2lsZW50QXVkaW8sIHZpZGVvOiBkZXRlY3RTaWxlbnRWaWRlbyB9W2tpbmRdO1xuICAgIHZhciBlbCA9IGxvY2FsTWVkaWFUcmFjay5fZHVtbXlFbCwgbWVkaWFTdHJlYW1UcmFjayA9IGxvY2FsTWVkaWFUcmFjay5tZWRpYVN0cmVhbVRyYWNrO1xuICAgIHZhciB0cmFja0NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGNoZWNrU2lsZW5jZSgpIHtcbiAgICAgICAgLy8gVGhlIGR1bW15IGVsZW1lbnQgaXMgcGF1c2VkLCBzbyBwbGF5IGl0IGFuZCB0aGVuIGRldGVjdCBzaWxlbmNlLlxuICAgICAgICByZXR1cm4gZWwucGxheSgpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZGV0ZWN0U2lsZW5jZShlbCk7IH0pLnRoZW4oZnVuY3Rpb24gKGlzU2lsZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNTaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybignU2lsZW5jZSBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oJ05vbi1zaWxlbmNlIGRldGVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNTaWxlbnQ7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgbG9nLndhcm4oJ0ZhaWxlZCB0byBkZXRlY3Qgc2lsZW5jZTonLCBlcnJvcik7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUGF1c2UgdGhlIGR1bW15IGVsZW1lbnQgYWdhaW4uXG4gICAgICAgICAgICBlbC5wYXVzZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkUmVhY3F1aXJlVHJhY2soKSB7XG4gICAgICAgIHZhciBfd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTZDbGVhbnVwID0gbG9jYWxNZWRpYVRyYWNrLl93b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNkNsZWFudXAsIGlzU3RvcHBlZCA9IGxvY2FsTWVkaWFUcmFjay5pc1N0b3BwZWQsIG11dGVkID0gbG9jYWxNZWRpYVRyYWNrLm1lZGlhU3RyZWFtVHJhY2subXV0ZWQ7XG4gICAgICAgIHZhciBpc0luYWR2ZXJ0ZW50bHlTdG9wcGVkID0gaXNTdG9wcGVkICYmICEhX3dvcmthcm91bmRXZWJLaXRCdWcxMjA4NTE2Q2xlYW51cDtcbiAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogUmVzdGFydCB0aGUgTG9jYWxNZWRpYVRyYWNrIGlmOlxuICAgICAgICAvLyAxLiBUaGUgYXBwIGlzIGZvcmVncm91bmRlZCwgYW5kXG4gICAgICAgIC8vIDIuIEEgcmVzdGFydCBpcyBub3QgYWxyZWFkeSBpbiBwcm9ncmVzcywgYW5kXG4gICAgICAgIC8vIDMuIFRoZSBMb2NhbE1lZGlhVHJhY2sgaXMgZWl0aGVyIG11dGVkLCBpbmFkdmVydGVudGx5IHN0b3BwZWQgb3Igc2lsZW50XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgICYmICF0cmFja0NoYW5nZUluUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAmJiAobXV0ZWQgfHwgaXNJbmFkdmVydGVudGx5U3RvcHBlZCB8fCBjaGVja1NpbGVuY2UoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXliZVJlc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgd2FpdEZvckV2ZW50KG1lZGlhU3RyZWFtVHJhY2ssICd1bm11dGUnKSxcbiAgICAgICAgICAgIHdhaXRGb3JTb21ldGltZSg1MClcbiAgICAgICAgXSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBzaG91bGRSZWFjcXVpcmVUcmFjaygpOyB9KS50aGVuKGZ1bmN0aW9uIChzaG91bGRSZWFjcXVpcmUpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZWFjcXVpcmUgJiYgIXRyYWNrQ2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHRyYWNrQ2hhbmdlSW5Qcm9ncmVzcyA9IGRlZmVyKCk7XG4gICAgICAgICAgICAgICAgbG9jYWxNZWRpYVRyYWNrLl9yZXN0YXJ0KCkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsID0gbG9jYWxNZWRpYVRyYWNrLl9kdW1teUVsO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVNZWRpYVN0cmVhbVRyYWNrTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhU3RyZWFtVHJhY2sgPSBsb2NhbE1lZGlhVHJhY2subWVkaWFTdHJlYW1UcmFjaztcbiAgICAgICAgICAgICAgICAgICAgYWRkTWVkaWFTdHJlYW1UcmFja0xpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICB0cmFja0NoYW5nZUluUHJvZ3Jlc3MucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0cmFja0NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogSWYgdGhlIE1lZGlhU3RyZWFtVHJhY2sgZW5kcyBiZWZvcmUgdGhlIERPTSBpcyB2aXNpYmxlLFxuICAgICAgICAgICAgLy8gdGhlbiB0aGlzIG1ha2VzIHN1cmUgdGhhdCB2aXNpYmlsaXR5IGNhbGxiYWNrIGZvciBwaGFzZSAyIGlzIGNhbGxlZCBvbmx5XG4gICAgICAgICAgICAvLyBhZnRlciB0aGUgTWVkaWFTdHJlYW1UcmFjayBpcyByZS1hY3F1aXJlZC5cbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gKHRyYWNrQ2hhbmdlSW5Qcm9ncmVzcyAmJiB0cmFja0NoYW5nZUluUHJvZ3Jlc3MucHJvbWlzZSkgfHwgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5maW5hbGx5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvY2FsTWVkaWFSZXN0YXJ0RGVmZXJyZWRzLnJlc29sdmVEZWZlcnJlZChraW5kKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk11dGUoKSB7XG4gICAgICAgIHZhciBsb2cgPSBsb2NhbE1lZGlhVHJhY2suX2xvZywga2luZCA9IGxvY2FsTWVkaWFUcmFjay5raW5kO1xuICAgICAgICBsb2cuaW5mbygnTXV0ZWQnKTtcbiAgICAgICAgbG9nLmRlYnVnKCdMb2NhbE1lZGlhVHJhY2s6JywgbG9jYWxNZWRpYVRyYWNrKTtcbiAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogV2hlbiBhIExvY2FsTWVkaWFUcmFjayBpcyBtdXRlZCB3aXRob3V0IHRoZSBhcHAgYmVpbmdcbiAgICAgICAgLy8gYmFja2dyb3VuZGVkLCBhbmQgdGhlIGluYWR2ZXJ0ZW50bHkgcGF1c2VkIGVsZW1lbnRzIGFyZSBwbGF5ZWQgYmVmb3JlIGl0XG4gICAgICAgIC8vIGlzIHJlc3RhcnRlZCwgaXQgbmV2ZXIgZ2V0cyB1bm11dGVkIGR1ZSB0byB0aGUgV2ViS2l0IEJ1ZyAyMTM4NTMuIEhlbmNlLFxuICAgICAgICAvLyBzZXR0aW5nIHRoaXMgRGVmZXJyZWQgd2lsbCBtYWtlIHN1cmUgdGhhdCB0aGUgaW5hZHZlcnRlbnRseSBwYXVzZWQgZWxlbWVudHNcbiAgICAgICAgLy8gYXJlIHBsYXllZCBvbmx5IGFmdGVyIHRoZSBMb2NhbE1lZGlhVHJhY2sgaXMgdW5tdXRlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjEzODUzXG4gICAgICAgIC8vXG4gICAgICAgIGxvY2FsTWVkaWFSZXN0YXJ0RGVmZXJyZWRzLnN0YXJ0RGVmZXJyZWQoa2luZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZE1lZGlhU3RyZWFtVHJhY2tMaXN0ZW5lcnMoKSB7XG4gICAgICAgIG1lZGlhU3RyZWFtVHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBtYXliZVJlc3RhcnQpO1xuICAgICAgICBtZWRpYVN0cmVhbVRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ211dGUnLCBvbk11dGUpO1xuICAgICAgICBtZWRpYVN0cmVhbVRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIG1heWJlUmVzdGFydCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZU1lZGlhU3RyZWFtVHJhY2tMaXN0ZW5lcnMoKSB7XG4gICAgICAgIG1lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBtYXliZVJlc3RhcnQpO1xuICAgICAgICBtZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCBvbk11dGUpO1xuICAgICAgICBtZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIG1heWJlUmVzdGFydCk7XG4gICAgfVxuICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBsaXN0ZW4gZm9yIGRvY3VtZW50IHZpc2liaWxpdHkgY2FsbGJhY2sgb24gcGhhc2UgMS5cbiAgICAvLyB0aGlzIGVuc3VyZXMgdGhhdCB3ZSBhY3F1aXJlIG1lZGlhIHRyYWNrcyBiZWZvcmUgUmVtb3RlTWVkaWFUcmFja1xuICAgIC8vIHRyaWVzIHRvIGBwbGF5YCB0aGVtIChpbiBwaGFzZSAyKS4gVGhpcyBvcmRlciBpcyBpbXBvcnRhbnQgYmVjYXVzZVxuICAgIC8vIHBsYXkgY2FuIGZhaWwgb24gc2FmYXJpIGlmIGF1ZGlvIGlzIG5vdCBiZWluZyBjYXB0dXJlZC5cbiAgICB2YXIgb25WaXNpYmlsaXR5Q2hhbmdlID0gZnVuY3Rpb24gKGlzVmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gaXNWaXNpYmxlID8gbWF5YmVSZXN0YXJ0KCkgOiBmYWxzZTtcbiAgICB9O1xuICAgIGRvY3VtZW50VmlzaWJpbGl0eU1vbml0b3Iub25WaXNpYmlsaXR5Q2hhbmdlKDEsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgYWRkTWVkaWFTdHJlYW1UcmFja0xpc3RlbmVycygpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50VmlzaWJpbGl0eU1vbml0b3Iub2ZmVmlzaWJpbGl0eUNoYW5nZSgxLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgICByZW1vdmVNZWRpYVN0cmVhbVRyYWNrTGlzdGVuZXJzKCk7XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gbWl4aW5Mb2NhbE1lZGlhVHJhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbG1lZGlhdHJhY2suanMubWFwIiwiLyogZXNsaW50IG5ldy1jYXA6MCAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBUcmFja1B1YmxpY2F0aW9uID0gcmVxdWlyZSgnLi90cmFja3B1YmxpY2F0aW9uJyk7XG52YXIgX2EgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbnN0YW50cycpLCBFID0gX2EudHlwZUVycm9ycywgdHJhY2tQcmlvcml0eSA9IF9hLnRyYWNrUHJpb3JpdHk7XG4vKipcbiAqIEEge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn0gaXMgYSB7QGxpbmsgTG9jYWxUcmFja30gdGhhdCBoYXMgYmVlblxuICogcHVibGlzaGVkIHRvIGEge0BsaW5rIFJvb219LlxuICogQGV4dGVuZHMgVHJhY2tQdWJsaWNhdGlvblxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1RyYWNrRW5hYmxlZCAtIHdoZXRoZXIgdGhlIHB1Ymxpc2hlZCB7QGxpbmsgTG9jYWxUcmFja31cbiAqICAgaXMgZW5hYmxlZFxuICogQHByb3BlcnR5IHtUcmFjay5LaW5kfSBraW5kIC0ga2luZCBvZiB0aGUgcHVibGlzaGVkIHtAbGluayBMb2NhbFRyYWNrfVxuICogQHByb3BlcnR5IHtUcmFjay5Qcmlvcml0eX0gcHJpb3JpdHkgLSB0aGUgcHVibGlzaCBwcmlvcml0eSBvZiB0aGUge0BsaW5rIExvY2FsVHJhY2t9XG4gKiBAcHJvcGVydHkge0xvY2FsVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBMb2NhbFRyYWNrfVxuICovXG52YXIgTG9jYWxUcmFja1B1YmxpY2F0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhbFRyYWNrUHVibGljYXRpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn0uXG4gICAgICogQHBhcmFtIHtMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9IHNpZ25hbGluZyAtIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogICB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfVxuICAgICAqIEBwYXJhbSB7TG9jYWxUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIExvY2FsVHJhY2t9XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihMb2NhbFRyYWNrUHVibGljYXRpb24pOiB2b2lkfSB1bnB1Ymxpc2ggLSBUaGUgY2FsbGJhY2tcbiAgICAgKiAgIHRoYXQgdW5wdWJsaXNoZXMgdGhlIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb259XG4gICAgICogQHBhcmFtIHtUcmFja1B1YmxpY2F0aW9uT3B0aW9uc30gb3B0aW9ucyAtIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb259XG4gICAgICogICBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9jYWxUcmFja1B1YmxpY2F0aW9uKHNpZ25hbGluZywgdHJhY2ssIHVucHVibGlzaCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0cmFjay5uYW1lLCBzaWduYWxpbmcuc2lkLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX3JlZW1pdFRyYWNrRXZlbnQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZW1pdChfdGhpcy5pc1RyYWNrRW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICA/ICd0cmFja0VuYWJsZWQnXG4gICAgICAgICAgICAgICAgICAgIDogJ3RyYWNrRGlzYWJsZWQnKTsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2lnbmFsaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3VucHVibGlzaDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB1bnB1Ymxpc2hcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1RyYWNrRW5hYmxlZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrLmtpbmQgPT09ICdkYXRhJyA/IHRydWUgOiB0aGlzLnRyYWNrLmlzRW5hYmxlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2luZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRyYWNrLmtpbmRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmlvcml0eToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYWxpbmcudXBkYXRlZFByaW9yaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFjazoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRyYWNrXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFjay5vbignZGlzYWJsZWQnLCBfdGhpcy5fcmVlbWl0VHJhY2tFdmVudCk7XG4gICAgICAgIHRyYWNrLm9uKCdlbmFibGVkJywgX3RoaXMuX3JlZW1pdFRyYWNrRXZlbnQpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExvY2FsVHJhY2tQdWJsaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltMb2NhbFRyYWNrUHVibGljYXRpb24gI1wiICsgdGhpcy5faW5zdGFuY2VJZCArIFwiOiBcIiArIHRoaXMudHJhY2tTaWQgKyBcIl1cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUge0BsaW5rIFRyYWNrLlByaW9yaXR5fSBvZiB0aGUgcHVibGlzaGVkIHtAbGluayBMb2NhbFRyYWNrfS5cbiAgICAgKiBAcGFyYW0ge1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eSAtIHRoZSBuZXcge0BsaW5rIFRyYWNrLnByaW9yaXR5fVxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9XG4gICAgICovXG4gICAgTG9jYWxUcmFja1B1YmxpY2F0aW9uLnByb3RvdHlwZS5zZXRQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xuICAgICAgICB2YXIgcHJpb3JpdHlWYWx1ZXMgPSBPYmplY3QudmFsdWVzKHRyYWNrUHJpb3JpdHkpO1xuICAgICAgICBpZiAoIXByaW9yaXR5VmFsdWVzLmluY2x1ZGVzKHByaW9yaXR5KSkge1xuICAgICAgICAgICAgdGhyb3cgRS5JTlZBTElEX1ZBTFVFKCdwcmlvcml0eScsIHByaW9yaXR5VmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaWduYWxpbmcuc2V0UHJpb3JpdHkocHJpb3JpdHkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVucHVibGlzaCBhIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb259LiBUaGlzIG1lYW5zIHRoYXQgdGhlIG1lZGlhXG4gICAgICogZnJvbSB0aGlzIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb259IGlzIG5vIGxvbmdlciBhdmFpbGFibGUgdG8gdGhlXG4gICAgICoge0BsaW5rIFJvb219J3Mge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fXMuXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgTG9jYWxUcmFja1B1YmxpY2F0aW9uLnByb3RvdHlwZS51bnB1Ymxpc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJhY2sucmVtb3ZlTGlzdGVuZXIoJ2Rpc2FibGVkJywgdGhpcy5fcmVlbWl0VHJhY2tFdmVudCk7XG4gICAgICAgIHRoaXMudHJhY2sucmVtb3ZlTGlzdGVuZXIoJ2VuYWJsZWQnLCB0aGlzLl9yZWVtaXRUcmFja0V2ZW50KTtcbiAgICAgICAgdGhpcy5fdW5wdWJsaXNoKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBMb2NhbFRyYWNrUHVibGljYXRpb247XG59KFRyYWNrUHVibGljYXRpb24pKTtcbm1vZHVsZS5leHBvcnRzID0gTG9jYWxUcmFja1B1YmxpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWx0cmFja3B1YmxpY2F0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgZ3Vlc3NCcm93c2VyID0gcmVxdWlyZSgnQHR3aWxpby93ZWJydGMvbGliL3V0aWwnKS5ndWVzc0Jyb3dzZXI7XG52YXIgZGV0ZWN0U2lsZW50VmlkZW8gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RldGVjdHNpbGVudHZpZGVvJyk7XG52YXIgbWl4aW5Mb2NhbE1lZGlhVHJhY2sgPSByZXF1aXJlKCcuL2xvY2FsbWVkaWF0cmFjaycpO1xudmFyIFZpZGVvVHJhY2sgPSByZXF1aXJlKCcuL3ZpZGVvdHJhY2snKTtcbnZhciBMb2NhbE1lZGlhVmlkZW9UcmFjayA9IG1peGluTG9jYWxNZWRpYVRyYWNrKFZpZGVvVHJhY2spO1xuLyoqXG4gKiBBIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9IGlzIGEge0BsaW5rIFZpZGVvVHJhY2t9IHJlcHJlc2VudGluZyB2aWRlbyB0aGF0XG4gKiB5b3VyIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBjYW4gcHVibGlzaCB0byBhIHtAbGluayBSb29tfS4gSXQgY2FuIGJlXG4gKiBlbmFibGVkIGFuZCBkaXNhYmxlZCB3aXRoIHtAbGluayBMb2NhbFZpZGVvVHJhY2sjZW5hYmxlfSBhbmRcbiAqIHtAbGluayBMb2NhbFZpZGVvVHJhY2sjZGlzYWJsZX0gb3Igc3RvcHBlZCBjb21wbGV0ZWx5IHdpdGhcbiAqIHtAbGluayBMb2NhbFZpZGVvVHJhY2sjc3RvcH0uXG4gKiBAZXh0ZW5kcyBWaWRlb1RyYWNrXG4gKiBAcHJvcGVydHkge1RyYWNrLklEfSBpZCAtIFRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSdzIElEXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU3RvcHBlZCAtIFdoZXRoZXIgb3Igbm90IHRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSBpc1xuICogICBzdG9wcGVkXG4gKiBAZW1pdHMgTG9jYWxWaWRlb1RyYWNrI2Rpc2FibGVkXG4gKiBAZW1pdHMgTG9jYWxWaWRlb1RyYWNrI2VuYWJsZWRcbiAqIEBlbWl0cyBMb2NhbFZpZGVvVHJhY2sjc3RhcnRlZFxuICogQGVtaXRzIExvY2FsVmlkZW9UcmFjayNzdG9wcGVkXG4gKi9cbnZhciBMb2NhbFZpZGVvVHJhY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvY2FsVmlkZW9UcmFjaywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSBmcm9tIGEgTWVkaWFTdHJlYW1UcmFjay5cbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IG1lZGlhU3RyZWFtVHJhY2sgLSBUaGUgdW5kZXJseWluZyBNZWRpYVN0cmVhbVRyYWNrXG4gICAgICogQHBhcmFtIHtMb2NhbFRyYWNrT3B0aW9uc30gW29wdGlvbnNdIC0ge0BsaW5rIExvY2FsVHJhY2t9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2NhbFZpZGVvVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICB3b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlbzogZ3Vlc3NCcm93c2VyKCkgPT09ICdzYWZhcmknXG4gICAgICAgICAgICAgICAgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50ID09PSAnZnVuY3Rpb24nXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lZGlhU3RyZWFtVHJhY2ssIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfd29ya2Fyb3VuZFNpbGVudExvY2FsVmlkZW86IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy53b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlb1xuICAgICAgICAgICAgICAgICAgICA/IHdvcmthcm91bmRTaWxlbnRMb2NhbFZpZGVvXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF93b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlb0NsZWFudXA6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogSW4gaU9TIFNhZmFyaSwgd2Ugd29yayBhcm91bmQgYSBidWcgd2hlcmUgbG9jYWwgdmlkZW9cbiAgICAgICAgLy8gTWVkaWFTdHJlYW1UcmFja3MgYXJlIHNpbGVudCAoZXZlbiB0aG91Z2ggdGhleSBhcmUgZW5hYmxlZCwgbGl2ZSBhbmQgdW5tdXRlZClcbiAgICAgICAgLy8gYWZ0ZXIgYWNjZXB0aW5nL3JlamVjdGluZyBhIHBob25lIGNhbGwuXG4gICAgICAgIGlmIChfdGhpcy5fd29ya2Fyb3VuZFNpbGVudExvY2FsVmlkZW8pIHtcbiAgICAgICAgICAgIF90aGlzLl93b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlb0NsZWFudXAgPSBfdGhpcy5fd29ya2Fyb3VuZFNpbGVudExvY2FsVmlkZW8oX3RoaXMsIGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExvY2FsVmlkZW9UcmFjay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltMb2NhbFZpZGVvVHJhY2sgI1wiICsgdGhpcy5faW5zdGFuY2VJZCArIFwiOiBcIiArIHRoaXMuaWQgKyBcIl1cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTG9jYWxWaWRlb1RyYWNrLnByb3RvdHlwZS5fY2hlY2tJZkNhbkNhcHR1cmVGcmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl9jaGVja0lmQ2FuQ2FwdHVyZUZyYW1lcy5jYWxsKHRoaXMsIHRoaXMuX3RyYWNrU2VuZGVyLmlzUHVibGlzaGluZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIExvY2FsVmlkZW9UcmFjay5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBMb2NhbFZpZGVvVHJhY2sucHJvdG90eXBlLl9zZXRTZW5kZXJNZWRpYVN0cmVhbVRyYWNrID0gZnVuY3Rpb24gKHVzZVByb2Nlc3NlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdW5wcm9jZXNzZWRUcmFjayA9IHRoaXMubWVkaWFTdHJlYW1UcmFjaztcbiAgICAgICAgdmFyIG1lZGlhU3RyZWFtVHJhY2sgPSB1c2VQcm9jZXNzZWQgPyB0aGlzLnByb2Nlc3NlZFRyYWNrIDogdW5wcm9jZXNzZWRUcmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrU2VuZGVyLnNldE1lZGlhU3RyZWFtVHJhY2sobWVkaWFTdHJlYW1UcmFjaylcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIF90aGlzLl9sb2cud2Fybignc2V0TWVkaWFTdHJlYW1UcmFjayBmYWlsZWQgb24gTG9jYWxWaWRlb1RyYWNrIFJUQ1J0cFNlbmRlcicsIHsgZXJyb3I6IGVycm9yLCBtZWRpYVN0cmVhbVRyYWNrOiBtZWRpYVN0cmVhbVRyYWNrIH0pOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3VucHJvY2Vzc2VkVHJhY2sgPSB1c2VQcm9jZXNzZWQgPyB1bnByb2Nlc3NlZFRyYWNrIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9IHRvIGFsbG93IGZvciBjdXN0b20gcHJvY2Vzc2luZyBvZiB2aWRlbyBmcmFtZXMgYmVsb25naW5nIHRvIGEgVmlkZW9UcmFjay5cbiAgICAgKiBPbmx5IENocm9tZSBzdXBwb3J0cyB0aGlzIGFzIG9mIG5vdy4gQ2FsbGluZyB0aGlzIEFQSSBmcm9tIGEgbm9uLXN1cHBvcnRlZCBicm93c2VyIHdpbGwgcmVzdWx0IGluIGEgbG9nIHdhcm5pbmcuXG4gICAgICogQHBhcmFtIHtWaWRlb1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIC0gVGhlIHtAbGluayBWaWRlb1Byb2Nlc3Nvcn0gdG8gdXNlLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2xhc3MgR3JheVNjYWxlUHJvY2Vzc29yIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHBlcmNlbnRhZ2UpIHtcbiAgICAgKiAgICAgdGhpcy5wZXJjZW50YWdlID0gcGVyY2VudGFnZTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIHByb2Nlc3NGcmFtZShpbnB1dEZyYW1lQnVmZmVyLCBvdXRwdXRGcmFtZUJ1ZmZlcikge1xuICAgICAqICAgICBjb25zdCBjb250ZXh0ID0gb3V0cHV0RnJhbWVCdWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgKiAgICAgY29udGV4dC5maWx0ZXIgPSBgZ3JheXNjYWxlKCR7dGhpcy5wZXJjZW50YWdlfSUpYDtcbiAgICAgKiAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW5wdXRGcmFtZUJ1ZmZlciwgMCwgMCwgaW5wdXRGcmFtZUJ1ZmZlci53aWR0aCwgaW5wdXRGcmFtZUJ1ZmZlci5oZWlnaHQpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGNvbnN0IGxvY2FsVmlkZW9UcmFjayA9IEFycmF5LmZyb20ocm9vbS5sb2NhbFBhcnRpY2lwYW50LnZpZGVvVHJhY2tzLnZhbHVlcygpKVswXS50cmFjaztcbiAgICAgKiBsb2NhbFZpZGVvVHJhY2suYWRkUHJvY2Vzc29yKG5ldyBHcmF5U2NhbGVQcm9jZXNzb3IoMTAwKSk7XG4gICAgICovXG4gICAgTG9jYWxWaWRlb1RyYWNrLnByb3RvdHlwZS5hZGRQcm9jZXNzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygnQWRkaW5nIFZpZGVvUHJvY2Vzc29yIHRvIHRoZSBMb2NhbFZpZGVvVHJhY2snKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuYWRkUHJvY2Vzc29yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZy53YXJuKCdVbmFibGUgdG8gYWRkIGEgVmlkZW9Qcm9jZXNzb3IgdG8gdGhlIExvY2FsVmlkZW9UcmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygnVXBkYXRpbmcgTG9jYWxWaWRlb1RyYWNrXFwncyBNZWRpYVN0cmVhbVRyYWNrIHdpdGggdGhlIHByb2Nlc3NlZCBNZWRpYVN0cmVhbVRyYWNrJywgdGhpcy5wcm9jZXNzZWRUcmFjayk7XG4gICAgICAgIHRoaXMuX3NldFNlbmRlck1lZGlhU3RyZWFtVHJhY2sodHJ1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHByZXZpb3VzbHkgYWRkZWQge0BsaW5rIFZpZGVvUHJvY2Vzc29yfSB1c2luZyBgYWRkUHJvY2Vzc29yYCBBUEkuXG4gICAgICogQHBhcmFtIHtWaWRlb1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIC0gVGhlIHtAbGluayBWaWRlb1Byb2Nlc3Nvcn0gdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2xhc3MgR3JheVNjYWxlUHJvY2Vzc29yIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHBlcmNlbnRhZ2UpIHtcbiAgICAgKiAgICAgdGhpcy5wZXJjZW50YWdlID0gcGVyY2VudGFnZTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIHByb2Nlc3NGcmFtZShpbnB1dEZyYW1lQnVmZmVyLCBvdXRwdXRGcmFtZUJ1ZmZlcikge1xuICAgICAqICAgICBjb25zdCBjb250ZXh0ID0gb3V0cHV0RnJhbWVCdWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgKiAgICAgY29udGV4dC5maWx0ZXIgPSBgZ3JheXNjYWxlKCR7dGhpcy5wZXJjZW50YWdlfSUpYDtcbiAgICAgKiAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW5wdXRGcmFtZUJ1ZmZlciwgMCwgMCwgaW5wdXRGcmFtZUJ1ZmZlci53aWR0aCwgaW5wdXRGcmFtZUJ1ZmZlci5oZWlnaHQpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGNvbnN0IGxvY2FsVmlkZW9UcmFjayA9IEFycmF5LmZyb20ocm9vbS5sb2NhbFBhcnRpY2lwYW50LnZpZGVvVHJhY2tzLnZhbHVlcygpKVswXS50cmFjaztcbiAgICAgKiBjb25zdCBncmF5U2NhbGVQcm9jZXNzb3IgPSBuZXcgR3JheVNjYWxlUHJvY2Vzc29yKDEwMCk7XG4gICAgICogbG9jYWxWaWRlb1RyYWNrLmFkZFByb2Nlc3NvcihncmF5U2NhbGVQcm9jZXNzb3IpO1xuICAgICAqXG4gICAgICogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlbW92ZS1idXR0b24nKS5vbmNsaWNrID0gKCkgPT4gbG9jYWxWaWRlb1RyYWNrLnJlbW92ZVByb2Nlc3NvcihncmF5U2NhbGVQcm9jZXNzb3IpO1xuICAgICAqL1xuICAgIExvY2FsVmlkZW9UcmFjay5wcm90b3R5cGUucmVtb3ZlUHJvY2Vzc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ1JlbW92aW5nIFZpZGVvUHJvY2Vzc29yIGZyb20gdGhlIExvY2FsVmlkZW9UcmFjaycpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5yZW1vdmVQcm9jZXNzb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdVcGRhdGluZyBMb2NhbFZpZGVvVHJhY2tcXCdzIE1lZGlhU3RyZWFtVHJhY2sgd2l0aCB0aGUgb3JpZ2luYWwgTWVkaWFTdHJlYW1UcmFjaycpO1xuICAgICAgICB0aGlzLl9zZXRTZW5kZXJNZWRpYVN0cmVhbVRyYWNrKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl91cGRhdGVFbGVtZW50c01lZGlhU3RyZWFtVHJhY2soKTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIHRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfS4gVGhpcyBpcyBlZmZlY3RpdmVseSBcInBhdXNlXCIuXG4gICAgICogSWYgYSB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9IGlzIGFkZGVkLCB0aGVuIGBwcm9jZXNzZWRUcmFja2AgaXMgZGlzYWJsZWQgYXMgd2VsbC5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAZmlyZXMgVmlkZW9UcmFjayNkaXNhYmxlZFxuICAgICAqL1xuICAgIExvY2FsVmlkZW9UcmFjay5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuZGlzYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWRUcmFjay5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0aGUge0BsaW5rIExvY2FsVmlkZW9UcmFja30uIFRoaXMgaXMgZWZmZWN0aXZlbHkgXCJ1bnBhdXNlXCIuXG4gICAgICogSWYgYSB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9IGlzIGFkZGVkLCB0aGVuIGBwcm9jZXNzZWRUcmFja2AgaXMgZW5hYmxlZCBhcyB3ZWxsLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBmaXJlcyBWaWRlb1RyYWNrI2VuYWJsZWRcbiAgICAqLyAvKipcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUge0BsaW5rIExvY2FsVmlkZW9UcmFja30uIFRoaXMgaXMgZWZmZWN0aXZlbHkgXCJ1bnBhdXNlXCJcbiAgICAgKiBvciBcInBhdXNlXCIuIElmIGEge0BsaW5rIFZpZGVvUHJvY2Vzc29yfSBpcyBhZGRlZCxcbiAgICAgKiB0aGVuIGBwcm9jZXNzZWRUcmFja2AgaXMgZW5hYmxlZCBvciBkaXNhYmxlZCBhcyB3ZWxsLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuYWJsZWRdIC0gU3BlY2lmeSBmYWxzZSB0byBwYXVzZSB0aGVcbiAgICAgKiAgIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9XG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGZpcmVzIFZpZGVvVHJhY2sjZGlzYWJsZWRcbiAgICAgKiBAZmlyZXMgVmlkZW9UcmFjayNlbmFibGVkXG4gICAgICovXG4gICAgTG9jYWxWaWRlb1RyYWNrLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICBpZiAoZW5hYmxlZCA9PT0gdm9pZCAwKSB7IGVuYWJsZWQgPSB0cnVlOyB9XG4gICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLmVuYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWRUcmFjay5lbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FwdHVyZUZyYW1lcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygnVXBkYXRpbmcgTG9jYWxWaWRlb1RyYWNrXFwncyBNZWRpYVN0cmVhbVRyYWNrIHdpdGggdGhlIHByb2Nlc3NlZCBNZWRpYVN0cmVhbVRyYWNrJywgdGhpcy5wcm9jZXNzZWRUcmFjayk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VuZGVyTWVkaWFTdHJlYW1UcmFjayh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzdGFydCB0aGUge0BsaW5rIExvY2FsVmlkZW9UcmFja30uIFRoaXMgc3RvcHMgdGhlIGV4aXN0aW5nIE1lZGlhU3RyZWFtVHJhY2tcbiAgICAgKiBhbmQgY3JlYXRlcyBhIG5ldyBNZWRpYVN0cmVhbVRyYWNrLiBJZiB0aGUge0BsaW5rIExvY2FsVmlkZW9UcmFja30gaXMgYmVpbmcgcHVibGlzaGVkXG4gICAgICogdG8gYSB7QGxpbmsgUm9vbX0sIHRoZW4gYWxsIHRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9cyB3aWxsIHN0YXJ0IHJlY2VpdmluZyBtZWRpYVxuICAgICAqIGZyb20gdGhlIG5ld2x5IGNyZWF0ZWQgTWVkaWFTdHJlYW1UcmFjay4gWW91IGNhbiBhY2Nlc3MgdGhlIG5ldyBNZWRpYVN0cmVhbVRyYWNrIHZpYVxuICAgICAqIHRoZSA8Y29kZT5tZWRpYVN0cmVhbVRyYWNrPC9jb2RlPiBwcm9wZXJ0eS4gSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGV2ZW50cyBvblxuICAgICAqIHRoZSBNZWRpYVN0cmVhbVRyYWNrIGRpcmVjdGx5LCBwbGVhc2UgZG8gc28gaW4gdGhlIFwic3RhcnRlZFwiIGV2ZW50IGhhbmRsZXIuIEFsc28sXG4gICAgICogdGhlIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9J3MgSUQgaXMgbm8gbG9uZ2VyIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHNhbWUgYXMgdGhlXG4gICAgICogdW5kZXJseWluZyBNZWRpYVN0cmVhbVRyYWNrJ3MgSUQuXG4gICAgICogQHBhcmFtIHtNZWRpYVRyYWNrQ29uc3RyYWludHN9IFtjb25zdHJhaW50c10gLSBUaGUgb3B0aW9uYWwgPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVRyYWNrQ29uc3RyYWludHNcIiB0YXJnZXQ9XCJfYmxhbmtcIj5NZWRpYVRyYWNrQ29uc3RyYWludHM8L2E+XG4gICAgICogICBmb3IgcmVzdGFydGluZyB0aGUge0BsaW5rIExvY2FsVmlkZW9UcmFja307IElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gdGhlIGN1cnJlbnQgTWVkaWFUcmFja0NvbnN0cmFpbnRzXG4gICAgICogICB3aWxsIGJlIHVzZWQ7IElmIDxjb2RlPnt9PC9jb2RlPiAoZW1wdHkgb2JqZWN0KSBpcyBzcGVjaWZpZWQsIHRoZW4gdGhlIGRlZmF1bHQgTWVkaWFUcmFja0NvbnN0cmFpbnRzXG4gICAgICogICB3aWxsIGJlIHVzZWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVqZWN0cyB3aXRoIGEgVHlwZUVycm9yIGlmIHRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSB3YXMgbm90IGNyZWF0ZWRcbiAgICAgKiAgIHVzaW5nIGFuIG9uZSBvZiA8Y29kZT5jcmVhdGVMb2NhbFZpZGVvVHJhY2s8L2NvZGU+LCA8Y29kZT5jcmVhdGVMb2NhbFRyYWNrczwvY29kZT4gb3IgPGNvZGU+Y29ubmVjdDwvY29kZT47XG4gICAgICogICBBbHNvIHJlamVjdHMgd2l0aCB0aGUgPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYURldmljZXMvZ2V0VXNlck1lZGlhI0V4Y2VwdGlvbnNcIiB0YXJnZXQ9XCJfYmxhbmtcIj5ET01FeGNlcHRpb248L2E+XG4gICAgICogICByYWlzZWQgYnkgPGNvZGU+Z2V0VXNlck1lZGlhPC9jb2RlPiB3aGVuIGl0IGZhaWxzXG4gICAgICogQGZpcmVzIExvY2FsVmlkZW9UcmFjayNzdG9wcGVkXG4gICAgICogQGZpcmVzIExvY2FsVmlkZW9UcmFjayNzdGFydGVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCB7IGNvbm5lY3QsIGNyZWF0ZUxvY2FsVmlkZW9UcmFjayB9ID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgYSBMb2NhbFZpZGVvVHJhY2sgdGhhdCBjYXB0dXJlcyB2aWRlbyBmcm9tIHRoZSBmcm9udC1mYWNpbmcgY2FtZXJhLlxuICAgICAqIGNyZWF0ZUxvY2FsVmlkZW9UcmFjayh7IGZhY2luZ01vZGU6ICd1c2VyJyB9KS50aGVuKGZ1bmN0aW9uKGxvY2FsVmlkZW9UcmFjaykge1xuICAgICAqICAgcmV0dXJuIGNvbm5lY3QoJ3Rva2VuJywge1xuICAgICAqICAgICBuYW1lOiAnbXktY29vbC1yb29tJyxcbiAgICAgKiAgICAgdHJhY2tzOiBbbG9jYWxWaWRlb1RyYWNrXVxuICAgICAqICAgfSk7XG4gICAgICogfSkudGhlbihmdW5jdGlvbihyb29tKSB7XG4gICAgICogICAvLyBSZXN0YXJ0IHRoZSBMb2NhbFZpZGVvVHJhY2sgdG8gY2FwdHVyZSB2aWRlbyBmcm9tIHRoZSBiYWNrLWZhY2luZyBjYW1lcmEuXG4gICAgICogICBjb25zdCBsb2NhbFZpZGVvVHJhY2sgPSBBcnJheS5mcm9tKHJvb20ubG9jYWxQYXJ0aWNpcGFudC52aWRlb1RyYWNrcy52YWx1ZXMoKSlbMF0udHJhY2s7XG4gICAgICogICByZXR1cm4gbG9jYWxWaWRlb1RyYWNrLnJlc3RhcnQoeyBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnIH0pO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIExvY2FsVmlkZW9UcmFjay5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3dvcmthcm91bmRTaWxlbnRMb2NhbFZpZGVvQ2xlYW51cCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya2Fyb3VuZFNpbGVudExvY2FsVmlkZW9DbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLl93b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlb0NsZWFudXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9taXNlID0gX3N1cGVyLnByb3RvdHlwZS5yZXN0YXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3Nvcikge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzdGFydFByb2Nlc3NvcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3dvcmthcm91bmRTaWxlbnRMb2NhbFZpZGVvKSB7XG4gICAgICAgICAgICBwcm9taXNlLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl93b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlb0NsZWFudXAgPSBfdGhpcy5fd29ya2Fyb3VuZFNpbGVudExvY2FsVmlkZW8oX3RoaXMsIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbHMgc3RvcCBvbiB0aGUgdW5kZXJseWluZyBNZWRpYVN0cmVhbVRyYWNrLiBJZiB5b3UgY2hvb3NlIHRvIHN0b3AgYVxuICAgICAqIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9LCB5b3Ugc2hvdWxkIHVucHVibGlzaCBpdCBhZnRlciBzdG9wcGluZy5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAZmlyZXMgTG9jYWxWaWRlb1RyYWNrI3N0b3BwZWRcbiAgICAgKi9cbiAgICBMb2NhbFZpZGVvVHJhY2sucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3JrYXJvdW5kU2lsZW50TG9jYWxWaWRlb0NsZWFudXApIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmthcm91bmRTaWxlbnRMb2NhbFZpZGVvQ2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5fd29ya2Fyb3VuZFNpbGVudExvY2FsVmlkZW9DbGVhbnVwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5zdG9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxWaWRlb1RyYWNrO1xufShMb2NhbE1lZGlhVmlkZW9UcmFjaykpO1xuLyoqXG4gKiBXb3JrIGFyb3VuZCBhIGJ1ZyB3aGVyZSBsb2NhbCB2aWRlbyBNZWRpYVN0cmVhbVRyYWNrcyBhcmUgc2lsZW50IChldmVuIHRob3VnaFxuICogdGhleSBhcmUgZW5hYmxlZCwgbGl2ZSBhbmQgdW5tdXRlZCkgYWZ0ZXIgYWNjZXB0aW5nL3JlamVjdGluZyBhIHBob25lIGNhbGwuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtMb2NhbFZpZGVvVHJhY2t9IGxvY2FsVmlkZW9UcmFja1xuICogQHBhcmFtIHtIVE1MRG9jdW1lbnR9IGRvY1xuICogQHJldHVybnMge2Z1bmN0aW9ufSBDbGVhbnMgdXAgbGlzdGVuZXJzIGF0dGFjaGVkIGJ5IHRoZSB3b3JrYXJvdW5kXG4gKi9cbmZ1bmN0aW9uIHdvcmthcm91bmRTaWxlbnRMb2NhbFZpZGVvKGxvY2FsVmlkZW9UcmFjaywgZG9jKSB7XG4gICAgdmFyIGxvZyA9IGxvY2FsVmlkZW9UcmFjay5fbG9nO1xuICAgIHZhciBlbCA9IGxvY2FsVmlkZW9UcmFjay5fZHVtbXlFbCwgbWVkaWFTdHJlYW1UcmFjayA9IGxvY2FsVmlkZW9UcmFjay5tZWRpYVN0cmVhbVRyYWNrO1xuICAgIGZ1bmN0aW9uIG9uVW5tdXRlKCkge1xuICAgICAgICBpZiAoIWxvY2FsVmlkZW9UcmFjay5pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2cuaW5mbygnVW5tdXRlZCwgY2hlY2tpbmcgc2lsZW5jZScpO1xuICAgICAgICAvLyBUaGUgZHVtbXkgZWxlbWVudCBpcyBwYXVzZWQsIHNvIHBsYXkgaXQgYW5kIHRoZW4gZGV0ZWN0IHNpbGVuY2UuXG4gICAgICAgIGVsLnBsYXkoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRldGVjdFNpbGVudFZpZGVvKGVsLCBkb2MpOyB9KS50aGVuKGZ1bmN0aW9uIChpc1NpbGVudCkge1xuICAgICAgICAgICAgaWYgKCFpc1NpbGVudCkge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKCdOb24tc2lsZW50IGZyYW1lcyBkZXRlY3RlZCwgc28gbm8gbmVlZCB0byByZXN0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nLndhcm4oJ1NpbGVuY2UgZGV0ZWN0ZWQsIHJlc3RhcnRpbmcnKTtcbiAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IElmIHdlIHRyeSBhbmQgcmVzdGFydCBhIHNpbGVudCBNZWRpYVN0cmVhbVRyYWNrXG4gICAgICAgICAgICAvLyB3aXRob3V0IHN0b3BwaW5nIGl0IGZpcnN0LCB0aGVuIGEgTm90UmVhZGFibGVFcnJvciBpcyByYWlzZWQuIEhlbmNlLFxuICAgICAgICAgICAgLy8gd2Ugc3RvcCB0aGUgTWVkaWFTdHJlYW1UcmFjayBoZXJlLlxuICAgICAgICAgICAgbG9jYWxWaWRlb1RyYWNrLl9zdG9wKCk7XG4gICAgICAgICAgICAvLyBSZXN0YXJ0IHRoZSBMb2NhbFZpZGVvVHJhY2suXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZpZGVvVHJhY2suX3Jlc3RhcnQoKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBsb2cud2FybignRmFpbGVkIHRvIGRldGVjdCBzaWxlbmNlIGFuZCByZXN0YXJ0OicsIGVycm9yKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZiBzaWxlbnQgZnJhbWVzIHdlcmUgbm90IGRldGVjdGVkLCB0aGVuIHBhdXNlIHRoZSBkdW1teSBlbGVtZW50IGFnYWluLlxuICAgICAgICAgICAgZWwgPSBsb2NhbFZpZGVvVHJhY2suX2R1bW15RWw7XG4gICAgICAgICAgICBpZiAoIWVsLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgIGVsLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgdW5tdXRlIGhhbmRsZXIuXG4gICAgICAgICAgICBtZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIG9uVW5tdXRlKTtcbiAgICAgICAgICAgIG1lZGlhU3RyZWFtVHJhY2sgPSBsb2NhbFZpZGVvVHJhY2subWVkaWFTdHJlYW1UcmFjaztcbiAgICAgICAgICAgIG1lZGlhU3RyZWFtVHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgb25Vbm11dGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gU2V0IHRoZSB1bm11dGUgaGFuZGxlci5cbiAgICBtZWRpYVN0cmVhbVRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIG9uVW5tdXRlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIG9uVW5tdXRlKTtcbiAgICB9O1xufVxuLyoqXG4gKiBUaGUge0BsaW5rIExvY2FsVmlkZW9UcmFja30gd2FzIGRpc2FibGVkLCBpLmUuIFwibXV0ZWRcIi5cbiAqIEBwYXJhbSB7TG9jYWxWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSB0aGF0IHdhc1xuICogICBkaXNhYmxlZFxuICogQGV2ZW50IExvY2FsVmlkZW9UcmFjayNkaXNhYmxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSB3YXMgZW5hYmxlZCwgaS5lLiBcInVubXV0ZWRcIi5cbiAqIEBwYXJhbSB7TG9jYWxWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSB0aGF0IHdhcyBlbmFibGVkXG4gKiBAZXZlbnQgTG9jYWxWaWRlb1RyYWNrI2VuYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIExvY2FsVmlkZW9UcmFja30gc3RhcnRlZC4gVGhpcyBtZWFucyB0aGVyZSBpcyBlbm91Z2ggdmlkZW8gZGF0YVxuICogdG8gYmVnaW4gcGxheWJhY2suXG4gKiBAcGFyYW0ge0xvY2FsVmlkZW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIExvY2FsVmlkZW9UcmFja30gdGhhdCBzdGFydGVkXG4gKiBAZXZlbnQgTG9jYWxWaWRlb1RyYWNrI3N0YXJ0ZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIExvY2FsVmlkZW9UcmFja30gc3RvcHBlZCwgZWl0aGVyIGJlY2F1c2Uge0BsaW5rIExvY2FsVmlkZW9UcmFjayNzdG9wfVxuICogb3Ige0BsaW5rIExvY2FsVmlkZW9UcmFjayNyZXN0YXJ0fSB3YXMgY2FsbGVkIG9yIGJlY2F1c2UgdGhlIHVuZGVybHlpbmdcbiAqIE1lZGlhU3RyZWFtVHJhY2sgZW5kZWQuXG4gKiBAcGFyYW0ge0xvY2FsVmlkZW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIExvY2FsVmlkZW9UcmFja30gdGhhdCBzdG9wcGVkXG4gKiBAZXZlbnQgTG9jYWxWaWRlb1RyYWNrI3N0b3BwZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBMb2NhbFZpZGVvVHJhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbHZpZGVvdHJhY2suanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBMb2NhbFRyYWNrUHVibGljYXRpb24gPSByZXF1aXJlKCcuL2xvY2FsdHJhY2twdWJsaWNhdGlvbicpO1xuLyoqXG4gKiBBIHtAbGluayBMb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvbn0gaXMgYSB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSB0aGF0IGhhc1xuICogYmVlbiBwdWJsaXNoZWQgdG8gYSB7QGxpbmsgUm9vbX0uXG4gKiBAZXh0ZW5kcyBMb2NhbFRyYWNrUHVibGljYXRpb25cbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZCAtIFwidmlkZW9cIlxuICogQHByb3BlcnR5IHtMb2NhbFZpZGVvVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9XG4gKi9cbnZhciBMb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIExvY2FsVmlkZW9UcmFja1B1YmxpY2F0aW9ufS5cbiAgICAgKiBAcGFyYW0ge0xvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ30gc2lnbmFsaW5nIC0gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9XG4gICAgICogQHBhcmFtIHtMb2NhbFZpZGVvVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihMb2NhbFRyYWNrUHVibGljYXRpb24pOiB2b2lkfSB1bnB1Ymxpc2ggLSBUaGUgY2FsbGJhY2tcbiAgICAgKiAgICB0aGF0IHVucHVibGlzaGVzIHRoZSB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9ufVxuICAgICAqIEBwYXJhbSB7VHJhY2tQdWJsaWNhdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9ufSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb24oc2lnbmFsaW5nLCB0cmFjaywgdW5wdWJsaXNoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzaWduYWxpbmcsIHRyYWNrLCB1bnB1Ymxpc2gsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgfVxuICAgIExvY2FsVmlkZW9UcmFja1B1YmxpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW0xvY2FsVmlkZW9UcmFja1B1YmxpY2F0aW9uICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyBcIjogXCIgKyB0aGlzLnRyYWNrU2lkICsgXCJdXCI7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb247XG59KExvY2FsVHJhY2tQdWJsaWNhdGlvbikpO1xubW9kdWxlLmV4cG9ydHMgPSBMb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsdmlkZW90cmFja3B1YmxpY2F0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgZ3Vlc3NCcm93c2VyID0gcmVxdWlyZSgnQHR3aWxpby93ZWJydGMvbGliL3V0aWwnKS5ndWVzc0Jyb3dzZXI7XG52YXIgTWVkaWFTdHJlYW0gPSByZXF1aXJlKCdAdHdpbGlvL3dlYnJ0YycpLk1lZGlhU3RyZWFtO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLCB3YWl0Rm9yRXZlbnQgPSBfYS53YWl0Rm9yRXZlbnQsIHdhaXRGb3JTb21ldGltZSA9IF9hLndhaXRGb3JTb21ldGltZTtcbnZhciBsb2NhbE1lZGlhUmVzdGFydERlZmVycmVkcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbG9jYWxtZWRpYXJlc3RhcnRkZWZlcnJlZHMnKTtcbnZhciBUcmFjayA9IHJlcXVpcmUoJy4vJyk7XG4vKipcbiAqIEEge0BsaW5rIE1lZGlhVHJhY2t9IHJlcHJlc2VudHMgYXVkaW8gb3IgdmlkZW8gdGhhdCBjYW4gYmUgc2VudCB0byBvclxuICogcmVjZWl2ZWQgZnJvbSBhIHtAbGluayBSb29tfS5cbiAqIEBleHRlbmRzIFRyYWNrXG4gKiBAcHJvcGVydHkge1RyYWNrLklEfSBpZCAtIFRoaXMge0BsaW5rIFRyYWNrfSdzIElEXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU3RhcnRlZCAtIFdoZXRoZXIgb3Igbm90IHRoZSB7QGxpbmsgTWVkaWFUcmFja30gaGFzXG4gKiAgIHN0YXJ0ZWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNFbmFibGVkIC0gV2hldGhlciBvciBub3QgdGhlIHtAbGluayBNZWRpYVRyYWNrfSBpc1xuICogICBlbmFibGVkIChpLmUuLCB3aGV0aGVyIGl0IGlzIHBhdXNlZCBvciBtdXRlZClcbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZCAtIFRoZSBraW5kIG9mIHRoZSB1bmRlcmx5aW5nXG4gKiAgIE1lZGlhU3RyZWFtVHJhY2ssIFwiYXVkaW9cIiBvciBcInZpZGVvXCJcbiAqIEBwcm9wZXJ0eSB7TWVkaWFTdHJlYW1UcmFja30gbWVkaWFTdHJlYW1UcmFjayAtIFRoZSB1bmRlcmx5aW5nXG4gKiAgIE1lZGlhU3RyZWFtVHJhY2tcbiAqIEBlbWl0cyBNZWRpYVRyYWNrI2Rpc2FibGVkXG4gKiBAZW1pdHMgTWVkaWFUcmFjayNlbmFibGVkXG4gKiBAZW1pdHMgTWVkaWFUcmFjayNzdGFydGVkXG4gKi9cbnZhciBNZWRpYVRyYWNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZWRpYVRyYWNrLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBNZWRpYVRyYWNrfS5cbiAgICAgKiBAcGFyYW0ge01lZGlhVHJhY2tUcmFuc2NlaXZlcn0gbWVkaWFUcmFja1RyYW5zY2VpdmVyXG4gICAgICogQHBhcmFtIHt7bG9nOiBMb2d9fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWVkaWFUcmFjayhtZWRpYVRyYWNrVHJhbnNjZWl2ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgcGxheVBhdXNlZEVsZW1lbnRzSWZOb3RCYWNrZ3JvdW5kZWQ6IGd1ZXNzQnJvd3NlcigpID09PSAnc2FmYXJpJ1xuICAgICAgICAgICAgICAgICYmIHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAmJiB0eXBlb2YgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICYmIHR5cGVvZiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdzdHJpbmcnXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lZGlhVHJhY2tUcmFuc2NlaXZlci5pZCwgbWVkaWFUcmFja1RyYW5zY2VpdmVyLmtpbmQsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIHZhciBpc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgTWVkaWFTdHJlYW06IE1lZGlhU3RyZWFtXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2F0dGFjaG1lbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kdW1teUVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZWxTaGltczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgV2Vha01hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzU3RhcnRlZDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNTdGFydGVkO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2lzU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0ZWQgPSBfaXNTdGFydGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcGxheVBhdXNlZEVsZW1lbnRzSWZOb3RCYWNrZ3JvdW5kZWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5wbGF5UGF1c2VkRWxlbWVudHNJZk5vdEJhY2tncm91bmRlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaG91bGRTaGltQXR0YWNoZWRFbGVtZW50czoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLndvcmthcm91bmRXZWJLaXRCdWcyMTI3ODBcbiAgICAgICAgICAgICAgICAgICAgfHwgb3B0aW9ucy5wbGF5UGF1c2VkRWxlbWVudHNJZk5vdEJhY2tncm91bmRlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF91bnByb2Nlc3NlZFRyYWNrOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfTWVkaWFTdHJlYW06IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5NZWRpYVN0cmVhbVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzU3RhcnRlZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1N0YXJ0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lZGlhU3RyZWFtVHJhY2s6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5wcm9jZXNzZWRUcmFjayB8fCBtZWRpYVRyYWNrVHJhbnNjZWl2ZXIudHJhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3NlZFRyYWNrOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuX2luaXRpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1lZGlhVHJhY2sucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdTdGFydGVkJyk7XG4gICAgICAgIHRoaXMuX2lzU3RhcnRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9kdW1teUVsKSB7XG4gICAgICAgICAgICB0aGlzLl9kdW1teUVsLm9uY2FucGxheSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHRoaXMuZW1pdCgnc3RhcnRlZCcsIHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0luaXRpYWxpemluZycpO1xuICAgICAgICB0aGlzLl9kdW1teUVsID0gdGhpcy5fY3JlYXRlRWxlbWVudCgpO1xuICAgICAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBmdW5jdGlvbiBvbmVuZGVkKCkge1xuICAgICAgICAgICAgc2VsZi5fZW5kKCk7XG4gICAgICAgICAgICBzZWxmLm1lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBvbmVuZGVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9kdW1teUVsKSB7XG4gICAgICAgICAgICB0aGlzLl9kdW1teUVsLm11dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2R1bW15RWwub25jYW5wbGF5ID0gdGhpcy5fc3RhcnQuYmluZCh0aGlzLCB0aGlzLl9kdW1teUVsKTtcbiAgICAgICAgICAgIC8vIE5PVEUoY3NhbnRvcyk6IFdlIGFsd2F5cyB3YW50IHRvIGF0dGFjaCB0aGUgb3JpZ2luYWwgbWVkaWFTdHJlYW1UcmFjayBmb3IgZHVtbXlFbFxuICAgICAgICAgICAgdGhpcy5fYXR0YWNoKHRoaXMuX2R1bW15RWwsIHRoaXMubWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2htZW50cy5kZWxldGUodGhpcy5fZHVtbXlFbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWVkaWFUcmFjay5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdFbmRlZCcpO1xuICAgICAgICBpZiAodGhpcy5fZHVtbXlFbCkge1xuICAgICAgICAgICAgdGhpcy5fZHVtbXlFbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuX2R1bW15RWwuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2R1bW15RWwub25jYW5wbGF5ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2R1bW15RWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZWRpYVRyYWNrLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVsID0gdGhpcy5fc2VsZWN0RWxlbWVudChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWVsKSB7XG4gICAgICAgICAgICBlbCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0F0dGVtcHRpbmcgdG8gYXR0YWNoIHRvIGVsZW1lbnQ6JywgZWwpO1xuICAgICAgICBlbCA9IHRoaXMuX2F0dGFjaChlbCk7XG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRTaGltQXR0YWNoZWRFbGVtZW50cyAmJiAhdGhpcy5fZWxTaGltcy5oYXMoZWwpKSB7XG4gICAgICAgICAgICB2YXIgb25VbmludGVudGlvbmFsbHlQYXVzZWQgPSB0aGlzLl9wbGF5UGF1c2VkRWxlbWVudHNJZk5vdEJhY2tncm91bmRlZFxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGxheUlmUGF1c2VkQW5kTm90QmFja2dyb3VuZGVkKGVsLCBfdGhpcy5fbG9nKTsgfVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2VsU2hpbXMuc2V0KGVsLCBzaGltTWVkaWFFbGVtZW50KGVsLCBvblVuaW50ZW50aW9uYWxseVBhdXNlZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGUgcHJvdmlkZWQgTWVkaWFTdHJlYW1UcmFjayB0byB0aGUgbWVkaWEgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gZWwgLSBUaGUgbWVkaWEgZWxlbWVudCB0byBhdHRhY2ggdG9cbiAgICAgKiBAcGFyYW0gbWVkaWFTdHJlYW1UcmFjayAtIFRoZSBNZWRpYVN0cmVhbVRyYWNrIHRvIGF0dGFjaC4gSWYgdGhpcyBpc1xuICAgICAqIG5vdCBwcm92aWRlZCwgaXQgdXNlcyB0aGUgcHJvY2Vzc2VkVHJhY2sgaWYgaXQgZXhpc3RzXG4gICAgICogb3IgaXQgZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgbWVkaWFTdHJlYW1UcmFja1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWVkaWFUcmFjay5wcm90b3R5cGUuX2F0dGFjaCA9IGZ1bmN0aW9uIChlbCwgbWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICBpZiAobWVkaWFTdHJlYW1UcmFjayA9PT0gdm9pZCAwKSB7IG1lZGlhU3RyZWFtVHJhY2sgPSB0aGlzLnByb2Nlc3NlZFRyYWNrIHx8IHRoaXMubWVkaWFTdHJlYW1UcmFjazsgfVxuICAgICAgICB2YXIgbWVkaWFTdHJlYW0gPSBlbC5zcmNPYmplY3Q7XG4gICAgICAgIGlmICghKG1lZGlhU3RyZWFtIGluc3RhbmNlb2YgdGhpcy5fTWVkaWFTdHJlYW0pKSB7XG4gICAgICAgICAgICBtZWRpYVN0cmVhbSA9IG5ldyB0aGlzLl9NZWRpYVN0cmVhbSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZXRUcmFja3MgPSBtZWRpYVN0cmVhbVRyYWNrLmtpbmQgPT09ICdhdWRpbydcbiAgICAgICAgICAgID8gJ2dldEF1ZGlvVHJhY2tzJ1xuICAgICAgICAgICAgOiAnZ2V0VmlkZW9UcmFja3MnO1xuICAgICAgICBtZWRpYVN0cmVhbVtnZXRUcmFja3NdKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgIG1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1lZGlhU3RyZWFtLmFkZFRyYWNrKG1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogcmVzZXR0aW5nIGBzcmNPYmplY3RgIGhlcmUsIGNhdXNlcyBmbGlja2VyIChKU0RLLTI2NDEpLCBidXQgaXQgbGV0cyB1c1xuICAgICAgICAvLyB0byBzaWRlc3RlcCB0aGUgYSBjaHJvbWUgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDUyMzUzXG4gICAgICAgIC8vXG4gICAgICAgIGVsLnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgICAgICBlbC5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIGVsLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9hdHRhY2htZW50cy5oYXMoZWwpKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2htZW50cy5hZGQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWVkaWFUcmFjay5wcm90b3R5cGUuX3NlbGVjdEVsZW1lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdG9yIG1hdGNoZWQgbm8gZWxlbWVudDogXCIgKyBzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrLnByb3RvdHlwZS5fdXBkYXRlRWxlbWVudHNNZWRpYVN0cmVhbVRyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ1JlYXR0YWNoaW5nIGFsbCBlbGVtZW50cyB0byB1cGRhdGUgbWVkaWFTdHJlYW1UcmFjaycpO1xuICAgICAgICB0aGlzLl9nZXRBbGxBdHRhY2hlZEVsZW1lbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIF90aGlzLl9hdHRhY2goZWwpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWVkaWFUcmFjay5wcm90b3R5cGUuX2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5raW5kKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH07XG4gICAgTWVkaWFUcmFjay5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBlbHM7XG4gICAgICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbHMgPSBbdGhpcy5fc2VsZWN0RWxlbWVudChlbCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFlbCkge1xuICAgICAgICAgICAgZWxzID0gdGhpcy5fZ2V0QWxsQXR0YWNoZWRFbGVtZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxzID0gW2VsXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0F0dGVtcHRpbmcgdG8gZGV0YWNoIGZyb20gZWxlbWVudHM6JywgZWxzKTtcbiAgICAgICAgdGhpcy5fZGV0YWNoRWxlbWVudHMoZWxzKTtcbiAgICAgICAgcmV0dXJuIGVsID8gZWxzWzBdIDogZWxzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrLnByb3RvdHlwZS5fZGV0YWNoRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLm1hcCh0aGlzLl9kZXRhY2hFbGVtZW50LmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrLnByb3RvdHlwZS5fZGV0YWNoRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoIXRoaXMuX2F0dGFjaG1lbnRzLmhhcyhlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVkaWFTdHJlYW0gPSBlbC5zcmNPYmplY3Q7XG4gICAgICAgIGlmIChtZWRpYVN0cmVhbSBpbnN0YW5jZW9mIHRoaXMuX01lZGlhU3RyZWFtKSB7XG4gICAgICAgICAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayh0aGlzLnByb2Nlc3NlZFRyYWNrIHx8IHRoaXMubWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNobWVudHMuZGVsZXRlKGVsKTtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFNoaW1BdHRhY2hlZEVsZW1lbnRzICYmIHRoaXMuX2VsU2hpbXMuaGFzKGVsKSkge1xuICAgICAgICAgICAgdmFyIHNoaW0gPSB0aGlzLl9lbFNoaW1zLmdldChlbCk7XG4gICAgICAgICAgICBzaGltLnVuU2hpbSgpO1xuICAgICAgICAgICAgdGhpcy5fZWxTaGltcy5kZWxldGUoZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWVkaWFUcmFjay5wcm90b3R5cGUuX2dldEFsbEF0dGFjaGVkRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbHMgPSBbXTtcbiAgICAgICAgdGhpcy5fYXR0YWNobWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVscy5wdXNoKGVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbHM7XG4gICAgfTtcbiAgICByZXR1cm4gTWVkaWFUcmFjaztcbn0oVHJhY2spKTtcbi8qKlxuICogUGxheSBhbiBIVE1MTWVkaWFFbGVtZW50IGlmIGl0IGlzIHBhdXNlZCBhbmQgbm90IGJhY2tncm91bmRlZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0xvZ30gbG9nXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gcGxheUlmUGF1c2VkQW5kTm90QmFja2dyb3VuZGVkKGVsLCBsb2cpIHtcbiAgICB2YXIgdGFnID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGxvZy53YXJuKCdVbmludGVudGlvbmFsbHkgcGF1c2VkOicsIGVsKTtcbiAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBXaGVuIHRoZSBlbGVtZW50IGlzIHVuaW50ZW50aW9uYWxseSBwYXVzZWQsIHdlIHdhaXQgb25lXG4gICAgLy8gc2Vjb25kIGZvciB0aGUgXCJvbnZpc2liaWxpdHljaGFuZ2VcIiBldmVudCBvbiB0aGUgSFRNTERvY3VtZW50IHRvIHNlZSBpZiB0aGVcbiAgICAvLyBhcHAgd2lsbCBiZSBiYWNrZ3JvdW5kZWQuIElmIG5vdCwgdGhlbiB0aGUgZWxlbWVudCBjYW4gYmUgc2FmZWx5IHBsYXllZC5cbiAgICBQcm9taXNlLnJhY2UoW1xuICAgICAgICB3YWl0Rm9yRXZlbnQoZG9jdW1lbnQsICd2aXNpYmlsaXR5Y2hhbmdlJyksXG4gICAgICAgIHdhaXRGb3JTb21ldGltZSgxMDAwKVxuICAgIF0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFdlIHBsYXkgdGhlIGluYWR2ZXJ0ZW50bHkgcGF1c2VkIGVsZW1lbnRzIG9ubHkgYWZ0ZXJcbiAgICAgICAgICAgIC8vIHRoZSBMb2NhbEF1ZGlvVHJhY2sgaXMgdW5tdXRlZCB0byB3b3JrIGFyb3VuZCBXZWJLaXQgQnVnIDIxMzg1My5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBCdWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMTM4NTNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBsb2NhbE1lZGlhUmVzdGFydERlZmVycmVkcy53aGVuUmVzb2x2ZWQoJ2F1ZGlvJykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oXCJQbGF5aW5nIHVuaW50ZW50aW9uYWxseSBwYXVzZWQgPFwiICsgdGFnICsgXCI+IGVsZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKCdFbGVtZW50OicsIGVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwucGxheSgpO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oXCJTdWNjZXNzZnVsbHkgcGxheWVkIHVuaW50ZW50aW9uYWxseSBwYXVzZWQgPFwiICsgdGFnICsgXCI+IGVsZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKCdFbGVtZW50OicsIGVsKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiRXJyb3Igd2hpbGUgcGxheWluZyB1bmludGVudGlvbmFsbHkgcGF1c2VkIDxcIiArIHRhZyArIFwiPiBlbGVtZW50OlwiLCB7IGVycm9yOiBlcnJvciwgZWw6IGVsIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogU2hpbSB0aGUgcGF1c2UoKSBhbmQgcGxheSgpIG1ldGhvZHMgb2YgdGhlIGdpdmVuIEhUTUxNZWRpYUVsZW1lbnQgc28gdGhhdFxuICogd2UgY2FuIGRldGVjdCBpZiBpdCB3YXMgcGF1c2VkIHVuaW50ZW50aW9uYWxseS5cbiAqIEBwYXJhbSB7SFRNTE1lZGlhRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBbb25VbmludGVudGlvbmFsbHlQYXVzZWQ9bnVsbF1cbiAqIEByZXR1cm5zIHt7cGF1c2VkSW50ZW50aW9uYWxseTogZnVuY3Rpb24sIHVuU2hpbTogZnVuY3Rpb259fVxuICovXG5mdW5jdGlvbiBzaGltTWVkaWFFbGVtZW50KGVsLCBvblVuaW50ZW50aW9uYWxseVBhdXNlZCkge1xuICAgIGlmIChvblVuaW50ZW50aW9uYWxseVBhdXNlZCA9PT0gdm9pZCAwKSB7IG9uVW5pbnRlbnRpb25hbGx5UGF1c2VkID0gbnVsbDsgfVxuICAgIHZhciBvcmlnUGF1c2UgPSBlbC5wYXVzZTtcbiAgICB2YXIgb3JpZ1BsYXkgPSBlbC5wbGF5O1xuICAgIHZhciBwYXVzZWRJbnRlbnRpb25hbGx5ID0gZmFsc2U7XG4gICAgZWwucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhdXNlZEludGVudGlvbmFsbHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gb3JpZ1BhdXNlLmNhbGwoZWwpO1xuICAgIH07XG4gICAgZWwucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGF1c2VkSW50ZW50aW9uYWxseSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb3JpZ1BsYXkuY2FsbChlbCk7XG4gICAgfTtcbiAgICB2YXIgb25QYXVzZSA9IG9uVW5pbnRlbnRpb25hbGx5UGF1c2VkID8gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXBhdXNlZEludGVudGlvbmFsbHkpIHtcbiAgICAgICAgICAgIG9uVW5pbnRlbnRpb25hbGx5UGF1c2VkKCk7XG4gICAgICAgIH1cbiAgICB9IDogbnVsbDtcbiAgICBpZiAob25QYXVzZSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIG9uUGF1c2UpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXVzZWRJbnRlbnRpb25hbGx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF1c2VkSW50ZW50aW9uYWxseTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5TaGltOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbC5wYXVzZSA9IG9yaWdQYXVzZTtcbiAgICAgICAgICAgIGVsLnBsYXkgPSBvcmlnUGxheTtcbiAgICAgICAgICAgIGlmIChvblBhdXNlKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGF1c2UnLCBvblBhdXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IE1lZGlhVHJhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZWRpYXRyYWNrLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTWVkaWFUcmFja1RyYW5zY2VpdmVyID0gcmVxdWlyZSgnLi90cmFuc2NlaXZlcicpO1xuLyoqXG4gKiBBIHtAbGluayBNZWRpYVRyYWNrUmVjZWl2ZXJ9IHJlcHJlc2VudHMgYSByZW1vdGUgTWVkaWFTdHJlYW1UcmFjay5cbiAqIEBleHRlbmRzIE1lZGlhVHJhY2tUcmFuc2NlaXZlclxuICovXG52YXIgTWVkaWFUcmFja1JlY2VpdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZWRpYVRyYWNrUmVjZWl2ZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIE1lZGlhVHJhY2tSZWNlaXZlcn0uXG4gICAgICogQHBhcmFtIHtUcmFjay5JRH0gaWQgLSBUaGUgTWVkaWFTdHJlYW1UcmFjayBJRCBzaWduYWxlZCB0aHJvdWdoIFJTUC9TRFBcbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IG1lZGlhU3RyZWFtVHJhY2sgLSBUaGUgcmVtb3RlIE1lZGlhU3RyZWFtVHJhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZWRpYVRyYWNrUmVjZWl2ZXIoaWQsIG1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGlkLCBtZWRpYVN0cmVhbVRyYWNrKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWVkaWFUcmFja1JlY2VpdmVyO1xufShNZWRpYVRyYWNrVHJhbnNjZWl2ZXIpKTtcbm1vZHVsZS5leHBvcnRzID0gTWVkaWFUcmFja1JlY2VpdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjZWl2ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBBdWRpb1RyYWNrID0gcmVxdWlyZSgnLi9hdWRpb3RyYWNrJyk7XG52YXIgbWl4aW5SZW1vdGVNZWRpYVRyYWNrID0gcmVxdWlyZSgnLi9yZW1vdGVtZWRpYXRyYWNrJyk7XG52YXIgUmVtb3RlTWVkaWFBdWRpb1RyYWNrID0gbWl4aW5SZW1vdGVNZWRpYVRyYWNrKEF1ZGlvVHJhY2spO1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSByZXByZXNlbnRzIGFuIHtAbGluayBBdWRpb1RyYWNrfSBwdWJsaXNoZWQgdG8gYVxuICoge0BsaW5rIFJvb219IGJ5IGEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fS5cbiAqIEBleHRlbmRzIEF1ZGlvVHJhY2tcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNFbmFibGVkIC0gV2hldGhlciB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IGlzIGVuYWJsZWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTd2l0Y2hlZE9mZiAtIFdoZXRoZXIgdGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSBpcyBzd2l0Y2hlZCBvZmZcbiAqIEBwcm9wZXJ0eSB7VHJhY2suU0lEfSBzaWQgLSBUaGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9J3MgU0lEXG4gKiBAcHJvcGVydHkgez9UcmFjay5Qcmlvcml0eX0gcHJpb3JpdHkgLSBUaGUgc3Vic2NyaWJlIHByaW9yaXR5IG9mIHRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja31cbiAqIEBlbWl0cyBSZW1vdGVBdWRpb1RyYWNrI2Rpc2FibGVkXG4gKiBAZW1pdHMgUmVtb3RlQXVkaW9UcmFjayNlbmFibGVkXG4gKiBAZW1pdHMgUmVtb3RlQXVkaW9UcmFjayNzdGFydGVkXG4gKiBAZW1pdHMgUmVtb3RlQXVkaW9UcmFjayNzd2l0Y2hlZE9mZlxuICogQGVtaXRzIFJlbW90ZUF1ZGlvVHJhY2sjc3dpdGNoZWRPblxuICovXG52YXIgUmVtb3RlQXVkaW9UcmFjayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVtb3RlQXVkaW9UcmFjaywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30uXG4gICAgICogQHBhcmFtIHtUcmFjay5TSUR9IHNpZCAtIFRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30ncyBTSURcbiAgICAgKiBAcGFyYW0ge01lZGlhVHJhY2tSZWNlaXZlcn0gbWVkaWFUcmFja1JlY2VpdmVyIC0gQW4gYXVkaW8gTWVkaWFTdHJlYW1UcmFjayBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRW5hYmxlZCAtIFdoZXRoZXIgdGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSBpcyBlbmFibGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1N3aXRjaGVkT2ZmIC0gV2hldGhlciB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IGlzIHN3aXRjaGVkIG9mZlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP1RyYWNrLlByaW9yaXR5KTogdm9pZH0gc2V0UHJpb3JpdHkgLSBTZXQgb3IgY2xlYXIgdGhlIHN1YnNjcmliZVxuICAgICAqICB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IG9mIHRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja31cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKENsaWVudFJlbmRlckhpbnQpOiB2b2lkfSBzZXRSZW5kZXJIaW50IC0gU2V0IHJlbmRlciBoaW50cy5cbiAgICAgKiBAcGFyYW0ge3tsb2c6IExvZ319IG9wdGlvbnMgLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrfSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVtb3RlQXVkaW9UcmFjayhzaWQsIG1lZGlhVHJhY2tSZWNlaXZlciwgaXNFbmFibGVkLCBpc1N3aXRjaGVkT2ZmLCBzZXRQcmlvcml0eSwgc2V0UmVuZGVySGludCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc2lkLCBtZWRpYVRyYWNrUmVjZWl2ZXIsIGlzRW5hYmxlZCwgaXNTd2l0Y2hlZE9mZiwgc2V0UHJpb3JpdHksIHNldFJlbmRlckhpbnQsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFJlbW90ZUF1ZGlvVHJhY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbUmVtb3RlQXVkaW9UcmFjayAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgdGhpcy5zaWQgKyBcIl1cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc3Vic2NyaWJlIHtAbGluayBUcmFjay5Qcmlvcml0eX0gb2YgdGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfS5cbiAgICAgKiBAcGFyYW0gez9UcmFjay5Qcmlvcml0eX0gcHJpb3JpdHkgLSB0aGUgbmV3IHN1YnNjcmliZSB7QGxpbmsgVHJhY2suUHJpb3JpdHl9O1xuICAgICAqICAgQ3VycmVudGx5IHNldFByaW9yaXR5IGhhcyBubyBlZmZlY3Qgb24gYXVkaW8gdHJhY2tzLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9XG4gICAgICovXG4gICAgUmVtb3RlQXVkaW9UcmFjay5wcm90b3R5cGUuc2V0UHJpb3JpdHkgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc2V0UHJpb3JpdHkuY2FsbCh0aGlzLCBwcmlvcml0eSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVtb3RlQXVkaW9UcmFjaztcbn0oUmVtb3RlTWVkaWFBdWRpb1RyYWNrKSk7XG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gd2FzIGRpc2FibGVkLCBpLmUuIFwibXV0ZWRcIi5cbiAqIEBwYXJhbSB7UmVtb3RlQXVkaW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IHRoYXQgd2FzXG4gKiAgIGRpc2FibGVkXG4gKiBAZXZlbnQgUmVtb3RlQXVkaW9UcmFjayNkaXNhYmxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gd2FzIGVuYWJsZWQsIGkuZS4gXCJ1bm11dGVkXCIuXG4gKiBAcGFyYW0ge1JlbW90ZUF1ZGlvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSB0aGF0IHdhc1xuICogICBlbmFibGVkXG4gKiBAZXZlbnQgUmVtb3RlQXVkaW9UcmFjayNlbmFibGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSBzdGFydGVkLiBUaGlzIG1lYW5zIHRoZXJlIGlzIGVub3VnaCBhdWRpbyBkYXRhXG4gKiB0byBiZWdpbiBwbGF5YmFjay5cbiAqIEBwYXJhbSB7UmVtb3RlQXVkaW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IHRoYXQgc3RhcnRlZFxuICogQGV2ZW50IFJlbW90ZUF1ZGlvVHJhY2sjc3RhcnRlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IHdhcyBzd2l0Y2hlZCBvZmYuXG4gKiBAcGFyYW0ge1JlbW90ZUF1ZGlvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSB0aGF0IHdhc1xuICogICBzd2l0Y2hlZCBvZmZcbiAqIEBldmVudCBSZW1vdGVBdWRpb1RyYWNrI3N3aXRjaGVkT2ZmXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gd2FzIHN3aXRjaGVkIG9uLlxuICogQHBhcmFtIHtSZW1vdGVBdWRpb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gdGhhdCB3YXNcbiAqICAgc3dpdGNoZWQgb25cbiAqIEBldmVudCBSZW1vdGVBdWRpb1RyYWNrI3N3aXRjaGVkT25cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVBdWRpb1RyYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RlYXVkaW90cmFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFJlbW90ZVRyYWNrUHVibGljYXRpb24gPSByZXF1aXJlKCcuL3JlbW90ZXRyYWNrcHVibGljYXRpb24nKTtcbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9ufSByZXByZXNlbnRzIGEge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9XG4gKiB0aGF0IGhhcyBiZWVuIHB1Ymxpc2hlZCB0byBhIHtAbGluayBSb29tfS5cbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZCAtIFwiYXVkaW9cIlxuICogQHByb3BlcnR5IHs/UmVtb3RlQXVkaW9UcmFja30gdHJhY2sgLSB1bmxlc3MgeW91IGhhdmUgc3Vic2NyaWJlZCB0byB0aGVcbiAqICAge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9LCB0aGlzIHByb3BlcnR5IGlzIG51bGxcbiAqIEBlbWl0cyBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24jc3Vic2NyaWJlZFxuICogQGVtaXRzIFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbiNzdWJzY3JpcHRpb25GYWlsZWRcbiAqIEBlbWl0cyBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24jdHJhY2tEaXNhYmxlZFxuICogQGVtaXRzIFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbiN0cmFja0VuYWJsZWRcbiAqIEBlbWl0cyBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24jdW5zdWJzY3JpYmVkXG4gKi9cbnZhciBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9ufS5cbiAgICAgKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9IHNpZ25hbGluZyAtIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBzaWduYWxpbmdcbiAgICAgKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb25PcHRpb25zfSBvcHRpb25zIC0ge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259XG4gICAgICogICBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uKHNpZ25hbGluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc2lnbmFsaW5nLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyBcIjogXCIgKyB0aGlzLnRyYWNrU2lkICsgXCJdXCI7XG4gICAgfTtcbiAgICByZXR1cm4gUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uO1xufShSZW1vdGVUcmFja1B1YmxpY2F0aW9uKSk7XG4vKipcbiAqIFlvdXIge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IHN1YnNjcmliZWQgdG8gdGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfS5cbiAqIEBwYXJhbSB7UmVtb3RlQXVkaW9UcmFja30gdHJhY2sgLSB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IHRoYXQgd2FzIHN1YnNjcmliZWQgdG9cbiAqIEBldmVudCBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24jc3Vic2NyaWJlZFxuICovXG4vKipcbiAqIFlvdXIge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IGZhaWxlZCB0byBzdWJzY3JpYmUgdG8gdGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfS5cbiAqIEBwYXJhbSB7VHdpbGlvRXJyb3J9IGVycm9yIC0gdGhlIHJlYXNvbiB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IGNvdWxkIG5vdCBiZVxuICogICBzdWJzY3JpYmVkIHRvXG4gKiBAZXZlbnQgUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uI3N1YnNjcmlwdGlvbkZhaWxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja30gd2FzIGRpc2FibGVkLlxuICogQGV2ZW50IFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbiN0cmFja0Rpc2FibGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfSB3YXMgZW5hYmxlZC5cbiAqIEBldmVudCBSZW1vdGVBdWRpb1RyYWNrUHVibGljYXRpb24jdHJhY2tFbmFibGVkXG4gKi9cbi8qKlxuICogWW91ciB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gdW5zdWJzY3JpYmVkIGZyb20gdGhlIHtAbGluayBSZW1vdGVBdWRpb1RyYWNrfS5cbiAqIEBwYXJhbSB7UmVtb3RlQXVkaW9UcmFja30gdHJhY2sgLSB0aGUge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2t9IHRoYXQgd2FzIHVuc3Vic2NyaWJlZCBmcm9tXG4gKiBAZXZlbnQgUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uI3Vuc3Vic2NyaWJlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW90ZWF1ZGlvdHJhY2twdWJsaWNhdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgICAgICB0b1tqXSA9IGZyb21baV07XG4gICAgcmV0dXJuIHRvO1xufTtcbnZhciBUcmFjayA9IHJlcXVpcmUoJy4vJyk7XG52YXIgX2EgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbnN0YW50cycpLCBFID0gX2EudHlwZUVycm9ycywgdHJhY2tQcmlvcml0eSA9IF9hLnRyYWNrUHJpb3JpdHk7XG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZURhdGFUcmFja30gcmVwcmVzZW50cyBkYXRhIHB1Ymxpc2hlZCB0byBhIHtAbGluayBSb29tfSBieSBhXG4gKiB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9LlxuICogQGV4dGVuZHMgVHJhY2tcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNFbmFibGVkIC0gdHJ1ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1N1YnNjcmliZWQgLSBXaGV0aGVyIHRoZSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfSBpc1xuICogICBzdWJzY3JpYmVkIHRvXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU3dpdGNoZWRPZmYgLSBXaGV0aGVyIHRoZSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfSBpc1xuICogICBzd2l0Y2hlZCBvZmZcbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZCAtIFwiZGF0YVwiXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IG1heFBhY2tldExpZmVUaW1lIC0gSWYgbm9uLW51bGwsIHRoaXMgcmVwcmVzZW50cyBhIHRpbWVcbiAqICAgbGltaXQgKGluIG1pbGxpc2Vjb25kcykgZHVyaW5nIHdoaWNoIGRhdGEgd2lsbCBiZSB0cmFuc21pdHRlZCBvclxuICogICByZXRyYW5zbWl0dGVkIGlmIG5vdCBhY2tub3dsZWRnZWQgb24gdGhlIHVuZGVybHlpbmcgUlRDRGF0YUNoYW5uZWwuXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IG1heFJldHJhbnNtaXRzIC0gSWYgbm9uLW51bGwsIHRoaXMgcmVwcmVzZW50cyB0aGUgbnVtYmVyXG4gKiAgIG9mIHRpbWVzIHRoZSBkYXRhIHdpbGwgYmUgcmV0cmFuc21pdHRlZCBpZiBub3Qgc3VjY2Vzc2Z1bGx5IHJlY2VpdmVkIG9uIHRoZVxuICogICB1bmRlcmx5aW5nIFJUQ0RhdGFDaGFubmVsLlxuICogQHByb3BlcnR5IHtib29sZWFufSBvcmRlcmVkIC0gdHJ1ZSBpZiBkYXRhIG9uIHRoZSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfSBjYW5cbiAqICAgYmUgcmVjZWl2ZWQgb3V0LW9mLW9yZGVyLlxuICogQHByb3BlcnR5IHs/VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5IC0gVGhlIHN1YnNjcmliZSBwcmlvcml0eSBvZiB0aGUge0BsaW5rIFJlbW90ZURhdGFUcmFja31cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcmVsaWFibGUgLSBUaGlzIGlzIHRydWUgaWYgYm90aFxuICogICA8Y29kZT5tYXhQYWNrZXRMaWZlVGltZTwvY29kZT4gYW5kIDxjb2RlPm1heFJldHJhbnNtaXRzPC9jb2RlPiBhcmUgc2V0IHRvXG4gKiAgIG51bGwuIEluIG90aGVyIHdvcmRzLCBpZiB0aGlzIGlzIHRydWUsIHRoZXJlIGlzIG5vIGJvdW5kIG9uIHBhY2tldCBsaWZldGltZVxuICogICBvciB0aGUgbnVtYmVyIG9mIHJldHJhbnNtaXRzIHRoYXQgd2lsbCBiZSBhdHRlbXB0ZWQsIGVuc3VyaW5nIFwicmVsaWFibGVcIlxuICogICB0cmFuc21pc3Npb24uXG4gKiBAcHJvcGVydHkge1RyYWNrLlNJRH0gc2lkIC0gVGhlIFNJRCBhc3NpZ25lZCB0byB0aGUge0BsaW5rIFJlbW90ZURhdGFUcmFja31cbiAqIEBlbWl0cyBSZW1vdGVEYXRhVHJhY2sjbWVzc2FnZVxuICogQGVtaXRzIFJlbW90ZURhdGFUcmFjayNzd2l0Y2hlZE9mZlxuICogQGVtaXRzIFJlbW90ZURhdGFUcmFjayNzd2l0Y2hlZE9uXG4gKi9cbnZhciBSZW1vdGVEYXRhVHJhY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbW90ZURhdGFUcmFjaywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfSBmcm9tIGEge0BsaW5rIERhdGFUcmFja1JlY2VpdmVyfS5cbiAgICAgKiBAcGFyYW0ge1RyYWNrLlNJRH0gc2lkXG4gICAgICogQHBhcmFtIHtEYXRhVHJhY2tSZWNlaXZlcn0gZGF0YVRyYWNrUmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0ge3tsb2c6IExvZywgbmFtZTogP3N0cmluZ319IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZW1vdGVEYXRhVHJhY2soc2lkLCBkYXRhVHJhY2tSZWNlaXZlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkYXRhVHJhY2tSZWNlaXZlci5pZCwgJ2RhdGEnLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2lzU3dpdGNoZWRPZmY6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcHJpb3JpdHk6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRW5hYmxlZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1N3aXRjaGVkT2ZmOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzU3dpdGNoZWRPZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YVRyYWNrUmVjZWl2ZXIubWF4UGFja2V0TGlmZVRpbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0czoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFUcmFja1JlY2VpdmVyLm1heFJldHJhbnNtaXRzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3JkZXJlZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFUcmFja1JlY2VpdmVyLm9yZGVyZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmlvcml0eToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmlvcml0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVsaWFibGU6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhVHJhY2tSZWNlaXZlci5tYXhQYWNrZXRMaWZlVGltZSA9PT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAmJiBkYXRhVHJhY2tSZWNlaXZlci5tYXhSZXRyYW5zbWl0cyA9PT0gbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHNpZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGF0YVRyYWNrUmVjZWl2ZXIub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEsIF90aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzdWJzY3JpYmVyIHtAbGluayBUcmFjay5Qcmlvcml0eX0gb2YgdGhlIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9LlxuICAgICAqIEBwYXJhbSB7P1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eSAtIHRoZSBuZXcge0BsaW5rIFRyYWNrLnByaW9yaXR5fTtcbiAgICAgKiAgIEN1cnJlbnRseSBzZXRQcmlvcml0eSBoYXMgbm8gZWZmZWN0IG9uIGRhdGEgdHJhY2tzLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9XG4gICAgICovXG4gICAgUmVtb3RlRGF0YVRyYWNrLnByb3RvdHlwZS5zZXRQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xuICAgICAgICB2YXIgcHJpb3JpdHlWYWx1ZXMgPSBfX3NwcmVhZEFycmF5KFtudWxsXSwgX19yZWFkKE9iamVjdC52YWx1ZXModHJhY2tQcmlvcml0eSkpKTtcbiAgICAgICAgaWYgKCFwcmlvcml0eVZhbHVlcy5pbmNsdWRlcyhwcmlvcml0eSkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gICAgICAgICAgICB0aHJvdyBFLklOVkFMSURfVkFMVUUoJ3ByaW9yaXR5JywgcHJpb3JpdHlWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IHByaW9yaXR5IGhhcyBubyByZWFsIGVmZmVjdCBvbiB0aGUgZGF0YSB0cmFja3MuXG4gICAgICAgIHRoaXMuX3ByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZW1vdGVEYXRhVHJhY2sucHJvdG90eXBlLl9zZXRFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3dpdGNoZWRPZmZcbiAgICAgKi9cbiAgICBSZW1vdGVEYXRhVHJhY2sucHJvdG90eXBlLl9zZXRTd2l0Y2hlZE9mZiA9IGZ1bmN0aW9uIChpc1N3aXRjaGVkT2ZmKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1N3aXRjaGVkT2ZmICE9PSBpc1N3aXRjaGVkT2ZmKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1N3aXRjaGVkT2ZmID0gaXNTd2l0Y2hlZE9mZjtcbiAgICAgICAgICAgIHRoaXMuZW1pdChpc1N3aXRjaGVkT2ZmID8gJ3N3aXRjaGVkT2ZmJyA6ICdzd2l0Y2hlZE9uJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZW1vdGVEYXRhVHJhY2s7XG59KFRyYWNrKSk7XG4vKipcbiAqIEEgbWVzc2FnZSB3YXMgcmVjZWl2ZWQgb3ZlciB0aGUge0BsaW5rIFJlbW90ZURhdGFUcmFja30uXG4gKiBAZXZlbnQgUmVtb3RlRGF0YVRyYWNrI21lc3NhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5QnVmZmVyfSBkYXRhXG4gKiBAcGFyYW0ge1JlbW90ZURhdGFUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZURhdGFUcmFja30gdGhhdCByZWNlaXZlZFxuICogICB0aGUgbWVzc2FnZVxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZURhdGFUcmFja30gd2FzIHN3aXRjaGVkIG9mZi5cbiAqIEBwYXJhbSB7UmVtb3RlRGF0YVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfSB0aGF0IHdhc1xuICogICBzd2l0Y2hlZCBvZmZcbiAqIEBldmVudCBSZW1vdGVEYXRhVHJhY2sjc3dpdGNoZWRPZmZcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9IHdhcyBzd2l0Y2hlZCBvbi5cbiAqIEBwYXJhbSB7UmVtb3RlRGF0YVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfSB0aGF0IHdhc1xuICogICBzd2l0Y2hlZCBvblxuICogQGV2ZW50IFJlbW90ZURhdGFUcmFjayNzd2l0Y2hlZE9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlRGF0YVRyYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RlZGF0YXRyYWNrLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiA9IHJlcXVpcmUoJy4vcmVtb3RldHJhY2twdWJsaWNhdGlvbicpO1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbn0gcmVwcmVzZW50cyBhIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9XG4gKiB0aGF0IGhhcyBiZWVuIHB1Ymxpc2hlZCB0byBhIHtAbGluayBSb29tfS5cbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZCAtIFwiZGF0YVwiXG4gKiBAcHJvcGVydHkgez9SZW1vdGVEYXRhVHJhY2t9IHRyYWNrIC0gdW5sZXNzIHlvdSBoYXZlIHN1YnNjcmliZWQgdG8gdGhlXG4gKiAgIHtAbGluayBSZW1vdGVEYXRhVHJhY2t9LCB0aGlzIHByb3BlcnR5IGlzIG51bGxcbiAqIEBlbWl0cyBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbiNzdWJzY3JpYmVkXG4gKiBAZW1pdHMgUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb24jc3Vic2NyaXB0aW9uRmFpbGVkXG4gKiBAZW1pdHMgUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb24jdW5zdWJzY3JpYmVkXG4gKi9cbnZhciBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9ufS5cbiAgICAgKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9IHNpZ25hbGluZyAtIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBzaWduYWxpbmdcbiAgICAgKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb25PcHRpb25zfSBvcHRpb25zIC0ge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259XG4gICAgICogICBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb24oc2lnbmFsaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzaWduYWxpbmcsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW1JlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyBcIjogXCIgKyB0aGlzLnRyYWNrU2lkICsgXCJdXCI7XG4gICAgfTtcbiAgICByZXR1cm4gUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb247XG59KFJlbW90ZVRyYWNrUHVibGljYXRpb24pKTtcbi8qKlxuICogWW91ciB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gc3Vic2NyaWJlZCB0byB0aGUge0BsaW5rIFJlbW90ZURhdGFUcmFja30uXG4gKiBAcGFyYW0ge1JlbW90ZURhdGFUcmFja30gdHJhY2sgLSB0aGUge0BsaW5rIFJlbW90ZURhdGFUcmFja30gdGhhdCB3YXMgc3Vic2NyaWJlZCB0b1xuICogQGV2ZW50IFJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uI3N1YnNjcmliZWRcbiAqL1xuLyoqXG4gKiBZb3VyIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBmYWlsZWQgdG8gc3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfS5cbiAqIEBwYXJhbSB7VHdpbGlvRXJyb3J9IGVycm9yIC0gdGhlIHJlYXNvbiB0aGUge0BsaW5rIFJlbW90ZURhdGFUcmFja30gY291bGQgbm90IGJlXG4gKiAgIHN1YnNjcmliZWQgdG9cbiAqIEBldmVudCBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbiNzdWJzY3JpcHRpb25GYWlsZWRcbiAqL1xuLyoqXG4gKiBZb3VyIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSB1bnN1YnNjcmliZWQgZnJvbSB0aGUge0BsaW5rIFJlbW90ZURhdGFUcmFja30uXG4gKiBAcGFyYW0ge1JlbW90ZURhdGFUcmFja30gdHJhY2sgLSB0aGUge0BsaW5rIFJlbW90ZURhdGFUcmFja30gdGhhdCB3YXMgdW5zdWJzY3JpYmVkIGZyb21cbiAqIEBldmVudCBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbiN1bnN1YnNjcmliZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW90ZWRhdGF0cmFja3B1YmxpY2F0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICByZXR1cm4gdG87XG59O1xudmFyIF9hID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25zdGFudHMnKSwgRSA9IF9hLnR5cGVFcnJvcnMsIHRyYWNrUHJpb3JpdHkgPSBfYS50cmFja1ByaW9yaXR5O1xudmFyIGd1ZXNzQnJvd3NlciA9IHJlcXVpcmUoJ0B0d2lsaW8vd2VicnRjL2xpYi91dGlsJykuZ3Vlc3NCcm93c2VyO1xudmFyIGRvY3VtZW50VmlzaWJpbGl0eU1vbml0b3IgPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvY3VtZW50dmlzaWJpbGl0eW1vbml0b3IuanMnKTtcbmZ1bmN0aW9uIG1peGluUmVtb3RlTWVkaWFUcmFjayhBdWRpb09yVmlkZW9UcmFjaykge1xuICAgIC8qKlxuICAgICAqIEEge0BsaW5rIFJlbW90ZU1lZGlhVHJhY2t9IHJlcHJlc2VudHMgYSB7QGxpbmsgTWVkaWFUcmFja30gcHVibGlzaGVkIHRvIGFcbiAgICAgKiB7QGxpbmsgUm9vbX0gYnkgYSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9LlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNFbmFibGVkIC0gV2hldGhlciB0aGUge0BsaW5rIFJlbW90ZU1lZGlhVHJhY2t9IGlzIGVuYWJsZWRcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU3dpdGNoZWRPZmYgLSBXaGV0aGVyIHRoZSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30gaXMgc3dpdGNoZWQgb2ZmXG4gICAgICogQHByb3BlcnR5IHtUcmFjay5TSUR9IHNpZCAtIFRoZSBTSUQgYXNzaWduZWQgdG8gdGhlIHtAbGluayBSZW1vdGVNZWRpYVRyYWNrfVxuICAgICAqIEBwcm9wZXJ0eSB7P1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eSAtIFRoZSBzdWJzY3JpYmUgcHJpb3JpdHkgb2YgdGhlIHtAbGluayBSZW1vdGVNZWRpYVRyYWNrfVxuICAgICAqIEBlbWl0cyBSZW1vdGVNZWRpYVRyYWNrI2Rpc2FibGVkXG4gICAgICogQGVtaXRzIFJlbW90ZU1lZGlhVHJhY2sjZW5hYmxlZFxuICAgICAqIEBlbWl0cyBSZW1vdGVNZWRpYVRyYWNrI3N3aXRjaGVkT2ZmXG4gICAgICogQGVtaXRzIFJlbW90ZU1lZGlhVHJhY2sjc3dpdGNoZWRPblxuICAgICAqL1xuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhSZW1vdGVNZWRpYVRyYWNrLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJlbW90ZU1lZGlhVHJhY2t9LlxuICAgICAgICAgKiBAcGFyYW0ge1RyYWNrLlNJRH0gc2lkXG4gICAgICAgICAqIEBwYXJhbSB7TWVkaWFUcmFja1JlY2VpdmVyfSBtZWRpYVRyYWNrUmVjZWl2ZXJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc0VuYWJsZWRcbiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IGlzU3dpdGNoZWRPZmZcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbig/VHJhY2suUHJpb3JpdHkpOiB2b2lkfSBzZXRQcmlvcml0eSAtIFNldCBvciBjbGVhciB0aGUgc3Vic2NyaWJlXG4gICAgICAgICAqICB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IG9mIHRoZSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja31cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihDbGllbnRSZW5kZXJIaW50KTogdm9pZH0gc2V0UmVuZGVySGludCAtIFNldCByZW5kZXIgaGludHMuXG4gICAgICAgICAqIEBwYXJhbSB7e2xvZzogTG9nLCBuYW1lOiA/c3RyaW5nfX0gb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUmVtb3RlTWVkaWFUcmFjayhzaWQsIG1lZGlhVHJhY2tSZWNlaXZlciwgaXNFbmFibGVkLCBpc1N3aXRjaGVkT2ZmLCBzZXRQcmlvcml0eSwgc2V0UmVuZGVySGludCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogV2ViS2l0IGJ1ZzogMjEyNzgwIHNvbWV0aW1lcyBjYXVzZXMgdGhlIGF1ZGlvL3ZpZGVvIGVsZW1lbnRzIHRvIHN0YXkgcGF1c2VkIHdoZW4gc2FmYXJpXG4gICAgICAgICAgICAgICAgLy8gcmVnYWlucyBmb3JlZ3JvdW5kLiBUbyB3b3JrYXJvdW5kIGl0LCB3aGVuIHNhZmFyaSBnYWlucyBmb3JlZ3JvdW5kIC0gd2Ugd2lsbCBwbGF5IGFueSBlbGVtZW50cyB0aGF0IHdlcmVcbiAgICAgICAgICAgICAgICAvLyBwbGF5aW5nIGJlZm9yZSBzYWZhcmkgbG9zdCBmb3JlZ3JvdW5kLlxuICAgICAgICAgICAgICAgIHdvcmthcm91bmRXZWJLaXRCdWcyMTI3ODA6IGd1ZXNzQnJvd3NlcigpID09PSAnc2FmYXJpJ1xuICAgICAgICAgICAgICAgICAgICAmJiB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgICYmIHR5cGVvZiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICYmIHR5cGVvZiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVkaWFUcmFja1JlY2VpdmVyLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgICAgICBfaXNFbmFibGVkOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpc0VuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfaXNTd2l0Y2hlZE9mZjoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXNTd2l0Y2hlZE9mZixcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9wcmlvcml0eToge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9zZXRQcmlvcml0eToge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2V0UHJpb3JpdHlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9zZXRSZW5kZXJIaW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocmVuZGVySGludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZygndXBkYXRpbmcgcmVuZGVyIGhpbnQ6JywgcmVuZGVySGludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZW5kZXJIaW50KHJlbmRlckhpbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0VuYWJsZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNFbmFibGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1N3aXRjaGVkT2ZmOiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzU3dpdGNoZWRPZmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW9yaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNpZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX3dvcmthcm91bmRXZWJLaXRCdWcyMTI3ODA6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMud29ya2Fyb3VuZFdlYktpdEJ1ZzIxMjc4MFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX3dvcmthcm91bmRXZWJLaXRCdWcyMTI3ODBDbGVhbnVwOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIHN1YnNjcmliZSB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IG9mIHRoZSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30uXG4gICAgICAgICAqIEBwYXJhbSB7P1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eSAtIHRoZSBuZXcgc3Vic2NyaWJlIHtAbGluayBUcmFjay5Qcmlvcml0eX07XG4gICAgICAgICAqICAgSWYgPGNvZGU+bnVsbDwvY29kZT4sIHRoZW4gdGhlIHN1YnNjcmliZSB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IGlzIGNsZWFyZWQsIHdoaWNoXG4gICAgICAgICAqICAgbWVhbnMgdGhlIHtAbGluayBUcmFjay5Qcmlvcml0eX0gc2V0IGJ5IHRoZSBwdWJsaXNoZXIgaXMgbm93IHRoZSBlZmZlY3RpdmUgcHJpb3JpdHkuXG4gICAgICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgUmVtb3RlTWVkaWFUcmFjay5wcm90b3R5cGUuc2V0UHJpb3JpdHkgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHZhciBwcmlvcml0eVZhbHVlcyA9IF9fc3ByZWFkQXJyYXkoW251bGxdLCBfX3JlYWQoT2JqZWN0LnZhbHVlcyh0cmFja1ByaW9yaXR5KSkpO1xuICAgICAgICAgICAgaWYgKCFwcmlvcml0eVZhbHVlcy5pbmNsdWRlcyhwcmlvcml0eSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgICAgICAgICAgICAgIHRocm93IEUuSU5WQUxJRF9WQUxVRSgncHJpb3JpdHknLCBwcmlvcml0eVZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpb3JpdHkgIT09IHByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcmlvcml0eShwcmlvcml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbmFibGVkXG4gICAgICAgICAqL1xuICAgICAgICBSZW1vdGVNZWRpYVRyYWNrLnByb3RvdHlwZS5fc2V0RW5hYmxlZCA9IGZ1bmN0aW9uIChpc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0VuYWJsZWQgIT09IGlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGlzRW5hYmxlZDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5faXNFbmFibGVkID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3dpdGNoZWRPZmZcbiAgICAgICAgICovXG4gICAgICAgIFJlbW90ZU1lZGlhVHJhY2sucHJvdG90eXBlLl9zZXRTd2l0Y2hlZE9mZiA9IGZ1bmN0aW9uIChpc1N3aXRjaGVkT2ZmKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNTd2l0Y2hlZE9mZiAhPT0gaXNTd2l0Y2hlZE9mZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU3dpdGNoZWRPZmYgPSBpc1N3aXRjaGVkT2ZmO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChpc1N3aXRjaGVkT2ZmID8gJ3N3aXRjaGVkT2ZmJyA6ICdzd2l0Y2hlZE9uJywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJlbW90ZU1lZGlhVHJhY2sucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuYXR0YWNoLmNhbGwodGhpcywgZWwpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWVkaWFTdHJlYW1UcmFjay5lbmFibGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IHdlIGRpc2FibGUgbWVkaWFTdHJlYW1UcmFjayB3aGVuIHRoZXJlXG4gICAgICAgICAgICAgICAgLy8gYXJlIG5vIGF0dGFjaG1lbnRzIHRvIGl0IChzZWUgbm90ZXMgYmVsb3cpLiBOb3cgdGhhdCB0aGVyZVxuICAgICAgICAgICAgICAgIC8vIGFyZSBhdHRhY2htZW50cyByZS1lbmFibGUgdGhlIHRyYWNrLlxuICAgICAgICAgICAgICAgIHRoaXMubWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZFRyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOT1RFKGNzYW50b3MpOiBzaW5jZSByZW1vdGUgdHJhY2tzIGRpc2FibGVzL2VuYWJsZXMgdGhlIG1lZGlhU3RyZWFtVHJhY2ssXG4gICAgICAgICAgICAgICAgLy8gY2FwdHVyZUZyYW1lcyBzdG9wcyBhbG9uZyB3aXRoIGl0LiBXZSBuZWVkIHRvIHN0YXJ0IGl0IGFnYWluIGFmdGVyIHJlLWVuYWJsaW5nLlxuICAgICAgICAgICAgICAgIC8vIFNlZSBhdHRhY2gvZGV0YWNoIG1ldGhvZHMgaW4gdGhpcyBjbGFzcyBhbmQgaW4gVmlkZW9UcmFjayBjbGFzcy5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FwdHVyZUZyYW1lcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl93b3JrYXJvdW5kV2ViS2l0QnVnMjEyNzgwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2Fyb3VuZFdlYktpdEJ1ZzIxMjc4MENsZWFudXAgPSB0aGlzLl93b3JrYXJvdW5kV2ViS2l0QnVnMjEyNzgwQ2xlYW51cFxuICAgICAgICAgICAgICAgICAgICB8fCBwbGF5SWZQYXVzZWRXaGlsZUluQmFja2dyb3VuZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIFJlbW90ZU1lZGlhVHJhY2sucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuZGV0YWNoLmNhbGwodGhpcywgZWwpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGFjaG1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogY2hyb21lIGNvbnRpbnVlcyBwbGF5aW5nIHdlYnJ0YyBhdWRpb1xuICAgICAgICAgICAgICAgIC8vIHRyYWNrIGV2ZW4gYWZ0ZXIgYXVkaW8gZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIERPTS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD03NDk5MjhcbiAgICAgICAgICAgICAgICAvLyB0byB3b3JrYXJvdW5kOiBoZXJlIGRpc2FibGUgdGhlIHRyYWNrIHdoZW5cbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gZWxlbWVudHMgYXR0YWNoZWQgdG8gaXQuXG4gICAgICAgICAgICAgICAgdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZFRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmthcm91bmRXZWJLaXRCdWcyMTI3ODBDbGVhbnVwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVuaG9vayB2aXNpYmlsaXR5IGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93b3JrYXJvdW5kV2ViS2l0QnVnMjEyNzgwQ2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93b3JrYXJvdW5kV2ViS2l0QnVnMjEyNzgwQ2xlYW51cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlbW90ZU1lZGlhVHJhY2s7XG4gICAgfShBdWRpb09yVmlkZW9UcmFjaykpO1xufVxuZnVuY3Rpb24gcGxheUlmUGF1c2VkV2hpbGVJbkJhY2tncm91bmQocmVtb3RlTWVkaWFUcmFjaykge1xuICAgIHZhciBsb2cgPSByZW1vdGVNZWRpYVRyYWNrLl9sb2csIGtpbmQgPSByZW1vdGVNZWRpYVRyYWNrLmtpbmQ7XG4gICAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlZChpc1Zpc2libGUpIHtcbiAgICAgICAgaWYgKCFpc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZW1vdGVNZWRpYVRyYWNrLl9hdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIHNoaW0gPSByZW1vdGVNZWRpYVRyYWNrLl9lbFNoaW1zLmdldChlbCk7XG4gICAgICAgICAgICB2YXIgaXNJbmFkdmVydGVudGx5UGF1c2VkID0gZWwucGF1c2VkICYmIHNoaW0gJiYgIXNoaW0ucGF1c2VkSW50ZW50aW9uYWxseSgpO1xuICAgICAgICAgICAgaWYgKGlzSW5hZHZlcnRlbnRseVBhdXNlZCkge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiUGxheWluZyBpbmFkdmVydGVudGx5IHBhdXNlZCA8XCIgKyBraW5kICsgXCI+IGVsZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKCdFbGVtZW50OicsIGVsKTtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ1JlbW90ZU1lZGlhVHJhY2s6JywgcmVtb3RlTWVkaWFUcmFjayk7XG4gICAgICAgICAgICAgICAgZWwucGxheSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsb2cuaW5mbyhcIlN1Y2Nlc3NmdWxseSBwbGF5ZWQgaW5hZHZlcnRlbnRseSBwYXVzZWQgPFwiICsga2luZCArIFwiPiBlbGVtZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ0VsZW1lbnQ6JywgZWwpO1xuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ1JlbW90ZU1lZGlhVHJhY2s6JywgcmVtb3RlTWVkaWFUcmFjayk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihcIkVycm9yIHdoaWxlIHBsYXlpbmcgaW5hZHZlcnRlbnRseSBwYXVzZWQgPFwiICsga2luZCArIFwiPiBlbGVtZW50OlwiLCB7IGVycjogZXJyLCBlbDogZWwsIHJlbW90ZU1lZGlhVHJhY2s6IHJlbW90ZU1lZGlhVHJhY2sgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogbGlzdGVuIGZvciBkb2N1bWVudCB2aXNpYmlsaXR5IGNhbGxiYWNrIG9uIHBoYXNlIDIuXG4gICAgLy8gdGhpcyBlbnN1cmVzIHRoYXQgYW55IExvY2FsTWVkaWFUcmFjaydzIHJlc3RhcnQgKHdoaWNoIGxpc3RlbiBvbiBwaGFzZSAxKSBnZXRzIGV4ZWN1dGVkXG4gICAgLy8gZmlyc3QuIFRoaXMgb3JkZXIgaXMgaW1wb3J0YW50IGJlY2F1c2Ugd2UgYHBsYXlgIHRyYWNrcyBpbiB0aGUgY2FsbGJhY2ssIGFuZFxuICAgIC8vIHBsYXkgY2FuIGZhaWwgb24gc2FmYXJpIGlmIGF1ZGlvIGlzIG5vdCBiZWluZyBjYXB0dXJlZC5cbiAgICBkb2N1bWVudFZpc2liaWxpdHlNb25pdG9yLm9uVmlzaWJpbGl0eUNoYW5nZSgyLCBvblZpc2liaWxpdHlDaGFuZ2VkKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudFZpc2liaWxpdHlNb25pdG9yLm9mZlZpc2liaWxpdHlDaGFuZ2UoMiwgb25WaXNpYmlsaXR5Q2hhbmdlZCk7XG4gICAgfTtcbn1cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30gd2FzIGRpc2FibGVkLlxuICogQHBhcmFtIHtSZW1vdGVNZWRpYVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30gdGhhdCB3YXNcbiAqICAgZGlzYWJsZWRcbiAqIEBldmVudCBSZW1vdGVNZWRpYVRyYWNrI2Rpc2FibGVkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30gd2FzIGVuYWJsZWQuXG4gKiBAcGFyYW0ge1JlbW90ZU1lZGlhVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVNZWRpYVRyYWNrfSB0aGF0IHdhc1xuICogICBlbmFibGVkXG4gKiBAZXZlbnQgUmVtb3RlTWVkaWFUcmFjayNlbmFibGVkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlTWVkaWFUcmFja30gd2FzIHN3aXRjaGVkIG9mZi5cbiAqIEBwYXJhbSB7UmVtb3RlTWVkaWFUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZU1lZGlhVHJhY2t9IHRoYXQgd2FzXG4gKiAgIHN3aXRjaGVkIG9mZlxuICogQGV2ZW50IFJlbW90ZU1lZGlhVHJhY2sjc3dpdGNoZWRPZmZcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVNZWRpYVRyYWNrfSB3YXMgc3dpdGNoZWQgb24uXG4gKiBAcGFyYW0ge1JlbW90ZU1lZGlhVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVNZWRpYVRyYWNrfSB0aGF0IHdhc1xuICogICBzd2l0Y2hlZCBvblxuICogQGV2ZW50IFJlbW90ZU1lZGlhVHJhY2sjc3dpdGNoZWRPblxuICovXG4vKipcbiAqIEEge0BsaW5rIENsaWVudFJlbmRlckhpbnR9IG9iamVjdCBzcGVjaWZpZXMgdHJhY2sgZGltZW5zaW9ucyBhbmQgL2VuYWJsZWQgZGlzYWJsZSBzdGF0ZS5cbiAqIFRoaXMgc3RhdGUgd2lsbCBiZSB1c2VkIGJ5IHRoZSBzZXJ2ZXIoU0ZVKSB0byBkZXRlcm1pbmUgYmFuZHdpZHRoIGFsbG9jYXRpb24gZm9yIHRoZSB0cmFjayxcbiAqIGFuZCB0dXJuIGl0IG9uIG9yIG9mZiBhcyBuZWVkZWQuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBDbGllbnRSZW5kZXJIaW50XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlbmFibGVkXSAtIHRyYWNrIGlzIGVuYWJsZWQgb3IgZGlzYWJsZWQuIGRlZmF1bHRzIHRvIGRpc2FibGVkLlxuICogQHByb3BlcnR5IHtWaWRlb1RyYWNrLkRpbWVuc2lvbnN9IFtyZW5kZXJEaW1lbnNpb25zXSAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHRoZSBkZXNpcmVkXG4gKiAgIHJlbmRlciBkaW1lbnNpb25zIG9mIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfXMuIFRoaXMgcHJvcGVydHkgbXVzdCBiZSBzcGVjaWZpZWQgaWYgZW5hYmxlZD10cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gbWl4aW5SZW1vdGVNZWRpYVRyYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RlbWVkaWF0cmFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFRyYWNrUHVibGljYXRpb24gPSByZXF1aXJlKCcuL3RyYWNrcHVibGljYXRpb24nKTtcbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcmVwcmVzZW50cyBhIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCBoYXNcbiAqIGJlZW4gcHVibGlzaGVkIHRvIGEge0BsaW5rIFJvb219LlxuICogQGV4dGVuZHMgVHJhY2tQdWJsaWNhdGlvblxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1N1YnNjcmliZWQgLSB3aGV0aGVyIHRoZSBwdWJsaXNoZWQge0BsaW5rIFJlbW90ZVRyYWNrfVxuICogICBpcyBzdWJzY3JpYmVkIHRvXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzVHJhY2tFbmFibGVkIC0gd2hldGhlciB0aGUgcHVibGlzaGVkXG4gKiAgIHtAbGluayBSZW1vdGVUcmFja30gaXMgZW5hYmxlZFxuICogQHByb3BlcnR5IHtUcmFjay5LaW5kfSBraW5kIC0ga2luZCBvZiB0aGUgcHVibGlzaGVkIHtAbGluayBSZW1vdGVUcmFja31cbiAqIEBwcm9wZXJ0eSB7VHJhY2suUHJpb3JpdHl9IHB1Ymxpc2hQcmlvcml0eSAtIHRoZSB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IG9mIHRoZSBwdWJsaXNoZWRcbiAqICAge0BsaW5rIFJlbW90ZVRyYWNrfSBzZXQgYnkgdGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH1cbiAqIEBwcm9wZXJ0eSB7P1JlbW90ZVRyYWNrfSB0cmFjayAtIFVubGVzcyB5b3UgaGF2ZSBzdWJzY3JpYmVkIHRvIHRoZVxuICogICB7QGxpbmsgUmVtb3RlVHJhY2t9LCB0aGlzIHByb3BlcnR5IGlzIG51bGxcbiAqIEBlbWl0cyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uI3B1Ymxpc2hQcmlvcml0eUNoYW5nZWRcbiAqIEBlbWl0cyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uI3N1YnNjcmliZWRcbiAqIEBlbWl0cyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uI3N1YnNjcmlwdGlvbkZhaWxlZFxuICogQGVtaXRzIFJlbW90ZVRyYWNrUHVibGljYXRpb24jdHJhY2tEaXNhYmxlZFxuICogQGVtaXRzIFJlbW90ZVRyYWNrUHVibGljYXRpb24jdHJhY2tFbmFibGVkXG4gKiBAZW1pdHMgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiN0cmFja1N3aXRjaGVkT2ZmXG4gKiBAZW1pdHMgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiN0cmFja1N3aXRjaGVkT25cbiAqIEBlbWl0cyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uI3Vuc3Vic2NyaWJlZFxuICpcbiAqL1xudmFyIFJlbW90ZVRyYWNrUHVibGljYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbW90ZVRyYWNrUHVibGljYXRpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259LlxuICAgICAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ30gc2lnbmFsaW5nIC0ge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259IHNpZ25hbGluZ1xuICAgICAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn1cbiAgICAgKiAgIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKHNpZ25hbGluZywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzaWduYWxpbmcubmFtZSwgc2lnbmFsaW5nLnNpZCwgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9zaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2lnbmFsaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RyYWNrOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1N1YnNjcmliZWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLl90cmFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNUcmFja0VuYWJsZWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsaW5nLmlzRW5hYmxlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2luZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHNpZ25hbGluZy5raW5kXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHVibGlzaFByaW9yaXR5OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hbGluZy5wcmlvcml0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2s6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gcmVtZW1iZXIgb3JpZ2luYWwgc3RhdGUsIGFuZCBmaXJlIGV2ZW50cyBvbmx5IG9uIGNoYW5nZS5cbiAgICAgICAgdmFyIGVycm9yID0gc2lnbmFsaW5nLmVycm9yLCBpc0VuYWJsZWQgPSBzaWduYWxpbmcuaXNFbmFibGVkLCBpc1N3aXRjaGVkT2ZmID0gc2lnbmFsaW5nLmlzU3dpdGNoZWRPZmYsIHByaW9yaXR5ID0gc2lnbmFsaW5nLnByaW9yaXR5O1xuICAgICAgICBzaWduYWxpbmcub24oJ3VwZGF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgIT09IHNpZ25hbGluZy5lcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yID0gc2lnbmFsaW5nLmVycm9yO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3N1YnNjcmlwdGlvbkZhaWxlZCcsIHNpZ25hbGluZy5lcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRW5hYmxlZCAhPT0gc2lnbmFsaW5nLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlzRW5hYmxlZCA9IHNpZ25hbGluZy5pc0VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyYWNrLl9zZXRFbmFibGVkKHNpZ25hbGluZy5pc0VuYWJsZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KHNpZ25hbGluZy5pc0VuYWJsZWQgPyAndHJhY2tFbmFibGVkJyA6ICd0cmFja0Rpc2FibGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTd2l0Y2hlZE9mZiAhPT0gc2lnbmFsaW5nLmlzU3dpdGNoZWRPZmYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKF90aGlzLnRyYWNrU2lkICsgXCI6IFwiICsgKGlzU3dpdGNoZWRPZmYgPyAnT0ZGJyA6ICdPTicpICsgXCIgPT4gXCIgKyAoc2lnbmFsaW5nLmlzU3dpdGNoZWRPZmYgPyAnT0ZGJyA6ICdPTicpKTtcbiAgICAgICAgICAgICAgICBpc1N3aXRjaGVkT2ZmID0gc2lnbmFsaW5nLmlzU3dpdGNoZWRPZmY7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyYWNrLl9zZXRTd2l0Y2hlZE9mZihzaWduYWxpbmcuaXNTd2l0Y2hlZE9mZik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoaXNTd2l0Y2hlZE9mZiA/ICd0cmFja1N3aXRjaGVkT2ZmJyA6ICd0cmFja1N3aXRjaGVkT24nLCBfdGhpcy50cmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzU3dpdGNoZWRPZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy53YXJuKCdUcmFjayB3YXMgbm90IHN1YnNjcmliZWQgd2hlbiBzd2l0Y2hlZCBPZmYuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByaW9yaXR5ICE9PSBzaWduYWxpbmcucHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICBwcmlvcml0eSA9IHNpZ25hbGluZy5wcmlvcml0eTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdwdWJsaXNoUHJpb3JpdHlDaGFuZ2VkJywgcHJpb3JpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW1JlbW90ZVRyYWNrUHVibGljYXRpb24gI1wiICsgdGhpcy5faW5zdGFuY2VJZCArIFwiOiBcIiArIHRoaXMudHJhY2tTaWQgKyBcIl1cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja30gdHJhY2tcbiAgICAgKi9cbiAgICBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLnByb3RvdHlwZS5fc3Vic2NyaWJlZCA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuX3RyYWNrICYmIHRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFjayA9IHRyYWNrO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdWJzY3JpYmVkJywgdHJhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlbW90ZVRyYWNrUHVibGljYXRpb24ucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYWNrKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLl90cmFjaztcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndW5zdWJzY3JpYmVkJywgdHJhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVtb3RlVHJhY2tQdWJsaWNhdGlvbjtcbn0oVHJhY2tQdWJsaWNhdGlvbikpO1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZVRyYWNrfSdzIHB1Ymxpc2gge0BsaW5rIFRyYWNrLlByaW9yaXR5fSB3YXMgY2hhbmdlZCBieSB0aGVcbiAqIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0uXG4gKiBAcGFyYW0ge1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eSAtIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9J3MgbmV3IHB1Ymxpc2hcbiAqICAge0BsaW5rIFRyYWNrLlByaW9yaXR5fTsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiNwdWJsaXNoUHJpb3JpdHkgaXMgYWxzb1xuICogICB1cGRhdGVkIGFjY29yZGluZ2x5XG4gKiBAZXZlbnQgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiNwdWJsaXNoUHJpb3JpdHlDaGFuZ2VkXG4gKi9cbi8qKlxuICogWW91ciB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gc3Vic2NyaWJlZCB0byB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfS5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCB3YXMgc3Vic2NyaWJlZCB0b1xuICogQGV2ZW50IFJlbW90ZVRyYWNrUHVibGljYXRpb24jc3Vic2NyaWJlZFxuICovXG4vKipcbiAqIFlvdXIge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IGZhaWxlZCB0byBzdWJzY3JpYmUgdG8gdGhlIHtAbGluayBSZW1vdGVUcmFja30uXG4gKiBAcGFyYW0ge1R3aWxpb0Vycm9yfSBlcnJvciAtIHRoZSByZWFzb24gdGhlIHtAbGluayBSZW1vdGVUcmFja30gY291bGQgbm90IGJlXG4gKiAgIHN1YnNjcmliZWQgdG9cbiAqIEBldmVudCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uI3N1YnNjcmlwdGlvbkZhaWxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyBkaXNhYmxlZC5cbiAqIEBldmVudCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uI3RyYWNrRGlzYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgZW5hYmxlZC5cbiAqIEBldmVudCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uI3RyYWNrRW5hYmxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyBzd2l0Y2hlZCBvZmYuXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrfSB0cmFjayAtIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHN3aXRjaGVkIG9mZlxuICogQGV2ZW50IFJlbW90ZVRyYWNrUHVibGljYXRpb24jdHJhY2tTd2l0Y2hlZE9mZlxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyBzd2l0Y2hlZCBvbi5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCB3YXMgc3dpdGNoZWQgb25cbiAqIEBldmVudCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uI3RyYWNrU3dpdGNoZWRPblxuICovXG4vKipcbiAqIFlvdXIge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IHVuc3Vic2NyaWJlZCBmcm9tIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9LlxuICogQHBhcmFtIHtSZW1vdGVUcmFja30gdHJhY2sgLSB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSB0aGF0IHdhcyB1bnN1YnNjcmliZWQgZnJvbVxuICogQGV2ZW50IFJlbW90ZVRyYWNrUHVibGljYXRpb24jdW5zdWJzY3JpYmVkXG4gKi9cbi8qKlxuICoge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259IG9wdGlvbnNcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFJlbW90ZVRyYWNrUHVibGljYXRpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge0xvZ0xldmVsfExvZ0xldmVsc30gbG9nTGV2ZWwgLSBMb2cgbGV2ZWwgZm9yICdtZWRpYScgbW9kdWxlc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW90ZVRyYWNrUHVibGljYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdGV0cmFja3B1YmxpY2F0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgbWl4aW5SZW1vdGVNZWRpYVRyYWNrID0gcmVxdWlyZSgnLi9yZW1vdGVtZWRpYXRyYWNrJyk7XG52YXIgVmlkZW9UcmFjayA9IHJlcXVpcmUoJy4vdmlkZW90cmFjaycpO1xudmFyIGRvY3VtZW50VmlzaWJpbGl0eU1vbml0b3IgPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvY3VtZW50dmlzaWJpbGl0eW1vbml0b3IuanMnKTtcbnZhciBOdWxsT2JzZXJ2ZXIgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bGxvYnNlcnZlci5qcycpLk51bGxPYnNlcnZlcjtcbnZhciBUaW1lb3V0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90aW1lb3V0Jyk7XG52YXIgUmVtb3RlTWVkaWFWaWRlb1RyYWNrID0gbWl4aW5SZW1vdGVNZWRpYVRyYWNrKFZpZGVvVHJhY2spO1xudmFyIFRSQUNLX1RVUk5fT0ZfREVMQVlfTVMgPSA1MDtcbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gcmVwcmVzZW50cyBhIHtAbGluayBWaWRlb1RyYWNrfSBwdWJsaXNoZWQgdG8gYVxuICoge0BsaW5rIFJvb219IGJ5IGEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fS5cbiAqIEBleHRlbmRzIFZpZGVvVHJhY2tcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNFbmFibGVkIC0gV2hldGhlciB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IGlzIGVuYWJsZWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTd2l0Y2hlZE9mZiAtIFdoZXRoZXIgdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSBpcyBzd2l0Y2hlZCBvZmZcbiAqIEBwcm9wZXJ0eSB7VHJhY2suU0lEfSBzaWQgLSBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9J3MgU0lEXG4gKiBAcHJvcGVydHkgez9UcmFjay5Qcmlvcml0eX0gcHJpb3JpdHkgLSBUaGUgc3Vic2NyaWJlIHByaW9yaXR5IG9mIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31cbiAqIEBlbWl0cyBSZW1vdGVWaWRlb1RyYWNrI2RpbWVuc2lvbnNDaGFuZ2VkXG4gKiBAZW1pdHMgUmVtb3RlVmlkZW9UcmFjayNkaXNhYmxlZFxuICogQGVtaXRzIFJlbW90ZVZpZGVvVHJhY2sjZW5hYmxlZFxuICogQGVtaXRzIFJlbW90ZVZpZGVvVHJhY2sjc3RhcnRlZFxuICogQGVtaXRzIFJlbW90ZVZpZGVvVHJhY2sjc3dpdGNoZWRPZmZcbiAqIEBlbWl0cyBSZW1vdGVWaWRlb1RyYWNrI3N3aXRjaGVkT25cbiAqL1xudmFyIFJlbW90ZVZpZGVvVHJhY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbW90ZVZpZGVvVHJhY2ssIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9LlxuICAgICAqIEBwYXJhbSB7VHJhY2suU0lEfSBzaWQgLSBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9J3MgU0lEXG4gICAgICogQHBhcmFtIHtNZWRpYVRyYWNrUmVjZWl2ZXJ9IG1lZGlhVHJhY2tSZWNlaXZlciAtIEEgdmlkZW8gTWVkaWFTdHJlYW1UcmFjayBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRW5hYmxlZCAtIHdoZXRoZXIgdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSBpcyBlbmFibGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1N3aXRjaGVkT2ZmIC0gV2hldGhlciB0aGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IGlzIHN3aXRjaGVkIG9mZlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP1RyYWNrLlByaW9yaXR5KTogdm9pZH0gc2V0UHJpb3JpdHkgLSBTZXQgb3IgY2xlYXIgdGhlIHN1YnNjcmliZVxuICAgICAqICB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IG9mIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja31cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKENsaWVudFJlbmRlckhpbnQpOiB2b2lkfSBzZXRSZW5kZXJIaW50IC0gU2V0IHJlbmRlciBoaW50cy5cbiAgICAgKiBAcGFyYW0ge3tsb2c6IExvZ319IG9wdGlvbnMgLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrfSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVtb3RlVmlkZW9UcmFjayhzaWQsIG1lZGlhVHJhY2tSZWNlaXZlciwgaXNFbmFibGVkLCBpc1N3aXRjaGVkT2ZmLCBzZXRQcmlvcml0eSwgc2V0UmVuZGVySGludCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2w6ICdhdXRvJyxcbiAgICAgICAgICAgIGNvbnRlbnRQcmVmZXJlbmNlc01vZGU6ICdhdXRvJyxcbiAgICAgICAgICAgIGVuYWJsZURvY3VtZW50VmlzaWJpbGl0eVR1cm5PZmY6IHRydWUsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBJbnRlcnNlY3Rpb25PYnNlcnZlcjogdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAndW5kZWZpbmVkJyB8fCBvcHRpb25zLmNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCAhPT0gJ2F1dG8nID8gTnVsbE9ic2VydmVyIDogSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsXG4gICAgICAgICAgICBSZXNpemVPYnNlcnZlcjogdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAndW5kZWZpbmVkJyB8fCBvcHRpb25zLmNvbnRlbnRQcmVmZXJlbmNlc01vZGUgIT09ICdhdXRvJyA/IE51bGxPYnNlcnZlciA6IFJlc2l6ZU9ic2VydmVyLFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzaWQsIG1lZGlhVHJhY2tSZWNlaXZlciwgaXNFbmFibGVkLCBpc1N3aXRjaGVkT2ZmLCBzZXRQcmlvcml0eSwgc2V0UmVuZGVySGludCwgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9lbmFibGVEb2N1bWVudFZpc2liaWxpdHlUdXJuT2ZmOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuZW5hYmxlRG9jdW1lbnRWaXNpYmlsaXR5VHVybk9mZiA9PT0gdHJ1ZSAmJiBvcHRpb25zLmNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCA9PT0gJ2F1dG8nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kb2N1bWVudFZpc2liaWxpdHlUdXJuT2ZmQ2xlYW51cDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY29udGVudFByZWZlcmVuY2VzTW9kZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmNvbnRlbnRQcmVmZXJlbmNlc01vZGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2ludmlzaWJsZUVsZW1lbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBXZWFrU2V0KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3R1cm5PZmZUaW1lcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgVGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRSZW5kZXJIaW50KHsgZW5hYmxlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfSwgVFJBQ0tfVFVSTl9PRl9ERUxBWV9NUywgZmFsc2UpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZXNpemVPYnNlcnZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgb3B0aW9ucy5SZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogd2UgaWdub3JlIGVsZW1lbnRzIGluIF9pbnZpc2libGVFbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyB0byBlbnN1cmUgdGhhdCBSZXNpemVPYnNlcnZlciBkb2VzIG5vdCBlbmQtdXAgdHVybmluZyBvZmYgYSB0cmFjayB3aGVuIGEgZnJlc2ggVmlkZW8gZWxlbWVudCBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBhdHRhY2hlZCBhbmQgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaGFzIG5vdCBoYWQgaXRzIGNhbGxiYWNrIGV4ZWN1dGVkIHlldC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpc2libGVFbGVtZW50UmVzaXplZCA9IGVudHJpZXMuZmluZChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuICFfdGhpcy5faW52aXNpYmxlRWxlbWVudHMuaGFzKGVudHJ5LnRhcmdldCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaWJsZUVsZW1lbnRSZXNpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVVwZGF0ZURpbWVuc2lvbkhpbnQoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW50ZXJzZWN0aW9uT2JzZXJ2ZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IG9wdGlvbnMuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNob3VsZFNldFJlbmRlckhpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhc1Zpc2libGUgPSAhX3RoaXMuX2ludmlzaWJsZUVsZW1lbnRzLmhhcyhlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhc1Zpc2libGUgIT09IGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoJ2ludGVyc2VjdGlvbk9ic2VydmVyIGRldGVjdGVkOiBPZmYgPT4gT24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2ludmlzaWJsZUVsZW1lbnRzLmRlbGV0ZShlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZygnaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgZGV0ZWN0ZWQ6IE9uID0+IE9mZicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW52aXNpYmxlRWxlbWVudHMuYWRkKGVudHJ5LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFNldFJlbmRlckhpbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFNldFJlbmRlckhpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlVXBkYXRlRW5hYmxlZEhpbnQoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB2aXNpYmlsaXR5IG9mIGFuIGVsZW1lbnQgY2hhbmdlcyB0aGF0IG1heSBjYXVzZSB0aGUgXCJiaWdnZXN0XCIgZWxlbWVudCB0byBjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZGltZW5zaW9ucyBhcyB3ZWxsLiBzaW5jZSBkaW1lbnNpb25zIGFyZSBjYWNoZWQgYW5kIGRlLWR1cGVkIGF0IHNpZ25hbGluZyBsYXllcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0cyBva2F5IGlmIHRoZXkgZ290ICByZXNlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVVwZGF0ZURpbWVuc2lvbkhpbnQoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IDAuMjUgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVtb3RlVmlkZW9UcmFjay5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKGR1bW15RWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuX3N0YXJ0LmNhbGwodGhpcywgZHVtbXlFbCk7XG4gICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBhZnRlciBlbWl0dGluZyBzdGFydGVkLCB1cGRhdGUgdHVybiBvZmYgdHJhY2sgaWYgbm90IHZpc2libGUuXG4gICAgICAgIG1heWJlVXBkYXRlRW5hYmxlZEhpbnQodGhpcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHRvIHN3aXRjaCBvbiBhIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSwgVGhpcyBtZXRob2QgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB0aGUgZ3JvdXAgcm9vbXMgYW5kIG9ubHkgd2hlbiBjb25uZWN0ZWQgd2l0aFxuICAgICAqIGNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCBpbiB2aWRlbyBiYW5kd2lkdGggcHJvZmlsZSBvcHRpb25zIHNldCB0byAnbWFudWFsJ1xuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIFJlbW90ZVZpZGVvVHJhY2sucHJvdG90eXBlLnN3aXRjaE9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sICE9PSAnbWFudWFsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlLiBZb3UgY2FuIGNhbGwgc3dpdGNoT24gb25seSB3aGVuIGJhbmR3aWR0aFByb2ZpbGUudmlkZW8uY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sIGlzIHNldCB0byBcIm1hbnVhbFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0UmVuZGVySGludCh7IGVuYWJsZWQ6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCB0byBzd2l0Y2ggb2ZmIGEge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9LCBUaGlzIG1ldGhvZCBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHRoZSBncm91cCByb29tcyBhbmQgb25seSB3aGVuIGNvbm5lY3RlZCB3aXRoXG4gICAgICogY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sIGluIHZpZGVvIGJhbmR3aWR0aCBwcm9maWxlIG9wdGlvbnMgc2V0IHRvICdtYW51YWwnXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgUmVtb3RlVmlkZW9UcmFjay5wcm90b3R5cGUuc3dpdGNoT2ZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sICE9PSAnbWFudWFsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlLiBZb3UgY2FuIGNhbGwgc3dpdGNoT2ZmIG9ubHkgd2hlbiBiYW5kd2lkdGhQcm9maWxlLnZpZGVvLmNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCBpcyBzZXQgdG8gXCJtYW51YWxcIicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFJlbmRlckhpbnQoeyBlbmFibGVkOiBmYWxzZSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSdzIGNvbnRlbnQgcHJlZmVyZW5jZXMuIFRoaXMgbWV0aG9kIGlzIGFwcGxpY2FibGUgb25seSBmb3IgdGhlIGdyb3VwIHJvb21zIGFuZCBvbmx5IHdoZW4gY29ubmVjdGVkIHdpdGhcbiAgICAgKiB2aWRlb0NvbnRlbnRQcmVmZXJlbmNlc01vZGUgaW4gdmlkZW8gYmFuZHdpZHRoIHByb2ZpbGUgb3B0aW9ucyBzZXQgdG8gJ21hbnVhbCdcbiAgICAgKiBAcGFyYW0ge1ZpZGVvQ29udGVudFByZWZlcmVuY2VzfSBjb250ZW50UHJlZmVyZW5jZXMgLSByZXF1ZXN0ZWQgcHJlZmVyZW5jZXMuXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgUmVtb3RlVmlkZW9UcmFjay5wcm90b3R5cGUuc2V0Q29udGVudFByZWZlcmVuY2VzID0gZnVuY3Rpb24gKGNvbnRlbnRQcmVmZXJlbmNlcykge1xuICAgICAgICBpZiAodGhpcy5fY29udGVudFByZWZlcmVuY2VzTW9kZSAhPT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZS4gWW91IGNhbiBjYWxsIHN3aXRjaE9uIG9ubHkgd2hlbiBiYW5kd2lkdGhQcm9maWxlLnZpZGVvLmNvbnRlbnRQcmVmZXJlbmNlc01vZGUgaXMgc2V0IHRvIFwibWFudWFsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudFByZWZlcmVuY2VzLnJlbmRlckRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFJlbmRlckhpbnQoeyByZW5kZXJEaW1lbnNpb25zOiBjb250ZW50UHJlZmVyZW5jZXMucmVuZGVyRGltZW5zaW9ucyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFJlbW90ZVZpZGVvVHJhY2sucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5hdHRhY2guY2FsbCh0aGlzLCBlbCk7XG4gICAgICAgIGlmICh0aGlzLl9jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgLy8gc3RhcnQgb2ZmIHRoZSBlbGVtZW50IGFzIGludmlzaWJsZS4gd2lsbCBtYXJrIGl0XG4gICAgICAgICAgICAvLyB2aXNpYmxlIChhbmQgdXBkYXRlIHJlbmRlciBoaW50cykgb25jZSBpbnRlcnNlY3Rpb24gb2JzZXJ2ZXIgY2FsbHMgYmFjay5cbiAgICAgICAgICAgIHRoaXMuX2ludmlzaWJsZUVsZW1lbnRzLmFkZChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUocmVzdWx0KTtcbiAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShyZXN1bHQpO1xuICAgICAgICBpZiAodGhpcy5fZW5hYmxlRG9jdW1lbnRWaXNpYmlsaXR5VHVybk9mZikge1xuICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnRWaXNpYmlsaXR5VHVybk9mZkNsZWFudXAgPSB0aGlzLl9kb2N1bWVudFZpc2liaWxpdHlUdXJuT2ZmQ2xlYW51cCB8fCBzZXR1cERvY3VtZW50VmlzaWJpbGl0eVR1cm5PZmYodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFJlbW90ZVZpZGVvVHJhY2sucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5kZXRhY2guY2FsbCh0aGlzLCBlbCk7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IEFycmF5LmlzQXJyYXkocmVzdWx0KSA/IHJlc3VsdCA6IFtyZXN1bHRdO1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5faW50ZXJzZWN0aW9uT2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgX3RoaXMuX3Jlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIF90aGlzLl9pbnZpc2libGVFbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fYXR0YWNobWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RvY3VtZW50VmlzaWJpbGl0eVR1cm5PZmZDbGVhbnVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnRWaXNpYmlsaXR5VHVybk9mZkNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb2N1bWVudFZpc2liaWxpdHlUdXJuT2ZmQ2xlYW51cCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWF5YmVVcGRhdGVFbmFibGVkSGludCh0aGlzKTtcbiAgICAgICAgbWF5YmVVcGRhdGVEaW1lbnNpb25IaW50KHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEge0BsaW5rIFZpZGVvUHJvY2Vzc29yfSB0byBhbGxvdyBmb3IgY3VzdG9tIHByb2Nlc3Npbmcgb2YgdmlkZW8gZnJhbWVzIGJlbG9uZ2luZyB0byBhIFZpZGVvVHJhY2suXG4gICAgICogV2hlbiBhIFBhcnRpY2lwYW50IHVuLXB1Ymxpc2hlcyBhbmQgcmUtcHVibGlzaGVzIGEgVmlkZW9UcmFjaywgYSBuZXcgUmVtb3RlVmlkZW9UcmFjayBpcyBjcmVhdGVkIGFuZFxuICAgICAqIGFueSBWaWRlb1Byb2Nlc3NvcnMgYXR0YWNoZWQgdG8gdGhlIHByZXZpb3VzIFJlbW90ZVZpZGVvVHJhY2sgd291bGQgaGF2ZSB0byBiZSByZS1hZGRlZCBhZ2Fpbi5cbiAgICAgKiBPbmx5IENocm9tZSBzdXBwb3J0cyB0aGlzIGFzIG9mIG5vdy4gQ2FsbGluZyB0aGlzIEFQSSBmcm9tIGEgbm9uLXN1cHBvcnRlZCBicm93c2VyIHdpbGwgcmVzdWx0IGluIGEgbG9nIHdhcm5pbmcuXG4gICAgICogQHBhcmFtIHtWaWRlb1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIC0gVGhlIHtAbGluayBWaWRlb1Byb2Nlc3Nvcn0gdG8gdXNlLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2xhc3MgR3JheVNjYWxlUHJvY2Vzc29yIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHBlcmNlbnRhZ2UpIHtcbiAgICAgKiAgICAgdGhpcy5wZXJjZW50YWdlID0gcGVyY2VudGFnZTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIHByb2Nlc3NGcmFtZShpbnB1dEZyYW1lQnVmZmVyLCBvdXRwdXRGcmFtZUJ1ZmZlcikge1xuICAgICAqICAgICBjb25zdCBjb250ZXh0ID0gb3V0cHV0RnJhbWVCdWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgKiAgICAgY29udGV4dC5maWx0ZXIgPSBgZ3JheXNjYWxlKCR7dGhpcy5wZXJjZW50YWdlfSUpYDtcbiAgICAgKiAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW5wdXRGcmFtZUJ1ZmZlciwgMCwgMCwgaW5wdXRGcmFtZUJ1ZmZlci53aWR0aCwgaW5wdXRGcmFtZUJ1ZmZlci5oZWlnaHQpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGNvbnN0IGdyYXlzY2FsZVByb2Nlc3NvciA9IG5ldyBHcmF5U2NhbGVQcm9jZXNzb3IoMTAwKTtcbiAgICAgKlxuICAgICAqIEFycmF5LmZyb20ocm9vbS5wYXJ0aWNpcGFudHMudmFsdWVzKCkpLmZvckVhY2gocGFydGljaXBhbnQgPT4ge1xuICAgICAqICAgY29uc3QgcmVtb3RlVmlkZW9UcmFjayA9IEFycmF5LmZyb20ocGFydGljaXBhbnQudmlkZW9UcmFja3MudmFsdWVzKCkpWzBdLnRyYWNrO1xuICAgICAqICAgcmVtb3RlVmlkZW9UcmFjay5hZGRQcm9jZXNzb3IoZ3JheXNjYWxlUHJvY2Vzc29yKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBSZW1vdGVWaWRlb1RyYWNrLnByb3RvdHlwZS5hZGRQcm9jZXNzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmFkZFByb2Nlc3Nvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBwcmV2aW91c2x5IGFkZGVkIHtAbGluayBWaWRlb1Byb2Nlc3Nvcn0gdXNpbmcgYGFkZFByb2Nlc3NvcmAgQVBJLlxuICAgICAqIEBwYXJhbSB7VmlkZW9Qcm9jZXNzb3J9IHByb2Nlc3NvciAtIFRoZSB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9IHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNsYXNzIEdyYXlTY2FsZVByb2Nlc3NvciB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwZXJjZW50YWdlKSB7XG4gICAgICogICAgIHRoaXMucGVyY2VudGFnZSA9IHBlcmNlbnRhZ2U7XG4gICAgICogICB9XG4gICAgICogICBwcm9jZXNzRnJhbWUoaW5wdXRGcmFtZUJ1ZmZlciwgb3V0cHV0RnJhbWVCdWZmZXIpIHtcbiAgICAgKiAgICAgY29uc3QgY29udGV4dCA9IG91dHB1dEZyYW1lQnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICogICAgIGNvbnRleHQuZmlsdGVyID0gYGdyYXlzY2FsZSgke3RoaXMucGVyY2VudGFnZX0lKWA7XG4gICAgICogICAgIGNvbnRleHQuZHJhd0ltYWdlKGlucHV0RnJhbWVCdWZmZXIsIDAsIDAsIGlucHV0RnJhbWVCdWZmZXIud2lkdGgsIGlucHV0RnJhbWVCdWZmZXIuaGVpZ2h0KTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBjb25zdCBncmF5c2NhbGVQcm9jZXNzb3IgPSBuZXcgR3JheVNjYWxlUHJvY2Vzc29yKDEwMCk7XG4gICAgICpcbiAgICAgKiBBcnJheS5mcm9tKHJvb20ucGFydGljaXBhbnRzLnZhbHVlcygpKS5mb3JFYWNoKHBhcnRpY2lwYW50ID0+IHtcbiAgICAgKiAgIGNvbnN0IHJlbW90ZVZpZGVvVHJhY2sgPSBBcnJheS5mcm9tKHBhcnRpY2lwYW50LnZpZGVvVHJhY2tzLnZhbHVlcygpKVswXS50cmFjaztcbiAgICAgKiAgIHJlbW90ZVZpZGVvVHJhY2suYWRkUHJvY2Vzc29yKGdyYXlzY2FsZVByb2Nlc3Nvcik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVtb3ZlLWJ1dHRvbicpLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICogICBBcnJheS5mcm9tKHJvb20ucGFydGljaXBhbnRzLnZhbHVlcygpKS5mb3JFYWNoKHBhcnRpY2lwYW50ID0+IHtcbiAgICAgKiAgICAgY29uc3QgcmVtb3RlVmlkZW9UcmFjayA9IEFycmF5LmZyb20ocGFydGljaXBhbnQudmlkZW9UcmFja3MudmFsdWVzKCkpWzBdLnRyYWNrO1xuICAgICAqICAgICByZW1vdGVWaWRlb1RyYWNrLnJlbW92ZVByb2Nlc3NvcihncmF5c2NhbGVQcm9jZXNzb3IpO1xuICAgICAqICAgfSk7XG4gICAgICogfVxuICAgICAqL1xuICAgIFJlbW90ZVZpZGVvVHJhY2sucHJvdG90eXBlLnJlbW92ZVByb2Nlc3NvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVtb3ZlUHJvY2Vzc29yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBSZW1vdGVWaWRlb1RyYWNrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW1JlbW90ZVZpZGVvVHJhY2sgI1wiICsgdGhpcy5faW5zdGFuY2VJZCArIFwiOiBcIiArIHRoaXMuc2lkICsgXCJdXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHN1YnNjcmliZSB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IG9mIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30uXG4gICAgICogQHBhcmFtIHs/VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5IC0gdGhlIG5ldyBzdWJzY3JpYmUge0BsaW5rIFRyYWNrLlByaW9yaXR5fTtcbiAgICAgKiAgIElmIDxjb2RlPm51bGw8L2NvZGU+LCB0aGVuIHRoZSBzdWJzY3JpYmUge0BsaW5rIFRyYWNrLlByaW9yaXR5fSBpcyBjbGVhcmVkLCB3aGljaFxuICAgICAqICAgbWVhbnMgdGhlIHtAbGluayBUcmFjay5Qcmlvcml0eX0gc2V0IGJ5IHRoZSBwdWJsaXNoZXIgaXMgbm93IHRoZSBlZmZlY3RpdmUgcHJpb3JpdHkuXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAgICAgKi9cbiAgICBSZW1vdGVWaWRlb1RyYWNrLnByb3RvdHlwZS5zZXRQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5zZXRQcmlvcml0eS5jYWxsKHRoaXMsIHByaW9yaXR5KTtcbiAgICB9O1xuICAgIHJldHVybiBSZW1vdGVWaWRlb1RyYWNrO1xufShSZW1vdGVNZWRpYVZpZGVvVHJhY2spKTtcbmZ1bmN0aW9uIHNldHVwRG9jdW1lbnRWaXNpYmlsaXR5VHVybk9mZihyZW1vdmVWaWRlb1RyYWNrKSB7XG4gICAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICAgICAgbWF5YmVVcGRhdGVFbmFibGVkSGludChyZW1vdmVWaWRlb1RyYWNrKTtcbiAgICB9XG4gICAgZG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvci5vblZpc2liaWxpdHlDaGFuZ2UoMSwgb25WaXNpYmlsaXR5Q2hhbmdlZCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvci5vZmZWaXNpYmlsaXR5Q2hhbmdlKDEsIG9uVmlzaWJpbGl0eUNoYW5nZWQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXliZVVwZGF0ZUVuYWJsZWRIaW50KHJlbW92ZVZpZGVvVHJhY2spIHtcbiAgICBpZiAocmVtb3ZlVmlkZW9UcmFjay5fY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sICE9PSAnYXV0bycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmlzaWJsZUVsZW1lbnRzID0gcmVtb3ZlVmlkZW9UcmFjay5fZ2V0QWxsQXR0YWNoZWRFbGVtZW50cygpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICFyZW1vdmVWaWRlb1RyYWNrLl9pbnZpc2libGVFbGVtZW50cy5oYXMoZWwpOyB9KTtcbiAgICB2YXIgZW5hYmxlZCA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnICYmIHZpc2libGVFbGVtZW50cy5sZW5ndGggPiAwO1xuICAgIGlmIChlbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJlbW92ZVZpZGVvVHJhY2suX3R1cm5PZmZUaW1lci5jbGVhcigpO1xuICAgICAgICByZW1vdmVWaWRlb1RyYWNrLl9zZXRSZW5kZXJIaW50KHsgZW5hYmxlZDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXJlbW92ZVZpZGVvVHJhY2suX3R1cm5PZmZUaW1lci5pc1NldCkge1xuICAgICAgICAvLyBzZXQgdGhlIHRyYWNrIHRvIGJlIHR1cm5lZCBvZmYgYWZ0ZXIgc29tZSBkZWxheS5cbiAgICAgICAgcmVtb3ZlVmlkZW9UcmFjay5fdHVybk9mZlRpbWVyLnN0YXJ0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWF5YmVVcGRhdGVEaW1lbnNpb25IaW50KHJlbW92ZVZpZGVvVHJhY2spIHtcbiAgICBpZiAocmVtb3ZlVmlkZW9UcmFjay5fY29udGVudFByZWZlcmVuY2VzTW9kZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHZpc2libGVFbGVtZW50cyA9IHJlbW92ZVZpZGVvVHJhY2suX2dldEFsbEF0dGFjaGVkRWxlbWVudHMoKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhcmVtb3ZlVmlkZW9UcmFjay5faW52aXNpYmxlRWxlbWVudHMuaGFzKGVsKTsgfSk7XG4gICAgaWYgKHZpc2libGVFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCh2aXNpYmxlRWxlbWVudHMuc29ydChmdW5jdGlvbiAoZWwxLCBlbDIpIHtcbiAgICAgICAgICAgIHJldHVybiBlbDIuY2xpZW50SGVpZ2h0ICsgZWwyLmNsaWVudFdpZHRoIC0gZWwxLmNsaWVudEhlaWdodCAtIGVsMS5jbGllbnRXaWR0aCAtIDE7XG4gICAgICAgIH0pLCAxKSwgX2IgPSBfYVswXSwgY2xpZW50SGVpZ2h0ID0gX2IuY2xpZW50SGVpZ2h0LCBjbGllbnRXaWR0aCA9IF9iLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgcmVuZGVyRGltZW5zaW9ucyA9IHsgaGVpZ2h0OiBjbGllbnRIZWlnaHQsIHdpZHRoOiBjbGllbnRXaWR0aCB9O1xuICAgICAgICByZW1vdmVWaWRlb1RyYWNrLl9zZXRSZW5kZXJIaW50KHsgcmVuZGVyRGltZW5zaW9uczogcmVuZGVyRGltZW5zaW9ucyB9KTtcbiAgICB9XG59XG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFZpZGVvQ29udGVudFByZWZlcmVuY2VzXG4gKiBAcHJvcGVydHkge1ZpZGVvVHJhY2suRGltZW5zaW9uc30gW3JlbmRlckRpbWVuc2lvbnNdIC0gUmVuZGVyIERpbWVuc2lvbnMgdG8gcmVxdWVzdCBmb3IgdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfS5cbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9J3MgZGltZW5zaW9ucyBjaGFuZ2VkLlxuICogQHBhcmFtIHtSZW1vdGVWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gd2hvc2VcbiAqICAgZGltZW5zaW9ucyBjaGFuZ2VkXG4gKiBAZXZlbnQgUmVtb3RlVmlkZW9UcmFjayNkaW1lbnNpb25zQ2hhbmdlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gd2FzIGRpc2FibGVkLCBpLmUuIFwicGF1c2VkXCIuXG4gKiBAcGFyYW0ge1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB0aGF0IHdhc1xuICogICBkaXNhYmxlZFxuICogQGV2ZW50IFJlbW90ZVZpZGVvVHJhY2sjZGlzYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHdhcyBlbmFibGVkLCBpLmUuIFwicmVzdW1lZFwiLlxuICogQHBhcmFtIHtSZW1vdGVWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gdGhhdCB3YXNcbiAqICAgZW5hYmxlZFxuICogQGV2ZW50IFJlbW90ZVZpZGVvVHJhY2sjZW5hYmxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gc3RhcnRlZC4gVGhpcyBtZWFucyB0aGVyZSBpcyBlbm91Z2ggdmlkZW8gZGF0YVxuICogdG8gYmVnaW4gcGxheWJhY2suXG4gKiBAcGFyYW0ge1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB0aGF0IHN0YXJ0ZWRcbiAqIEBldmVudCBSZW1vdGVWaWRlb1RyYWNrI3N0YXJ0ZWRcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB3YXMgc3dpdGNoZWQgb2ZmLlxuICogQHBhcmFtIHtSZW1vdGVWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gdGhhdCB3YXNcbiAqICAgc3dpdGNoZWQgb2ZmXG4gKiBAZXZlbnQgUmVtb3RlVmlkZW9UcmFjayNzd2l0Y2hlZE9mZlxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHdhcyBzd2l0Y2hlZCBvbi5cbiAqIEBwYXJhbSB7UmVtb3RlVmlkZW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHRoYXQgd2FzXG4gKiAgIHN3aXRjaGVkIG9uXG4gKiBAZXZlbnQgUmVtb3RlVmlkZW9UcmFjayNzd2l0Y2hlZE9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlVmlkZW9UcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW90ZXZpZGVvdHJhY2suanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBSZW1vdGVUcmFja1B1YmxpY2F0aW9uID0gcmVxdWlyZSgnLi9yZW1vdGV0cmFja3B1YmxpY2F0aW9uJyk7XG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbn0gcmVwcmVzZW50cyBhIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfVxuICogdGhhdCBoYXMgYmVlbiBwdWJsaXNoZWQgdG8gYSB7QGxpbmsgUm9vbX0uXG4gKiBAcHJvcGVydHkge1RyYWNrLktpbmR9IGtpbmQgLSBcInZpZGVvXCJcbiAqIEBwcm9wZXJ0eSB7P1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gdW5sZXNzIHlvdSBoYXZlIHN1YnNjcmliZWQgdG8gdGhlXG4gKiAgIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSwgdGhpcyBwcm9wZXJ0eSBpcyBudWxsXG4gKiBAZW1pdHMgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uI3N1YnNjcmliZWRcbiAqIEBlbWl0cyBSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb24jc3Vic2NyaXB0aW9uRmFpbGVkXG4gKiBAZW1pdHMgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uI3RyYWNrRGlzYWJsZWRcbiAqIEBlbWl0cyBSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb24jdHJhY2tFbmFibGVkXG4gKiBAZW1pdHMgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uI3Vuc3Vic2NyaWJlZFxuICovXG52YXIgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbn0uXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfSBzaWduYWxpbmcgLSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gc2lnbmFsaW5nXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9uT3B0aW9uc30gb3B0aW9ucyAtIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICAgICAqICAgb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbihzaWduYWxpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNpZ25hbGluZywgb3B0aW9ucykgfHwgdGhpcztcbiAgICB9XG4gICAgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW1JlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbiAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgdGhpcy50cmFja1NpZCArIFwiXVwiO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbjtcbn0oUmVtb3RlVHJhY2tQdWJsaWNhdGlvbikpO1xuLyoqXG4gKiBZb3VyIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBzdWJzY3JpYmVkIHRvIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30uXG4gKiBAcGFyYW0ge1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB0aGF0IHdhcyBzdWJzY3JpYmVkIHRvXG4gKiBAZXZlbnQgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uI3N1YnNjcmliZWRcbiAqL1xuLyoqXG4gKiBZb3VyIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBmYWlsZWQgdG8gc3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30uXG4gKiBAcGFyYW0ge1R3aWxpb0Vycm9yfSBlcnJvciAtIHRoZSByZWFzb24gdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSBjb3VsZCBub3QgYmVcbiAqICAgc3Vic2NyaWJlZCB0b1xuICogQGV2ZW50IFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbiNzdWJzY3JpcHRpb25GYWlsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9IHdhcyBkaXNhYmxlZC5cbiAqIEBldmVudCBSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb24jdHJhY2tEaXNhYmxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30gd2FzIGVuYWJsZWQuXG4gKiBAZXZlbnQgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uI3RyYWNrRW5hYmxlZFxuICovXG4vKipcbiAqIFlvdXIge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IHVuc3Vic2NyaWJlZCBmcm9tIHRoZSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30uXG4gKiBAcGFyYW0ge1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gdGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB0aGF0IHdhcyB1bnN1YnNjcmliZWQgZnJvbVxuICogQGV2ZW50IFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbiN1bnN1YnNjcmliZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdGV2aWRlb3RyYWNrcHVibGljYXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBNZWRpYVRyYWNrVHJhbnNjZWl2ZXIgPSByZXF1aXJlKCcuL3RyYW5zY2VpdmVyJyk7XG4vKipcbiAqIEEge0BsaW5rIE1lZGlhVHJhY2tTZW5kZXJ9IHJlcHJlc2VudHMgb25lIG9yIG1vcmUgbG9jYWwgUlRDUnRwU2VuZGVycy5cbiAqIEBleHRlbmRzIE1lZGlhVHJhY2tUcmFuc2NlaXZlclxuICovXG52YXIgTWVkaWFUcmFja1NlbmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVkaWFUcmFja1NlbmRlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTWVkaWFUcmFja1NlbmRlcn0uXG4gICAgICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSBtZWRpYVN0cmVhbVRyYWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWVkaWFUcmFja1NlbmRlcihtZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lZGlhU3RyZWFtVHJhY2suaWQsIG1lZGlhU3RyZWFtVHJhY2spIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfY2xvbmVzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZW5kZXJzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzUHVibGlzaGluZzoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLl9jbG9uZXMuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyB7QGxpbmsgTWVkaWFUcmFja1NlbmRlcn0gY29udGFpbmluZyBhIGNsb25lIG9mIHRoZSB1bmRlcmx5aW5nXG4gICAgICogTWVkaWFTdHJlYW1UcmFjay4gTm8gUlRDUnRwU2VuZGVycyBhcmUgY29waWVkLlxuICAgICAqIEByZXR1cm5zIHtNZWRpYVRyYWNrU2VuZGVyfVxuICAgICAqL1xuICAgIE1lZGlhVHJhY2tTZW5kZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xvbmUgPSBuZXcgTWVkaWFUcmFja1NlbmRlcih0aGlzLnRyYWNrLmNsb25lKCkpO1xuICAgICAgICB0aGlzLl9jbG9uZXMuYWRkKGNsb25lKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY2xvbmVkIHtAbGluayBNZWRpYVRyYWNrU2VuZGVyfS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrU2VuZGVyLnByb3RvdHlwZS5yZW1vdmVDbG9uZSA9IGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICB0aGlzLl9jbG9uZXMuZGVsZXRlKGNsb25lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZ2l2ZW4gTWVkaWFTdHJlYW1UcmFjay5cbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IG1lZGlhU3RyZWFtVHJhY2tcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBNZWRpYVRyYWNrU2VuZGVyLnByb3RvdHlwZS5zZXRNZWRpYVN0cmVhbVRyYWNrID0gZnVuY3Rpb24gKG1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNsb25lcyA9IEFycmF5LmZyb20odGhpcy5fY2xvbmVzKTtcbiAgICAgICAgdmFyIHNlbmRlcnMgPSBBcnJheS5mcm9tKHRoaXMuX3NlbmRlcnMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2xvbmVzLm1hcChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZS5zZXRNZWRpYVN0cmVhbVRyYWNrKG1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKSk7XG4gICAgICAgIH0pLmNvbmNhdChzZW5kZXJzLm1hcChmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VuZGVyLnJlcGxhY2VUcmFjayhtZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgfSkpKS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl90cmFjayA9IG1lZGlhU3RyZWFtVHJhY2s7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGFuIFJUQ1J0cFNlbmRlci5cbiAgICAgKiBAcGFyYW0ge1JUQ1J0cFNlbmRlcn0gc2VuZGVyXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgTWVkaWFUcmFja1NlbmRlci5wcm90b3R5cGUuYWRkU2VuZGVyID0gZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgICB0aGlzLl9zZW5kZXJzLmFkZChzZW5kZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBSVENSdHBTZW5kZXIuXG4gICAgICogQHBhcmFtIHtSVENSdHBTZW5kZXJ9IHNlbmRlclxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIE1lZGlhVHJhY2tTZW5kZXIucHJvdG90eXBlLnJlbW92ZVNlbmRlciA9IGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICAgICAgdGhpcy5fc2VuZGVycy5kZWxldGUoc2VuZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gTWVkaWFUcmFja1NlbmRlcjtcbn0oTWVkaWFUcmFja1RyYW5zY2VpdmVyKSk7XG5tb2R1bGUuZXhwb3J0cyA9IE1lZGlhVHJhY2tTZW5kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW5kZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuLi8uLi9ldmVudGVtaXR0ZXInKTtcbnZhciBfYSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKSwgYnVpbGRMb2dMZXZlbHMgPSBfYS5idWlsZExvZ0xldmVscywgdmFsdWVUb0pTT04gPSBfYS52YWx1ZVRvSlNPTjtcbnZhciBERUZBVUxUX0xPR19MRVZFTCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uc3RhbnRzJykuREVGQVVMVF9MT0dfTEVWRUw7XG52YXIgTG9nID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9sb2cnKTtcbnZhciBuSW5zdGFuY2VzID0gMDtcbi8qKlxuICogQSB7QGxpbmsgVHJhY2tQdWJsaWNhdGlvbn0gcmVwcmVzZW50cyBhIHtAbGluayBUcmFja30gdGhhdFxuICogaGFzIGJlZW4gcHVibGlzaGVkIHRvIGEge0BsaW5rIFJvb219LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRyYWNrTmFtZSAtIHRoZSBwdWJsaXNoZWQge0BsaW5rIFRyYWNrfSdzIG5hbWVcbiAqIEBwcm9wZXJ0eSB7VHJhY2suU0lEfSB0cmFja1NpZCAtIFNJRCBhc3NpZ25lZCB0byB0aGUgcHVibGlzaGVkIHtAbGluayBUcmFja31cbiAqIEBlbWl0cyBUcmFja1B1YmxpY2F0aW9uI3RyYWNrRGlzYWJsZWRcbiAqIEBlbWl0cyBUcmFja1B1YmxpY2F0aW9uI3RyYWNrRW5hYmxlZFxuICovXG52YXIgVHJhY2tQdWJsaWNhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJhY2tQdWJsaWNhdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgVHJhY2tQdWJsaWNhdGlvbn0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWNrTmFtZSAtIHRoZSBwdWJsaXNoZWQge0BsaW5rIFRyYWNrfSdzIG5hbWVcbiAgICAgKiBAcGFyYW0ge1RyYWNrLlNJRH0gdHJhY2tTaWQgLSBTSUQgYXNzaWduZWQgdG8gdGhlIHtAbGluayBUcmFja31cbiAgICAgKiBAcGFyYW0ge1RyYWNrUHVibGljYXRpb25PcHRpb25zfSBvcHRpb25zIC0ge0BsaW5rIFRyYWNrUHVibGljYXRpb259IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFja1B1YmxpY2F0aW9uKHRyYWNrTmFtZSwgdHJhY2tTaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgbG9nTGV2ZWw6IERFRkFVTFRfTE9HX0xFVkVMXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgbG9nTGV2ZWxzID0gYnVpbGRMb2dMZXZlbHMob3B0aW9ucy5sb2dMZXZlbCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfaW5zdGFuY2VJZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuSW5zdGFuY2VzKytcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9nOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMubG9nID8gb3B0aW9ucy5sb2cuY3JlYXRlTG9nKCdkZWZhdWx0JywgX3RoaXMpIDogbmV3IExvZygnZGVmYXVsdCcsIF90aGlzLCBsb2dMZXZlbHMsIG9wdGlvbnMubG9nZ2VyTmFtZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFja05hbWU6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0cmFja05hbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFja1NpZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRyYWNrU2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRyYWNrUHVibGljYXRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlVG9KU09OKHRoaXMpO1xuICAgIH07XG4gICAgVHJhY2tQdWJsaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltUcmFja1B1YmxpY2F0aW9uICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyBcIjogXCIgKyB0aGlzLnRyYWNrU2lkICsgXCJdXCI7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhY2tQdWJsaWNhdGlvbjtcbn0oRXZlbnRFbWl0dGVyKSk7XG4vKipcbiAqIFRoZSBwdWJsaXNoZWQge0BsaW5rIFRyYWNrfSB3YXMgZGlzYWJsZWQuXG4gKiBAZXZlbnQgVHJhY2tQdWJsaWNhdGlvbiN0cmFja0Rpc2FibGVkXG4gKi9cbi8qKlxuICogVGhlIHB1Ymxpc2hlZCB7QGxpbmsgVHJhY2t9IHdhcyBlbmFibGVkLlxuICogQGV2ZW50IFRyYWNrUHVibGljYXRpb24jdHJhY2tFbmFibGVkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb259IG9yIGEge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbn0uXG4gKiBAdHlwZWRlZiB7TG9jYWxBdWRpb1RyYWNrUHVibGljYXRpb258UmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9ufSBBdWRpb1RyYWNrUHVibGljYXRpb25cbiAqL1xuLyoqXG4gKiBBIHtAbGluayBMb2NhbERhdGFUcmFja1B1YmxpY2F0aW9ufSBvciBhIHtAbGluayBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbn0uXG4gKiBAdHlwZWRlZiB7TG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvbnxSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbn0gRGF0YVRyYWNrUHVibGljYXRpb25cbiAqL1xuLyoqXG4gKiBBIHtAbGluayBMb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvbn0gb3IgYSB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9ufS5cbiAqIEB0eXBlZGVmIHtMb2NhbFZpZGVvVHJhY2tQdWJsaWNhdGlvbnxSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb259IFZpZGVvVHJhY2tQdWJsaWNhdGlvblxuICovXG4vKipcbiAqIHtAbGluayBUcmFja1B1YmxpY2F0aW9ufSBvcHRpb25zXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUcmFja1B1YmxpY2F0aW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtMb2dMZXZlbHxMb2dMZXZlbHN9IGxvZ0xldmVsIC0gTG9nIGxldmVsIGZvciAnbWVkaWEnIG1vZHVsZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBUcmFja1B1YmxpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2twdWJsaWNhdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFRyYWNrVHJhbnNjZWl2ZXIgPSByZXF1aXJlKCcuLi8uLi90cmFuc2NlaXZlcicpO1xuLyoqXG4gKiBBIHtAbGluayBNZWRpYVRyYWNrVHJhbnNjZWl2ZXJ9IHJlcHJlc2VudHMgZWl0aGVyIG9uZSBvciBtb3JlIGxvY2FsXG4gKiBSVENSdHBTZW5kZXJzLCBvciBhIHNpbmdsZSBSVENSdHBSZWNlaXZlci5cbiAqIEBleHRlbmRzIFRyYWNrVHJhbnNjZWl2ZXJcbiAqIEBwcm9wZXJ0eSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAqL1xudmFyIE1lZGlhVHJhY2tUcmFuc2NlaXZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVkaWFUcmFja1RyYW5zY2VpdmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBNZWRpYVRyYWNrVHJhbnNjZWl2ZXJ9LlxuICAgICAqIEBwYXJhbSB7VHJhY2suSUR9IGlkIC0gVGhlIE1lZGlhU3RyZWFtVHJhY2sgSUQgc2lnbmFsZWQgdGhyb3VnaCBSU1AvU0RQXG4gICAgICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSBtZWRpYVN0cmVhbVRyYWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWVkaWFUcmFja1RyYW5zY2VpdmVyKGlkLCBtZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGlkLCBtZWRpYVN0cmVhbVRyYWNrLmtpbmQpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfdHJhY2s6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWVkaWFTdHJlYW1UcmFjayxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2suZW5hYmxlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVhZHlTdGF0ZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFjay5yZWFkeVN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFjazoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1lZGlhVHJhY2tUcmFuc2NlaXZlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmFjay5zdG9wKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc3RvcC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lZGlhVHJhY2tUcmFuc2NlaXZlcjtcbn0oVHJhY2tUcmFuc2NlaXZlcikpO1xubW9kdWxlLmV4cG9ydHMgPSBNZWRpYVRyYWNrVHJhbnNjZWl2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2NlaXZlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBERUZBVUxUX1ZJREVPX1BST0NFU1NPUl9TVEFUU19JTlRFUlZBTF9NUyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uc3RhbnRzJykuREVGQVVMVF9WSURFT19QUk9DRVNTT1JfU1RBVFNfSU5URVJWQUxfTVM7XG4vKipcbiAqIFZpZGVvUHJvY2Vzc29yRXZlbnRPYnNlcnZlciBsaXN0ZW5zIHRvIHtAbGluayBWaWRlb1Byb2Nlc3Nvcn0gcmVsYXRlZCBldmVudHNcbiAqIGFuZCByZS1lbWl0cyB0aGVtIGFzIGEgZ2VuZXJpYyBldmVudCB3aXRoIHNvbWUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQGVtaXRzIFZpZGVvUHJvY2Vzc29yRXZlbnRPYnNlcnZlciNldmVudFxuICovXG52YXIgVmlkZW9Qcm9jZXNzb3JFdmVudE9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaWRlb1Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHtMb2d9IGxvZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZpZGVvUHJvY2Vzc29yRXZlbnRPYnNlcnZlcihsb2cpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9sYXN0U3RhdHNTYXZlVGltZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xhc3RTdGF0c1B1Ymxpc2hUaW1lOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9nOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGxvZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9wcm9jZXNzb3JJbmZvOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc3RhdHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMub24oJ2FkZCcsIGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgICBfdGhpcy5fbGFzdFN0YXRzU2F2ZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgX3RoaXMuX2xhc3RTdGF0c1B1Ymxpc2hUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIF90aGlzLl9wcm9jZXNzb3JJbmZvID0gaW5mbztcbiAgICAgICAgICAgIF90aGlzLl9zdGF0cyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuX3JlZW1pdEV2ZW50KCdhZGQnLCBfdGhpcy5fZ2V0RXZlbnREYXRhKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMub24oJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gX3RoaXMuX2dldEV2ZW50RGF0YSgpO1xuICAgICAgICAgICAgX3RoaXMuX2xhc3RTdGF0c1NhdmVUaW1lID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLl9sYXN0U3RhdHNQdWJsaXNoVGltZSA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5fcHJvY2Vzc29ySW5mbyA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5fc3RhdHMgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuX3JlZW1pdEV2ZW50KCdyZW1vdmUnLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZWVtaXRFdmVudCgnc3RhcnQnLCBfdGhpcy5fZ2V0RXZlbnREYXRhKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMub24oJ3N0b3AnLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgX3RoaXMuX3JlZW1pdEV2ZW50KCdzdG9wJywgT2JqZWN0LmFzc2lnbih7IG1lc3NhZ2U6IG1lc3NhZ2UgfSwgX3RoaXMuX2dldEV2ZW50RGF0YSgpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vbignc3RhdHMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbWF5YmVFbWl0U3RhdHMoKTsgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWaWRlb1Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIucHJvdG90eXBlLl9nZXRFdmVudERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJvY2Vzc29ySW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3Byb2Nlc3NvckluZm8sIHByb2Nlc3NvciA9IF9hLnByb2Nlc3NvciwgY2FwdHVyZUhlaWdodCA9IF9hLmNhcHR1cmVIZWlnaHQsIGNhcHR1cmVXaWR0aCA9IF9hLmNhcHR1cmVXaWR0aCwgaW5wdXRGcmFtZVJhdGUgPSBfYS5pbnB1dEZyYW1lUmF0ZSwgaXNSZW1vdGVWaWRlb1RyYWNrID0gX2EuaXNSZW1vdGVWaWRlb1RyYWNrO1xuICAgICAgICB2YXIgZGF0YSA9IHsgY2FwdHVyZUhlaWdodDogY2FwdHVyZUhlaWdodCwgY2FwdHVyZVdpZHRoOiBjYXB0dXJlV2lkdGgsIGlucHV0RnJhbWVSYXRlOiBpbnB1dEZyYW1lUmF0ZSwgaXNSZW1vdGVWaWRlb1RyYWNrOiBpc1JlbW90ZVZpZGVvVHJhY2sgfTtcbiAgICAgICAgZGF0YS5uYW1lID0gcHJvY2Vzc29yLl9uYW1lIHx8ICdWaWRlb1Byb2Nlc3Nvcic7XG4gICAgICAgIFsnYXNzZXRzUGF0aCcsICdibHVyRmlsdGVyUmFkaXVzJywgJ2ZpdFR5cGUnLCAnaXNTaW1kRW5hYmxlZCcsICdtYXNrQmx1clJhZGl1cycsICd2ZXJzaW9uJ10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHByb2Nlc3NvcltcIl9cIiArIHByb3BdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtwcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBkYXRhW3Byb3BdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGRhdGFbcHJvcF0gPSB2YWwgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTYXZlIHN0YXRzIGV2ZXJ5IHNlY29uZC4gSWYgYSBzcGVjaWZpYyB0aW1lIGludGVydmFsIGhhcyBlbGFwc2VkLFxuICAgICAqIHRoZSBzdGF0cyBldmVudCB3aWxsIGJlIGVtaXR0ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZGVvUHJvY2Vzc29yRXZlbnRPYnNlcnZlci5wcm90b3R5cGUuX21heWJlRW1pdFN0YXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRzIHx8ICF0aGlzLl9wcm9jZXNzb3JJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlbmNobWFyayA9IHRoaXMuX3Byb2Nlc3NvckluZm8ucHJvY2Vzc29yLl9iZW5jaG1hcms7XG4gICAgICAgIGlmICghYmVuY2htYXJrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgLSB0aGlzLl9sYXN0U3RhdHNTYXZlVGltZSA8IDEwMDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSB7IG91dHB1dEZyYW1lUmF0ZTogYmVuY2htYXJrLmdldFJhdGUoJ3RvdGFsUHJvY2Vzc2luZ0RlbGF5JykgfTtcbiAgICAgICAgWydjYXB0dXJlRnJhbWVEZWxheScsICdpbWFnZUNvbXBvc2l0aW9uRGVsYXknLCAnaW5wdXRJbWFnZVJlc2l6ZURlbGF5JywgJ3Byb2Nlc3NGcmFtZURlbGF5JywgJ3NlZ21lbnRhdGlvbkRlbGF5J10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgZW50cnlbbmFtZV0gPSBiZW5jaG1hcmsuZ2V0QXZlcmFnZURlbGF5KG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbGFzdFN0YXRzU2F2ZVRpbWUgPSBub3c7XG4gICAgICAgIHRoaXMuX3N0YXRzLnB1c2goZW50cnkpO1xuICAgICAgICBpZiAobm93IC0gdGhpcy5fbGFzdFN0YXRzUHVibGlzaFRpbWUgPCBERUZBVUxUX1ZJREVPX1BST0NFU1NPUl9TVEFUU19JTlRFUlZBTF9NUykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RTdGF0c1B1Ymxpc2hUaW1lID0gbm93O1xuICAgICAgICB2YXIgc3RhdHMgPSB0aGlzLl9zdGF0cy5zcGxpY2UoMCk7XG4gICAgICAgIHZhciBhdmVyYWdlcyA9IHN0YXRzLnJlZHVjZShmdW5jdGlvbiAoYXZlcmFnZXMsIGN1cnJlbnQsIG4pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGVudHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhdmVyYWdlc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBhdmVyYWdlc1tuYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF2ZXJhZ2VzW25hbWVdID0gKChhdmVyYWdlc1tuYW1lXSAqIG4pICsgY3VycmVudFtuYW1lXSkgLyAobiArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYXZlcmFnZXM7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXZlcmFnZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGF2ZXJhZ2VzW25hbWVdID0gcGFyc2VGbG9hdChhdmVyYWdlc1tuYW1lXS50b0ZpeGVkKDIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JlZW1pdEV2ZW50KCdzdGF0cycsIE9iamVjdC5hc3NpZ24oe30sIGF2ZXJhZ2VzLCB0aGlzLl9nZXRFdmVudERhdGEoKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWaWRlb1Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIucHJvdG90eXBlLl9yZWVtaXRFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBkYXRhKSB7XG4gICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIlZpZGVvUHJvY2Vzc29yOlwiICsgbmFtZSwgZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCB7IG5hbWU6IG5hbWUsIGRhdGE6IGRhdGEgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVmlkZW9Qcm9jZXNzb3JFdmVudE9ic2VydmVyO1xufShFdmVudEVtaXR0ZXIpKTtcbm1vZHVsZS5leHBvcnRzID0gVmlkZW9Qcm9jZXNzb3JFdmVudE9ic2VydmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlkZW9wcm9jZXNzb3JldmVudG9ic2VydmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTWVkaWFUcmFjayA9IHJlcXVpcmUoJy4vbWVkaWF0cmFjaycpO1xudmFyIFZpZGVvUHJvY2Vzc29yRXZlbnRPYnNlcnZlciA9IHJlcXVpcmUoJy4vdmlkZW9wcm9jZXNzb3JldmVudG9ic2VydmVyJyk7XG52YXIgREVGQVVMVF9GUkFNRV9SQVRFID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25zdGFudHMnKS5ERUZBVUxUX0ZSQU1FX1JBVEU7XG4vKipcbiAqIEEge0BsaW5rIFZpZGVvVHJhY2t9IGlzIGEge0BsaW5rIFRyYWNrfSByZXByZXNlbnRpbmcgdmlkZW8uXG4gKiBAZXh0ZW5kcyBUcmFja1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc1N0YXJ0ZWQgLSBXaGV0aGVyIG9yIG5vdCB0aGUge0BsaW5rIFZpZGVvVHJhY2t9IGhhc1xuICogICBzdGFydGVkOyBpZiB0aGUge0BsaW5rIFZpZGVvVHJhY2t9IHN0YXJ0ZWQsIHRoZXJlIGlzIGVub3VnaCB2aWRlbyBkYXRhIHRvXG4gKiAgIGJlZ2luIHBsYXliYWNrXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzRW5hYmxlZCAtIFdoZXRoZXIgb3Igbm90IHRoZSB7QGxpbmsgVmlkZW9UcmFja30gaXNcbiAqICAgZW5hYmxlZDsgaWYgdGhlIHtAbGluayBWaWRlb1RyYWNrfSBpcyBub3QgZW5hYmxlZCwgaXQgaXMgXCJwYXVzZWRcIlxuICogQHByb3BlcnR5IHtWaWRlb1RyYWNrLkRpbWVuc2lvbnN9IGRpbWVuc2lvbnMgLSBUaGUge0BsaW5rIFZpZGVvVHJhY2t9J3NcbiAqICAge0BsaW5rIFZpZGVvVHJhY2suRGltZW5zaW9uc31cbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZCAtIFwidmlkZW9cIlxuICogQHByb3BlcnR5IHtNZWRpYVN0cmVhbVRyYWNrfSBtZWRpYVN0cmVhbVRyYWNrIC0gQSB2aWRlbyBNZWRpYVN0cmVhbVRyYWNrXG4gKiBAcHJvcGVydHkgez9NZWRpYVN0cmVhbVRyYWNrfSBwcm9jZXNzZWRUcmFjayAtIFRoZSBzb3VyY2Ugb2YgcHJvY2Vzc2VkIHZpZGVvIGZyYW1lcy5cbiAqIEl0IGlzIG51bGwgaWYgbm8gVmlkZW9Qcm9jZXNzb3IgaGFzIGJlZW4gYWRkZWQuXG4gKiBAcHJvcGVydHkgez9WaWRlb1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIC0gQSB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9IHRoYXQgaXMgY3VycmVudGx5XG4gKiAgIHByb2Nlc3NpbmcgdmlkZW8gZnJhbWVzLiBJdCBpcyBudWxsIGlmIHZpZGVvIGZyYW1lcyBhcmUgbm90IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBlbWl0cyBWaWRlb1RyYWNrI2RpbWVuc2lvbnNDaGFuZ2VkXG4gKiBAZW1pdHMgVmlkZW9UcmFjayNkaXNhYmxlZFxuICogQGVtaXRzIFZpZGVvVHJhY2sjZW5hYmxlZFxuICogQGVtaXRzIFZpZGVvVHJhY2sjc3RhcnRlZFxuICovXG52YXIgVmlkZW9UcmFjayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlkZW9UcmFjaywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgVmlkZW9UcmFja30uXG4gICAgICogQHBhcmFtIHtNZWRpYVRyYWNrVHJhbnNjZWl2ZXJ9IG1lZGlhVHJhY2tUcmFuc2NlaXZlclxuICAgICAqIEBwYXJhbSB7e2xvZzogTG9nfX0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZpZGVvVHJhY2sobWVkaWFUcmFja1RyYW5zY2VpdmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lZGlhVHJhY2tUcmFuc2NlaXZlciwgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9jYXB0dXJlVGltZW91dElkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaXNDYXB0dXJpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW5wdXRGcmFtZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX291dHB1dEZyYW1lOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcHJvY2Vzc29yRXZlbnRPYnNlcnZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF91bm11dGVIYW5kbGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3Nvcjoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLl9wcm9jZXNzb3JFdmVudE9ic2VydmVyID0gbmV3IChvcHRpb25zLlZpZGVvUHJvY2Vzc29yRXZlbnRPYnNlcnZlciB8fCBWaWRlb1Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIpKF90aGlzLl9sb2cpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlkZW9UcmFjay5wcm90b3R5cGUuX2NoZWNrSWZDYW5DYXB0dXJlRnJhbWVzID0gZnVuY3Rpb24gKGlzUHVibGlzaGluZykge1xuICAgICAgICBpZiAoaXNQdWJsaXNoaW5nID09PSB2b2lkIDApIHsgaXNQdWJsaXNoaW5nID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGNhbkNhcHR1cmVGcmFtZXMgPSB0cnVlO1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVuYWJsZWQgPSBfYS5lbmFibGVkLCByZWFkeVN0YXRlID0gX2EucmVhZHlTdGF0ZTtcbiAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICBjYW5DYXB0dXJlRnJhbWVzID0gZmFsc2U7XG4gICAgICAgICAgICBtZXNzYWdlID0gJ01lZGlhU3RyZWFtVHJhY2sgaXMgZGlzYWJsZWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XG4gICAgICAgICAgICBjYW5DYXB0dXJlRnJhbWVzID0gZmFsc2U7XG4gICAgICAgICAgICBtZXNzYWdlID0gJ01lZGlhU3RyZWFtVHJhY2sgaXMgZW5kZWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHtcbiAgICAgICAgICAgIGNhbkNhcHR1cmVGcmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnVmlkZW9Qcm9jZXNzb3Igbm90IGRldGVjdGVkLic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9hdHRhY2htZW50cy5zaXplICYmICFpc1B1Ymxpc2hpbmcpIHtcbiAgICAgICAgICAgIGNhbkNhcHR1cmVGcmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnVmlkZW9UcmFjayBpcyBub3QgcHVibGlzaGluZyBhbmQgdGhlcmUgaXMgbm8gYXR0YWNoZWQgZWxlbWVudC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2FuQ2FwdHVyZUZyYW1lczogY2FuQ2FwdHVyZUZyYW1lcywgbWVzc2FnZTogbWVzc2FnZSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWaWRlb1RyYWNrLnByb3RvdHlwZS5fY2FwdHVyZUZyYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2FwdHVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0lnbm9yaW5nIGNhcHR1cmVGcmFtZXMgY2FsbC4gQ2FwdHVyZSBpcyBhbHJlYWR5IGluIHByb2dyZXNzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja0lmQ2FuQ2FwdHVyZUZyYW1lcygpLmNhbkNhcHR1cmVGcmFtZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2FwdHVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0Nhbm5vdCBjYXB0dXJlIGZyYW1lcy4gSWdub3JpbmcgY2FwdHVyZUZyYW1lcyBjYWxsLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzQ2FwdHVyaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc29yRXZlbnRPYnNlcnZlci5lbWl0KCdzdGFydCcpO1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ1N0YXJ0IGNhcHR1cmluZyBmcmFtZXMnKTtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBwcm9jZXNzRnJhbWVQZXJpb2RNcztcbiAgICAgICAgdGhpcy5fZHVtbXlFbC5wbGF5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZUZyYW1lID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLl9jYXB0dXJlVGltZW91dElkKTtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZnJhbWVSYXRlLCBmcmFtZVJhdGUgPSBfYSA9PT0gdm9pZCAwID8gREVGQVVMVF9GUkFNRV9SQVRFIDogX2E7XG4gICAgICAgICAgICAgICAgdmFyIGNhcHR1cmVQZXJpb2RNcyA9IE1hdGguZmxvb3IoMTAwMCAvIGZyYW1lUmF0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGF5ID0gY2FwdHVyZVBlcmlvZE1zIC0gcHJvY2Vzc0ZyYW1lUGVyaW9kTXM7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5IDwgMCB8fCB0eXBlb2YgcHJvY2Vzc0ZyYW1lUGVyaW9kTXMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NhcHR1cmVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGNiLCBkZWxheSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrUmVzdWx0ID0gX3RoaXMuX2NoZWNrSWZDYW5DYXB0dXJlRnJhbWVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1Jlc3VsdC5jYW5DYXB0dXJlRnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc0NhcHR1cmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvY2Vzc29yRXZlbnRPYnNlcnZlci5lbWl0KCdzdG9wJywgY2hlY2tSZXN1bHQubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoJ0Nhbm5vdCBjYXB0dXJlIGZyYW1lcy4gU3RvcHBpbmcgY2FwdHVyaW5nIGZyYW1lcy4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKSwgX2IgPSBfYS53aWR0aCwgd2lkdGggPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLCBfYyA9IF9hLmhlaWdodCwgaGVpZ2h0ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYztcbiAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIHRoZSBjYW52YXMnIGRpbWVuc2lvbiB0cmlnZ2VycyBhIHJlZHJhdy5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IHNldCBpdCBpZiBpdCBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lucHV0RnJhbWUud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbnB1dEZyYW1lLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbnB1dEZyYW1lLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9vdXRwdXRGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX291dHB1dEZyYW1lLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb3V0cHV0RnJhbWUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9pbnB1dEZyYW1lLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKF90aGlzLl9kdW1teUVsLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfdGhpcy5wcm9jZXNzb3IucHJvY2Vzc0ZyYW1lKF90aGlzLl9pbnB1dEZyYW1lLCBfdGhpcy5fb3V0cHV0RnJhbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZygnRXhjZXB0aW9uIGRldGVjdGVkIGFmdGVyIGNhbGxpbmcgcHJvY2Vzc0ZyYW1lLicsIGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSA/IHJlc3VsdCA6IFByb21pc2UucmVzb2x2ZShyZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fb3V0cHV0RnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByb2Nlc3NlZFRyYWNrLnJlcXVlc3RGcmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIuZW1pdCgnc3RhdHMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0ZyYW1lUGVyaW9kTXMgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICBjYXB0dXJlRnJhbWUocHJvY2Vzcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FwdHVyZUZyYW1lKHByb2Nlc3MpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIF90aGlzLl9sb2cuZXJyb3IoJ1ZpZGVvIGVsZW1lbnQgY2Fubm90IGJlIHBsYXllZCcsIHsgZXJyb3I6IGVycm9yLCB0cmFjazogX3RoaXMgfSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWaWRlb1RyYWNrLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5faW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fZHVtbXlFbCkge1xuICAgICAgICAgICAgdGhpcy5fZHVtbXlFbC5vbmxvYWRlZG1ldGFkYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25zQ2hhbmdlZChfdGhpcywgX3RoaXMuX2R1bW15RWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpbWVuc2lvbnMud2lkdGggPSBfdGhpcy5fZHVtbXlFbC52aWRlb1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaW1lbnNpb25zLmhlaWdodCA9IF90aGlzLl9kdW1teUVsLnZpZGVvSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9kdW1teUVsLm9ucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25zQ2hhbmdlZChfdGhpcywgX3RoaXMuX2R1bW15RWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpbWVuc2lvbnMud2lkdGggPSBfdGhpcy5fZHVtbXlFbC52aWRlb1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaW1lbnNpb25zLmhlaWdodCA9IF90aGlzLl9kdW1teUVsLnZpZGVvSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKCdEaW1lbnNpb25zIGNoYW5nZWQ6JywgX3RoaXMuZGltZW5zaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFZpZGVvVHJhY2suRElNRU5TSU9OU19DSEFOR0VELCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZGVvVHJhY2sucHJvdG90eXBlLl9yZXN0YXJ0UHJvY2Vzc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvY2Vzc29yID0gdGhpcy5wcm9jZXNzb3I7XG4gICAgICAgIGlmIChwcm9jZXNzb3IpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUHJvY2Vzc29yKHByb2Nlc3Nvcik7XG4gICAgICAgICAgICB0aGlzLmFkZFByb2Nlc3Nvcihwcm9jZXNzb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZGVvVHJhY2sucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChkdW1teUVsKSB7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy53aWR0aCA9IGR1bW15RWwudmlkZW9XaWR0aDtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLmhlaWdodCA9IGR1bW15RWwudmlkZW9IZWlnaHQ7XG4gICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygnRGltZW5zaW9uczonLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5fc3RhcnQuY2FsbCh0aGlzLCBkdW1teUVsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIHtAbGluayBWaWRlb1Byb2Nlc3Nvcn0gdG8gYWxsb3cgZm9yIGN1c3RvbSBwcm9jZXNzaW5nIG9mIHZpZGVvIGZyYW1lcyBiZWxvbmdpbmcgdG8gYSBWaWRlb1RyYWNrLlxuICAgICAqIE9ubHkgQ2hyb21lIHN1cHBvcnRzIHRoaXMgYXMgb2Ygbm93LiBDYWxsaW5nIHRoaXMgQVBJIGZyb20gYSBub24tc3VwcG9ydGVkIGJyb3dzZXIgd2lsbCByZXN1bHQgaW4gYSBsb2cgd2FybmluZy5cbiAgICAgKiBAcGFyYW0ge1ZpZGVvUHJvY2Vzc29yfSBwcm9jZXNzb3IgLSBUaGUge0BsaW5rIFZpZGVvUHJvY2Vzc29yfSB0byB1c2UuXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjbGFzcyBHcmF5U2NhbGVQcm9jZXNzb3Ige1xuICAgICAqICAgY29uc3RydWN0b3IocGVyY2VudGFnZSkge1xuICAgICAqICAgICB0aGlzLnBlcmNlbnRhZ2UgPSBwZXJjZW50YWdlO1xuICAgICAqICAgfVxuICAgICAqICAgcHJvY2Vzc0ZyYW1lKGlucHV0RnJhbWVCdWZmZXIsIG91dHB1dEZyYW1lQnVmZmVyKSB7XG4gICAgICogICAgIGNvbnN0IGNvbnRleHQgPSBvdXRwdXRGcmFtZUJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAqICAgICBjb250ZXh0LmZpbHRlciA9IGBncmF5c2NhbGUoJHt0aGlzLnBlcmNlbnRhZ2V9JSlgO1xuICAgICAqICAgICBjb250ZXh0LmRyYXdJbWFnZShpbnB1dEZyYW1lQnVmZmVyLCAwLCAwLCBpbnB1dEZyYW1lQnVmZmVyLndpZHRoLCBpbnB1dEZyYW1lQnVmZmVyLmhlaWdodCk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogVmlkZW8uY3JlYXRlTG9jYWxWaWRlb1RyYWNrKCkudGhlbihmdW5jdGlvbih2aWRlb1RyYWNrKSB7XG4gICAgICogICB2aWRlb1RyYWNrLmFkZFByb2Nlc3NvcihuZXcgR3JheVNjYWxlUHJvY2Vzc29yKDEwMCkpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIFZpZGVvVHJhY2sucHJvdG90eXBlLmFkZFByb2Nlc3NvciA9IGZ1bmN0aW9uIChwcm9jZXNzb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2cud2FybignQWRkaW5nIGEgVmlkZW9Qcm9jZXNzb3IgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm9jZXNzb3IgfHwgdHlwZW9mIHByb2Nlc3Nvci5wcm9jZXNzRnJhbWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjZWl2ZWQgYW4gaW52YWxpZCBWaWRlb1Byb2Nlc3NvciBmcm9tIGFkZFByb2Nlc3Nvci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBWaWRlb1Byb2Nlc3NvciBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZHVtbXlFbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWaWRlb1RyYWNrIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0FkZGluZyBWaWRlb1Byb2Nlc3NvciB0byB0aGUgVmlkZW9UcmFjaycsIHByb2Nlc3Nvcik7XG4gICAgICAgIGlmICghdGhpcy5fdW5tdXRlSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fdW5tdXRlSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKCdtZWRpYVN0cmVhbVRyYWNrIHVubXV0ZWQnKTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKGNzYW50b3MpOiBPbiBjZXJ0YWluIHNjZW5hcmlvcyB3aGVyZSBtZWRpYVN0cmVhbVRyYWNrIGlzIGNvbWluZyBmcm9tIG11dGVkIHRvIHVubXV0ZWQgc3RhdGUsXG4gICAgICAgICAgICAgICAgLy8gdGhlIHByb2Nlc3NlZFRyYWNrIGRvZXNuJ3QgdW5tdXRlcyBhdXRvbWF0aWNhbGx5IGFsdGhvdWdoIGVuYWJsZWQgaXMgYWxyZWFkeSBzZXQgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgdGVybWluYWwgc3RhdGUgZm9yIHRoZSBwcm9jZXNzZWRUcmFjayBhbmQgc2hvdWxkIGJlIHJlc3RhcnRlZC4gKFZJREVPLTQxNzYpXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb2Nlc3NlZFRyYWNrLm11dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoJ21lZGlhU3RyZWFtVHJhY2sgaXMgdW5tdXRlZCBidXQgcHJvY2Vzc2VkVHJhY2sgaXMgbXV0ZWQuIFJlc3RhcnRpbmcgcHJvY2Vzc29yLicpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzdGFydFByb2Nlc3NvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5fdW5tdXRlSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCksIF9iID0gX2Eud2lkdGgsIHdpZHRoID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYiwgX2MgPSBfYS5oZWlnaHQsIGhlaWdodCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsIF9kID0gX2EuZnJhbWVSYXRlLCBmcmFtZVJhdGUgPSBfZCA9PT0gdm9pZCAwID8gREVGQVVMVF9GUkFNRV9SQVRFIDogX2Q7XG4gICAgICAgIHRoaXMuX2lucHV0RnJhbWUgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLl9vdXRwdXRGcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLl9vdXRwdXRGcmFtZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9vdXRwdXRGcmFtZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkVHJhY2sgPSB0aGlzLl9vdXRwdXRGcmFtZS5jYXB0dXJlU3RyZWFtKDApLmdldFRyYWNrcygpWzBdO1xuICAgICAgICB0aGlzLnByb2Nlc3NlZFRyYWNrLmVuYWJsZWQgPSB0aGlzLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZDtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NvckV2ZW50T2JzZXJ2ZXIuZW1pdCgnYWRkJywge1xuICAgICAgICAgICAgcHJvY2Vzc29yOiBwcm9jZXNzb3IsXG4gICAgICAgICAgICBjYXB0dXJlSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBjYXB0dXJlV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaW5wdXRGcmFtZVJhdGU6IGZyYW1lUmF0ZSxcbiAgICAgICAgICAgIGlzUmVtb3RlVmlkZW9UcmFjazogdGhpcy50b1N0cmluZygpLmluY2x1ZGVzKCdSZW1vdGVWaWRlb1RyYWNrJylcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUVsZW1lbnRzTWVkaWFTdHJlYW1UcmFjaygpO1xuICAgICAgICB0aGlzLl9jYXB0dXJlRnJhbWVzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIEhUTUxWaWRlb0VsZW1lbnQgYW5kIGF0dGFjaCB0aGUge0BsaW5rIFZpZGVvVHJhY2t9IHRvIGl0LlxuICAgICAqXG4gICAgICogVGhlIEhUTUxWaWRlb0VsZW1lbnQncyA8Y29kZT5zcmNPYmplY3Q8L2NvZGU+IHdpbGwgYmUgc2V0IHRvIGEgbmV3XG4gICAgICogTWVkaWFTdHJlYW0gY29udGFpbmluZyB0aGUge0BsaW5rIFZpZGVvVHJhY2t9J3MgTWVkaWFTdHJlYW1UcmFjay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtIVE1MVmlkZW9FbGVtZW50fSB2aWRlb0VsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gICAgICpcbiAgICAgKiBWaWRlby5jcmVhdGVMb2NhbFZpZGVvVHJhY2soKS50aGVuKGZ1bmN0aW9uKHZpZGVvVHJhY2spIHtcbiAgICAgKiAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IHZpZGVvVHJhY2suYXR0YWNoKCk7XG4gICAgICogICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHZpZGVvRWxlbWVudCk7XG4gICAgICogfSk7XG4gICAgKi8gLyoqXG4gICAgICogQXR0YWNoIHRoZSB7QGxpbmsgVmlkZW9UcmFja30gdG8gYW4gZXhpc3RpbmcgSFRNTE1lZGlhRWxlbWVudC4gVGhlXG4gICAgICogSFRNTE1lZGlhRWxlbWVudCBjb3VsZCBiZSBhbiBIVE1MQXVkaW9FbGVtZW50IG9yIGFuIEhUTUxWaWRlb0VsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgSFRNTE1lZGlhRWxlbWVudCdzIDxjb2RlPnNyY09iamVjdDwvY29kZT4gaXMgbm90IHNldCB0byBhIE1lZGlhU3RyZWFtLFxuICAgICAqIHRoaXMgbWV0aG9kIHNldHMgaXQgdG8gYSBuZXcgTWVkaWFTdHJlYW0gY29udGFpbmluZyB0aGUge0BsaW5rIFZpZGVvVHJhY2t9J3NcbiAgICAgKiBNZWRpYVN0cmVhbVRyYWNrOyBvdGhlcndpc2UsIGl0IGFkZHMgdGhlIHtAbGluayBNZWRpYVRyYWNrfSdzXG4gICAgICogTWVkaWFTdHJlYW1UcmFjayB0byB0aGUgZXhpc3RpbmcgTWVkaWFTdHJlYW0uIEZpbmFsbHksIGlmIHRoZXJlIGFyZSBhbnkgb3RoZXJcbiAgICAgKiBNZWRpYVN0cmVhbVRyYWNrcyBvZiB0aGUgc2FtZSBraW5kIG9uIHRoZSBNZWRpYVN0cmVhbSwgdGhpcyBtZXRob2QgcmVtb3Zlc1xuICAgICAqIHRoZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhRWxlbWVudCAtIFRoZSBIVE1MTWVkaWFFbGVtZW50IHRvIGF0dGFjaCB0b1xuICAgICAqIEByZXR1cm5zIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYUVsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gICAgICpcbiAgICAgKiBjb25zdCB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAqIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodmlkZW9FbGVtZW50KTtcbiAgICAgKlxuICAgICAqIFZpZGVvLmNyZWF0ZUxvY2FsVmlkZW9UcmFjaygpLnRoZW4oZnVuY3Rpb24odmlkZW9UcmFjaykge1xuICAgICAqICAgdmlkZW9UcmFjay5hdHRhY2godmlkZW9FbGVtZW50KTtcbiAgICAgKiB9KTtcbiAgICAqLyAvKipcbiAgICAgKiBBdHRhY2ggdGhlIHtAbGluayBWaWRlb1RyYWNrfSB0byBhbiBIVE1MTWVkaWFFbGVtZW50IHNlbGVjdGVkIGJ5XG4gICAgICogPGNvZGU+ZG9jdW1lbnQucXVlcnlTZWxlY3RvcjwvY29kZT4uIFRoZSBIVE1MTWVkaWFFbGVtZW50IGNvdWxkIGJlIGFuXG4gICAgICogSFRNTEF1ZGlvRWxlbWVudCBvciBhbiBIVE1MVmlkZW9FbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgdGhlIEhUTUxNZWRpYUVsZW1lbnQncyA8Y29kZT5zcmNPYmplY3Q8L2NvZGU+IGlzIG5vdCBzZXQgdG8gYSBNZWRpYVN0cmVhbSxcbiAgICAgKiB0aGlzIG1ldGhvZCBzZXRzIGl0IHRvIGEgbmV3IE1lZGlhU3RyZWFtIGNvbnRhaW5pbmcgdGhlIHtAbGluayBWaWRlb1RyYWNrfSdzXG4gICAgICogTWVkaWFTdHJlYW1UcmFjazsgb3RoZXJ3aXNlLCBpdCBhZGRzIHRoZSB7QGxpbmsgVmlkZW9UcmFja30nc1xuICAgICAqIE1lZGlhU3RyZWFtVHJhY2sgdG8gdGhlIGV4aXN0aW5nIE1lZGlhU3RyZWFtLiBGaW5hbGx5LCBpZiB0aGVyZSBhcmUgYW55IG90aGVyXG4gICAgICogTWVkaWFTdHJlYW1UcmFja3Mgb2YgdGhlIHNhbWUga2luZCBvbiB0aGUgTWVkaWFTdHJlYW0sIHRoaXMgbWV0aG9kIHJlbW92ZXNcbiAgICAgKiB0aGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gQSBxdWVyeSBzZWxlY3RvciBmb3IgdGhlIEhUTUxNZWRpYUVsZW1lbnQgdG9cbiAgICAgKiAgIGF0dGFjaCB0b1xuICAgICAqIEByZXR1cm5zIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYUVsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IFZpZGVvID0gcmVxdWlyZSgndHdpbGlvLXZpZGVvJyk7XG4gICAgICpcbiAgICAgKiBjb25zdCB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAqIHZpZGVvRWxlbWVudC5pZCA9ICdteS12aWRlby1lbGVtZW50JztcbiAgICAgKiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHZpZGVvRWxlbWVudCk7XG4gICAgICpcbiAgICAgKiBWaWRlby5jcmVhdGVMb2NhbFZpZGVvVHJhY2soKS50aGVuKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICogICB0cmFjay5hdHRhY2goJyNteS12aWRlby1lbGVtZW50Jyk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgVmlkZW9UcmFjay5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5hdHRhY2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXB0dXJlRnJhbWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaCB0aGUge0BsaW5rIFZpZGVvVHJhY2t9IGZyb20gYWxsIHByZXZpb3VzbHkgYXR0YWNoZWQgSFRNTE1lZGlhRWxlbWVudHMuXG4gICAgICogQHJldHVybnMge0FycmF5PEhUTUxNZWRpYUVsZW1lbnQ+fSBtZWRpYUVsZW1lbnRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBtZWRpYUVsZW1lbnRzID0gdmlkZW9UcmFjay5kZXRhY2goKTtcbiAgICAgKiBtZWRpYUVsZW1lbnRzLmZvckVhY2gobWVkaWFFbGVtZW50ID0+IG1lZGlhRWxlbWVudC5yZW1vdmUoKSk7XG4gICAgKi8gLyoqXG4gICAgICogRGV0YWNoIHRoZSB7QGxpbmsgVmlkZW9UcmFja30gZnJvbSBhIHByZXZpb3VzbHkgYXR0YWNoZWQgSFRNTE1lZGlhRWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhRWxlbWVudCAtIE9uZSBvZiB0aGUgSFRNTE1lZGlhRWxlbWVudHMgdG9cbiAgICAgKiAgIHdoaWNoIHRoZSB7QGxpbmsgVmlkZW9UcmFja30gaXMgYXR0YWNoZWRcbiAgICAgKiBAcmV0dXJucyB7SFRNTE1lZGlhRWxlbWVudH0gbWVkaWFFbGVtZW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXktdmlkZW8tZWxlbWVudCcpO1xuICAgICAqIHZpZGVvVHJhY2suZGV0YWNoKHZpZGVvRWxlbWVudCkucmVtb3ZlKCk7XG4gICAgKi8gLyoqXG4gICAgICogRGV0YWNoIHRoZSB7QGxpbmsgVmlkZW9UcmFja30gZnJvbSBhIHByZXZpb3VzbHkgYXR0YWNoZWQgSFRNTE1lZGlhRWxlbWVudFxuICAgICAqICAgc3BlY2lmaWVkIGJ5IDxjb2RlPmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3I8L2NvZGU+LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIFRoZSBxdWVyeSBzZWxlY3RvciBvZiBIVE1MTWVkaWFFbGVtZW50IHRvIHdoaWNoXG4gICAgICogICAgdGhlIHtAbGluayBWaWRlb1RyYWNrfSBpcyBhdHRhY2hlZFxuICAgICAqIEByZXR1cm5zIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYUVsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZpZGVvVHJhY2suZGV0YWNoKCcjbXktdmlkZW8tZWxlbWVudCcpLnJlbW92ZSgpO1xuICAgICAqL1xuICAgIFZpZGVvVHJhY2sucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZGV0YWNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHByZXZpb3VzbHkgYWRkZWQge0BsaW5rIFZpZGVvUHJvY2Vzc29yfSB1c2luZyBgYWRkUHJvY2Vzc29yYCBBUEkuXG4gICAgICogQHBhcmFtIHtWaWRlb1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIC0gVGhlIHtAbGluayBWaWRlb1Byb2Nlc3Nvcn0gdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2xhc3MgR3JheVNjYWxlUHJvY2Vzc29yIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHBlcmNlbnRhZ2UpIHtcbiAgICAgKiAgICAgdGhpcy5wZXJjZW50YWdlID0gcGVyY2VudGFnZTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIHByb2Nlc3NGcmFtZShpbnB1dEZyYW1lQnVmZmVyLCBvdXRwdXRGcmFtZUJ1ZmZlcikge1xuICAgICAqICAgICBjb25zdCBjb250ZXh0ID0gb3V0cHV0RnJhbWVCdWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgKiAgICAgY29udGV4dC5maWx0ZXIgPSBgZ3JheXNjYWxlKCR7dGhpcy5wZXJjZW50YWdlfSUpYDtcbiAgICAgKiAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW5wdXRGcmFtZUJ1ZmZlciwgMCwgMCwgaW5wdXRGcmFtZUJ1ZmZlci53aWR0aCwgaW5wdXRGcmFtZUJ1ZmZlci5oZWlnaHQpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFZpZGVvLmNyZWF0ZUxvY2FsVmlkZW9UcmFjaygpLnRoZW4oZnVuY3Rpb24odmlkZW9UcmFjaykge1xuICAgICAqICAgY29uc3QgZ3JheVNjYWxlUHJvY2Vzc29yID0gbmV3IEdyYXlTY2FsZVByb2Nlc3NvcigxMDApO1xuICAgICAqICAgdmlkZW9UcmFjay5hZGRQcm9jZXNzb3IoZ3JheVNjYWxlUHJvY2Vzc29yKTtcbiAgICAgKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZW1vdmUtYnV0dG9uJykub25jbGljayA9ICgpID0+IHZpZGVvVHJhY2sucmVtb3ZlUHJvY2Vzc29yKGdyYXlTY2FsZVByb2Nlc3Nvcik7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgVmlkZW9UcmFjay5wcm90b3R5cGUucmVtb3ZlUHJvY2Vzc29yID0gZnVuY3Rpb24gKHByb2Nlc3Nvcikge1xuICAgICAgICBpZiAoIXByb2Nlc3Nvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWNlaXZlZCBhbiBpbnZhbGlkIFZpZGVvUHJvY2Vzc29yIGZyb20gcmVtb3ZlUHJvY2Vzc29yLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXhpc3RpbmcgVmlkZW9Qcm9jZXNzb3IgZGV0ZWN0ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3NvciAhPT0gdGhpcy5wcm9jZXNzb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIFZpZGVvUHJvY2Vzc29yIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBleGlzdGluZyBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvY2Vzc29yRXZlbnRPYnNlcnZlci5lbWl0KCdyZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdSZW1vdmluZyBWaWRlb1Byb2Nlc3NvciBmcm9tIHRoZSBWaWRlb1RyYWNrJywgcHJvY2Vzc29yKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2NhcHR1cmVUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5fdW5tdXRlSGFuZGxlcik7XG4gICAgICAgIHRoaXMuX3VubXV0ZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9pc0NhcHR1cmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkVHJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbnB1dEZyYW1lLmdldENvbnRleHQoJzJkJykuY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2lucHV0RnJhbWUud2lkdGgsIHRoaXMuX2lucHV0RnJhbWUuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fb3V0cHV0RnJhbWUuZ2V0Q29udGV4dCgnMmQnKS5jbGVhclJlY3QoMCwgMCwgdGhpcy5fb3V0cHV0RnJhbWUud2lkdGgsIHRoaXMuX291dHB1dEZyYW1lLmhlaWdodCk7XG4gICAgICAgIHRoaXMuX2lucHV0RnJhbWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9vdXRwdXRGcmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUVsZW1lbnRzTWVkaWFTdHJlYW1UcmFjaygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBWaWRlb1RyYWNrO1xufShNZWRpYVRyYWNrKSk7XG5WaWRlb1RyYWNrLkRJTUVOU0lPTlNfQ0hBTkdFRCA9ICdkaW1lbnNpb25zQ2hhbmdlZCc7XG5mdW5jdGlvbiBkaW1lbnNpb25zQ2hhbmdlZCh0cmFjaywgZWxlbSkge1xuICAgIHJldHVybiB0cmFjay5kaW1lbnNpb25zLndpZHRoICE9PSBlbGVtLnZpZGVvV2lkdGhcbiAgICAgICAgfHwgdHJhY2suZGltZW5zaW9ucy5oZWlnaHQgIT09IGVsZW0udmlkZW9IZWlnaHQ7XG59XG4vKipcbiAqIEEge0BsaW5rIFZpZGVvVHJhY2t9J3Mgd2lkdGggYW5kIGhlaWdodC5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IFZpZGVvVHJhY2suRGltZW5zaW9uc1xuICogQHByb3BlcnR5IHs/bnVtYmVyfSB3aWR0aCAtIFRoZSB7QGxpbmsgVmlkZW9UcmFja30ncyB3aWR0aCBvciBudWxsIGlmIHRoZVxuICogICB7QGxpbmsgVmlkZW9UcmFja30gaGFzIG5vdCB5ZXQgc3RhcnRlZFxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBoZWlnaHQgLSBUaGUge0BsaW5rIFZpZGVvVHJhY2t9J3MgaGVpZ2h0IG9yIG51bGwgaWYgdGhlXG4gKiAgIHtAbGluayBWaWRlb1RyYWNrfSBoYXMgbm90IHlldCBzdGFydGVkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgVmlkZW9Qcm9jZXNzb3J9LCB3aGVuIGFkZGVkIHZpYSB7QGxpbmsgVmlkZW9UcmFjayNhZGRQcm9jZXNzb3J9LFxuICogaXMgdXNlZCB0byBwcm9jZXNzIGluY29taW5nIHZpZGVvIGZyYW1lcyBiZWZvcmVcbiAqIHNlbmRpbmcgdG8gdGhlIGVuY29kZXIgb3IgcmVuZGVyZXIuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBWaWRlb1Byb2Nlc3NvclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcHJvY2Vzc0ZyYW1lIC0gQSBjYWxsYmFjayB0byByZWNlaXZlIGlucHV0IGFuZCBvdXRwdXQgZnJhbWUgYnVmZmVycyBmb3IgcHJvY2Vzc2luZy5cbiAqIFRoZSBpbnB1dCBmcmFtZSBidWZmZXIgY29udGFpbnMgdGhlIG9yaWdpbmFsIHZpZGVvIGZyYW1lIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBhZGRpdGlvbmFsIHByb2Nlc3NpbmdcbiAqIHN1Y2ggYXMgYXBwbHlpbmcgZmlsdGVycyB0byBpdC4gVGhlIG91dHB1dCBmcmFtZSBidWZmZXIgaXMgdXNlZCB0byByZWNlaXZlIHRoZSBwcm9jZXNzZWQgdmlkZW8gZnJhbWVcbiAqIGJlZm9yZSBzZW5kaW5nIHRvIHRoZSBlbmNvZGVyIG9yIHJlbmRlcmVyLlxuICpcbiAqIEFueSBleGNlcHRpb24gcmFpc2VkIChlaXRoZXIgc3luY2hyb25vdXNseSBvciBhc3luY2hyb25vdXNseSkgaW4gYHByb2Nlc3NGcmFtZWAgd2lsbCByZXN1bHQgaW4gdGhlIGZyYW1lIGJlaW5nIGRyb3BwZWQuXG4gKiBUaGlzIGNhbGxiYWNrIGhhcyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTo8YnIvPjxici8+XG4gKiA8Y29kZT5wcm9jZXNzRnJhbWUoPC9jb2RlPjxici8+XG4gKiAmbmJzcDsmbmJzcDs8Y29kZT5pbnB1dEZyYW1lQnVmZmVyOiBPZmZzY3JlZW5DYW52YXMsPC9jb2RlPjxici8+XG4gKiAmbmJzcDsmbmJzcDs8Y29kZT5vdXRwdXRGcmFtZUJ1ZmZlcjogSFRNTENhbnZhc0VsZW1lbnQ8L2NvZGU+PGJyLz5cbiAqIDxjb2RlPik6IFByb21pc2UmbHQ7dm9pZCZndDsgfCB2b2lkOzwvY29kZT5cbiAqXG4gKiBAZXhhbXBsZVxuICogY2xhc3MgR3JheVNjYWxlUHJvY2Vzc29yIHtcbiAqICAgY29uc3RydWN0b3IocGVyY2VudGFnZSkge1xuICogICAgIHRoaXMucGVyY2VudGFnZSA9IHBlcmNlbnRhZ2U7XG4gKiAgIH1cbiAqICAgcHJvY2Vzc0ZyYW1lKGlucHV0RnJhbWVCdWZmZXIsIG91dHB1dEZyYW1lQnVmZmVyKSB7XG4gKiAgICAgY29uc3QgY29udGV4dCA9IG91dHB1dEZyYW1lQnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gKiAgICAgY29udGV4dC5maWx0ZXIgPSBgZ3JheXNjYWxlKCR7dGhpcy5wZXJjZW50YWdlfSUpYDtcbiAqICAgICBjb250ZXh0LmRyYXdJbWFnZShpbnB1dEZyYW1lQnVmZmVyLCAwLCAwLCBpbnB1dEZyYW1lQnVmZmVyLndpZHRoLCBpbnB1dEZyYW1lQnVmZmVyLmhlaWdodCk7XG4gKiAgIH1cbiAqIH1cbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFZpZGVvVHJhY2t9J3MgZGltZW5zaW9ucyBjaGFuZ2VkLlxuICogQHBhcmFtIHtWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgVmlkZW9UcmFja30gd2hvc2UgZGltZW5zaW9ucyBjaGFuZ2VkXG4gKiBAZXZlbnQgVmlkZW9UcmFjayNkaW1lbnNpb25zQ2hhbmdlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgVmlkZW9UcmFja30gd2FzIGRpc2FibGVkLCBpLmUuIFwicGF1c2VkXCIuXG4gKiBAcGFyYW0ge1ZpZGVvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBWaWRlb1RyYWNrfSB0aGF0IHdhcyBkaXNhYmxlZFxuICogQGV2ZW50IFZpZGVvVHJhY2sjZGlzYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFZpZGVvVHJhY2t9IHdhcyBlbmFibGVkLCBpLmUuIFwidW5wYXVzZWRcIi5cbiAqIEBwYXJhbSB7VmlkZW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFZpZGVvVHJhY2t9IHRoYXQgd2FzIGVuYWJsZWRcbiAqIEBldmVudCBWaWRlb1RyYWNrI2VuYWJsZWRcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIFZpZGVvVHJhY2t9IHN0YXJ0ZWQuIFRoaXMgbWVhbnMgdGhlcmUgaXMgZW5vdWdoIHZpZGVvIGRhdGEgdG9cbiAqIGJlZ2luIHBsYXliYWNrLlxuICogQHBhcmFtIHtWaWRlb1RyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgVmlkZW9UcmFja30gdGhhdCBzdGFydGVkXG4gKiBAZXZlbnQgVmlkZW9UcmFjayNzdGFydGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlkZW9UcmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZGVvdHJhY2suanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgX2EgPSByZXF1aXJlKCcuL3V0aWwvY29uc3RhbnRzJyksIERFRkFVTFRfTlFfTEVWRUxfTE9DQUwgPSBfYS5ERUZBVUxUX05RX0xFVkVMX0xPQ0FMLCBERUZBVUxUX05RX0xFVkVMX1JFTU9URSA9IF9hLkRFRkFVTFRfTlFfTEVWRUxfUkVNT1RFLCBNQVhfTlFfTEVWRUwgPSBfYS5NQVhfTlFfTEVWRUw7XG52YXIgaW5SYW5nZSA9IHJlcXVpcmUoJy4vdXRpbCcpLmluUmFuZ2U7XG4vKipcbiAqIHtAbGluayBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25JbXBsfSByZXByZXNlbnRzIGFuIG9iamVjdCB3aGljaCBub3RpZmllcyBpdHNcbiAqIGxpc3RlbmVycyBvZiBhbnkgY2hhbmdlcyBpbiB0aGUgdmFsdWVzIG9mIGl0cyBwcm9wZXJ0aWVzLlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAaW1wbGVtZW50cyBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25cbiAqIEBwcm9wZXJ0eSB7P05ldHdvcmtRdWFsaXR5VmVyYm9zaXR5fSBsb2NhbCAtIFZlcmJvc2l0eSBsZXZlbCBmb3Ige0BsaW5rIExvY2FsUGFydGljaXBhbnR9XG4gKiBAcHJvcGVydHkgez9OZXR3b3JrUXVhbGl0eVZlcmJvc2l0eX0gcmVtb3RlIC0gVmVyYm9zaXR5IGxldmVsIGZvciB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9c1xuICovXG52YXIgTmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uSW1wbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4ge0BsaW5rIE5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbkltcGx9LlxuICAgICAqIEBwYXJhbSB7TmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9ufSBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24gLSBJbml0aWFsIHtAbGluayBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb259XG4gICAgICovXG4gICAgZnVuY3Rpb24gTmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uSW1wbChuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBsb2NhbDogREVGQVVMVF9OUV9MRVZFTF9MT0NBTCxcbiAgICAgICAgICAgIHJlbW90ZTogREVGQVVMVF9OUV9MRVZFTF9SRU1PVEVcbiAgICAgICAgfSwgbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIGxvY2FsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGluUmFuZ2UobmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uLmxvY2FsLCBERUZBVUxUX05RX0xFVkVMX0xPQ0FMLCBNQVhfTlFfTEVWRUwpXG4gICAgICAgICAgICAgICAgICAgID8gbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uLmxvY2FsXG4gICAgICAgICAgICAgICAgICAgIDogREVGQVVMVF9OUV9MRVZFTF9MT0NBTCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpblJhbmdlKG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbi5yZW1vdGUsIERFRkFVTFRfTlFfTEVWRUxfUkVNT1RFLCBNQVhfTlFfTEVWRUwpXG4gICAgICAgICAgICAgICAgICAgID8gbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uLnJlbW90ZVxuICAgICAgICAgICAgICAgICAgICA6IERFRkFVTFRfTlFfTEVWRUxfUkVNT1RFLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdmVyYm9zaXR5IGxldmVscyBmb3IgbmV0d29yayBxdWFsaXR5IGluZm9ybWF0aW9uIGZvclxuICAgICAqIHtAbGluayBMb2NhbFBhcnRpY2lwYW50fSBhbmQge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB3aXRoIHRob3NlXG4gICAgICogaW4gdGhlIGdpdmVuIHtAbGluayBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb259LlxuICAgICAqIEBwYXJhbSB7TmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9ufSBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24gLSBUaGUgbmV3IHtAbGluayBOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb259XG4gICAgICovXG4gICAgTmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uSW1wbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGxvY2FsOiB0aGlzLmxvY2FsLFxuICAgICAgICAgICAgcmVtb3RlOiB0aGlzLnJlbW90ZVxuICAgICAgICB9LCBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBbXG4gICAgICAgICAgICBbJ2xvY2FsJywgREVGQVVMVF9OUV9MRVZFTF9MT0NBTCwgM10sXG4gICAgICAgICAgICBbJ3JlbW90ZScsIERFRkFVTFRfTlFfTEVWRUxfUkVNT1RFLCAzXVxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDMpLCBsb2NhbE9yUmVtb3RlID0gX2JbMF0sIG1pbiA9IF9iWzFdLCBtYXggPSBfYlsyXTtcbiAgICAgICAgICAgIF90aGlzW2xvY2FsT3JSZW1vdGVdID0gdHlwZW9mIG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbltsb2NhbE9yUmVtb3RlXSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAmJiBpblJhbmdlKG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbltsb2NhbE9yUmVtb3RlXSwgbWluLCBtYXgpXG4gICAgICAgICAgICAgICAgPyBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25bbG9jYWxPclJlbW90ZV1cbiAgICAgICAgICAgICAgICA6IG1pbjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uSW1wbDtcbn0oRXZlbnRFbWl0dGVyKSk7XG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbkltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrcXVhbGl0eWNvbmZpZ3VyYXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xuICAgIHJldHVybiB0bztcbn07XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9ldmVudGVtaXR0ZXInKTtcbnZhciBSZW1vdGVBdWRpb1RyYWNrID0gcmVxdWlyZSgnLi9tZWRpYS90cmFjay9yZW1vdGVhdWRpb3RyYWNrJyk7XG52YXIgUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uID0gcmVxdWlyZSgnLi9tZWRpYS90cmFjay9yZW1vdGVhdWRpb3RyYWNrcHVibGljYXRpb24nKTtcbnZhciBSZW1vdGVEYXRhVHJhY2sgPSByZXF1aXJlKCcuL21lZGlhL3RyYWNrL3JlbW90ZWRhdGF0cmFjaycpO1xudmFyIFJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uID0gcmVxdWlyZSgnLi9tZWRpYS90cmFjay9yZW1vdGVkYXRhdHJhY2twdWJsaWNhdGlvbicpO1xudmFyIFJlbW90ZVZpZGVvVHJhY2sgPSByZXF1aXJlKCcuL21lZGlhL3RyYWNrL3JlbW90ZXZpZGVvdHJhY2snKTtcbnZhciBSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb24gPSByZXF1aXJlKCcuL21lZGlhL3RyYWNrL3JlbW90ZXZpZGVvdHJhY2twdWJsaWNhdGlvbicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBuSW5zdGFuY2VzID0gMDtcbi8qKlxuICoge0BsaW5rIE5ldHdvcmtRdWFsaXR5TGV2ZWx9IGlzIGEgdmFsdWUgZnJvbSAw4oCTNSwgaW5jbHVzaXZlLCByZXByZXNlbnRpbmcgdGhlXG4gKiBxdWFsaXR5IG9mIGEgbmV0d29yayBjb25uZWN0aW9uLlxuICogQHR5cGVkZWYge251bWJlcn0gTmV0d29ya1F1YWxpdHlMZXZlbFxuICovXG4vKipcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQHByb3BlcnR5IHtNYXA8VHJhY2suU0lELCBBdWRpb1RyYWNrUHVibGljYXRpb24+fSBhdWRpb1RyYWNrcyAtXG4gKiAgICBUaGUge0BsaW5rIFBhcnRpY2lwYW50fSdzIHtAbGluayBBdWRpb1RyYWNrUHVibGljYXRpb259c1xuICogQHByb3BlcnR5IHtNYXA8VHJhY2suU0lELCBEYXRhVHJhY2tQdWJsaWNhdGlvbj59IGRhdGFUcmFja3MgLVxuICogICAgVGhlIHtAbGluayBQYXJ0aWNpcGFudH0ncyB7QGxpbmsgRGF0YVRyYWNrUHVibGljYXRpb259cy5cbiAqIEBwcm9wZXJ0eSB7UGFydGljaXBhbnQuSWRlbnRpdHl9IGlkZW50aXR5IC0gVGhlIGlkZW50aXR5IG9mIHRoZSB7QGxpbmsgUGFydGljaXBhbnR9XG4gKiBAcHJvcGVydHkgez9OZXR3b3JrUXVhbGl0eUxldmVsfSBuZXR3b3JrUXVhbGl0eUxldmVsIC0gVGhlXG4gKiAgICB7QGxpbmsgUGFydGljaXBhbnR9J3MgY3VycmVudCB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0sIGlmIGFueVxuICogQHByb3BlcnR5IHs/TmV0d29ya1F1YWxpdHlTdGF0c30gbmV0d29ya1F1YWxpdHlTdGF0cyAtIFRoZVxuICogICAge0BsaW5rIFBhcnRpY2lwYW50fSdzIGN1cnJlbnQge0BsaW5rIE5ldHdvcmtRdWFsaXR5U3RhdHN9LCBpZiBhbnlcbiAqIEBwcm9wZXJ0eSB7UGFydGljaXBhbnQuU0lEfSBzaWQgLSBUaGUge0BsaW5rIFBhcnRpY2lwYW50fSdzIFNJRFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gXCJjb25uZWN0ZWRcIiwgXCJkaXNjb25uZWN0ZWRcIiBvciBcInJlY29ubmVjdGluZ1wiXG4gKiBAcHJvcGVydHkge01hcDxUcmFjay5TSUQsIFRyYWNrUHVibGljYXRpb24+fSB0cmFja3MgLVxuICogICAgVGhlIHtAbGluayBQYXJ0aWNpcGFudH0ncyB7QGxpbmsgVHJhY2tQdWJsaWNhdGlvbn1zXG4gKiBAcHJvcGVydHkge01hcDxUcmFjay5TSUQsIFZpZGVvVHJhY2tQdWJsaWNhdGlvbj59IHZpZGVvVHJhY2tzIC1cbiAqICAgIFRoZSB7QGxpbmsgUGFydGljaXBhbnR9J3Mge0BsaW5rIFZpZGVvVHJhY2tQdWJsaWNhdGlvbn1zXG4gKiBAZW1pdHMgUGFydGljaXBhbnQjZGlzY29ubmVjdGVkXG4gKiBAZW1pdHMgUGFydGljaXBhbnQjbmV0d29ya1F1YWxpdHlMZXZlbENoYW5nZWRcbiAqIEBlbWl0cyBQYXJ0aWNpcGFudCNyZWNvbm5lY3RlZFxuICogQGVtaXRzIFBhcnRpY2lwYW50I3JlY29ubmVjdGluZ1xuICogQGVtaXRzIFBhcnRpY2lwYW50I3RyYWNrRGltZW5zaW9uc0NoYW5nZWRcbiAqIEBlbWl0cyBQYXJ0aWNpcGFudCN0cmFja1N0YXJ0ZWRcbiAqL1xudmFyIFBhcnRpY2lwYW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYXJ0aWNpcGFudCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUGFydGljaXBhbnR9LlxuICAgICAqIEBwYXJhbSB7UGFydGljaXBhbnRTaWduYWxpbmd9IHNpZ25hbGluZ1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXJ0aWNpcGFudChzaWduYWxpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgUmVtb3RlQXVkaW9UcmFjazogUmVtb3RlQXVkaW9UcmFjayxcbiAgICAgICAgICAgIFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbjogUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uLFxuICAgICAgICAgICAgUmVtb3RlRGF0YVRyYWNrOiBSZW1vdGVEYXRhVHJhY2ssXG4gICAgICAgICAgICBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbjogUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb24sXG4gICAgICAgICAgICBSZW1vdGVWaWRlb1RyYWNrOiBSZW1vdGVWaWRlb1RyYWNrLFxuICAgICAgICAgICAgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uOiBSZW1vdGVWaWRlb1RyYWNrUHVibGljYXRpb24sXG4gICAgICAgICAgICB0cmFja3M6IFtdXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgaW5kZXhlZCA9IGluZGV4VHJhY2tzQnlJZChvcHRpb25zLnRyYWNrcyk7XG4gICAgICAgIHZhciBsb2cgPSBvcHRpb25zLmxvZy5jcmVhdGVMb2coJ2RlZmF1bHQnLCBfdGhpcyk7XG4gICAgICAgIHZhciBhdWRpb1RyYWNrcyA9IG5ldyBNYXAoaW5kZXhlZC5hdWRpb1RyYWNrcyk7XG4gICAgICAgIHZhciBkYXRhVHJhY2tzID0gbmV3IE1hcChpbmRleGVkLmRhdGFUcmFja3MpO1xuICAgICAgICB2YXIgdHJhY2tzID0gbmV3IE1hcChpbmRleGVkLnRyYWNrcyk7XG4gICAgICAgIHZhciB2aWRlb1RyYWNrcyA9IG5ldyBNYXAoaW5kZXhlZC52aWRlb1RyYWNrcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfUmVtb3RlQXVkaW9UcmFjazoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLlJlbW90ZUF1ZGlvVHJhY2tcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuUmVtb3RlQXVkaW9UcmFja1B1YmxpY2F0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX1JlbW90ZURhdGFUcmFjazoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLlJlbW90ZURhdGFUcmFja1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9SZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLlJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX1JlbW90ZVZpZGVvVHJhY2s6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5SZW1vdGVWaWRlb1RyYWNrXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX1JlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLlJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hdWRpb1RyYWNrczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBhdWRpb1RyYWNrc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kYXRhVHJhY2tzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFUcmFja3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW5zdGFuY2VJZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiArK25JbnN0YW5jZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jb250ZW50UHJlZmVyZW5jZXNNb2RlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuY29udGVudFByZWZlcmVuY2VzTW9kZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9nOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGxvZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2lnbmFsaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RyYWNrczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0cmFja3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdHJhY2tFdmVudFJlZW1pdHRlcnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RyYWNrUHVibGljYXRpb25FdmVudFJlZW1pdHRlcnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RyYWNrU2lnbmFsaW5nVXBkYXRlZEV2ZW50Q2FsbGJhY2tzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF92aWRlb1RyYWNrczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2aWRlb1RyYWNrc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF1ZGlvVHJhY2tzOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YVRyYWNrczoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkZW50aXR5OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hbGluZy5pZGVudGl0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV0d29ya1F1YWxpdHlMZXZlbDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYWxpbmcubmV0d29ya1F1YWxpdHlMZXZlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV0d29ya1F1YWxpdHlTdGF0czoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYWxpbmcubmV0d29ya1F1YWxpdHlTdGF0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hbGluZy5zaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hbGluZy5zdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2tzOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlkZW9UcmFja3M6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLl90cmFja3MuZm9yRWFjaChyZWVtaXRUcmFja0V2ZW50cy5iaW5kKG51bGwsIF90aGlzKSk7XG4gICAgICAgIHNpZ25hbGluZy5vbignbmV0d29ya1F1YWxpdHlMZXZlbENoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnbmV0d29ya1F1YWxpdHlMZXZlbENoYW5nZWQnLCBfdGhpcy5uZXR3b3JrUXVhbGl0eUxldmVsLCBfdGhpcy5uZXR3b3JrUXVhbGl0eVN0YXRzICYmXG4gICAgICAgICAgICAgICAgKF90aGlzLm5ldHdvcmtRdWFsaXR5U3RhdHMuYXVkaW8gfHwgX3RoaXMubmV0d29ya1F1YWxpdHlTdGF0cy52aWRlbylcbiAgICAgICAgICAgICAgICA/IF90aGlzLm5ldHdvcmtRdWFsaXR5U3RhdHNcbiAgICAgICAgICAgICAgICA6IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVlbWl0U2lnbmFsaW5nU3RhdGVDaGFuZ2VkRXZlbnRzKF90aGlzLCBzaWduYWxpbmcpO1xuICAgICAgICBsb2cuaW5mbyhcIkNyZWF0ZWQgYSBuZXcgUGFydGljaXBhbnRcIiArIChfdGhpcy5pZGVudGl0eSA/IFwiOiBcIiArIF90aGlzLmlkZW50aXR5IDogJycpKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHtAbGluayBSZW1vdGVUcmFja30gZXZlbnRzIHRvIHJlLWVtaXQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8c3RyaW5nPj59IGV2ZW50c1xuICAgICAqL1xuICAgIFBhcnRpY2lwYW50LnByb3RvdHlwZS5fZ2V0VHJhY2tFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbJ2RpbWVuc2lvbnNDaGFuZ2VkJywgJ3RyYWNrRGltZW5zaW9uc0NoYW5nZWQnXSxcbiAgICAgICAgICAgIFsnbWVzc2FnZScsICd0cmFja01lc3NhZ2UnXSxcbiAgICAgICAgICAgIFsnc3RhcnRlZCcsICd0cmFja1N0YXJ0ZWQnXVxuICAgICAgICBdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQYXJ0aWNpcGFudC5wcm90b3R5cGUuX2dldFRyYWNrUHVibGljYXRpb25FdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIFBhcnRpY2lwYW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW1BhcnRpY2lwYW50ICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyBcIjogXCIgKyB0aGlzLnNpZCArIFwiXVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1JlbW90ZVRyYWNrfSB0cmFja1xuICAgICAqIEBwYXJhbSB7VHJhY2suSUR9IGlkXG4gICAgICogQHJldHVybnMgez9SZW1vdGVUcmFja31cbiAgICAgKi9cbiAgICBQYXJ0aWNpcGFudC5wcm90b3R5cGUuX2FkZFRyYWNrID0gZnVuY3Rpb24gKHRyYWNrLCBpZCkge1xuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBpZiAodGhpcy5fdHJhY2tzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYWNrcy5zZXQoaWQsIHRyYWNrKTtcbiAgICAgICAgdmFyIHRyYWNrc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiB0aGlzLl9hdWRpb1RyYWNrcyxcbiAgICAgICAgICAgIHZpZGVvOiB0aGlzLl92aWRlb1RyYWNrcyxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuX2RhdGFUcmFja3NcbiAgICAgICAgfVt0cmFjay5raW5kXTtcbiAgICAgICAgdHJhY2tzQnlLaW5kLnNldChpZCwgdHJhY2spO1xuICAgICAgICByZWVtaXRUcmFja0V2ZW50cyh0aGlzLCB0cmFjaywgaWQpO1xuICAgICAgICBsb2cuaW5mbyhcIkFkZGVkIGEgbmV3IFwiICsgdXRpbC50cmFja0NsYXNzKHRyYWNrKSArIFwiOlwiLCBpZCk7XG4gICAgICAgIGxvZy5kZWJ1Zyh1dGlsLnRyYWNrQ2xhc3ModHJhY2spICsgXCI6XCIsIHRyYWNrKTtcbiAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uXG4gICAgICogQHJldHVybnMgez9SZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICAgICAqL1xuICAgIFBhcnRpY2lwYW50LnByb3RvdHlwZS5fYWRkVHJhY2tQdWJsaWNhdGlvbiA9IGZ1bmN0aW9uIChwdWJsaWNhdGlvbikge1xuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBpZiAodGhpcy50cmFja3MuaGFzKHB1YmxpY2F0aW9uLnRyYWNrU2lkKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja3Muc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIHZhciB0cmFja1B1YmxpY2F0aW9uc0J5S2luZCA9IHtcbiAgICAgICAgICAgIGF1ZGlvOiB0aGlzLmF1ZGlvVHJhY2tzLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhVHJhY2tzLFxuICAgICAgICAgICAgdmlkZW86IHRoaXMudmlkZW9UcmFja3NcbiAgICAgICAgfVtwdWJsaWNhdGlvbi5raW5kXTtcbiAgICAgICAgdHJhY2tQdWJsaWNhdGlvbnNCeUtpbmQuc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIHJlZW1pdFRyYWNrUHVibGljYXRpb25FdmVudHModGhpcywgcHVibGljYXRpb24pO1xuICAgICAgICBsb2cuaW5mbyhcIkFkZGVkIGEgbmV3IFwiICsgdXRpbC50cmFja1B1YmxpY2F0aW9uQ2xhc3MocHVibGljYXRpb24pICsgXCI6XCIsIHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgbG9nLmRlYnVnKHV0aWwudHJhY2tQdWJsaWNhdGlvbkNsYXNzKHB1YmxpY2F0aW9uKSArIFwiOlwiLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUGFydGljaXBhbnQucHJvdG90eXBlLl9oYW5kbGVUcmFja1NpZ25hbGluZ0V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgbG9nID0gX2EuX2xvZywgY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sID0gX2EuX2NsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCwgY29udGVudFByZWZlcmVuY2VzTW9kZSA9IF9hLl9jb250ZW50UHJlZmVyZW5jZXNNb2RlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBSZW1vdGVBdWRpb1RyYWNrID0gdGhpcy5fUmVtb3RlQXVkaW9UcmFjaztcbiAgICAgICAgdmFyIFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbiA9IHRoaXMuX1JlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbjtcbiAgICAgICAgdmFyIFJlbW90ZVZpZGVvVHJhY2sgPSB0aGlzLl9SZW1vdGVWaWRlb1RyYWNrO1xuICAgICAgICB2YXIgUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uID0gdGhpcy5fUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uO1xuICAgICAgICB2YXIgUmVtb3RlRGF0YVRyYWNrID0gdGhpcy5fUmVtb3RlRGF0YVRyYWNrO1xuICAgICAgICB2YXIgUmVtb3RlRGF0YVRyYWNrUHVibGljYXRpb24gPSB0aGlzLl9SZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbjtcbiAgICAgICAgdmFyIHBhcnRpY2lwYW50U2lnbmFsaW5nID0gdGhpcy5fc2lnbmFsaW5nO1xuICAgICAgICBmdW5jdGlvbiB0cmFja1NpZ25hbGluZ0FkZGVkKHNpZ25hbGluZykge1xuICAgICAgICAgICAgdmFyIFJlbW90ZVRyYWNrUHVibGljYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgYXVkaW86IFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbixcbiAgICAgICAgICAgICAgICBkYXRhOiBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbixcbiAgICAgICAgICAgICAgICB2aWRlbzogUmVtb3RlVmlkZW9UcmFja1B1YmxpY2F0aW9uXG4gICAgICAgICAgICB9W3NpZ25hbGluZy5raW5kXTtcbiAgICAgICAgICAgIHZhciBwdWJsaWNhdGlvbiA9IG5ldyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKHNpZ25hbGluZywgeyBsb2c6IGxvZyB9KTtcbiAgICAgICAgICAgIHNlbGYuX2FkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuICAgICAgICAgICAgdmFyIGlzU3Vic2NyaWJlZCA9IHNpZ25hbGluZy5pc1N1YnNjcmliZWQ7XG4gICAgICAgICAgICBpZiAoaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tTaWduYWxpbmdTdWJzY3JpYmVkKHNpZ25hbGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl90cmFja1NpZ25hbGluZ1VwZGF0ZWRFdmVudENhbGxiYWNrcy5zZXQoc2lnbmFsaW5nLnNpZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1N1YnNjcmliZWQgIT09IHNpZ25hbGluZy5pc1N1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNTdWJzY3JpYmVkID0gc2lnbmFsaW5nLmlzU3Vic2NyaWJlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tTaWduYWxpbmdTdWJzY3JpYmVkKHNpZ25hbGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJhY2tTaWduYWxpbmdVbnN1YnNjcmliZWQoc2lnbmFsaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNpZ25hbGluZy5vbigndXBkYXRlZCcsIHNlbGYuX3RyYWNrU2lnbmFsaW5nVXBkYXRlZEV2ZW50Q2FsbGJhY2tzLmdldChzaWduYWxpbmcuc2lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJhY2tTaWduYWxpbmdSZW1vdmVkKHNpZ25hbGluZykge1xuICAgICAgICAgICAgaWYgKHNpZ25hbGluZy5pc1N1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICBzaWduYWxpbmcuc2V0VHJhY2tUcmFuc2NlaXZlcihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1cGRhdGVkID0gc2VsZi5fdHJhY2tTaWduYWxpbmdVcGRhdGVkRXZlbnRDYWxsYmFja3MuZ2V0KHNpZ25hbGluZy5zaWQpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBzaWduYWxpbmcucmVtb3ZlTGlzdGVuZXIoJ3VwZGF0ZWQnLCB1cGRhdGVkKTtcbiAgICAgICAgICAgICAgICBzZWxmLl90cmFja1NpZ25hbGluZ1VwZGF0ZWRFdmVudENhbGxiYWNrcy5kZWxldGUoc2lnbmFsaW5nLnNpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHVibGljYXRpb24gPSBzZWxmLnRyYWNrcy5nZXQoc2lnbmFsaW5nLnNpZCk7XG4gICAgICAgICAgICBpZiAocHVibGljYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9yZW1vdmVUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0cmFja1NpZ25hbGluZ1N1YnNjcmliZWQoc2lnbmFsaW5nKSB7XG4gICAgICAgICAgICB2YXIgaXNFbmFibGVkID0gc2lnbmFsaW5nLmlzRW5hYmxlZCwgbmFtZSA9IHNpZ25hbGluZy5uYW1lLCBraW5kID0gc2lnbmFsaW5nLmtpbmQsIHNpZCA9IHNpZ25hbGluZy5zaWQsIHRyYWNrVHJhbnNjZWl2ZXIgPSBzaWduYWxpbmcudHJhY2tUcmFuc2NlaXZlciwgaXNTd2l0Y2hlZE9mZiA9IHNpZ25hbGluZy5pc1N3aXRjaGVkT2ZmO1xuICAgICAgICAgICAgdmFyIFJlbW90ZVRyYWNrID0ge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBSZW1vdGVBdWRpb1RyYWNrLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBSZW1vdGVWaWRlb1RyYWNrLFxuICAgICAgICAgICAgICAgIGRhdGE6IFJlbW90ZURhdGFUcmFja1xuICAgICAgICAgICAgfVtraW5kXTtcbiAgICAgICAgICAgIHZhciBwdWJsaWNhdGlvbiA9IHNlbGYudHJhY2tzLmdldChzaWQpO1xuICAgICAgICAgICAgLy8gTk9URShtcm9iZXJ0cyk6IEl0IHNob3VsZCBuZXZlciBiZSB0aGUgY2FzZSB0aGF0IHRoZSBUcmFja1NpZ25hbGluZyBhbmRcbiAgICAgICAgICAgIC8vIE1lZGlhU3RyZWFtVHJhY2sgb3IgRGF0YVRyYWNrUmVjZWl2ZXIga2luZHMgZGlzYWdyZWU7IGhvd2V2ZXIsIGp1c3QgaW5cbiAgICAgICAgICAgIC8vIGNhc2UsIHdlIGhhbmRsZSBpdCBoZXJlLlxuICAgICAgICAgICAgaWYgKCFSZW1vdGVUcmFjayB8fCBraW5kICE9PSB0cmFja1RyYW5zY2VpdmVyLmtpbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHsgbG9nOiBsb2csIG5hbWU6IG5hbWUsIGNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbDogY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sLCBjb250ZW50UHJlZmVyZW5jZXNNb2RlOiBjb250ZW50UHJlZmVyZW5jZXNNb2RlIH07XG4gICAgICAgICAgICB2YXIgc2V0UHJpb3JpdHkgPSBmdW5jdGlvbiAobmV3UHJpb3JpdHkpIHsgcmV0dXJuIHBhcnRpY2lwYW50U2lnbmFsaW5nLnVwZGF0ZVN1YnNjcmliZXJUcmFja1ByaW9yaXR5KHNpZCwgbmV3UHJpb3JpdHkpOyB9O1xuICAgICAgICAgICAgdmFyIHNldFJlbmRlckhpbnQgPSBmdW5jdGlvbiAocmVuZGVySGludCkge1xuICAgICAgICAgICAgICAgIGlmIChzaWduYWxpbmcuaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50U2lnbmFsaW5nLnVwZGF0ZVRyYWNrUmVuZGVySGludChzaWQsIHJlbmRlckhpbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSBraW5kID09PSAnZGF0YSdcbiAgICAgICAgICAgICAgICA/IG5ldyBSZW1vdGVUcmFjayhzaWQsIHRyYWNrVHJhbnNjZWl2ZXIsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgOiBuZXcgUmVtb3RlVHJhY2soc2lkLCB0cmFja1RyYW5zY2VpdmVyLCBpc0VuYWJsZWQsIGlzU3dpdGNoZWRPZmYsIHNldFByaW9yaXR5LCBzZXRSZW5kZXJIaW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHNlbGYuX2FkZFRyYWNrKHRyYWNrLCBwdWJsaWNhdGlvbiwgdHJhY2tUcmFuc2NlaXZlci5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJhY2tTaWduYWxpbmdVbnN1YnNjcmliZWQoc2lnbmFsaW5nKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoQXJyYXkuZnJvbShzZWxmLl90cmFja3MuZW50cmllcygpKS5maW5kKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHRyYWNrID0gX2JbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNrLnNpZCA9PT0gc2lnbmFsaW5nLnNpZDtcbiAgICAgICAgICAgIH0pLCAyKSwgaWQgPSBfYVswXSwgdHJhY2sgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBwdWJsaWNhdGlvbiA9IHNlbGYudHJhY2tzLmdldChzaWduYWxpbmcuc2lkKTtcbiAgICAgICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgICAgIHNlbGYuX3JlbW92ZVRyYWNrKHRyYWNrLCBwdWJsaWNhdGlvbiwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcnRpY2lwYW50U2lnbmFsaW5nLm9uKCd0cmFja0FkZGVkJywgdHJhY2tTaWduYWxpbmdBZGRlZCk7XG4gICAgICAgIHBhcnRpY2lwYW50U2lnbmFsaW5nLm9uKCd0cmFja1JlbW92ZWQnLCB0cmFja1NpZ25hbGluZ1JlbW92ZWQpO1xuICAgICAgICBwYXJ0aWNpcGFudFNpZ25hbGluZy50cmFja3MuZm9yRWFjaCh0cmFja1NpZ25hbGluZ0FkZGVkKTtcbiAgICAgICAgcGFydGljaXBhbnRTaWduYWxpbmcub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZygnUmVtb3ZpbmcgZXZlbnQgbGlzdGVuZXJzJyk7XG4gICAgICAgICAgICAgICAgcGFydGljaXBhbnRTaWduYWxpbmcucmVtb3ZlTGlzdGVuZXIoJ3N0YXRlQ2hhbmdlZCcsIHN0YXRlQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgcGFydGljaXBhbnRTaWduYWxpbmcucmVtb3ZlTGlzdGVuZXIoJ3RyYWNrQWRkZWQnLCB0cmFja1NpZ25hbGluZ0FkZGVkKTtcbiAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudFNpZ25hbGluZy5yZW1vdmVMaXN0ZW5lcigndHJhY2tSZW1vdmVkJywgdHJhY2tTaWduYWxpbmdSZW1vdmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IEFueSB0cmFuc2l0aW9uIHRvIFwiY29ubmVjdGVkXCIgaGVyZSBpcyBhIHJlc3VsdCBvZlxuICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgc2lnbmFsaW5nIHJlY29ubmVjdGlvbiwgYW5kIG5vdCBhIGZpcnN0LXRpbWUgZXN0YWJsaXNobWVudFxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBzaWduYWxpbmcgY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICBsb2cuaW5mbygncmVjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogYHN0YXRlQ2hhbmdlZGAgY2FuIGdldCBlbWl0dGVkIHdpdGggU3RhdGVNYWNoaW5lIGxvY2tlZC5cbiAgICAgICAgICAgICAgICAvLyBEbyBub3Qgc2lnbmFsICBwdWJsaWMgZXZlbnRzIHN5bmNocm9ub3VzbHkgd2l0aCBsb2NrIGhlbGQuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmVtaXQoJ3JlY29ubmVjdGVkJyk7IH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja30gdHJhY2tcbiAgICAgKiBAcGFyYW0ge1RyYWNrLklEfSBpZFxuICAgICAqIEByZXR1cm5zIHs/UmVtb3RlVHJhY2t9XG4gICAgICovXG4gICAgUGFydGljaXBhbnQucHJvdG90eXBlLl9yZW1vdmVUcmFjayA9IGZ1bmN0aW9uICh0cmFjaywgaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFja3MuaGFzKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhY2tzLmRlbGV0ZShpZCk7XG4gICAgICAgIHZhciB0cmFja3NCeUtpbmQgPSB7XG4gICAgICAgICAgICBhdWRpbzogdGhpcy5fYXVkaW9UcmFja3MsXG4gICAgICAgICAgICB2aWRlbzogdGhpcy5fdmlkZW9UcmFja3MsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLl9kYXRhVHJhY2tzXG4gICAgICAgIH1bdHJhY2sua2luZF07XG4gICAgICAgIHRyYWNrc0J5S2luZC5kZWxldGUoaWQpO1xuICAgICAgICB2YXIgcmVlbWl0dGVycyA9IHRoaXMuX3RyYWNrRXZlbnRSZWVtaXR0ZXJzLmdldChpZCkgfHwgbmV3IE1hcCgpO1xuICAgICAgICByZWVtaXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlZW1pdHRlciwgZXZlbnQpIHtcbiAgICAgICAgICAgIHRyYWNrLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCByZWVtaXR0ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxvZyA9IHRoaXMuX2xvZztcbiAgICAgICAgbG9nLmluZm8oXCJSZW1vdmVkIGEgXCIgKyB1dGlsLnRyYWNrQ2xhc3ModHJhY2spICsgXCI6XCIsIGlkKTtcbiAgICAgICAgbG9nLmRlYnVnKHV0aWwudHJhY2tDbGFzcyh0cmFjaykgKyBcIjpcIiwgdHJhY2spO1xuICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb25cbiAgICAgKiBAcmV0dXJucyB7P1JlbW90ZVRyYWNrUHVibGljYXRpb259XG4gICAgICovXG4gICAgUGFydGljaXBhbnQucHJvdG90eXBlLl9yZW1vdmVUcmFja1B1YmxpY2F0aW9uID0gZnVuY3Rpb24gKHB1YmxpY2F0aW9uKSB7XG4gICAgICAgIHB1YmxpY2F0aW9uID0gdGhpcy50cmFja3MuZ2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgaWYgKCFwdWJsaWNhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja3MuZGVsZXRlKHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgdmFyIHRyYWNrUHVibGljYXRpb25zQnlLaW5kID0ge1xuICAgICAgICAgICAgYXVkaW86IHRoaXMuYXVkaW9UcmFja3MsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGFUcmFja3MsXG4gICAgICAgICAgICB2aWRlbzogdGhpcy52aWRlb1RyYWNrc1xuICAgICAgICB9W3B1YmxpY2F0aW9uLmtpbmRdO1xuICAgICAgICB0cmFja1B1YmxpY2F0aW9uc0J5S2luZC5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgICAgICB2YXIgcmVlbWl0dGVycyA9IHRoaXMuX3RyYWNrUHVibGljYXRpb25FdmVudFJlZW1pdHRlcnMuZ2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkKSB8fCBuZXcgTWFwKCk7XG4gICAgICAgIHJlZW1pdHRlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVlbWl0dGVyLCBldmVudCkge1xuICAgICAgICAgICAgcHVibGljYXRpb24ucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIHJlZW1pdHRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBsb2cuaW5mbyhcIlJlbW92ZWQgYSBcIiArIHV0aWwudHJhY2tQdWJsaWNhdGlvbkNsYXNzKHB1YmxpY2F0aW9uKSArIFwiOlwiLCBwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICAgIGxvZy5kZWJ1Zyh1dGlsLnRyYWNrUHVibGljYXRpb25DbGFzcyhwdWJsaWNhdGlvbikgKyBcIjpcIiwgcHVibGljYXRpb24pO1xuICAgICAgICByZXR1cm4gcHVibGljYXRpb247XG4gICAgfTtcbiAgICBQYXJ0aWNpcGFudC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXRpbC52YWx1ZVRvSlNPTih0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJ0aWNpcGFudDtcbn0oRXZlbnRFbWl0dGVyKSk7XG4vKipcbiAqIEEge0BsaW5rIFBhcnRpY2lwYW50LlNJRH0gaXMgYSAzNC1jaGFyYWN0ZXIgc3RyaW5nIHN0YXJ0aW5nIHdpdGggXCJQQVwiXG4gKiB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgYSB7QGxpbmsgUGFydGljaXBhbnR9LlxuICogQHR5cGUgc3RyaW5nXG4gKiBAdHlwZWRlZiBQYXJ0aWNpcGFudC5TSURcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBQYXJ0aWNpcGFudC5JZGVudGl0eX0gaXMgYSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGFcbiAqIHtAbGluayBQYXJ0aWNpcGFudH0uIFlvdSBjYW4gdGhpbmsgb2YgaXQgbGlrZSBhIG5hbWUuXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBQYXJ0aWNpcGFudC5JZGVudGl0eVxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUGFydGljaXBhbnR9IGhhcyBkaXNjb25uZWN0ZWQuXG4gKiBAcGFyYW0ge1BhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUGFydGljaXBhbnR9IHRoYXQgZGlzY29ubmVjdGVkLlxuICogQGV2ZW50IFBhcnRpY2lwYW50I2Rpc2Nvbm5lY3RlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUGFydGljaXBhbnR9J3Mge0BsaW5rIE5ldHdvcmtRdWFsaXR5TGV2ZWx9IGNoYW5nZWQuXG4gKiBAcGFyYW0ge05ldHdvcmtRdWFsaXR5TGV2ZWx9IG5ldHdvcmtRdWFsaXR5TGV2ZWwgLSBUaGUgbmV3XG4gKiAgIHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfVxuICogQHBhcmFtIHs/TmV0d29ya1F1YWxpdHlTdGF0c30gbmV0d29ya1F1YWxpdHlTdGF0cyAtIFRoZSB7QGxpbmsgTmV0d29ya1F1YWxpdHlTdGF0c31cbiAqICAgYmFzZWQgb24gd2hpY2gge0BsaW5rIE5ldHdvcmtRdWFsaXR5TGV2ZWx9IGlzIGNhbGN1bGF0ZWQsIGlmIGFueVxuICogQGV2ZW50IFBhcnRpY2lwYW50I25ldHdvcmtRdWFsaXR5TGV2ZWxDaGFuZ2VkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBQYXJ0aWNpcGFudH0gaGFzIHJlY29ubmVjdGVkIHRvIHRoZSB7QGxpbmsgUm9vbX0gYWZ0ZXIgYSBzaWduYWxpbmcgY29ubmVjdGlvbiBkaXNydXB0aW9uLlxuICogQGV2ZW50IFBhcnRpY2lwYW50I3JlY29ubmVjdGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBQYXJ0aWNpcGFudH0gaXMgcmVjb25uZWN0aW5nIHRvIHRoZSB7QGxpbmsgUm9vbX0gYWZ0ZXIgYSBzaWduYWxpbmcgY29ubmVjdGlvbiBkaXNydXB0aW9uLlxuICogQGV2ZW50IFBhcnRpY2lwYW50I3JlY29ubmVjdGluZ1xuICovXG4vKipcbiAqIE9uZSBvZiB0aGUge0BsaW5rIFBhcnRpY2lwYW50fSdzIHtAbGluayBWaWRlb1RyYWNrfSdzIGRpbWVuc2lvbnMgY2hhbmdlZC5cbiAqIEBwYXJhbSB7VmlkZW9UcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFZpZGVvVHJhY2t9IHdob3NlIGRpbWVuc2lvbnMgY2hhbmdlZFxuICogQGV2ZW50IFBhcnRpY2lwYW50I3RyYWNrRGltZW5zaW9uc0NoYW5nZWRcbiAqL1xuLyoqXG4gKiBPbmUgb2YgdGhlIHtAbGluayBQYXJ0aWNpcGFudH0ncyB7QGxpbmsgVHJhY2t9cyBzdGFydGVkLlxuICogQHBhcmFtIHtUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFRyYWNrfSB0aGF0IHN0YXJ0ZWRcbiAqIEBldmVudCBQYXJ0aWNpcGFudCN0cmFja1N0YXJ0ZWRcbiAqL1xuLyoqXG4gKiBJbmRleGVkIHtAbGluayBUcmFja31zIGJ5IHtAbGluayBUcmFjay5JRH0uXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBJbmRleGVkVHJhY2tzXG4gKiBAcHJvcGVydHkge0FycmF5PHswOiBUcmFjay5JRCwgMTogQXVkaW9UcmFja30+fSBhdWRpb1RyYWNrcyAtIEluZGV4ZWRcbiAqICAge0BsaW5rIEF1ZGlvVHJhY2t9c1xuICogQHByb3BlcnR5IHtBcnJheTx7MDogVHJhY2suSUQsIDE6IERhdGFUcmFja30+fSBkYXRhVHJhY2tzIC0gSW5kZXhlZFxuICogICB7QGxpbmsgRGF0YVRyYWNrfXNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8ezA6IFRyYWNrLklELCAxOiBUcmFja30+fSB0cmFja3MgLSBJbmRleGVkIHtAbGluayBUcmFja31zXG4gKiBAcHJvcGVydHkge0FycmF5PHswOiBUcmFjay5JRCwgMTogVmlkZW9UcmFja30+fSB2aWRlb1RyYWNrcyAtIEluZGV4ZWRcbiAqICAge0BsaW5rIFZpZGVvVHJhY2t9c1xuICogQHByaXZhdGVcbiAqL1xuLyoqXG4gKiBJbmRleCB0cmFja3MgYnkge0BsaW5rIFRyYWNrLklEfS5cbiAqIEBwYXJhbSB7QXJyYXk8VHJhY2s+fSB0cmFja3NcbiAqIEByZXR1cm5zIHtJbmRleGVkVHJhY2tzfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5kZXhUcmFja3NCeUlkKHRyYWNrcykge1xuICAgIHZhciBpbmRleGVkVHJhY2tzID0gdHJhY2tzLm1hcChmdW5jdGlvbiAodHJhY2spIHsgcmV0dXJuIFt0cmFjay5pZCwgdHJhY2tdOyB9KTtcbiAgICB2YXIgaW5kZXhlZEF1ZGlvVHJhY2tzID0gaW5kZXhlZFRyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKGtleVZhbHVlKSB7IHJldHVybiBrZXlWYWx1ZVsxXS5raW5kID09PSAnYXVkaW8nOyB9KTtcbiAgICB2YXIgaW5kZXhlZFZpZGVvVHJhY2tzID0gaW5kZXhlZFRyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKGtleVZhbHVlKSB7IHJldHVybiBrZXlWYWx1ZVsxXS5raW5kID09PSAndmlkZW8nOyB9KTtcbiAgICB2YXIgaW5kZXhlZERhdGFUcmFja3MgPSBpbmRleGVkVHJhY2tzLmZpbHRlcihmdW5jdGlvbiAoa2V5VmFsdWUpIHsgcmV0dXJuIGtleVZhbHVlWzFdLmtpbmQgPT09ICdkYXRhJzsgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXVkaW9UcmFja3M6IGluZGV4ZWRBdWRpb1RyYWNrcyxcbiAgICAgICAgZGF0YVRyYWNrczogaW5kZXhlZERhdGFUcmFja3MsXG4gICAgICAgIHRyYWNrczogaW5kZXhlZFRyYWNrcyxcbiAgICAgICAgdmlkZW9UcmFja3M6IGluZGV4ZWRWaWRlb1RyYWNrc1xuICAgIH07XG59XG4vKipcbiAqIFJlLWVtaXQge0BsaW5rIFBhcnRpY2lwYW50U2lnbmFsaW5nfSAnc3RhdGVDaGFuZ2VkJyBldmVudHMuXG4gKiBAcGFyYW0ge1BhcnRpY2lwYW50fSBwYXJ0aWNpcGFudFxuICogQHBhcmFtIHtQYXJ0aWNpcGFudFNpZ25hbGluZ30gc2lnbmFsaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWVtaXRTaWduYWxpbmdTdGF0ZUNoYW5nZWRFdmVudHMocGFydGljaXBhbnQsIHNpZ25hbGluZykge1xuICAgIHZhciBsb2cgPSBwYXJ0aWNpcGFudC5fbG9nO1xuICAgIGlmIChwYXJ0aWNpcGFudC5zdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZWVtaXQgc3RhdGUgdHJhbnNpdGlvbiBldmVudHMgZnJvbSB0aGUgUGFydGljaXBhbnRTaWduYWxpbmcuXG4gICAgc2lnbmFsaW5nLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBzdGF0ZUNoYW5nZWQoc3RhdGUpIHtcbiAgICAgICAgbG9nLmRlYnVnKCdUcmFuc2l0aW9uZWQgdG8gc3RhdGU6Jywgc3RhdGUpO1xuICAgICAgICBwYXJ0aWNpcGFudC5lbWl0KHN0YXRlLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZygnUmVtb3ZpbmcgVHJhY2sgZXZlbnQgcmVlbWl0dGVycycpO1xuICAgICAgICAgICAgc2lnbmFsaW5nLnJlbW92ZUxpc3RlbmVyKCdzdGF0ZUNoYW5nZWQnLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgICAgcGFydGljaXBhbnQuX3RyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgIHZhciByZWVtaXR0ZXJzID0gcGFydGljaXBhbnQuX3RyYWNrRXZlbnRSZWVtaXR0ZXJzLmdldCh0cmFjay5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrICYmIHJlZW1pdHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVlbWl0dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZWVtaXR0ZXIsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5yZW1vdmVMaXN0ZW5lcihldmVudCwgcmVlbWl0dGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8td2FybmluZy1jb21tZW50c1xuICAgICAgICAgICAgLy8gVE9ETyhqb21hKTogUmVtb3ZpbmcgdGhpcyBpbnRyb2R1Y2VkIHVuaXQgdGVzdCBmYWlsdXJlcyBpbiB0aGUgUmVtb3RlUGFydGljaXBhbnQuXG4gICAgICAgICAgICAvLyBJbnZlc3RpZ2F0ZSBmdXJ0aGVyIGJlZm9yZSByZW1vdmluZy5cbiAgICAgICAgICAgIHNpZ25hbGluZy50cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tTaWduYWxpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSBwYXJ0aWNpcGFudC5fdHJhY2tzLmdldCh0cmFja1NpZ25hbGluZy5pZCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZW1pdHRlcnMgPSBwYXJ0aWNpcGFudC5fdHJhY2tFdmVudFJlZW1pdHRlcnMuZ2V0KHRyYWNrU2lnbmFsaW5nLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2sgJiYgcmVlbWl0dGVycykge1xuICAgICAgICAgICAgICAgICAgICByZWVtaXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlZW1pdHRlciwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCByZWVtaXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcnRpY2lwYW50Ll90cmFja0V2ZW50UmVlbWl0dGVycy5jbGVhcigpO1xuICAgICAgICAgICAgcGFydGljaXBhbnQudHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHB1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgcGFydGljaXBhbnQuX3RyYWNrUHVibGljYXRpb25FdmVudFJlZW1pdHRlcnMuZ2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAocmVlbWl0dGVyLCBldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwdWJsaWNhdGlvbi5yZW1vdmVMaXN0ZW5lcihldmVudCwgcmVlbWl0dGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFydGljaXBhbnQuX3RyYWNrUHVibGljYXRpb25FdmVudFJlZW1pdHRlcnMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBSZS1lbWl0IHtAbGluayBUcmFja30gZXZlbnRzLlxuICogQHBhcmFtIHtQYXJ0aWNpcGFudH0gcGFydGljaXBhbnRcbiAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrXG4gKiBAcGFyYW0ge1RyYWNrLklEfSBpZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVlbWl0VHJhY2tFdmVudHMocGFydGljaXBhbnQsIHRyYWNrLCBpZCkge1xuICAgIHZhciB0cmFja0V2ZW50UmVlbWl0dGVycyA9IG5ldyBNYXAoKTtcbiAgICBpZiAocGFydGljaXBhbnQuc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFydGljaXBhbnQuX2dldFRyYWNrRXZlbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRQYWlyKSB7XG4gICAgICAgIHZhciB0cmFja0V2ZW50ID0gZXZlbnRQYWlyWzBdO1xuICAgICAgICB2YXIgcGFydGljaXBhbnRFdmVudCA9IGV2ZW50UGFpclsxXTtcbiAgICAgICAgdHJhY2tFdmVudFJlZW1pdHRlcnMuc2V0KHRyYWNrRXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW3BhcnRpY2lwYW50RXZlbnRdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRpY2lwYW50LmVtaXQuYXBwbHkocGFydGljaXBhbnQsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhY2sub24odHJhY2tFdmVudCwgdHJhY2tFdmVudFJlZW1pdHRlcnMuZ2V0KHRyYWNrRXZlbnQpKTtcbiAgICB9KTtcbiAgICBwYXJ0aWNpcGFudC5fdHJhY2tFdmVudFJlZW1pdHRlcnMuc2V0KGlkLCB0cmFja0V2ZW50UmVlbWl0dGVycyk7XG59XG4vKipcbiAqIFJlLWVtaXQge0BsaW5rIFRyYWNrUHVibGljYXRpb259IGV2ZW50cy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BhcnRpY2lwYW50fSBwYXJ0aWNpcGFudFxuICogQHBhcmFtIHtUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvblxuICovXG5mdW5jdGlvbiByZWVtaXRUcmFja1B1YmxpY2F0aW9uRXZlbnRzKHBhcnRpY2lwYW50LCBwdWJsaWNhdGlvbikge1xuICAgIHZhciBwdWJsaWNhdGlvbkV2ZW50UmVlbWl0dGVycyA9IG5ldyBNYXAoKTtcbiAgICBpZiAocGFydGljaXBhbnQuc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFydGljaXBhbnQuX2dldFRyYWNrUHVibGljYXRpb25FdmVudHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBwdWJsaWNhdGlvbkV2ZW50ID0gX2JbMF0sIHBhcnRpY2lwYW50RXZlbnQgPSBfYlsxXTtcbiAgICAgICAgcHVibGljYXRpb25FdmVudFJlZW1pdHRlcnMuc2V0KHB1YmxpY2F0aW9uRXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnRpY2lwYW50LmVtaXQuYXBwbHkocGFydGljaXBhbnQsIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbcGFydGljaXBhbnRFdmVudF0sIF9fcmVhZChhcmdzKSksIFtwdWJsaWNhdGlvbl0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHB1YmxpY2F0aW9uLm9uKHB1YmxpY2F0aW9uRXZlbnQsIHB1YmxpY2F0aW9uRXZlbnRSZWVtaXR0ZXJzLmdldChwdWJsaWNhdGlvbkV2ZW50KSk7XG4gICAgfSk7XG4gICAgcGFydGljaXBhbnQuX3RyYWNrUHVibGljYXRpb25FdmVudFJlZW1pdHRlcnMuc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbkV2ZW50UmVlbWl0dGVycyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2lwYW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFydGljaXBhbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRDb21iaW5lZENvbm5lY3Rpb25TdGF0cyA9IHZvaWQgMDtcbmZ1bmN0aW9uIGdldFN0YXRWYWx1ZXMocmVwb3J0LCBzdGF0TmFtZSwga2luZCwgcmVwb3J0VHlwZXMpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHJlcG9ydC5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0KSB7XG4gICAgICAgIGlmICgocmVwb3J0VHlwZXMubGVuZ3RoID09PSAwIHx8IHJlcG9ydFR5cGVzLmluY2x1ZGVzKHN0YXQudHlwZSkpICYmXG4gICAgICAgICAgICAoa2luZC5sZW5ndGggPT09IDAgfHwga2luZC5pbmNsdWRlcyhzdGF0LmtpbmQpKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHN0YXRbc3RhdE5hbWVdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHN0YXRbc3RhdE5hbWVdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xufVxuZnVuY3Rpb24gZ2V0Q29tYmluZWRDb25uZWN0aW9uU3RhdHMoX2EpIHtcbiAgICB2YXIgcHVibGlzaGVyID0gX2EucHVibGlzaGVyLCBzdWJzY3JpYmVyID0gX2Euc3Vic2NyaWJlcjtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYiwgcHVibGlzaGVyU3RhdHMsIHN1YnNjcmliZXJTdGF0cywgdGltZXN0YW1wcywgdGltZXN0YW1wLCBqaXR0ZXIsIHBhY2tldHMsIHBhY2tldHNMb3N0LCB0cmFja1JvdW5kVHJpcFRpbWUsIGN1cnJlbnRSb3VuZFRyaXBUaW1lLCByb3VuZFRyaXBUaW1lLCBieXRlc1NlbnQsIGJ5dGVzUmVjZWl2ZWQsIHNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzLCBpY2VDYW5kaWRhdGVTdGF0cztcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoW3B1Ymxpc2hlciwgc3Vic2NyaWJlcl0ubWFwKGZ1bmN0aW9uIChwYykgeyByZXR1cm4gcGMuZ2V0U3RhdHMoKTsgfSkpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9iID0gX19yZWFkLmFwcGx5KHZvaWQgMCwgW19jLnNlbnQoKSwgMl0pLCBwdWJsaXNoZXJTdGF0cyA9IF9iWzBdLCBzdWJzY3JpYmVyU3RhdHMgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wcyA9IGdldFN0YXRWYWx1ZXMoc3Vic2NyaWJlclN0YXRzLCAndGltZXN0YW1wJywgWydhdWRpbyddLCBbJ2luYm91bmQtcnRwJ10pO1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSB0aW1lc3RhbXBzLmxlbmd0aCA+IDAgPyB0aW1lc3RhbXBzWzBdIDogMDtcbiAgICAgICAgICAgICAgICAgICAgaml0dGVyID0gZ2V0U3RhdFZhbHVlcyhzdWJzY3JpYmVyU3RhdHMsICdqaXR0ZXInLCBbJ2F1ZGlvJ10sIFsnaW5ib3VuZC1ydHAnXSkucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBNYXRoLm1heChhLCBiKTsgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHBhY2tldHMgPSBnZXRTdGF0VmFsdWVzKHN1YnNjcmliZXJTdGF0cywgJ3BhY2tldHNSZWNlaXZlZCcsIFsnYXVkaW8nLCAndmlkZW8nXSwgWydpbmJvdW5kLXJ0cCddKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgKyBiOyB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcGFja2V0c0xvc3QgPSBnZXRTdGF0VmFsdWVzKHN1YnNjcmliZXJTdGF0cywgJ3BhY2tldHNMb3N0JywgWydhdWRpbycsICd2aWRlbyddLCBbJ2luYm91bmQtcnRwJ10pLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSArIGI7IH0sIDApO1xuICAgICAgICAgICAgICAgICAgICB0cmFja1JvdW5kVHJpcFRpbWUgPSBnZXRTdGF0VmFsdWVzKHB1Ymxpc2hlclN0YXRzLCAncm91bmRUcmlwVGltZScsIFsnYXVkaW8nLCAndmlkZW8nXSwgWydyZW1vdGUtaW5ib3VuZC1ydHAnXSkucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBNYXRoLm1heChhLCBiKTsgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb3VuZFRyaXBUaW1lID0gZ2V0U3RhdFZhbHVlcyhzdWJzY3JpYmVyU3RhdHMsICdjdXJyZW50Um91bmRUcmlwVGltZScsIFtdLCBbJ2NhbmRpZGF0ZS1wYWlyJ10pLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gTWF0aC5tYXgoYSwgYik7IH0sIDApO1xuICAgICAgICAgICAgICAgICAgICByb3VuZFRyaXBUaW1lID0gKGN1cnJlbnRSb3VuZFRyaXBUaW1lIHx8IHRyYWNrUm91bmRUcmlwVGltZSkgKiAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBieXRlc1NlbnQgPSBnZXRTdGF0VmFsdWVzKHB1Ymxpc2hlclN0YXRzLCAnYnl0ZXNTZW50JywgW10sIFsnY2FuZGlkYXRlLXBhaXInXSkucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgYjsgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQgPSBnZXRTdGF0VmFsdWVzKHN1YnNjcmliZXJTdGF0cywgJ2J5dGVzUmVjZWl2ZWQnLCBbXSwgWydjYW5kaWRhdGUtcGFpciddKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgKyBiOyB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHMgPSBleHRyYWN0U2VsZWN0ZWRBY3RpdmVDYW5kaWRhdGVQYWlyKHN1YnNjcmliZXJTdGF0cyk7XG4gICAgICAgICAgICAgICAgICAgIGljZUNhbmRpZGF0ZVN0YXRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJTdGF0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdC50eXBlID09PSAnbG9jYWwtY2FuZGlkYXRlJyB8fCBzdGF0LnR5cGUgPT09ICdyZW1vdGUtY2FuZGlkYXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljZUNhbmRpZGF0ZVN0YXRzLnB1c2gobWFrZVN0YW5kYXJkQ2FuZGlkYXRlU3RhdHMoc3RhdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgdGltZXN0YW1wOiB0aW1lc3RhbXAsIGppdHRlcjogaml0dGVyLCBwYWNrZXRzOiBwYWNrZXRzLCBwYWNrZXRzTG9zdDogcGFja2V0c0xvc3QsIHJvdW5kVHJpcFRpbWU6IHJvdW5kVHJpcFRpbWUsIGJ5dGVzU2VudDogYnl0ZXNTZW50LCBieXRlc1JlY2VpdmVkOiBieXRlc1JlY2VpdmVkLCBzZWxlY3RlZEljZUNhbmRpZGF0ZVBhaXJTdGF0czogc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHMsIGljZUNhbmRpZGF0ZVN0YXRzOiBpY2VDYW5kaWRhdGVTdGF0cyB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmdldENvbWJpbmVkQ29ubmVjdGlvblN0YXRzID0gZ2V0Q29tYmluZWRDb25uZWN0aW9uU3RhdHM7XG5mdW5jdGlvbiBtYWtlU3RhbmRhcmRDYW5kaWRhdGVTdGF0cyhpbnB1dCkge1xuICAgIHZhciBzdGFuZGFyZGl6ZWRDYW5kaWRhdGVTdGF0c0tleXMgPSBbXG4gICAgICAgIHsga2V5OiAndHJhbnNwb3J0SWQnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IGtleTogJ2NhbmRpZGF0ZVR5cGUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IGtleTogJ3BvcnQnLCBhbHRLZXlzOiBbJ3BvcnROdW1iZXInXSwgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBrZXk6ICdhZGRyZXNzJywgYWx0S2V5czogWydpcCcsICdpcEFkZHJlc3MnXSwgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgeyBrZXk6ICdwcmlvcml0eScsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsga2V5OiAncHJvdG9jb2wnLCBhbHRLZXlzOiBbJ3RyYW5zcG9ydCddLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IGtleTogJ3VybCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsga2V5OiAnZGVsZXRlZCcsIHR5cGU6ICdib29sZWFuJyB9LFxuICAgICAgICB7IGtleTogJ3JlbGF5UHJvdG9jb2wnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIHN0YW5kYXJkaXplZENhbmRpZGF0ZVN0YXRzS2V5cy5yZWR1Y2UoZnVuY3Rpb24gKHJlcG9ydCwga2V5SW5mbykge1xuICAgICAgICB2YXIga2V5c1RvTG9va0ZvciA9IFtrZXlJbmZvLmtleV07XG4gICAgICAgIGlmIChrZXlJbmZvLmFsdEtleXMpIHtcbiAgICAgICAgICAgIGtleXNUb0xvb2tGb3IgPSBrZXlzVG9Mb29rRm9yLmNvbmNhdChrZXlJbmZvLmFsdEtleXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBrZXlzVG9Mb29rRm9yLmZpbmQoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5IGluIGlucHV0OyB9KTtcbiAgICAgICAgaWYgKGtleSAmJiB0eXBlb2YgaW5wdXRba2V5XSA9PT0ga2V5SW5mby50eXBlKSB7XG4gICAgICAgICAgICByZXBvcnRba2V5SW5mby5rZXldID0gaW5wdXRba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVwb3J0O1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RTZWxlY3RlZEFjdGl2ZUNhbmRpZGF0ZVBhaXIoc3RhdHMpIHtcbiAgICB2YXIgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSBudWxsO1xuICAgIHZhciBjYW5kaWRhdGVQYWlycyA9IFtdO1xuICAgIHN0YXRzLmZvckVhY2goZnVuY3Rpb24gKHN0YXQpIHtcbiAgICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ3RyYW5zcG9ydCcgJiYgc3RhdC5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSBzdGF0LnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXQudHlwZSA9PT0gJ2NhbmRpZGF0ZS1wYWlyJykge1xuICAgICAgICAgICAgY2FuZGlkYXRlUGFpcnMucHVzaChzdGF0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHNGb3VuZCA9IGNhbmRpZGF0ZVBhaXJzLmZpbmQoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICByZXR1cm4gcGFpci5zZWxlY3RlZCB8fFxuICAgICAgICAgICAgLy8gU3BlYy1jb21wbGlhbnQgd2F5XG4gICAgICAgICAgICAoc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgJiYgcGFpci5pZCA9PT0gc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQpO1xuICAgIH0pO1xuICAgIGlmICghYWN0aXZlQ2FuZGlkYXRlUGFpclN0YXRzRm91bmQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHMgPSBhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHNGb3VuZDtcbiAgICB2YXIgYWN0aXZlTG9jYWxDYW5kaWRhdGVTdGF0cyA9IHN0YXRzLmdldChhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHMubG9jYWxDYW5kaWRhdGVJZCk7XG4gICAgdmFyIGFjdGl2ZVJlbW90ZUNhbmRpZGF0ZVN0YXRzID0gc3RhdHMuZ2V0KGFjdGl2ZUNhbmRpZGF0ZVBhaXJTdGF0cy5yZW1vdGVDYW5kaWRhdGVJZCk7XG4gICAgaWYgKCFhY3RpdmVMb2NhbENhbmRpZGF0ZVN0YXRzIHx8ICFhY3RpdmVSZW1vdGVDYW5kaWRhdGVTdGF0cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG9jYWxDYW5kaWRhdGU6IG1ha2VTdGFuZGFyZENhbmRpZGF0ZVN0YXRzKGFjdGl2ZUxvY2FsQ2FuZGlkYXRlU3RhdHMpLFxuICAgICAgICByZW1vdGVDYW5kaWRhdGU6IG1ha2VTdGFuZGFyZENhbmRpZGF0ZVN0YXRzKGFjdGl2ZVJlbW90ZUNhbmRpZGF0ZVN0YXRzKVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRDb21iaW5lZENvbm5lY3Rpb25TdGF0cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFR1cm5DcmVkZW50aWFscyA9IHZvaWQgMDtcbnZhciBUd2lsaW9Db25uZWN0aW9uID0gcmVxdWlyZSgnLi4vdHdpbGlvY29ubmVjdGlvbi5qcycpO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKSwgV1NfU0VSVkVSID0gX2EuV1NfU0VSVkVSLCBJQ0VfVkVSU0lPTiA9IF9hLklDRV9WRVJTSU9OO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmZ1bmN0aW9uIGdldFR1cm5DcmVkZW50aWFscyh0b2tlbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIG9wdGlvbnMgPSBfX2Fzc2lnbih7IGVudmlyb25tZW50OiAncHJvZCcsIHJlZ2lvbjogJ2dsbCcgfSwgb3B0aW9ucyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gICAgICAgIHZhciB3c1NlcnZlciA9IFdTX1NFUlZFUihvcHRpb25zLmVudmlyb25tZW50LCBvcHRpb25zLnJlZ2lvbik7XG4gICAgICAgIHZhciBldmVudE9ic2VydmVyID0gbmV3IGV2ZW50c18xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB2YXIgY29ubmVjdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZXR3b3JrTW9uaXRvcjogbnVsbCxcbiAgICAgICAgICAgIGV2ZW50T2JzZXJ2ZXI6IGV2ZW50T2JzZXJ2ZXIsXG4gICAgICAgICAgICBoZWxsb0JvZHk6IHtcbiAgICAgICAgICAgICAgICBlZGdlOiAncm9hbWluZycsXG4gICAgICAgICAgICAgICAgcHJlZmxpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHRva2VuOiB0b2tlbixcbiAgICAgICAgICAgICAgICB0eXBlOiAnaWNlJyxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBJQ0VfVkVSU0lPTlxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHR3aWxpb0Nvbm5lY3Rpb24gPSBuZXcgVHdpbGlvQ29ubmVjdGlvbih3c1NlcnZlciwgY29ubmVjdGlvbk9wdGlvbnMpO1xuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICB0d2lsaW9Db25uZWN0aW9uLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gICAgICAgIHR3aWxpb0Nvbm5lY3Rpb24ub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ2ljZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UuaWNlX3NlcnZlcnMpO1xuICAgICAgICAgICAgICAgICAgICB0d2lsaW9Db25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0VHVybkNyZWRlbnRpYWxzID0gZ2V0VHVybkNyZWRlbnRpYWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0dHVybmNyZWRlbnRpYWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgICAgICB0b1tqXSA9IGZyb21baV07XG4gICAgcmV0dXJuIHRvO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFrZVN0YXQgPSB2b2lkIDA7XG4vKipcbiAqIENvbXB1dGVzIG1pbiwgbWF4LCBhdmVyYWdlIGZvciBnaXZlbiBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdmFsdWVzXG4gKiBAcmV0dXJucyB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcjogYXZlcmFnZTogbnVtYmVyfXxudWxsfVxuICovXG5mdW5jdGlvbiBtYWtlU3RhdCh2YWx1ZXMpIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHZhbHVlcykpKTtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh2YWx1ZXMpKSk7XG4gICAgICAgIHZhciBhdmVyYWdlID0gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAodG90YWwsIHZhbHVlKSB7IHJldHVybiB0b3RhbCArIHZhbHVlOyB9LCAwKSAvIHZhbHVlcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7IG1pbjogbWluLCBtYXg6IG1heCwgYXZlcmFnZTogYXZlcmFnZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMubWFrZVN0YXQgPSBtYWtlU3RhdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2VzdGF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tb3NUb1Njb3JlID0gZXhwb3J0cy5jYWxjdWxhdGVNT1MgPSB2b2lkIDA7XG52YXIgcjAgPSA5NC43Njg7IC8vIENvbnN0YW50IHVzZWQgaW4gY29tcHV0aW5nIFwickZhY3RvclwiLlxuLy8gY29waWVkIGZyb20gaHR0cHM6Ly9jb2RlLmhxLnR3aWxpby5jb20vY2xpZW50L3Nkay1mcmQvYmxvYi9tYXN0ZXIvdm9pY2Uvdm9pY2UtbW9zLWNhbGN1bGF0aW9uLm1kXG5mdW5jdGlvbiBjYWxjdWxhdGVNT1MocnR0LCBqaXR0ZXIsIGZyYWN0aW9uTG9zdCkge1xuICAgIC8vIENvbXB1dGUgdGhlIGVmZmVjdGl2ZSBsYXRlbmN5LlxuICAgIHZhciBlZmZlY3RpdmVMYXRlbmN5ID0gcnR0ICsgKGppdHRlciAqIDIpICsgMTA7XG4gICAgLy8gQ29tcHV0ZSB0aGUgaW5pdGlhbCBcInJGYWN0b3JcIiBmcm9tIGVmZmVjdGl2ZSBsYXRlbmN5LlxuICAgIHZhciByRmFjdG9yID0gMDtcbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSBlZmZlY3RpdmVMYXRlbmN5IDwgMTYwOlxuICAgICAgICAgICAgckZhY3RvciA9IHIwIC0gKGVmZmVjdGl2ZUxhdGVuY3kgLyA0MCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBlZmZlY3RpdmVMYXRlbmN5IDwgMTAwMDpcbiAgICAgICAgICAgIHJGYWN0b3IgPSByMCAtICgoZWZmZWN0aXZlTGF0ZW5jeSAtIDEyMCkgLyAxMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gQWRqdXN0IFwickZhY3RvclwiIHdpdGggdGhlIGZyYWN0aW9uIG9mIHBhY2tldHMgbG9zdC5cbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSBmcmFjdGlvbkxvc3QgPD0gKHJGYWN0b3IgLyAyLjUpOlxuICAgICAgICAgICAgckZhY3RvciA9IE1hdGgubWF4KHJGYWN0b3IgLSBmcmFjdGlvbkxvc3QgKiAyLjUsIDYuNTIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByRmFjdG9yID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIE1PUyBmcm9tIFwickZhY3RvclwiLlxuICAgIHZhciBtb3MgPSAxICtcbiAgICAgICAgKDAuMDM1ICogckZhY3RvcikgK1xuICAgICAgICAoMC4wMDAwMDcgKiByRmFjdG9yKSAqXG4gICAgICAgICAgICAockZhY3RvciAtIDYwKSAqXG4gICAgICAgICAgICAoMTAwIC0gckZhY3Rvcik7XG4gICAgcmV0dXJuIG1vcztcbn1cbmV4cG9ydHMuY2FsY3VsYXRlTU9TID0gY2FsY3VsYXRlTU9TO1xuZnVuY3Rpb24gbW9zVG9TY29yZShtb3NWYWx1ZSkge1xuICAgIHZhciBzY29yZSA9IDA7XG4gICAgaWYgKCFtb3NWYWx1ZSkge1xuICAgICAgICBzY29yZSA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vc1ZhbHVlID4gNC4yKSB7XG4gICAgICAgIHNjb3JlID0gNTtcbiAgICB9XG4gICAgZWxzZSBpZiAobW9zVmFsdWUgPiA0LjApIHtcbiAgICAgICAgc2NvcmUgPSA0O1xuICAgIH1cbiAgICBlbHNlIGlmIChtb3NWYWx1ZSA+IDMuNikge1xuICAgICAgICBzY29yZSA9IDM7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vc1ZhbHVlID4gMykge1xuICAgICAgICBzY29yZSA9IDI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzY29yZSA9IDE7XG4gICAgfVxuICAgIHJldHVybiBzY29yZTtcbn1cbmV4cG9ydHMubW9zVG9TY29yZSA9IG1vc1RvU2NvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucnVuUHJlZmxpZ2h0ID0gZXhwb3J0cy5QcmVmbGlnaHRUZXN0ID0gdm9pZCAwO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL3V0aWwvY29uc3RhbnRzXCIpO1xudmFyIHRpbWVyXzEgPSByZXF1aXJlKFwiLi90aW1lclwiKTtcbnZhciBtb3NfMSA9IHJlcXVpcmUoXCIuL21vc1wiKTtcbnZhciBnZXRDb21iaW5lZENvbm5lY3Rpb25TdGF0c18xID0gcmVxdWlyZShcIi4vZ2V0Q29tYmluZWRDb25uZWN0aW9uU3RhdHNcIik7XG52YXIgZ2V0dHVybmNyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9nZXR0dXJuY3JlZGVudGlhbHNcIik7XG52YXIgbWFrZXN0YXRfMSA9IHJlcXVpcmUoXCIuL21ha2VzdGF0XCIpO1xudmFyIHN5bnRoZXRpY2F1ZGlvXzEgPSByZXF1aXJlKFwiLi9zeW50aGV0aWNhdWRpb1wiKTtcbnZhciBzeW50aGV0aWN2aWRlb18xID0gcmVxdWlyZShcIi4vc3ludGhldGljdmlkZW9cIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgTG9nID0gcmVxdWlyZSgnLi4vdXRpbC9sb2cnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuLi9ldmVudGVtaXR0ZXInKTtcbnZhciBNb3ZpbmdBdmVyYWdlRGVsdGEgPSByZXF1aXJlKCcuLi91dGlsL21vdmluZ2F2ZXJhZ2VkZWx0YScpO1xudmFyIFNFQ09ORCA9IDEwMDA7XG52YXIgREVGQVVMVF9URVNUX0RVUkFUSU9OID0gMTAgKiBTRUNPTkQ7XG4vKipcbiAqIHByb2dyZXNzIHZhbHVlcyB0aGF0IGFyZSBzZW50IGJ5IHtAbGluayBQcmVmbGlnaHRUZXN0I2V2ZW50OnByb2dyZXNzfVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIFByZWZsaWdodFByb2dyZXNzID0ge1xuICAgIC8qKlxuICAgICAqIHtAbGluayBQcmVmbGlnaHRUZXN0fSBoYXMgc3VjY2Vzc2Z1bGx5IGdlbmVyYXRlZCBzeW50aGV0aWMgdHJhY2tzXG4gICAgICovXG4gICAgbWVkaWFBY3F1aXJlZDogJ21lZGlhQWNxdWlyZWQnLFxuICAgIC8qKlxuICAgICAqIHtAbGluayBQcmVmbGlnaHRUZXN0fSBoYXMgc3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCB0byB0d2lsaW8gc2VydmVyIGFuZCBvYnRhaW5lZCB0dXJuIGNyZWRlbnRpYWxzXG4gICAgICovXG4gICAgY29ubmVjdGVkOiAnY29ubmVjdGVkJyxcbiAgICAvKipcbiAgICAgKiBzdWJzY3JpYmVyUGFydGljaXBhbnQgc3VjY2Vzc2Z1bGx5IHN1YnNjcmliZWQgdG8gbWVkaWEgdHJhY2tzLlxuICAgICAqL1xuICAgIG1lZGlhU3Vic2NyaWJlZDogJ21lZGlhU3Vic2NyaWJlZCcsXG4gICAgLyoqXG4gICAgICogbWVkaWEgZmxvdyB3YXMgZGV0ZWN0ZWQuXG4gICAgICovXG4gICAgbWVkaWFTdGFydGVkOiAnbWVkaWFTdGFydGVkJyxcbiAgICAvKipcbiAgICAgKiBlc3RhYmxpc2hlZCBEVExTIGNvbm5lY3Rpb24uIFRoaXMgaXMgbWVhc3VyZWQgZnJvbSBSVENEdGxzVHJhbnNwb3J0IGBjb25uZWN0aW5nYCB0byBgY29ubmVjdGVkYCBzdGF0ZS5cbiAgICAgKiBPbiBTYWZhcmksIFN1cHBvcnQgZm9yIG1lYXN1cmluZyB0aGlzIGlzIG1pc3NpbmcsIHRoaXMgZXZlbnQgd2lsbCBiZSBub3QgYmUgZW1pdHRlZCBvbiBTYWZhcmkuXG4gICAgICovXG4gICAgZHRsc0Nvbm5lY3RlZDogJ2R0bHNDb25uZWN0ZWQnLFxuICAgIC8qKlxuICAgICAqIGVzdGFibGlzaGVkIGEgUGVlckNvbm5lY3Rpb24sIFRoaXMgaXMgbWVhc3VyZWQgZnJvbSBQZWVyQ29ubmVjdGlvbiBgY29ubmVjdGluZ2AgdG8gYGNvbm5lY3RlZGAgc3RhdGUuXG4gICAgICogT24gRmlyZWZveCwgU3VwcG9ydCBmb3IgbWVhc3VyaW5nIHRoaXMgaXMgbWlzc2luZywgdGhpcyBldmVudCB3aWxsIGJlIG5vdCBiZSBlbWl0dGVkIG9uIEZpcmVmb3guXG4gICAgICovXG4gICAgcGVlckNvbm5lY3Rpb25Db25uZWN0ZWQ6ICdwZWVyQ29ubmVjdGlvbkNvbm5lY3RlZCcsXG4gICAgLyoqXG4gICAgICogZXN0YWJsaXNoZWQgSUNFIGNvbm5lY3Rpb24uIFRoaXMgaXMgbWVhc3VyZWQgZnJvbSBJQ0UgY29ubmVjdGlvbiBgY2hlY2tpbmdgIHRvIGBjb25uZWN0ZWRgIHN0YXRlLlxuICAgICAqL1xuICAgIGljZUNvbm5lY3RlZDogJ2ljZUNvbm5lY3RlZCdcbn07XG5mdW5jdGlvbiBub3RFbXB0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xufVxudmFyIG5JbnN0YW5jZXMgPSAwO1xuLyoqXG4gKiBBIHtAbGluayBQcmVmbGlnaHRUZXN0fSBtb25pdG9ycyBwcm9ncmVzcyBvZiBhbiBvbmdvaW5nIHByZWZsaWdodCB0ZXN0LlxuICogPGJyPjxicj5cbiAqIEluc3RhbmNlIG9mIHtAbGluayBQcmVmbGlnaHRUZXN0fSBpcyByZXR1cm5lZCBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6dHdpbGlvLXZpZGVvLnJ1blByZWZsaWdodH1cbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQGVtaXRzIFByZWZsaWdodFRlc3QjY29tcGxldGVkXG4gKiBAZW1pdHMgUHJlZmxpZ2h0VGVzdCNmYWlsZWRcbiAqIEBlbWl0cyBQcmVmbGlnaHRUZXN0I3Byb2dyZXNzXG4gKi9cbnZhciBQcmVmbGlnaHRUZXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmVmbGlnaHRUZXN0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMge0BsaW5rIFByZWZsaWdodFRlc3R9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuICAgICAqIEBwYXJhbSB7P1ByZWZsaWdodE9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByZWZsaWdodFRlc3QodG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3Rlc3RUaW1pbmcgPSBuZXcgdGltZXJfMS5UaW1lcigpO1xuICAgICAgICBfdGhpcy5fZHRsc1RpbWluZyA9IG5ldyB0aW1lcl8xLlRpbWVyKCk7XG4gICAgICAgIF90aGlzLl9pY2VUaW1pbmcgPSBuZXcgdGltZXJfMS5UaW1lcigpO1xuICAgICAgICBfdGhpcy5fcGVlckNvbm5lY3Rpb25UaW1pbmcgPSBuZXcgdGltZXJfMS5UaW1lcigpO1xuICAgICAgICBfdGhpcy5fbWVkaWFUaW1pbmcgPSBuZXcgdGltZXJfMS5UaW1lcigpO1xuICAgICAgICBfdGhpcy5fY29ubmVjdFRpbWluZyA9IG5ldyB0aW1lcl8xLlRpbWVyKCk7XG4gICAgICAgIF90aGlzLl9zZW50Qnl0ZXNNb3ZpbmdBdmVyYWdlID0gbmV3IE1vdmluZ0F2ZXJhZ2VEZWx0YSgpO1xuICAgICAgICBfdGhpcy5fcGFja2V0TG9zc01vdmluZ0F2ZXJhZ2UgPSBuZXcgTW92aW5nQXZlcmFnZURlbHRhKCk7XG4gICAgICAgIF90aGlzLl9yZWNlaXZlZEJ5dGVzTW92aW5nQXZlcmFnZSA9IG5ldyBNb3ZpbmdBdmVyYWdlRGVsdGEoKTtcbiAgICAgICAgX3RoaXMuX2xvZyA9IG5ldyBMb2coJ2RlZmF1bHQnLCBfdGhpcywgY29uc3RhbnRzXzEuREVGQVVMVF9MT0dfTEVWRUwsIGNvbnN0YW50c18xLkRFRkFVTFRfTE9HR0VSX05BTUUpO1xuICAgICAgICBfdGhpcy5fdGVzdER1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCBERUZBVUxUX1RFU1RfRFVSQVRJT047XG4gICAgICAgIF90aGlzLl9pbnN0YW5jZUlkID0gbkluc3RhbmNlcysrO1xuICAgICAgICBfdGhpcy5fdGVzdFRpbWluZy5zdGFydCgpO1xuICAgICAgICBfdGhpcy5fcnVuUHJlZmxpZ2h0VGVzdCh0b2tlbiwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUHJlZmxpZ2h0VGVzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltQcmVmbGlnaHQgI1wiICsgdGhpcy5faW5zdGFuY2VJZCArIFwiXVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc3RvcHMgb25nb2luZyB0ZXN0cyBhbmQgZW1pdHMgZXJyb3JcbiAgICAgKi9cbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFByZWZsaWdodFRlc3QucHJvdG90eXBlLl9nZW5lcmF0ZVByZWZsaWdodFJlcG9ydCA9IGZ1bmN0aW9uIChjb2xsZWN0ZWRTdGF0cykge1xuICAgICAgICB0aGlzLl90ZXN0VGltaW5nLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRlc3RUaW1pbmc6IHRoaXMuX3Rlc3RUaW1pbmcuZ2V0VGltZU1lYXN1cmVtZW50KCksXG4gICAgICAgICAgICBuZXR3b3JrVGltaW5nOiB7XG4gICAgICAgICAgICAgICAgZHRsczogdGhpcy5fZHRsc1RpbWluZy5nZXRUaW1lTWVhc3VyZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBpY2U6IHRoaXMuX2ljZVRpbWluZy5nZXRUaW1lTWVhc3VyZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBwZWVyQ29ubmVjdGlvbjogdGhpcy5fcGVlckNvbm5lY3Rpb25UaW1pbmcuZ2V0VGltZU1lYXN1cmVtZW50KCksXG4gICAgICAgICAgICAgICAgY29ubmVjdDogdGhpcy5fY29ubmVjdFRpbWluZy5nZXRUaW1lTWVhc3VyZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBtZWRpYTogdGhpcy5fbWVkaWFUaW1pbmcuZ2V0VGltZU1lYXN1cmVtZW50KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgICAgIGppdHRlcjogbWFrZXN0YXRfMS5tYWtlU3RhdChjb2xsZWN0ZWRTdGF0cy5qaXR0ZXIpLFxuICAgICAgICAgICAgICAgIHJ0dDogbWFrZXN0YXRfMS5tYWtlU3RhdChjb2xsZWN0ZWRTdGF0cy5ydHQpLFxuICAgICAgICAgICAgICAgIHBhY2tldExvc3M6IG1ha2VzdGF0XzEubWFrZVN0YXQoY29sbGVjdGVkU3RhdHMucGFja2V0TG9zcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHM6IGNvbGxlY3RlZFN0YXRzLnNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzLFxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlU3RhdHM6IGNvbGxlY3RlZFN0YXRzLmljZUNhbmRpZGF0ZVN0YXRzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5fZXhlY3V0ZVByZWZsaWdodFN0ZXAgPSBmdW5jdGlvbiAoc3RlcE5hbWUsIHN0ZXApIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIE1BWF9TVEVQX0RVUkFUSU9OLCBzdGVwUHJvbWlzZSwgdGltZXIsIHRpbWVvdXRQcm9taXNlLCByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0V4ZWN1dGluZyBzdGVwOiAnLCBzdGVwTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBNQVhfU1RFUF9EVVJBVElPTiA9IHRoaXMuX3Rlc3REdXJhdGlvbiArIDEwICogU0VDT05EO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0b3BwZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKF9yZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGltZWQgb3V0IHdhaXRpbmcgZm9yIDogXCIgKyBzdGVwTmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIE1BWF9TVEVQX0RVUkFUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsICwgMywgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yYWNlKFt0aW1lb3V0UHJvbWlzZSwgc3RlcFByb21pc2VdKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUHJlZmxpZ2h0VGVzdC5wcm90b3R5cGUuX3RyYWNrTmV0d29ya1RpbWluZ3MgPSBmdW5jdGlvbiAocGMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2NoZWNraW5nJykge1xuICAgICAgICAgICAgICAgIF90aGlzLl9pY2VUaW1pbmcuc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2ljZVRpbWluZy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncHJvZ3Jlc3MnLCBQcmVmbGlnaHRQcm9ncmVzcy5pY2VDb25uZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZmlyZWZveCBkb2VzIG5vdCBzdXBwb3J0IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZS5cbiAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBjLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3BlZXJDb25uZWN0aW9uVGltaW5nLnN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGMuY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIF90aGlzLl9wZWVyQ29ubmVjdGlvblRpbWluZy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncHJvZ3Jlc3MnLCBQcmVmbGlnaHRQcm9ncmVzcy5wZWVyQ29ubmVjdGlvbkNvbm5lY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTYWZhcmkgZG9lcyBub3QgZXhwb3NlIHNlbmRlci50cmFuc3BvcnQuXG4gICAgICAgIHZhciBzZW5kZXJzID0gcGMuZ2V0U2VuZGVycygpO1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gc2VuZGVycy5tYXAoZnVuY3Rpb24gKHNlbmRlcikgeyByZXR1cm4gc2VuZGVyLnRyYW5zcG9ydDsgfSkuZmluZChub3RFbXB0eSk7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNwb3J0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIGR0bHNUcmFuc3BvcnRfMSA9IHRyYW5zcG9ydDtcbiAgICAgICAgICAgIGR0bHNUcmFuc3BvcnRfMS5hZGRFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHRsc1RyYW5zcG9ydF8xLnN0YXRlID09PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2R0bHNUaW1pbmcuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGR0bHNUcmFuc3BvcnRfMS5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2R0bHNUaW1pbmcuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdwcm9ncmVzcycsIFByZWZsaWdodFByb2dyZXNzLmR0bHNDb25uZWN0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5fcnVuUHJlZmxpZ2h0VGVzdCA9IGZ1bmN0aW9uICh0b2tlbiwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxUcmFja3MsIHBjcywgZWxlbWVudHNfMSwgaWNlU2VydmVycywgc2VuZGVyUENfMSwgcmVjZWl2ZXJQQ18xLCByZW1vdGVUcmFja3NfMSwgY29sbGVjdGVkU3RhdHNfMSwgcmVwb3J0LCBlcnJvcl8xO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBwY3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCA4LCA5LCAxMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNfMSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZXhlY3V0ZVByZWZsaWdodFN0ZXAoJ0FjcXVpcmUgbWVkaWEnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBbc3ludGhldGljYXVkaW9fMS5zeW50aGV0aWNBdWRpbygpLCBzeW50aGV0aWN2aWRlb18xLnN5bnRoZXRpY1ZpZGVvKHsgd2lkdGg6IDY0MCwgaGVpZ2h0OiA0ODAgfSldOyB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIFByZWZsaWdodFByb2dyZXNzLm1lZGlhQWNxdWlyZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkZWJ1ZycsIHsgbG9jYWxUcmFja3M6IGxvY2FsVHJhY2tzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdFRpbWluZy5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZXhlY3V0ZVByZWZsaWdodFN0ZXAoJ0dldCB0dXJuIGNyZWRlbnRpYWxzJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0dHVybmNyZWRlbnRpYWxzXzEuZ2V0VHVybkNyZWRlbnRpYWxzKHRva2VuLCBvcHRpb25zKTsgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpY2VTZXJ2ZXJzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdFRpbWluZy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgUHJlZmxpZ2h0UHJvZ3Jlc3MuY29ubmVjdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlclBDXzEgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oeyBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3k6ICdyZWxheScsIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXJQQ18xID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHsgaWNlU2VydmVyczogaWNlU2VydmVycywgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwY3MucHVzaChzZW5kZXJQQ18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBjcy5wdXNoKHJlY2VpdmVyUENfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYVRpbWluZy5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZXhlY3V0ZVByZWZsaWdodFN0ZXAoJ1NldHVwIFBlZXIgQ29ubmVjdGlvbnMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdGVUcmFja3NQcm9taXNlLCBvZmZlciwgdXBkYXRlZE9mZmVyLCBhbnN3ZXIsIHVwZGF0ZWRBbnN3ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlclBDXzEuYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5jYW5kaWRhdGUgJiYgcmVjZWl2ZXJQQ18xLmFkZEljZUNhbmRpZGF0ZShldmVudC5jYW5kaWRhdGUpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXJQQ18xLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQuY2FuZGlkYXRlICYmIHNlbmRlclBDXzEuYWRkSWNlQ2FuZGlkYXRlKGV2ZW50LmNhbmRpZGF0ZSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykgeyByZXR1cm4gc2VuZGVyUENfMS5hZGRUcmFjayh0cmFjayk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVUcmFja3NQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdGVUcmFja3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyUENfMS5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZVRyYWNrcy5wdXNoKGV2ZW50LnRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3RlVHJhY2tzLmxlbmd0aCA9PT0gbG9jYWxUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVtb3RlVHJhY2tzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNlbmRlclBDXzEuY3JlYXRlT2ZmZXIoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZE9mZmVyID0gb2ZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNlbmRlclBDXzEuc2V0TG9jYWxEZXNjcmlwdGlvbih1cGRhdGVkT2ZmZXIpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVjZWl2ZXJQQ18xLnNldFJlbW90ZURlc2NyaXB0aW9uKHVwZGF0ZWRPZmZlcildO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZWNlaXZlclBDXzEuY3JlYXRlQW5zd2VyKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5zd2VyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQW5zd2VyID0gYW5zd2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZWNlaXZlclBDXzEuc2V0TG9jYWxEZXNjcmlwdGlvbih1cGRhdGVkQW5zd2VyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNlbmRlclBDXzEuc2V0UmVtb3RlRGVzY3JpcHRpb24odXBkYXRlZEFuc3dlcildO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFja05ldHdvcmtUaW1pbmdzKHNlbmRlclBDXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVtb3RlVHJhY2tzUHJvbWlzZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZVRyYWNrc18xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkZWJ1ZycsIHsgcmVtb3RlVHJhY2tzOiByZW1vdGVUcmFja3NfMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZVRyYWNrc18xLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbG9nLndhcm4odHJhY2sua2luZCArICc6ZW5kZWQnKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbXV0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9sb2cud2Fybih0cmFjay5raW5kICsgJzptdXRlZCcpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCd1bm11dGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbG9nLndhcm4odHJhY2sua2luZCArICc6dW5tdXRlZCcpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIFByZWZsaWdodFByb2dyZXNzLm1lZGlhU3Vic2NyaWJlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9leGVjdXRlUHJlZmxpZ2h0U3RlcCgnd2FpdCBmb3IgdHJhY2tzIHRvIHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbmV3IE1lZGlhU3RyZWFtKHJlbW90ZVRyYWNrc18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzXzEucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2RlYnVnRWxlbWVudCcsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5vbmNhbnBsYXkgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhVGltaW5nLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCBQcmVmbGlnaHRQcm9ncmVzcy5tZWRpYVN0YXJ0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZXhlY3V0ZVByZWZsaWdodFN0ZXAoJ2NvbGxlY3Qgc3RhdHMgZm9yIGR1cmF0aW9uJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2NvbGxlY3RSVENTdGF0c0ZvckR1cmF0aW9uKF90aGlzLl90ZXN0RHVyYXRpb24sIGluaXRDb2xsZWN0ZWRTdGF0cygpLCBzZW5kZXJQQ18xLCByZWNlaXZlclBDXzEpOyB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFN0YXRzXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9leGVjdXRlUHJlZmxpZ2h0U3RlcCgnZ2VuZXJhdGUgcmVwb3J0JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2dlbmVyYXRlUHJlZmxpZ2h0UmVwb3J0KGNvbGxlY3RlZFN0YXRzXzEpOyB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29tcGxldGVkJywgcmVwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZmFpbGVkJywgZXJyb3JfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBjcy5mb3JFYWNoKGZ1bmN0aW9uIChwYykgeyByZXR1cm4gcGMuY2xvc2UoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykgeyByZXR1cm4gdHJhY2suc3RvcCgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5fY29sbGVjdFJUQ1N0YXRzID0gZnVuY3Rpb24gKGNvbGxlY3RlZFN0YXRzLCBzZW5kZXJQQywgcmVjZWl2ZXJQQykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29tYmluZWRTdGF0cywgdGltZXN0YW1wLCBieXRlc1NlbnQsIGJ5dGVzUmVjZWl2ZWQsIHBhY2tldHMsIHBhY2tldHNMb3N0LCByb3VuZFRyaXBUaW1lLCBqaXR0ZXIsIHNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzLCBpY2VDYW5kaWRhdGVTdGF0cywgaGFzTGFzdERhdGEsIGZyYWN0aW9uUGFja2V0TG9zdCwgcGVyY2VudFBhY2tldHNMb3N0LCBzY29yZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0Q29tYmluZWRDb25uZWN0aW9uU3RhdHNfMS5nZXRDb21iaW5lZENvbm5lY3Rpb25TdGF0cyh7IHB1Ymxpc2hlcjogc2VuZGVyUEMsIHN1YnNjcmliZXI6IHJlY2VpdmVyUEMgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21iaW5lZFN0YXRzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wID0gY29tYmluZWRTdGF0cy50aW1lc3RhbXAsIGJ5dGVzU2VudCA9IGNvbWJpbmVkU3RhdHMuYnl0ZXNTZW50LCBieXRlc1JlY2VpdmVkID0gY29tYmluZWRTdGF0cy5ieXRlc1JlY2VpdmVkLCBwYWNrZXRzID0gY29tYmluZWRTdGF0cy5wYWNrZXRzLCBwYWNrZXRzTG9zdCA9IGNvbWJpbmVkU3RhdHMucGFja2V0c0xvc3QsIHJvdW5kVHJpcFRpbWUgPSBjb21iaW5lZFN0YXRzLnJvdW5kVHJpcFRpbWUsIGppdHRlciA9IGNvbWJpbmVkU3RhdHMuaml0dGVyLCBzZWxlY3RlZEljZUNhbmRpZGF0ZVBhaXJTdGF0cyA9IGNvbWJpbmVkU3RhdHMuc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHMsIGljZUNhbmRpZGF0ZVN0YXRzID0gY29tYmluZWRTdGF0cy5pY2VDYW5kaWRhdGVTdGF0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0xhc3REYXRhID0gY29sbGVjdGVkU3RhdHMuaml0dGVyLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRTdGF0cy5qaXR0ZXIucHVzaChqaXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkU3RhdHMucnR0LnB1c2gocm91bmRUcmlwVGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZW50Qnl0ZXNNb3ZpbmdBdmVyYWdlLnB1dFNhbXBsZShieXRlc1NlbnQsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWNlaXZlZEJ5dGVzTW92aW5nQXZlcmFnZS5wdXRTYW1wbGUoYnl0ZXNSZWNlaXZlZCwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhY2tldExvc3NNb3ZpbmdBdmVyYWdlLnB1dFNhbXBsZShwYWNrZXRzTG9zdCwgcGFja2V0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTGFzdERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IEJ5dGVzTW92aW5nQXZlcmFnZSB3aGljaCBpcyBpbiBieXRlcy9taWxsaXNlY29uZCB0byBiaXRzL3NlY29uZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFN0YXRzLm91dGdvaW5nQml0cmF0ZS5wdXNoKHRoaXMuX3NlbnRCeXRlc01vdmluZ0F2ZXJhZ2UuZ2V0KCkgKiAxMDAwICogOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkU3RhdHMuaW5jb21pbmdCaXRyYXRlLnB1c2godGhpcy5fcmVjZWl2ZWRCeXRlc01vdmluZ0F2ZXJhZ2UuZ2V0KCkgKiAxMDAwICogOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhY3Rpb25QYWNrZXRMb3N0ID0gdGhpcy5fcGFja2V0TG9zc01vdmluZ0F2ZXJhZ2UuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudFBhY2tldHNMb3N0ID0gTWF0aC5taW4oMTAwLCBmcmFjdGlvblBhY2tldExvc3QgKiAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFN0YXRzLnBhY2tldExvc3MucHVzaChwZXJjZW50UGFja2V0c0xvc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlID0gbW9zXzEuY2FsY3VsYXRlTU9TKHJvdW5kVHJpcFRpbWUsIGppdHRlciwgZnJhY3Rpb25QYWNrZXRMb3N0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRTdGF0cy5tb3MucHVzaChzY29yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbGxlY3RlZFN0YXRzLnNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkU3RhdHMuc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHMgPSBzZWxlY3RlZEljZUNhbmRpZGF0ZVBhaXJTdGF0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0ZWRTdGF0cy5pY2VDYW5kaWRhdGVTdGF0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRTdGF0cy5pY2VDYW5kaWRhdGVTdGF0cyA9IGljZUNhbmRpZGF0ZVN0YXRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFByZWZsaWdodFRlc3QucHJvdG90eXBlLl9jb2xsZWN0UlRDU3RhdHNGb3JEdXJhdGlvbiA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgY29sbGVjdGVkU3RhdHMsIHNlbmRlclBDLCByZWNlaXZlclBDKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFRpbWUsIFNUQVRfSU5URVJWQUwsIHJlbWFpbmluZ0R1cmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNUQVRfSU5URVJWQUwgPSBNYXRoLm1pbigxMDAwLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB1dGlsXzEud2FpdEZvclNvbWV0aW1lKFNUQVRfSU5URVJWQUwpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fY29sbGVjdFJUQ1N0YXRzKGNvbGxlY3RlZFN0YXRzLCBzZW5kZXJQQywgcmVjZWl2ZXJQQyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdEdXJhdGlvbiA9IGR1cmF0aW9uIC0gKERhdGUubm93KCkgLSBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVtYWluaW5nRHVyYXRpb24gPiAwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jb2xsZWN0UlRDU3RhdHNGb3JEdXJhdGlvbihyZW1haW5pbmdEdXJhdGlvbiwgY29sbGVjdGVkU3RhdHMsIHNlbmRlclBDLCByZWNlaXZlclBDKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFN0YXRzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCBjb2xsZWN0ZWRTdGF0c107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFByZWZsaWdodFRlc3Q7XG59KEV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5QcmVmbGlnaHRUZXN0ID0gUHJlZmxpZ2h0VGVzdDtcbmZ1bmN0aW9uIGluaXRDb2xsZWN0ZWRTdGF0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtb3M6IFtdLFxuICAgICAgICBqaXR0ZXI6IFtdLFxuICAgICAgICBydHQ6IFtdLFxuICAgICAgICBvdXRnb2luZ0JpdHJhdGU6IFtdLFxuICAgICAgICBpbmNvbWluZ0JpdHJhdGU6IFtdLFxuICAgICAgICBwYWNrZXRMb3NzOiBbXSxcbiAgICAgICAgc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHM6IG51bGwsXG4gICAgICAgIGljZUNhbmRpZGF0ZVN0YXRzOiBbXSxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIG5ldHdvcmsgdGltaW5nIG1lYXN1cmVtZW50cyBjYXB0dXJlZCBkdXJpbmcgcHJlZmxpZ2h0IHRlc3RcbiAqIEB0eXBlZGVmIHtvYmplY3R9IE5ldHdvcmtUaW1pbmdcbiAqIEBwcm9wZXJ0eSB7VGltZU1lYXN1cmVtZW50fSBbY29ubmVjdF0gLSBUaW1lIHRvIGVzdGFibGlzaCBzaWduYWxpbmcgY29ubmVjdGlvbiBhbmQgYWNxdWlyZSB0dXJuIGNyZWRlbnRpYWxzXG4gKiBAcHJvcGVydHkge1RpbWVNZWFzdXJlbWVudH0gW21lZGlhXSAtIFRpbWUgdG8gc3RhcnQgbWVkaWEuIFRoaXMgaXMgbWVhc3VyZWQgZnJvbSBjYWxsaW5nIGNvbm5lY3QgdG8gcmVtb3RlIG1lZGlhIGdldHRpbmcgc3RhcnRlZC5cbiAqIEBwcm9wZXJ0eSB7VGltZU1lYXN1cmVtZW50fSBbZHRsc10gLSBUaW1lIHRvIGVzdGFibGlzaCBkdGxzIGNvbm5lY3Rpb24uIFRoaXMgaXMgbWVhc3VyZWQgZnJvbSBSVENEdGxzVHJhbnNwb3J0IGBjb25uZWN0aW5nYCB0byBgY29ubmVjdGVkYCBzdGF0ZS4gKE5vdCBhdmFpbGFibGUgb24gU2FmYXJpKVxuICogQHByb3BlcnR5IHtUaW1lTWVhc3VyZW1lbnR9IFtpY2VdIC0gVGltZSB0byBlc3RhYmxpc2ggaWNlIGNvbm5lY3Rpdml0eS4gVGhpcyBpcyBtZWFzdXJlZCBmcm9tIElDRSBjb25uZWN0aW9uIGBjaGVja2luZ2AgdG8gYGNvbm5lY3RlZGAgc3RhdGUuXG4gKiBAcHJvcGVydHkge1RpbWVNZWFzdXJlbWVudH0gW3BlZXJDb25uZWN0aW9uXSAtIFRpbWUgdG8gZXN0YWJsaXNoIHBlZXIgY29ubmVjdGl2aXR5LiBUaGlzIGlzIG1lYXN1cmVkIGZyb20gUGVlckNvbm5lY3Rpb24gYGNvbm5lY3RpbmdgIHRvIGBjb25uZWN0ZWRgIHN0YXRlLiAoTm90IGF2YWlsYWJsZSBvbiBGaXJlZm94KVxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgc3RhdHMgZm9yIGEgbnVtZXJpY2FsIG1ldHJpYy5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IFN0YXRzXG4gKiBAcHJvcGVydHkgIHtudW1iZXJ9IFthdmVyYWdlXSAtIGF2ZXJhZ2UgdmFsdWUgb2JzZXJ2ZWQuXG4gKiBAcHJvcGVydHkgIHtudW1iZXJ9IFttYXhdIC0gbWF4IHZhbHVlIG9ic2VydmVkLlxuICogQHByb3BlcnR5ICB7bnVtYmVyfSBbbWluXSAtIG1pbiB2YWx1ZSBvYnNlcnZlZC5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIHN0YXRzIGZvciBhIG51bWVyaWNhbCBtZXRyaWMuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTZWxlY3RlZEljZUNhbmRpZGF0ZVBhaXJTdGF0c1xuICogQHByb3BlcnR5ICB7UlRDSWNlQ2FuZGlkYXRlU3RhdHN9IFtsb2NhbENhbmRpZGF0ZV0gLSBzZWxlY3RlZCBsb2NhbCBpY2UgY2FuZGlkYXRlXG4gKiBAcHJvcGVydHkgIHtSVENJY2VDYW5kaWRhdGVTdGF0c30gW3JlbW90ZUNhbmRpZGF0ZV0gLSBzZWxlY3RlZCBsb2NhbCBpY2UgY2FuZGlkYXRlXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBSVEMgcmVsYXRlZCBzdGF0cyB0aGF0IHdlcmUgb2JzZXJ2ZWQgZHVyaW5nIHByZWZsaWdodCB0ZXN0XG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQcmVmbGlnaHRSZXBvcnRTdGF0c1xuICogQHByb3BlcnR5IHtTdGF0c30gW2ppdHRlcl0gLSBQYWNrZXQgZGVsYXkgdmFyaWF0aW9uIGluIHNlY29uZHNcbiAqIEBwcm9wZXJ0eSB7U3RhdHN9IFtydHRdIC0gUm91bmQgdHJpcCB0aW1lLCB0byB0aGUgc2VydmVyIGJhY2sgdG8gdGhlIGNsaWVudCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge1N0YXRzfSBbcGFja2V0TG9zc10gLSBQYWNrZXQgbG9zcyBhcyBhIHBlcmNlbnQgb2YgdG90YWwgcGFja2V0cyBzZW50LlxuKi9cbi8qKlxuICogUmVwcmVzZW50cyByZXBvcnQgZ2VuZXJhdGVkIGJ5IHtAbGluayBQcmVmbGlnaHRUZXN0fS5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IFByZWZsaWdodFRlc3RSZXBvcnRcbiAqIEBwcm9wZXJ0eSB7VGltZU1lYXN1cmVtZW50fSBbdGVzdFRpbWluZ10gLSBUaW1lIG1lYXN1cmVtZW50cyBvZiB0ZXN0IHJ1biB0aW1lLlxuICogQHByb3BlcnR5IHtOZXR3b3JrVGltaW5nfSBbbmV0d29ya1RpbWluZ10gLSBOZXR3b3JrIHJlbGF0ZWQgdGltZSBtZWFzdXJlbWVudHMuXG4gKiBAcHJvcGVydHkge1ByZWZsaWdodFJlcG9ydFN0YXRzfSBbc3RhdHNdIC0gUlRDIHJlbGF0ZWQgc3RhdHMgY2FwdHVyZWQgZHVyaW5nIHRoZSB0ZXN0LlxuICogQHByb3BlcnR5IHtBcnJheTxSVENJY2VDYW5kaWRhdGVTdGF0cz59IFtpY2VDYW5kaWRhdGVTdGF0c10gLSBMaXN0IG9mIGdhdGhlcmVkIGljZSBjYW5kaWRhdGVzLlxuICogQHByb3BlcnR5IHtTZWxlY3RlZEljZUNhbmRpZGF0ZVBhaXJTdGF0c30gc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHMgLSBzdGF0cyBmb3IgdGhlIGljZSBjYW5kaWRhdGVzIHRoYXQgd2VyZSB1c2VkIGZvciB0aGUgY29ubmVjdGlvbi5cbiAqL1xuLyoqXG4gKiBZb3UgbWF5IHBhc3MgdGhlc2Ugb3B0aW9ucyB0byB7QGxpbmsgbW9kdWxlOnR3aWxpby12aWRlby50ZXN0UHJlZmxpZ2h0fSBpbiBvcmRlciB0byBvdmVycmlkZSB0aGVcbiAqIGRlZmF1bHQgYmVoYXZpb3IuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQcmVmbGlnaHRPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3JlZ2lvbj0nZ2xsJ10gLSBQcmVmZXJyZWQgc2lnbmFsaW5nIHJlZ2lvbjsgQnkgZGVmYXVsdCwgeW91IHdpbGwgYmUgY29ubmVjdGVkIHRvIHRoZVxuICogICBuZWFyZXN0IHNpZ25hbGluZyBzZXJ2ZXIgZGV0ZXJtaW5lZCBieSBsYXRlbmN5IGJhc2VkIHJvdXRpbmcuIFNldHRpbmcgYSB2YWx1ZSBvdGhlclxuICogICB0aGFuIDxjb2RlIHN0eWxlPVwicGFkZGluZzowIDBcIj5nbGw8L2NvZGU+IGJ5cGFzc2VzIHJvdXRpbmcgYW5kIGd1YXJhbnRlZXMgdGhhdCBzaWduYWxpbmcgdHJhZmZpYyB3aWxsIGJlXG4gKiAgIHRlcm1pbmF0ZWQgaW4gdGhlIHJlZ2lvbiB0aGF0IHlvdSBwcmVmZXIuIFBsZWFzZSByZWZlciB0byB0aGlzIDxhIGhyZWY9XCJodHRwczovL3d3dy50d2lsaW8uY29tL2RvY3MvdmlkZW8vaXAtYWRkcmVzcy13aGl0ZWxpc3Rpbmcjc2lnbmFsaW5nLWNvbW11bmljYXRpb25cIiB0YXJnZXQ9XCJfYmxhbmtcIj50YWJsZTwvYT5cbiAqICAgZm9yIHRoZSBsaXN0IG9mIHN1cHBvcnRlZCBzaWduYWxpbmcgcmVnaW9ucy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MTAwMDBdIC0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBydW4gdGVzdCBmb3IuXG4gKiAgIG9uY2UgY29ubmVjdGVkIHRlc3Qgd2lsbCBydW4gZm9yIHRoaXMgZHVyYXRpb24gYmVmb3JlIGdlbmVyYXRpbmcgdGhlIHN0YXRzIHJlcG9ydC5cbiAqL1xuLyoqXG4gKiBQcmVmbGlnaHQgdGVzdCBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAqIEBwYXJhbSB7UHJlZmxpZ2h0VGVzdFJlcG9ydH0gcmVwb3J0IC0gcmVzdWx0cyBvZiB0aGUgdGVzdC5cbiAqIEBldmVudCBQcmVmbGlnaHRUZXN0I2NvbXBsZXRlZFxuICovXG4vKipcbiAqIFByZWZsaWdodCB0ZXN0IGhhcyBlbmNvdW50ZXJlZCBhIGZhaWxlZCBhbmQgaXMgbm93IHN0b3BwZWQuXG4gKiBAcGFyYW0ge1R3aWxpb0Vycm9yfEVycm9yfSBlcnJvciAtIGVycm9yIG9iamVjdFxuICogQGV2ZW50IFByZWZsaWdodFRlc3QjZmFpbGVkXG4gKi9cbi8qKlxuICogRW1pdHRlZCB0byBpbmRpY2F0ZSBwcm9ncmVzcyBvZiB0aGUgdGVzdFxuICogQHBhcmFtIHtQcmVmbGlnaHRQcm9ncmVzc30gcHJvZ3Jlc3MgLSBpbmRpY2F0ZXMgdGhlIHN0YXR1cyBjb21wbGV0ZWQuXG4gKiBAZXZlbnQgUHJlZmxpZ2h0VGVzdCNwcm9ncmVzc1xuICovXG4vKipcbiAqIEBtZXRob2RcbiAqIEBuYW1lIHJ1blByZWZsaWdodFxuICogQGRlc2NyaXB0aW9uIFJ1biBhIHByZWZsaWdodCB0ZXN0LiBUaGlzIG1ldGhvZCB3aWxsIHN0YXJ0IGEgdGVzdCB0byBjaGVjayB0aGUgcXVhbGl0eSBvZiBuZXR3b3JrIGNvbm5lY3Rpb24uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR3aWxpby12aWRlb1xuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gVGhlIEFjY2VzcyBUb2tlbiBzdHJpbmdcbiAqIEBwYXJhbSB7UHJlZmxpZ2h0T3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIHRoZSB0ZXN0XG4gKiBAcmV0dXJucyB7UHJlZmxpZ2h0VGVzdH0gcHJlZmxpZ2h0VGVzdCAtIGFuIGluc3RhbmNlIHRvIGJlIHVzZWQgdG8gbW9uaXRvciBwcm9ncmVzcyBvZiB0aGUgdGVzdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgeyBydW5QcmVmbGlnaHQgfSA9IHJlcXVpcmUoJ3R3aWxpby12aWRlbycpO1xuICogdmFyIHByZWZsaWdodCA9IHJ1blByZWZsaWdodCgpO1xuICogcHJlZmxpZ2h0VGVzdC5vbigncHJvZ3Jlc3MnLCBwcm9ncmVzcyA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdwcmVmbGlnaHQgcHJvZ3Jlc3M6JywgcHJvZ3Jlc3MpO1xuICogfSk7XG4gKlxuICogcHJlZmxpZ2h0VGVzdC5vbignZmFpbGVkJywgZXJyb3IgPT4ge1xuICogICBjb25zb2xlLmVycm9yKCdwcmVmbGlnaHQgZXJyb3I6JywgZXJyb3IpO1xuICogfSk7XG4gKlxuICogcHJlZmxpZ2h0VGVzdC5vbignY29tcGxldGVkJywgcmVwb3J0ID0+IHtcbiAqICAgY29uc29sZS5sb2coJ3ByZWZsaWdodCBjb21wbGV0ZWQ6JywgcmVwb3J0KSk7XG4gKiB9KTtcbiovXG5mdW5jdGlvbiBydW5QcmVmbGlnaHQodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBwcmVmbGlnaHQgPSBuZXcgUHJlZmxpZ2h0VGVzdCh0b2tlbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHByZWZsaWdodDtcbn1cbmV4cG9ydHMucnVuUHJlZmxpZ2h0ID0gcnVuUHJlZmxpZ2h0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZmxpZ2h0dGVzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3ludGhldGljQXVkaW8gPSB2b2lkIDA7XG5mdW5jdGlvbiBzeW50aGV0aWNBdWRpbygpIHtcbiAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogV2UgaGF2ZSB0byBkZWxheSByZXF1aXJlLWluZyBBdWRpb0NvbnRleHRGYWN0b3J5LCBiZWNhdXNlXG4gICAgLy8gaXQgZXhwb3J0cyBhIGRlZmF1bHQgaW5zdGFuY2Ugd2hvc2UgY29uc3RydWN0b3IgY2FsbHMgT2JqZWN0LmFzc2lnbi5cbiAgICB2YXIgYXVkaW9Db250ZXh0RmFjdG9yeSA9IHJlcXVpcmUoJy4uL3dlYmF1ZGlvL2F1ZGlvY29udGV4dCcpO1xuICAgIHZhciBob2xkZXIgPSB7fTtcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0RmFjdG9yeS5nZXRPckNyZWF0ZShob2xkZXIpO1xuICAgIHZhciBvc2NpbGxhdG9yID0gYXVkaW9Db250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICB2YXIgZHN0ID0gb3NjaWxsYXRvci5jb25uZWN0KGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCkpO1xuICAgIG9zY2lsbGF0b3Iuc3RhcnQoKTtcbiAgICB2YXIgdHJhY2sgPSBkc3Quc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF07XG4gICAgdmFyIG9yaWdpbmFsU3RvcCA9IHRyYWNrLnN0b3A7XG4gICAgdHJhY2suc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb3JpZ2luYWxTdG9wLmNhbGwodHJhY2spO1xuICAgICAgICBhdWRpb0NvbnRleHRGYWN0b3J5LnJlbGVhc2UoaG9sZGVyKTtcbiAgICB9O1xuICAgIHJldHVybiB0cmFjaztcbn1cbmV4cG9ydHMuc3ludGhldGljQXVkaW8gPSBzeW50aGV0aWNBdWRpbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN5bnRoZXRpY2F1ZGlvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zeW50aGV0aWNWaWRlbyA9IHZvaWQgMDtcbmZ1bmN0aW9uIHN5bnRoZXRpY1ZpZGVvKF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2Iud2lkdGgsIHdpZHRoID0gX2MgPT09IHZvaWQgMCA/IDY0MCA6IF9jLCBfZCA9IF9iLmhlaWdodCwgaGVpZ2h0ID0gX2QgPT09IHZvaWQgMCA/IDQ4MCA6IF9kO1xuICAgIHZhciBjYW52YXMgPSBPYmplY3QuYXNzaWduKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnZ3JlZW4nO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgLy8gZHJhdyByYW5kb20gcmVjdC9jaXJjbGUuXG4gICAgICAgICAgICB2YXIgciA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDI1NSk7XG4gICAgICAgICAgICB2YXIgZyA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDI1NSk7XG4gICAgICAgICAgICB2YXIgYiA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDI1NSk7XG4gICAgICAgICAgICB2YXIgYSA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDI1NSk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKFwiICsgciArIFwiLCBcIiArIGcgKyBcIiwgXCIgKyBiICsgXCIsIFwiICsgYSArIFwiKVwiO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KE1hdGgucmFuZG9tKCkgKiB3aWR0aCwgTWF0aC5yYW5kb20oKSAqIGhlaWdodCwgNTAsIDUwKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBzdHJlYW0gPSBjYW52YXMuY2FwdHVyZVN0cmVhbSgzMCk7XG4gICAgdmFyIHRyYWNrID0gc3RyZWFtLmdldFRyYWNrcygpWzBdO1xuICAgIHZhciBvcmlnaW5hbFN0b3AgPSB0cmFjay5zdG9wO1xuICAgIHRyYWNrLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBvcmlnaW5hbFN0b3AuY2FsbCh0cmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gdHJhY2s7XG59XG5leHBvcnRzLnN5bnRoZXRpY1ZpZGVvID0gc3ludGhldGljVmlkZW87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zeW50aGV0aWN2aWRlby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGltZXIgPSB2b2lkIDA7XG52YXIgVGltZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZXIoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgICAgICAgdGhpcy5fZW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICAgIFRpbWVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFRpbWVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbmQgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFRpbWVyLnByb3RvdHlwZS5nZXRUaW1lTWVhc3VyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogdGhpcy5fc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHRoaXMuX2VuZCxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLl9lbmQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMuX2VuZCAtIHRoaXMuX3N0YXJ0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGltZXI7XG59KCkpO1xuZXhwb3J0cy5UaW1lciA9IFRpbWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xuICAgIHJldHVybiB0bztcbn07XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuLyoqXG4gKiBBIHtAbGluayBRdWV1ZWluZ0V2ZW50RW1pdHRlcn0gY2FuIHF1ZXVlIGV2ZW50cyB1bnRpbCBhIGxpc3RlbmVyIGhhcyBiZWVuXG4gKiBhZGRlZC5cbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG52YXIgUXVldWVpbmdFdmVudEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFF1ZXVlaW5nRXZlbnRFbWl0dGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBRdWV1ZWluZ0V2ZW50RW1pdHRlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBRdWV1ZWluZ0V2ZW50RW1pdHRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9xdWV1ZWRFdmVudHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXQgYW55IHF1ZXVlZCBldmVudHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgZXZlcnkgZXZlbnQgaGFkIGxpc3RlbmVycywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgKi8gLyoqXG4gICAgICogRW1pdCBhbnkgcXVldWVkIGV2ZW50cyBtYXRjaGluZyB0aGUgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBldmVyeSBldmVudCBoYWQgbGlzdGVuZXJzLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBRdWV1ZWluZ0V2ZW50RW1pdHRlci5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKF8sIHF1ZXVlZEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5kZXF1ZXVlKHF1ZXVlZEV2ZW50KSAmJiByZXN1bHQ7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5fcXVldWVkRXZlbnRzLmdldChldmVudCkgfHwgW107XG4gICAgICAgIHRoaXMuX3F1ZXVlZEV2ZW50cy5kZWxldGUoZXZlbnQpO1xuICAgICAgICByZXR1cm4gcXVldWUucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGFyZ3MpIHsgcmV0dXJuIF90aGlzLmVtaXQuYXBwbHkoX3RoaXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChbZXZlbnRdLmNvbmNhdChhcmdzKSkpKSAmJiByZXN1bHQ7IH0sIHJlc3VsdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZXZlbnQgaGFzIGxpc3RlbmVycywgZW1pdCB0aGUgZXZlbnQ7IG90aGVyd2lzZSwgcXVldWUgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBmYWxzZSBpZiB0aGUgZXZlbnQgd2FzIHF1ZXVlZFxuICAgICAqL1xuICAgIFF1ZXVlaW5nRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLmVtaXQuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudCA9IGFyZ3NbMF07XG4gICAgICAgIGlmICghdGhpcy5fcXVldWVkRXZlbnRzLmhhcyhldmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlZEV2ZW50cy5zZXQoZXZlbnQsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9xdWV1ZWRFdmVudHMuZ2V0KGV2ZW50KS5wdXNoKGFyZ3Muc2xpY2UoMSkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gUXVldWVpbmdFdmVudEVtaXR0ZXI7XG59KEV2ZW50RW1pdHRlcikpO1xubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZWluZ0V2ZW50RW1pdHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlaW5nZXZlbnRlbWl0dGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICByZXR1cm4gdG87XG59O1xudmFyIFBhcnRpY2lwYW50ID0gcmVxdWlyZSgnLi9wYXJ0aWNpcGFudCcpO1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gcmVwcmVzZW50cyBhIHJlbW90ZSB7QGxpbmsgUGFydGljaXBhbnR9IGluIGFcbiAqIHtAbGluayBSb29tfS5cbiAqIEBleHRlbmRzIFBhcnRpY2lwYW50XG4gKiBAcHJvcGVydHkge01hcDxUcmFjay5TSUQsIFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbj59IGF1ZGlvVHJhY2tzIC1cbiAqICAgIFRoZSB7QGxpbmsgUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZUF1ZGlvVHJhY2tQdWJsaWNhdGlvbn1zXG4gKiBAcHJvcGVydHkge01hcDxUcmFjay5TSUQsIFJlbW90ZURhdGFUcmFja1B1YmxpY2F0aW9uPn0gZGF0YVRyYWNrcyAtXG4gKiAgICBUaGUge0BsaW5rIFBhcnRpY2lwYW50fSdzIHtAbGluayBSZW1vdGVEYXRhVHJhY2tQdWJsaWNhdGlvbn1zXG4gKiBAcHJvcGVydHkge01hcDxUcmFjay5TSUQsIFJlbW90ZVRyYWNrUHVibGljYXRpb24+fSB0cmFja3MgLVxuICogICAgVGhlIHtAbGluayBQYXJ0aWNpcGFudH0ncyB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn1zXG4gKiBAcHJvcGVydHkge01hcDxUcmFjay5TSUQsIFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbj59IHZpZGVvVHJhY2tzIC1cbiAqICAgIFRoZSB7QGxpbmsgUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2tQdWJsaWNhdGlvbn1zXG4gKiBAZW1pdHMgUmVtb3RlUGFydGljaXBhbnQjcmVjb25uZWN0ZWRcbiAqIEBlbWl0cyBSZW1vdGVQYXJ0aWNpcGFudCNyZWNvbm5lY3RpbmdcbiAqIEBlbWl0cyBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja0RpbWVuc2lvbnNDaGFuZ2VkXG4gKiBAZW1pdHMgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tEaXNhYmxlZFxuICogQGVtaXRzIFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrRW5hYmxlZFxuICogQGVtaXRzIFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrTWVzc2FnZVxuICogQGVtaXRzIFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrUHVibGlzaGVkXG4gKiBAZW1pdHMgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tQdWJsaXNoUHJpb3JpdHlDaGFuZ2VkXG4gKiBAZW1pdHMgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tTdGFydGVkXG4gKiBAZW1pdHMgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tTdWJzY3JpYmVkXG4gKiBAZW1pdHMgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcbiAqIEBlbWl0cyBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja1N3aXRjaGVkT2ZmXG4gKiBAZW1pdHMgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tTd2l0Y2hlZE9uXG4gKiBAZW1pdHMgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tVbnB1Ymxpc2hlZFxuICogQGVtaXRzIFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrVW5zdWJzY3JpYmVkXG4gKi9cbnZhciBSZW1vdGVQYXJ0aWNpcGFudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVtb3RlUGFydGljaXBhbnQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fS5cbiAgICAgKiBAcGFyYW0ge1BhcnRpY2lwYW50U2lnbmFsaW5nfSBzaWduYWxpbmdcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVtb3RlUGFydGljaXBhbnQoc2lnbmFsaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNpZ25hbGluZywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2hhbmRsZVRyYWNrU2lnbmFsaW5nRXZlbnRzKCk7XG4gICAgICAgIF90aGlzLm9uY2UoJ2Rpc2Nvbm5lY3RlZCcsIF90aGlzLl91bnN1YnNjcmliZVRyYWNrcy5iaW5kKF90aGlzKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVtb3RlUGFydGljaXBhbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbUmVtb3RlUGFydGljaXBhbnQgI1wiICsgdGhpcy5faW5zdGFuY2VJZCArICh0aGlzLnNpZCA/IFwiOiBcIiArIHRoaXMuc2lkIDogJycpICsgXCJdXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHJlbW90ZVRyYWNrXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvblxuICAgICAqIEBwYXJhbSB7VHJhY2suSUR9IGlkXG4gICAgICogQHJldHVybnMgez9SZW1vdGVUcmFja31cbiAgICAgKi9cbiAgICBSZW1vdGVQYXJ0aWNpcGFudC5wcm90b3R5cGUuX2FkZFRyYWNrID0gZnVuY3Rpb24gKHJlbW90ZVRyYWNrLCBwdWJsaWNhdGlvbiwgaWQpIHtcbiAgICAgICAgaWYgKCFfc3VwZXIucHJvdG90eXBlLl9hZGRUcmFjay5jYWxsKHRoaXMsIHJlbW90ZVRyYWNrLCBpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHB1YmxpY2F0aW9uLl9zdWJzY3JpYmVkKHJlbW90ZVRyYWNrKTtcbiAgICAgICAgdGhpcy5lbWl0KCd0cmFja1N1YnNjcmliZWQnLCByZW1vdGVUcmFjaywgcHVibGljYXRpb24pO1xuICAgICAgICByZXR1cm4gcmVtb3RlVHJhY2s7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb25cbiAgICAgKiBAcmV0dXJucyB7P1JlbW90ZVRyYWNrUHVibGljYXRpb259XG4gICAgICovXG4gICAgUmVtb3RlUGFydGljaXBhbnQucHJvdG90eXBlLl9hZGRUcmFja1B1YmxpY2F0aW9uID0gZnVuY3Rpb24gKHB1YmxpY2F0aW9uKSB7XG4gICAgICAgIHZhciBhZGRlZFB1YmxpY2F0aW9uID0gX3N1cGVyLnByb3RvdHlwZS5fYWRkVHJhY2tQdWJsaWNhdGlvbi5jYWxsKHRoaXMsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgaWYgKCFhZGRlZFB1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3RyYWNrUHVibGlzaGVkJywgYWRkZWRQdWJsaWNhdGlvbik7XG4gICAgICAgIHJldHVybiBhZGRlZFB1YmxpY2F0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZW1vdGVQYXJ0aWNpcGFudC5wcm90b3R5cGUuX2dldFRyYWNrUHVibGljYXRpb25FdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChfc3VwZXIucHJvdG90eXBlLl9nZXRUcmFja1B1YmxpY2F0aW9uRXZlbnRzLmNhbGwodGhpcykpKSwgW1xuICAgICAgICAgICAgWydzdWJzY3JpcHRpb25GYWlsZWQnLCAndHJhY2tTdWJzY3JpcHRpb25GYWlsZWQnXSxcbiAgICAgICAgICAgIFsndHJhY2tEaXNhYmxlZCcsICd0cmFja0Rpc2FibGVkJ10sXG4gICAgICAgICAgICBbJ3RyYWNrRW5hYmxlZCcsICd0cmFja0VuYWJsZWQnXSxcbiAgICAgICAgICAgIFsncHVibGlzaFByaW9yaXR5Q2hhbmdlZCcsICd0cmFja1B1Ymxpc2hQcmlvcml0eUNoYW5nZWQnXSxcbiAgICAgICAgICAgIFsndHJhY2tTd2l0Y2hlZE9mZicsICd0cmFja1N3aXRjaGVkT2ZmJ10sXG4gICAgICAgICAgICBbJ3RyYWNrU3dpdGNoZWRPbicsICd0cmFja1N3aXRjaGVkT24nXVxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVtb3RlUGFydGljaXBhbnQucHJvdG90eXBlLl91bnN1YnNjcmliZVRyYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50cmFja3MuZm9yRWFjaChmdW5jdGlvbiAocHVibGljYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwdWJsaWNhdGlvbi5pc1N1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSBwdWJsaWNhdGlvbi50cmFjaztcbiAgICAgICAgICAgICAgICBwdWJsaWNhdGlvbi5fdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCd0cmFja1Vuc3Vic2NyaWJlZCcsIHRyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1JlbW90ZVRyYWNrfSByZW1vdGVUcmFja1xuICAgICAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb25cbiAgICAgKiBAcGFyYW0ge1RyYWNrLklEfSBpZFxuICAgICAqIEByZXR1cm5zIHs/UmVtb3RlVHJhY2t9XG4gICAgICovXG4gICAgUmVtb3RlUGFydGljaXBhbnQucHJvdG90eXBlLl9yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIChyZW1vdGVUcmFjaywgcHVibGljYXRpb24sIGlkKSB7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZWRUcmFjayA9IHRoaXMuX3RyYWNrcy5nZXQoaWQpO1xuICAgICAgICBpZiAoIXVuc3Vic2NyaWJlZFRyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9yZW1vdmVUcmFjay5jYWxsKHRoaXMsIHVuc3Vic2NyaWJlZFRyYWNrLCBpZCk7XG4gICAgICAgIHB1YmxpY2F0aW9uLl91bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmVtaXQoJ3RyYWNrVW5zdWJzY3JpYmVkJywgdW5zdWJzY3JpYmVkVHJhY2ssIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlZFRyYWNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uXG4gICAgICogQHJldHVybnMgez9SZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICAgICAqL1xuICAgIFJlbW90ZVBhcnRpY2lwYW50LnByb3RvdHlwZS5fcmVtb3ZlVHJhY2tQdWJsaWNhdGlvbiA9IGZ1bmN0aW9uIChwdWJsaWNhdGlvbikge1xuICAgICAgICB0aGlzLl9zaWduYWxpbmcuY2xlYXJUcmFja0hpbnQocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgICAgICB2YXIgcmVtb3ZlZFB1YmxpY2F0aW9uID0gX3N1cGVyLnByb3RvdHlwZS5fcmVtb3ZlVHJhY2tQdWJsaWNhdGlvbi5jYWxsKHRoaXMsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgaWYgKCFyZW1vdmVkUHVibGljYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgndHJhY2tVbnB1Ymxpc2hlZCcsIHJlbW92ZWRQdWJsaWNhdGlvbik7XG4gICAgICAgIHJldHVybiByZW1vdmVkUHVibGljYXRpb247XG4gICAgfTtcbiAgICByZXR1cm4gUmVtb3RlUGFydGljaXBhbnQ7XG59KFBhcnRpY2lwYW50KSk7XG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IGhhcyByZWNvbm5lY3RlZCB0byB0aGUge0BsaW5rIFJvb219IGFmdGVyIGEgc2lnbmFsaW5nIGNvbm5lY3Rpb24gZGlzcnVwdGlvbi5cbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCNyZWNvbm5lY3RlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IGlzIHJlY29ubmVjdGluZyB0byB0aGUge0BsaW5rIFJvb219IGFmdGVyIGEgc2lnbmFsaW5nIGNvbm5lY3Rpb24gZGlzcnVwdGlvbi5cbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCNyZWNvbm5lY3RpbmdcbiAqL1xuLyoqXG4gKiBPbmUgb2YgdGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0ncyB7QGxpbmsgUmVtb3RlVmlkZW9UcmFja30ncyBkaW1lbnNpb25zIGNoYW5nZWQuXG4gKiBAcGFyYW0ge1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB3aG9zZSBkaW1lbnNpb25zIGNoYW5nZWRcbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja0RpbWVuc2lvbnNDaGFuZ2VkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyBkaXNhYmxlZCBieSB0aGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fS5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb24gLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259IGFzc29jaWF0ZWQgd2l0aCB0aGUgZGlzYWJsZWQge0BsaW5rIFJlbW90ZVRyYWNrfVxuICogQGV2ZW50IFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrRGlzYWJsZWRcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVUcmFja30gd2FzIGVuYWJsZWQgYnkgdGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0uXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBhc3NvY2lhdGVkIHdpdGggdGhlIGVuYWJsZWQge0BsaW5rIFJlbW90ZVRyYWNrfVxuICogQGV2ZW50IFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrRW5hYmxlZFxuICovXG4vKipcbiAqIEEgbWVzc2FnZSB3YXMgcmVjZWl2ZWQgb3ZlciBvbmUgb2YgdGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0nc1xuICoge0BsaW5rIFJlbW90ZURhdGFUcmFja31zLlxuICogQGV2ZW50IFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrTWVzc2FnZVxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXlCdWZmZXJ9IGRhdGFcbiAqIEBwYXJhbSB7UmVtb3RlRGF0YVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlRGF0YVRyYWNrfSBvdmVyIHdoaWNoIHRoZVxuICogICBtZXNzYWdlIHdhcyByZWNlaXZlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgcHVibGlzaGVkIGJ5IHRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IGFmdGVyXG4gKiBjb25uZWN0aW5nIHRvIHRoZSB7QGxpbmsgUm9vbX0uIFRoaXMgZXZlbnQgaXMgbm90IGVtaXR0ZWQgZm9yXG4gKiB7QGxpbmsgUmVtb3RlVHJhY2t9cyB0aGF0IHdlcmUgcHVibGlzaGVkIHdoaWxlIHRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9XG4gKiB3YXMgY29ubmVjdGluZyB0byB0aGUge0BsaW5rIFJvb219LlxuICogQGV2ZW50IFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrUHVibGlzaGVkXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICogICB3aGljaCByZXByZXNlbnRzIHRoZSBwdWJsaXNoZWQge0BsaW5rIFJlbW90ZVRyYWNrfVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIHRyYWNrUHVibGlzaGVkKHB1YmxpY2F0aW9uKSB7XG4gKiAgIGNvbnNvbGUubG9nKGBUcmFjayAke3B1YmxpY2F0aW9uLnRyYWNrU2lkfSB3YXMgcHVibGlzaGVkYCk7XG4gKiB9XG4gKlxuICogcm9vbS5vbigncGFydGljaXBhbnRDb25uZWN0ZWQnLCBwYXJ0aWNpcGFudCA9PiB7XG4gKiAgIC8vIEhhbmRsZSBSZW1vdGVUcmFja3MgcHVibGlzaGVkIHdoaWxlIGNvbm5lY3RpbmcgdG8gdGhlIFJvb20uXG4gKiAgIHBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmZvckVhY2godHJhY2tQdWJsaXNoZWQpO1xuICpcbiAqICAgLy8gSGFuZGxlIFJlbW90ZVRyYWNrcyBwdWJsaXNoZWQgYWZ0ZXIgY29ubmVjdGluZyB0byB0aGUgUm9vbS5cbiAqICAgcGFydGljaXBhbnQub24oJ3RyYWNrUHVibGlzaGVkJywgdHJhY2tQdWJsaXNoZWQpO1xuICogfSk7XG4gKi9cbi8qKlxuICogT25lIG9mIHRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZVRyYWNrfXMgc3RhcnRlZC5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCBzdGFydGVkXG4gKiBAZXZlbnQgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tTdGFydGVkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgc3Vic2NyaWJlZCB0by5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCB3YXMgc3Vic2NyaWJlZCB0b1xuICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvbiAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn1cbiAqICAgZm9yIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHN1YnNjcmliZWQgdG9cbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja1N1YnNjcmliZWRcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0ncyB7QGxpbmsgUmVtb3RlVHJhY2t9IGNvdWxkIG5vdCBiZSBzdWJzY3JpYmVkIHRvLlxuICogQHBhcmFtIHtUd2lsaW9FcnJvcn0gZXJyb3IgLSBUaGUgcmVhc29uIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IGNvdWxkIG5vdCBiZVxuICogICBzdWJzY3JpYmVkIHRvXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlXG4gKiAgIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBmb3IgdGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCBjb3VsZCBub3RcbiAqICAgYmUgc3Vic2NyaWJlZCB0b1xuICogQGV2ZW50IFJlbW90ZVBhcnRpY2lwYW50I3RyYWNrU3Vic2NyaXB0aW9uRmFpbGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSdzIHB1Ymxpc2gge0BsaW5rIFRyYWNrLlByaW9yaXR5fSB3YXMgY2hhbmdlZCBieSB0aGVcbiAqIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0uXG4gKiBAcGFyYW0ge1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eSAtIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9J3MgbmV3IHB1Ymxpc2hcbiAqICAge0BsaW5rIFRyYWNrLlByaW9yaXR5fTtcbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb24gLSBUaGVcbiAqICAge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259IGZvciB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSB0aGF0IGNoYW5nZWQgcHJpb3JpdHlcbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja1B1Ymxpc2hQcmlvcml0eUNoYW5nZWRcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0ncyB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyBzdWJzY3JpYmVkIHRvLlxuICogQHBhcmFtIHtSZW1vdGVUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrfSB0aGF0IHdhcyBzd2l0Y2hlZCBvZmZcbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb24gLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259XG4gKiAgIGZvciB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSB0aGF0IHdhcyBzd2l0Y2hlZCBvZmZcbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja1N3aXRjaGVkT2ZmXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgc3dpdGNoZWQgb24uXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHN3aXRjaGVkIG9uLlxuICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvbiAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn1cbiAqICAgZm9yIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHN3aXRjaGVkIG9uXG4gKiBAZXZlbnQgUmVtb3RlUGFydGljaXBhbnQjdHJhY2tTd2l0Y2hlZE9uXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyB1bnB1Ymxpc2hlZCBieSB0aGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fS5cbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja1VucHVibGlzaGVkXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICogICB3aGljaCByZXByZXNlbnRzIHRoZSB1bnB1Ymxpc2hlZCB7QGxpbmsgUmVtb3RlVHJhY2t9XG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgdW5zdWJzY3JpYmVkIGZyb20uXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrfSB0cmFjayAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHVuc3Vic2NyaWJlZCBmcm9tXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICogICBmb3IgdGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCB3YXMgdW5zdWJzY3JpYmVkIGZyb21cbiAqIEBldmVudCBSZW1vdGVQYXJ0aWNpcGFudCN0cmFja1Vuc3Vic2NyaWJlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW90ZVBhcnRpY2lwYW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RlcGFydGljaXBhbnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xuICAgIHJldHVybiB0bztcbn07XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9ldmVudGVtaXR0ZXInKTtcbnZhciBSZW1vdGVQYXJ0aWNpcGFudCA9IHJlcXVpcmUoJy4vcmVtb3RlcGFydGljaXBhbnQnKTtcbnZhciBTdGF0c1JlcG9ydCA9IHJlcXVpcmUoJy4vc3RhdHMvc3RhdHNyZXBvcnQnKTtcbnZhciB2YWx1ZVRvSlNPTiA9IHJlcXVpcmUoJy4vdXRpbCcpLnZhbHVlVG9KU09OO1xudmFyIG5JbnN0YW5jZXMgPSAwO1xuLyoqXG4gKiBBIHtAbGluayBSb29tfSByZXByZXNlbnRzIGNvbW11bmljYXRpb24gYmV0d2VlbiB5b3UgYW5kIG9uZSBvciBtb3JlXG4gKiB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9cyBzaGFyaW5nIHtAbGluayBBdWRpb1RyYWNrfXMgYW5kXG4gKiB7QGxpbmsgVmlkZW9UcmFja31zLlxuICogPGJyPjxicj5cbiAqIFlvdSBjYW4gY29ubmVjdCB0byBhIHtAbGluayBSb29tfSBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6dHdpbGlvLXZpZGVvLmNvbm5lY3R9LlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAcHJvcGVydHkgez9SZW1vdGVQYXJ0aWNpcGFudH0gZG9taW5hbnRTcGVha2VyIC0gVGhlIERvbWluYW50IFNwZWFrZXIgaW4gdGhlXG4gKiAgIHtAbGluayBSb29tfSwgaWYgYW55XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzUmVjb3JkaW5nIC0gV2hldGhlciBvciBub3QgdGhlIHtAbGluayBSb29tfSBpcyBiZWluZ1xuICogICByZWNvcmRlZFxuICogQHByb3BlcnR5IHtMb2NhbFBhcnRpY2lwYW50fSBsb2NhbFBhcnRpY2lwYW50IC0gWW91ciB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH1cbiAqICAgaW4gdGhlIHtAbGluayBSb29tfVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lZGlhUmVnaW9uIC0gU3RyaW5nIGluZGljYXRpbmcgZ2VvZ3JhcGhpY2FsIHJlZ2lvblxuICogICAgd2hlcmUgIG1lZGlhIGlzIHByb2Nlc3NlZCBmb3IgdGhlIHtAbGluayBSb29tfS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIHtAbGluayBSb29tfSdzIG5hbWVcbiAqIEBwcm9wZXJ0eSB7TWFwPFBhcnRpY2lwYW50LlNJRCwgUmVtb3RlUGFydGljaXBhbnQ+fSBwYXJ0aWNpcGFudHMgLVxuICogICBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fXMgcGFydGljaXBhdGluZyBpbiB0aGlzIHtAbGluayBSb29tfVxuICogQHByb3BlcnR5IHtSb29tLlNJRH0gc2lkIC0gVGhlIHtAbGluayBSb29tfSdzIFNJRFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gXCJjb25uZWN0ZWRcIiwgXCJyZWNvbm5lY3RpbmdcIiwgb3IgXCJkaXNjb25uZWN0ZWRcIlxuICogQHRocm93cyB7U2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yfVxuICogQGVtaXRzIFJvb20jZGlzY29ubmVjdGVkXG4gKiBAZW1pdHMgUm9vbSNwYXJ0aWNpcGFudENvbm5lY3RlZFxuICogQGVtaXRzIFJvb20jcGFydGljaXBhbnREaXNjb25uZWN0ZWRcbiAqIEBlbWl0cyBSb29tI3BhcnRpY2lwYW50UmVjb25uZWN0ZWRcbiAqIEBlbWl0cyBSb29tI3BhcnRpY2lwYW50UmVjb25uZWN0aW5nXG4gKiBAZW1pdHMgUm9vbSNyZWNvbm5lY3RlZFxuICogQGVtaXRzIFJvb20jcmVjb25uZWN0aW5nXG4gKiBAZW1pdHMgUm9vbSNyZWNvcmRpbmdTdGFydGVkXG4gKiBAZW1pdHMgUm9vbSNyZWNvcmRpbmdTdG9wcGVkXG4gKiBAZW1pdHMgUm9vbSN0cmFja0RpbWVuc2lvbnNDaGFuZ2VkXG4gKiBAZW1pdHMgUm9vbSN0cmFja0Rpc2FibGVkXG4gKiBAZW1pdHMgUm9vbSN0cmFja0VuYWJsZWRcbiAqIEBlbWl0cyBSb29tI3RyYWNrTWVzc2FnZVxuICogQGVtaXRzIFJvb20jdHJhY2tQdWJsaXNoZWRcbiAqIEBlbWl0cyBSb29tI3RyYWNrUHVibGlzaFByaW9yaXR5Q2hhbmdlZFxuICogQGVtaXRzIFJvb20jdHJhY2tTdGFydGVkXG4gKiBAZW1pdHMgUm9vbSN0cmFja1N1YnNjcmliZWRcbiAqIEBlbWl0cyBSb29tI3RyYWNrU3dpdGNoZWRPZmZcbiAqIEBlbWl0cyBSb29tI3RyYWNrU3dpdGNoZWRPblxuICogQGVtaXRzIFJvb20jdHJhY2tVbnB1Ymxpc2hlZFxuICogQGVtaXRzIFJvb20jdHJhY2tVbnN1YnNjcmliZWRcbiAqL1xudmFyIFJvb20gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb20sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJvb219LlxuICAgICAqIEBwYXJhbSB7Um9vbVNpZ25hbGluZ30gc2lnbmFsaW5nXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSb29tKGxvY2FsUGFydGljaXBhbnQsIHNpZ25hbGluZywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICB2YXIgbG9nID0gb3B0aW9ucy5sb2cuY3JlYXRlTG9nKCdkZWZhdWx0JywgX3RoaXMpO1xuICAgICAgICB2YXIgcGFydGljaXBhbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2xvZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsb2dcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sIHx8ICdkaXNhYmxlZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY29udGVudFByZWZlcmVuY2VzTW9kZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmNvbnRlbnRQcmVmZXJlbmNlc01vZGUgfHwgJ2Rpc2FibGVkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pbnN0YW5jZUlkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICsrbkluc3RhbmNlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcGFydGljaXBhbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcnRpY2lwYW50c1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2lnbmFsaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9taW5hbnRTcGVha2VyOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFydGljaXBhbnRzLmdldChzaWduYWxpbmcuZG9taW5hbnRTcGVha2VyU2lkKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1JlY29yZGluZzoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYWxpbmcucmVjb3JkaW5nLmlzRW5hYmxlZCB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9jYWxQYXJ0aWNpcGFudDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxvY2FsUGFydGljaXBhbnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2lnbmFsaW5nLm5hbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJ0aWNpcGFudHM6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJ0aWNpcGFudHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzaWduYWxpbmcuc2lkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsaW5nLnN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZWRpYVJlZ2lvbjoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHNpZ25hbGluZy5tZWRpYVJlZ2lvblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlUmVjb3JkaW5nRXZlbnRzKF90aGlzLCBzaWduYWxpbmcucmVjb3JkaW5nKTtcbiAgICAgICAgaGFuZGxlU2lnbmFsaW5nRXZlbnRzKF90aGlzLCBzaWduYWxpbmcpO1xuICAgICAgICBsb2cuaW5mbygnQ3JlYXRlZCBhIG5ldyBSb29tOicsIF90aGlzLm5hbWUpO1xuICAgICAgICBsb2cuZGVidWcoJ0luaXRpYWwgUmVtb3RlUGFydGljaXBhbnRzOicsIEFycmF5LmZyb20oX3RoaXMuX3BhcnRpY2lwYW50cy52YWx1ZXMoKSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJvb20ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbUm9vbSAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgdGhpcy5zaWQgKyBcIl1cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgZnJvbSB0aGUge0BsaW5rIFJvb219LlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIFJvb20ucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xvZy5pbmZvKCdEaXNjb25uZWN0aW5nJyk7XG4gICAgICAgIHRoaXMuX3NpZ25hbGluZy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB7QGxpbmsgUm9vbX0ncyBtZWRpYSBzdGF0aXN0aWNzLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gU2FmYXJpIDEyLjAgb3IgYmVsb3dcbiAgICAgKiBkdWUgdG8gdGhpcyBidWcgOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTkyNjAxXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXk8U3RhdHNSZXBvcnQ+Pn1cbiAgICAgKi9cbiAgICBSb29tLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbGluZy5nZXRTdGF0cygpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlcykge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocmVzcG9uc2VzKS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgaWQgPSBfYlswXSwgcmVzcG9uc2UgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YXRzUmVwb3J0KGlkLCBPYmplY3QuYXNzaWduKHt9LCByZXNwb25zZSwge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbEF1ZGlvVHJhY2tTdGF0czogcmV3cml0ZUxvY2FsVHJhY2tJZHMoX3RoaXMsIHJlc3BvbnNlLmxvY2FsQXVkaW9UcmFja1N0YXRzKSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxWaWRlb1RyYWNrU3RhdHM6IHJld3JpdGVMb2NhbFRyYWNrSWRzKF90aGlzLCByZXNwb25zZS5sb2NhbFZpZGVvVHJhY2tTdGF0cylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb29tLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVRvSlNPTih0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBSb29tO1xufShFdmVudEVtaXR0ZXIpKTtcbmZ1bmN0aW9uIHJld3JpdGVMb2NhbFRyYWNrSWRzKHJvb20sIHRyYWNrU3RhdHMpIHtcbiAgICB2YXIgbG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZyA9IHJvb20ubG9jYWxQYXJ0aWNpcGFudC5fc2lnbmFsaW5nO1xuICAgIHJldHVybiB0cmFja1N0YXRzLnJlZHVjZShmdW5jdGlvbiAodHJhY2tTdGF0cywgdHJhY2tTdGF0KSB7XG4gICAgICAgIHZhciBwdWJsaWNhdGlvbiA9IGxvY2FsUGFydGljaXBhbnRTaWduYWxpbmcudHJhY2tzLmdldCh0cmFja1N0YXQudHJhY2tJZCk7XG4gICAgICAgIHZhciB0cmFja1NlbmRlciA9IGxvY2FsUGFydGljaXBhbnRTaWduYWxpbmcuZ2V0U2VuZGVyKHB1YmxpY2F0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRyYWNrU2VuZGVyXG4gICAgICAgICAgICA/IFtPYmplY3QuYXNzaWduKHt9LCB0cmFja1N0YXQsIHsgdHJhY2tJZDogdHJhY2tTZW5kZXIuaWQgfSldLmNvbmNhdCh0cmFja1N0YXRzKVxuICAgICAgICAgICAgOiB0cmFja1N0YXRzO1xuICAgIH0sIFtdKTtcbn1cbi8qKlxuICogQSB7QGxpbmsgUm9vbS5TSUR9IGlzIGEgMzQtY2hhcmFjdGVyIHN0cmluZyBzdGFydGluZyB3aXRoIFwiUk1cIlxuICogdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzIGEge0BsaW5rIFJvb219LlxuICogQHR5cGUgc3RyaW5nXG4gKiBAdHlwZWRlZiBSb29tLlNJRFxuICovXG4vKipcbiAqIFRoZSBEb21pbmFudCBTcGVha2VyIGluIHRoZSB7QGxpbmsgUm9vbX0gY2hhbmdlZC4gRWl0aGVyIHRoZSBEb21pbmFudCBTcGVha2VyXG4gKiBpcyBhIG5ldyB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IG9yIHRoZSBEb21pbmFudCBTcGVha2VyIGhhcyBiZWVuIHJlc2V0IGFuZFxuICogaXMgbm93IG51bGwuXG4gKiBAcGFyYW0gez9SZW1vdGVQYXJ0aWNpcGFudH0gZG9taW5hbnRTcGVha2VyIC0gVGhlIERvbWluYW50IFNwZWFrZXIgaW4gdGhlXG4gKiAgIHtAbGluayBSb29tfSwgaWYgYW55XG4gKiBAZXZlbnQgUm9vbSNkb21pbmFudFNwZWFrZXJDaGFuZ2VkXG4gKi9cbi8qKlxuICogWW91ciB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gd2FzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSB7QGxpbmsgUm9vbX0gYW5kIGFsbFxuICogb3RoZXIge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fXMuXG4gKiBAcGFyYW0ge1Jvb219IHJvb20gLSBUaGUge0BsaW5rIFJvb219IHlvdXJcbiAqICAge0BsaW5rIExvY2FsUGFydGljaXBhbnR9IHdhcyBkaXNjb25uZWN0ZWQgZnJvbVxuICogQHBhcmFtIHs/VHdpbGlvRXJyb3J9IGVycm9yIC0gUHJlc2VudCB3aGVuIHRoZSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudH0gZ290XG4gKiAgIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSB7QGxpbmsgUm9vbX0gdW5leHBlY3RlZGx5XG4gKiBAZXZlbnQgUm9vbSNkaXNjb25uZWN0ZWRcbiAqIEBleGFtcGxlXG4gKiBteVJvb20ub24oJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uKHJvb20sIGVycm9yKSB7XG4gKiAgIGlmIChlcnJvcikge1xuICogICAgIGNvbnNvbGUubG9nKCdVbmV4cGVjdGVkbHkgZGlzY29ubmVjdGVkOicsIGVycm9yKTtcbiAqICAgfVxuICogICBteVJvb20ubG9jYWxQYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICogICAgIHRyYWNrLnN0b3AoKTtcbiAqICAgICB0cmFjay5kZXRhY2goKTtcbiAqICAgfSk7XG4gKiB9KTtcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gam9pbmVkIHRoZSB7QGxpbmsgUm9vbX0uIEluIExhcmdlIEdyb3VwIFJvb21zIChNYXhpbXVtXG4gKiBQYXJ0aWNpcGFudHMgZ3JlYXRlciB0aGFuIDUwKSwgdGhpcyBldmVudCBpcyByYWlzZWQgb25seSB3aGVuIGEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fVxuICogcHVibGlzaGVzIGF0IGxlYXN0IG9uZSB7QGxpbmsgTG9jYWxUcmFja30uXG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHdobyBqb2luZWRcbiAqIEBldmVudCBSb29tI3BhcnRpY2lwYW50Q29ubmVjdGVkXG4gKiBAZXhhbXBsZVxuICogbXlSb29tLm9uKCdwYXJ0aWNpcGFudENvbm5lY3RlZCcsIGZ1bmN0aW9uKHBhcnRpY2lwYW50KSB7XG4gKiAgIGNvbnNvbGUubG9nKHBhcnRpY2lwYW50LmlkZW50aXR5ICsgJyBqb2luZWQgdGhlIFJvb20nKTtcbiAqIH0pO1xuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSBsZWZ0IHRoZSB7QGxpbmsgUm9vbX0uIEluIExhcmdlIEdyb3VwIFJvb21zIChNYXhpbXVtXG4gKiBQYXJ0aWNpcGFudHMgZ3JlYXRlciB0aGFuIDUwKSwgdGhpcyBldmVudCBpcyByYWlzZWQgb25seSB3aGVuIGEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fVxuICogdW5wdWJsaXNoZXMgYWxsIGl0cyB7QGxpbmsgTG9jYWxUcmFja31zLlxuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudH0gcGFydGljaXBhbnQgLSBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB3aG8gbGVmdFxuICogQGV2ZW50IFJvb20jcGFydGljaXBhbnREaXNjb25uZWN0ZWRcbiAqIEBleGFtcGxlXG4gKiBteVJvb20ub24oJ3BhcnRpY2lwYW50RGlzY29ubmVjdGVkJywgZnVuY3Rpb24ocGFydGljaXBhbnQpIHtcbiAqICAgY29uc29sZS5sb2cocGFydGljaXBhbnQuaWRlbnRpdHkgKyAnIGxlZnQgdGhlIFJvb20nKTtcbiAqICAgcGFydGljaXBhbnQudHJhY2tzLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAqICAgICB0cmFjay5kZXRhY2goKS5mb3JFYWNoKGZ1bmN0aW9uKG1lZGlhRWxlbWVudCkge1xuICogICAgICAgbWVkaWFFbGVtZW50LnJlbW92ZSgpO1xuICogICAgIH0pO1xuICogICB9KTtcbiAqIH0pO1xuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSBoYXMgcmVjb25uZWN0ZWQgdG8gdGhlIHtAbGluayBSb29tfSBhZnRlciBhIHNpZ25hbGluZyBjb25uZWN0aW9uIGRpc3J1cHRpb24uXG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHRoYXQgaGFzIHJlY29ubmVjdGVkLlxuICogQGV2ZW50IFJvb20jcGFydGljaXBhbnRSZWNvbm5lY3RlZFxuICogQGV4YW1wbGVcbiAqIG15Um9vbS5vbigncGFydGljaXBhbnRSZWNvbm5lY3RlZCcsIHBhcnRpY2lwYW50ID0+IHtcbiAqICAgY29uc29sZS5sb2cocGFydGljaXBhbnQuaWRlbnRpdHkgKyAnIHJlY29ubmVjdGVkIHRvIHRoZSBSb29tJyk7XG4gKiB9KTtcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gaXMgcmVjb25uZWN0aW5nIHRvIHRoZSB7QGxpbmsgUm9vbX0gYWZ0ZXIgYSBzaWduYWxpbmcgY29ubmVjdGlvbiBkaXNydXB0aW9uLlxuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudH0gcGFydGljaXBhbnQgLSBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB0aGF0IGlzIHJlY29ubmVjdGluZy5cbiAqIEBldmVudCBSb29tI3BhcnRpY2lwYW50UmVjb25uZWN0aW5nXG4gKiBAZXhhbXBsZVxuICogbXlSb29tLm9uKCdwYXJ0aWNpcGFudFJlY29ubmVjdGluZycsIHBhcnRpY2lwYW50ID0+IHtcbiAqICAgY29uc29sZS5sb2cocGFydGljaXBhbnQuaWRlbnRpdHkgKyAnIGlzIHJlY29ubmVjdGluZyB0byB0aGUgUm9vbScpO1xuICogfSk7XG4gKi9cbi8qKlxuICogWW91ciBhcHBsaWNhdGlvbiBzdWNjZXNzZnVsbHkgcmVjb25uZWN0ZWQgdG8gdGhlIHtAbGluayBSb29tfS4gV2hlbiB0aGlzXG4gKiBldmVudCBpcyBlbWl0dGVkLCB0aGUge0BsaW5rIFJvb219IGlzIGluIHN0YXRlIFwiY29ubmVjdGVkXCIuXG4gKiBAZXZlbnQgUm9vbSNyZWNvbm5lY3RlZFxuICogQGV4YW1wbGVcbiAqIG15Um9vbS5vbigncmVjb25uZWN0ZWQnLCAoKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdSZWNvbm5lY3RlZCEnKTtcbiAqIH0pO1xuICovXG4vKipcbiAqIFlvdXIgYXBwbGljYXRpb24gaXMgcmVjb25uZWN0aW5nIHRvIHRoZSB7QGxpbmsgUm9vbX0uIFRoaXMgaGFwcGVucyB3aGVuIHRoZXJlXG4gKiBpcyBhIGRpc3J1cHRpb24gaW4geW91ciBzaWduYWxpbmcgY29ubmVjdGlvbiBhbmQvb3IgeW91ciBtZWRpYSBjb25uZWN0aW9uLiBXaGVuXG4gKiB0aGlzIGV2ZW50IGlzIGVtaXR0ZWQsIHRoZSB7QGxpbmsgUm9vbX0gaXMgaW4gc3RhdGUgXCJyZWNvbm5lY3RpbmdcIi4gSWYgcmVjb25uZWN0aW5nXG4gKiBzdWNjZWVkcywgdGhlIHtAbGluayBSb29tfSB3aWxsIGVtaXQgYSBcInJlY29ubmVjdGVkXCIgZXZlbnQuXG4gKiBAcGFyYW0ge01lZGlhQ29ubmVjdGlvbkVycm9yfFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvcn0gZXJyb3IgLSBBXG4gKiAgIHtAbGluayBNZWRpYUNvbm5lY3Rpb25FcnJvcn0gaWYgeW91ciBhcHBsaWNhdGlvbiBpcyByZWNvbm5lY3RpbmcgZHVlIHRvIGFcbiAqICAgZGlzcnVwdGlvbiBpbiB5b3VyIG1lZGlhIGNvbm5lY3Rpb24sIG9yIGEge0BsaW5rIFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvcn1cbiAqICAgaWYgeW91ciBhcHBsaWNhdGlvbiBpcyByZWNvbm5lY3RpbmcgZHVlIHRvIGEgZGlzcnVwdGlvbiBpbiB5b3VyIHNpZ25hbGluZyBjb25uZWN0aW9uXG4gKiBAZXZlbnQgUm9vbSNyZWNvbm5lY3RpbmdcbiAqIEBleGFtcGxlXG4gKiBteVJvb20ub24oJ3JlY29ubmVjdGluZycsIGVycm9yID0+IHtcbiAqICAgaWYgKGVycm9yLmNvZGUgPT09IDUzMDAxKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ1JlY29ubmVjdGluZyB5b3VyIHNpZ25hbGluZyBjb25uZWN0aW9uIScsIGVycm9yLm1lc3NhZ2UpO1xuICogICB9IGVsc2UgaWYgKGVycm9yLmNvZGUgPT09IDUzNDA1KSB7XG4gKiAgICAgY29uc29sZS5sb2coJ1JlY29ubmVjdGluZyB5b3VyIG1lZGlhIGNvbm5lY3Rpb24hJywgZXJyb3IubWVzc2FnZSk7XG4gKiAgIH1cbiAqIH0pO1xuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUm9vbX0gaXMgbm93IGJlaW5nIHJlY29yZGVkXG4gKiBAZXZlbnQgUm9vbSNyZWNvcmRpbmdTdGFydGVkXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSb29tfSBpcyBubyBsb25nZXIgYmVpbmcgcmVjb3JkZWRcbiAqIEBldmVudCBSb29tI3JlY29yZGluZ1N0b3BwZWRcbiAqL1xuLyoqXG4gKiBPbmUgb2YgdGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0ncyB7QGxpbmsgVmlkZW9UcmFja30ncyBkaW1lbnNpb25zIGNoYW5nZWQuXG4gKiBAcGFyYW0ge1JlbW90ZVZpZGVvVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrfSB3aG9zZSBkaW1lbnNpb25zIGNoYW5nZWRcbiAqIEBwYXJhbSB7UmVtb3RlUGFydGljaXBhbnR9IHBhcnRpY2lwYW50IC0gVGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gd2hvc2VcbiAqICAge0BsaW5rIFJlbW90ZVZpZGVvVHJhY2t9J3MgZGltZW5zaW9ucyBjaGFuZ2VkXG4gKiBAZXZlbnQgUm9vbSN0cmFja0RpbWVuc2lvbnNDaGFuZ2VkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyBkaXNhYmxlZCBieSBhIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gaW4gdGhlIHtAbGluayBSb29tfS5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb24gLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259IHRoYXQgcmVwcmVzZW50cyBkaXNhYmxlZCB7QGxpbmsgUmVtb3RlVHJhY2t9XG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHdob1xuICogICBkaXNhYmxlZCB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfVxuICogQGV2ZW50IFJvb20jdHJhY2tEaXNhYmxlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgZW5hYmxlZCBieSBhIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gaW4gdGhlIHtAbGluayBSb29tfS5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb24gLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259IHRoYXQgcmVwcmVzZW50cyBlbmFibGVkIHtAbGluayBSZW1vdGVUcmFja31cbiAqIEBwYXJhbSB7UmVtb3RlUGFydGljaXBhbnR9IHBhcnRpY2lwYW50IC0gVGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gd2hvXG4gKiAgIGVuYWJsZWQgdGhlIHtAbGluayBSZW1vdGVUcmFja31cbiAqIEBldmVudCBSb29tI3RyYWNrRW5hYmxlZFxuICovXG4vKipcbiAqIEEgbWVzc2FnZSB3YXMgcmVjZWl2ZWQgb3ZlciBvbmUgb2YgdGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0nc1xuICoge0BsaW5rIFJlbW90ZURhdGFUcmFja30ncy5cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5QnVmZmVyfSBkYXRhXG4gKiBAcGFyYW0ge1JlbW90ZURhdGFUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZURhdGFUcmFja30gb3ZlciB3aGljaCB0aGVcbiAqICAgbWVzc2FnZSB3YXMgcmVjZWl2ZWRcbiAqIEBwYXJhbSB7UmVtb3RlUGFydGljaXBhbnR9IHBhcnRpY2lwYW50IC0gVGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gd2hvc2VcbiAqICAge0BsaW5rIFJlbW90ZURhdGFUcmFja30gcmVjZWl2ZWQgdGhlIG1lc3NhZ2VcbiAqIEBldmVudCBSb29tI3RyYWNrTWVzc2FnZVxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgcHVibGlzaGVkIGJ5IGEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSBhZnRlclxuICogY29ubmVjdGluZyB0byB0aGUge0BsaW5rIFJvb219LiBUaGlzIGV2ZW50IGlzIG5vdCBlbWl0dGVkIGZvclxuICoge0BsaW5rIFJlbW90ZVRyYWNrfXMgdGhhdCB3ZXJlIHB1Ymxpc2hlZCB3aGlsZSB0aGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fVxuICogd2FzIGNvbm5lY3RpbmcgdG8gdGhlIHtAbGluayBSb29tfS5cbiAqIEBldmVudCBSb29tI3RyYWNrUHVibGlzaGVkXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICogICB3aGljaCByZXByZXNlbnRzIHRoZSBwdWJsaXNoZWQge0BsaW5rIFJlbW90ZVRyYWNrfVxuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudH0gcGFydGljaXBhbnQgLSBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB3aG9cbiAqICAgcHVibGlzaGVkIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9XG4gKiBAZXhhbXBsZVxuICogZnVuY3Rpb24gdHJhY2tQdWJsaXNoZWQocHVibGljYXRpb24sIHBhcnRpY2lwYW50KSB7XG4gKiAgIGNvbnNvbGUubG9nKGBSZW1vdGVQYXJ0aWNpcGFudCAke3BhcnRpY2lwYW50LnNpZH0gcHVibGlzaGVkIFRyYWNrICR7cHVibGljYXRpb24udHJhY2tTaWR9YCk7XG4gKiB9XG4gKlxuICogLy8gSGFuZGxlIFJlbW90ZVRyYWNrcyBwdWJsaXNoZWQgYWZ0ZXIgY29ubmVjdGluZyB0byB0aGUgUm9vbS5cbiAqIHJvb20ub24oJ3RyYWNrUHVibGlzaGVkJywgdHJhY2tQdWJsaXNoZWQpO1xuICpcbiAqIHJvb20ub24oJ3BhcnRpY2lwYW50Q29ubmVjdGVkJywgcGFydGljaXBhbnQgPT4ge1xuICogICAvLyBIYW5kbGUgUmVtb3RlVHJhY2tzIHB1Ymxpc2hlZCB3aGlsZSBjb25uZWN0aW5nIHRvIHRoZSBSb29tLlxuICogICBwYXJ0aWNpcGFudC50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHRyYWNrUHVibGlzaGVkKHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCkpO1xuICogfSk7XG4gKi9cbi8qKlxuICogT25lIG9mIGEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSdzIHtAbGluayBSZW1vdGVUcmFja31zIGluIHRoZSB7QGxpbmsgUm9vbX0gc3RhcnRlZC5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCBzdGFydGVkXG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHdob3NlXG4gKiAgIHtAbGluayBSZW1vdGVUcmFja30gc3RhcnRlZFxuICogQGV2ZW50IFJvb20jdHJhY2tTdGFydGVkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9J3Mge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgc3Vic2NyaWJlZCB0by5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCB3YXMgc3Vic2NyaWJlZFxuICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvbiAtIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn1cbiAqICAgZm9yIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgd2FzIHN1YnNjcmliZWQgdG9cbiAqIEBwYXJhbSB7UmVtb3RlUGFydGljaXBhbnR9IHBhcnRpY2lwYW50IC0gVGhlIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0gd2hvc2VcbiAqICAge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgc3Vic2NyaWJlZFxuICogQGV2ZW50IFJvb20jdHJhY2tTdWJzY3JpYmVkXG4gKiBAZXhhbXBsZVxuICogcm9vbS5vbigndHJhY2tTdWJzY3JpYmVkJywgZnVuY3Rpb24odHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCkge1xuICogICB2YXIgcGFydGljaXBhbnRWaWV3ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcnRpY2lwYW50LXZpZXctJyArIHBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAqICAgcGFydGljaXBhbnRWaWV3LmFwcGVuZENoaWxkKHRyYWNrLmF0dGFjaCgpKTtcbiAqIH0pO1xuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSdzIHtAbGluayBSZW1vdGVUcmFja30gd2FzIHN3aXRjaGVkIG9mZi5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCB3YXMgc3dpdGNoZWQgb2ZmXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICogICBmb3IgdGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCB3YXMgc3Vic2NyaWJlZCB0b1xuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudH0gcGFydGljaXBhbnQgLSBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB3aG9zZVxuICogICB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyBzd2l0Y2hlZCBvZmZcbiAqIEBldmVudCBSb29tI3RyYWNrU3dpdGNoZWRPZmZcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0ncyB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyBzd2l0Y2hlZCBvbi5cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2t9IHRyYWNrIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCB3YXMgc3dpdGNoZWQgb25cbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb24gLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259XG4gKiAgIGZvciB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSB0aGF0IHdhcyBzdWJzY3JpYmVkIHRvXG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHdob3NlXG4gKiAgIHtAbGluayBSZW1vdGVUcmFja30gd2FzIHN3aXRjaGVkIG9uXG4gKiBAZXZlbnQgUm9vbSN0cmFja1N3aXRjaGVkT25cbiAqL1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudH0ncyB7QGxpbmsgUmVtb3RlVHJhY2t9IGNvdWxkIG5vdCBiZSBzdWJzY3JpYmVkIHRvLlxuICogQHBhcmFtIHtUd2lsaW9FcnJvcn0gZXJyb3IgLSBUaGUgcmVhc29uIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IGNvdWxkIG5vdCBiZVxuICogICBzdWJzY3JpYmVkIHRvXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlXG4gKiAgIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBmb3IgdGhlIHtAbGluayBSZW1vdGVUcmFja30gdGhhdCBjb3VsZCBub3RcbiAqICAgYmUgc3Vic2NyaWJlZCB0b1xuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudH0gcGFydGljaXBhbnQgLSBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB3aG9zZVxuICogICB7QGxpbmsgUmVtb3RlVHJhY2t9IGNvdWxkIG5vdCBiZSBzdWJzY3JpYmVkIHRvXG4gKiBAZXZlbnQgUm9vbSN0cmFja1N1YnNjcmlwdGlvbkZhaWxlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9J3MgcHVibGlzaCB7QGxpbmsgVHJhY2suUHJpb3JpdHl9IHdhcyBjaGFuZ2VkIGJ5IHRoZVxuICoge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fS5cbiAqIEBwYXJhbSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5IC0gdGhlIHtAbGluayBSZW1vdGVUcmFja30ncyBuZXcgcHVibGlzaFxuICogICB7QGxpbmsgVHJhY2suUHJpb3JpdHl9O1xuICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvbiAtIFRoZVxuICogICB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gZm9yIHRoZSB7QGxpbmsgUmVtb3RlVHJhY2t9IHRoYXQgY2hhbmdlZCBwcmlvcml0eVxuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudH0gcGFydGljaXBhbnQgLSBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB3aG9zZVxuICogICB7QGxpbmsgUmVtb3RlVHJhY2t9IGNoYW5nZWQgcHJpb3JpdHlcbiAqIEBldmVudCBSb29tI3RyYWNrUHVibGlzaFByaW9yaXR5Q2hhbmdlZFxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVRyYWNrfSB3YXMgdW5wdWJsaXNoZWQgYnkgYSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHRvIHRoZSB7QGxpbmsgUm9vbX0uXG4gKiBAZXZlbnQgUm9vbSN0cmFja1VucHVibGlzaGVkXG4gKiBAcGFyYW0ge1JlbW90ZVRyYWNrUHVibGljYXRpb259IHB1YmxpY2F0aW9uIC0gVGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufVxuICogICB3aGljaCByZXByZXNlbnRzIHRoZSB1bnB1Ymxpc2hlZCB7QGxpbmsgUmVtb3RlVHJhY2t9XG4gKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50fSBwYXJ0aWNpcGFudCAtIFRoZSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnR9IHdob1xuICogICB1bnB1Ymxpc2hlZCB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfVxuICovXG4vKipcbiAqIEEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSdzIHtAbGluayBSZW1vdGVUcmFja30gd2FzIHVuc3Vic2NyaWJlZCBmcm9tLlxuICogQHBhcmFtIHtSZW1vdGVUcmFja30gdHJhY2sgLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrfSB0aGF0IHdhcyB1bnN1YnNjcmliZWRcbiAqIEBwYXJhbSB7UmVtb3RlVHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb24gLSBUaGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb259XG4gKiAgIGZvciB0aGUge0BsaW5rIFJlbW90ZVRyYWNrfSB0aGF0IHdhcyB1bnN1YnNjcmliZWQgZnJvbVxuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudH0gcGFydGljaXBhbnQgLSBUaGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50fSB3aG9zZVxuICogICB7QGxpbmsgUmVtb3RlVHJhY2t9IHdhcyB1bnN1YnNjcmliZWRcbiAqIEBldmVudCBSb29tI3RyYWNrVW5zdWJzY3JpYmVkXG4gKiBAZXhhbXBsZVxuICogcm9vbS5vbigndHJhY2tVbnN1YnNjcmliZWQnLCBmdW5jdGlvbih0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KSB7XG4gKiAgIHRyYWNrLmRldGFjaCgpLmZvckVhY2goZnVuY3Rpb24obWVkaWFFbGVtZW50KSB7XG4gKiAgICAgbWVkaWFFbGVtZW50LnJlbW92ZSgpO1xuICogICB9KTtcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBjb25uZWN0UGFydGljaXBhbnQocm9vbSwgcGFydGljaXBhbnRTaWduYWxpbmcpIHtcbiAgICB2YXIgbG9nID0gcm9vbS5fbG9nLCBjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgPSByb29tLl9jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wsIGNvbnRlbnRQcmVmZXJlbmNlc01vZGUgPSByb29tLl9jb250ZW50UHJlZmVyZW5jZXNNb2RlO1xuICAgIHZhciBwYXJ0aWNpcGFudCA9IG5ldyBSZW1vdGVQYXJ0aWNpcGFudChwYXJ0aWNpcGFudFNpZ25hbGluZywgeyBsb2c6IGxvZywgY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sOiBjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wsIGNvbnRlbnRQcmVmZXJlbmNlc01vZGU6IGNvbnRlbnRQcmVmZXJlbmNlc01vZGUgfSk7XG4gICAgbG9nLmluZm8oJ0EgbmV3IFJlbW90ZVBhcnRpY2lwYW50IGNvbm5lY3RlZDonLCBwYXJ0aWNpcGFudCk7XG4gICAgcm9vbS5fcGFydGljaXBhbnRzLnNldChwYXJ0aWNpcGFudC5zaWQsIHBhcnRpY2lwYW50KTtcbiAgICByb29tLmVtaXQoJ3BhcnRpY2lwYW50Q29ubmVjdGVkJywgcGFydGljaXBhbnQpO1xuICAgIC8vIFJlZW1pdCBUcmFjayBhbmQgUmVtb3RlUGFydGljaXBhbnQgZXZlbnRzLlxuICAgIHZhciBldmVudExpc3RlbmVycyA9IFtcbiAgICAgICAgWydyZWNvbm5lY3RlZCcsICdwYXJ0aWNpcGFudFJlY29ubmVjdGVkJ10sXG4gICAgICAgIFsncmVjb25uZWN0aW5nJywgJ3BhcnRpY2lwYW50UmVjb25uZWN0aW5nJ10sXG4gICAgICAgICd0cmFja0RpbWVuc2lvbnNDaGFuZ2VkJyxcbiAgICAgICAgJ3RyYWNrRGlzYWJsZWQnLFxuICAgICAgICAndHJhY2tFbmFibGVkJyxcbiAgICAgICAgJ3RyYWNrTWVzc2FnZScsXG4gICAgICAgICd0cmFja1B1Ymxpc2hlZCcsXG4gICAgICAgICd0cmFja1B1Ymxpc2hQcmlvcml0eUNoYW5nZWQnLFxuICAgICAgICAndHJhY2tTdGFydGVkJyxcbiAgICAgICAgJ3RyYWNrU3Vic2NyaWJlZCcsXG4gICAgICAgICd0cmFja1N1YnNjcmlwdGlvbkZhaWxlZCcsXG4gICAgICAgICd0cmFja1N3aXRjaGVkT2ZmJyxcbiAgICAgICAgJ3RyYWNrU3dpdGNoZWRPbicsXG4gICAgICAgICd0cmFja1VucHVibGlzaGVkJyxcbiAgICAgICAgJ3RyYWNrVW5zdWJzY3JpYmVkJ1xuICAgIF0ubWFwKGZ1bmN0aW9uIChldmVudE9yUGFpcikge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoQXJyYXkuaXNBcnJheShldmVudE9yUGFpcilcbiAgICAgICAgICAgID8gZXZlbnRPclBhaXJcbiAgICAgICAgICAgIDogW2V2ZW50T3JQYWlyLCBldmVudE9yUGFpcl0sIDIpLCBldmVudCA9IF9hWzBdLCBwYXJ0aWNpcGFudEV2ZW50ID0gX2FbMV07XG4gICAgICAgIGZ1bmN0aW9uIHJlZW1pdCgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KHBhcnRpY2lwYW50RXZlbnQpO1xuICAgICAgICAgICAgYXJncy5wdXNoKHBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgIHJvb20uZW1pdC5hcHBseShyb29tLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncykpKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0aWNpcGFudC5vbihldmVudCwgcmVlbWl0KTtcbiAgICAgICAgcmV0dXJuIFtldmVudCwgcmVlbWl0XTtcbiAgICB9KTtcbiAgICBwYXJ0aWNpcGFudC5vbmNlKCdkaXNjb25uZWN0ZWQnLCBmdW5jdGlvbiBwYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdmFyIGRvbWluYW50U3BlYWtlciA9IHJvb20uZG9taW5hbnRTcGVha2VyO1xuICAgICAgICBsb2cuaW5mbygnUmVtb3RlUGFydGljaXBhbnQgZGlzY29ubmVjdGVkOicsIHBhcnRpY2lwYW50KTtcbiAgICAgICAgcm9vbS5fcGFydGljaXBhbnRzLmRlbGV0ZShwYXJ0aWNpcGFudC5zaWQpO1xuICAgICAgICBldmVudExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICBwYXJ0aWNpcGFudC5yZW1vdmVMaXN0ZW5lcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb20uZW1pdCgncGFydGljaXBhbnREaXNjb25uZWN0ZWQnLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIGlmIChwYXJ0aWNpcGFudCA9PT0gZG9taW5hbnRTcGVha2VyKSB7XG4gICAgICAgICAgICByb29tLmVtaXQoJ2RvbWluYW50U3BlYWtlckNoYW5nZWQnLCByb29tLmRvbWluYW50U3BlYWtlcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVJlY29yZGluZ0V2ZW50cyhyb29tLCByZWNvcmRpbmcpIHtcbiAgICByZWNvcmRpbmcub24oJ3VwZGF0ZWQnLCBmdW5jdGlvbiB1cGRhdGVkKCkge1xuICAgICAgICB2YXIgc3RhcnRlZCA9IHJlY29yZGluZy5pc0VuYWJsZWQ7XG4gICAgICAgIHJvb20uX2xvZy5pbmZvKFwiUmVjb3JkaW5nIFwiICsgKHN0YXJ0ZWQgPyAnc3RhcnRlZCcgOiAnc3RvcHBlZCcpKTtcbiAgICAgICAgcm9vbS5lbWl0KFwicmVjb3JkaW5nXCIgKyAoc3RhcnRlZCA/ICdTdGFydGVkJyA6ICdTdG9wcGVkJykpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlU2lnbmFsaW5nRXZlbnRzKHJvb20sIHNpZ25hbGluZykge1xuICAgIHZhciBsb2cgPSByb29tLl9sb2c7XG4gICAgLy8gUmVlbWl0IFJlbW90ZVBhcnRpY2lwYW50IGV2ZW50cyBmcm9tIHRoZSBSb29tU2lnbmFsaW5nLlxuICAgIGxvZy5kZWJ1ZygnQ3JlYXRpbmcgYSBuZXcgUmVtb3RlUGFydGljaXBhbnQgZm9yIGVhY2ggUGFydGljaXBhbnRTaWduYWxpbmcgJ1xuICAgICAgICArICdpbiB0aGUgUm9vbVNpZ25hbGluZycpO1xuICAgIHNpZ25hbGluZy5wYXJ0aWNpcGFudHMuZm9yRWFjaChjb25uZWN0UGFydGljaXBhbnQuYmluZChudWxsLCByb29tKSk7XG4gICAgbG9nLmRlYnVnKCdTZXR0aW5nIHVwIFJlbW90ZVBhcnRpY2lwYW50IGNyZWF0aW9uIGZvciBhbGwgc3Vic2VxdWVudCAnXG4gICAgICAgICsgJ1BhcnRpY2lwYW50U2lnbmFsaW5ncyB0aGF0IGNvbm5lY3QgdG8gdGhlIFJvb21TaWduYWxpbmcnKTtcbiAgICBzaWduYWxpbmcub24oJ3BhcnRpY2lwYW50Q29ubmVjdGVkJywgY29ubmVjdFBhcnRpY2lwYW50LmJpbmQobnVsbCwgcm9vbSkpO1xuICAgIHNpZ25hbGluZy5vbignZG9taW5hbnRTcGVha2VyQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvb20uZW1pdCgnZG9taW5hbnRTcGVha2VyQ2hhbmdlZCcsIHJvb20uZG9taW5hbnRTcGVha2VyKTsgfSk7XG4gICAgLy8gUmVlbWl0IHN0YXRlIHRyYW5zaXRpb24gZXZlbnRzIGZyb20gdGhlIFJvb21TaWduYWxpbmcuXG4gICAgc2lnbmFsaW5nLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBzdGF0ZUNoYW5nZWQoc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIGxvZy5pbmZvKCdUcmFuc2l0aW9uZWQgdG8gc3RhdGU6Jywgc3RhdGUpO1xuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgIHJvb20ucGFydGljaXBhbnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50Ll91bnN1YnNjcmliZVRyYWNrcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJvb20uZW1pdChzdGF0ZSwgcm9vbSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaChmdW5jdGlvbiAocHVibGljYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcHVibGljYXRpb24udW5wdWJsaXNoKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2lnbmFsaW5nLnJlbW92ZUxpc3RlbmVyKCdzdGF0ZUNoYW5nZWQnLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogYHN0YXRlQ2hhbmdlZGAgY2FuIGdldCBlbWl0dGVkIHdpdGggU3RhdGVNYWNoaW5lIGxvY2tlZC5cbiAgICAgICAgICAgICAgICAvLyBEbyBub3Qgc2lnbmFsICBwdWJsaWMgZXZlbnRzIHN5bmNocm9ub3VzbHkgd2l0aCBsb2NrIGhlbGQuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiByb29tLmVtaXQoJ3JlY29ubmVjdGluZycsIGVycm9yKTsgfSwgMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBgc3RhdGVDaGFuZ2VkYCBjYW4gZ2V0IGVtaXR0ZWQgd2l0aCBTdGF0ZU1hY2hpbmUgbG9ja2VkLlxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBzaWduYWwgIHB1YmxpYyBldmVudHMgc3luY2hyb25vdXNseSB3aXRoIGxvY2sgaGVsZC5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvb20uZW1pdCgncmVjb25uZWN0ZWQnKTsgfSwgMCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gUm9vbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvb20uanMubWFwIiwiLyogZXNsaW50IGNvbnNpc3RlbnQtcmV0dXJuOjAgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgUGFydGljaXBhbnRTaWduYWxpbmcgPSByZXF1aXJlKCcuL3BhcnRpY2lwYW50Jyk7XG52YXIgUm9vbVNpZ25hbGluZyA9IHJlcXVpcmUoJy4vcm9vbScpO1xudmFyIFN0YXRlTWFjaGluZSA9IHJlcXVpcmUoJy4uL3N0YXRlbWFjaGluZScpO1xuLypcblNpZ25hbGluZyBTdGF0ZXNcbi0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICArLS0tLS0tLS0tK1xuICAgICAgICAgICAgICB8ICAgICAgICAgfFxuICAgICAgICAgICAgICB8IG9wZW5pbmcgfFxuICAgICAgICAgKy0tLT58ICAgICAgICAgfFxuICAgICAgICAgfCAgICArLS0tLS0tLS0tK1xuICAgICstLS0tLS0tLSsgICB8ICAgfCAgICstLS0tLS0rXG4gICAgfCAgICAgICAgfDwtLSsgICArLS0+fCAgICAgIHxcbiAgICB8IGNsb3NlZCB8PC0tLS0tLS0tLS18IG9wZW4gfFxuICAgIHwgICAgICAgIHw8LS0rICAgKy0tPnwgICAgICB8XG4gICAgKy0tLS0tLS0tKyAgIHwgICB8ICAgKy0tLS0tLStcbiAgICAgICAgICAgICAgKy0tLS0tLS0tLSsgICB8XG4gICAgICAgICAgICAgIHwgICAgICAgICB8PC0tK1xuICAgICAgICAgICAgICB8IGNsb3NpbmcgfFxuICAgICAgICAgICAgICB8ICAgICAgICAgfFxuICAgICAgICAgICAgICArLS0tLS0tLS0tK1xuXG4qL1xudmFyIHN0YXRlcyA9IHtcbiAgICBjbG9zZWQ6IFtcbiAgICAgICAgJ29wZW5pbmcnXG4gICAgXSxcbiAgICBvcGVuaW5nOiBbXG4gICAgICAgICdjbG9zZWQnLFxuICAgICAgICAnb3BlbidcbiAgICBdLFxuICAgIG9wZW46IFtcbiAgICAgICAgJ2Nsb3NlZCcsXG4gICAgICAgICdjbG9zaW5nJ1xuICAgIF0sXG4gICAgY2xvc2luZzogW1xuICAgICAgICAnY2xvc2VkJyxcbiAgICAgICAgJ29wZW4nXG4gICAgXVxufTtcbi8qKlxuICogQGV4dGVuZHMgU3RhdGVNYWNoaW5lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBvbmUgb2YgXCJjbG9zZWRcIiwgXCJvcGVuaW5nXCIsIFwib3BlblwiLCBvciBcImNsb3NpbmdcIlxuICovXG52YXIgU2lnbmFsaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWduYWxpbmcsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IHtAbGluayBTaWduYWxpbmd9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpZ25hbGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdjbG9zZWQnLCBzdGF0ZXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgLy8gTk9URShtcm9iZXJ0cyk6IFRoaXMgaXMgYSBkdW1teSBpbXBsZW1lbnRhdGlvbiBzdWl0YWJsZSBmb3IgdGVzdGluZy5cbiAgICBTaWduYWxpbmcucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKCdjbG9zaW5nJywga2V5KTtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKCdjbG9zZWQnLCBrZXkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAvLyBOT1RFKG1yb2JlcnRzKTogVGhpcyBpcyBhIGR1bW15IGltcGxlbWVudGF0aW9uIHN1aXRhYmxlIGZvciB0ZXN0aW5nLlxuICAgIFNpZ25hbGluZy5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbiAobG9jYWxQYXJ0aWNpcGFudCwgdG9rZW4sIGVuY29kaW5nUGFyYW1ldGVycywgcHJlZmVycmVkQ29kZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIGxvY2FsUGFydGljaXBhbnQuY29ubmVjdCgnUEEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsICd0ZXN0Jyk7XG4gICAgICAgIHZhciBzaWQgPSAnUk0wMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCc7XG4gICAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG5ldyBSb29tU2lnbmFsaW5nKGxvY2FsUGFydGljaXBhbnQsIHNpZCwgb3B0aW9ucykpO1xuICAgICAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHsgfTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIC8vIE5PVEUobXJvYmVydHMpOiBUaGlzIGlzIGEgZHVtbXkgaW1wbGVtZW50YXRpb24gc3VpdGFibGUgZm9yIHRlc3RpbmcuXG4gICAgU2lnbmFsaW5nLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKCdvcGVuaW5nJywga2V5KTtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKCdvcGVuJywga2V5KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSB7QGxpbmsgU2lnbmFsaW5nfS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx0aGlzPn1cbiAgICAgKi9cbiAgICBTaWduYWxpbmcucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5icmFja2V0KCdjbG9zZScsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX3RoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY2xvc2Uoa2V5KTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFNpZ25hbGluZyBzdGF0ZSBcXFwiXCIgKyBfdGhpcy5zdGF0ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIGEge0BsaW5rIFJvb21TaWduYWxpbmd9LlxuICAgICAqIEBwYXJhbSB7UGFydGljaXBhbnRTaWduYWxpbmd9IGxvY2FsUGFydGljaXBhbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAgICAgKiBAcGFyYW0ge0VuY29kaW5nUGFyYW1ldGVyc0ltcGx9IGVuY29kaW5nUGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7UHJlZmVycmVkQ29kZWNzfSBwcmVmZXJyZWRDb2RlY3NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGZ1bmN0aW9uKCk6IENhbmNlbGFibGVQcm9taXNlPFJvb21TaWduYWxpbmc+Pn1cbiAgICAgKi9cbiAgICBTaWduYWxpbmcucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAobG9jYWxQYXJ0aWNpcGFudCwgdG9rZW4sIGVuY29kaW5nUGFyYW1ldGVycywgcHJlZmVycmVkQ29kZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJhY2tldCgnY29ubmVjdCcsIGZ1bmN0aW9uIHRyYW5zaXRpb24oa2V5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNlbGYuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb3BlbihrZXkpLnRoZW4odHJhbnNpdGlvbi5iaW5kKG51bGwsIGtleSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFKG1yb2JlcnRzKTogV2UgZG9uJ3QgbmVlZCB0byBob2xkIHRoZSBsb2NrIGluIF9jb25uZWN0LiBJbnN0ZWFkLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IG5lZWQgdG8gZW5zdXJlIHRoZSBTaWduYWxpbmcgcmVtYWlucyBvcGVuLlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbGVhc2VMb2NrQ29tcGxldGVseShrZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fY29ubmVjdChsb2NhbFBhcnRpY2lwYW50LCB0b2tlbiwgZW5jb2RpbmdQYXJhbWV0ZXJzLCBwcmVmZXJyZWRDb2RlY3MsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgU2lnbmFsaW5nIHN0YXRlIFxcXCJcIiArIHNlbGYuc3RhdGUgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbG9jYWwge0BsaW5rIFBhcnRpY2lwYW50U2lnbmFsaW5nfS5cbiAgICAgKiBAcmV0dXJucyB7UGFydGljaXBhbnRTaWduYWxpbmd9XG4gICAgICovXG4gICAgU2lnbmFsaW5nLnByb3RvdHlwZS5jcmVhdGVMb2NhbFBhcnRpY2lwYW50U2lnbmFsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50U2lnbmFsaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSB7QGxpbmsgU2lnbmFsaW5nfS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx0aGlzPn1cbiAgICAgKi9cbiAgICBTaWduYWxpbmcucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmJyYWNrZXQoJ29wZW4nLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF90aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9vcGVuKGtleSk7XG4gICAgICAgICAgICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFNpZ25hbGluZyBzdGF0ZSBcXFwiXCIgKyBfdGhpcy5zdGF0ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2lnbmFsaW5nO1xufShTdGF0ZU1hY2hpbmUpKTtcbm1vZHVsZS5leHBvcnRzID0gU2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBQYXJ0aWNpcGFudFNpZ25hbGluZyA9IHJlcXVpcmUoJy4vcGFydGljaXBhbnQnKTtcbnZhciBMb2NhbFBhcnRpY2lwYW50U2lnbmFsaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhbFBhcnRpY2lwYW50U2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExvY2FsUGFydGljaXBhbnRTaWduYWxpbmcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfcHVibGljYXRpb25zVG9UcmFja1NlbmRlcnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RyYWNrU2VuZGVyc1RvUHVibGljYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGFUcmFja1NlbmRlcnxNZWRpYVRyYWNrU2VuZGVyfSB0cmFja1NlbmRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtUcmFjay5Qcmlvcml0eX0gcHJpb3JpdHlcbiAgICAgKiBAcmV0dXJucyB7TG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfSBwdWJsaWNhdGlvblxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnRTaWduYWxpbmcucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gKHRyYWNrU2VuZGVyLCBuYW1lLCBwcmlvcml0eSkge1xuICAgICAgICB2YXIgcHVibGljYXRpb24gPSB0aGlzLl9jcmVhdGVMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmcodHJhY2tTZW5kZXIsIG5hbWUsIHByaW9yaXR5KTtcbiAgICAgICAgdGhpcy5fdHJhY2tTZW5kZXJzVG9QdWJsaWNhdGlvbnMuc2V0KHRyYWNrU2VuZGVyLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIHRoaXMuX3B1YmxpY2F0aW9uc1RvVHJhY2tTZW5kZXJzLnNldChwdWJsaWNhdGlvbiwgdHJhY2tTZW5kZXIpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmFkZFRyYWNrLmNhbGwodGhpcywgcHVibGljYXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0YVRyYWNrU2VuZGVyfE1lZGlhVHJhY2tTZW5kZXJ9IHRyYWNrU2VuZGVyXG4gICAgICogQHJldHVybnMgez9Mb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZy5wcm90b3R5cGUuZ2V0UHVibGljYXRpb24gPSBmdW5jdGlvbiAodHJhY2tTZW5kZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrU2VuZGVyc1RvUHVibGljYXRpb25zLmdldCh0cmFja1NlbmRlcikgfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfSB0cmFja1B1YmxpY2F0aW9uXG4gICAgICogQHJldHVybnMgez9EYXRhVHJhY2tTZW5kZXJ8TWVkaWFUcmFja1NlbmRlcn1cbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50U2lnbmFsaW5nLnByb3RvdHlwZS5nZXRTZW5kZXIgPSBmdW5jdGlvbiAodHJhY2tQdWJsaWNhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHVibGljYXRpb25zVG9UcmFja1NlbmRlcnMuZ2V0KHRyYWNrUHVibGljYXRpb24pIHx8IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGFUcmFja1NlbmRlcnxNZWRpYVRyYWNrU2VuZGVyfSB0cmFja1NlbmRlclxuICAgICAqIEByZXR1cm5zIHs/TG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nfVxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnRTaWduYWxpbmcucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gKHRyYWNrU2VuZGVyKSB7XG4gICAgICAgIHZhciBwdWJsaWNhdGlvbiA9IHRoaXMuX3RyYWNrU2VuZGVyc1RvUHVibGljYXRpb25zLmdldCh0cmFja1NlbmRlcik7XG4gICAgICAgIGlmICghcHVibGljYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYWNrU2VuZGVyc1RvUHVibGljYXRpb25zLmRlbGV0ZSh0cmFja1NlbmRlcik7XG4gICAgICAgIHRoaXMuX3B1YmxpY2F0aW9uc1RvVHJhY2tTZW5kZXJzLmRlbGV0ZShwdWJsaWNhdGlvbik7XG4gICAgICAgIHZhciBkaWREZWxldGUgPSBfc3VwZXIucHJvdG90eXBlLnJlbW92ZVRyYWNrLmNhbGwodGhpcywgcHVibGljYXRpb24pO1xuICAgICAgICBpZiAoZGlkRGVsZXRlKSB7XG4gICAgICAgICAgICBwdWJsaWNhdGlvbi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2FsUGFydGljaXBhbnRTaWduYWxpbmc7XG59KFBhcnRpY2lwYW50U2lnbmFsaW5nKSk7XG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsUGFydGljaXBhbnRTaWduYWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbHBhcnRpY2lwYW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgVHJhY2tTaWduYWxpbmcgPSByZXF1aXJlKCcuL3RyYWNrJyk7XG4vKipcbiAqIEEge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvbn0gaW1wbGVtZW50YXRpb25cbiAqIEBleHRlbmRzIFRyYWNrU2lnbmFsaW5nXG4gKiBAcHJvcGVydHkge1RyYWNrLklEfSBpZFxuICovXG52YXIgTG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmcsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ30uIHtAbGluayBUcmFja1NlbmRlcnN9XG4gICAgICogYXJlIGFsd2F5cyBjbG9uZWQuXG4gICAgICogQHBhcmFtIHtEYXRhVHJhY2tTZW5kZXJ8TWVkaWFUcmFja1NlbmRlcn0gdHJhY2tTZW5kZXIgLSB0aGUge0BsaW5rIFRyYWNrU2VuZGVyfVxuICAgICAqICAgb2YgdGhlIHtAbGluayBMb2NhbFRyYWNrfSB0byBiZSBwdWJsaXNoZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB7QGxpbmsgTG9jYWxUcmFja30gdG8gYmUgcHVibGlzaGVkXG4gICAgICogQHBhcmFtIHtUcmFjay5Qcmlvcml0eX0gcHJpb3JpdHkgLSBpbml0aWFsIHtAbGluayBUcmFjay5Qcmlvcml0eX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmcodHJhY2tTZW5kZXIsIG5hbWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRyYWNrU2VuZGVyID0gdHJhY2tTZW5kZXIuY2xvbmUoKTtcbiAgICAgICAgdmFyIGVuYWJsZWQgPSB0cmFja1NlbmRlci5raW5kID09PSAnZGF0YScgPyB0cnVlIDogdHJhY2tTZW5kZXIudHJhY2suZW5hYmxlZDtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCB0cmFja1NlbmRlci5raW5kLCBlbmFibGVkLCBwcmlvcml0eSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2V0VHJhY2tUcmFuc2NlaXZlcih0cmFja1NlbmRlcik7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfdXBkYXRlZFByaW9yaXR5OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHByaW9yaXR5LFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0cmFja1NlbmRlci5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nLnByb3RvdHlwZSwgXCJ1cGRhdGVkUHJpb3JpdHlcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVwZGF0ZWQge0BsaW5rIFRyYWNrLlByaW9yaXR5fSBvZiB0aGUge0BsaW5rIExvY2FsVHJhY2t9LlxuICAgICAgICAgKiBAcHJvcGVydHkge1RyYWNrLnByaW9yaXR5fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlZFByaW9yaXR5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRW5hYmxlIChvciBkaXNhYmxlKSB0aGUge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ30gaWYgaXQgaXMgbm90XG4gICAgICogYWxyZWFkeSBlbmFibGVkIChvciBkaXNhYmxlZCkuIFRoaXMgYWxzbyB1cGRhdGVzIHRoZSBjbG9uZWRcbiAgICAgKiB7QGxpbmsgTWVkaWFUcmFja1NlbmRlcn0ncyBNZWRpYVN0cmVhbVRyYWNrcyBgZW5hYmxlZGAgc3RhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZW5hYmxlZD10cnVlXVxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG4gICAgTG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICBlbmFibGVkID0gdHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJyA/IGVuYWJsZWQgOiB0cnVlO1xuICAgICAgICB0aGlzLnRyYWNrVHJhbnNjZWl2ZXIudHJhY2suZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMsIGVuYWJsZWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVqZWN0cyB0aGUgU0lEJ3MgZGVmZXJyZWQgcHJvbWlzZSB3aXRoIHRoZSBnaXZlbiBFcnJvci5cbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZy5wcm90b3R5cGUucHVibGlzaEZhaWxlZCA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAoc2V0RXJyb3IodGhpcywgZXJyb3IpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUge0BsaW5rIFRyYWNrLlByaW9yaXR5fSBvZiB0aGUgcHVibGlzaGVkIHtAbGluayBMb2NhbFRyYWNrfS5cbiAgICAgKiBAcGFyYW0ge1RyYWNrLnByaW9yaXR5fSBwcmlvcml0eVxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZy5wcm90b3R5cGUuc2V0UHJpb3JpdHkgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZWRQcmlvcml0eSAhPT0gcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZWRQcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHB1Ymxpc2hlZCB7QGxpbmsgTG9jYWxUcmFja30ncyB7QGxpbmsgVHJhY2suU0lEfS5cbiAgICAgKiBAcGFyYW0ge1RyYWNrLlNJRH0gc2lkXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgTG9jYWxUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nLnByb3RvdHlwZS5zZXRTaWQgPSBmdW5jdGlvbiAoc2lkKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc2V0U2lkLmNhbGwodGhpcywgc2lkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIGNsb25lZCB7QGxpbmsgVHJhY2tTZW5kZXJ9LlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmFja1RyYW5zY2VpdmVyLnN0b3AoKTtcbiAgICB9O1xuICAgIHJldHVybiBMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmc7XG59KFRyYWNrU2lnbmFsaW5nKSk7XG4vKipcbiAqIEBwYXJhbSB7TG9jYWxUcmFja1B1YmxpY2F0aW9ufSBwdWJsaWNhdGlvblxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqIEByZXR1cm5zIHtib29sZWFufSB1cGRhdGVkXG4gKi9cbmZ1bmN0aW9uIHNldEVycm9yKHB1YmxpY2F0aW9uLCBlcnJvcikge1xuICAgIGlmIChwdWJsaWNhdGlvbi5fc2lkICE9PSBudWxsIHx8IHB1YmxpY2F0aW9uLl9lcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHB1YmxpY2F0aW9uLl9lcnJvciA9IGVycm9yO1xuICAgIHJldHVybiB0cnVlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbHRyYWNrcHVibGljYXRpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBTdGF0ZU1hY2hpbmUgPSByZXF1aXJlKCcuLi9zdGF0ZW1hY2hpbmUnKTtcbnZhciBOZXR3b3JrUXVhbGl0eVN0YXRzID0gcmVxdWlyZSgnLi4vc3RhdHMvbmV0d29ya3F1YWxpdHlzdGF0cycpO1xuLypcblBhcnRpY2lwYW50U2lnbmFsaW5nIFN0YXRlc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgKy0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLStcbiAgICB8ICAgICAgICAgICAgfCAgICAgfCAgICAgICAgICAgfCAgICAgfCAgICAgICAgICAgICAgfFxuICAgIHwgY29ubmVjdGluZyB8LS0tLT58IGNvbm5lY3RlZCB8LS0tLT58IGRpc2Nvbm5lY3RlZCB8XG4gICAgfCAgICAgICAgICAgIHwgICAgIHwgICAgICAgICAgIHwgICAgIHwgICAgICAgICAgICAgIHxcbiAgICArLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBeICAgICAgICAgICAgICAgICAgICBeXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgICstLS0tLS0tLS0tLS0tLSsgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgfC0tfCAgICAgICAgICAgICAgfCAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLT58IHJlY29ubmVjdGluZyB8LS18XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuKi9cbnZhciBzdGF0ZXMgPSB7XG4gICAgY29ubmVjdGluZzogW1xuICAgICAgICAnY29ubmVjdGVkJ1xuICAgIF0sXG4gICAgY29ubmVjdGVkOiBbXG4gICAgICAgICdkaXNjb25uZWN0ZWQnLFxuICAgICAgICAncmVjb25uZWN0aW5nJ1xuICAgIF0sXG4gICAgcmVjb25uZWN0aW5nOiBbXG4gICAgICAgICdjb25uZWN0ZWQnLFxuICAgICAgICAnZGlzY29ubmVjdGVkJ1xuICAgIF0sXG4gICAgZGlzY29ubmVjdGVkOiBbXVxufTtcbi8qKlxuICogQSB7QGxpbmsgUGFydGljaXBhbnR9IGltcGxlbWVudGF0aW9uXG4gKiBAZXh0ZW5kcyBTdGF0ZU1hY2hpbmVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gaWRlbnRpdHlcbiAqIEBwcm9wZXJ0eSB7P1BhcnRpY2lwYW50LlNJRH0gc2lkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBcImNvbm5lY3RpbmdcIiwgXCJjb25uZWN0ZWRcIiwgb3IgXCJkaXNjb25uZWN0ZWRcIlxuICogQHByb3BlcnR5IHtNYXA8VHJhY2suSUQgfCBUcmFjay5TSUQsIFRyYWNrU2lnbmFsaW5nPn0gdHJhY2tzXG4gKiBAZW1pdHMgUGFydGljaXBhbnRTaWduYWxpbmcjbmV0d29ya1F1YWxpdHlMZXZlbENoYW5nZWRcbiAqIEBlbWl0cyBQYXJ0aWNpcGFudFNpZ25hbGluZyN0cmFja0FkZGVkXG4gKiBAZW1pdHMgUGFydGljaXBhbnRTaWduYWxpbmcjdHJhY2tSZW1vdmVkXG4gKi9cbnZhciBQYXJ0aWNpcGFudFNpZ25hbGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFydGljaXBhbnRTaWduYWxpbmcsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFBhcnRpY2lwYW50U2lnbmFsaW5nfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXJ0aWNpcGFudFNpZ25hbGluZygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ2Nvbm5lY3RpbmcnLCBzdGF0ZXMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfaWRlbnRpdHk6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9uZXR3b3JrUXVhbGl0eUxldmVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbmV0d29ya1F1YWxpdHlTdGF0czoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NpZDoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWRlbnRpdHk6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faWRlbnRpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYWNrczoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFydGljaXBhbnRTaWduYWxpbmcucHJvdG90eXBlLCBcIm5ldHdvcmtRdWFsaXR5TGV2ZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfSwgaWYgYW55LlxuICAgICAgICAgKiBAcmV0dXJucyB7P05ldHdvcmtRdWFsaXR5TGV2ZWx9IG5ldHdvcmtRdWFsaXR5TGV2ZWwgLSBpbml0aWFsbHkgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29ya1F1YWxpdHlMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXJ0aWNpcGFudFNpZ25hbGluZy5wcm90b3R5cGUsIFwibmV0d29ya1F1YWxpdHlTdGF0c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQge0BsaW5rIE5ldHdvcmtRdWFsaXR5U3RhdHN9XG4gICAgICAgICAqIEByZXR1cm5zIHs/TmV0d29ya1F1YWxpdHlTdGF0c30gbmV0d29ya1F1YWxpdHlTdGF0cyAtIGluaXRpYWxseSBudWxsXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZXR3b3JrUXVhbGl0eVN0YXRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSB7QGxpbmsgVHJhY2tTaWduYWxpbmd9LCBNZWRpYVN0cmVhbVRyYWNrLCBvclxuICAgICAqIHtAbGluayBEYXRhVHJhY2tTZW5kZXJ9IHRvIHRoZSB7QGxpbmsgUGFydGljaXBhbnRTaWduYWxpbmd9LlxuICAgICAqIEBwYXJhbSB7VHJhY2tTaWduYWxpbmd8RGF0YVRyYWNrU2VuZGVyfE1lZGlhVHJhY2tTZW5kZXJ9IHRyYWNrXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGZpcmVzIFBhcnRpY2lwYW50U2lnbmFsaW5nI3RyYWNrQWRkZWRcbiAgICAgKi9cbiAgICBQYXJ0aWNpcGFudFNpZ25hbGluZy5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdGhpcy50cmFja3Muc2V0KHRyYWNrLmlkIHx8IHRyYWNrLnNpZCwgdHJhY2spO1xuICAgICAgICB0aGlzLmVtaXQoJ3RyYWNrQWRkZWQnLCB0cmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCB0aGUge0BsaW5rIFBhcnRpY2lwYW50U2lnbmFsaW5nfS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBQYXJ0aWNpcGFudFNpZ25hbGluZy5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnByZWVtcHQoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSB7QGxpbmsgVHJhY2tTaWduYWxpbmd9LCBNZWRpYVN0cmVhbVRyYWNrLCBvclxuICAgICAqIHtAbGluayBEYXRhVHJhY2tTZW5kZXJ9IGZyb20gdGhlIHtAbGluayBQYXJ0aWNpcGFudFNpZ25hbGluZ30uXG4gICAgICogQHBhcmFtIHtUcmFja1NpZ25hbGluZ3xEYXRhVHJhY2tTZW5kZXJ8TWVkaWFUcmFja1NlbmRlcn0gdHJhY2tcbiAgICAgKiBAcmV0dXJucyB7P1RyYWNrU2lnbmFsaW5nfVxuICAgICAqIEBmaXJlcyBQYXJ0aWNpcGFudFNpZ25hbGluZyN0cmFja1JlbW92ZWRcbiAgICAgKi9cbiAgICBQYXJ0aWNpcGFudFNpZ25hbGluZy5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFyIHNpZ25hbGluZyA9IHRoaXMudHJhY2tzLmdldCh0cmFjay5pZCB8fCB0cmFjay5zaWQpO1xuICAgICAgICB0aGlzLnRyYWNrcy5kZWxldGUodHJhY2suaWQgfHwgdHJhY2suc2lkKTtcbiAgICAgICAgaWYgKHNpZ25hbGluZykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd0cmFja1JlbW92ZWQnLCB0cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25hbGluZyB8fCBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZXR3b3JrUXVhbGl0eUxldmVsfSBuZXR3b3JrUXVhbGl0eUxldmVsXG4gICAgICogQHBhcmFtIHs/TmV0d29ya1F1YWxpdHlMZXZlbHN9IFtuZXR3b3JrUXVhbGl0eUxldmVscz1udWxsXVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFBhcnRpY2lwYW50U2lnbmFsaW5nLnByb3RvdHlwZS5zZXROZXR3b3JrUXVhbGl0eUxldmVsID0gZnVuY3Rpb24gKG5ldHdvcmtRdWFsaXR5TGV2ZWwsIG5ldHdvcmtRdWFsaXR5TGV2ZWxzKSB7XG4gICAgICAgIGlmICh0aGlzLl9uZXR3b3JrUXVhbGl0eUxldmVsICE9PSBuZXR3b3JrUXVhbGl0eUxldmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXR3b3JrUXVhbGl0eUxldmVsID0gbmV0d29ya1F1YWxpdHlMZXZlbDtcbiAgICAgICAgICAgIHRoaXMuX25ldHdvcmtRdWFsaXR5U3RhdHMgPSBuZXR3b3JrUXVhbGl0eUxldmVsc1xuICAgICAgICAgICAgICAgICYmIChuZXR3b3JrUXVhbGl0eUxldmVscy5hdWRpbyB8fCBuZXR3b3JrUXVhbGl0eUxldmVscy52aWRlbylcbiAgICAgICAgICAgICAgICA/IG5ldyBOZXR3b3JrUXVhbGl0eVN0YXRzKG5ldHdvcmtRdWFsaXR5TGV2ZWxzKVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnbmV0d29ya1F1YWxpdHlMZXZlbENoYW5nZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0aGUge0BsaW5rIFBhcnRpY2lwYW50U2lnbmFsaW5nfS5cbiAgICAgKiBAcGFyYW0ge1BhcnRpY2lwYW50LlNJRH0gc2lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aXR5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgUGFydGljaXBhbnRTaWduYWxpbmcucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoc2lkLCBpZGVudGl0eSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnIHx8IHRoaXMuc3RhdGUgPT09ICdyZWNvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NpZCA9IHNpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faWRlbnRpdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmVlbXB0KCdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zaXRpb24gdG8gXCJyZWNvbm5lY3RpbmdcIiBzdGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBQYXJ0aWNpcGFudFNpZ25hbGluZy5wcm90b3R5cGUucmVjb25uZWN0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnIHx8IHRoaXMuc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnByZWVtcHQoJ3JlY29ubmVjdGluZycpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnRpY2lwYW50U2lnbmFsaW5nO1xufShTdGF0ZU1hY2hpbmUpKTtcbi8qKlxuICogQGV2ZW50IFBhcnRpY2lwYW50U2lnbmFsaW5nI2V2ZW50Om5ldHdvcmtRdWFsaXR5TGV2ZWxDaGFuZ2VkXG4gKi9cbi8qKlxuICoge0BsaW5rIFRyYWNrU2lnbmFsaW5nfSB3YXMgYWRkZWQgdG8gdGhlIHtAbGluayBQYXJ0aWNpcGFudFNpZ25hbGluZ30uXG4gKiBAZXZlbnQgUGFydGljaXBhbnRTaWduYWxpbmcjdHJhY2tBZGRlZFxuICogQHBhcmFtIHtUcmFja1NpZ25hbGluZ30gdHJhY2tcbiAqL1xuLyoqXG4gKiB7QGxpbmsgVHJhY2tTaWduYWxpbmd9IHdhcyByZW1vdmVkIGZyb20gdGhlIHtAbGluayBQYXJ0aWNpcGFudFNpZ25hbGluZ30uXG4gKiBAZXZlbnQgUGFydGljaXBhbnRTaWduYWxpbmcjdHJhY2tSZW1vdmVkXG4gKiBAcGFyYW0ge1RyYWNrU2lnbmFsaW5nfSB0cmFja1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2lwYW50U2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFydGljaXBhbnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4vKipcbiAqIFJlcHJlc2VudHMgcmVjb3JkaW5nIHN0YXRlXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGlzRW5hYmxlZFxuICovXG52YXIgUmVjb3JkaW5nU2lnbmFsaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWNvcmRpbmdTaWduYWxpbmcsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJlY29yZGluZ1NpZ25hbGluZ30uXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVjb3JkaW5nU2lnbmFsaW5nKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2lzRW5hYmxlZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNFbmFibGVkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRW5hYmxlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIHtAbGluayBSZWNvcmRpbmdTaWduYWxpbmd9IGlmIGl0IGlzIG5vdCBhbHJlYWR5IGRpc2FibGVkLlxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG4gICAgUmVjb3JkaW5nU2lnbmFsaW5nLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmFibGUoZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5hYmxlIChvciBkaXNhYmxlKSB0aGUge0BsaW5rIFJlY29yZGluZ1NpZ25hbGluZ30gaWYgaXQgaXMgbm90IGFscmVhZHkgZW5hYmxlZFxuICAgICAqIChvciBkaXNhYmxlZCkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZW5hYmxlZD10cnVlXVxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG4gICAgUmVjb3JkaW5nU2lnbmFsaW5nLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICBlbmFibGVkID0gdHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJyA/IGVuYWJsZWQgOiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQgIT09IGVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBSZWNvcmRpbmdTaWduYWxpbmc7XG59KEV2ZW50RW1pdHRlcikpO1xuLyoqXG4gKiBFbWl0dGVkIHdoZW5ldmVyIHRoZSB7QGxpbmsgUmVjb3JkaW5nU2lnbmFsaW5nfSBpcyB1cGRhdGVkXG4gKiBAZXZlbnQgUmVjb3JkaW5nU2lnbmFsaW5nI3VwZGF0ZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZWNvcmRpbmdTaWduYWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNvcmRpbmcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBQYXJ0aWNpcGFudFNpZ25hbGluZyA9IHJlcXVpcmUoJy4vcGFydGljaXBhbnQnKTtcbi8qKlxuICogQSB7QGxpbmsgUGFydGljaXBhbnR9IGltcGxlbWVudGF0aW9uXG4gKiBAZXh0ZW5kcyBQYXJ0aWNpcGFudFNpZ25hbGluZ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkZW50aXR5XG4gKiBAcHJvcGVydHkge1BhcnRpY2lwYW50LlNJRH0gc2lkXG4gKi9cbnZhciBSZW1vdGVQYXJ0aWNpcGFudFNpZ25hbGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVtb3RlUGFydGljaXBhbnRTaWduYWxpbmcsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nfS5cbiAgICAgKiBAcGFyYW0ge1BhcnRpY2lwYW50LlNJRH0gc2lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aXR5XG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVtb3RlUGFydGljaXBhbnRTaWduYWxpbmcoc2lkLCBpZGVudGl0eSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb25uZWN0KHNpZCwgaWRlbnRpdHkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZW1vdGVQYXJ0aWNpcGFudFNpZ25hbGluZztcbn0oUGFydGljaXBhbnRTaWduYWxpbmcpKTtcbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlUGFydGljaXBhbnRTaWduYWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdGVwYXJ0aWNpcGFudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFRyYWNrU2lnbmFsaW5nID0gcmVxdWlyZSgnLi90cmFjaycpO1xuLyoqXG4gKiBBIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9ufSBpbXBsZW1lbnRhdGlvblxuICogQGV4dGVuZHMgVHJhY2tTaWduYWxpbmdcbiAqL1xudmFyIFJlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmcsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9LlxuICAgICAqIEBwYXJhbSB7VHJhY2suU0lEfSBzaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7VHJhY2suS2luZH0ga2luZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbmFibGVkXG4gICAgICogQHBhcmFtIHtUcmFjay5Qcmlvcml0eX0gcHJpb3JpdHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3dpdGNoZWRPZmZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nKHNpZCwgbmFtZSwga2luZCwgaXNFbmFibGVkLCBwcmlvcml0eSwgaXNTd2l0Y2hlZE9mZikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBraW5kLCBpc0VuYWJsZWQsIHByaW9yaXR5KSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2lzU3dpdGNoZWRPZmY6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaXNTd2l0Y2hlZE9mZixcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLnNldFNpZChzaWQpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nLnByb3RvdHlwZSwgXCJpc1N1YnNjcmliZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9IGlzIHN1YnNjcmliZWQgdG8uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy50cmFja1RyYW5zY2VpdmVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmcucHJvdG90eXBlLCBcImlzU3dpdGNoZWRPZmZcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9IGlzIHN3aXRjaGVkIG9mZi5cbiAgICAgICAgICogQHByb3BlcnR5IHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNTd2l0Y2hlZE9mZjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZy5wcm90b3R5cGUuc3Vic2NyaWJlRmFpbGVkID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICghdGhpcy5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBwdWJsaXNoIHtAbGluayBUcmFjay5Qcmlvcml0eX0uXG4gICAgICogQHBhcmFtIHtUcmFjay5Qcmlvcml0eX0gcHJpb3JpdHlcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nLnByb3RvdHlwZS5zZXRQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpb3JpdHkgIT09IHByaW9yaXR5KSB7XG4gICAgICAgICAgICB0aGlzLl9wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRyYWNrIHN3aXRjaCBvbi9vZmYgc3RhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1N3aXRjaGVkT2ZmXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZy5wcm90b3R5cGUuc2V0U3dpdGNoZWRPZmYgPSBmdW5jdGlvbiAoaXNTd2l0Y2hlZE9mZikge1xuICAgICAgICBpZiAodGhpcy5faXNTd2l0Y2hlZE9mZiAhPT0gaXNTd2l0Y2hlZE9mZikge1xuICAgICAgICAgICAgdGhpcy5faXNTd2l0Y2hlZE9mZiA9IGlzU3dpdGNoZWRPZmY7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nO1xufShUcmFja1NpZ25hbGluZykpO1xubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVUcmFja1B1YmxpY2F0aW9uU2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RldHJhY2twdWJsaWNhdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIERlZmF1bHRSZWNvcmRpbmdTaWduYWxpbmcgPSByZXF1aXJlKCcuL3JlY29yZGluZycpO1xudmFyIFN0YXRlTWFjaGluZSA9IHJlcXVpcmUoJy4uL3N0YXRlbWFjaGluZScpO1xudmFyIERlZmF1bHRUaW1lb3V0ID0gcmVxdWlyZSgnLi4vdXRpbC90aW1lb3V0Jyk7XG52YXIgYnVpbGRMb2dMZXZlbHMgPSByZXF1aXJlKCcuLi91dGlsJykuYnVpbGRMb2dMZXZlbHM7XG52YXIgREVGQVVMVF9MT0dfTEVWRUwgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLkRFRkFVTFRfTE9HX0xFVkVMO1xudmFyIExvZyA9IHJlcXVpcmUoJy4uL3V0aWwvbG9nJyk7XG52YXIgX2EgPSByZXF1aXJlKCcuLi91dGlsL3R3aWxpby12aWRlby1lcnJvcnMnKSwgTWVkaWFDb25uZWN0aW9uRXJyb3IgPSBfYS5NZWRpYUNvbm5lY3Rpb25FcnJvciwgTWVkaWFEVExTVHJhbnNwb3J0RmFpbGVkRXJyb3IgPSBfYS5NZWRpYURUTFNUcmFuc3BvcnRGYWlsZWRFcnJvciwgU2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yID0gX2EuU2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yO1xudmFyIG5JbnN0YW5jZXMgPSAwO1xuLypcblJvb21TaWduYWxpbmcgU3RhdGVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgKy0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tK1xuICAgIHwgICAgICAgICAgIHwgICAgIHwgICAgICAgICAgICAgIHxcbiAgICB8IGNvbm5lY3RlZCB8LS0tLT58IGRpc2Nvbm5lY3RlZCB8XG4gICAgfCAgICAgICAgICAgfCAgICAgfCAgICAgICAgICAgICAgfFxuICAgICstLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICB8ICBeICAgICAgICAgICAgICAgXlxuICAgICAgICAgIHwgIHwgICAgICAgICAgICAgICB8XG4gICAgICAgICAgfCAgfCAgICstLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICB8ICArLS0tfCAgICAgICAgICAgICAgfFxuICAgICAgICAgIHwgICAgICB8IHJlY29ubmVjdGluZyB8XG4gICAgICAgICAgKy0tLS0tPnwgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuXG4qL1xudmFyIHN0YXRlcyA9IHtcbiAgICBjb25uZWN0ZWQ6IFtcbiAgICAgICAgJ3JlY29ubmVjdGluZycsXG4gICAgICAgICdkaXNjb25uZWN0ZWQnXG4gICAgXSxcbiAgICByZWNvbm5lY3Rpbmc6IFtcbiAgICAgICAgJ2Nvbm5lY3RlZCcsXG4gICAgICAgICdkaXNjb25uZWN0ZWQnXG4gICAgXSxcbiAgICBkaXNjb25uZWN0ZWQ6IFtdXG59O1xuLyoqXG4gKiBBIHtAbGluayBSb29tfSBpbXBsZW1lbnRhdGlvblxuICogQGV4dGVuZHMgU3RhdGVNYWNoaW5lXG4gKiBAcHJvcGVydHkge1JUQ1BlZXJDb25uZWN0aW9uU3RhdGV9IGNvbm5lY3Rpb25TdGF0ZVxuICogQHByb3BlcnR5IHs/UGFydGljaXBhbnQuU0lEfSBkb21pbmFudFNwZWFrZXJTaWRcbiAqIEBwcm9wZXJ0eSB7UGFydGljaXBhbnRTaWduYWxpbmd9IGxvY2FsUGFydGljaXBhbnRcbiAqIEBwcm9wZXJ0eSB7UlRDSWNlQ29ubmVjdGlvblN0YXRlfSBpY2VDb25uZWN0aW9uU3RhdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge01hcDxzdHJpbmcsIFJlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nPn0gcGFydGljaXBhbnRzXG4gKiBAcHJvcGVydHkge1JlY29yZGluZ1NpZ25hbGluZ30gcmVjb3JkaW5nXG4gKiBAcHJvcGVydHkge1Jvb20uU0lEfSBzaWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0ZSAtIFwiY29ubmVjdGVkXCIsIFwicmVjb25uZWN0aW5nXCIsIG9yIFwiZGlzY29ubmVjdGVkXCJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaWduYWxpbmdDb25uZWN0aW9uU3RhdGUgLSBcImNvbm5lY3RlZFwiLFxuICogICBcInJlY29ubmVjdGluZ1wiLCBvciBcImRpc2Nvbm5lY3RlZFwiXG4gKiBAZW1pdHMgUm9vbVNpZ25hbGluZyNjb25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gKiBAZW1pdHMgUm9vbVNpZ25hbGluZyNkb21pbmFudFNwZWFrZXJDaGFuZ2VkXG4gKiBAZW1pdHMgUm9vbVNpZ25hbGluZyNpY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gKiBAZW1pdHMgUm9vbVNpZ25hbGluZyNzaWduYWxpbmdDb25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gKi9cbnZhciBSb29tU2lnbmFsaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb29tU2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSb29tU2lnbmFsaW5nfS5cbiAgICAgKiBAcGFyYW0ge1BhcnRpY2lwYW50U2lnbmFsaW5nfSBsb2NhbFBhcnRpY2lwYW50XG4gICAgICogQHBhcmFtIHtSb29tLlNJRH0gc2lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJvb21TaWduYWxpbmcobG9jYWxQYXJ0aWNpcGFudCwgc2lkLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGxvZ0xldmVsOiBERUZBVUxUX0xPR19MRVZFTCxcbiAgICAgICAgICAgIFJlY29yZGluZ1NpZ25hbGluZzogRGVmYXVsdFJlY29yZGluZ1NpZ25hbGluZyxcbiAgICAgICAgICAgIFRpbWVvdXQ6IERlZmF1bHRUaW1lb3V0XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgbG9nTGV2ZWxzID0gYnVpbGRMb2dMZXZlbHMob3B0aW9ucy5sb2dMZXZlbCk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ2Nvbm5lY3RlZCcsIHN0YXRlcykgfHwgdGhpcztcbiAgICAgICAgdmFyIFJlY29yZGluZ1NpZ25hbGluZyA9IG9wdGlvbnMuUmVjb3JkaW5nU2lnbmFsaW5nO1xuICAgICAgICB2YXIgc2Vzc2lvblRpbWVvdXQgPSBuZXcgb3B0aW9ucy5UaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9kaXNjb25uZWN0KF90aGlzLl9yZWNvbm5lY3RpbmdFcnJvcik7XG4gICAgICAgIH0sIG9wdGlvbnMuc2Vzc2lvblRpbWVvdXQsIGZhbHNlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9pbnN0YW5jZUlkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5JbnN0YW5jZXMrK1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sb2c6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5sb2dcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmxvZy5jcmVhdGVMb2coJ2RlZmF1bHQnLCBfdGhpcylcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgTG9nKCdkZWZhdWx0JywgX3RoaXMsIGxvZ0xldmVscywgb3B0aW9ucy5sb2dnZXJOYW1lKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9tZWRpYUNvbm5lY3Rpb25Jc1JlY29ubmVjdGluZzoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVjb25uZWN0aW5nRXJyb3I6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZXNzaW9uVGltZW91dDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzZXNzaW9uVGltZW91dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbWluYW50U3BlYWtlclNpZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2NhbFBhcnRpY2lwYW50OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbG9jYWxQYXJ0aWNpcGFudFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuYW1lXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFydGljaXBhbnRzOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjb3JkaW5nOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFJlY29yZGluZ1NpZ25hbGluZygpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vbignY29ubmVjdGlvblN0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnXG4gICAgICAgICAgICAgICAgJiYgIVsnZGlzY29ubmVjdGVkJywgJ2ZhaWxlZCddLmluY2x1ZGVzKF90aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGlzY29ubmVjdChuZXcgTWVkaWFEVExTVHJhbnNwb3J0RmFpbGVkRXJyb3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vbignaWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heWJlVXBkYXRlU3RhdGUoX3RoaXMpOyB9KTtcbiAgICAgICAgX3RoaXMub24oJ3NpZ25hbGluZ0Nvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXliZVVwZGF0ZVN0YXRlKF90aGlzKTsgfSk7XG4gICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IEluIGNhc2UgXCJpY2VDb25uZWN0aW9uU3RhdGVcIiBpcyBhbHJlYWR5IGZhaWxlZCwgdXBkYXRlXG4gICAgICAgIC8vIHRoZSBSb29tU2lnbmFsaW5nIHN0YXRlLiBzZXRUaW1lb3V0KCkgZW5zdXJlcyB0aGF0IHRoZSBzdGF0ZSBpcyB1cGRhdGVkXG4gICAgICAgIC8vIGFmdGVyIFJvb21WMidzIGNvbnN0cnVjdG9yIGlzIGZ1bGx5IGV4ZWN1dGVkLCB0aGVyZWJ5IG1ha2luZyBcInNpZ25hbGluZ0Nvbm5lY3Rpb25TdGF0ZVwiXG4gICAgICAgIC8vIGF2YWlsYWJsZSBoZXJlLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heWJlVXBkYXRlU3RhdGUoX3RoaXMpOyB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0LCBwb3NzaWJseSB3aXRoIGFuIEVycm9yLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFcnJvcn0gW2Vycm9yXVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFJvb21TaWduYWxpbmcucHJvdG90eXBlLl9kaXNjb25uZWN0ID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgdGhpcy5wcmVlbXB0KCdkaXNjb25uZWN0ZWQnLCBudWxsLCBbZXJyb3JdKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFJvb21TaWduYWxpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbUm9vbVNpZ25hbGluZyAjXCIgKyB0aGlzLl9pbnN0YW5jZUlkICsgXCI6IFwiICsgKHRoaXMubG9jYWxQYXJ0aWNpcGFudCA/IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQgOiAnbnVsbCcpICsgXCJdXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudFNpZ25hbGluZ30gdG8gdGhlIHtAbGluayBSb29tU2lnbmFsaW5nfS5cbiAgICAgKiBAcGFyYW0ge1JlbW90ZVBhcnRpY2lwYW50U2lnbmFsaW5nfSBwYXJ0aWNpcGFudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFJvb21TaWduYWxpbmcucHJvdG90eXBlLmNvbm5lY3RQYXJ0aWNpcGFudCA9IGZ1bmN0aW9uIChwYXJ0aWNpcGFudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChwYXJ0aWNpcGFudC5zdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJ0aWNpcGFudHMuaGFzKHBhcnRpY2lwYW50LnNpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRpY2lwYW50cy5zZXQocGFydGljaXBhbnQuc2lkLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIHBhcnRpY2lwYW50Lm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBzdGF0ZUNoYW5nZWQoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudC5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBhcnRpY2lwYW50cy5kZWxldGUocGFydGljaXBhbnQuc2lkKTtcbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ3BhcnRpY2lwYW50RGlzY29ubmVjdGVkJywgcGFydGljaXBhbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KCdwYXJ0aWNpcGFudENvbm5lY3RlZCcsIHBhcnRpY2lwYW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFJvb21TaWduYWxpbmcucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgKG9yIHVuc2V0KSB0aGUgRG9taW5hbnQgU3BlYWtlci5cbiAgICAgKiBAcGFyYW0gez9QYXJ0aWNpcGFudC5TSUR9IGRvbWluYW50U3BlYWtlclNpZFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFJvb21TaWduYWxpbmcucHJvdG90eXBlLnNldERvbWluYW50U3BlYWtlciA9IGZ1bmN0aW9uIChkb21pbmFudFNwZWFrZXJTaWQpIHtcbiAgICAgICAgdGhpcy5kb21pbmFudFNwZWFrZXJTaWQgPSBkb21pbmFudFNwZWFrZXJTaWQ7XG4gICAgICAgIHRoaXMuZW1pdCgnZG9taW5hbnRTcGVha2VyQ2hhbmdlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIFJvb21TaWduYWxpbmc7XG59KFN0YXRlTWFjaGluZSkpO1xuLyoqXG4gKiBAZXZlbnQgUm9vbVNpZ25hbGluZyNldmVudDpjb25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gKi9cbi8qKlxuICogQGV2ZW50IFJvb21TaWduYWxpbmcjZXZlbnQ6ZG9taW5hbnRTcGVha2VyQ2hhbmdlZFxuICovXG4vKipcbiAqIHtAbGluayBSZW1vdGVQYXJ0aWNpcGFudFNpZ25hbGluZ30gY29ubmVjdGVkIHRvIHRoZSB7QGxpbmsgUm9vbVNpZ25hbGluZ30uXG4gKiBAZXZlbnQgUm9vbVNpZ25hbGluZyNldmVudDpwYXJ0aWNpcGFudENvbm5lY3RlZFxuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudFNpZ25hbGluZ30gcGFydGljaXBhbnRTaWduYWxpbmdcbiAqL1xuLyoqXG4gKiB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnRTaWduYWxpbmd9IGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSB7QGxpbmsgUm9vbVNpZ25hbGluZ30uXG4gKiBAZXZlbnQgUm9vbVNpZ25hbGluZyNldmVudDpwYXJ0aWNpcGFudERpc2Nvbm5lY3RlZFxuICogQHBhcmFtIHtSZW1vdGVQYXJ0aWNpcGFudFNpZ25hbGluZ30gcGFydGljaXBhbnRTaWduYWxpbmdcbiAqL1xuLyoqXG4gKiBAZXZlbnQgUm9vbVNpZ25hbGluZyNldmVudDppY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gKi9cbi8qKlxuICogQGV2ZW50IFJvb21TaWduYWxpbmcjZXZlbnQ6c2lnbmFsaW5nQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFxuICovXG4vKipcbiAqIE1heWJlIHVwZGF0ZSB0aGUge0BsaW5rIFJvb21TaWduYWxpbmd9IHN0YXRlLlxuICogQHBhcmFtIHtSb29tU2lnbmFsaW5nfSByb29tU2lnbmFsaW5nXG4gKi9cbmZ1bmN0aW9uIG1heWJlVXBkYXRlU3RhdGUocm9vbVNpZ25hbGluZykge1xuICAgIGlmIChyb29tU2lnbmFsaW5nLnN0YXRlID09PSAnZGlzY29ubmVjdGVkJyB8fCByb29tU2lnbmFsaW5nLnNpZ25hbGluZ0Nvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgcm9vbVNpZ25hbGluZy5fc2Vzc2lvblRpbWVvdXQuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV3U3RhdGU7XG4gICAgaWYgKHJvb21TaWduYWxpbmcuc2lnbmFsaW5nQ29ubmVjdGlvblN0YXRlID09PSAncmVjb25uZWN0aW5nJykge1xuICAgICAgICBuZXdTdGF0ZSA9IHJvb21TaWduYWxpbmcuc2lnbmFsaW5nQ29ubmVjdGlvblN0YXRlO1xuICAgIH1cbiAgICBlbHNlIGlmIChyb29tU2lnbmFsaW5nLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgcm9vbVNpZ25hbGluZy5fbWVkaWFDb25uZWN0aW9uSXNSZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICBuZXdTdGF0ZSA9ICdyZWNvbm5lY3RpbmcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyb29tU2lnbmFsaW5nLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ25ldycgfHwgcm9vbVNpZ25hbGluZy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjaGVja2luZycpIHtcbiAgICAgICAgbmV3U3RhdGUgPSByb29tU2lnbmFsaW5nLl9tZWRpYUNvbm5lY3Rpb25Jc1JlY29ubmVjdGluZyA/ICdyZWNvbm5lY3RpbmcnIDogJ2Nvbm5lY3RlZCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByb29tU2lnbmFsaW5nLl9tZWRpYUNvbm5lY3Rpb25Jc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICByb29tU2lnbmFsaW5nLl9yZWNvbm5lY3RpbmdFcnJvciA9IG51bGw7XG4gICAgICAgIHJvb21TaWduYWxpbmcuX3Nlc3Npb25UaW1lb3V0LmNsZWFyKCk7XG4gICAgICAgIG5ld1N0YXRlID0gJ2Nvbm5lY3RlZCc7XG4gICAgfVxuICAgIGlmIChuZXdTdGF0ZSA9PT0gcm9vbVNpZ25hbGluZy5zdGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXdTdGF0ZSA9PT0gJ3JlY29ubmVjdGluZycpIHtcbiAgICAgICAgcm9vbVNpZ25hbGluZy5fcmVjb25uZWN0aW5nRXJyb3IgPSByb29tU2lnbmFsaW5nLnNpZ25hbGluZ0Nvbm5lY3Rpb25TdGF0ZSA9PT0gJ3JlY29ubmVjdGluZydcbiAgICAgICAgICAgID8gbmV3IFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvcigpXG4gICAgICAgICAgICA6IG5ldyBNZWRpYUNvbm5lY3Rpb25FcnJvcigpO1xuICAgICAgICByb29tU2lnbmFsaW5nLl9zZXNzaW9uVGltZW91dC5zdGFydCgpO1xuICAgICAgICByb29tU2lnbmFsaW5nLnByZWVtcHQobmV3U3RhdGUsIG51bGwsIFtyb29tU2lnbmFsaW5nLl9yZWNvbm5lY3RpbmdFcnJvcl0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcm9vbVNpZ25hbGluZy5wcmVlbXB0KG5ld1N0YXRlKTtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFJvb21TaWduYWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb29tLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuLyoqXG4gKiBBIHtAbGluayBUcmFja30gaW1wbGVtZW50YXRpb25cbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQHByb3BlcnR5IHtUcmFjay5LaW5kfSBraW5kXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICovXG52YXIgVHJhY2tTaWduYWxpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYWNrU2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBUcmFja1NpZ25hbGluZ30uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1RyYWNrLktpbmR9IGtpbmRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRW5hYmxlZFxuICAgICAqIEBwYXJhbSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5XG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhY2tTaWduYWxpbmcobmFtZSwga2luZCwgaXNFbmFibGVkLCBwcmlvcml0eSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICB2YXIgc2lkID0gbnVsbDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9lcnJvcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzRW5hYmxlZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpc0VuYWJsZWQsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcHJpb3JpdHk6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJpb3JpdHksXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdHJhY2tUcmFuc2NlaXZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NpZDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3NpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWQgPSBfc2lkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtpbmQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBraW5kXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYWNrU2lnbmFsaW5nLnByb3RvdHlwZSwgXCJlcnJvclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24tbnVsbCBpZiBwdWJsaWNhdGlvbiBvciBzdWJzY3JpcHRpb24gZmFpbGVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgez9FcnJvcn0gZXJyb3JcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYWNrU2lnbmFsaW5nLnByb3RvdHlwZSwgXCJpc0VuYWJsZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUge0BsaW5rIFRyYWNrU2lnbmFsaW5nfSBpcyBlbmFibGVkLlxuICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0VuYWJsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhY2tTaWduYWxpbmcucHJvdG90eXBlLCBcInByaW9yaXR5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB7QGxpbmsgVHJhY2tTaWduYWxpbmd9J3MgcHJpb3JpdHkuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VHJhY2suUHJpb3JpdHl9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmlvcml0eTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFja1NpZ25hbGluZy5wcm90b3R5cGUsIFwic2lkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB7QGxpbmsgVHJhY2tTaWduYWxpbmd9J3Mge0BsaW5rIFRyYWNrLlNJRH0uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VHJhY2suU0lEfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYWNrU2lnbmFsaW5nLnByb3RvdHlwZSwgXCJ0cmFja1RyYW5zY2VpdmVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB7QGxpbmsgVHJhY2tTaWduYWxpbmd9J3Mge0BsaW5rIFRyYWNrVHJhbnNjZWl2ZXJ9LlxuICAgICAgICAgKiBAcHJvcGVydHkge1RyYWNrVHJhbnNjZWl2ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFja1RyYW5zY2VpdmVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB0aGUge0BsaW5rIFRyYWNrU2lnbmFsaW5nfSBpZiBpdCBpcyBub3QgYWxyZWFkeSBkaXNhYmxlZC5cbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuICAgIFRyYWNrU2lnbmFsaW5nLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmFibGUoZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5hYmxlIChvciBkaXNhYmxlKSB0aGUge0BsaW5rIFRyYWNrU2lnbmFsaW5nfSBpZiBpdCBpcyBub3QgYWxyZWFkeSBlbmFibGVkXG4gICAgICogKG9yIGRpc2FibGVkKS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmFibGVkPXRydWVdXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cbiAgICBUcmFja1NpZ25hbGluZy5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgZW5hYmxlZCA9IHR5cGVvZiBlbmFibGVkID09PSAnYm9vbGVhbicgPyBlbmFibGVkIDogdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkICE9PSBlbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0VuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHtAbGluayBUcmFja1RyYW5zY2VpdmVyfSBvbiB0aGUge0BsaW5rIFRyYWNrU2lnbmFsaW5nfS5cbiAgICAgKiBAcGFyYW0ge1RyYWNrVHJhbnNjZWl2ZXJ9IHRyYWNrVHJhbnNjZWl2ZXJcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBUcmFja1NpZ25hbGluZy5wcm90b3R5cGUuc2V0VHJhY2tUcmFuc2NlaXZlciA9IGZ1bmN0aW9uICh0cmFja1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIHRyYWNrVHJhbnNjZWl2ZXIgPSB0cmFja1RyYW5zY2VpdmVyIHx8IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrVHJhbnNjZWl2ZXIgIT09IHRyYWNrVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrVHJhbnNjZWl2ZXIgPSB0cmFja1RyYW5zY2VpdmVyO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIFNJRCBvbiB0aGUge0BsaW5rIFRyYWNrU2lnbmFsaW5nfSBvbmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWRcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBUcmFja1NpZ25hbGluZy5wcm90b3R5cGUuc2V0U2lkID0gZnVuY3Rpb24gKHNpZCkge1xuICAgICAgICBpZiAodGhpcy5zaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpZCA9IHNpZDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYWNrU2lnbmFsaW5nO1xufShFdmVudEVtaXR0ZXIpKTtcbi8qKlxuICogRW1pdHRlZCB3aGVuZXZlciB0aGUge0BsaW5rIFRyYWNrU2lnbmFsaW5nfSBpcyB1cGRhdGVkXG4gKiBAZXZlbnQgVHJhY2tTaWduYWxpbmcjdXBkYXRlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFRyYWNrU2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2suanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIENhbmNlbGFibGVQcm9taXNlID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jYW5jZWxhYmxlcHJvbWlzZScpO1xudmFyIERlZmF1bHRQZWVyQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL3BlZXJjb25uZWN0aW9ubWFuYWdlcicpO1xudmFyIERlZmF1bHRSb29tVjIgPSByZXF1aXJlKCcuL3Jvb20nKTtcbnZhciBEZWZhdWx0VHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90d2lsaW9jb25uZWN0aW9udHJhbnNwb3J0Jyk7XG52YXIgX2EgPSByZXF1aXJlKCcuLi8uLi91dGlsL3R3aWxpby12aWRlby1lcnJvcnMnKSwgU2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yID0gX2EuU2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yLCBTaWduYWxpbmdJbmNvbWluZ01lc3NhZ2VJbnZhbGlkRXJyb3IgPSBfYS5TaWduYWxpbmdJbmNvbWluZ01lc3NhZ2VJbnZhbGlkRXJyb3I7XG52YXIgX2IgPSByZXF1aXJlKCcuLi8uLi91dGlsJyksIGZsYXRNYXAgPSBfYi5mbGF0TWFwLCBjcmVhdGVSb29tQ29ubmVjdEV2ZW50UGF5bG9hZCA9IF9iLmNyZWF0ZVJvb21Db25uZWN0RXZlbnRQYXlsb2FkO1xuZnVuY3Rpb24gY3JlYXRlQ2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlKHRva2VuLCB3c1NlcnZlciwgbG9jYWxQYXJ0aWNpcGFudCwgZW5jb2RpbmdQYXJhbWV0ZXJzLCBwcmVmZXJyZWRDb2RlY3MsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIFBlZXJDb25uZWN0aW9uTWFuYWdlcjogRGVmYXVsdFBlZXJDb25uZWN0aW9uTWFuYWdlcixcbiAgICAgICAgUm9vbVYyOiBEZWZhdWx0Um9vbVYyLFxuICAgICAgICBUcmFuc3BvcnQ6IERlZmF1bHRUcmFuc3BvcnRcbiAgICB9LCBvcHRpb25zKTtcbiAgICB2YXIgUGVlckNvbm5lY3Rpb25NYW5hZ2VyID0gb3B0aW9ucy5QZWVyQ29ubmVjdGlvbk1hbmFnZXIsIFJvb21WMiA9IG9wdGlvbnMuUm9vbVYyLCBUcmFuc3BvcnQgPSBvcHRpb25zLlRyYW5zcG9ydCwgaWNlU2VydmVycyA9IG9wdGlvbnMuaWNlU2VydmVycywgbG9nID0gb3B0aW9ucy5sb2c7XG4gICAgdmFyIHBlZXJDb25uZWN0aW9uTWFuYWdlciA9IG5ldyBQZWVyQ29ubmVjdGlvbk1hbmFnZXIoZW5jb2RpbmdQYXJhbWV0ZXJzLCBwcmVmZXJyZWRDb2RlY3MsIG9wdGlvbnMpO1xuICAgIHZhciB0cmFja1NlbmRlcnMgPSBmbGF0TWFwKGxvY2FsUGFydGljaXBhbnQudHJhY2tzLCBmdW5jdGlvbiAodHJhY2tWMikgeyByZXR1cm4gW3RyYWNrVjIudHJhY2tUcmFuc2NlaXZlcl07IH0pO1xuICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5zZXRUcmFja1NlbmRlcnModHJhY2tTZW5kZXJzKTtcbiAgICB2YXIgY2FuY2VsbGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoJ0NhbmNlbGVkJyk7XG4gICAgdmFyIHRyYW5zcG9ydDtcbiAgICB2YXIgY2FuY2VsYWJsZVByb21pc2UgPSBuZXcgQ2FuY2VsYWJsZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgaXNDYW5jZWxlZCkge1xuICAgICAgICB2YXIgb25JY2VkID0gZnVuY3Rpb24gKGljZVNlcnZlcnMpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbmNlbGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoY2FuY2VsbGF0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjYW5jZWxsYXRpb25FcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2cuZGVidWcoJ0dvdCBJQ0Ugc2VydmVyczonLCBpY2VTZXJ2ZXJzKTtcbiAgICAgICAgICAgIG9wdGlvbnMuaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29uZmlndXJhdGlvbihvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbk1hbmFnZXIuY3JlYXRlQW5kT2ZmZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDYW5jZWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChjYW5jZWxsYXRpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNhbmNlbGxhdGlvbkVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ2NyZWF0ZUFuZE9mZmVyKCkgc3VjY2VlZGVkLicpO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFBlZXJDb25uZWN0aW9uTWFuYWdlciNjcmVhdGVBbmRPZmZlcigpIHF1ZXVlcyB0aGVcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIG9mZmVyIGluIHRoZSBldmVudCBxdWV1ZSBmb3IgdGhlICdkZXNjcmlwdGlvbicgZXZlbnQuIFNvLFxuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBkZXF1ZXVlaW5nIHRvIHByZXZlbnQgdGhlIHNwdXJpb3VzICd1cGRhdGUnIG1lc3NhZ2Ugc2VudCBieVxuICAgICAgICAgICAgICAgIC8vIHRoZSBjbGllbnQgYWZ0ZXIgY29ubmVjdGluZyB0byBhIHJvb20uXG4gICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLmRlcXVldWUoJ2Rlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoJ2NyZWF0ZUFuZE9mZmVyKCkgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBJbnNpZ2h0c1B1Ymxpc2hlciA9IG9wdGlvbnMuSW5zaWdodHNQdWJsaXNoZXIsIE51bGxJbnNpZ2h0c1B1Ymxpc2hlciA9IG9wdGlvbnMuTnVsbEluc2lnaHRzUHVibGlzaGVyLCBhdXRvbWF0aWNTdWJzY3JpcHRpb24gPSBvcHRpb25zLmF1dG9tYXRpY1N1YnNjcmlwdGlvbiwgYmFuZHdpZHRoUHJvZmlsZSA9IG9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZSwgZG9taW5hbnRTcGVha2VyID0gb3B0aW9ucy5kb21pbmFudFNwZWFrZXIsIGVudmlyb25tZW50ID0gb3B0aW9ucy5lbnZpcm9ubWVudCwgZXZlbnRPYnNlcnZlciA9IG9wdGlvbnMuZXZlbnRPYnNlcnZlciwgbG9nZ2VyTmFtZSA9IG9wdGlvbnMubG9nZ2VyTmFtZSwgbG9nTGV2ZWwgPSBvcHRpb25zLmxvZ0xldmVsLCBuYW1lID0gb3B0aW9ucy5uYW1lLCBuZXR3b3JrTW9uaXRvciA9IG9wdGlvbnMubmV0d29ya01vbml0b3IsIG5ldHdvcmtRdWFsaXR5ID0gb3B0aW9ucy5uZXR3b3JrUXVhbGl0eSwgaW5zaWdodHMgPSBvcHRpb25zLmluc2lnaHRzLCByZWFsbSA9IG9wdGlvbnMucmVhbG0sIHNkcFNlbWFudGljcyA9IG9wdGlvbnMuc2RwU2VtYW50aWNzLCB3c1NlcnZlckluc2lnaHRzID0gb3B0aW9ucy53c1NlcnZlckluc2lnaHRzO1xuICAgICAgICAvLyBkZWNpZGUgd2hpY2ggbXNwIGNoYW5uZWxzIHRvIHJlcXVlc3RcbiAgICAgICAgLy8gZG9taW5hbnRTcGVha2VyLCBuZXR3b3JrUXVhbGl0eVxuICAgICAgICB2YXIgdHJhY2tQcmlvcml0eSA9ICEhYmFuZHdpZHRoUHJvZmlsZTtcbiAgICAgICAgdmFyIHRyYWNrU3dpdGNoT2ZmID0gISFiYW5kd2lkdGhQcm9maWxlO1xuICAgICAgICB2YXIgcmVuZGVySGludHMgPSAhIWJhbmR3aWR0aFByb2ZpbGUgJiZcbiAgICAgICAgICAgIChvcHRpb25zLmNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCAhPT0gJ2Rpc2FibGVkJyB8fCBvcHRpb25zLmNvbnRlbnRQcmVmZXJlbmNlc01vZGUgIT09ICdkaXNhYmxlZCcpO1xuICAgICAgICB2YXIgdHJhbnNwb3J0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgYXV0b21hdGljU3Vic2NyaXB0aW9uOiBhdXRvbWF0aWNTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICBkb21pbmFudFNwZWFrZXI6IGRvbWluYW50U3BlYWtlcixcbiAgICAgICAgICAgIGVudmlyb25tZW50OiBlbnZpcm9ubWVudCxcbiAgICAgICAgICAgIGV2ZW50T2JzZXJ2ZXI6IGV2ZW50T2JzZXJ2ZXIsXG4gICAgICAgICAgICBsb2dnZXJOYW1lOiBsb2dnZXJOYW1lLFxuICAgICAgICAgICAgbG9nTGV2ZWw6IGxvZ0xldmVsLFxuICAgICAgICAgICAgbmV0d29ya01vbml0b3I6IG5ldHdvcmtNb25pdG9yLFxuICAgICAgICAgICAgbmV0d29ya1F1YWxpdHk6IG5ldHdvcmtRdWFsaXR5LFxuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyxcbiAgICAgICAgICAgIGluc2lnaHRzOiBpbnNpZ2h0cyxcbiAgICAgICAgICAgIG9uSWNlZDogb25JY2VkLFxuICAgICAgICAgICAgcmVhbG06IHJlYWxtLFxuICAgICAgICAgICAgcmVuZGVySGludHM6IHJlbmRlckhpbnRzLFxuICAgICAgICAgICAgc2RwU2VtYW50aWNzOiBzZHBTZW1hbnRpY3MsXG4gICAgICAgICAgICB0cmFja1ByaW9yaXR5OiB0cmFja1ByaW9yaXR5LFxuICAgICAgICAgICAgdHJhY2tTd2l0Y2hPZmY6IHRyYWNrU3dpdGNoT2ZmXG4gICAgICAgIH0sIHR5cGVvZiB3c1NlcnZlckluc2lnaHRzID09PSAnc3RyaW5nJyA/IHtcbiAgICAgICAgICAgIHdzU2VydmVySW5zaWdodHM6IHdzU2VydmVySW5zaWdodHNcbiAgICAgICAgfSA6IHt9LCBJbnNpZ2h0c1B1Ymxpc2hlciA/IHtcbiAgICAgICAgICAgIEluc2lnaHRzUHVibGlzaGVyOiBJbnNpZ2h0c1B1Ymxpc2hlclxuICAgICAgICB9IDoge30sIE51bGxJbnNpZ2h0c1B1Ymxpc2hlciA/IHtcbiAgICAgICAgICAgIE51bGxJbnNpZ2h0c1B1Ymxpc2hlcjogTnVsbEluc2lnaHRzUHVibGlzaGVyXG4gICAgICAgIH0gOiB7fSwgYmFuZHdpZHRoUHJvZmlsZSA/IHtcbiAgICAgICAgICAgIGJhbmR3aWR0aFByb2ZpbGU6IGJhbmR3aWR0aFByb2ZpbGVcbiAgICAgICAgfSA6IHt9KTtcbiAgICAgICAgdHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydChuYW1lLCB0b2tlbiwgbG9jYWxQYXJ0aWNpcGFudCwgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLCB3c1NlcnZlciwgdHJhbnNwb3J0T3B0aW9ucyk7XG4gICAgICAgIHZhciBjb25uZWN0RXZlbnRQYXlsb2FkID0gY3JlYXRlUm9vbUNvbm5lY3RFdmVudFBheWxvYWQob3B0aW9ucyk7XG4gICAgICAgIGV2ZW50T2JzZXJ2ZXIuZW1pdCgnZXZlbnQnLCBjb25uZWN0RXZlbnRQYXlsb2FkKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoJ2Nvbm5lY3RlZCcsIGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZygnVHJhbnNwb3J0IGNvbm5lY3RlZDonLCBpbml0aWFsU3RhdGUpO1xuICAgICAgICAgICAgaWYgKGlzQ2FuY2VsZWQoKSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChjYW5jZWxsYXRpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvY2FsUGFydGljaXBhbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZS5wYXJ0aWNpcGFudDtcbiAgICAgICAgICAgIGlmICghbG9jYWxQYXJ0aWNpcGFudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBTaWduYWxpbmdJbmNvbWluZ01lc3NhZ2VJbnZhbGlkRXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNpZ25hbGluZ1JlZ2lvbiA9IGluaXRpYWxTdGF0ZS5vcHRpb25zLnNpZ25hbGluZ19yZWdpb247XG4gICAgICAgICAgICBsb2NhbFBhcnRpY2lwYW50LnNldFNpZ25hbGluZ1JlZ2lvbihzaWduYWxpbmdSZWdpb24pO1xuICAgICAgICAgICAgcmVzb2x2ZShuZXcgUm9vbVYyKGxvY2FsUGFydGljaXBhbnQsIGluaXRpYWxTdGF0ZSwgdHJhbnNwb3J0LCBwZWVyQ29ubmVjdGlvbk1hbmFnZXIsIG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zcG9ydC5vbmNlKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiAoc3RhdGUsIGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IgfHwgbmV3IFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZygnVHJhbnNwb3J0IHN0YXRlIGNoYW5nZWQ6Jywgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY2FuY2VsYWJsZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwZWVyQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2UoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2FuY2VsYWJsZVByb21pc2U7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNhbmNlbGFibGVSb29tU2lnbmFsaW5nUHJvbWlzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbmNlbGFibGVyb29tc2lnbmFsaW5ncHJvbWlzZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIE1lZGlhU2lnbmFsaW5nID0gcmVxdWlyZSgnLi9tZWRpYXNpZ25hbGluZycpO1xuLyoqXG4gKiBAcHJvcGVydHkgez9UcmFjay5TSUR9IGxvdWRlc3RQYXJ0aWNpcGFudFNpZFxuICogQGVtaXRzIERvbWluYW50U3BlYWtlclNpZ25hbGluZyN1cGRhdGVkXG4gKi9cbnZhciBEb21pbmFudFNwZWFrZXJTaWduYWxpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvbWluYW50U3BlYWtlclNpZ25hbGluZywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4ge0BsaW5rIERvbWluYW50U3BlYWtlclNpZ25hbGluZ30uXG4gICAgICovXG4gICAgZnVuY3Rpb24gRG9taW5hbnRTcGVha2VyU2lnbmFsaW5nKGdldFJlY2VpdmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdldFJlY2VpdmVyLCAnYWN0aXZlX3NwZWFrZXInLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2xvdWRlc3RQYXJ0aWNpcGFudFNpZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMub24oJ3JlYWR5JywgZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0Lm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhY3RpdmVfc3BlYWtlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0TG91ZGVzdFBhcnRpY2lwYW50U2lkKG1lc3NhZ2UucGFydGljaXBhbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvbWluYW50U3BlYWtlclNpZ25hbGluZy5wcm90b3R5cGUsIFwibG91ZGVzdFBhcnRpY2lwYW50U2lkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbG91ZGVzdCB7QGxpbmsgVHJhY2suU0lEfSwgaWYga25vd24uXG4gICAgICAgICAqIEByZXR1cm5zIHs/VHJhY2suU0lEfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG91ZGVzdFBhcnRpY2lwYW50U2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1RyYWNrLlNJRH0gbG91ZGVzdFBhcnRpY2lwYW50U2lkXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgRG9taW5hbnRTcGVha2VyU2lnbmFsaW5nLnByb3RvdHlwZS5fc2V0TG91ZGVzdFBhcnRpY2lwYW50U2lkID0gZnVuY3Rpb24gKGxvdWRlc3RQYXJ0aWNpcGFudFNpZCkge1xuICAgICAgICBpZiAodGhpcy5sb3VkZXN0UGFydGljaXBhbnRTaWQgPT09IGxvdWRlc3RQYXJ0aWNpcGFudFNpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvdWRlc3RQYXJ0aWNpcGFudFNpZCA9IGxvdWRlc3RQYXJ0aWNpcGFudFNpZDtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gRG9taW5hbnRTcGVha2VyU2lnbmFsaW5nO1xufShNZWRpYVNpZ25hbGluZykpO1xuLyoqXG4gKiBAZXZlbnQgRG9taW5hbnRTcGVha2VyU2lnbmFsaW5nI3VwZGF0ZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBEb21pbmFudFNwZWFrZXJTaWduYWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb21pbmFudHNwZWFrZXJzaWduYWxpbmcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEZpbHRlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZmlsdGVyJyk7XG4vKipcbiAqIEFuIHtAbGluayBJY2VCb3h9IHN0b3JlcyB0cmlja2xlZCBJQ0UgY2FuZGlkYXRlcy4gQ2FuZGlkYXRlcyBhZGRlZCB0byB0aGVcbiAqIHtAbGluayBJY2VCb3h9IHZpYSB7QGxpbmsgSWNlQm94I3VwZGF0ZX0gYXJlIGNvbXBhcmVkIGFnYWluc3QgcHJldmlvdXNseVxuICogdHJpY2tsZWQgY2FuZGlkYXRlcyBhbmQgb25seSBuZXcgY2FuZGlkYXRlcyB3aWxsIGJlIHJldHVybmVkIChhc3N1bWluZyB0aGV5XG4gKiBtYXRjaCB0aGUgY3VycmVudCBJQ0UgdXNlcm5hbWUgZnJhZ21lbnQgc2V0IGJ5IHtAbGluayBJY2VCb3gjc2V0VWZyYWd9KS5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdWZyYWdcbiAqL1xudmFyIEljZUJveCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4ge0BsaW5rIEljZUJveH0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gSWNlQm94KCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBfZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBGaWx0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBnZXRLZXk6IGZ1bmN0aW9uIGdldEtleShpY2VTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGljZVN0YXRlLnVmcmFnO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpc0xlc3NUaGFuT3JFcXVhbFRvOiBmdW5jdGlvbiBpc0xlc3NUaGFuT3JFcXVhbFRvKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnJldmlzaW9uIDw9IGIucmV2aXNpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF91ZnJhZzoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdWZyYWc6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdWZyYWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBJQ0UgdXNlcm5hbWUgZnJhZ21lbnQgb24gdGhlIHtAbGluayBJY2VCb3h9LiBUaGlzIG1ldGhvZCByZXR1cm5zIGFueVxuICAgICAqIElDRSBjYW5kaWRhdGVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlcm5hbWUgZnJhZ21lbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVmcmFnXG4gICAgICogQHJldHVybnMge0FycmF5PFJUQ0ljZUNhbmRpZGF0ZUluaXQ+fVxuICAgICAqL1xuICAgIEljZUJveC5wcm90b3R5cGUuc2V0VWZyYWcgPSBmdW5jdGlvbiAodWZyYWcpIHtcbiAgICAgICAgdGhpcy5fdWZyYWcgPSB1ZnJhZztcbiAgICAgICAgdmFyIGljZSA9IHRoaXMuX2ZpbHRlci50b01hcCgpLmdldCh1ZnJhZyk7XG4gICAgICAgIHJldHVybiBpY2UgPyBpY2UuY2FuZGlkYXRlcyA6IFtdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB7QGxpbmsgSWNlQm94fS4gVGhpcyBtZXRob2QgcmV0dXJucyBhbnkgbmV3IElDRSBjYW5kaWRhdGVzXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IHVzZXJuYW1lIGZyYWdtZW50LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpY2VTdGF0ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheTxSVENJY2VDYW5kaWRhdGVJbml0Pn1cbiAgICAgKi9cbiAgICBJY2VCb3gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpY2VTdGF0ZSkge1xuICAgICAgICAvLyBOT1RFKG1yb2JlcnRzKTogVGhlIFNlcnZlciBzb21ldGltZXMgZG9lcyBub3Qgc2V0IHRoZSBjYW5kaWRhdGVzIHByb3BlcnR5LlxuICAgICAgICBpY2VTdGF0ZS5jYW5kaWRhdGVzID0gaWNlU3RhdGUuY2FuZGlkYXRlcyB8fCBbXTtcbiAgICAgICAgdmFyIG9sZEljZVN0YXRlID0gdGhpcy5fZmlsdGVyLnRvTWFwKCkuZ2V0KGljZVN0YXRlLnVmcmFnKTtcbiAgICAgICAgdmFyIG9sZENhbmRpZGF0ZXMgPSBvbGRJY2VTdGF0ZSA/IG9sZEljZVN0YXRlLmNhbmRpZGF0ZXMgOiBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlci51cGRhdGUoaWNlU3RhdGUpICYmIHRoaXMuX3VmcmFnID09PSBpY2VTdGF0ZS51ZnJhZ1xuICAgICAgICAgICAgPyBpY2VTdGF0ZS5jYW5kaWRhdGVzLnNsaWNlKG9sZENhbmRpZGF0ZXMubGVuZ3RoKVxuICAgICAgICAgICAgOiBbXTtcbiAgICB9O1xuICAgIHJldHVybiBJY2VCb3g7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBJY2VCb3g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pY2Vib3guanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25zdGFudHMnKSwgSUNFX0FDVElWSVRZX0NIRUNLX1BFUklPRF9NUyA9IF9hLklDRV9BQ1RJVklUWV9DSEVDS19QRVJJT0RfTVMsIElDRV9JTkFDVElWSVRZX1RIUkVTSE9MRF9NUyA9IF9hLklDRV9JTkFDVElWSVRZX1RIUkVTSE9MRF9NUztcbi8qKlxuICogTW9uaXRvcnMgYSB7QGxpbmsgUlRDUGVlckNvbm5lY3Rpb259J3Mgc3RhdHMgYW5kIG5vdGlmaWVzXG4gKiBjYWxsZXIgd2hlbiBpbmFjdGl2aXR5IGlzIGRldGVjdGVkLlxuICovXG52YXIgSWNlQ29ubmVjdGlvbk1vbml0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIHtAbGluayBJY2VDb25uZWN0aW9uTW9uaXRvcn0uXG4gICAgICogQHBhcmFtIHtSVENQZWVyQ29ubmVjdGlvbn0gcGVlckNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gSWNlQ29ubmVjdGlvbk1vbml0b3IocGVlckNvbm5lY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgYWN0aXZpdHlDaGVja1BlcmlvZE1zOiBJQ0VfQUNUSVZJVFlfQ0hFQ0tfUEVSSU9EX01TLFxuICAgICAgICAgICAgaW5hY3Rpdml0eVRocmVzaG9sZE1zOiBJQ0VfSU5BQ1RJVklUWV9USFJFU0hPTERfTVMsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBfYWN0aXZpdHlDaGVja1BlcmlvZE1zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuYWN0aXZpdHlDaGVja1BlcmlvZE1zXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2luYWN0aXZpdHlUaHJlc2hvbGRNczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmluYWN0aXZpdHlUaHJlc2hvbGRNc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sYXN0QWN0aXZpdHk6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9wZWVyQ29ubmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwZWVyQ29ubmVjdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90aW1lcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgSWNlQ29ubmVjdGlvbk1vbml0b3IucHJvdG90eXBlLl9nZXRBY3RpdmVQYWlyU3RhdCA9IGZ1bmN0aW9uIChzdGF0cykge1xuICAgICAgICB2YXIgc3RhdHNBcnJheSA9IEFycmF5LmZyb20oc3RhdHMudmFsdWVzKCkpO1xuICAgICAgICB2YXIgaGFzSW5Cb3VuZFRyYWNrcyA9IHN0YXRzQXJyYXkuZmluZChmdW5jdGlvbiAoc3RhdCkgeyByZXR1cm4gc3RhdC50eXBlID09PSAnaW5ib3VuZC1ydHAnOyB9KTtcbiAgICAgICAgaWYgKCFoYXNJbkJvdW5kVHJhY2tzKSB7XG4gICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogd2hlbiB0aGVyZSBhcmUgbm8gdHJhY2tzIHNoYXJlZCBvbiBhIHBlZXJDb25uZWN0aW9uXG4gICAgICAgICAgICAvLyB3ZSBtYXkgc2VlIGluYWN0aXZpdHkgb24gYnl0ZXNSZWNlaXZlZCAtIGJ1dCB0aGF0IGlzIG5vdCByZWFsIGluYWN0aXZpdHksXG4gICAgICAgICAgICAvLyBpZ25vcmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWN0aXZlUGFpclN0YXRzID0gc3RhdHNBcnJheS5maW5kKGZ1bmN0aW9uIChzdGF0KSB7IHJldHVybiBzdGF0LnR5cGUgPT09ICdjYW5kaWRhdGUtcGFpcicgJiYgc3RhdC5ub21pbmF0ZWQ7IH0pO1xuICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogc29tZXRpbWVzIChKU0RLLTI2NjcpIGFmdGVyIGdldHRpbmcgZGlzY29ubmVjdGVkIHdoaWxlIHN3aXRjaGluZyBuZXR3b3JrXG4gICAgICAgIC8vIHdlIG1heSBub3QgZmluZCBhY3RpdmUgcGFpci4gVHJlYXQgdGhpcyBhcyAwIGJ5dGVzUmVjZWl2ZWQgc28gdGhhdCB3ZSBjb3VudCBpdCB0b3dhcmRzIGluYWN0aXZpdHkuXG4gICAgICAgIHJldHVybiBhY3RpdmVQYWlyU3RhdHMgfHwge1xuICAgICAgICAgICAgYnl0ZXNSZWNlaXZlZDogMCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogTWF0aC5yb3VuZCgobmV3IERhdGUoKSkuZ2V0VGltZSgpKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IElDRSBjb25uZWN0aW9uIHN0YXRzLCBhbmQgZXh0cmFjdCByZWNlaXZlZCBhbmQgc2VuZCBieXRlcy5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlPD9SVENJY2VDYW5kaWRhdGVQYWlyU3RhdHM+XG4gICAgICovXG4gICAgSWNlQ29ubmVjdGlvbk1vbml0b3IucHJvdG90eXBlLl9nZXRJY2VDb25uZWN0aW9uU3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5nZXRTdGF0cygpLnRoZW4oZnVuY3Rpb24gKHN0YXRzKSB7IHJldHVybiBfdGhpcy5fZ2V0QWN0aXZlUGFpclN0YXQoc3RhdHMpOyB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzY2hlZHVsZXMvdW4tc2NoZWR1bGVzIGluYWN0aXZpdHkgY2FsbGJhY2suXG4gICAgICovXG4gICAgSWNlQ29ubmVjdGlvbk1vbml0b3IucHJvdG90eXBlLl9zY2hlZHVsZUluYWN0aXZpdHlDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdGhpcy5fb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBzY2hlZHVsZSBjYWxsYmFja1xuICAgICAgICAgICAgdGhpcy5fb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fcGVlckNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX29uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNhbGxiYWNrICYmIHRoaXMuX29uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCkge1xuICAgICAgICAgICAgLy8gdW5zY2hlZHVsZSBjYWxsYmFja1xuICAgICAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgICAgIHRoaXMuX29uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IG1vbml0b3JpbmcgdGhlIElDRSBjb25uZWN0aW9uLlxuICAgICAqIE1vbml0b3JzIGJ5dGVzIHJlY2VpdmVkIG9uIGFjdGl2ZSBpY2UgY29ubmVjdGlvbiBwYWlyLFxuICAgICAqIGludm9rZXMgb25JY2VDb25uZWN0aW9uSW5hY3RpdmUgd2hlbiBpbmFjdGl2aXR5IGlzIGRldGVjdGVkLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uSWNlQ29ubmVjdGlvbkluYWN0aXZlXG4gICAgICovXG4gICAgSWNlQ29ubmVjdGlvbk1vbml0b3IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKG9uSWNlQ29ubmVjdGlvbkluYWN0aXZlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9nZXRJY2VDb25uZWN0aW9uU3RhdHMoKS50aGVuKGZ1bmN0aW9uIChpY2VTdGF0cykge1xuICAgICAgICAgICAgICAgIGlmICghaWNlU3RhdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9sYXN0QWN0aXZpdHkgfHwgX3RoaXMuX2xhc3RBY3Rpdml0eS5ieXRlc1JlY2VpdmVkICE9PSBpY2VTdGF0cy5ieXRlc1JlY2VpdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sYXN0QWN0aXZpdHkgPSBpY2VTdGF0cztcbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZWN0ZWQgYWN0aXZpdHksIGNhbmNlbCBzY2hlZHVsZWQgY2FsbGJhY2sgaWYgYW55LlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2NoZWR1bGVJbmFjdGl2aXR5Q2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpY2VTdGF0cy50aW1lc3RhbXAgLSBfdGhpcy5fbGFzdEFjdGl2aXR5LnRpbWVzdGFtcCA+PSBfdGhpcy5faW5hY3Rpdml0eVRocmVzaG9sZE1zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRldGVjdGVkIGluYWN0aXZpdHkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fcGVlckNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25JY2VDb25uZWN0aW9uSW5hY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5fb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2NoZWR1bGVJbmFjdGl2aXR5Q2FsbGJhY2sob25JY2VDb25uZWN0aW9uSW5hY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMuX2FjdGl2aXR5Q2hlY2tQZXJpb2RNcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9wIG1vbml0b3JpbmcgdGhlIElDRSBjb25uZWN0aW9uIHN0YXRlLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIEljZUNvbm5lY3Rpb25Nb25pdG9yLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZUluYWN0aXZpdHlDYWxsYmFjayhudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3RpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RBY3Rpdml0eSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJY2VDb25uZWN0aW9uTW9uaXRvcjtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IEljZUNvbm5lY3Rpb25Nb25pdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWNlY29ubmVjdGlvbm1vbml0b3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBkZWZhdWx0Q3JlYXRlQ2FuY2VsYWJsZVJvb21TaWduYWxpbmdQcm9taXNlID0gcmVxdWlyZSgnLi9jYW5jZWxhYmxlcm9vbXNpZ25hbGluZ3Byb21pc2UnKTtcbnZhciBMb2NhbFBhcnRpY2lwYW50VjIgPSByZXF1aXJlKCcuL2xvY2FscGFydGljaXBhbnQnKTtcbnZhciBTaWduYWxpbmcgPSByZXF1aXJlKCcuLi8nKTtcbi8qKlxuICoge0BsaW5rIFNpZ25hbGluZ1YyfSBpbXBsZW1lbnRzIHZlcnNpb24gMiBvZiBvdXIgc2lnbmFsaW5nIHByb3RvY29sLlxuICogQGV4dGVuZHMgU2lnbmFsaW5nXG4gKi9cbnZhciBTaWduYWxpbmdWMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbmFsaW5nVjIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IHtAbGluayBTaWduYWxpbmdWMn0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdzU2VydmVyXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTaWduYWxpbmdWMih3c1NlcnZlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiBlc2xpbnQgbmV3LWNhcDowICovXG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNyZWF0ZUNhbmNlbGFibGVSb29tU2lnbmFsaW5nUHJvbWlzZTogZGVmYXVsdENyZWF0ZUNhbmNlbGFibGVSb29tU2lnbmFsaW5nUHJvbWlzZVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2NyZWF0ZUNhbmNlbGFibGVSb29tU2lnbmFsaW5nUHJvbWlzZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmNyZWF0ZUNhbmNlbGFibGVSb29tU2lnbmFsaW5nUHJvbWlzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfd3NTZXJ2ZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogd3NTZXJ2ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTaWduYWxpbmdWMi5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbiAobG9jYWxQYXJ0aWNpcGFudCwgdG9rZW4sIGVuY29kaW5nUGFyYW1ldGVycywgcHJlZmVycmVkQ29kZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUNhbmNlbGFibGVSb29tU2lnbmFsaW5nUHJvbWlzZS5iaW5kKG51bGwsIHRva2VuLCB0aGlzLl93c1NlcnZlciwgbG9jYWxQYXJ0aWNpcGFudCwgZW5jb2RpbmdQYXJhbWV0ZXJzLCBwcmVmZXJyZWRDb2RlY3MsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgU2lnbmFsaW5nVjIucHJvdG90eXBlLmNyZWF0ZUxvY2FsUGFydGljaXBhbnRTaWduYWxpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmdQYXJhbWV0ZXJzLCBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2NhbFBhcnRpY2lwYW50VjIoZW5jb2RpbmdQYXJhbWV0ZXJzLCBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24pO1xuICAgIH07XG4gICAgcmV0dXJuIFNpZ25hbGluZ1YyO1xufShTaWduYWxpbmcpKTtcbm1vZHVsZS5leHBvcnRzID0gU2lnbmFsaW5nVjI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIExvY2FsUGFydGljaXBhbnRTaWduYWxpbmcgPSByZXF1aXJlKCcuLi9sb2NhbHBhcnRpY2lwYW50Jyk7XG52YXIgTG9jYWxUcmFja1B1YmxpY2F0aW9uVjIgPSByZXF1aXJlKCcuL2xvY2FsdHJhY2twdWJsaWNhdGlvbicpO1xudmFyIGlzRGVlcEVxdWFsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLmlzRGVlcEVxdWFsO1xuLyoqXG4gKiBAZXh0ZW5kcyBQYXJ0aWNpcGFudFNpZ25hbGluZ1xuICogQHByb3BlcnR5IHtCYW5kd2lkdGhQcm9maWxlT3B0aW9uc30gYmFuZHdpZHRoUHJvZmlsZVxuICogQHByb3BlcnR5IHtOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25JbXBsfSBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXZpc2lvblxuICogQGVtaXRzIExvY2FsUGFydGljaXBhbnRWMiN1cGRhdGVkXG4gKi9cbnZhciBMb2NhbFBhcnRpY2lwYW50VjIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvY2FsUGFydGljaXBhbnRWMiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTG9jYWxQYXJ0aWNpcGFudFYyfS5cbiAgICAgKiBAcGFyYW0ge0VuY29kaW5nUGFyYW1ldGVyc0ltcGx9IGVuY29kaW5nUGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7TmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uSW1wbH0gbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvY2FsUGFydGljaXBhbnRWMihlbmNvZGluZ1BhcmFtZXRlcnMsIG5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBMb2NhbFRyYWNrUHVibGljYXRpb25WMjogTG9jYWxUcmFja1B1YmxpY2F0aW9uVjJcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9iYW5kd2lkdGhQcm9maWxlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZW5jb2RpbmdQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGVuY29kaW5nUGFyYW1ldGVyc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX0xvY2FsVHJhY2tQdWJsaWNhdGlvblYyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuTG9jYWxUcmFja1B1YmxpY2F0aW9uVjJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcHVibGlzaGVkUmV2aXNpb246IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZXZpc2lvbjoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NpZ25hbGluZ1JlZ2lvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFuZHdpZHRoUHJvZmlsZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYW5kd2lkdGhQcm9maWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYW5kd2lkdGhQcm9maWxlUmV2aXNpb246IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXZpc2lvbjoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXZpc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lnbmFsaW5nUmVnaW9uOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbGluZ1JlZ2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2lnbmFsaW5nUmVnaW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYWxpbmdSZWdpb24uXG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudFYyLnByb3RvdHlwZS5zZXRTaWduYWxpbmdSZWdpb24gPSBmdW5jdGlvbiAoc2lnbmFsaW5nUmVnaW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2lnbmFsaW5nUmVnaW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWxpbmdSZWdpb24gPSBzaWduYWxpbmdSZWdpb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUge0BsaW5rIEJhbmR3aWR0aFByb2ZpbGVPcHRpb25zfS5cbiAgICAgKiBAcGFyYW0ge0JhbmR3aWR0aFByb2ZpbGVPcHRpb25zfSBiYW5kd2lkdGhQcm9maWxlXG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudFYyLnByb3RvdHlwZS5zZXRCYW5kd2lkdGhQcm9maWxlID0gZnVuY3Rpb24gKGJhbmR3aWR0aFByb2ZpbGUpIHtcbiAgICAgICAgaWYgKCFpc0RlZXBFcXVhbCh0aGlzLl9iYW5kd2lkdGhQcm9maWxlLCBiYW5kd2lkdGhQcm9maWxlKSkge1xuICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogT2JqZWN0LmFzc2lnbigpIGNvcGllcyB0aGUgdmFsdWVzIG9mIG9ubHlcbiAgICAgICAgICAgIC8vIHRoZSB0b3AgbGV2ZWwgcHJvcGVydGllcy4gSW4gb3JkZXIgdG8gZGVlcCBjb3B5IHRoZSBvYmplY3QsIHdlXG4gICAgICAgICAgICAvLyBzdHJpbmdpZnkgYW5kIHBhcnNlIHRoZSBvYmplY3QuXG4gICAgICAgICAgICB0aGlzLl9iYW5kd2lkdGhQcm9maWxlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShiYW5kd2lkdGhQcm9maWxlKSk7XG4gICAgICAgICAgICB0aGlzLl9iYW5kd2lkdGhQcm9maWxlUmV2aXNpb24rKztcbiAgICAgICAgICAgIHRoaXMuZGlkVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUge0BsaW5rIEVuY29kaW5nUGFyYW1ldGVyc30uXG4gICAgICogQHBhcmFtIHs/RW5jb2RpbmdQYXJhbWV0ZXJzfSBlbmNvZGluZ1BhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50VjIucHJvdG90eXBlLnNldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoZW5jb2RpbmdQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRoaXMuX2VuY29kaW5nUGFyYW1ldGVycy51cGRhdGUoZW5jb2RpbmdQYXJhbWV0ZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50VjJ9IHdpdGggdGhlIG5ldyBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge1B1Ymxpc2hlZH0gcHVibGlzaGVkXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudFYyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAocHVibGlzaGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9wdWJsaXNoZWRSZXZpc2lvbiA+PSBwdWJsaXNoZWQucmV2aXNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3B1Ymxpc2hlZFJldmlzaW9uID0gcHVibGlzaGVkLnJldmlzaW9uO1xuICAgICAgICBwdWJsaXNoZWQudHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHB1YmxpY2F0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbFRyYWNrUHVibGljYXRpb25WMiA9IHRoaXMudHJhY2tzLmdldChwdWJsaWNhdGlvblN0YXRlLmlkKTtcbiAgICAgICAgICAgIGlmIChsb2NhbFRyYWNrUHVibGljYXRpb25WMikge1xuICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tQdWJsaWNhdGlvblYyLnVwZGF0ZShwdWJsaWNhdGlvblN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7RGF0YVRyYWNrU2VuZGVyfE1lZGlhVHJhY2tTZW5kZXJ9IHRyYWNrU2VuZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eVxuICAgICAqIEByZXR1cm5zIHtMb2NhbFRyYWNrUHVibGljYXRpb25WMn1cbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50VjIucHJvdG90eXBlLl9jcmVhdGVMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmcgPSBmdW5jdGlvbiAodHJhY2tTZW5kZXIsIG5hbWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5fTG9jYWxUcmFja1B1YmxpY2F0aW9uVjIodHJhY2tTZW5kZXIsIG5hbWUsIHByaW9yaXR5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb25WMn0gZm9yIHRoZSBnaXZlbiB7QGxpbmsgRGF0YVRyYWNrU2VuZGVyfVxuICAgICAqIG9yIHtAbGluayBNZWRpYVRyYWNrU2VuZGVyfSB0byB0aGUge0BsaW5rIExvY2FsUGFydGljaXBhbnRWMn0uXG4gICAgICogQHBhcmFtIHtEYXRhVHJhY2tTZW5kZXJ8TWVkaWFUcmFja1NlbmRlcn0gdHJhY2tTZW5kZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5XG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudFYyLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uICh0cmFja1NlbmRlciwgbmFtZSwgcHJpb3JpdHkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrU2VuZGVyLCBuYW1lLCBwcmlvcml0eSk7XG4gICAgICAgIHZhciBwdWJsaWNhdGlvbiA9IHRoaXMuZ2V0UHVibGljYXRpb24odHJhY2tTZW5kZXIpO1xuICAgICAgICB2YXIgaXNFbmFibGVkID0gcHVibGljYXRpb24uaXNFbmFibGVkLCB1cGRhdGVkUHJpb3JpdHkgPSBwdWJsaWNhdGlvbi51cGRhdGVkUHJpb3JpdHk7XG4gICAgICAgIHZhciB1cGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogVGhlIExvY2FsUGFydGljaXBhbnRWMidzIHN0YXRlIGlzIG9ubHkgcHVibGlzaGVkIGlmXG4gICAgICAgICAgICAvLyB0aGUgXCJ1cGRhdGVkXCIgZXZlbnQgaXMgZW1pdHRlZCBkdWUgdG8gTG9jYWxUcmFja1B1YmxpY2F0aW9uVjInc1xuICAgICAgICAgICAgLy8gLmlzRW5hYmxlZCBvciAudXBkYXRlZFByaW9yaXR5IGJlaW5nIGNoYW5nZWQuIFdlIGRvIG5vdCBwdWJsaXNoIGlmIGl0IGlzIGZpcmVkIGR1ZSB0byB0aGVcbiAgICAgICAgICAgIC8vIExvY2FsVHJhY2tQdWJsaWNhdGlvblYyJ3MgLnNpZCBiZWluZyBzZXQuXG4gICAgICAgICAgICBpZiAoaXNFbmFibGVkICE9PSBwdWJsaWNhdGlvbi5pc0VuYWJsZWQgfHwgdXBkYXRlZFByaW9yaXR5ICE9PSBwdWJsaWNhdGlvbi51cGRhdGVkUHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaWRVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICBpc0VuYWJsZWQgPSBwdWJsaWNhdGlvbi5pc0VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgdXBkYXRlZFByaW9yaXR5ID0gcHVibGljYXRpb24udXBkYXRlZFByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwdWJsaWNhdGlvbi5vbigndXBkYXRlZCcsIHVwZGF0ZWQpO1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcihwdWJsaWNhdGlvbik7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycy5zZXQocHVibGljYXRpb24sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHB1YmxpY2F0aW9uLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGVkJywgdXBkYXRlZCk7IH0pO1xuICAgICAgICB0aGlzLmRpZFVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtMb2NhbFRyYWNrUHVibGljYXRpb25WMn0gcHVibGljYXRpb25cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBMb2NhbFBhcnRpY2lwYW50VjIucHJvdG90eXBlLl9yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChwdWJsaWNhdGlvbikge1xuICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMuZ2V0KHB1YmxpY2F0aW9uKTtcbiAgICAgICAgaWYgKHJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50VjJ9LlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudFYyLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJldmlzaW9uOiB0aGlzLnJldmlzaW9uLFxuICAgICAgICAgICAgdHJhY2tzOiBBcnJheS5mcm9tKHRoaXMudHJhY2tzLnZhbHVlcygpKS5tYXAoZnVuY3Rpb24gKHRyYWNrKSB7IHJldHVybiB0cmFjay5nZXRTdGF0ZSgpOyB9KVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5jcmVtZW50IHRoZSByZXZpc2lvbiBmb3IgdGhlIHtAbGluayBMb2NhbFBhcnRpY2lwYW50VjJ9LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudFYyLnByb3RvdHlwZS5kaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JldmlzaW9uKys7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9uVjJ9IGZvciB0aGUgZ2l2ZW4ge0BsaW5rIERhdGFUcmFja1NlbmRlcn1cbiAgICAgKiBvciB7QGxpbmsgTWVkaWFUcmFja1NlbmRlcn0gZnJvbSB0aGUge0BsaW5rIExvY2FsUGFydGljaXBhbnRWMn0uXG4gICAgICogQHBhcmFtIHtEYXRhVHJhY2tTZW5kZXJ8TWVkaWFUcmFja1NlbmRlcn0gdHJhY2tTZW5kZXJcbiAgICAgKiBAcmV0dXJucyB7P0xvY2FsVHJhY2tQdWJsaWNhdGlvblYyfVxuICAgICAqL1xuICAgIExvY2FsUGFydGljaXBhbnRWMi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiAodHJhY2tTZW5kZXIpIHtcbiAgICAgICAgdmFyIHB1YmxpY2F0aW9uID0gX3N1cGVyLnByb3RvdHlwZS5yZW1vdmVUcmFjay5jYWxsKHRoaXMsIHRyYWNrU2VuZGVyKTtcbiAgICAgICAgaWYgKHB1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgICB0cmFja1NlbmRlci5yZW1vdmVDbG9uZShwdWJsaWNhdGlvbi50cmFja1RyYW5zY2VpdmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyKHB1YmxpY2F0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZGlkVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmVyYm9zaXR5IG9mIG5ldHdvcmsgcXVhbGl0eSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge05ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbn0gbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgTG9jYWxQYXJ0aWNpcGFudFYyLnByb3RvdHlwZS5zZXROZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiAobmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMubmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uLnVwZGF0ZShuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24pO1xuICAgIH07XG4gICAgLy8gbGliL3NpZ25hbGluZy92Mi9sb2NhbHBhcnRpY2lwYW50LmpzXG4gICAgTG9jYWxQYXJ0aWNpcGFudFYyLnByb3RvdHlwZS5zZXRQdWJsaXNoZXJIaW50cyA9IGZ1bmN0aW9uIChoaW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyAgICAgXCJoaW50c1wiOiBbXG4gICAgICAgIC8vICAgICAgIHtcbiAgICAgICAgLy8gICAgICAgICBcImVuY29kaW5nc1wiOiBbXG4gICAgICAgIC8vICAgICAgICAgICB7XG4gICAgICAgIC8vICAgICAgICAgICAgIFwiZW5hYmxlZFwiOiB0cnVlLFxuICAgICAgICAvLyAgICAgICAgICAgICBcImxheWVyX2luZGV4XCI6IDAsXG4gICAgICAgIC8vICAgICAgICAgICAgIFwibWF4X2JpdHJhdGVcIjogNTAwMDAwLFxuICAgICAgICAvLyAgICAgICAgICAgICBcIm1heF9mcmFtZXJhdGVcIjogNSxcbiAgICAgICAgLy8gICAgICAgICAgICAgXCJyZW5kZXJfZGltZW5zaW9uc1wiOiB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogMTgwLFxuICAgICAgICAvLyAgICAgICAgICAgICAgIFwid2lkdGhcIjogMzIwXG4gICAgICAgIC8vICAgICAgICAgICAgIH1cbiAgICAgICAgLy8gICAgICAgICAgIH0sXG4gICAgICAgIC8vICAgICAgICAgICB7XG4gICAgICAgIC8vICAgICAgICAgICAgIFwiZW5hYmxlZFwiOiBmYWxzZSxcbiAgICAgICAgLy8gICAgICAgICAgICAgXCJsYXllcl9pbmRleFwiOiAxXG4gICAgICAgIC8vICAgICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgXSxcbiAgICAgICAgLy8gICAgICAgICBcInRyYWNrXCI6IFwiTVQxMjNcIlxuICAgICAgICAvLyAgICAgICB9XG4gICAgICAgIC8vICAgICBdLFxuICAgICAgICBoaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHRyYWNrID0gX2EudHJhY2ssIGVuY29kaW5ncyA9IF9hLmVuY29kaW5ncztcbiAgICAgICAgICAgIHZhciB0cmFja1NpZ25hbGluZyA9IEFycmF5LmZyb20oX3RoaXMudHJhY2tzLnZhbHVlcygpKS5maW5kKGZ1bmN0aW9uICh0cmFja1B1YikgeyByZXR1cm4gdHJhY2tQdWIuc2lkID09PSB0cmFjazsgfSk7XG4gICAgICAgICAgICBpZiAodHJhY2tTaWduYWxpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcnRwU2VuZGVyID0gQXJyYXkuZnJvbSh0cmFja1NpZ25hbGluZy50cmFja1RyYW5zY2VpdmVyLl9zZW5kZXJzKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyc18xID0gcnRwU2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgICAgICAgICBlbmNvZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuYWJsZWQgPSBfYS5lbmFibGVkLCBsYXllckluZGV4ID0gX2EubGF5ZXJfaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNfMS5lbmNvZGluZ3NbbGF5ZXJJbmRleF0uYWN0aXZlID0gZW5hYmxlZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBydHBTZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd0cmFjayBzaWduYWxpbmcgbm90IGZvdW5kOiAnLCB0cmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2FsUGFydGljaXBhbnRWMjtcbn0oTG9jYWxQYXJ0aWNpcGFudFNpZ25hbGluZykpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFB1Ymxpc2hlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJldmlzaW9uXG4gKiBAcHJvcGVydHkge0FycmF5PFB1Ymxpc2hlZFRyYWNrPn0gdHJhY2tzXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge0NyZWF0ZWRUcmFja3xSZWFkeVRyYWNrfEZhaWxlZFRyYWNrfSBQdWJsaXNoZWRUcmFja1xuICovXG4vKipcbiAqIEBpbnRlcmZhY2UgQ3JlYXRlZFRyYWNrXG4gKiBAcHJvcGVydHkge1RyYWNrLklEfSBpZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gXCJjcmVhdGVkXCJcbiAqL1xuLyoqXG4gKiBAaW50ZXJmYWNlIFJlYWR5VHJhY2tcbiAqIEBwcm9wZXJ0eSB7VHJhY2suSUR9IGlkXG4gKiBAcHJvcGVydHkge1RyYWNrLlNJRH0gc2lkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBcInJlYWR5XCJcbiAqL1xuLyoqXG4gKiBAaW50ZXJmYWNlIEZhaWxlZFRyYWNrXG4gKiBAcHJvcGVydHkge1RyYWNrLklEfSBpZFxuICogQHByb3BlcnR5IHtUcmFja0Vycm9yfSBlcnJvclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gXCJmYWlsZWRcIlxuICovXG4vKipcbiAqIEBpbnRlcmZhY2UgVHJhY2tFcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbi8qKlxuICogQGV2ZW50IExvY2FsUGFydGljaXBhbnRWMiN1cGRhdGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxQYXJ0aWNpcGFudFYyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxwYXJ0aWNpcGFudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZyA9IHJlcXVpcmUoJy4uL2xvY2FsdHJhY2twdWJsaWNhdGlvbicpO1xudmFyIGNyZWF0ZVR3aWxpb0Vycm9yID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90d2lsaW8tdmlkZW8tZXJyb3JzJykuY3JlYXRlVHdpbGlvRXJyb3I7XG4vKipcbiAqIEBleHRlbmRzIExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ1xuICovXG52YXIgTG9jYWxUcmFja1B1YmxpY2F0aW9uVjIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvY2FsVHJhY2tQdWJsaWNhdGlvblYyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb25WMn0uXG4gICAgICogQHBhcmFtIHtEYXRhVHJhY2tTZW5kZXJ8TWVkaWFUcmFja1NlbmRlcn0gdHJhY2tTZW5kZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5XG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9jYWxUcmFja1B1YmxpY2F0aW9uVjIodHJhY2tTZW5kZXIsIG5hbWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB0cmFja1NlbmRlciwgbmFtZSwgcHJpb3JpdHkpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUge0BsaW5rIExvY2FsVHJhY2tQdWJsaWNhdGlvblYyI1JlcHJlc2VudGF0aW9ufSBvZiBhIGdpdmVuIHtAbGluayBUcmFja1NpZ25hbGluZ30uXG4gICAgICogQHJldHVybnMge0xvY2FsVHJhY2tQdWJsaWNhdGlvblYyI1JlcHJlc2VudGF0aW9ufSAtIHdpdGhvdXQgdGhlIFNJRFxuICAgICAqL1xuICAgIExvY2FsVHJhY2tQdWJsaWNhdGlvblYyLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMuaXNFbmFibGVkLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBwcmlvcml0eTogdGhpcy51cGRhdGVkUHJpb3JpdHlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdGhlIHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb25WMn0gdG8gYSB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9uVjIjUmVwcmVzZW50YXRpb259IG9mIGl0c2VsZlxuICAgICAqIGFuZCBwZXJmb3JtIGFueSB1cGRhdGVzIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0ge1B1Ymxpc2hlZFRyYWNrfSB0cmFja1xuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBmaXJlcyBUcmFja1NpZ25hbGluZyN1cGRhdGVkXG4gICAgICovXG4gICAgTG9jYWxUcmFja1B1YmxpY2F0aW9uVjIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICBzd2l0Y2ggKHRyYWNrLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdyZWFkeSc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTaWQodHJhY2suc2lkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6IHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSB0cmFjay5lcnJvcjtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hGYWlsZWQoY3JlYXRlVHdpbGlvRXJyb3IoZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDogLy8gJ2NyZWF0ZWQnXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxUcmFja1B1YmxpY2F0aW9uVjI7XG59KExvY2FsVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZykpO1xuLyoqXG4gKiBUaGUgUm9vbSBTaWduYWxpbmcgUHJvdG9jb2wgKFJTUCkgcmVwcmVzZW50YXRpb24gb2YgYSB7QGxpbmsgTG9jYWxUcmFja1B1YmxpY2F0aW9uVjJ9LlxuICogQHR5cGVkZWYge29iamVjdH0gTG9jYWxUcmFja1B1YmxpY2F0aW9uVjIjUmVwcmVzZW50YXRpb25cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZW5hYmxlZFxuICogQHByb3BlcnR5IHtUcmFjay5JRH0gaWRcbiAqIEBwcm9wZXJ0eSB7VHJhY2suS2luZH0ga2luZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqIEBwcmlvcml0eSB7VHJhY2suUHJpb3JpdHl9IHByaW9yaXR5XG4gKiBAcHJvcGVydHkge1RyYWNrLlNJRH0gc2lkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxUcmFja1B1YmxpY2F0aW9uVjI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbHRyYWNrcHVibGljYXRpb24uanMubWFwIiwiLyogZXNsaW50IGNhbGxiYWNrLXJldHVybjowICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xudmFyIG5JbnN0YW5jZXMgPSAwO1xudmFyIE1lZGlhU2lnbmFsaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZWRpYVNpZ25hbGluZywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTWVkaWFTaWduYWxpbmd9LlxuICAgICAqIEBwYXJhbSB7UHJvbWlzZTxEYXRhVHJhY2tSZWNlaXZlcj59IGdldFJlY2VpdmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1lZGlhU2lnbmFsaW5nKGdldFJlY2VpdmVyLCBjaGFubmVsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfaW5zdGFuY2VJZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuSW5zdGFuY2VzKytcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFubmVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoYW5uZWwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xvZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmxvZy5jcmVhdGVMb2coJ2RlZmF1bHQnLCBfdGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0UmVjZWl2ZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0UmVjZWl2ZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVjZWl2ZXJQcm9taXNlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RyYW5zcG9ydDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZWRpYVNpZ25hbGluZy5wcm90b3R5cGUsIFwiaXNTZXR1cFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fcmVjZWl2ZXJQcm9taXNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWVkaWFTaWduYWxpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbTWVkaWFTaWduYWxpbmcgI1wiICsgdGhpcy5faW5zdGFuY2VJZCArIFwiOlwiICsgdGhpcy5jaGFubmVsICsgXCJdXCI7XG4gICAgfTtcbiAgICBNZWRpYVNpZ25hbGluZy5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdGVhcmRvd24oKTtcbiAgICAgICAgdGhpcy5fbG9nLmluZm8oJ3NldHRpbmcgdXAgbXNwIHRyYW5zcG9ydCBmb3IgaWQ6JywgaWQpO1xuICAgICAgICB2YXIgcmVjZWl2ZXJQcm9taXNlID0gdGhpcy5fZ2V0UmVjZWl2ZXIoaWQpLnRoZW4oZnVuY3Rpb24gKHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIua2luZCAhPT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5lcnJvcignRXhwZWN0ZWQgYSBEYXRhVHJhY2tSZWNlaXZlcicpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBEYXRhVHJhY2tSZWNlaXZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLl9yZWNlaXZlclByb21pc2UgIT09IHJlY2VpdmVyUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RyYW5zcG9ydCA9IHJlY2VpdmVyLnRvRGF0YVRyYW5zcG9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5lcnJvcignRmFpbGVkIHRvIHRvRGF0YVRyYW5zcG9ydCcpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHRvRGF0YVRyYW5zcG9ydCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZW1pdCgncmVhZHknLCBfdGhpcy5fdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIHJlY2VpdmVyLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3RlYXJkb3duKCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXJQcm9taXNlID0gcmVjZWl2ZXJQcm9taXNlO1xuICAgIH07XG4gICAgTWVkaWFTaWduYWxpbmcucHJvdG90eXBlLl90ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmluZm8oJ1RlYXJpbmcgZG93bicpO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlY2VpdmVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3RlYXJkb3duJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZWRpYVNpZ25hbGluZztcbn0oRXZlbnRFbWl0dGVyKSk7XG5tb2R1bGUuZXhwb3J0cyA9IE1lZGlhU2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWFzaWduYWxpbmcuanMubWFwIiwiLyogZXNsaW50IGNhbGxiYWNrLXJldHVybjowICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xudmFyIFBlZXJDb25uZWN0aW9uUmVwb3J0RmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uL3N0YXRzL3BlZXJjb25uZWN0aW9ucmVwb3J0ZmFjdG9yeScpO1xuLyoqXG4gKiBAZW1pdHMgTmV0d29ya1F1YWxpdHlNb25pdG9yI3VwZGF0ZWRcbiAqL1xudmFyIE5ldHdvcmtRdWFsaXR5TW9uaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV0d29ya1F1YWxpdHlNb25pdG9yLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBOZXR3b3JrUXVhbGl0eU1vbml0b3J9LlxuICAgICAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25NYW5hZ2VyfSBtYW5hZ2VyXG4gICAgICogQHBhcmFtIHtOZXR3b3JrUXVhbGl0eVNpZ25hbGluZ30gc2lnbmFsaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gTmV0d29ya1F1YWxpdHlNb25pdG9yKG1hbmFnZXIsIHNpZ25hbGluZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX2ZhY3Rvcmllczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgV2Vha01hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21hbmFnZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWFuYWdlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2lnbmFsaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzaWduYWxpbmcub24oJ3VwZGF0ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5lbWl0KCd1cGRhdGVkJyk7IH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXR3b3JrUXVhbGl0eU1vbml0b3IucHJvdG90eXBlLCBcImxldmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0sIGlmIGFueS5cbiAgICAgICAgICogQHJldHVybnMgez9OZXR3b3JrUXVhbGl0eUxldmVsfSBsZXZlbCAtIGluaXRpYWxseSBudWxsXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduYWxpbmcubGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmV0d29ya1F1YWxpdHlNb25pdG9yLnByb3RvdHlwZSwgXCJsZXZlbHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsc30sIGlmIGFueS5cbiAgICAgICAgICogQHJldHVybnMgez9OZXR3b3JrUXVhbGl0eUxldmVsc30gbGV2ZWxzIC0gaW5pdGlhbGx5IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbGluZy5sZXZlbHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmV0d29ya1F1YWxpdHlNb25pdG9yLnByb3RvdHlwZSwgXCJyZW1vdGVMZXZlbHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsc30gb2YgcmVtb3RlIHBhcnRpY2lwYW50cywgaWYgYW55LlxuICAgICAgICAgKiBAcmV0dXJucyB7TWFwPFN0cmluZywgTmV0d29ya1F1YWxpdHlMZXZlbHM+fSByZW1vdGVMZXZlbHNcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbGluZy5yZW1vdGVMZXZlbHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBtb25pdG9yaW5nLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIE5ldHdvcmtRdWFsaXR5TW9uaXRvci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl90aW1lb3V0ICE9PSB0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dChfdGhpcykudGhlbihmdW5jdGlvbiAocmVwb3J0cykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fdGltZW91dCAhPT0gdGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQocmVwb3J0cywgMSksIHJlcG9ydCA9IF9hWzBdO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2lnbmFsaW5nLnB1dChyZXBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSB0aW1lb3V0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcCBtb25pdG9yaW5nLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIE5ldHdvcmtRdWFsaXR5TW9uaXRvci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBOZXR3b3JrUXVhbGl0eU1vbml0b3I7XG59KEV2ZW50RW1pdHRlcikpO1xuLyoqXG4gKiBAcGFyYW0ge05ldHdvcmtRdWFsaXR5TW9uaXRvcn1cbiAqIEByZXR1cm5zIHtQcm9taXNlPE5ldHdvcmtRdWFsaXR5SW5wdXRzPn1cbiAqL1xuZnVuY3Rpb24gbmV4dChtb25pdG9yKSB7XG4gICAgdmFyIHBjdjJzID0gbW9uaXRvci5fbWFuYWdlci5fcGVlckNvbm5lY3Rpb25zXG4gICAgICAgID8gQXJyYXkuZnJvbShtb25pdG9yLl9tYW5hZ2VyLl9wZWVyQ29ubmVjdGlvbnMudmFsdWVzKCkpXG4gICAgICAgIDogW107XG4gICAgdmFyIHBjcyA9IHBjdjJzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHBjdjIpIHsgcmV0dXJuIHBjdjIuX3BlZXJDb25uZWN0aW9uOyB9KVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwYykgeyByZXR1cm4gcGMuc2lnbmFsaW5nU3RhdGUgIT09ICdjbG9zZWQnOyB9KTtcbiAgICB2YXIgZmFjdG9yaWVzID0gcGNzLm1hcChmdW5jdGlvbiAocGMpIHtcbiAgICAgICAgaWYgKG1vbml0b3IuX2ZhY3Rvcmllcy5oYXMocGMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9uaXRvci5fZmFjdG9yaWVzLmdldChwYyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZhY3RvcnkgPSBuZXcgUGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5KHBjKTtcbiAgICAgICAgbW9uaXRvci5fZmFjdG9yaWVzLnNldChwYywgZmFjdG9yeSk7XG4gICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgIH0pO1xuICAgIHZhciByZXBvcnRzT3JOdWxsUHJvbWlzZXMgPSBmYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChmYWN0b3J5KSB7IHJldHVybiBmYWN0b3J5Lm5leHQoKS5jYXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9KTsgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHJlcG9ydHNPck51bGxQcm9taXNlcykudGhlbihmdW5jdGlvbiAocmVwb3J0c09yTnVsbCkgeyByZXR1cm4gcmVwb3J0c09yTnVsbFxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChyZXBvcnRPck51bGwpIHsgcmV0dXJuIHJlcG9ydE9yTnVsbDsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocmVwb3J0KSB7IHJldHVybiByZXBvcnQuc3VtbWFyaXplKCk7IH0pOyB9KTtcbn1cbi8qKlxuICogVGhlIHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfSBjaGFuZ2VkLlxuICogQGV2ZW50IE5ldHdvcmtRdWFsaXR5TW9uaXRvciN1cGRhdGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya1F1YWxpdHlNb25pdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29ya3F1YWxpdHltb25pdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTWVkaWFTaWduYWxpbmcgPSByZXF1aXJlKCcuL21lZGlhc2lnbmFsaW5nJyk7XG52YXIgQXN5bmNWYXIgPSByZXF1aXJlKCcuLi8uLi91dGlsL2FzeW5jdmFyJyk7XG4vKipcbiAqIEBpbnRlcmZhY2UgTWVkaWFTaWduYWxpbmdUcmFuc3BvcnRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24ob2JqZWN0KTogYm9vbGVhbn0gc2VuZFxuICogQGVtaXRzIE1lZGlhU2lnbmFsaW5nVHJhbnNwb3J0I21lc3NhZ2VcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIE1lZGlhU2lnbmFsaW5nVHJhbnNwb3J0fSByZWNlaXZlZCBhIG1lc3NhZ2UuXG4gKiBAZXZlbnQgTWVkaWFTaWduYWxpbmdUcmFuc3BvcnQjbWVzc2FnZVxuICogQHBhcmFtIHtvYmplY3R9IG1lc3NhZ2VcbiAqL1xuLyoqXG4gKiBAaW50ZXJmYWNlIExhdGVuY3lTdGF0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGppdHRlclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJ0dFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVsXG4gKi9cbi8qKlxuICogQGludGVyZmFjZSBGcmFjdGlvbkxvc3RTdGF0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGZyYWN0aW9uTG9zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVsXG4gKi9cbi8qKlxuICogQGludGVyZmFjZSBCYW5kd2lkdGhTdGF0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGFjdHVhbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGF2YWlsYWJsZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVsXG4gKi9cbi8qKlxuICogQGludGVyZmFjZSBTZW5kT3JSZWN2U3RhdHNcbiAqIEBwcm9wZXJ0eSB7QmFuZHdpZHRoU3RhdHN9IGJhbmR3aWR0aFxuICogQHByb3BlcnR5IHtGcmFjdGlvbkxvc3RTdGF0c30gZnJhY3Rpb25Mb3N0XG4gKiBAcHJvcGVydHkge0xhdGVuY3lTdGF0c30gbGF0ZW5jeVxuICovXG4vKipcbiAqIEBpbnRlcmZhY2UgTWVkaWFMZXZlbHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZW5kXG4gKiBAcHJvcGVydHkge1NlbmRPclJlY3ZTdGF0c30gc2VuZFN0YXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmVjdlxuICogQHByb3BlcnR5IHtTZW5kT3JSZWN2U3RhdHN9IHJlY3ZTdGF0c1xuICovXG4vKipcbiAqIEBpbnRlcmZhY2UgTmV0d29ya1F1YWxpdHlMZXZlbHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZXZlbFxuICogQHByb3BlcnR5IHtNZWRpYUxldmVsc30gYXVkaW9cbiAqIEBwcm9wZXJ0eSB7TWVkaWFMZXZlbHN9IHZpZGVvXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge1BlZXJDb25uZWN0aW9uU3VtbWFyeX0gTmV0d29ya1F1YWxpdHlJbnB1dHNcbiAqL1xuLyoqXG4gKiBAY2xhc3NkZXNjIFRoZSB7QGxpbmsgTmV0d29ya1F1YWxpdHlTaWduYWxpbmd9IGNsYXNzIGFsbG93cyBzdWJtaXR0aW5nXG4gKiAgIHtAbGluayBOZXR3b3JrUXVhbGl0eUlucHV0c30gZm9yIGNvbXB1dGluZyB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0uIEl0XG4gKiAgIGRvZXMgc28gYnkgc2VuZGluZyBhbmQgcmVjZWl2aW5nIG1lc3NhZ2VzIG92ZXIgYVxuICogICB7QGxpbmsgTWVkaWFTaWduYWxpbmdUcmFuc3BvcnR9LiBUaGUgZXhhY3QgdHJhbnNwb3J0IHVzZWQgZGVwZW5kcyBvbiB0aGVcbiAqICAgdG9wb2xvZ3kgb2YgdGhlIHtAbGluayBSb29tfSB0aGF0IHtAbGluayBOZXR3b3JrUXVhbGl0eVNpZ25hbGluZ30gaXMgYmVpbmdcbiAqICAgdXNlZCB3aXRoaW46IGZvciBQMlAgUm9vbXMsIHdlIHJlLXVzZSB0aGUge0BsaW5rIFRyYW5zcG9ydFYyfTsgYW5kIGZvclxuICogICBHcm91cCBSb29tcywgd2UgdXNlIGEge0BsaW5rIERhdGFUcmFuc3BvcnR9LlxuICogQGVtaXRzIE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nI3VwZGF0ZWRcbiAqL1xudmFyIE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXR3b3JrUXVhbGl0eVNpZ25hbGluZywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTmV0d29ya1F1YWxpdHlTaWduYWxpbmd9LlxuICAgICAqIEBwYXJhbSB7UHJvbWlzZTxEYXRhVHJhY2tSZWNlaXZlcj59IGdldFJlY2VpdmVyXG4gICAgICogQHBhcmFtIHtOZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25JbXBsfSBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZXR3b3JrUXVhbGl0eVNpZ25hbGluZyhnZXRSZWNlaXZlciwgbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdldFJlY2VpdmVyLCAnbmV0d29ya19xdWFsaXR5Jywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9sZXZlbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xldmVsczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlbW90ZUxldmVsczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbmV0d29ya1F1YWxpdHlJbnB1dHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IEFzeW5jVmFyKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbmV0d29ya1F1YWxpdHlSZXBvcnRMZXZlbHM6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydExldmVsOiBuZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24ubG9jYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVSZXBvcnRMZXZlbDogbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uLnJlbW90ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uKCdyZWFkeScsIGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmV0d29ya19xdWFsaXR5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVOZXR3b3JrUXVhbGl0eU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuX3NlbmROZXR3b3JrUXVhbGl0eUlucHV0cygpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXR3b3JrUXVhbGl0eVNpZ25hbGluZy5wcm90b3R5cGUsIFwibGV2ZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfSwgaWYgYW55LlxuICAgICAgICAgKiBAcmV0dXJucyB7P05ldHdvcmtRdWFsaXR5TGV2ZWx9IGxldmVsIC0gaW5pdGlhbGx5IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nLnByb3RvdHlwZSwgXCJsZXZlbHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsc30sIGlmIGFueS5cbiAgICAgICAgICogQHJldHVybnMgez9OZXR3b3JrUXVhbGl0eUxldmVsc30gbGV2ZWxzIC0gaW5pdGlhbGx5IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xldmVscztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXR3b3JrUXVhbGl0eVNpZ25hbGluZy5wcm90b3R5cGUsIFwicmVtb3RlTGV2ZWxzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbHN9IG9mIHJlbW90ZSBwYXJ0aWNpcGFudHMsIGlmIGFueS5cbiAgICAgICAgICogQHJldHVybnMge01hcDxTdHJpbmcsIE5ldHdvcmtRdWFsaXR5TGV2ZWxzPn0gcmVtb3RlTGV2ZWxzXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVMZXZlbHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfSBpcyBuZXcsIGFuZCByYWlzZSBhblxuICAgICAqIGV2ZW50IGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtZXNzYWdlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgTmV0d29ya1F1YWxpdHlTaWduYWxpbmcucHJvdG90eXBlLl9oYW5kbGVOZXR3b3JrUXVhbGl0eU1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgbGV2ZWwgPSBudWxsO1xuICAgICAgICB2YXIgbG9jYWwgPSBtZXNzYWdlID8gbWVzc2FnZS5sb2NhbCA6IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBOT1RFKG1yb2JlcnRzKTogSW4gcHJvZCwgd2UgcGxhbiB0byBvbmx5IHNlbmQgdGhlIGxldmVsLlxuICAgICAgICAgICAgbGV2ZWwgPSBsb2NhbDtcbiAgICAgICAgICAgIHRoaXMuX2xldmVscyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvY2FsID09PSAnb2JqZWN0JyAmJiBsb2NhbCkge1xuICAgICAgICAgICAgLy8gTk9URShtcm9iZXJ0cyk6IEluIGRldiwgd2UgcGxhbiB0byBzZW5kIHRoZSBkZWNvbXBvc2VkIGxldmVscy4gQW4gZWFybHlcbiAgICAgICAgICAgIC8vIFZNUyB2ZXJzaW9uIGRvZXMgbm90IGNvbXB1dGUgYGxldmVsYCBmb3IgdXMsIHNvIHdlIGZhbGxiYWNrIHRvIHRha2luZ1xuICAgICAgICAgICAgLy8gdGhlIG1pbmltdW0gb3Vyc2VsdmVzLlxuICAgICAgICAgICAgdGhpcy5fbGV2ZWxzID0gbG9jYWw7XG4gICAgICAgICAgICBsZXZlbCA9IHR5cGVvZiBsb2NhbC5sZXZlbCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IGxvY2FsLmxldmVsXG4gICAgICAgICAgICAgICAgOiBNYXRoLm1pbihsb2NhbC5hdWRpby5zZW5kLCBsb2NhbC5hdWRpby5yZWN2LCBsb2NhbC52aWRlby5zZW5kLCBsb2NhbC52aWRlby5yZWN2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgIT09IG51bGwgJiYgdGhpcy5sZXZlbCAhPT0gbGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVMZXZlbHMgPSBtZXNzYWdlICYmIG1lc3NhZ2UucmVtb3Rlc1xuICAgICAgICAgICAgPyBtZXNzYWdlLnJlbW90ZXMucmVkdWNlKGZ1bmN0aW9uIChsZXZlbHMsIG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBvbGRPYmogPSBfdGhpcy5fcmVtb3RlTGV2ZWxzLmdldChvYmouc2lkKSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAob2xkT2JqLmxldmVsICE9PSBvYmoubGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsZXZlbHMuc2V0KG9iai5zaWQsIG9iaik7XG4gICAgICAgICAgICB9LCBuZXcgTWFwKCkpXG4gICAgICAgICAgICA6IHRoaXMuX3JlbW90ZUxldmVscztcbiAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NlbmROZXR3b3JrUXVhbGl0eUlucHV0cygpOyB9LCAxMDAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IHNlbmRpbmcge0BsaW5rIE5ldHdvcmtRdWFsaXR5SW5wdXRzfS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nLnByb3RvdHlwZS5fc2VuZE5ldHdvcmtRdWFsaXR5SW5wdXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29ya1F1YWxpdHlJbnB1dHMudGFrZSgpLnRoZW4oZnVuY3Rpb24gKG5ldHdvcmtRdWFsaXR5SW5wdXRzKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl90cmFuc3BvcnQucHVibGlzaChjcmVhdGVOZXR3b3JrUXVhbGl0eUlucHV0c01lc3NhZ2UobmV0d29ya1F1YWxpdHlJbnB1dHMsIF90aGlzLl9uZXR3b3JrUXVhbGl0eVJlcG9ydExldmVscykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1dCB7QGxpbmsgTmV0d29ya1F1YWxpdHlJbnB1dHN9IHRvIGJlIHVzZWQgZm9yIGNvbXB1dGluZ1xuICAgICAqIHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfS5cbiAgICAgKiBAcGFyYW0ge05ldHdvcmtRdWFsaXR5SW5wdXRzfSBuZXR3b3JrUXVhbGl0eUlucHV0c1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAobmV0d29ya1F1YWxpdHlJbnB1dHMpIHtcbiAgICAgICAgdGhpcy5fbmV0d29ya1F1YWxpdHlJbnB1dHMucHV0KG5ldHdvcmtRdWFsaXR5SW5wdXRzKTtcbiAgICB9O1xuICAgIHJldHVybiBOZXR3b3JrUXVhbGl0eVNpZ25hbGluZztcbn0oTWVkaWFTaWduYWxpbmcpKTtcbi8qKlxuICogVGhlIHtAbGluayBOZXR3b3JrUXVhbGl0eUxldmVsfSBjaGFuZ2VkLlxuICogQGV2ZW50IE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nI3VwZGF0ZWRcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBOZXR3b3JrUXVhbGl0eVJlcG9ydExldmVsc1xuICogQHBhcmFtIHtudW1iZXJ9IHJlcG9ydExldmVsXG4gKiBAcGFyYW0ge251bWJlcn0gcmVtb3RlUmVwb3J0TGV2ZWxcbiAqL1xuLyoqXG4gKiBAcGFyYW0ge05ldHdvcmtRdWFsaXR5SW5wdXRzfSBuZXR3b3JrUXVhbGl0eUlucHV0c1xuICogQHBhcmFtIHtOZXR3b3JrUXVhbGl0eVJlcG9ydExldmVsc30gbmV0d29ya1F1YWxpdHlSZXBvcnRMZXZlbHNcbiAqIEByZXR1cm5zIHtvYmplY3R9IG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTmV0d29ya1F1YWxpdHlJbnB1dHNNZXNzYWdlKG5ldHdvcmtRdWFsaXR5SW5wdXRzLCBuZXR3b3JrUXVhbGl0eVJlcG9ydExldmVscykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgdHlwZTogJ25ldHdvcmtfcXVhbGl0eScgfSwgbmV0d29ya1F1YWxpdHlJbnB1dHMsIG5ldHdvcmtRdWFsaXR5UmVwb3J0TGV2ZWxzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya1F1YWxpdHlTaWduYWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrcXVhbGl0eXNpZ25hbGluZy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgICAgICB0b1tqXSA9IGZyb21baV07XG4gICAgcmV0dXJuIHRvO1xufTtcbnZhciBEZWZhdWx0QmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvZmYnKTtcbnZhciBfYSA9IHJlcXVpcmUoJ0B0d2lsaW8vd2VicnRjJyksIERlZmF1bHRNZWRpYVN0cmVhbSA9IF9hLk1lZGlhU3RyZWFtLCBEZWZhdWx0UlRDSWNlQ2FuZGlkYXRlID0gX2EuUlRDSWNlQ2FuZGlkYXRlLCBEZWZhdWx0UlRDUGVlckNvbm5lY3Rpb24gPSBfYS5SVENQZWVyQ29ubmVjdGlvbiwgRGVmYXVsdFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IF9hLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiwgZ2V0U3RhdGlzdGljcyA9IF9hLmdldFN0YXRzO1xudmFyIGd1ZXNzQnJvd3NlciA9IHJlcXVpcmUoJ0B0d2lsaW8vd2VicnRjL2xpYi91dGlsJykuZ3Vlc3NCcm93c2VyO1xudmFyIGdldFNkcEZvcm1hdCA9IHJlcXVpcmUoJ0B0d2lsaW8vd2VicnRjL2xpYi91dGlsL3NkcCcpLmdldFNkcEZvcm1hdDtcbnZhciBfYiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uc3RhbnRzJyksIERFRkFVTFRfSUNFX0dBVEhFUklOR19USU1FT1VUX01TID0gX2IuREVGQVVMVF9JQ0VfR0FUSEVSSU5HX1RJTUVPVVRfTVMsIERFRkFVTFRfTE9HX0xFVkVMID0gX2IuREVGQVVMVF9MT0dfTEVWRUwsIERFRkFVTFRfU0VTU0lPTl9USU1FT1VUX1NFQyA9IF9iLkRFRkFVTFRfU0VTU0lPTl9USU1FT1VUX1NFQywgaWNlUmVzdGFydEJhY2tvZmZDb25maWcgPSBfYi5pY2VSZXN0YXJ0QmFja29mZkNvbmZpZztcbnZhciBfYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvc2RwJyksIGNyZWF0ZUNvZGVjTWFwRm9yTWVkaWFTZWN0aW9uID0gX2MuY3JlYXRlQ29kZWNNYXBGb3JNZWRpYVNlY3Rpb24sIGRpc2FibGVSdHggPSBfYy5kaXNhYmxlUnR4LCBlbmFibGVEdHhGb3JPcHVzID0gX2MuZW5hYmxlRHR4Rm9yT3B1cywgZ2V0TWVkaWFTZWN0aW9ucyA9IF9jLmdldE1lZGlhU2VjdGlvbnMsIHJlbW92ZVNTUkNBdHRyaWJ1dGVzID0gX2MucmVtb3ZlU1NSQ0F0dHJpYnV0ZXMsIHJldmVydFNpbXVsY2FzdEZvck5vblZQOE1lZGlhU2VjdGlvbnMgPSBfYy5yZXZlcnRTaW11bGNhc3RGb3JOb25WUDhNZWRpYVNlY3Rpb25zLCBzZXRCaXRyYXRlUGFyYW1ldGVycyA9IF9jLnNldEJpdHJhdGVQYXJhbWV0ZXJzLCBzZXRDb2RlY1ByZWZlcmVuY2VzID0gX2Muc2V0Q29kZWNQcmVmZXJlbmNlcywgc2V0U2ltdWxjYXN0ID0gX2Muc2V0U2ltdWxjYXN0LCB1bmlmaWVkUGxhbkFkZE9yUmV3cml0ZU5ld1RyYWNrSWRzID0gX2MudW5pZmllZFBsYW5BZGRPclJld3JpdGVOZXdUcmFja0lkcywgdW5pZmllZFBsYW5BZGRPclJld3JpdGVUcmFja0lkcyA9IF9jLnVuaWZpZWRQbGFuQWRkT3JSZXdyaXRlVHJhY2tJZHMsIHVuaWZpZWRQbGFuRmlsdGVyTG9jYWxDb2RlY3MgPSBfYy51bmlmaWVkUGxhbkZpbHRlckxvY2FsQ29kZWNzO1xudmFyIERlZmF1bHRUaW1lb3V0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90aW1lb3V0Jyk7XG52YXIgX2QgPSByZXF1aXJlKCcuLi8uLi91dGlsL3R3aWxpby12aWRlby1lcnJvcnMnKSwgTWVkaWFDbGllbnRMb2NhbERlc2NGYWlsZWRFcnJvciA9IF9kLk1lZGlhQ2xpZW50TG9jYWxEZXNjRmFpbGVkRXJyb3IsIE1lZGlhQ2xpZW50UmVtb3RlRGVzY0ZhaWxlZEVycm9yID0gX2QuTWVkaWFDbGllbnRSZW1vdGVEZXNjRmFpbGVkRXJyb3I7XG52YXIgX2UgPSByZXF1aXJlKCcuLi8uLi91dGlsJyksIGJ1aWxkTG9nTGV2ZWxzID0gX2UuYnVpbGRMb2dMZXZlbHMsIGdldFBsYXRmb3JtID0gX2UuZ2V0UGxhdGZvcm0sIGlzQ2hyb21lU2NyZWVuU2hhcmVUcmFjayA9IF9lLmlzQ2hyb21lU2NyZWVuU2hhcmVUcmFjaywgb25jZVBlclRpY2sgPSBfZS5vbmNlUGVyVGljaztcbnZhciBJY2VCb3ggPSByZXF1aXJlKCcuL2ljZWJveCcpO1xudmFyIERlZmF1bHRJY2VDb25uZWN0aW9uTW9uaXRvciA9IHJlcXVpcmUoJy4vaWNlY29ubmVjdGlvbm1vbml0b3IuanMnKTtcbnZhciBEYXRhVHJhY2tSZWNlaXZlciA9IHJlcXVpcmUoJy4uLy4uL2RhdGEvcmVjZWl2ZXInKTtcbnZhciBNZWRpYVRyYWNrUmVjZWl2ZXIgPSByZXF1aXJlKCcuLi8uLi9tZWRpYS90cmFjay9yZWNlaXZlcicpO1xudmFyIFN0YXRlTWFjaGluZSA9IHJlcXVpcmUoJy4uLy4uL3N0YXRlbWFjaGluZScpO1xudmFyIExvZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbG9nJyk7XG52YXIgSWRlbnRpdHlUcmFja01hdGNoZXIgPSByZXF1aXJlKCcuLi8uLi91dGlsL3NkcC90cmFja21hdGNoZXIvaWRlbnRpdHknKTtcbnZhciBPcmRlcmVkVHJhY2tNYXRjaGVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9zZHAvdHJhY2ttYXRjaGVyL29yZGVyZWQnKTtcbnZhciBNSURUcmFja01hdGNoZXIgPSByZXF1aXJlKCcuLi8uLi91dGlsL3NkcC90cmFja21hdGNoZXIvbWlkJyk7XG52YXIgd29ya2Fyb3VuZElzc3VlODMyOSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvc2RwL2lzc3VlODMyOScpO1xudmFyIGd1ZXNzID0gZ3Vlc3NCcm93c2VyKCk7XG52YXIgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybSgpO1xudmFyIGlzQW5kcm9pZCA9IC9hbmRyb2lkLy50ZXN0KHBsYXRmb3JtKTtcbnZhciBpc0Nocm9tZSA9IGd1ZXNzID09PSAnY2hyb21lJztcbnZhciBpc0ZpcmVmb3ggPSBndWVzcyA9PT0gJ2ZpcmVmb3gnO1xudmFyIGlzU2FmYXJpID0gZ3Vlc3MgPT09ICdzYWZhcmknO1xudmFyIGlzUlRDUnRwU2VuZGVyUGFyYW1zU3VwcG9ydGVkID0gdHlwZW9mIFJUQ1J0cFNlbmRlciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB0eXBlb2YgUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIFJUQ1J0cFNlbmRlci5wcm90b3R5cGUuc2V0UGFyYW1ldGVycyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBuSW5zdGFuY2VzID0gMDtcbi8qXG5QZWVyQ29ubmVjdGlvblYyIFN0YXRlc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICstLS0tLS0rICAgICstLS0tLS0tLStcbiAgICB8ICAgICAgfCAgICB8ICAgICAgICB8XG4gICAgfCBvcGVuIHwtLS0+fCBjbG9zZWQgfFxuICAgIHwgICAgICB8ICAgIHwgICAgICAgIHxcbiAgICArLS0tLS0tKyAgICArLS0tLS0tLS0rXG4gICAgICB8ICBeICAgICAgICAgIF5cbiAgICAgIHwgIHwgICAgICAgICAgfFxuICAgICAgfCAgfCAgICAgICAgICB8XG4gICAgICB2ICB8ICAgICAgICAgIHxcbiAgKy0tLS0tLS0tLS0rICAgICAgfFxuICB8ICAgICAgICAgIHwgICAgICB8XG4gIHwgdXBkYXRpbmcgfC0tLS0tLStcbiAgfCAgICAgICAgICB8XG4gICstLS0tLS0tLS0tK1xuXG4qL1xudmFyIHN0YXRlcyA9IHtcbiAgICBvcGVuOiBbXG4gICAgICAgICdjbG9zZWQnLFxuICAgICAgICAndXBkYXRpbmcnXG4gICAgXSxcbiAgICB1cGRhdGluZzogW1xuICAgICAgICAnY2xvc2VkJyxcbiAgICAgICAgJ29wZW4nXG4gICAgXSxcbiAgICBjbG9zZWQ6IFtdXG59O1xuLyoqXG4gKiBAZXh0ZW5kcyBTdGF0ZU1hY2hpbmVcbiAqIEBwcm9wZXJ0eSB7aWR9XG4gKiBAZW1pdHMgUGVlckNvbm5lY3Rpb25WMiNjb25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gKiBAZW1pdHMgUGVlckNvbm5lY3Rpb25WMiNpY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gKiBAZW1pdHMgUGVlckNvbm5lY3Rpb25WMiNjYW5kaWRhdGVzXG4gKiBAZW1pdHMgUGVlckNvbm5lY3Rpb25WMiNkZXNjcmlwdGlvblxuICovXG52YXIgUGVlckNvbm5lY3Rpb25WMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGVlckNvbm5lY3Rpb25WMiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtFbmNvZGluZ1BhcmFtZXRlcnNJbXBsfSBlbmNvZGluZ1BhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge1ByZWZlcnJlZENvZGVjc30gcHJlZmVycmVkQ29kZWNzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBlZXJDb25uZWN0aW9uVjIoaWQsIGVuY29kaW5nUGFyYW1ldGVycywgcHJlZmVycmVkQ29kZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICdvcGVuJywgc3RhdGVzKSB8fCB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBlbmFibGVEc2NwOiBmYWxzZSxcbiAgICAgICAgICAgIGR1bW15QXVkaW9NZWRpYVN0cmVhbVRyYWNrOiBudWxsLFxuICAgICAgICAgICAgaXNDaHJvbWVTY3JlZW5TaGFyZVRyYWNrOiBpc0Nocm9tZVNjcmVlblNoYXJlVHJhY2ssXG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGlzUlRDUnRwU2VuZGVyUGFyYW1zU3VwcG9ydGVkOiBpc1JUQ1J0cFNlbmRlclBhcmFtc1N1cHBvcnRlZCxcbiAgICAgICAgICAgIGxvZ0xldmVsOiBERUZBVUxUX0xPR19MRVZFTCxcbiAgICAgICAgICAgIG9mZmVyT3B0aW9uczoge30sXG4gICAgICAgICAgICByZXZlcnRTaW11bGNhc3RGb3JOb25WUDhNZWRpYVNlY3Rpb25zOiByZXZlcnRTaW11bGNhc3RGb3JOb25WUDhNZWRpYVNlY3Rpb25zLFxuICAgICAgICAgICAgc2Vzc2lvblRpbWVvdXQ6IERFRkFVTFRfU0VTU0lPTl9USU1FT1VUX1NFQyAqIDEwMDAsXG4gICAgICAgICAgICBzZXRCaXRyYXRlUGFyYW1ldGVyczogc2V0Qml0cmF0ZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzZXRDb2RlY1ByZWZlcmVuY2VzOiBzZXRDb2RlY1ByZWZlcmVuY2VzLFxuICAgICAgICAgICAgc2V0U2ltdWxjYXN0OiBzZXRTaW11bGNhc3QsXG4gICAgICAgICAgICBCYWNrb2ZmOiBEZWZhdWx0QmFja29mZixcbiAgICAgICAgICAgIEljZUNvbm5lY3Rpb25Nb25pdG9yOiBEZWZhdWx0SWNlQ29ubmVjdGlvbk1vbml0b3IsXG4gICAgICAgICAgICBNZWRpYVN0cmVhbTogRGVmYXVsdE1lZGlhU3RyZWFtLFxuICAgICAgICAgICAgUlRDSWNlQ2FuZGlkYXRlOiBEZWZhdWx0UlRDSWNlQ2FuZGlkYXRlLFxuICAgICAgICAgICAgUlRDUGVlckNvbm5lY3Rpb246IERlZmF1bHRSVENQZWVyQ29ubmVjdGlvbixcbiAgICAgICAgICAgIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbjogRGVmYXVsdFJUQ1Nlc3Npb25EZXNjcmlwdGlvbixcbiAgICAgICAgICAgIFRpbWVvdXQ6IERlZmF1bHRUaW1lb3V0XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgY29uZmlndXJhdGlvbiA9IGdldENvbmZpZ3VyYXRpb24ob3B0aW9ucyk7XG4gICAgICAgIHZhciBzZHBGb3JtYXQgPSBnZXRTZHBGb3JtYXQoY29uZmlndXJhdGlvbi5zZHBTZW1hbnRpY3MpO1xuICAgICAgICB2YXIgaXNVbmlmaWVkUGxhbiA9IHNkcEZvcm1hdCA9PT0gJ3VuaWZpZWQnO1xuICAgICAgICB2YXIgbG9jYWxNZWRpYVN0cmVhbSA9IGlzVW5pZmllZFBsYW4gPyBudWxsIDogbmV3IG9wdGlvbnMuTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgdmFyIGxvZ0xldmVscyA9IGJ1aWxkTG9nTGV2ZWxzKG9wdGlvbnMubG9nTGV2ZWwpO1xuICAgICAgICB2YXIgUlRDUGVlckNvbm5lY3Rpb24gPSBvcHRpb25zLlJUQ1BlZXJDb25uZWN0aW9uO1xuICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVEc2NwID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNocm9tZVNwZWNpZmljQ29uc3RyYWludHMgPSBvcHRpb25zLmNocm9tZVNwZWNpZmljQ29uc3RyYWludHMgfHwge307XG4gICAgICAgICAgICBvcHRpb25zLmNocm9tZVNwZWNpZmljQ29uc3RyYWludHMub3B0aW9uYWwgPSBvcHRpb25zLmNocm9tZVNwZWNpZmljQ29uc3RyYWludHMub3B0aW9uYWwgfHwgW107XG4gICAgICAgICAgICBvcHRpb25zLmNocm9tZVNwZWNpZmljQ29uc3RyYWludHMub3B0aW9uYWwucHVzaCh7IGdvb2dEc2NwOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2cgPSBvcHRpb25zLmxvZyA/IG9wdGlvbnMubG9nLmNyZWF0ZUxvZygnd2VicnRjJywgX3RoaXMpIDogbmV3IExvZygnd2VicnRjJywgX3RoaXMsIGxvZ0xldmVscywgb3B0aW9ucy5sb2dnZXJOYW1lKTtcbiAgICAgICAgdmFyIHBlZXJDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGNvbmZpZ3VyYXRpb24sIG9wdGlvbnMuY2hyb21lU3BlY2lmaWNDb25zdHJhaW50cyk7XG4gICAgICAgIGlmIChvcHRpb25zLmR1bW15QXVkaW9NZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5hZGRUcmFjayhvcHRpb25zLmR1bW15QXVkaW9NZWRpYVN0cmVhbVRyYWNrLCBsb2NhbE1lZGlhU3RyZWFtIHx8IG5ldyBvcHRpb25zLk1lZGlhU3RyZWFtKCkpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfYXBwbGllZFRyYWNrSWRzVG9BdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kYXRhQ2hhbm5lbHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2RhdGFUcmFja1JlY2VpdmVyczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZGVzY3JpcHRpb25SZXZpc2lvbjoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2RpZEdlbmVyYXRlTG9jYWxDYW5kaWRhdGVzOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2VuYWJsZURzY3A6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5lbmFibGVEc2NwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2VuY29kaW5nUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBlbmNvZGluZ1BhcmFtZXRlcnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaXNDaHJvbWVTY3JlZW5TaGFyZVRyYWNrOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuaXNDaHJvbWVTY3JlZW5TaGFyZVRyYWNrLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pY2VHYXRoZXJpbmdGYWlsZWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaWNlR2F0aGVyaW5nVGltZW91dDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgb3B0aW9ucy5UaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9oYW5kbGVJY2VHYXRoZXJpbmdUaW1lb3V0KCk7IH0sIERFRkFVTFRfSUNFX0dBVEhFUklOR19USU1FT1VUX01TLCBmYWxzZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaWNlUmVzdGFydEJhY2tvZmY6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5CYWNrb2ZmLmV4cG9uZW50aWFsKGljZVJlc3RhcnRCYWNrb2ZmQ29uZmlnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pbnN0YW5jZUlkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICsrbkluc3RhbmNlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pc0ljZUNvbm5lY3Rpb25JbmFjdGl2ZToge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pc0ljZUxpdGU6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaXNJY2VSZXN0YXJ0QmFja29mZkluUHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaXNSZXN0YXJ0aW5nSWNlOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzVW5pZmllZFBsYW46IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaXNVbmlmaWVkUGxhblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pc1JUQ1J0cFNlbmRlclBhcmFtc1N1cHBvcnRlZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmlzUlRDUnRwU2VuZGVyUGFyYW1zU3VwcG9ydGVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xhc3RJY2VDb25uZWN0aW9uU3RhdGU6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sYXN0U3RhYmxlRGVzY3JpcHRpb25SZXZpc2lvbjoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xvY2FsQ2FuZGlkYXRlczoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sb2NhbENvZGVjczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9jYWxDYW5kaWRhdGVzUmV2aXNpb246IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sb2NhbERlc2NyaXB0aW9uV2l0aG91dFNpbXVsY2FzdDoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xvY2FsRGVzY3JpcHRpb246IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sb2NhbE1lZGlhU3RyZWFtOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGxvY2FsTWVkaWFTdHJlYW1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbG9jYWxVZnJhZzoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xvZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsb2dcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZXZlbnRPYnNlcnZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmV2ZW50T2JzZXJ2ZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVtb3RlQ29kZWNNYXBzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9ydHBTZW5kZXJzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pY2VDb25uZWN0aW9uTW9uaXRvcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgb3B0aW9ucy5JY2VDb25uZWN0aW9uTW9uaXRvcihwZWVyQ29ubmVjdGlvbilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWVkaWFUcmFja1JlY2VpdmVyczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbmVlZHNBbnN3ZXI6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbmVnb3RpYXRpb25Sb2xlOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb2ZmZXJPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMub2ZmZXJPcHRpb25zXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uRW5jb2RpbmdQYXJhbWV0ZXJzQ2hhbmdlZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvbmNlUGVyVGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faXNSVENSdHBTZW5kZXJQYXJhbXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX25lZWRzQW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRW5jb2RpbmdQYXJhbWV0ZXJzKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZlcigpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3BlZXJDb25uZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBlZXJDb25uZWN0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ByZWZlcnJlZEF1ZGlvQ29kZWNzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHByZWZlcnJlZENvZGVjcy5hdWRpb1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9wcmVmZXJyZWRWaWRlb0NvZGVjczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcmVmZXJyZWRDb2RlY3MudmlkZW9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2hvdWxkQXBwbHlEdHg6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJlZmVycmVkQ29kZWNzLmF1ZGlvLmV2ZXJ5KGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29kZWMgPSBfYS5jb2RlYztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVjICE9PSAnb3B1cyc7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfHwgcHJlZmVycmVkQ29kZWNzLmF1ZGlvLnNvbWUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZWMgPSBfYS5jb2RlYywgZHR4ID0gX2EuZHR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVjID09PSAnb3B1cycgJiYgZHR4O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaG91bGRBcHBseVNpbXVsY2FzdDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAoaXNDaHJvbWUgfHwgaXNTYWZhcmkpICYmIHByZWZlcnJlZENvZGVjcy52aWRlby5zb21lKGZ1bmN0aW9uIChjb2RlY1NldHRpbmdzKSB7IHJldHVybiBjb2RlY1NldHRpbmdzLmNvZGVjLnRvTG93ZXJDYXNlKCkgPT09ICd2cDgnICYmIGNvZGVjU2V0dGluZ3Muc2ltdWxjYXN0OyB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9xdWV1ZWREZXNjcmlwdGlvbjoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2ljZVJlY29ubmVjdFRpbWVvdXQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IG9wdGlvbnMuVGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZygnSUNFIHJlY29ubmVjdCB0aW1lZCBvdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zLnNlc3Npb25UaW1lb3V0LCBmYWxzZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVjeWNsZWRUcmFuc2NlaXZlcnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBhdWRpbzogW10sXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvOiBbXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVwbGFjZVRyYWNrUHJvbWlzZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlbW90ZUNhbmRpZGF0ZXM6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IEljZUJveCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NkcEZvcm1hdDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzZHBGb3JtYXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2V0Qml0cmF0ZVBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5zZXRCaXRyYXRlUGFyYW1ldGVyc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZXRDb2RlY1ByZWZlcmVuY2VzOiB7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogUmUtb3JkZXJpbmcgcGF5bG9hZCB0eXBlcyBpbiBvcmRlciB0byBtYWtlIHN1cmUgYSBub24tSDI2NFxuICAgICAgICAgICAgICAgIC8vIHByZWZlcnJlZCBjb2RlYyBpcyBzZWxlY3RlZCBkb2VzIG5vdCB3b3JrIG9uIEFuZHJvaWQgRmlyZWZveCBkdWUgdG8gdGhpcyBiZWhhdmlvcjpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjgzMjU4LiBTbywgd2Ugd29yayBhcm91bmQgdGhpcyBieVxuICAgICAgICAgICAgICAgIC8vIG5vdCBhcHBseWluZyBhbnkgbm9uLUgyNjQgcHJlZmVycmVkIHZpZGVvIGNvZGVjLlxuICAgICAgICAgICAgICAgIHZhbHVlOiBpc0ZpcmVmb3ggJiYgaXNBbmRyb2lkICYmIHByZWZlcnJlZENvZGVjcy52aWRlb1swXSAmJiBwcmVmZXJyZWRDb2RlY3MudmlkZW9bMF0uY29kZWMudG9Mb3dlckNhc2UoKSAhPT0gJ2gyNjQnXG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKHNkcCkgeyByZXR1cm4gc2RwOyB9XG4gICAgICAgICAgICAgICAgICAgIDogb3B0aW9ucy5zZXRDb2RlY1ByZWZlcmVuY2VzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NldFNpbXVsY2FzdDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnNldFNpbXVsY2FzdFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZXZlcnRTaW11bGNhc3RGb3JOb25WUDhNZWRpYVNlY3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMucmV2ZXJ0U2ltdWxjYXN0Rm9yTm9uVlA4TWVkaWFTZWN0aW9uc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9SVENJY2VDYW5kaWRhdGU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5SVENJY2VDYW5kaWRhdGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfUlRDUGVlckNvbm5lY3Rpb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5SVENQZWVyQ29ubmVjdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9SVENTZXNzaW9uRGVzY3JpcHRpb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5SVENTZXNzaW9uRGVzY3JpcHRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2hvdWxkT2ZmZXI6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2hvdWxkUmVzdGFydEljZToge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90cmFja0lkc1RvQXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdHJhY2tNYXRjaGVyOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMub24oJ2NoYW5nZWQnLCBfdGhpcy5fb25FbmNvZGluZ1BhcmFtZXRlcnNDaGFuZ2VkKTtcbiAgICAgICAgcGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgX3RoaXMuX2hhbmRsZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZS5iaW5kKF90aGlzKSk7XG4gICAgICAgIHBlZXJDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2RhdGFjaGFubmVsJywgX3RoaXMuX2hhbmRsZURhdGFDaGFubmVsRXZlbnQuYmluZChfdGhpcykpO1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCBfdGhpcy5faGFuZGxlSWNlQ2FuZGlkYXRlRXZlbnQuYmluZChfdGhpcykpO1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBfdGhpcy5faGFuZGxlSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgcGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCBfdGhpcy5faGFuZGxlSWNlR2F0aGVyaW5nU3RhdGVDaGFuZ2UuYmluZChfdGhpcykpO1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdzaWduYWxpbmdzdGF0ZWNoYW5nZScsIF90aGlzLl9oYW5kbGVTaWduYWxpbmdTdGF0ZUNoYW5nZS5iaW5kKF90aGlzKSk7XG4gICAgICAgIHBlZXJDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgX3RoaXMuX2hhbmRsZVRyYWNrRXZlbnQuYmluZChfdGhpcykpO1xuICAgICAgICBfdGhpcy5faWNlUmVzdGFydEJhY2tvZmYub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2luaXRpYXRlSWNlUmVzdGFydCgpOyB9KTtcbiAgICAgICAgdmFyIHNlbGYgPSBfdGhpcztcbiAgICAgICAgX3RoaXMub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3N0YXRlQ2hhbmdlZCcsIHN0YXRlQ2hhbmdlZCk7XG4gICAgICAgICAgICBzZWxmLl9kYXRhQ2hhbm5lbHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUNoYW5uZWwsIGRhdGFUcmFja1NlbmRlcikge1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlRGF0YVRyYWNrU2VuZGVyKGRhdGFUcmFja1NlbmRlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltQZWVyQ29ubmVjdGlvblYyICNcIiArIHRoaXMuX2luc3RhbmNlSWQgKyBcIjogXCIgKyB0aGlzLmlkICsgXCJdXCI7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUsIFwiY29ubmVjdGlvblN0YXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0ncyB1bmRlcmx5aW5nIFJUQ1BlZXJDb25uZWN0aW9uJ3MgUlRDUGVlckNvbm5lY3Rpb25TdGF0ZVxuICAgICAgICAgKiBpZiBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIsIGl0cyBSVENJY2VDb25uZWN0aW9uU3RhdGUgb3RoZXJ3aXNlLlxuICAgICAgICAgKiBAcHJvcGVydHkge1JUQ1BlZXJDb25uZWN0aW9uU3RhdGV9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCdcbiAgICAgICAgICAgICAgICA/ICdmYWlsZWQnIDogKHRoaXMuX3BlZXJDb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSB8fCB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUsIFwiaWNlQ29ubmVjdGlvblN0YXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0ncyB1bmRlcmx5aW5nIFJUQ1BlZXJDb25uZWN0aW9uJ3NcbiAgICAgICAgICogUlRDSWNlQ29ubmVjdGlvblN0YXRlLlxuICAgICAgICAgKiBAcHJvcGVydHkge1JUQ0ljZUNvbm5lY3Rpb25TdGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICgodGhpcy5faXNJY2VDb25uZWN0aW9uSW5hY3RpdmUgJiYgdGhpcy5fcGVlckNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGVkJykgfHwgdGhpcy5faWNlR2F0aGVyaW5nRmFpbGVkKVxuICAgICAgICAgICAgICAgID8gJ2ZhaWxlZCcgOiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUsIFwiaXNBcHBsaWNhdGlvblNlY3Rpb25OZWdvdGlhdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfSBoYXMgbmVnb3RpYXRlZCBvciBpcyBpbiB0aGUgcHJvY2Vzc1xuICAgICAgICAgKiBvZiBuZWdvdGlhdGluZyB0aGUgYXBwbGljYXRpb24gbT0gc2VjdGlvbi5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBhY2Nlc3NpbmcgLmxvY2FsRGVzY3JpcHRpb24gaW4gJ2Nsb3NlZCcgc3RhdGUgY2F1c2VzIGl0IHRocm93IGV4Y2VwdGlvbnMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBnZXRNZWRpYVNlY3Rpb25zKHRoaXMuX3BlZXJDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb24uc2RwLCAnYXBwbGljYXRpb24nKS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFkZCBhbiBJQ0UgY2FuZGlkYXRlIHRvIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2FuZGlkYXRlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX2FkZEljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FuZGlkYXRlID0gbmV3IF90aGlzLl9SVENJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcGVlckNvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogRmlyZWZveCA2OCsgbm93IGdlbmVyYXRlcyBhbiBSVENJY2VDYW5kaWRhdGUgd2l0aCBhblxuICAgICAgICAgICAgLy8gZW1wdHkgY2FuZGlkYXRlIHN0cmluZyB0byBzaWduYWwgZW5kLW9mLWNhbmRpZGF0ZXMsIGZvbGxvd2VkIGJ5IGEgbnVsbFxuICAgICAgICAgICAgLy8gY2FuZGlkYXRlLiBBcyBvZiBub3csIENocm9tZSBhbmQgU2FmYXJpIHJlamVjdCB0aGlzIFJUQ0ljZUNhbmRpZGF0ZS4gU2luY2VcbiAgICAgICAgICAgIC8vIHRoaXMgZG9lcyBub3QgYWZmZWN0IHRoZSBtZWRpYSBjb25uZWN0aW9uIGJldHdlZW4gRmlyZWZveCA2OCsgYW5kIENocm9tZS9TYWZhcmlcbiAgICAgICAgICAgIC8vIGluIFBlZXItdG8tUGVlciBSb29tcywgd2Ugc3VwcHJlc3MgdGhlIEVycm9yIGFuZCBsb2cgYSB3YXJuaW5nIG1lc3NhZ2UuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQ2hyb21lIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTc4NTgyXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgX3RoaXMuX2xvZy53YXJuKFwiRmFpbGVkIHRvIGFkZCBSVENJY2VDYW5kaWRhdGUgXCIgKyAoY2FuZGlkYXRlID8gXCJcXFwiXCIgKyBjYW5kaWRhdGUuY2FuZGlkYXRlICsgXCJcXFwiXCIgOiAnbnVsbCcpICsgXCI6IFwiXG4gICAgICAgICAgICAgICAgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgSUNFIGNhbmRpZGF0ZXMgdG8gdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gY2FuZGlkYXRlc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9hZGRJY2VDYW5kaWRhdGVzID0gZnVuY3Rpb24gKGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGNhbmRpZGF0ZXMubWFwKHRoaXMuX2FkZEljZUNhbmRpZGF0ZSwgdGhpcykpLnRoZW4oZnVuY3Rpb24gKCkgeyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBSVENSdHBUcmFuc2NlaXZlciBvciB1cGRhdGUgYW4gZXhpc3RpbmcgUlRDUnRwVHJhbnNjZWl2ZXIgZm9yIHRoZVxuICAgICAqIGdpdmVuIE1lZGlhU3RyZWFtVHJhY2suXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gICAgICogQHJldHVybnMge1JUQ1J0cFRyYW5zY2VpdmVyfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9hZGRPclVwZGF0ZVRyYW5zY2VpdmVyID0gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0cmFuc2NlaXZlciA9IHRha2VSZWN5Y2xlZFRyYW5zY2VpdmVyKHRoaXMsIHRyYWNrLmtpbmQpO1xuICAgICAgICBpZiAodHJhbnNjZWl2ZXIgJiYgdHJhbnNjZWl2ZXIuc2VuZGVyKSB7XG4gICAgICAgICAgICB2YXIgb2xkVHJhY2tJZCA9IHRyYW5zY2VpdmVyLnNlbmRlci50cmFjayA/IHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5pZCA6IG51bGw7XG4gICAgICAgICAgICBpZiAob2xkVHJhY2tJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiUmV1c2luZyB0cmFuc2NlaXZlcjogXCIgKyB0cmFuc2NlaXZlci5taWQgKyBcIl0gXCIgKyBvbGRUcmFja0lkICsgXCIgPT4gXCIgKyB0cmFjay5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTpyZW1lbWJlciB0aGlzIHRyYW5zY2VpdmVyIHdoaWxlIHdlIHJlcGxhY2UgdHJhY2suXG4gICAgICAgICAgICAvLyB3ZSByZWN5Y2xlIHRyYW5zY2VpdmVycyB0aGF0IGFyZSBub3QgaW4gdXNlIGFmdGVyICduZWdvdGlhdGlvbkNvbXBsZXRlZCcsIGJ1dCB3ZSB3YW50IHRvIHByZXZlbnRcbiAgICAgICAgICAgIC8vIHRoaXMgb25lIGZyb20gZ2V0dGluZyByZWN5Y2xlZCB3aGlsZSByZXBsYWNlVHJhY2sgaXMgcGVuZGluZy5cbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VUcmFja1Byb21pc2VzLnNldCh0cmFuc2NlaXZlciwgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjaykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRyZWN2JztcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlcGxhY2VUcmFja1Byb21pc2VzLmRlbGV0ZSh0cmFuc2NlaXZlcik7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uLmFkZFRyYW5zY2VpdmVyKHRyYWNrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHRoZSB7QGxpbmsgSWNlQm94fS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdH0gZGVzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fY2hlY2tJY2VCb3ggPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIHVmcmFnID0gZ2V0VWZyYWcoZGVzY3JpcHRpb24pO1xuICAgICAgICBpZiAoIXVmcmFnKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSB0aGlzLl9yZW1vdGVDYW5kaWRhdGVzLnNldFVmcmFnKHVmcmFnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEljZUNhbmRpZGF0ZXMoY2FuZGlkYXRlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gYW5zd2VyIGFuZCBzZXQgaXQgb24gdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdH0gb2ZmZXJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fYW5zd2VyID0gZnVuY3Rpb24gKG9mZmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX25lZ290aWF0aW9uUm9sZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9uZWdvdGlhdGlvblJvbGUgPSAnYW5zd2VyZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZWRpYUNsaWVudFJlbW90ZURlc2NGYWlsZWRFcnJvcigpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcGVlckNvbm5lY3Rpb24uY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGFuc3dlcikge1xuICAgICAgICAgICAgaWYgKGlzRmlyZWZveCkge1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFdlIHdvcmsgYXJvdW5kIENocm9taXVtIGJ1ZyAxMTA2MTU3IGJ5IGRpc2FibGluZ1xuICAgICAgICAgICAgICAgIC8vIFJUWCBpbiBGaXJlZm94IDc5Ky4gRm9yIG1vcmUgZGV0YWlscyBhYm91dCB0aGUgYnVnLCBwbGVhc2UgZ28gaGVyZTpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMTA2MTU3XG4gICAgICAgICAgICAgICAgYW5zd2VyID0gbmV3IF90aGlzLl9SVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgICAgICAgICBzZHA6IGRpc2FibGVSdHgoYW5zd2VyLnNkcCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGFuc3dlci50eXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbnN3ZXIgPSB3b3JrYXJvdW5kSXNzdWU4MzI5KGFuc3dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogVXBjb21pbmcgY2hyb21lIHZlcnNpb25zIGFyZSBnb2luZyB0byByZW1vdmUgc3NyYyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBtc2xhYmVsIGFuZCBsYWJlbC4gU2VlIHRoaXMgYnVnIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD03MTEwXG4gICAgICAgICAgICAvLyBhbmQgUFNBOiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2ZvcnVtLyMhc2VhcmNoaW4vZGlzY3Vzcy13ZWJydGMvUFNBJTdDc29ydDpkYXRlL2Rpc2N1c3Mtd2VicnRjL2pjWk8tV2owV3VzL2syWHZQQ3ZvQXdBSlxuICAgICAgICAgICAgLy8gV2UgYXJlIG5vdCByZWZlcmVuY2luZyB0aG9zZSBhdHRyaWJ1dGVzLCBidXQgdGhpcyBjaGFuZ2VzIGdvZXMgYWhlYWQgYW5kIHJlbW92ZXMgdGhlbSB0byBzZWUgaWYgaXQgd29ya3MuXG4gICAgICAgICAgICAvLyB0aGlzIGFsc28gaGVscHMgcmVkdWNlIGJ5dGVzIG9uIHdpcmVzXG4gICAgICAgICAgICB2YXIgdXBkYXRlZFNkcCA9IHJlbW92ZVNTUkNBdHRyaWJ1dGVzKGFuc3dlci5zZHAsIFsnbXNsYWJlbCcsICdsYWJlbCddKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fc2hvdWxkQXBwbHlTaW11bGNhc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2RwV2l0aG91dFNpbXVsY2FzdCA9IHVwZGF0ZWRTZHA7XG4gICAgICAgICAgICAgICAgdXBkYXRlZFNkcCA9IF90aGlzLl9zZXRTaW11bGNhc3Qoc2RwV2l0aG91dFNpbXVsY2FzdCwgX3RoaXMuX3NkcEZvcm1hdCwgX3RoaXMuX3RyYWNrSWRzVG9BdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKHN5ZXJyYXByYWdhZGEpOiBWTVMgZG9lcyBub3Qgc3VwcG9ydCBIMjY0IHNpbXVsY2FzdC4gU28sXG4gICAgICAgICAgICAgICAgLy8gdW5zZXQgc2ltdWxjYXN0IGZvciBzZWN0aW9ucyBpbiBsb2NhbCBvZmZlciB3aGVyZSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAgICAgICAgLy8gc2VjdGlvbnMgaW4gYW5zd2VyIGRvZXNuJ3QgaGF2ZSB2cDggYXMgcHJlZmVycmVkIGNvZGVjIGFuZCByZWFwcGx5IG9mZmVyLlxuICAgICAgICAgICAgICAgIHVwZGF0ZWRTZHAgPSBfdGhpcy5fcmV2ZXJ0U2ltdWxjYXN0Rm9yTm9uVlA4TWVkaWFTZWN0aW9ucyh1cGRhdGVkU2RwLCBzZHBXaXRob3V0U2ltdWxjYXN0LCBvZmZlci5zZHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogV29yayBhcm91bmQgQ2hyb21pdW0gYnVnIDEwNzQ0MjEuXG4gICAgICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDc0NDIxXG4gICAgICAgICAgICB1cGRhdGVkU2RwID0gdXBkYXRlZFNkcC5yZXBsYWNlKC80MmUwMTUvZywgJzQyZTAxZicpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9zZXRMb2NhbERlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhbnN3ZXIudHlwZSxcbiAgICAgICAgICAgICAgICBzZHA6IHVwZGF0ZWRTZHBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY2hlY2tJY2VCb3gob2ZmZXIpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcXVldWVkRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAmJiBfdGhpcy5fdXBkYXRlRGVzY3JpcHRpb24oX3RoaXMuX3F1ZXVlZERlc2NyaXB0aW9uKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fcXVldWVkRGVzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9tYXliZVJlb2ZmZXIoX3RoaXMuX3BlZXJDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb24pO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBlcnJvclRvVGhyb3cgPSBlcnJvciBpbnN0YW5jZW9mIE1lZGlhQ2xpZW50UmVtb3RlRGVzY0ZhaWxlZEVycm9yID8gZXJyb3IgOiBuZXcgTWVkaWFDbGllbnRMb2NhbERlc2NGYWlsZWRFcnJvcigpO1xuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hNZWRpYVdhcm5pbmcoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gX2Fuc3dlcicsXG4gICAgICAgICAgICAgICAgY29kZTogZXJyb3JUb1Rocm93LmNvZGUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IGVycm9yVG9UaHJvdztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgdW5kZXJseWluZyBSVENQZWVyQ29ubmVjdGlvbi4gUmV0dXJucyBmYWxzZSBpZiB0aGVcbiAgICAgKiBSVENQZWVyQ29ubmVjdGlvbiB3YXMgYWxyZWFkeSBjbG9zZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2ljZUNvbm5lY3Rpb25Nb25pdG9yLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucHJlZW1wdCgnY2xvc2VkJyk7XG4gICAgICAgICAgICB0aGlzLl9lbmNvZGluZ1BhcmFtZXRlcnMucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZWQnLCB0aGlzLl9vbkVuY29kaW5nUGFyYW1ldGVyc0NoYW5nZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEgXCJjb25uZWN0aW9uc3RhdGVjaGFuZ2VcIiBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9oYW5kbGVDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvblN0YXRlQ2hhbmdlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEgXCJkYXRhY2hhbm5lbFwiIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSVENEYXRhQ2hhbm5lbEV2ZW50fSBldmVudFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9oYW5kbGVEYXRhQ2hhbm5lbEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhQ2hhbm5lbCA9IGV2ZW50LmNoYW5uZWw7XG4gICAgICAgIHZhciBkYXRhVHJhY2tSZWNlaXZlciA9IG5ldyBEYXRhVHJhY2tSZWNlaXZlcihkYXRhQ2hhbm5lbCk7XG4gICAgICAgIHRoaXMuX2RhdGFUcmFja1JlY2VpdmVycy5hZGQoZGF0YVRyYWNrUmVjZWl2ZXIpO1xuICAgICAgICBkYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9kYXRhVHJhY2tSZWNlaXZlcnMuZGVsZXRlKGRhdGFUcmFja1JlY2VpdmVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdCgndHJhY2tBZGRlZCcsIGRhdGFUcmFja1JlY2VpdmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIGdsYXJlIHNjZW5hcmlvIG9uIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1JUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXR9IG9mZmVyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX2hhbmRsZUdsYXJlID0gZnVuY3Rpb24gKG9mZmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygnR2xhcmUgZGV0ZWN0ZWQ7IHJvbGxpbmcgYmFjaycpO1xuICAgICAgICBpZiAodGhpcy5faXNSZXN0YXJ0aW5nSWNlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ0FuIElDRSByZXN0YXJ0IHdhcyBpbiBwcm9ncmVzczsgd2VcXCdsbCBuZWVkIHRvIHJlc3RhcnQgSUNFIGFnYWluIGFmdGVyIHJvbGxpbmcgYmFjaycpO1xuICAgICAgICAgICAgdGhpcy5faXNSZXN0YXJ0aW5nSWNlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zaG91bGRSZXN0YXJ0SWNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fdHJhY2tJZHNUb0F0dHJpYnV0ZXMgPSBuZXcgTWFwKF90aGlzLl9hcHBsaWVkVHJhY2tJZHNUb0F0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9zZXRMb2NhbERlc2NyaXB0aW9uKHsgdHlwZTogJ3JvbGxiYWNrJyB9KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbmVlZHNBbnN3ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYW5zd2VyKG9mZmVyKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoZGlkUmVvZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGRpZFJlb2ZmZXIgPyBQcm9taXNlLnJlc29sdmUoKSA6IF90aGlzLl9vZmZlcigpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9wdWJsaXNoTWVkaWFXYXJuaW5nID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gX2EubWVzc2FnZSwgY29kZSA9IF9hLmNvZGUsIGVycm9yID0gX2EuZXJyb3IsIHNkcCA9IF9hLnNkcDtcbiAgICAgICAgdGhpcy5fZXZlbnRPYnNlcnZlci5lbWl0KCdldmVudCcsIHsgbGV2ZWw6ICd3YXJuaW5nJywgbmFtZTogJ2Vycm9yJywgZ3JvdXA6ICdtZWRpYScsIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICAgICAgY29udGV4dDogSlNPTi5zdHJpbmdpZnkoeyBlcnJvcjogZXJyb3IubWVzc2FnZSwgc2RwOiBzZHAgfSlcbiAgICAgICAgICAgIH0gfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW4gSUNFIGNhbmRpZGF0ZSBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX2hhbmRsZUljZUNhbmRpZGF0ZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5jYW5kaWRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygnQ2xlYXJpbmcgSUNFIGdhdGhlcmluZyB0aW1lb3V0Jyk7XG4gICAgICAgICAgICB0aGlzLl9kaWRHZW5lcmF0ZUxvY2FsQ2FuZGlkYXRlcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pY2VHYXRoZXJpbmdUaW1lb3V0LmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbENhbmRpZGF0ZXMucHVzaChldmVudC5jYW5kaWRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwZWVyQ29ubmVjdGlvblN0YXRlID0ge1xuICAgICAgICAgICAgaWNlOiB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlczogdGhpcy5faXNJY2VMaXRlID8gW10gOiB0aGlzLl9sb2NhbENhbmRpZGF0ZXMuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICB1ZnJhZzogdGhpcy5fbG9jYWxVZnJhZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgIH07XG4gICAgICAgIGlmICghZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvblN0YXRlLmljZS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodGhpcy5faXNJY2VMaXRlICYmIGV2ZW50LmNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uU3RhdGUuaWNlLnJldmlzaW9uID0gdGhpcy5fbG9jYWxDYW5kaWRhdGVzUmV2aXNpb24rKztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2FuZGlkYXRlcycsIHBlZXJDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW4gSUNFIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX2hhbmRsZUljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGljZUNvbm5lY3Rpb25TdGF0ZSA9IHRoaXMuX3BlZXJDb25uZWN0aW9uLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgdmFyIGlzSWNlQ29ubmVjdGVkT3JDb21wbGV0ZSA9IFsnY29ubmVjdGVkJywgJ2NvbXBsZXRlZCddLmluY2x1ZGVzKGljZUNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIGxvZy5kZWJ1ZyhcIklDRSBjb25uZWN0aW9uIHN0YXRlIGlzIFxcXCJcIiArIGljZUNvbm5lY3Rpb25TdGF0ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgaWYgKGlzSWNlQ29ubmVjdGVkT3JDb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5faWNlUmVjb25uZWN0VGltZW91dC5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5faWNlUmVzdGFydEJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGFzdEljZUNvbm5lY3Rpb25TdGF0ZSAhPT0gJ2ZhaWxlZCcgJiYgaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJyAmJiAhdGhpcy5fc2hvdWxkUmVzdGFydEljZSAmJiAhdGhpcy5faXNSZXN0YXJ0aW5nSWNlKSB7XG4gICAgICAgICAgICAvLyBDYXNlIDE6IFRyYW5zaXRpb24gdG8gXCJmYWlsZWRcIi5cbiAgICAgICAgICAgIGxvZy53YXJuKCdJQ0UgZmFpbGVkJyk7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWF0ZUljZVJlc3RhcnRCYWNrb2ZmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoWydkaXNjb25uZWN0ZWQnLCAnZmFpbGVkJ10uaW5jbHVkZXModGhpcy5fbGFzdEljZUNvbm5lY3Rpb25TdGF0ZSkgJiYgaXNJY2VDb25uZWN0ZWRPckNvbXBsZXRlKSB7XG4gICAgICAgICAgICAvLyBDYXNlIDI6IFRyYW5zaXRpb24gZnJvbSBcImRpc2Nvbm5lY3RlZFwiIG9yIFwiZmFpbGVkXCIuXG4gICAgICAgICAgICBsb2cuZGVidWcoJ0lDRSByZWNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0YXJ0IG1vbml0b3IgbWVkaWEgd2hlbiBjb25uZWN0ZWQsIGFuZCBjb250aW51ZSB0byBtb25pdG9yIHdoaWxlIHN0YXRlIGlzIGNvbXBsZXRlLWRpc2Nvbm5lY3RlZC1jb25uZWN0ZWQuXG4gICAgICAgIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0ljZUNvbm5lY3Rpb25JbmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faWNlQ29ubmVjdGlvbk1vbml0b3Iuc3RhcnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIG5vdGU6IGljZUNvbm5lY3Rpb24gbW9uaXRvciB3YWl0cyBmb3IgaWNlQ29ubmVjdGlvblN0YXRlPWRpc2Nvbm5lY3RlZCBmb3JcbiAgICAgICAgICAgICAgICAvLyBkZXRlY3RpbmcgaW5hY3Rpdml0eS4gSXRzIHBvc3NpYmxlIHRoYXQgaXQgbWF5IGtub3cgYWJvdXQgZGlzY29ubmVjdGVkIGJlZm9yZSBfaGFuZGxlSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlXG4gICAgICAgICAgICAgICAgX3RoaXMuX2ljZUNvbm5lY3Rpb25Nb25pdG9yLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9zaG91bGRSZXN0YXJ0SWNlICYmICFfdGhpcy5faXNSZXN0YXJ0aW5nSWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKCdJQ0UgQ29ubmVjdGlvbiBNb25pdG9yIGRldGVjdGVkIGluYWN0aXZpdHknKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzSWNlQ29ubmVjdGlvbkluYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luaXRpYXRlSWNlUmVzdGFydEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnaWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCcpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdjb25uZWN0aW9uU3RhdGVDaGFuZ2VkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIVsnZGlzY29ubmVjdGVkJywgJ2NvbXBsZXRlZCddLmluY2x1ZGVzKGljZUNvbm5lY3Rpb25TdGF0ZSkpIHsgLy8gZG9uJ3Qgc3RvcCBtb25pdG9yaW5nIGZvciBkaXNjb25uZWN0ZWQgb3IgY29tcGxldGVkLlxuICAgICAgICAgICAgdGhpcy5faWNlQ29ubmVjdGlvbk1vbml0b3Iuc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5faXNJY2VDb25uZWN0aW9uSW5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0SWNlQ29ubmVjdGlvblN0YXRlID0gaWNlQ29ubmVjdGlvblN0YXRlO1xuICAgICAgICB0aGlzLmVtaXQoJ2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBJQ0UgZ2F0aGVyaW5nIHRpbWVvdXQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5faGFuZGxlSWNlR2F0aGVyaW5nVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbG9nLndhcm4oJ0lDRSBmYWlsZWQgdG8gZ2F0aGVyIGFueSBsb2NhbCBjYW5kaWRhdGVzJyk7XG4gICAgICAgIHRoaXMuX2ljZUdhdGhlcmluZ0ZhaWxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2luaXRpYXRlSWNlUmVzdGFydEJhY2tvZmYoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdpY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvblN0YXRlQ2hhbmdlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFuIElDRSBnYXRoZXJpbmcgc3RhdGUgY2hhbmdlIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX2hhbmRsZUljZUdhdGhlcmluZ1N0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWNlR2F0aGVyaW5nU3RhdGUgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5pY2VHYXRoZXJpbmdTdGF0ZTtcbiAgICAgICAgdmFyIGxvZyA9IHRoaXMuX2xvZztcbiAgICAgICAgbG9nLmRlYnVnKFwiSUNFIGdhdGhlcmluZyBzdGF0ZSBpcyBcXFwiXCIgKyBpY2VHYXRoZXJpbmdTdGF0ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogU3RhcnQgdGhlIElDRSBnYXRoZXJpbmcgdGltZW91dCBvbmx5IGlmIHRoZSBSVENQZWVyQ29ubmVjdGlvblxuICAgICAgICAvLyBoYXMgc3RhcnRlZCBnYXRoZXJpbmcgY2FuZGlkYXRlcyBmb3IgdGhlIGZpcnN0IHRpbWUgc2luY2UgdGhlIGluaXRpYWwgb2ZmZXIvYW5zd2VyXG4gICAgICAgIC8vIG9yIGFuIG9mZmVyL2Fuc3dlciB3aXRoIElDRSByZXN0YXJ0LlxuICAgICAgICB2YXIgX2EgPSB0aGlzLl9pY2VHYXRoZXJpbmdUaW1lb3V0LCBkZWxheSA9IF9hLmRlbGF5LCBpc1NldCA9IF9hLmlzU2V0O1xuICAgICAgICBpZiAoaWNlR2F0aGVyaW5nU3RhdGUgPT09ICdnYXRoZXJpbmcnICYmICF0aGlzLl9kaWRHZW5lcmF0ZUxvY2FsQ2FuZGlkYXRlcyAmJiAhaXNTZXQpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlN0YXJ0aW5nIElDRSBnYXRoZXJpbmcgdGltZW91dDogXCIgKyBkZWxheSk7XG4gICAgICAgICAgICB0aGlzLl9pY2VHYXRoZXJpbmdGYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2ljZUdhdGhlcmluZ1RpbWVvdXQuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEgc2lnbmFsaW5nIHN0YXRlIGNoYW5nZSBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9oYW5kbGVTaWduYWxpbmdTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykge1xuICAgICAgICAgICAgdGhpcy5fYXBwbGllZFRyYWNrSWRzVG9BdHRyaWJ1dGVzID0gbmV3IE1hcCh0aGlzLl90cmFja0lkc1RvQXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIHRyYWNrIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5faGFuZGxlVHJhY2tFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2RwID0gdGhpcy5fcGVlckNvbm5lY3Rpb24ucmVtb3RlRGVzY3JpcHRpb25cbiAgICAgICAgICAgID8gdGhpcy5fcGVlckNvbm5lY3Rpb24ucmVtb3RlRGVzY3JpcHRpb24uc2RwXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5fdHJhY2tNYXRjaGVyKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFja01hdGNoZXIgPSBldmVudC50cmFuc2NlaXZlciAmJiBldmVudC50cmFuc2NlaXZlci5taWRcbiAgICAgICAgICAgICAgICA/IG5ldyBNSURUcmFja01hdGNoZXIoKVxuICAgICAgICAgICAgICAgIC8vIE5PVEUobXJvYmVydHMpOiBVbnRpbCBDaHJvbWUgc2hpcHMgUlRDUnRwVHJhbnNjZWl2ZXJzIHdpdGggTUlEXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCwgd2UgaGF2ZSB0byB1c2UgdGhlIHNhbWUgaGFja3kgc29sdXRpb24gYXMgU2FmYXJpLiBSZXZpc2l0XG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3aGVuIFJUQ1J0cFRyYW5zY2VpdmVycyBhbmQgTUlEcyBsYW5kLiBXZSBzaG91bGQgYmUgYWJsZSB0byB1c2VcbiAgICAgICAgICAgICAgICAvLyB0aGUgc2FtZSB0ZWNobmlxdWUgYXMgRmlyZWZveC5cbiAgICAgICAgICAgICAgICA6IGlzU2FmYXJpIHx8IHRoaXMuX2lzVW5pZmllZFBsYW4gPyBuZXcgT3JkZXJlZFRyYWNrTWF0Y2hlcigpIDogbmV3IElkZW50aXR5VHJhY2tNYXRjaGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhY2tNYXRjaGVyLnVwZGF0ZShzZHApO1xuICAgICAgICB2YXIgbWVkaWFTdHJlYW1UcmFjayA9IGV2ZW50LnRyYWNrO1xuICAgICAgICB2YXIgc2lnbmFsZWRUcmFja0lkID0gdGhpcy5fdHJhY2tNYXRjaGVyLm1hdGNoKGV2ZW50KSB8fCBtZWRpYVN0cmVhbVRyYWNrLmlkO1xuICAgICAgICB2YXIgbWVkaWFUcmFja1JlY2VpdmVyID0gbmV3IE1lZGlhVHJhY2tSZWNlaXZlcihzaWduYWxlZFRyYWNrSWQsIG1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBJbiB1bmlmaWVkIHBsYW4gbW9kZSwgXCJlbmRlZFwiIGlzIG5vdCBmaXJlZCBvbiB0aGUgcmVtb3RlXG4gICAgICAgIC8vIE1lZGlhU3RyZWFtVHJhY2sgd2hlbiB0aGUgcmVtb3RlIHBlZXIgcmVtb3ZlcyBhIHRyYWNrLiBTbywgd2hlbiB0aGlzXG4gICAgICAgIC8vIE1lZGlhU3RyZWFtVHJhY2sgaXMgcmUtdXNlZCBmb3IgYSBkaWZmZXJlbnQgdHJhY2sgZHVlIHRvIHRoZSByZW1vdGUgcGVlclxuICAgICAgICAvLyBjYWxsaW5nIFJUQ1J0cFNlbmRlci5yZXBsYWNlVHJhY2soKSwgd2UgZGVsZXRlIHRoZSBwcmV2aW91cyBNZWRpYVRyYWNrUmVjZWl2ZXJcbiAgICAgICAgLy8gdGhhdCBvd25lZCB0aGlzIE1lZGlhU3RyZWFtVHJhY2sgYmVmb3JlIGFkZGluZyB0aGUgbmV3IE1lZGlhVHJhY2tSZWNlaXZlci5cbiAgICAgICAgdGhpcy5fbWVkaWFUcmFja1JlY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja1JlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAodHJhY2tSZWNlaXZlci50cmFjay5pZCA9PT0gbWVkaWFUcmFja1JlY2VpdmVyLnRyYWNrLmlkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21lZGlhVHJhY2tSZWNlaXZlcnMuZGVsZXRlKHRyYWNrUmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWVkaWFUcmFja1JlY2VpdmVycy5hZGQobWVkaWFUcmFja1JlY2VpdmVyKTtcbiAgICAgICAgbWVkaWFTdHJlYW1UcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9tZWRpYVRyYWNrUmVjZWl2ZXJzLmRlbGV0ZShtZWRpYVRyYWNrUmVjZWl2ZXIpOyB9KTtcbiAgICAgICAgdGhpcy5lbWl0KCd0cmFja0FkZGVkJywgbWVkaWFUcmFja1JlY2VpdmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIElDRSBSZXN0YXJ0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX2luaXRpYXRlSWNlUmVzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIGxvZy53YXJuKCdBdHRlbXB0aW5nIHRvIHJlc3RhcnQgSUNFJyk7XG4gICAgICAgIHRoaXMuX2RpZEdlbmVyYXRlTG9jYWxDYW5kaWRhdGVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzSWNlUmVzdGFydEJhY2tvZmZJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Nob3VsZFJlc3RhcnRJY2UgPSB0cnVlO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9pY2VSZWNvbm5lY3RUaW1lb3V0LCBkZWxheSA9IF9hLmRlbGF5LCBpc1NldCA9IF9hLmlzU2V0O1xuICAgICAgICBpZiAoIWlzU2V0KSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoXCJTdGFydGluZyBJQ0UgcmVjb25uZWN0IHRpbWVvdXQ6IFwiICsgZGVsYXkpO1xuICAgICAgICAgICAgdGhpcy5faWNlUmVjb25uZWN0VGltZW91dC5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2ZmZXIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlIGFuIElDRSBSZXN0YXJ0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX2luaXRpYXRlSWNlUmVzdGFydEJhY2tvZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgdGhpcy5faXNJY2VSZXN0YXJ0QmFja29mZkluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cud2FybignQW4gSUNFIHJlc3RhcnQgaGFzIGJlZW4gc2NoZWR1bGVkJyk7XG4gICAgICAgIHRoaXMuX2lzSWNlUmVzdGFydEJhY2tvZmZJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faWNlUmVzdGFydEJhY2tvZmYuYmFja29mZigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uZGl0aW9uYWxseSByZS1vZmZlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P1JUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXR9IGxvY2FsRGVzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fbWF5YmVSZW9mZmVyID0gZnVuY3Rpb24gKGxvY2FsRGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIHNob3VsZFJlb2ZmZXIgPSB0aGlzLl9zaG91bGRPZmZlcjtcbiAgICAgICAgaWYgKGxvY2FsRGVzY3JpcHRpb24gJiYgbG9jYWxEZXNjcmlwdGlvbi5zZHApIHtcbiAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IEZvciBcInVuaWZpZWQtcGxhblwiIHNkcHMsIGlmIHRoZSBsb2NhbCBSVENTZXNzaW9uRGVzY3JpcHRpb25cbiAgICAgICAgICAgIC8vIGhhcyBmZXdlciBhdWRpbyBhbmQvb3IgdmlkZW8gc2VuZCogbT0gbGluZXMgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBSVENSdHBTZW5kZXJzXG4gICAgICAgICAgICAvLyB3aXRoIG5vbi1udWxsIE1lZGlhU3RyZWFtVHJhY2tzLCBpdCBtZWFucyB0aGF0IHRoZSBuZXdseSBhZGRlZCBSVENSdHBTZW5kZXJzXG4gICAgICAgICAgICAvLyByZXF1aXJlIHJlbmVnb3RpYXRpb24uXG4gICAgICAgICAgICBpZiAodGhpcy5faXNVbmlmaWVkUGxhbikge1xuICAgICAgICAgICAgICAgIHZhciBzZW5kZXJzXzEgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5nZXRTZW5kZXJzKCkuZmlsdGVyKGZ1bmN0aW9uIChzZW5kZXIpIHsgcmV0dXJuIHNlbmRlci50cmFjazsgfSk7XG4gICAgICAgICAgICAgICAgc2hvdWxkUmVvZmZlciA9IFsnYXVkaW8nLCAndmlkZW8nXS5yZWR1Y2UoZnVuY3Rpb24gKHNob3VsZE9mZmVyLCBraW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZWRpYVNlY3Rpb25zID0gZ2V0TWVkaWFTZWN0aW9ucyhsb2NhbERlc2NyaXB0aW9uLnNkcCwga2luZCwgJyhzZW5kcmVjdnxzZW5kb25seSknKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbmRlcnNPZktpbmQgPSBzZW5kZXJzXzEuZmlsdGVyKGlzU2VuZGVyT2ZLaW5kLmJpbmQobnVsbCwga2luZCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkT2ZmZXIgfHwgKG1lZGlhU2VjdGlvbnMubGVuZ3RoIDwgc2VuZGVyc09mS2luZC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0sIHNob3VsZFJlb2ZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URShtcm9iZXJ0cyk6IFdlIGFsc28gbmVlZCB0byByZS1vZmZlciBpZiB3ZSBoYXZlIGEgRGF0YVRyYWNrIHRvIHNoYXJlXG4gICAgICAgICAgICAvLyBidXQgbm8gbT0gYXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgICAgIHZhciBoYXNEYXRhVHJhY2sgPSB0aGlzLl9kYXRhQ2hhbm5lbHMuc2l6ZSA+IDA7XG4gICAgICAgICAgICB2YXIgaGFzQXBwbGljYXRpb25NZWRpYVNlY3Rpb24gPSBnZXRNZWRpYVNlY3Rpb25zKGxvY2FsRGVzY3JpcHRpb24uc2RwLCAnYXBwbGljYXRpb24nKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgdmFyIG5lZWRzQXBwbGljYXRpb25NZWRpYVNlY3Rpb24gPSBoYXNEYXRhVHJhY2sgJiYgIWhhc0FwcGxpY2F0aW9uTWVkaWFTZWN0aW9uO1xuICAgICAgICAgICAgc2hvdWxkUmVvZmZlciA9IHNob3VsZFJlb2ZmZXIgfHwgbmVlZHNBcHBsaWNhdGlvbk1lZGlhU2VjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvbWlzZSA9IHNob3VsZFJlb2ZmZXIgPyB0aGlzLl9vZmZlcigpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hvdWxkUmVvZmZlcjsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gb2ZmZXIgYW5kIHNldCBpdCBvbiB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX29mZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb2ZmZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fb2ZmZXJPcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbmVlZHNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fc2hvdWxkUmVzdGFydEljZSkge1xuICAgICAgICAgICAgdGhpcy5fc2hvdWxkUmVzdGFydEljZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faXNSZXN0YXJ0aW5nSWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIG9mZmVyT3B0aW9ucy5pY2VSZXN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5fcmVwbGFjZVRyYWNrUHJvbWlzZXMudmFsdWVzKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVPZmZlcihvZmZlck9wdGlvbnMpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBlcnJvclRvVGhyb3cgPSBuZXcgTWVkaWFDbGllbnRMb2NhbERlc2NGYWlsZWRFcnJvcigpO1xuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hNZWRpYVdhcm5pbmcoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gY3JlYXRlIG9mZmVyJyxcbiAgICAgICAgICAgICAgICBjb2RlOiBlcnJvclRvVGhyb3cuY29kZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JUb1Rocm93O1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChvZmZlcikge1xuICAgICAgICAgICAgaWYgKGlzRmlyZWZveCkge1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFdlIHdvcmsgYXJvdW5kIENocm9taXVtIGJ1ZyAxMTA2MTU3IGJ5IGRpc2FibGluZ1xuICAgICAgICAgICAgICAgIC8vIFJUWCBpbiBGaXJlZm94IDc5Ky4gRm9yIG1vcmUgZGV0YWlscyBhYm91dCB0aGUgYnVnLCBwbGVhc2UgZ28gaGVyZTpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMTA2MTU3XG4gICAgICAgICAgICAgICAgb2ZmZXIgPSBuZXcgX3RoaXMuX1JUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHNkcDogZGlzYWJsZVJ0eChvZmZlci5zZHApLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZlci50eXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZlciA9IHdvcmthcm91bmRJc3N1ZTgzMjkob2ZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IHVwY29taW5nIGNocm9tZSB2ZXJzaW9ucyBhcmUgZ29pbmcgdG8gcmVtb3ZlIHNzcmMgYXR0cmlidXRlc1xuICAgICAgICAgICAgLy8gbXNsYWJlbCBhbmQgbGFiZWwuIFNlZSB0aGlzIGJ1ZyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NzExMFxuICAgICAgICAgICAgLy8gYW5kIFBTQTogaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIXNlYXJjaGluL2Rpc2N1c3Mtd2VicnRjL1BTQSU3Q3NvcnQ6ZGF0ZS9kaXNjdXNzLXdlYnJ0Yy9qY1pPLVdqMFd1cy9rMlh2UEN2b0F3QUpcbiAgICAgICAgICAgIC8vIExvb2tzIGxpa2Ugd2UgYXJlIG5vdCByZWZlcmVuY2luZyB0aG9zZSBhdHRyaWJ1dGVzLCBidXQgdGhpcyBjaGFuZ2VzIGdvZXMgYWhlYWQgYW5kIHJlbW92ZXMgdGhlbSB0byBzZWUgaWYgaXQgd29ya3MuXG4gICAgICAgICAgICAvLyB0aGlzIGFsc28gaGVscHMgcmVkdWNlIGJ5dGVzIG9uIHdpcmVzXG4gICAgICAgICAgICB2YXIgc2RwID0gcmVtb3ZlU1NSQ0F0dHJpYnV0ZXMob2ZmZXIuc2RwLCBbJ21zbGFiZWwnLCAnbGFiZWwnXSk7XG4gICAgICAgICAgICBzZHAgPSBfdGhpcy5faXNVbmlmaWVkUGxhbiAmJiBfdGhpcy5fcGVlckNvbm5lY3Rpb24ucmVtb3RlRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICA/IHVuaWZpZWRQbGFuRmlsdGVyTG9jYWxDb2RlY3Moc2RwLCBfdGhpcy5fcGVlckNvbm5lY3Rpb24ucmVtb3RlRGVzY3JpcHRpb24uc2RwKVxuICAgICAgICAgICAgICAgIDogc2RwO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZWRTZHAgPSBfdGhpcy5fc2V0Q29kZWNQcmVmZXJlbmNlcyhzZHAsIF90aGlzLl9wcmVmZXJyZWRBdWRpb0NvZGVjcywgX3RoaXMuX3ByZWZlcnJlZFZpZGVvQ29kZWNzKTtcbiAgICAgICAgICAgIF90aGlzLl9zaG91bGRPZmZlciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fbmVnb3RpYXRpb25Sb2xlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX25lZ290aWF0aW9uUm9sZSA9ICdvZmZlcmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5fc2hvdWxkQXBwbHlTaW11bGNhc3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9jYWxEZXNjcmlwdGlvbldpdGhvdXRTaW11bGNhc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvZmZlcicsXG4gICAgICAgICAgICAgICAgICAgIHNkcDogdXBkYXRlZFNkcFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdXBkYXRlZFNkcCA9IF90aGlzLl9zZXRTaW11bGNhc3QodXBkYXRlZFNkcCwgX3RoaXMuX3NkcEZvcm1hdCwgX3RoaXMuX3RyYWNrSWRzVG9BdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2V0TG9jYWxEZXNjcmlwdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29mZmVyJyxcbiAgICAgICAgICAgICAgICBzZHA6IHVwZGF0ZWRTZHBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgTWVkaWFUcmFja1NlbmRlciBJRCBvZiB0aGUgZ2l2ZW4gTWVkaWFTdHJlYW1UcmFjayBJRC5cbiAgICAgKiBTaW5jZSBhIE1lZGlhVHJhY2tTZW5kZXIncyB1bmRlcmx5aW5nIE1lZGlhU3RyZWFtVHJhY2sgY2FuIGJlXG4gICAgICogcmVwbGFjZWQsIHRoZSBjb3JyZXNwb25kaW5nIElEcyBjYW4gbWlzbWF0Y2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1RyYWNrLklEfSBpZFxuICAgICAqIEByZXR1cm5zIHtUcmFjay5JRH1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5fZ2V0TWVkaWFUcmFja1NlbmRlcklkID0gZnVuY3Rpb24gKHRyYWNrSWQpIHtcbiAgICAgICAgdmFyIG1lZGlhVHJhY2tTZW5kZXIgPSBBcnJheS5mcm9tKHRoaXMuX3J0cFNlbmRlcnMua2V5cygpKS5maW5kKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGlkID0gX2EudHJhY2suaWQ7XG4gICAgICAgICAgICByZXR1cm4gaWQgPT09IHRyYWNrSWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVkaWFUcmFja1NlbmRlciA/IG1lZGlhVHJhY2tTZW5kZXIuaWQgOiB0cmFja0lkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIG9yIHJld3JpdGUgbG9jYWwgTWVkaWFTdHJlYW1UcmFjayBJRHMgaW4gdGhlIGdpdmVuIFVuaWZpZWQgUGxhbiBSVENTZXNzaW9uRGVzY3JpcHRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1JUQ1Nlc3Npb25EZXNjcmlwdGlvbn0gZGVzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJuIHtSVENTZXNzaW9uRGVzY3JpcHRpb259XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX2FkZE9yUmV3cml0ZUxvY2FsVHJhY2tJZHMgPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRyYW5zY2VpdmVycyA9IHRoaXMuX3BlZXJDb25uZWN0aW9uLmdldFRyYW5zY2VpdmVycygpO1xuICAgICAgICB2YXIgYWN0aXZlVHJhbnNjZWl2ZXJzID0gdHJhbnNjZWl2ZXJzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBzZW5kZXIgPSBfYS5zZW5kZXIsIHN0b3BwZWQgPSBfYS5zdG9wcGVkO1xuICAgICAgICAgICAgcmV0dXJuICFzdG9wcGVkICYmIHNlbmRlciAmJiBzZW5kZXIudHJhY2s7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBNZWRpYVN0cmVhbVRyYWNrIElEcyB3aWxsIGJlIHByZXNlbnQgaW5cbiAgICAgICAgLy8gU0RQcywgYW5kIGV2ZW4gaWYgdGhleSBhcmUsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZXkgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGVcbiAgICAgICAgLy8gYWN0dWFsIE1lZGlhU3RyZWFtVHJhY2sgSURzLiBTbywgd2UgYWRkIG9yIHJlLXdyaXRlIHRoZSBhY3R1YWwgTWVkaWFTdHJlYW1UcmFjayBJRHNcbiAgICAgICAgLy8gdG8gdGhlIGFzc2lnbmVkIG09IHNlY3Rpb25zIGhlcmUuXG4gICAgICAgIHZhciBhc3NpZ25lZFRyYW5zY2VpdmVycyA9IGFjdGl2ZVRyYW5zY2VpdmVycy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gX2EubWlkO1xuICAgICAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtaWRzVG9UcmFja0lkcyA9IG5ldyBNYXAoYXNzaWduZWRUcmFuc2NlaXZlcnMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IF9hLm1pZCwgc2VuZGVyID0gX2Euc2VuZGVyO1xuICAgICAgICAgICAgcmV0dXJuIFttaWQsIF90aGlzLl9nZXRNZWRpYVRyYWNrU2VuZGVySWQoc2VuZGVyLnRyYWNrLmlkKV07XG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIHNkcDEgPSB1bmlmaWVkUGxhbkFkZE9yUmV3cml0ZVRyYWNrSWRzKGRlc2NyaXB0aW9uLnNkcCwgbWlkc1RvVHJhY2tJZHMpO1xuICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBDaHJvbWUgYW5kIFNhZmFyaSBkbyBub3QgYXBwbHkgdGhlIG9mZmVyIHVudGlsIHRoZXkgZ2V0IGFuIGFuc3dlci5cbiAgICAgICAgLy8gU28sIHdlIGFkZCBvciByZS13cml0ZSB0aGUgYWN0dWFsIE1lZGlhU3RyZWFtVHJhY2sgSURzIHRvIHRoZSB1bmFzc2lnbmVkIG09IHNlY3Rpb25zIGhlcmUuXG4gICAgICAgIHZhciB1bmFzc2lnbmVkVHJhbnNjZWl2ZXJzID0gYWN0aXZlVHJhbnNjZWl2ZXJzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBtaWQgPSBfYS5taWQ7XG4gICAgICAgICAgICByZXR1cm4gIW1pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuZXdUcmFja0lkc0J5S2luZCA9IG5ldyBNYXAoWydhdWRpbycsICd2aWRlbyddLm1hcChmdW5jdGlvbiAoa2luZCkgeyByZXR1cm4gW1xuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIHVuYXNzaWduZWRUcmFuc2NlaXZlcnMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBzZW5kZXIgPSBfYS5zZW5kZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRlci50cmFjay5raW5kID09PSBraW5kO1xuICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBzZW5kZXIgPSBfYS5zZW5kZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9nZXRNZWRpYVRyYWNrU2VuZGVySWQoc2VuZGVyLnRyYWNrLmlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF07IH0pKTtcbiAgICAgICAgdmFyIHNkcDIgPSB1bmlmaWVkUGxhbkFkZE9yUmV3cml0ZU5ld1RyYWNrSWRzKHNkcDEsIG1pZHNUb1RyYWNrSWRzLCBuZXdUcmFja0lkc0J5S2luZCk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5fUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgIHNkcDogc2RwMixcbiAgICAgICAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSb2xsYmFjayBhbmQgYXBwbHkgdGhlIGdpdmVuIG9mZmVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0fSBvZmZlclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9yb2xsYmFja0FuZEFwcGx5T2ZmZXIgPSBmdW5jdGlvbiAob2ZmZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldExvY2FsRGVzY3JpcHRpb24oeyB0eXBlOiAncm9sbGJhY2snIH0pLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIGxvY2FsIGRlc2NyaXB0aW9uIG9uIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1JUQ1Nlc3Npb25EZXNjcmlwdGlvbnxSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0fSBkZXNjcmlwdGlvblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9zZXRMb2NhbERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlICE9PSAncm9sbGJhY2snICYmIHRoaXMuX3Nob3VsZEFwcGx5RHR4KSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IG5ldyB0aGlzLl9SVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgICAgIHNkcDogZW5hYmxlRHR4Rm9yT3B1cyhkZXNjcmlwdGlvbi5zZHApLFxuICAgICAgICAgICAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRMb2NhbERlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2cud2FybihcIkNhbGxpbmcgc2V0TG9jYWxEZXNjcmlwdGlvbiB3aXRoIGFuIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBvZiB0eXBlIFxcXCJcIiArIGRlc2NyaXB0aW9uLnR5cGUgKyBcIlxcXCIgZmFpbGVkIHdpdGggdGhlIGVycm9yIFxcXCJcIiArIGVycm9yLm1lc3NhZ2UgKyBcIlxcXCIuXCIpO1xuICAgICAgICAgICAgdmFyIGVycm9yVG9UaHJvdyA9IG5ldyBNZWRpYUNsaWVudExvY2FsRGVzY0ZhaWxlZEVycm9yKCk7XG4gICAgICAgICAgICB2YXIgcHVibGlzaFdhcm5pbmcgPSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJDYWxsaW5nIHNldExvY2FsRGVzY3JpcHRpb24gd2l0aCBhbiBSVENTZXNzaW9uRGVzY3JpcHRpb24gb2YgdHlwZSBcXFwiXCIgKyBkZXNjcmlwdGlvbi50eXBlICsgXCJcXFwiIGZhaWxlZFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yVG9UaHJvdy5jb2RlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbi5zZHApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLndhcm4oXCJUaGUgU0RQIHdhcyBcIiArIGRlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgICAgICAgICAgcHVibGlzaFdhcm5pbmcuc2RwID0gZGVzY3JpcHRpb24uc2RwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hNZWRpYVdhcm5pbmcocHVibGlzaFdhcm5pbmcpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JUb1Rocm93O1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlICE9PSAncm9sbGJhY2snKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvY2FsRGVzY3JpcHRpb24gPSBfdGhpcy5faXNVbmlmaWVkUGxhbiA/IF90aGlzLl9hZGRPclJld3JpdGVMb2NhbFRyYWNrSWRzKGRlc2NyaXB0aW9uKSA6IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IEluIG9yZGVyIGZvciB0aGlzIGZlYXR1cmUgdG8gYmUgYmFja3dhcmQgY29tcGF0aWJsZSB3aXRoIG9sZGVyXG4gICAgICAgICAgICAgICAgLy8gU0RLIHZlcnNpb25zIHdoaWNoIHRvIG5vdCBzdXBwb3J0IG9wdXMgRFRYLCB3ZSBhcHBlbmQgXCJ1c2VkdHg9MVwiIHRvIHRoZSBsb2NhbCBTRFBcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHdoaWxlIGFwcGx5aW5nIGl0LiBXZSB3aWxsIG5vdCBzZW5kIGl0IG92ZXIgdGhlIHdpcmUgdG8gcHJldmVudCBpbmFkdmVydGVudFxuICAgICAgICAgICAgICAgIC8vIGVuYWJsaW5nIG9mIG9wdXMgRFRYIGluIG9sZGVyIFNES3MuIE5ld2VyIFNES3Mgd2lsbCBhcHBlbmQgXCJ1c2VkdHg9MVwiIGJ5IHRoZW1zZWx2ZXNcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZGV2ZWxvcGVyIGhhcyByZXF1ZXN0ZWQgb3B1cyBEVFggdG8gYmUgZW5hYmxlZC4gKEpTREstMzA2MylcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3Nob3VsZEFwcGx5RHR4KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2NhbERlc2NyaXB0aW9uID0gbmV3IF90aGlzLl9SVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2RwOiBlbmFibGVEdHhGb3JPcHVzKF90aGlzLl9sb2NhbERlc2NyaXB0aW9uLnNkcCwgW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX3RoaXMuX2xvY2FsRGVzY3JpcHRpb24udHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvY2FsQ2FuZGlkYXRlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnb2ZmZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9kZXNjcmlwdGlvblJldmlzaW9uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sYXN0U3RhYmxlRGVzY3JpcHRpb25SZXZpc2lvbiA9IF90aGlzLl9kZXNjcmlwdGlvblJldmlzaW9uO1xuICAgICAgICAgICAgICAgICAgICBuZWdvdGlhdGlvbkNvbXBsZXRlZChfdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2NhbFVmcmFnID0gZ2V0VWZyYWcoZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Rlc2NyaXB0aW9uJywgX3RoaXMuZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGEgcmVtb3RlIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBvbiB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0fSBkZXNjcmlwdGlvblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLl9zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24uc2RwKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUlRDUnRwU2VuZGVyUGFyYW1zU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24uc2RwID0gdGhpcy5fc2V0Qml0cmF0ZVBhcmFtZXRlcnMoZGVzY3JpcHRpb24uc2RwLCBpc0ZpcmVmb3ggPyAnVElBUycgOiAnQVMnLCB0aGlzLl9lbmNvZGluZ1BhcmFtZXRlcnMubWF4QXVkaW9CaXRyYXRlLCB0aGlzLl9lbmNvZGluZ1BhcmFtZXRlcnMubWF4VmlkZW9CaXRyYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLnNkcCA9IHRoaXMuX3NldENvZGVjUHJlZmVyZW5jZXMoZGVzY3JpcHRpb24uc2RwLCB0aGlzLl9wcmVmZXJyZWRBdWRpb0NvZGVjcywgdGhpcy5fcHJlZmVycmVkVmlkZW9Db2RlY3MpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEFwcGx5RHR4KSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24uc2RwID0gZW5hYmxlRHR4Rm9yT3B1cyhkZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogUmVtb3ZlIFwidXNlZHR4PTFcIiBmcm9tIG9wdXMncyBmbXRwIGxpbmUgaWYgcHJlc2VudFxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIERUWCBpcyBkaXNhYmxlZC5cbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5zZHAgPSBlbmFibGVEdHhGb3JPcHVzKGRlc2NyaXB0aW9uLnNkcCwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRmlyZWZveCkge1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobXJvYmVydHMpOiBEbyB0aGlzIHRvIHJlZHVjZSBvdXIgTWVkaWFTdHJlYW0gY291bnQgaW4gRmlyZWZveC4gQnlcbiAgICAgICAgICAgICAgICAvLyBtYXBwaW5nIE1lZGlhU3RyZWFtIElEcyBpbiB0aGUgU0RQIHRvIFwiLVwiLCB3ZSBlbnN1cmUgdGhlIFwidHJhY2tcIiBldmVudFxuICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgaW5jbHVkZSBhbnkgbmV3IE1lZGlhU3RyZWFtcyBpbiBGaXJlZm94LiBJdHMgYHN0cmVhbXNgIG1lbWJlclxuICAgICAgICAgICAgICAgIC8vIHdpbGwgYWx3YXlzIGJlIHRoZSBlbXB0eSBBcnJheS5cbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5zZHAgPSBmaWx0ZXJPdXRNZWRpYVN0cmVhbUlkcyhkZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wZWVyQ29ubmVjdGlvbi5yZW1vdGVEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzSWNlTGl0ZSA9IC9hPWljZS1saXRlLy50ZXN0KGRlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVzY3JpcHRpb24gPSBuZXcgdGhpcy5fUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE5PVEUoc3llcnJhcHJhZ2FkYSk6IFZNUyBkb2VzIG5vdCBzdXBwb3J0IEgyNjQgc2ltdWxjYXN0LiBTbyxcbiAgICAgICAgICAgIC8vIHVuc2V0IHNpbXVsY2FzdCBmb3Igc2VjdGlvbnMgaW4gbG9jYWwgb2ZmZXIgd2hlcmUgY29ycmVzcG9uZGluZ1xuICAgICAgICAgICAgLy8gc2VjdGlvbnMgaW4gYW5zd2VyIGRvZXNuJ3QgaGF2ZSB2cDggYXMgcHJlZmVycmVkIGNvZGVjIGFuZCByZWFwcGx5IG9mZmVyLlxuICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICdhbnN3ZXInICYmIF90aGlzLl9zaG91bGRBcHBseVNpbXVsY2FzdCkge1xuICAgICAgICAgICAgICAgIHZhciBzZHBXaXRob3V0U2ltdWxjYXN0Rm9yTm9uVlA4TWVkaWFTZWN0aW9ucyA9IF90aGlzLl9yZXZlcnRTaW11bGNhc3RGb3JOb25WUDhNZWRpYVNlY3Rpb25zKF90aGlzLl9sb2NhbERlc2NyaXB0aW9uLnNkcCwgX3RoaXMuX2xvY2FsRGVzY3JpcHRpb25XaXRob3V0U2ltdWxjYXN0LnNkcCwgZGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgICAgICAgICBpZiAoc2RwV2l0aG91dFNpbXVsY2FzdEZvck5vblZQOE1lZGlhU2VjdGlvbnMgIT09IF90aGlzLl9sb2NhbERlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JvbGxiYWNrQW5kQXBwbHlPZmZlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfdGhpcy5fbG9jYWxEZXNjcmlwdGlvbi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2RwOiBzZHBXaXRob3V0U2ltdWxjYXN0Rm9yTm9uVlA4TWVkaWFTZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3BlZXJDb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKTsgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lzUmVzdGFydGluZ0ljZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKCdBbiBJQ0UgcmVzdGFydCB3YXMgaW4tcHJvZ3Jlc3MgYW5kIGlzIG5vdyBjb21wbGV0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzUmVzdGFydGluZ0ljZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZWdvdGlhdGlvbkNvbXBsZXRlZChfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMuX2xvZy53YXJuKFwiQ2FsbGluZyBzZXRSZW1vdGVEZXNjcmlwdGlvbiB3aXRoIGFuIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBvZiB0eXBlIFxcXCJcIiArIGRlc2NyaXB0aW9uLnR5cGUgKyBcIlxcXCIgZmFpbGVkIHdpdGggdGhlIGVycm9yIFxcXCJcIiArIGVycm9yLm1lc3NhZ2UgKyBcIlxcXCIuXCIpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9sb2cud2FybihcIlRoZSBTRFAgd2FzIFwiICsgZGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9J3MgZGVzY3JpcHRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1JUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXR9IGRlc2NyaXB0aW9uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX3VwZGF0ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAoZGVzY3JpcHRpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYW5zd2VyJzpcbiAgICAgICAgICAgIGNhc2UgJ3ByYW5zd2VyJzpcbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24ucmV2aXNpb24gIT09IHRoaXMuX2Rlc2NyaXB0aW9uUmV2aXNpb25cbiAgICAgICAgICAgICAgICAgICAgfHwgdGhpcy5fcGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09ICdoYXZlLWxvY2FsLW9mZmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uUmV2aXNpb24gPSBkZXNjcmlwdGlvbi5yZXZpc2lvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Nsb3NlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2UoKTtcbiAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZS1vZmZlcic6XG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnJldmlzaW9uIDw9IHRoaXMuX2xhc3RTdGFibGVEZXNjcmlwdGlvblJldmlzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fbmVlZHNBbnN3ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWVkRGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kZXNjcmlwdGlvblJldmlzaW9uID0gZGVzY3JpcHRpb24ucmV2aXNpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZmVyKCk7XG4gICAgICAgICAgICBjYXNlICdvZmZlcic6XG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnJldmlzaW9uIDw9IHRoaXMuX2xhc3RTdGFibGVEZXNjcmlwdGlvblJldmlzaW9uXG4gICAgICAgICAgICAgICAgICAgIHx8IHRoaXMuX3BlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gJ2hhdmUtbG9jYWwtb2ZmZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBGb3IgYSBwZWVyIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gMSkgY3JlYXRlT2ZmZXIgYWx3YXlzIGdlbmVyYXRlIFNEUCB3aXRoIGBzZXR1cDphY3RwYXNzYFxuICAgICAgICAgICAgICAgICAgICAvLyAyKSB3aGVuIHJlbW90ZSBkZXNjcmlwdGlvbiBpcyBzZXQgYHNldHVwOmFjdGl2ZWAgIC0gdGhlIGFuc3dlciBnZW5lcmF0ZWQgc2VsZWN0cyB0aGUgZHRscyByb2xlIG9mIHNldHVwOnBhc3NpdmVcbiAgICAgICAgICAgICAgICAgICAgLy8gMykgd2hlbiByZW1vdGUgZGVzY3JpcHRpb24gaXMgc2V0IGBzZXR1cDpwYXNzaXZlYCAtIHRoZSBhbnN3ZXIgZ2VuZXJhdGVkIHNlbGVjdHMgdGhlIGR0bHMgcm9sZSBvZiBzZXR1cDphY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgLy8gNCkgd2hlbiByZW1vdGUgZGVzY3JpcHRpb24gaXMgc2V0IGBzZXR1cDphY3RwYXNzYCAtIHRoZSBhbnN3ZXIgZ2VuZXJhdGVkIHVzZXMgdGhlIHByZXZpb3VzbHkgbmVnb3RpYXRlZCByb2xlIChpZiBub3QgbmVnb3RpYXRlZCBwcmV2aW91c2x5IHNldHVwOmFjdGl2ZSBpcyB1c2VkKVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHRlc3Qgc2hvd3MgdGhlICBiZWhhdmlvcjogaHR0cHM6Ly9naXRodWIuY29tL3R3aWxpby90d2lsaW8td2VicnRjLmpzL2Jsb2IvbWFzdGVyL3Rlc3QvaW50ZWdyYXRpb24vc3BlYy9ydGNwZWVyY29ubmVjdGlvbi5qcyNMOTM2XG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggZ2xhcmUgaGFuZGxpbmcgKGlmIGR0bHMgcm9sZSB3YXMgbm90IG5lZ290aWF0ZWQgYmVmb3JlICkgdGhlIGdlbmVyYXRlZCBhbnN3ZXIgd2lsbCBzZXQgc2V0dXA6YWN0aXZlLlxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0aGF0LiBsZXRzIHdhaXQgZm9yIFwiaW5pdGlhbCBuZWdvdGlhdGlvblwiIGJlZm9yZSBhdHRlbXB0aW5nIGdsYXJlIGhhbmRsaW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmVlZHNBbnN3ZXIgJiYgdGhpcy5fbGFzdFN0YWJsZURlc2NyaXB0aW9uUmV2aXNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlZERlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVzY3JpcHRpb25SZXZpc2lvbiA9IGRlc2NyaXB0aW9uLnJldmlzaW9uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlR2xhcmUoZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kZXNjcmlwdGlvblJldmlzaW9uID0gZGVzY3JpcHRpb24ucmV2aXNpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fuc3dlcihkZXNjcmlwdGlvbikudGhlbihmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGFuc3dlciBvciBwcmFuc3dlci5cbiAgICAgICAgdmFyIHJldmlzaW9uID0gZGVzY3JpcHRpb24ucmV2aXNpb247XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2V0UmVtb3RlRGVzY3JpcHRpb24oZGVzY3JpcHRpb24pO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBlcnJvclRvVGhyb3cgPSBuZXcgTWVkaWFDbGllbnRSZW1vdGVEZXNjRmFpbGVkRXJyb3IoKTtcbiAgICAgICAgICAgIF90aGlzLl9wdWJsaXNoTWVkaWFXYXJuaW5nKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNhbGxpbmcgc2V0UmVtb3RlRGVzY3JpcHRpb24gd2l0aCBhbiBSVENTZXNzaW9uRGVzY3JpcHRpb24gb2YgdHlwZSBcXFwiXCIgKyBkZXNjcmlwdGlvbi50eXBlICsgXCJcXFwiIGZhaWxlZFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yVG9UaHJvdy5jb2RlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICBzZHA6IGRlc2NyaXB0aW9uLnNkcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvclRvVGhyb3c7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2xhc3RTdGFibGVEZXNjcmlwdGlvblJldmlzaW9uID0gcmV2aXNpb247XG4gICAgICAgICAgICBfdGhpcy5fbmVlZHNBbnN3ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY2hlY2tJY2VCb3goZGVzY3JpcHRpb24pO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcXVldWVkRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAmJiBfdGhpcy5fdXBkYXRlRGVzY3JpcHRpb24oX3RoaXMuX3F1ZXVlZERlc2NyaXB0aW9uKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fcXVldWVkRGVzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9tYXliZVJlb2ZmZXIoX3RoaXMuX3BlZXJDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb24pLnRoZW4oZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfSdzIElDRSBjYW5kaWRhdGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGljZVN0YXRlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuX3VwZGF0ZUljZSA9IGZ1bmN0aW9uIChpY2VTdGF0ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlcyA9IHRoaXMuX3JlbW90ZUNhbmRpZGF0ZXMudXBkYXRlKGljZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEljZUNhbmRpZGF0ZXMoY2FuZGlkYXRlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSB7QGxpbmsgRGF0YVRyYWNrU2VuZGVyfSB0byB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEBwYXJhbSB7RGF0YVRyYWNrU2VuZGVyfSBkYXRhVHJhY2tTZW5kZXJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5hZGREYXRhVHJhY2tTZW5kZXIgPSBmdW5jdGlvbiAoZGF0YVRyYWNrU2VuZGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhQ2hhbm5lbHMuaGFzKGRhdGFUcmFja1NlbmRlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGRhdGFDaGFubmVsRGljdCA9IHtcbiAgICAgICAgICAgICAgICBvcmRlcmVkOiBkYXRhVHJhY2tTZW5kZXIub3JkZXJlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChkYXRhVHJhY2tTZW5kZXIubWF4UGFja2V0TGlmZVRpbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbERpY3QubWF4UGFja2V0TGlmZVRpbWUgPSBkYXRhVHJhY2tTZW5kZXIubWF4UGFja2V0TGlmZVRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YVRyYWNrU2VuZGVyLm1heFJldHJhbnNtaXRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YUNoYW5uZWxEaWN0Lm1heFJldHJhbnNtaXRzID0gZGF0YVRyYWNrU2VuZGVyLm1heFJldHJhbnNtaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRhdGFDaGFubmVsID0gdGhpcy5fcGVlckNvbm5lY3Rpb24uY3JlYXRlRGF0YUNoYW5uZWwoZGF0YVRyYWNrU2VuZGVyLmlkLCBkYXRhQ2hhbm5lbERpY3QpO1xuICAgICAgICAgICAgZGF0YVRyYWNrU2VuZGVyLmFkZERhdGFDaGFubmVsKGRhdGFDaGFubmVsKTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFDaGFubmVscy5zZXQoZGF0YVRyYWNrU2VuZGVyLCBkYXRhQ2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIkVycm9yIGNyZWF0aW5nIGFuIFJUQ0RhdGFDaGFubmVsIGZvciBEYXRhVHJhY2sgXFxcIlwiICsgZGF0YVRyYWNrU2VuZGVyLmlkICsgXCJcXFwiOiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHtAbGluayBNZWRpYVRyYWNrU2VuZGVyfSB0byB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEBwYXJhbSB7TWVkaWFUcmFja1NlbmRlcn0gbWVkaWFUcmFja1NlbmRlclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLmFkZE1lZGlhVHJhY2tTZW5kZXIgPSBmdW5jdGlvbiAobWVkaWFUcmFja1NlbmRlcikge1xuICAgICAgICBpZiAodGhpcy5fcGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnIHx8IHRoaXMuX3J0cFNlbmRlcnMuaGFzKG1lZGlhVHJhY2tTZW5kZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbmRlcjtcbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsTWVkaWFTdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsTWVkaWFTdHJlYW0uYWRkVHJhY2sobWVkaWFUcmFja1NlbmRlci50cmFjayk7XG4gICAgICAgICAgICBzZW5kZXIgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5hZGRUcmFjayhtZWRpYVRyYWNrU2VuZGVyLnRyYWNrLCB0aGlzLl9sb2NhbE1lZGlhU3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2NlaXZlciA9IHRoaXMuX2FkZE9yVXBkYXRlVHJhbnNjZWl2ZXIobWVkaWFUcmFja1NlbmRlci50cmFjayk7XG4gICAgICAgICAgICBzZW5kZXIgPSB0cmFuc2NlaXZlci5zZW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgbWVkaWFUcmFja1NlbmRlci5hZGRTZW5kZXIoc2VuZGVyKTtcbiAgICAgICAgdGhpcy5fcnRwU2VuZGVycy5zZXQobWVkaWFUcmFja1NlbmRlciwgc2VuZGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0uXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXNjcmlwdGlvblJldmlzaW9uKys7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbERlc2NyaXB0aW9uID0geyB0eXBlOiAnY2xvc2UnIH07XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Rlc2NyaXB0aW9uJywgdGhpcy5nZXRTdGF0ZSgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB7QGxpbmsgRGF0YVRyYWNrUmVjZWl2ZXJ9cyBhbmQgdGhlIHtAbGluayBNZWRpYVRyYWNrUmVjZWl2ZXJzfSBvbiB0aGVcbiAgICAgKiB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0uXG4gICAgICogQHJldHVybnMge0FycmF5PERhdGFUcmFja1JlY2VpdmVyfE1lZGlhVHJhY2tSZWNlaXZlcj59IHRyYWNrUmVjZWl2ZXJzXG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuZ2V0VHJhY2tSZWNlaXZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2RhdGFUcmFja1JlY2VpdmVycykuY29uY2F0KEFycmF5LmZyb20odGhpcy5fbWVkaWFUcmFja1JlY2VpdmVycykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0ncyBzdGF0ZSAoc3BlY2lmaWNhbGx5LCBpdHMgZGVzY3JpcHRpb24pLlxuICAgICAqIEByZXR1cm5zIHs/b2JqZWN0fVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvY2FsRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBSZXR1cm4gbW9zdCByZWNlbnQgbG9jYWxEZXNjcmlwdGlvbi4gSWYgdGhlIG1vc3QgcmVjZW50IGxvY2FsIGRlc2NyaXB0aW9uIGlzIGFuXG4gICAgICAgIC8vIGFuc3dlciwgYW5kIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBmb3Igc2VuZGluZyBhIFwic3luY1wiIG1lc3NhZ2Ugd2hpbGUgdGhlIG5leHQgcmVtb3RlIG9mZmVyIGlzIGJlaW5nIHByb2Nlc3NlZCxcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzZW5kIHRoZSBtb3N0IHJlY2VudCBzdGFibGUgZGVzY3JpcHRpb24gcmV2aXNpb24gaW5zdGVhZCBvZiB0aGUgY3VycmVudCBkZXNjcmlwdGlvbiByZXZpc2lvbixcbiAgICAgICAgLy8gd2hpY2ggaXMgc3VwcG9zZWQgdG8gYmUgZm9yIHRoZSBuZXh0IGxvY2FsIGFuc3dlci5cbiAgICAgICAgdmFyIGxvY2FsRGVzY3JpcHRpb25SZXZpc2lvbiA9IHRoaXMuX2xvY2FsRGVzY3JpcHRpb24udHlwZSA9PT0gJ2Fuc3dlcicgPyB0aGlzLl9sYXN0U3RhYmxlRGVzY3JpcHRpb25SZXZpc2lvbiA6IHRoaXMuX2Rlc2NyaXB0aW9uUmV2aXNpb247XG4gICAgICAgIHZhciBsb2NhbERlc2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy5fbG9jYWxEZXNjcmlwdGlvbi50eXBlLFxuICAgICAgICAgICAgcmV2aXNpb246IGxvY2FsRGVzY3JpcHRpb25SZXZpc2lvblxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fbG9jYWxEZXNjcmlwdGlvbi5zZHApIHtcbiAgICAgICAgICAgIGxvY2FsRGVzY3JpcHRpb24uc2RwID0gdGhpcy5fbG9jYWxEZXNjcmlwdGlvbi5zZHA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBsb2NhbERlc2NyaXB0aW9uLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBvZmZlciBhbmQgc2V0IGl0IG9uIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUub2ZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9uZWVkc0Fuc3dlciB8fCB0aGlzLl9pc1Jlc3RhcnRpbmdJY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3VsZE9mZmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5icmFja2V0KCdvZmZlcmluZycsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIF90aGlzLnRyYW5zaXRpb24oJ3VwZGF0aW5nJywga2V5KTtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gX3RoaXMuX25lZWRzQW5zd2VyIHx8IF90aGlzLl9pc1Jlc3RhcnRpbmdJY2UgPyBQcm9taXNlLnJlc29sdmUoKSA6IF90aGlzLl9vZmZlcigpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJ5VHJhbnNpdGlvbignb3BlbicsIGtleSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50cnlUcmFuc2l0aW9uKCdvcGVuJywga2V5KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHtAbGluayBEYXRhVHJhY2tTZW5kZXJ9IGZyb20gdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfS5cbiAgICAgKiBAcGFyYW0ge0RhdGFUcmFja1NlbmRlcn0gZGF0YVRyYWNrU2VuZGVyXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUucmVtb3ZlRGF0YVRyYWNrU2VuZGVyID0gZnVuY3Rpb24gKGRhdGFUcmFja1NlbmRlcikge1xuICAgICAgICB2YXIgZGF0YUNoYW5uZWwgPSB0aGlzLl9kYXRhQ2hhbm5lbHMuZ2V0KGRhdGFUcmFja1NlbmRlcik7XG4gICAgICAgIGlmIChkYXRhQ2hhbm5lbCkge1xuICAgICAgICAgICAgZGF0YVRyYWNrU2VuZGVyLnJlbW92ZURhdGFDaGFubmVsKGRhdGFDaGFubmVsKTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFDaGFubmVscy5kZWxldGUoZGF0YVRyYWNrU2VuZGVyKTtcbiAgICAgICAgICAgIGRhdGFDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUge0BsaW5rIE1lZGlhVHJhY2tTZW5kZXJ9IGZyb20gdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfS5cbiAgICAgKiBAcGFyYW0ge01lZGlhVHJhY2tTZW5kZXJ9IG1lZGlhVHJhY2tTZW5kZXJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5yZW1vdmVNZWRpYVRyYWNrU2VuZGVyID0gZnVuY3Rpb24gKG1lZGlhVHJhY2tTZW5kZXIpIHtcbiAgICAgICAgdmFyIHNlbmRlciA9IHRoaXMuX3J0cFNlbmRlcnMuZ2V0KG1lZGlhVHJhY2tTZW5kZXIpO1xuICAgICAgICBpZiAoIXNlbmRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsTWVkaWFTdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsTWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2sobWVkaWFUcmFja1NlbmRlci50cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgbWVkaWFUcmFja1NlbmRlci5yZW1vdmVTZW5kZXIoc2VuZGVyKTtcbiAgICAgICAgdGhpcy5fcnRwU2VuZGVycy5kZWxldGUobWVkaWFUcmFja1NlbmRlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIFJUQ0NvbmZpZ3VyYXRpb24gb24gdGhlIHVuZGVybHlpbmcgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIHtSVENDb25maWd1cmF0aW9ufSBjb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25WMi5wcm90b3R5cGUuc2V0Q29uZmlndXJhdGlvbiA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0Q29uZmlndXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0Q29uZmlndXJhdGlvbihnZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBJQ0UgcmVjb25uZWN0IHRpbWVvdXQgcGVyaW9kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwZXJpb2QgLSBQZXJpb2QgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uVjIucHJvdG90eXBlLnNldEljZVJlY29ubmVjdFRpbWVvdXQgPSBmdW5jdGlvbiAocGVyaW9kKSB7XG4gICAgICAgIHRoaXMuX2ljZVJlY29ubmVjdFRpbWVvdXQuc2V0RGVsYXkocGVyaW9kKTtcbiAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdVcGRhdGVkIElDRSByZWNvbm5lY3Rpb24gdGltZW91dCBwZXJpb2Q6JywgdGhpcy5faWNlUmVjb25uZWN0VGltZW91dC5kZWxheSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn0uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBlZXJDb25uZWN0aW9uU3RhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAocGVlckNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5icmFja2V0KCd1cGRhdGluZycsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy50cmFuc2l0aW9uKCd1cGRhdGluZycsIGtleSk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHBlZXJDb25uZWN0aW9uU3RhdGUuaWNlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKF90aGlzLl91cGRhdGVJY2UocGVlckNvbm5lY3Rpb25TdGF0ZS5pY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwZWVyQ29ubmVjdGlvblN0YXRlLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKF90aGlzLl91cGRhdGVEZXNjcmlwdGlvbihwZWVyQ29ubmVjdGlvblN0YXRlLmRlc2NyaXB0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodXBkYXRlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJ5VHJhbnNpdGlvbignb3BlbicsIGtleSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50cnlUcmFuc2l0aW9uKCdvcGVuJywga2V5KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9J3MgbWVkaWEgc3RhdGlzdGljcy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdGFuZGFyZGl6ZWRTdGF0c1Jlc3BvbnNlPn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvblYyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGdldFN0YXRpc3RpY3ModGhpcy5fcGVlckNvbm5lY3Rpb24pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiByZXdyaXRlVHJhY2tJZHMoX3RoaXMsIHJlc3BvbnNlKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGVlckNvbm5lY3Rpb25WMjtcbn0oU3RhdGVNYWNoaW5lKSk7XG5mdW5jdGlvbiByZXdyaXRlTG9jYWxUcmFja0lkKHBjdjIsIHN0YXRzKSB7XG4gICAgdmFyIHRyYWNrSWQgPSBwY3YyLl9nZXRNZWRpYVRyYWNrU2VuZGVySWQoc3RhdHMudHJhY2tJZCk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3RhdHMsIHsgdHJhY2tJZDogdHJhY2tJZCB9KTtcbn1cbmZ1bmN0aW9uIHJld3JpdGVUcmFja0lkKHBjdjIsIHN0YXRzKSB7XG4gICAgdmFyIHJlY2VpdmVyID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHBjdjIuX21lZGlhVHJhY2tSZWNlaXZlcnMpKS5maW5kKGZ1bmN0aW9uIChyZWNlaXZlcikgeyByZXR1cm4gcmVjZWl2ZXIudHJhY2suaWQgPT09IHN0YXRzLnRyYWNrSWQ7IH0pO1xuICAgIHZhciB0cmFja0lkID0gcmVjZWl2ZXIgPyByZWNlaXZlci5pZCA6IG51bGw7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3RhdHMsIHsgdHJhY2tJZDogdHJhY2tJZCB9KTtcbn1cbmZ1bmN0aW9uIHJld3JpdGVUcmFja0lkcyhwY3YyLCByZXNwb25zZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3BvbnNlLCB7XG4gICAgICAgIHJlbW90ZUF1ZGlvVHJhY2tTdGF0czogcmVzcG9uc2UucmVtb3RlQXVkaW9UcmFja1N0YXRzLm1hcChmdW5jdGlvbiAoc3RhdHMpIHsgcmV0dXJuIHJld3JpdGVUcmFja0lkKHBjdjIsIHN0YXRzKTsgfSksXG4gICAgICAgIHJlbW90ZVZpZGVvVHJhY2tTdGF0czogcmVzcG9uc2UucmVtb3RlVmlkZW9UcmFja1N0YXRzLm1hcChmdW5jdGlvbiAoc3RhdHMpIHsgcmV0dXJuIHJld3JpdGVUcmFja0lkKHBjdjIsIHN0YXRzKTsgfSksXG4gICAgICAgIGxvY2FsQXVkaW9UcmFja1N0YXRzOiByZXNwb25zZS5sb2NhbEF1ZGlvVHJhY2tTdGF0cy5tYXAoZnVuY3Rpb24gKHN0YXRzKSB7IHJldHVybiByZXdyaXRlTG9jYWxUcmFja0lkKHBjdjIsIHN0YXRzKTsgfSksXG4gICAgICAgIGxvY2FsVmlkZW9UcmFja1N0YXRzOiByZXNwb25zZS5sb2NhbFZpZGVvVHJhY2tTdGF0cy5tYXAoZnVuY3Rpb24gKHN0YXRzKSB7IHJldHVybiByZXdyaXRlTG9jYWxUcmFja0lkKHBjdjIsIHN0YXRzKTsgfSksXG4gICAgfSk7XG59XG4vKipcbiAqIEBldmVudCBQZWVyQ29ubmVjdGlvblYyI2NhbmRpZGF0ZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBjYW5kaWRhdGVzXG4gKi9cbi8qKlxuICogQGV2ZW50IFBlZXJDb25uZWN0aW9uVjIjY29ubmVjdGlvblN0YXRlQ2hhbmdlZFxuICovXG4vKipcbiAqIEBldmVudCBQZWVyQ29ubmVjdGlvblYyI2Rlc2NyaXB0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gZGVzY3JpcHRpb25cbiAqL1xuLyoqXG4gKiBAZXZlbnQgUGVlckNvbm5lY3Rpb25WMiNpY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gKi9cbi8qKlxuICogQGV2ZW50IFBlZXJDb25uZWN0aW9uVjIjdHJhY2tBZGRlZFxuICogQHBhcmFtIHtEYXRhVHJhY2tSZWNlaXZlcnxNZWRpYVRyYWNrUmVjZWl2ZXJ9IHRyYWNrUmVjZWl2ZXJcbiAqL1xuZnVuY3Rpb24gZ2V0VWZyYWcoZGVzY3JpcHRpb24pIHtcbiAgICBpZiAoZGVzY3JpcHRpb24uc2RwKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGRlc2NyaXB0aW9uLnNkcC5tYXRjaCgvXmE9aWNlLXVmcmFnOihbYS16QS1aMC05Ky9dKykvbSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnXG4gICAgfSwgY29uZmlndXJhdGlvbik7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIE1lZGlhU3RyZWFtVHJhY2sgb2YgdGhlIGdpdmVuIFJUQ1JUUFNlbmRlciBpcyBhIG5vbi1lbmRlZFxuICogTWVkaWFTdHJlYW1UcmFjayBvZiBhIGdpdmVuIGtpbmQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAqIEBwYXJhbSB7UlRDUnRwU2VuZGVyfSBzZW5kZXJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU2VuZGVyT2ZLaW5kKGtpbmQsIHNlbmRlcikge1xuICAgIHZhciB0cmFjayA9IHNlbmRlci50cmFjaztcbiAgICByZXR1cm4gdHJhY2sgJiYgdHJhY2sua2luZCA9PT0ga2luZCAmJiB0cmFjay5yZWFkeVN0YXRlICE9PSAnZW5kZWQnO1xufVxuLyoqXG4gKiBQcmVmZXJyZWQgY29kZWNzLlxuICogQHR5cGVkZWYge29iamVjdH0gUHJlZmVycmVkQ29kZWNzXG4gKiBAcHJvcGVydHkge0FycmF5PEF1ZGlvQ29kZWM+fSBhdWRpb1xuICogQHByb3BlcnR5IHtBcnJheTxWaWRlb0NvZGVjPn0gdmlkZW9cbiAqL1xuZnVuY3Rpb24gZmlsdGVyT3V0TWVkaWFTdHJlYW1JZHMoc2RwKSB7XG4gICAgcmV0dXJuIHNkcC5yZXBsYWNlKC9hPW1zaWQ6W14gXSsgL2csICdhPW1zaWQ6LSAnKTtcbn1cbi8qKlxuICogV2hldGhlciBhbiBSVENSdHBUcmFuc2NlaXZlciBjYW4gYmUgcmVjeWNsZWQuXG4gKiBAcGFyYW0ge1JUQ1J0cFRyYW5zY2VpdmVyfSB0cmFuc2NlaXZlclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFJlY3ljbGVUcmFuc2NlaXZlcih0cmFuc2NlaXZlciwgcGN2Mikge1xuICAgIHJldHVybiAhdHJhbnNjZWl2ZXIuc3RvcHBlZFxuICAgICAgICAmJiAhcGN2Mi5fcmVwbGFjZVRyYWNrUHJvbWlzZXMuaGFzKHRyYW5zY2VpdmVyKVxuICAgICAgICAmJiBbJ2luYWN0aXZlJywgJ3JlY3Zvbmx5J10uaW5jbHVkZXModHJhbnNjZWl2ZXIuZGlyZWN0aW9uKTtcbn1cbi8qKlxuICogVGFrZSBhIHJlY3ljbGVkIFJUQ1J0cFRyYW5zY2VpdmVyIGlmIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25WMn0gcGN2MlxuICogQHBhcmFtIHtUcmFjay5LaW5kfSBraW5kXG4gKiBAcmV0dXJucyB7P1JUQ1J0cFRyYW5zY2VpdmVyfVxuICovXG5mdW5jdGlvbiB0YWtlUmVjeWNsZWRUcmFuc2NlaXZlcihwY3YyLCBraW5kKSB7XG4gICAgdmFyIHByZWZlcnJlZENvZGVjcyA9IHtcbiAgICAgICAgYXVkaW86IHBjdjIuX3ByZWZlcnJlZEF1ZGlvQ29kZWNzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBjb2RlYyA9IF9hLmNvZGVjO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVjLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pLFxuICAgICAgICB2aWRlbzogcGN2Mi5fcHJlZmVycmVkVmlkZW9Db2RlY3MubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGNvZGVjID0gX2EuY29kZWM7XG4gICAgICAgICAgICByZXR1cm4gY29kZWMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICB9W2tpbmRdO1xuICAgIHZhciByZWN5Y2xlZFRyYW5zY2VpdmVycyA9IHBjdjIuX3JlY3ljbGVkVHJhbnNjZWl2ZXJzW2tpbmRdO1xuICAgIHZhciBsb2NhbENvZGVjID0gcHJlZmVycmVkQ29kZWNzLmZpbmQoZnVuY3Rpb24gKGNvZGVjKSB7IHJldHVybiBwY3YyLl9sb2NhbENvZGVjcy5oYXMoY29kZWMpOyB9KTtcbiAgICBpZiAoIWxvY2FsQ29kZWMpIHtcbiAgICAgICAgcmV0dXJuIHJlY3ljbGVkVHJhbnNjZWl2ZXJzLnNoaWZ0KCk7XG4gICAgfVxuICAgIHZhciB0cmFuc2NlaXZlciA9IHJlY3ljbGVkVHJhbnNjZWl2ZXJzLmZpbmQoZnVuY3Rpb24gKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHZhciByZW1vdGVDb2RlY01hcCA9IHBjdjIuX3JlbW90ZUNvZGVjTWFwcy5nZXQodHJhbnNjZWl2ZXIubWlkKTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUNvZGVjTWFwICYmIHJlbW90ZUNvZGVjTWFwLmhhcyhsb2NhbENvZGVjKTtcbiAgICB9KTtcbiAgICBpZiAodHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmVjeWNsZWRUcmFuc2NlaXZlcnMuc3BsaWNlKHJlY3ljbGVkVHJhbnNjZWl2ZXJzLmluZGV4T2YodHJhbnNjZWl2ZXIpLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zY2VpdmVyO1xufVxuLyoqXG4gKiBVcGRhdGUgdGhlIHNldCBvZiBsb2NhbGx5IHN1cHBvcnRlZCB7QGxpbmsgQ29kZWN9cy5cbiAqIEBwYXJhbSBwY3YyXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gdXBkYXRlTG9jYWxDb2RlY3MocGN2Mikge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHBjdjIuX3BlZXJDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb247XG4gICAgaWYgKCFkZXNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGdldE1lZGlhU2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgIHZhciBjb2RlY01hcCA9IGNyZWF0ZUNvZGVjTWFwRm9yTWVkaWFTZWN0aW9uKHNlY3Rpb24pO1xuICAgICAgICBjb2RlY01hcC5mb3JFYWNoKGZ1bmN0aW9uIChwdHMsIGNvZGVjKSB7IHJldHVybiBwY3YyLl9sb2NhbENvZGVjcy5hZGQoY29kZWMpOyB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogVXBkYXRlIHRoZSB7QGxpbmsgQ29kZWN9IG1hcHMgZm9yIGFsbCBtPSBzZWN0aW9ucyBpbiB0aGUgcmVtb3RlIHtAbGluayBSVENTZXNzaW9uRGVzY3JpcHRpb259cy5cbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25WMn0gcGN2MlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVJlbW90ZUNvZGVjTWFwcyhwY3YyKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gcGN2Mi5fcGVlckNvbm5lY3Rpb24ucmVtb3RlRGVzY3JpcHRpb247XG4gICAgaWYgKCFkZXNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGdldE1lZGlhU2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgIHZhciBtaWQgPSBzZWN0aW9uLm1hdGNoKC9eYT1taWQ6KC4rKSQvbSlbMV07XG4gICAgICAgIHZhciBjb2RlY01hcCA9IGNyZWF0ZUNvZGVjTWFwRm9yTWVkaWFTZWN0aW9uKHNlY3Rpb24pO1xuICAgICAgICBwY3YyLl9yZW1vdGVDb2RlY01hcHMuc2V0KG1pZCwgY29kZWNNYXApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBVcGRhdGUgdGhlIGxpc3Qgb2YgcmVjeWNsZWQgUlRDUnRwVHJhbnNjZWl2ZXJzLlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvblYyfSBwY3YyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVJlY3ljbGVkVHJhbnNjZWl2ZXJzKHBjdjIpIHtcbiAgICBwY3YyLl9yZWN5Y2xlZFRyYW5zY2VpdmVycy5hdWRpbyA9IFtdO1xuICAgIHBjdjIuX3JlY3ljbGVkVHJhbnNjZWl2ZXJzLnZpZGVvID0gW107XG4gICAgcGN2Mi5fcGVlckNvbm5lY3Rpb24uZ2V0VHJhbnNjZWl2ZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHNob3VsZFJlY3ljbGVUcmFuc2NlaXZlcih0cmFuc2NlaXZlciwgcGN2MikpIHtcbiAgICAgICAgICAgIHZhciB0cmFjayA9IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrO1xuICAgICAgICAgICAgcGN2Mi5fcmVjeWNsZWRUcmFuc2NlaXZlcnNbdHJhY2sua2luZF0ucHVzaCh0cmFuc2NlaXZlcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogUGVyZm9ybSBjZXJ0YWluIHVwZGF0ZXMgYWZ0ZXIgYW4gU0RQIG5lZ290aWF0aW9uIGlzIGNvbXBsZXRlZC5cbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25WMn0gcGN2MlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIG5lZ290aWF0aW9uQ29tcGxldGVkKHBjdjIpIHtcbiAgICBpZiAocGN2Mi5faXNVbmlmaWVkUGxhbikge1xuICAgICAgICB1cGRhdGVSZWN5Y2xlZFRyYW5zY2VpdmVycyhwY3YyKTtcbiAgICAgICAgdXBkYXRlTG9jYWxDb2RlY3MocGN2Mik7XG4gICAgICAgIHVwZGF0ZVJlbW90ZUNvZGVjTWFwcyhwY3YyKTtcbiAgICB9XG4gICAgaWYgKHBjdjIuX2lzUlRDUnRwU2VuZGVyUGFyYW1zU3VwcG9ydGVkKSB7XG4gICAgICAgIHVwZGF0ZUVuY29kaW5nUGFyYW1ldGVycyhwY3YyKTtcbiAgICB9XG59XG4vKipcbiAqIFVwZGF0ZSB0aGUgUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzIG9mIGFsbCBhY3RpdmUgUlRDUnRwU2VuZGVycy5cbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25WMn0gcGN2MlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUVuY29kaW5nUGFyYW1ldGVycyhwY3YyKSB7XG4gICAgdmFyIF9hID0gcGN2Mi5fZW5jb2RpbmdQYXJhbWV0ZXJzLCBtYXhBdWRpb0JpdHJhdGUgPSBfYS5tYXhBdWRpb0JpdHJhdGUsIG1heFZpZGVvQml0cmF0ZSA9IF9hLm1heFZpZGVvQml0cmF0ZTtcbiAgICB2YXIgbWF4Qml0cmF0ZXMgPSBuZXcgTWFwKFtcbiAgICAgICAgWydhdWRpbycsIG1heEF1ZGlvQml0cmF0ZV0sXG4gICAgICAgIFsndmlkZW8nLCBtYXhWaWRlb0JpdHJhdGVdXG4gICAgXSk7XG4gICAgcGN2Mi5fcGVlckNvbm5lY3Rpb24uZ2V0U2VuZGVycygpLmZpbHRlcihmdW5jdGlvbiAoc2VuZGVyKSB7IHJldHVybiBzZW5kZXIudHJhY2s7IH0pLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgICB2YXIgbWF4Qml0cmF0ZSA9IG1heEJpdHJhdGVzLmdldChzZW5kZXIudHJhY2sua2luZCk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBpZiAobWF4Qml0cmF0ZSA9PT0gbnVsbCB8fCBtYXhCaXRyYXRlID09PSAwKSB7XG4gICAgICAgICAgICByZW1vdmVNYXhCaXRyYXRlKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGN2Mi5faXNDaHJvbWVTY3JlZW5TaGFyZVRyYWNrKHNlbmRlci50cmFjaykpIHtcbiAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBTb21ldGltZXMgKEpTREstMjU1NykgY2hyb21lIGRvZXMgbm90IHNlbmQgYW55IGJ5dGVzIG9uIHNjcmVlbiB0cmFjayBpZiBNYXhCaXRSYXRlIGlzIHNldCBvbiBpdCB2aWEgc2V0UGFyYW1ldGVycyxcbiAgICAgICAgICAgIC8vIFRvIHdvcmthcm91bmQgdGhpcyBpc3N1ZSB3ZSB3aWxsIG5vdCBhcHBseSBtYXhCaXRyYXRlIGlmIHRoZSB0cmFjayBhcHBlYXJzIHRvIGJlIGEgc2NyZWVuIHNoYXJlIHRyYWNrIGNyZWF0ZWQgYnkgY2hyb21lXG4gICAgICAgICAgICBwY3YyLl9sb2cud2FybihcIk5vdCBzZXR0aW5nIG1heEJpdHJhdGUgZm9yIFwiICsgc2VuZGVyLnRyYWNrLmtpbmQgKyBcIiBUcmFjayBcIiArIHNlbmRlci50cmFjay5pZCArIFwiIGJlY2F1c2UgaXQgYXBwZWFycyB0byBiZSBzY3JlZW4gc2hhcmUgdHJhY2s6IFwiICsgc2VuZGVyLnRyYWNrLmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldE1heEJpdHJhdGUocGFyYW1zLCBtYXhCaXRyYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRmlyZWZveCAmJiBwY3YyLl9lbmFibGVEc2NwICYmIHBhcmFtcy5lbmNvZGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogXCJuZXR3b3JrUHJpb3JpdHlcIiBpcyBhIHBlci1zZW5kZXIgcHJvcGVydHkgYW5kIG5vdFxuICAgICAgICAgICAgLy8gYSBwZXItZW5jb2RpbmctbGF5ZXIgcHJvcGVydHkuIFNvLCB3ZSBzZXQgdGhlIHZhbHVlIG9ubHkgb24gdGhlIGZpcnN0XG4gICAgICAgICAgICAvLyBlbmNvZGluZyBsYXllci4gQW55IGF0dGVtcHQgdG8gc2V0IHRoZSB2YWx1ZSBvbiBzdWJzZXF1ZW50IGVuY29kaW5nXG4gICAgICAgICAgICAvLyBsYXllcnMgKGluIHRoZSBjYXNlIG9mIHNpbXVsY2FzdCkgd2lsbCByZXN1bHQgaW4gdGhlIFByb21pc2UgcmV0dXJuZWRcbiAgICAgICAgICAgIC8vIGJ5IFJUQ1J0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKCkgYmVpbmcgcmVqZWN0ZWQuXG4gICAgICAgICAgICBwYXJhbXMuZW5jb2RpbmdzWzBdLm5ldHdvcmtQcmlvcml0eSA9ICdoaWdoJztcbiAgICAgICAgfVxuICAgICAgICBzZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcGN2Mi5fbG9nLndhcm4oXCJFcnJvciB3aGlsZSBzZXR0aW5nIGVuY29kaW5ncyBwYXJhbWV0ZXJzIGZvciBcIiArIHNlbmRlci50cmFjay5raW5kICsgXCIgVHJhY2sgXCIgKyBzZW5kZXIudHJhY2suaWQgKyBcIjogXCIgKyAoZXJyb3IubWVzc2FnZSB8fCBlcnJvci5uYW1lKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZW1vdmUgbWF4Qml0cmF0ZSBmcm9tIHRoZSBSVENSdHBTZW5kUGFyYW1ldGVycycgZW5jb2RpbmdzLlxuICogQHBhcmFtIHtSVENSdHBTZW5kUGFyYW1ldGVyc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTWF4Qml0cmF0ZShwYXJhbXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMuZW5jb2RpbmdzKSkge1xuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzLmZvckVhY2goZnVuY3Rpb24gKGVuY29kaW5nKSB7IHJldHVybiBkZWxldGUgZW5jb2RpbmcubWF4Qml0cmF0ZTsgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBTZXQgdGhlIGdpdmVuIG1heEJpdHJhdGUgaW4gdGhlIFJUQ1J0cFNlbmRQYXJhbWV0ZXJzJyBlbmNvZGluZ3MuXG4gKiBAcGFyYW0ge1JUQ1J0cFNlbmRQYXJhbWV0ZXJzfSBwYXJhbXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhCaXRyYXRlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gc2V0TWF4Qml0cmF0ZShwYXJhbXMsIG1heEJpdHJhdGUpIHtcbiAgICBpZiAoaXNGaXJlZm94KSB7XG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBbeyBtYXhCaXRyYXRlOiBtYXhCaXRyYXRlIH1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChlbmNvZGluZykge1xuICAgICAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IG1heEJpdHJhdGU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUGVlckNvbm5lY3Rpb25WMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlZXJjb25uZWN0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICByZXR1cm4gdG87XG59O1xudmFyIGd1ZXNzQnJvd3NlciA9IHJlcXVpcmUoJ0B0d2lsaW8vd2VicnRjL2xpYi91dGlsJykuZ3Vlc3NCcm93c2VyO1xudmFyIFBlZXJDb25uZWN0aW9uVjIgPSByZXF1aXJlKCcuL3BlZXJjb25uZWN0aW9uJyk7XG52YXIgTWVkaWFUcmFja1NlbmRlciA9IHJlcXVpcmUoJy4uLy4uL21lZGlhL3RyYWNrL3NlbmRlcicpO1xudmFyIFF1ZXVlaW5nRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi4vLi4vcXVldWVpbmdldmVudGVtaXR0ZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIE1lZGlhQ29ubmVjdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90d2lsaW8tdmlkZW8tZXJyb3JzJykuTWVkaWFDb25uZWN0aW9uRXJyb3I7XG52YXIgaXNGaXJlZm94ID0gZ3Vlc3NCcm93c2VyKCkgPT09ICdmaXJlZm94Jztcbi8qKlxuICoge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0gbWFuYWdlcyBtdWx0aXBsZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn1zLlxuICogQGV4dGVuZHMgUXVldWVpbmdFdmVudEVtaXR0ZXJcbiAqIEBlbWl0cyBQZWVyQ29ubmVjdGlvbk1hbmFnZXIjY2FuZGlkYXRlc1xuICogQGVtaXRzIFBlZXJDb25uZWN0aW9uTWFuYWdlciNjb25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gKiBAZW1pdHMgUGVlckNvbm5lY3Rpb25NYW5hZ2VyI2Rlc2NyaXB0aW9uXG4gKiBAZW1pdHMgUGVlckNvbm5lY3Rpb25NYW5hZ2VyI2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWRcbiAqIEBlbWl0cyBQZWVyQ29ubmVjdGlvbk1hbmFnZXIjdHJhY2tBZGRlZFxuICovXG52YXIgUGVlckNvbm5lY3Rpb25NYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQZWVyQ29ubmVjdGlvbk1hbmFnZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IHtAbGluayBQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9LlxuICAgICAqIEBwYXJhbSB7RW5jb2RpbmdQYXJhbWV0ZXJzSW1wbH0gZW5jb2RpbmdQYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtQcmVmZXJyZWRDb2RlY3N9IHByZWZlcnJlZENvZGVjc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGVlckNvbm5lY3Rpb25NYW5hZ2VyKGVuY29kaW5nUGFyYW1ldGVycywgcHJlZmVycmVkQ29kZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGF1ZGlvQ29udGV4dEZhY3Rvcnk6IGlzRmlyZWZveFxuICAgICAgICAgICAgICAgID8gcmVxdWlyZSgnLi4vLi4vd2ViYXVkaW8vYXVkaW9jb250ZXh0JylcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICBQZWVyQ29ubmVjdGlvblYyOiBQZWVyQ29ubmVjdGlvblYyXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgYXVkaW9Db250ZXh0ID0gb3B0aW9ucy5hdWRpb0NvbnRleHRGYWN0b3J5XG4gICAgICAgICAgICA/IG9wdGlvbnMuYXVkaW9Db250ZXh0RmFjdG9yeS5nZXRPckNyZWF0ZShfdGhpcylcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgLy8gTk9URShtcm9iZXJ0cyk6IElmIHdlJ3JlIHVzaW5nIGFuIEF1ZGlvQ29udGV4dCwgd2UgZG9uJ3QgbmVlZCB0byBzcGVjaWZ5XG4gICAgICAgIC8vIGBvZmZlclRvUmVjZWl2ZUF1ZGlvYCBpbiBSVENPZmZlck9wdGlvbnMuXG4gICAgICAgIHZhciBvZmZlck9wdGlvbnMgPSBhdWRpb0NvbnRleHRcbiAgICAgICAgICAgID8geyBvZmZlclRvUmVjZWl2ZVZpZGVvOiB0cnVlIH1cbiAgICAgICAgICAgIDogeyBvZmZlclRvUmVjZWl2ZUF1ZGlvOiB0cnVlLCBvZmZlclRvUmVjZWl2ZVZpZGVvOiB0cnVlIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfYXVkaW9Db250ZXh0RmFjdG9yeToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmF1ZGlvQ29udGV4dEZhY3RvcnlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY2xvc2VkUGVlckNvbm5lY3Rpb25JZHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFNldCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jb25maWd1cmF0aW9uRGVmZXJyZWQ6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdXRpbC5kZWZlcigpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2Nvbm5lY3Rpb25TdGF0ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnbmV3JyxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kdW1teUF1ZGlvVHJhY2tTZW5kZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXVkaW9Db250ZXh0XG4gICAgICAgICAgICAgICAgICAgID8gbmV3IE1lZGlhVHJhY2tTZW5kZXIoY3JlYXRlRHVtbXlBdWRpb01lZGlhU3RyZWFtVHJhY2soYXVkaW9Db250ZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2VuY29kaW5nUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBlbmNvZGluZ1BhcmFtZXRlcnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaWNlQ29ubmVjdGlvblN0YXRlOiB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICduZXcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2RhdGFUcmFja1NlbmRlcnM6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFNldCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xhc3RDb25uZWN0aW9uU3RhdGU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ25ldycsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbGFzdEljZUNvbm5lY3Rpb25TdGF0ZToge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnbmV3J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9tZWRpYVRyYWNrU2VuZGVyczoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb2ZmZXJPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9mZmVyT3B0aW9uc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9wZWVyQ29ubmVjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ByZWZlcnJlZENvZGVjczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcmVmZXJyZWRDb2RlY3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2Vzc2lvblRpbWVvdXQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9QZWVyQ29ubmVjdGlvblYyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuUGVlckNvbm5lY3Rpb25WMlxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZSwgXCJjb25uZWN0aW9uU3RhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdW1tYXJpemVkIFJUQ1BlZXJDb25uZWN0aW9uU3RhdGUgYWNyb3NzIGFsbCB0aGVcbiAgICAgICAgICoge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0ncyB1bmRlcmx5aW5nIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfXMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7UlRDUGVlckNvbm5lY3Rpb25TdGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQZWVyQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLCBcImljZUNvbm5lY3Rpb25TdGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN1bW1hcml6ZWQgUlRDSWNlQ29ubmVjdGlvblN0YXRlIGFjcm9zcyBhbGwgdGhlXG4gICAgICAgICAqIHtAbGluayBQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9J3MgdW5kZXJseWluZyB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn1zLlxuICAgICAgICAgKiBAcHJvcGVydHkge1JUQ0ljZUNvbm5lY3Rpb25TdGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn1zIHdoaWNoIGFyZSBubyBsb25nZXIgcmVsZXZhbnQuXG4gICAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBwZWVyQ29ubmVjdGlvblN0YXRlc1xuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuX2Nsb3NlQWJzZW50UGVlckNvbm5lY3Rpb25zID0gZnVuY3Rpb24gKHBlZXJDb25uZWN0aW9uU3RhdGVzKSB7XG4gICAgICAgIHZhciBwZWVyQ29ubmVjdGlvbklkcyA9IG5ldyBTZXQocGVlckNvbm5lY3Rpb25TdGF0ZXMubWFwKGZ1bmN0aW9uIChwZWVyQ29ubmVjdGlvblN0YXRlKSB7IHJldHVybiBwZWVyQ29ubmVjdGlvblN0YXRlLmlkOyB9KSk7XG4gICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwZWVyQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgaWYgKCFwZWVyQ29ubmVjdGlvbklkcy5oYXMocGVlckNvbm5lY3Rpb24uaWQpKSB7XG4gICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24uX2Nsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0ncyBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn1cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLl9nZXRDb25maWd1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlndXJhdGlvbkRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgb3IgY3JlYXRlIGEge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb25maWd1cmF0aW9uXVxuICAgICAqIEByZXR1cm5zIHtQZWVyQ29ubmVjdGlvblYyfVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuX2dldE9yQ3JlYXRlID0gZnVuY3Rpb24gKGlkLCBjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBlZXJDb25uZWN0aW9uID0gdGhpcy5fcGVlckNvbm5lY3Rpb25zLmdldChpZCk7XG4gICAgICAgIGlmICghcGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBQZWVyQ29ubmVjdGlvblYyXzEgPSB0aGlzLl9QZWVyQ29ubmVjdGlvblYyO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBkdW1teUF1ZGlvTWVkaWFTdHJlYW1UcmFjazogdGhpcy5fZHVtbXlBdWRpb1RyYWNrU2VuZGVyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5fZHVtbXlBdWRpb1RyYWNrU2VuZGVyLnRyYWNrXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBvZmZlck9wdGlvbnM6IHRoaXMuX29mZmVyT3B0aW9uc1xuICAgICAgICAgICAgfSwgdGhpcy5fc2Vzc2lvblRpbWVvdXQgPyB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvblRpbWVvdXQ6IHRoaXMuX3Nlc3Npb25UaW1lb3V0XG4gICAgICAgICAgICB9IDoge30sIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwZWVyQ29ubmVjdGlvbiA9IG5ldyBQZWVyQ29ubmVjdGlvblYyXzEoaWQsIHRoaXMuX2VuY29kaW5nUGFyYW1ldGVycywgdGhpcy5fcHJlZmVycmVkQ29kZWNzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1lZGlhQ29ubmVjdGlvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbnMuc2V0KHBlZXJDb25uZWN0aW9uLmlkLCBwZWVyQ29ubmVjdGlvbik7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbignY2FuZGlkYXRlcycsIHRoaXMucXVldWUuYmluZCh0aGlzLCAnY2FuZGlkYXRlcycpKTtcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLm9uKCdkZXNjcmlwdGlvbicsIHRoaXMucXVldWUuYmluZCh0aGlzLCAnZGVzY3JpcHRpb24nKSk7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbigndHJhY2tBZGRlZCcsIHRoaXMucXVldWUuYmluZCh0aGlzLCAndHJhY2tBZGRlZCcpKTtcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBzdGF0ZUNoYW5nZWQoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdzdGF0ZUNoYW5nZWQnLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kYXRhVHJhY2tTZW5kZXJzLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlcikgeyByZXR1cm4gcGVlckNvbm5lY3Rpb24ucmVtb3ZlRGF0YVRyYWNrU2VuZGVyKHNlbmRlcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9tZWRpYVRyYWNrU2VuZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzZW5kZXIpIHsgcmV0dXJuIHBlZXJDb25uZWN0aW9uLnJlbW92ZU1lZGlhVHJhY2tTZW5kZXIoc2VuZGVyKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3BlZXJDb25uZWN0aW9ucy5kZWxldGUocGVlckNvbm5lY3Rpb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jbG9zZWRQZWVyQ29ubmVjdGlvbklkcy5hZGQocGVlckNvbm5lY3Rpb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uU3RhdGUoc2VsZik7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUljZUNvbm5lY3Rpb25TdGF0ZShzZWxmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLm9uKCdjb25uZWN0aW9uU3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlQ29ubmVjdGlvblN0YXRlKF90aGlzKTsgfSk7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5vbignaWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVwZGF0ZUljZUNvbm5lY3Rpb25TdGF0ZShfdGhpcyk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fZGF0YVRyYWNrU2VuZGVycy5mb3JFYWNoKHBlZXJDb25uZWN0aW9uLmFkZERhdGFUcmFja1NlbmRlciwgcGVlckNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFUcmFja1NlbmRlcnMuZm9yRWFjaChwZWVyQ29ubmVjdGlvbi5hZGRNZWRpYVRyYWNrU2VuZGVyLCBwZWVyQ29ubmVjdGlvbik7XG4gICAgICAgICAgICB1cGRhdGVJY2VDb25uZWN0aW9uU3RhdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlZXJDb25uZWN0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgYWxsIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn1zIGluIHRoaXMge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0uXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2R1bW15QXVkaW9UcmFja1NlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5fZHVtbXlBdWRpb1RyYWNrU2VuZGVyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYXVkaW9Db250ZXh0RmFjdG9yeSkge1xuICAgICAgICAgICAgdGhpcy5fYXVkaW9Db250ZXh0RmFjdG9yeS5yZWxlYXNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUljZUNvbm5lY3Rpb25TdGF0ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9IG9uIHRoaXMge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0uXG4gICAgICogVGhlbiwgY3JlYXRlIGEgbmV3IG9mZmVyIHdpdGggdGhlIG5ld2x5LWNyZWF0ZWQge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dGhpcz59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVBbmRPZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvbmZpZ3VyYXRpb24oKS50aGVuKGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaWQ7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWQgPSB1dGlsLm1ha2VVVUlEKCk7XG4gICAgICAgICAgICB9IHdoaWxlIChfdGhpcy5fcGVlckNvbm5lY3Rpb25zLmhhcyhpZCkpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9nZXRPckNyZWF0ZShpZCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcGVlckNvbm5lY3Rpb24ub2ZmZXIoKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB7QGxpbmsgRGF0YVRyYWNrUmVjZWl2ZXJ9cyBhbmQge0BsaW5rIE1lZGlhVHJhY2tSZWNlaXZlcn1zIG9mIGFsbFxuICAgICAqIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn1zLlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxEYXRhVHJhY2tSZWNlaXZlcnxNZWRpYVRyYWNrUmVjZWl2ZXI+fSB0cmFja1JlY2VpdmVyc1xuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHJhY2tSZWNlaXZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmZsYXRNYXAodGhpcy5fcGVlckNvbm5lY3Rpb25zLCBmdW5jdGlvbiAocGVlckNvbm5lY3Rpb24pIHsgcmV0dXJuIHBlZXJDb25uZWN0aW9uLmdldFRyYWNrUmVjZWl2ZXJzKCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGF0ZXMgb2YgYWxsIHtAbGluayBQZWVyQ29ubmVjdGlvblYyfXMuXG4gICAgICogQHJldHVybnMge0FycmF5PG9iamVjdD59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRTdGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwZWVyQ29ubmVjdGlvblN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBwZWVyQ29ubmVjdGlvblN0YXRlID0gcGVlckNvbm5lY3Rpb24uZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChwZWVyQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25TdGF0ZXMucHVzaChwZWVyQ29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvblN0YXRlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0ncyBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRDb25maWd1cmF0aW9uID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZ3VyYXRpb25EZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwZWVyQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgdGhpcy5fY29uZmlndXJhdGlvbkRlZmVycmVkLnJlc29sdmUoY29uZmlndXJhdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBJQ0UgcmVjb25uZWN0IHRpbWVvdXQgcGVyaW9kIGZvciBhbGwge0BsaW5rIFBlZXJDb25uZWN0aW9uVjJ9cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGVyaW9kIC0gUGVyaW9kIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldEljZVJlY29ubmVjdFRpbWVvdXQgPSBmdW5jdGlvbiAocGVyaW9kKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXNzaW9uVGltZW91dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24uc2V0SWNlUmVjb25uZWN0VGltZW91dChwZXJpb2QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9zZXNzaW9uVGltZW91dCA9IHBlcmlvZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUge0BsaW5rIERhdGFUcmFja1NlbmRlcn1zIGFuZCB7QGxpbmsgTWVkaWFUcmFja1NlbmRlcn1zIG9uIHRoZVxuICAgICAqIHtAbGluayBQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9J3MgdW5kZXJseWluZyB7QGxpbmsgUGVlckNvbm5lY3Rpb25WMn1zLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8RGF0YVRyYWNrU2VuZGVyfE1lZGlhVHJhY2tTZW5kZXI+fSB0cmFja1NlbmRlcnNcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBQZWVyQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldFRyYWNrU2VuZGVycyA9IGZ1bmN0aW9uICh0cmFja1NlbmRlcnMpIHtcbiAgICAgICAgdmFyIGRhdGFUcmFja1NlbmRlcnMgPSBuZXcgU2V0KHRyYWNrU2VuZGVycy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrU2VuZGVyKSB7IHJldHVybiB0cmFja1NlbmRlci5raW5kID09PSAnZGF0YSc7IH0pKTtcbiAgICAgICAgdmFyIG1lZGlhVHJhY2tTZW5kZXJzID0gbmV3IFNldCh0cmFja1NlbmRlcnNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrU2VuZGVyKSB7IHJldHVybiB0cmFja1NlbmRlciAmJiAodHJhY2tTZW5kZXIua2luZCA9PT0gJ2F1ZGlvJyB8fCB0cmFja1NlbmRlci5raW5kID09PSAndmlkZW8nKTsgfSkpO1xuICAgICAgICB2YXIgY2hhbmdlcyA9IGdldFRyYWNrU2VuZGVyQ2hhbmdlcyh0aGlzLCBkYXRhVHJhY2tTZW5kZXJzLCBtZWRpYVRyYWNrU2VuZGVycyk7XG4gICAgICAgIHRoaXMuX2RhdGFUcmFja1NlbmRlcnMgPSBkYXRhVHJhY2tTZW5kZXJzO1xuICAgICAgICB0aGlzLl9tZWRpYVRyYWNrU2VuZGVycyA9IG1lZGlhVHJhY2tTZW5kZXJzO1xuICAgICAgICBhcHBseVRyYWNrU2VuZGVyQ2hhbmdlcyh0aGlzLCBjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHtAbGluayBQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gcGVlckNvbm5lY3Rpb25TdGF0ZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzeW5jZWQ9ZmFsc2VdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dGhpcz59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAocGVlckNvbm5lY3Rpb25TdGF0ZXMsIHN5bmNlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoc3luY2VkID09PSB2b2lkIDApIHsgc3luY2VkID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHN5bmNlZCkge1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VBYnNlbnRQZWVyQ29ubmVjdGlvbnMocGVlckNvbm5lY3Rpb25TdGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDb25maWd1cmF0aW9uKCkudGhlbihmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBlZXJDb25uZWN0aW9uU3RhdGVzLm1hcChmdW5jdGlvbiAocGVlckNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fY2xvc2VkUGVlckNvbm5lY3Rpb25JZHMuaGFzKHBlZXJDb25uZWN0aW9uU3RhdGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGVlckNvbm5lY3Rpb24gPSBfdGhpcy5fZ2V0T3JDcmVhdGUocGVlckNvbm5lY3Rpb25TdGF0ZS5pZCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlZXJDb25uZWN0aW9uLnVwZGF0ZShwZWVyQ29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25NYW5hZ2VyfSdzIG1lZGlhIHN0YXRpc3RpY3MuXG4gICAgICogQHJldHVybnMge1Byb21pc2UuPE1hcDxQZWVyQ29ubmVjdGlvblYyI2lkLCBTdGFuZGFyZGl6ZWRTdGF0c1Jlc3BvbnNlPj59XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBlZXJDb25uZWN0aW9ucyA9IEFycmF5LmZyb20odGhpcy5fcGVlckNvbm5lY3Rpb25zLnZhbHVlcygpKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBlZXJDb25uZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHBlZXJDb25uZWN0aW9uKSB7IHJldHVybiBwZWVyQ29ubmVjdGlvbi5nZXRTdGF0cygpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBbXG4gICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5pZCxcbiAgICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgIF07IH0pOyB9KSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VzKSB7IHJldHVybiBuZXcgTWFwKHJlc3BvbnNlcyk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFBlZXJDb25uZWN0aW9uTWFuYWdlcjtcbn0oUXVldWVpbmdFdmVudEVtaXR0ZXIpKTtcbi8qKlxuICogQ3JlYXRlIGEgZHVtbXkgYXVkaW8gTWVkaWFTdHJlYW1UcmFjayB3aXRoIHRoZSBnaXZlbiBBdWRpb0NvbnRleHQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGF1ZGlvQ29udGV4dFxuICogQHJldHVybiB7TWVkaWFTdHJlYW1UcmFja31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRHVtbXlBdWRpb01lZGlhU3RyZWFtVHJhY2soYXVkaW9Db250ZXh0KSB7XG4gICAgdmFyIG1lZGlhU3RyZWFtRGVzdGluYXRpb24gPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpO1xuICAgIHJldHVybiBtZWRpYVN0cmVhbURlc3RpbmF0aW9uLnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdO1xufVxuLyoqXG4gKiBAZXZlbnQge1BlZXJDb25uZWN0aW9uTWFuYWdlciNjYW5kaWRhdGVzfVxuICogQHBhcmFtIHtvYmplY3R9IGNhbmRpZGF0ZXNcbiAqL1xuLyoqXG4gKiBAZXZlbnQge1BlZXJDb25uZWN0aW9uTWFuYWdlciNjb25uZWN0aW9uU3RhdGVDaGFuZ2VkfVxuICovXG4vKipcbiAqIEBldmVudCB7UGVlckNvbm5lY3Rpb25NYW5hZ2VyI2Rlc2NyaXB0aW9ufVxuICogQHBhcmFtIHtvYmplY3R9IGRlc2NyaXB0aW9uXG4gKi9cbi8qKlxuICogQGV2ZW50IHtQZWVyQ29ubmVjdGlvbk1hbmFnZXIjaWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlZH1cbiAqL1xuLyoqXG4gKiBAZXZlbnQge1BlZXJDb25uZWN0aW9uTWFuYWdlciN0cmFja0FkZGVkfVxuICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfERhdGFUcmFja1JlY2VpdmVyfSBtZWRpYVN0cmVhbVRyYWNrT3JEYXRhVHJhY2tSZWNlaXZlclxuICovXG4vKipcbiAqIEFwcGx5IHtAbGluayBUcmFja1NlbmRlckNoYW5nZXN9LlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9IHBlZXJDb25uZWN0aW9uTWFuYWdlclxuICogQHBhcmFtIHtUcmFja1NlbmRlckNoYW5nZXN9IGNoYW5nZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBhcHBseVRyYWNrU2VuZGVyQ2hhbmdlcyhwZWVyQ29ubmVjdGlvbk1hbmFnZXIsIGNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcy5kYXRhLmFkZC5zaXplXG4gICAgICAgIHx8IGNoYW5nZXMuZGF0YS5yZW1vdmUuc2l6ZVxuICAgICAgICB8fCBjaGFuZ2VzLm1lZGlhLmFkZC5zaXplXG4gICAgICAgIHx8IGNoYW5nZXMubWVkaWEucmVtb3ZlLnNpemUpIHtcbiAgICAgICAgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLl9wZWVyQ29ubmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIGNoYW5nZXMuZGF0YS5yZW1vdmUuZm9yRWFjaChwZWVyQ29ubmVjdGlvbi5yZW1vdmVEYXRhVHJhY2tTZW5kZXIsIHBlZXJDb25uZWN0aW9uKTtcbiAgICAgICAgICAgIGNoYW5nZXMubWVkaWEucmVtb3ZlLmZvckVhY2gocGVlckNvbm5lY3Rpb24ucmVtb3ZlTWVkaWFUcmFja1NlbmRlciwgcGVlckNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgY2hhbmdlcy5kYXRhLmFkZC5mb3JFYWNoKHBlZXJDb25uZWN0aW9uLmFkZERhdGFUcmFja1NlbmRlciwgcGVlckNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgY2hhbmdlcy5tZWRpYS5hZGQuZm9yRWFjaChwZWVyQ29ubmVjdGlvbi5hZGRNZWRpYVRyYWNrU2VuZGVyLCBwZWVyQ29ubmVjdGlvbik7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5tZWRpYS5hZGQuc2l6ZVxuICAgICAgICAgICAgICAgIHx8IGNoYW5nZXMubWVkaWEucmVtb3ZlLnNpemVcbiAgICAgICAgICAgICAgICB8fCAoY2hhbmdlcy5kYXRhLmFkZC5zaXplICYmICFwZWVyQ29ubmVjdGlvbi5pc0FwcGxpY2F0aW9uU2VjdGlvbk5lZ290aWF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24ub2ZmZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJmYWNlIERhdGFUcmFja1NlbmRlckNoYW5nZXNcbiAqIEBwcm9wZXJ0eSB7U2V0PERhdGFUcmFja1NlbmRlcj59IGFkZFxuICogQHByb3BlcnR5IHtTZXQ8RGF0YVRyYWNrU2VuZGVyPn0gcmVtb3ZlXG4gKi9cbi8qKlxuICogR2V0IHRoZSB7QExpbmsgRGF0YVRyYWNrU2VuZGVyfSBjaGFuZ2VzLlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9IHBlZXJDb25uZWN0aW9uTWFuYWdlclxuICogQHBhcmFtIHtBcnJheTxEYXRhVHJhY2tTZW5kZXI+fSBkYXRhVHJhY2tTZW5kZXJzXG4gKiBAcmV0dXJucyB7RGF0YVRyYWNrU2VuZGVyQ2hhbmdlc30gY2hhbmdlc1xuICovXG5mdW5jdGlvbiBnZXREYXRhVHJhY2tTZW5kZXJDaGFuZ2VzKHBlZXJDb25uZWN0aW9uTWFuYWdlciwgZGF0YVRyYWNrU2VuZGVycykge1xuICAgIHZhciBkYXRhVHJhY2tTZW5kZXJzVG9BZGQgPSB1dGlsLmRpZmZlcmVuY2UoZGF0YVRyYWNrU2VuZGVycywgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLl9kYXRhVHJhY2tTZW5kZXJzKTtcbiAgICB2YXIgZGF0YVRyYWNrU2VuZGVyc1RvUmVtb3ZlID0gdXRpbC5kaWZmZXJlbmNlKHBlZXJDb25uZWN0aW9uTWFuYWdlci5fZGF0YVRyYWNrU2VuZGVycywgZGF0YVRyYWNrU2VuZGVycyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiBkYXRhVHJhY2tTZW5kZXJzVG9BZGQsXG4gICAgICAgIHJlbW92ZTogZGF0YVRyYWNrU2VuZGVyc1RvUmVtb3ZlXG4gICAgfTtcbn1cbi8qKlxuICogQGludGVyZmFjZSBUcmFja1NlbmRlckNoYW5nZXNcbiAqIEBwcm9wZXJ0eSB7RGF0YVRyYWNrU2VuZGVyQ2hhbmdlc30gZGF0YVxuICogQHByb3BlcnR5IHtNZWRpYVRyYWNrU2VuZGVyQ2hhbmdlc30gbWVkaWFcbiAqL1xuLyoqXG4gKiBHZXQge0BsaW5rIERhdGFUcmFja1NlbmRlcn0gYW5kIHtAbGluayBNZWRpYVRyYWNrU2VuZGVyfSBjaGFuZ2VzLlxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9IHBlZXJDb25uZWN0aW9uTWFuYWdlclxuICogQHBhcmFtIHtBcnJheTxEYXRhVHJhY2tTZW5kZXI+fSBkYXRhVHJhY2tTZW5kZXJzXG4gKiBAcGFyYW0ge0FycmF5PE1lZGlhVHJhY2tTZW5kZXI+fSBtZWRpYVRyYWNrU2VuZGVyc1xuICogQHJldHVybnMge1RyYWNrU2VuZGVyQ2hhbmdlc30gY2hhbmdlc1xuICovXG5mdW5jdGlvbiBnZXRUcmFja1NlbmRlckNoYW5nZXMocGVlckNvbm5lY3Rpb25NYW5hZ2VyLCBkYXRhVHJhY2tTZW5kZXJzLCBtZWRpYVRyYWNrU2VuZGVycykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGdldERhdGFUcmFja1NlbmRlckNoYW5nZXMocGVlckNvbm5lY3Rpb25NYW5hZ2VyLCBkYXRhVHJhY2tTZW5kZXJzKSxcbiAgICAgICAgbWVkaWE6IGdldE1lZGlhVHJhY2tTZW5kZXJDaGFuZ2VzKHBlZXJDb25uZWN0aW9uTWFuYWdlciwgbWVkaWFUcmFja1NlbmRlcnMpXG4gICAgfTtcbn1cbi8qKlxuICogQGludGVyZmFjZSBNZWRpYVRyYWNrU2VuZGVyQ2hhbmdlc1xuICogQHByb3BlcnR5IHtTZXQ8TWVkaWFUcmFja1NlbmRlcj59IGFkZFxuICogQHByb3BlcnR5IHtTZXQ8TWVkaWFUcmFja1NlbmRlcj59IHJlbW92ZVxuICovXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIE1lZGlhVHJhY2tTZW5kZXJ9IGNoYW5nZXMuXG4gKiBAcGFyYW0ge1BlZXJDb25uZWN0aW9uTWFuYWdlcn0gcGVlckNvbm5lY3Rpb25NYW5hZ2VyXG4gKiBAcGFyYW0ge0FycmF5PE1lZGlhVHJhY2tTZW5kZXI+fSBtZWRpYVRyYWNrU2VuZGVyc1xuICogQHJldHVybnMge01lZGlhVHJhY2tTZW5kZXJDaGFuZ2VzfSBjaGFuZ2VzXG4gKi9cbmZ1bmN0aW9uIGdldE1lZGlhVHJhY2tTZW5kZXJDaGFuZ2VzKHBlZXJDb25uZWN0aW9uTWFuYWdlciwgbWVkaWFUcmFja1NlbmRlcnMpIHtcbiAgICB2YXIgbWVkaWFUcmFja1NlbmRlcnNUb0FkZCA9IHV0aWwuZGlmZmVyZW5jZShtZWRpYVRyYWNrU2VuZGVycywgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLl9tZWRpYVRyYWNrU2VuZGVycyk7XG4gICAgdmFyIG1lZGlhVHJhY2tTZW5kZXJzVG9SZW1vdmUgPSB1dGlsLmRpZmZlcmVuY2UocGVlckNvbm5lY3Rpb25NYW5hZ2VyLl9tZWRpYVRyYWNrU2VuZGVycywgbWVkaWFUcmFja1NlbmRlcnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogbWVkaWFUcmFja1NlbmRlcnNUb0FkZCxcbiAgICAgICAgcmVtb3ZlOiBtZWRpYVRyYWNrU2VuZGVyc1RvUmVtb3ZlXG4gICAgfTtcbn1cbi8qKlxuICogVGhpcyBvYmplY3QgbWFwcyBSVENJY2VDb25uZWN0aW9uU3RhdGUgYW5kIFJUQ1BlZXJDb25uZWN0aW9uU3RhdGUgdmFsdWVzIHRvIGEgXCJyYW5rXCIuXG4gKi9cbnZhciB0b1JhbmsgPSB7XG4gICAgbmV3OiAwLFxuICAgIGNoZWNraW5nOiAxLFxuICAgIGNvbm5lY3Rpbmc6IDIsXG4gICAgY29ubmVjdGVkOiAzLFxuICAgIGNvbXBsZXRlZDogNCxcbiAgICBkaXNjb25uZWN0ZWQ6IC0xLFxuICAgIGZhaWxlZDogLTIsXG4gICAgY2xvc2VkOiAtM1xufTtcbi8qKlxuICogVGhpcyBvYmplY3QgbWFwcyBcInJhbmtcIiBiYWNrIHRvIFJUQ0ljZUNvbm5lY3Rpb25TdGF0ZSBvciBSVENQZWVyQ29ubmVjdGlvblN0YXRlIHZhbHVlcy5cbiAqL1xudmFyIGZyb21SYW5rO1xuLyoqXG4gKiBgT2JqZWN0LmtleXNgIGlzIG5vdCBzdXBwb3J0ZWQgaW4gb2xkZXIgYnJvd3NlcnMsIHNvIHdlIGNhbid0IGp1c3RcbiAqIHN5bmNocm9ub3VzbHkgY2FsbCBpdCBpbiB0aGlzIG1vZHVsZTsgd2UgbmVlZCB0byBkZWZlciBpbnZva2luZyBpdCB1bnRpbCB3ZVxuICoga25vdyB3ZSdyZSBpbiBhIG1vZGVybiBlbnZpcm9ubWVudCAoaS5lLiwgYW55dGhpbmcgdGhhdCBzdXBwb3J0cyBXZWJSVEMpLlxuICogQHJldHVybnMge29iamVjdH0gZnJvbVJhbmtcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRnJvbVJhbmsoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRvUmFuaykucmVkdWNlKGZ1bmN0aW9uIChmcm9tUmFuaywgc3RhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihmcm9tUmFuaywgKF9hID0ge30sIF9hW3RvUmFua1tzdGF0ZV1dID0gc3RhdGUsIF9hKSk7XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiBTdW1tYXJpemUgUlRDSWNlQ29ubmVjdGlvblN0YXRlcyBvciBSVENQZWVyQ29ubmVjdGlvblN0YXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8UlRDSWNlQ29ubmVjdGlvblN0YXRlPnxBcnJheTxSVENQZWVyQ29ubmVjdGlvblN0YXRlPn0gc3RhdGVzXG4gKiBAcmV0dXJucyB7UlRDSWNlQ29ubmVjdGlvblN0YXRlfFJUQ1BlZXJDb25uZWN0aW9uU3RhdGV9IHN1bW1hcnlcbiAqL1xuZnVuY3Rpb24gc3VtbWFyaXplSWNlT3JQZWVyQ29ubmVjdGlvblN0YXRlcyhzdGF0ZXMpIHtcbiAgICBpZiAoIXN0YXRlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICduZXcnO1xuICAgIH1cbiAgICBmcm9tUmFuayA9IGZyb21SYW5rIHx8IGNyZWF0ZUZyb21SYW5rKCk7XG4gICAgcmV0dXJuIHN0YXRlcy5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlMSwgc3RhdGUyKSB7XG4gICAgICAgIHJldHVybiBmcm9tUmFua1tNYXRoLm1heCh0b1Jhbmtbc3RhdGUxXSwgdG9SYW5rW3N0YXRlMl0pXTtcbiAgICB9KTtcbn1cbi8qKlxuICogVXBkYXRlIHRoZSB7QGxpbmsgUGVlckNvbm5lY3Rpb25NYW5hZ2VyfSdzIGBpY2VDb25uZWN0aW9uU3RhdGVgLCBhbmQgZW1pdCBhblxuICogXCJpY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkXCIgZXZlbnQsIGlmIG5lY2Vzc2FyeS5cbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25NYW5hZ2VyfSBwY21cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGVJY2VDb25uZWN0aW9uU3RhdGUocGNtKSB7XG4gICAgcGNtLl9sYXN0SWNlQ29ubmVjdGlvblN0YXRlID0gcGNtLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICBwY20uX2ljZUNvbm5lY3Rpb25TdGF0ZSA9IHN1bW1hcml6ZUljZU9yUGVlckNvbm5lY3Rpb25TdGF0ZXMoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHBjbS5fcGVlckNvbm5lY3Rpb25zLnZhbHVlcygpKSkubWFwKGZ1bmN0aW9uIChwY3YyKSB7IHJldHVybiBwY3YyLmljZUNvbm5lY3Rpb25TdGF0ZTsgfSkpO1xuICAgIGlmIChwY20uaWNlQ29ubmVjdGlvblN0YXRlICE9PSBwY20uX2xhc3RJY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgcGNtLmVtaXQoJ2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnKTtcbiAgICB9XG59XG4vKipcbiAqIFVwZGF0ZSB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uTWFuYWdlcn0ncyBgY29ubmVjdGlvblN0YXRlYCwgYW5kIGVtaXQgYVxuICogXCJjb25uZWN0aW9uU3RhdGVDaGFuZ2VkXCIgZXZlbnQsIGlmIG5lY2Vzc2FyeS5cbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25NYW5hZ2VyfSBwY21cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGVDb25uZWN0aW9uU3RhdGUocGNtKSB7XG4gICAgcGNtLl9sYXN0Q29ubmVjdGlvblN0YXRlID0gcGNtLmNvbm5lY3Rpb25TdGF0ZTtcbiAgICBwY20uX2Nvbm5lY3Rpb25TdGF0ZSA9IHN1bW1hcml6ZUljZU9yUGVlckNvbm5lY3Rpb25TdGF0ZXMoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHBjbS5fcGVlckNvbm5lY3Rpb25zLnZhbHVlcygpKSkubWFwKGZ1bmN0aW9uIChwY3YyKSB7IHJldHVybiBwY3YyLmNvbm5lY3Rpb25TdGF0ZTsgfSkpO1xuICAgIGlmIChwY20uY29ubmVjdGlvblN0YXRlICE9PSBwY20uX2xhc3RDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgcGNtLmVtaXQoJ2Nvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnKTtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFBlZXJDb25uZWN0aW9uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlZXJjb25uZWN0aW9ubWFuYWdlci5qcy5tYXAiLCIvKiBlc2xpbnQgY2FsbGJhY2stcmV0dXJuOjAgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTWVkaWFTaWduYWxpbmcgPSByZXF1aXJlKCcuL21lZGlhc2lnbmFsaW5nJyk7XG52YXIgUHVibGlzaGVySGludHNTaWduYWxpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFB1Ymxpc2hlckhpbnRzU2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSZW5kZXJIaW50c1NpZ25hbGluZ30uXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHVibGlzaGVySGludHNTaWduYWxpbmcoZ2V0UmVjZWl2ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ2V0UmVjZWl2ZXIsICdwdWJsaXNoZXJfaGludHMnLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vbigncmVhZHknLCBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBfdGhpcy5fbG9nLmluZm8oJ3B1Ymxpc2hlcl9oaW50cyB0cmFuc3BvcnQgcmVhZHk6ICcsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoJ3B1Ymxpc2hlcl9oaW50cyBJbmNvbWluZzogJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVibGlzaGVyX2hpbnRzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnB1Ymxpc2hlciAmJiBtZXNzYWdlLnB1Ymxpc2hlci5oaW50cyAmJiBtZXNzYWdlLnB1Ymxpc2hlci5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcm9jZXNzUHVibGlzaGVySGludHMobWVzc2FnZS5wdWJsaXNoZXIuaGludHMsIG1lc3NhZ2UucHVibGlzaGVyLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy53YXJuKCdVbmtub3duIG1lc3NhZ2UgdHlwZTogJywgbWVzc2FnZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyB7XG4gICAgLy8gICBcInB1Ymxpc2hlclwiOiB7XG4gICAgLy8gICAgIFwiaGludHNcIjogW1xuICAgIC8vICAgICAgIHtcbiAgICAvLyAgICAgICAgIFwiZW5jb2RpbmdzXCI6IFtcbiAgICAvLyAgICAgICAgICAge1xuICAgIC8vICAgICAgICAgICAgIFwiZW5hYmxlZFwiOiB0cnVlLFxuICAgIC8vICAgICAgICAgICAgIFwibGF5ZXJfaW5kZXhcIjogMCxcbiAgICAvLyAgICAgICAgICAgICBcIm1heF9iaXRyYXRlXCI6IDUwMDAwMCxcbiAgICAvLyAgICAgICAgICAgICBcIm1heF9mcmFtZXJhdGVcIjogNSxcbiAgICAvLyAgICAgICAgICAgICBcInJlbmRlcl9kaW1lbnNpb25zXCI6IHtcbiAgICAvLyAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IDE4MCxcbiAgICAvLyAgICAgICAgICAgICAgIFwid2lkdGhcIjogMzIwXG4gICAgLy8gICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICB9LFxuICAgIC8vICAgICAgICAgICB7XG4gICAgLy8gICAgICAgICAgICAgXCJlbmFibGVkXCI6IGZhbHNlLFxuICAgIC8vICAgICAgICAgICAgIFwibGF5ZXJfaW5kZXhcIjogMVxuICAgIC8vICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICBdLFxuICAgIC8vICAgICAgICAgXCJ0cmFja1wiOiBcIk1UMTIzXCJcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgIF0sXG4gICAgLy8gICAgIFwiaWRcIjogMTIzXG4gICAgLy8gICB9LFxuICAgIC8vICAgXCJ0eXBlXCI6IFwicHVibGlzaGVyX2hpbnRzXCJcbiAgICAvLyB9XG4gICAgUHVibGlzaGVySGludHNTaWduYWxpbmcucHJvdG90eXBlLl9wcm9jZXNzUHVibGlzaGVySGludHMgPSBmdW5jdGlvbiAoaGludHMsIGlkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoaW50UmVzcG9uc2VzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChoaW50KSB7XG4gICAgICAgICAgICAgICAgaGludFJlc3BvbnNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2s6IGhpbnQudHJhY2ssXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogJ09LJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhpbnQuZW5jb2RpbmdzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmFibGVkID0gX2EuZW5hYmxlZCwgbGF5ZXJJbmRleCA9IF9hLmxheWVyX2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKGhpbnQudHJhY2sgKyBcIiBsYXllcjpcIiArIGxheWVySW5kZXggKyBcIiwgZW5hYmxlZDpcIiArIGVuYWJsZWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZWQnLCBoaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoJ2Vycm9yIHByb2Nlc3NpbmcgaGludHM6JywgZXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICBcInR5cGVcIjogXCJwdWJsaXNoZXJfaGludHNcIixcbiAgICAgICAgLy8gICBcInB1Ymxpc2hlclwiOiB7XG4gICAgICAgIC8vICAgICBcImhpbnRzXCI6IFtcbiAgICAgICAgLy8gICAgICAge1xuICAgICAgICAvLyAgICAgICAgIFwidHJhY2tcIjogXCJNVDEyM1wiLFxuICAgICAgICAvLyAgICAgICAgIFwicmVzdWx0XCI6IFwiT0tcIlxuICAgICAgICAvLyAgICAgICB9LFxuICAgICAgICAvLyAgICAgICB7XG4gICAgICAgIC8vICAgICAgICAgXCJ0cmFja1wiOiBcIk1UNDU2XCIsXG4gICAgICAgIC8vICAgICAgICAgXCJyZXN1bHRcIjogXCJJTlZBTElEX1BVQkxJU0hFUl9ISU5UXCJcbiAgICAgICAgLy8gICAgICAgfSxcbiAgICAgICAgLy8gICAgICAge1xuICAgICAgICAvLyAgICAgICAgIFwidHJhY2tcIjogXCJNVDc4OVwiLFxuICAgICAgICAvLyAgICAgICAgIFwicmVzdWx0XCI6IFwiVU5LTk9XTl9UUkFDS1wiXG4gICAgICAgIC8vICAgICAgIH1cbiAgICAgICAgLy8gICAgIF0sXG4gICAgICAgIC8vICAgICBcImlkXCI6IDEyM1xuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICB2YXIgcGF5TG9hZCA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdwdWJsaXNoZXJfaGludHMnLFxuICAgICAgICAgICAgcHVibGlzaGVyOiB7IGlkOiBpZCwgaGludHM6IGhpbnRzIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnB1Ymxpc2gocGF5TG9hZCk7XG4gICAgfTtcbiAgICByZXR1cm4gUHVibGlzaGVySGludHNTaWduYWxpbmc7XG59KE1lZGlhU2lnbmFsaW5nKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFB1Ymxpc2hlckhpbnRzU2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaGVyaGludHNpZ25hbGluZy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFJlY29yZGluZ1NpZ25hbGluZyA9IHJlcXVpcmUoJy4uL3JlY29yZGluZycpO1xuLyoqXG4gKiBAZXh0ZW5kcyBSZWNvcmRpbmdTaWduYWxpbmdcbiAqL1xudmFyIFJlY29yZGluZ1YyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWNvcmRpbmdWMiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUmVjb3JkaW5nVjJ9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlY29yZGluZ1YyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgX3JldmlzaW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IDEsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0aGUge0BsaW5rIFJlY29yZGluZ1YyfSB0byBhIHtAbGluayBSZWNvcmRpbmdWMiNSZXByZXNlbnRhdGlvbn1cbiAgICAgKiBvZiBpdHNlbGYgYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgbmVjZXNzYXJ5LlxuICAgICAqIEBwYXJhbSB7UmVjb3JkaW5nVjIjUmVwcmVzZW50YXRpb259IHJlY29yZGluZ1xuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBmaXJlcyBSZWNvcmRpbmdTaWduYWxpbmcjdXBkYXRlZFxuICAgICAqL1xuICAgIFJlY29yZGluZ1YyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAocmVjb3JkaW5nKSB7XG4gICAgICAgIGlmIChyZWNvcmRpbmcucmV2aXNpb24gPCB0aGlzLl9yZXZpc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmV2aXNpb24gPSByZWNvcmRpbmcucmV2aXNpb247XG4gICAgICAgIHJldHVybiB0aGlzLmVuYWJsZShyZWNvcmRpbmcuaXNfcmVjb3JkaW5nKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWNvcmRpbmdWMjtcbn0oUmVjb3JkaW5nU2lnbmFsaW5nKSk7XG4vKipcbiAqIFRoZSBSb29tIFNpZ25hbGluZyBQcm90b2NvbCAoUlNQKSByZXByZXNlbnRhdGlvbiBvZiBhIHtAbGluayBSZWNvcmRpbmdWMn1cbiAqIEB0eXBlZGVmIHtvYmplY3R9IFJlY29yZGluZ1YyI1JlcHJlc2VudGF0aW9uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVuYWJsZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXZpc2lvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlY29yZGluZ1YyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjb3JkaW5nLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgUmVtb3RlUGFydGljaXBhbnRTaWduYWxpbmcgPSByZXF1aXJlKCcuLi9yZW1vdGVwYXJ0aWNpcGFudCcpO1xudmFyIFJlbW90ZVRyYWNrUHVibGljYXRpb25WMiA9IHJlcXVpcmUoJy4vcmVtb3RldHJhY2twdWJsaWNhdGlvbicpO1xuLyoqXG4gKiBAZXh0ZW5kcyBSZW1vdGVQYXJ0aWNpcGFudFNpZ25hbGluZ1xuICogQHByb3BlcnR5IHs/bnVtYmVyfSByZXZpc2lvblxuICovXG52YXIgUmVtb3RlUGFydGljaXBhbnRWMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVtb3RlUGFydGljaXBhbnRWMiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUmVtb3RlUGFydGljaXBhbnRWMn0uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpY2lwYW50U3RhdGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFRyYWNrLlNJRCk6IGJvb2xlYW59IGdldEluaXRpYWxUcmFja1N3aXRjaE9mZlN0YXRlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihUcmFjay5TSUQsIFRyYWNrLlByaW9yaXR5KTogYm9vbGVhbn0gc2V0UHJpb3JpdHlcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFRyYWNrLlNJRCwgQ2xpZW50UmVuZGVySGludCk6IFByb21pc2U8dm9pZD59IHNldFJlbmRlckhpbnRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFRyYWNrLlNJRCk6IHZvaWR9IGNsZWFyVHJhY2tIaW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbW90ZVBhcnRpY2lwYW50VjIocGFydGljaXBhbnRTdGF0ZSwgZ2V0SW5pdGlhbFRyYWNrU3dpdGNoT2ZmU3RhdGUsIHNldFByaW9yaXR5LCBzZXRSZW5kZXJIaW50LCBjbGVhclRyYWNrSGludCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJ0aWNpcGFudFN0YXRlLnNpZCwgcGFydGljaXBhbnRTdGF0ZS5pZGVudGl0eSkgfHwgdGhpcztcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYyOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjJcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfcmV2aXNpb246IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9SZW1vdGVUcmFja1B1YmxpY2F0aW9uVjI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5SZW1vdGVUcmFja1B1YmxpY2F0aW9uVjJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0SW5pdGlhbFRyYWNrU3dpdGNoT2ZmU3RhdGU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0SW5pdGlhbFRyYWNrU3dpdGNoT2ZmU3RhdGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVTdWJzY3JpYmVyVHJhY2tQcmlvcml0eToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodHJhY2tTaWQsIHByaW9yaXR5KSB7IHJldHVybiBzZXRQcmlvcml0eSh0cmFja1NpZCwgcHJpb3JpdHkpOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlVHJhY2tSZW5kZXJIaW50OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0cmFja1NpZCwgcmVuZGVySGludCkgeyByZXR1cm4gc2V0UmVuZGVySGludCh0cmFja1NpZCwgcmVuZGVySGludCk7IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhclRyYWNrSGludDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodHJhY2tTaWQpIHsgcmV0dXJuIGNsZWFyVHJhY2tIaW50KHRyYWNrU2lkKTsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldmlzaW9uOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldmlzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcy51cGRhdGUocGFydGljaXBhbnRTdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVtb3RlUGFydGljaXBhbnRWMi5wcm90b3R5cGUuX2dldE9yQ3JlYXRlVHJhY2sgPSBmdW5jdGlvbiAodHJhY2tTdGF0ZSkge1xuICAgICAgICB2YXIgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYyID0gdGhpcy5fUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYyO1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrcy5nZXQodHJhY2tTdGF0ZS5zaWQpO1xuICAgICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNTd2l0Y2hlZE9mZiA9IHRoaXMuX2dldEluaXRpYWxUcmFja1N3aXRjaE9mZlN0YXRlKHRyYWNrU3RhdGUuc2lkKTtcbiAgICAgICAgICAgIHRyYWNrID0gbmV3IFJlbW90ZVRyYWNrUHVibGljYXRpb25WMih0cmFja1N0YXRlLCBpc1N3aXRjaGVkT2ZmKTtcbiAgICAgICAgICAgIHRoaXMuYWRkVHJhY2sodHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFjaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUge0BsaW5rIFJlbW90ZVBhcnRpY2lwYW50VjJ9IHdpdGggdGhlIG5ldyBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGljaXBhbnRTdGF0ZVxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIFJlbW90ZVBhcnRpY2lwYW50VjIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWNpcGFudFN0YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnJldmlzaW9uICE9PSBudWxsICYmIHBhcnRpY2lwYW50U3RhdGUucmV2aXNpb24gPD0gdGhpcy5yZXZpc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmV2aXNpb24gPSBwYXJ0aWNpcGFudFN0YXRlLnJldmlzaW9uO1xuICAgICAgICB2YXIgdHJhY2tzVG9LZWVwID0gbmV3IFNldCgpO1xuICAgICAgICBwYXJ0aWNpcGFudFN0YXRlLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja1N0YXRlKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSBfdGhpcy5fZ2V0T3JDcmVhdGVUcmFjayh0cmFja1N0YXRlKTtcbiAgICAgICAgICAgIHRyYWNrLnVwZGF0ZSh0cmFja1N0YXRlKTtcbiAgICAgICAgICAgIHRyYWNrc1RvS2VlcC5hZGQodHJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgIGlmICghdHJhY2tzVG9LZWVwLmhhcyh0cmFjaykpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzd2l0Y2ggKHBhcnRpY2lwYW50U3RhdGUuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZWNvbm5lY3RpbmcnOlxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0aW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLnNpZCwgdGhpcy5pZGVudGl0eSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gUmVtb3RlUGFydGljaXBhbnRWMjtcbn0oUmVtb3RlUGFydGljaXBhbnRTaWduYWxpbmcpKTtcbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlUGFydGljaXBhbnRWMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW90ZXBhcnRpY2lwYW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZyA9IHJlcXVpcmUoJy4uL3JlbW90ZXRyYWNrcHVibGljYXRpb24nKTtcbi8qKlxuICogQGV4dGVuZHMgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZ1xuICovXG52YXIgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFJlbW90ZVRyYWNrUHVibGljYXRpb25WMn0uXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjIjUmVwcmVzZW50YXRpb259IHRyYWNrXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1N3aXRjaGVkT2ZmXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjIodHJhY2ssIGlzU3dpdGNoZWRPZmYpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRyYWNrLnNpZCwgdHJhY2submFtZSwgdHJhY2sua2luZCwgdHJhY2suZW5hYmxlZCwgdHJhY2sucHJpb3JpdHksIGlzU3dpdGNoZWRPZmYpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdGhlIHtAbGluayBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjJ9IHRvIGFcbiAgICAgKiB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYyI1JlcHJlc2VudGF0aW9ufSBvZiBpdHNlbGYgYW5kIHBlcmZvcm0gYW55XG4gICAgICogdXBkYXRlcyBuZWNlc3NhcnkuXG4gICAgICogQHBhcmFtIHtSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjIjUmVwcmVzZW50YXRpb259IHRyYWNrXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICogQGZpcmVzIFRyYWNrU2lnbmFsaW5nI3VwZGF0ZWRcbiAgICAgKi9cbiAgICBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB0aGlzLmVuYWJsZSh0cmFjay5lbmFibGVkKTtcbiAgICAgICAgdGhpcy5zZXRQcmlvcml0eSh0cmFjay5wcmlvcml0eSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbW90ZVRyYWNrUHVibGljYXRpb25WMjtcbn0oUmVtb3RlVHJhY2tQdWJsaWNhdGlvblNpZ25hbGluZykpO1xuLyoqXG4gKiBUaGUgUm9vbSBTaWduYWxpbmcgUHJvdG9jb2wgKFJTUCkgcmVwcmVzZW50YXRpb24gb2YgYSB7QGxpbmsgUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYyfS5cbiAqIEB0eXBlZGVmIHtMb2NhbFRyYWNrUHVibGljYXRpb25WMiNSZXByZXNlbnRhdGlvbn0gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblYyI1JlcHJlc2VudGF0aW9uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHN1YnNjcmliZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZW1vdGVUcmFja1B1YmxpY2F0aW9uVjI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdGV0cmFja3B1YmxpY2F0aW9uLmpzLm1hcCIsIi8qIGVzbGludCBjYWxsYmFjay1yZXR1cm46MCAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBNZWRpYVNpZ25hbGluZyA9IHJlcXVpcmUoJy4vbWVkaWFzaWduYWxpbmcnKTtcbnZhciBpc0RlZXBFcXVhbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKS5pc0RlZXBFcXVhbDtcbnZhciBtZXNzYWdlSWQgPSAxO1xudmFyIFJlbmRlckhpbnRzU2lnbmFsaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJIaW50c1NpZ25hbGluZywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUmVuZGVySGludHNTaWduYWxpbmd9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbmRlckhpbnRzU2lnbmFsaW5nKGdldFJlY2VpdmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdldFJlY2VpdmVyLCAncmVuZGVyX2hpbnRzJywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF90cmFja1NpZHNUb1JlbmRlckhpbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pc1Jlc3BvbnNlUGVuZGluZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uKCdyZWFkeScsIGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZygnSW5jb21pbmc6ICcsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlbmRlcl9oaW50cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvY2Vzc0hpbnRSZXN1bHRzKChtZXNzYWdlICYmIG1lc3NhZ2Uuc3Vic2NyaWJlciAmJiBtZXNzYWdlLnN1YnNjcmliZXIuaGludHMpIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy53YXJuKCdVbmtub3duIG1lc3NhZ2UgdHlwZTogJywgbWVzc2FnZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbik6IFdoZW4gdHJhbnNwb3J0IGlzIHNldCAoZWl0aGVyIDFzdCB0aW1lIG9mIGFmdGVyIHZtcyBmYWlsb3ZlcilcbiAgICAgICAgICAgIC8vIHJlc2VuZCBhbGwgdHJhY2sgc3RhdGVzLiBGb3IgdGhpcyBzaW1wbHkgbWFyayBhbGwgdHJhY2tzIGFzIGRpcnR5LlxuICAgICAgICAgICAgQXJyYXkuZnJvbShfdGhpcy5fdHJhY2tTaWRzVG9SZW5kZXJIaW50cy5rZXlzKCkpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrU2lkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrU3RhdGUgPSBfdGhpcy5fdHJhY2tTaWRzVG9SZW5kZXJIaW50cy5nZXQodHJhY2tTaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja1N0YXRlLnJlbmRlckRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tTdGF0ZS5pc0RpbWVuc2lvbkRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCdlbmFibGVkJyBpbiB0cmFja1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrU3RhdGUuaXNFbmFibGVkRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuX3NlbmRIaW50cygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZW5kZXJIaW50c1NpZ25hbGluZy5wcm90b3R5cGUuX3Byb2Nlc3NIaW50UmVzdWx0cyA9IGZ1bmN0aW9uIChoaW50UmVzdWx0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9pc1Jlc3BvbnNlUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICBoaW50UmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChoaW50UmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoaGludFJlc3VsdC5yZXN1bHQgIT09ICdPSycpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKCdTZXJ2ZXIgZXJyb3IgcHJvY2Vzc2luZyBoaW50OicsIGhpbnRSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZEhpbnRzKCk7XG4gICAgfTtcbiAgICBSZW5kZXJIaW50c1NpZ25hbGluZy5wcm90b3R5cGUuX3NlbmRIaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnQgfHwgdGhpcy5faXNSZXNwb25zZVBlbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGludHMgPSBbXTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl90cmFja1NpZHNUb1JlbmRlckhpbnRzLmtleXMoKSkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tTaWQpIHtcbiAgICAgICAgICAgIHZhciB0cmFja1N0YXRlID0gX3RoaXMuX3RyYWNrU2lkc1RvUmVuZGVySGludHMuZ2V0KHRyYWNrU2lkKTtcbiAgICAgICAgICAgIGlmICh0cmFja1N0YXRlLmlzRW5hYmxlZERpcnR5IHx8IHRyYWNrU3RhdGUuaXNEaW1lbnNpb25EaXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBtc3BIaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAndHJhY2snOiB0cmFja1NpZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0cmFja1N0YXRlLmlzRW5hYmxlZERpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1zcEhpbnQuZW5hYmxlZCA9IHRyYWNrU3RhdGUuZW5hYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tTdGF0ZS5pc0VuYWJsZWREaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJhY2tTdGF0ZS5pc0RpbWVuc2lvbkRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgICAgICAgICAgICAgbXNwSGludC5yZW5kZXJfZGltZW5zaW9ucyA9IHRyYWNrU3RhdGUucmVuZGVyRGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tTdGF0ZS5pc0RpbWVuc2lvbkRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhpbnRzLnB1c2gobXNwSGludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHBheUxvYWQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlbmRlcl9oaW50cycsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcjoge1xuICAgICAgICAgICAgICAgICAgICBpZDogbWVzc2FnZUlkKyssXG4gICAgICAgICAgICAgICAgICAgIGhpbnRzOiBoaW50c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoJ091dGdvaW5nOiAnLCBwYXlMb2FkKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydC5wdWJsaXNoKHBheUxvYWQpO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNwb25zZVBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyYWNrLlNJRH0gdHJhY2tTaWRcbiAgICAgKiBAcGFyYW0ge0NsaWVudFJlbmRlckhpbnR9IHJlbmRlckhpbnRcbiAgICAgKi9cbiAgICBSZW5kZXJIaW50c1NpZ25hbGluZy5wcm90b3R5cGUuc2V0VHJhY2tIaW50ID0gZnVuY3Rpb24gKHRyYWNrU2lkLCByZW5kZXJIaW50KSB7XG4gICAgICAgIHZhciB0cmFja1N0YXRlID0gdGhpcy5fdHJhY2tTaWRzVG9SZW5kZXJIaW50cy5nZXQodHJhY2tTaWQpIHx8IHsgaXNFbmFibGVkRGlydHk6IGZhbHNlLCBpc0RpbWVuc2lvbkRpcnR5OiBmYWxzZSB9O1xuICAgICAgICBpZiAoJ2VuYWJsZWQnIGluIHJlbmRlckhpbnQgJiYgdHJhY2tTdGF0ZS5lbmFibGVkICE9PSByZW5kZXJIaW50LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRyYWNrU3RhdGUuZW5hYmxlZCA9ICEhcmVuZGVySGludC5lbmFibGVkO1xuICAgICAgICAgICAgdHJhY2tTdGF0ZS5pc0VuYWJsZWREaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbmRlckhpbnQucmVuZGVyRGltZW5zaW9ucyAmJiAhaXNEZWVwRXF1YWwocmVuZGVySGludC5yZW5kZXJEaW1lbnNpb25zLCB0cmFja1N0YXRlLnJlbmRlckRpbWVuc2lvbnMpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICAgICB0cmFja1N0YXRlLnJlbmRlckRpbWVuc2lvbnMgPSByZW5kZXJIaW50LnJlbmRlckRpbWVuc2lvbnM7XG4gICAgICAgICAgICB0cmFja1N0YXRlLmlzRGltZW5zaW9uRGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYWNrU2lkc1RvUmVuZGVySGludHMuc2V0KHRyYWNrU2lkLCB0cmFja1N0YXRlKTtcbiAgICAgICAgdGhpcy5fc2VuZEhpbnRzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBtdXN0IGJlIGNhbGxlZCB3aGVuIHRyYWNrIGlzIHVuc3Vic2NyaWJlZC5cbiAgICAgKiBAcGFyYW0ge1RyYWNrLlNJRH0gdHJhY2tTaWRcbiAgICAgKi9cbiAgICBSZW5kZXJIaW50c1NpZ25hbGluZy5wcm90b3R5cGUuY2xlYXJUcmFja0hpbnQgPSBmdW5jdGlvbiAodHJhY2tTaWQpIHtcbiAgICAgICAgdGhpcy5fdHJhY2tTaWRzVG9SZW5kZXJIaW50cy5kZWxldGUodHJhY2tTaWQpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbmRlckhpbnRzU2lnbmFsaW5nO1xufShNZWRpYVNpZ25hbGluZykpO1xubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJIaW50c1NpZ25hbGluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlcmhpbnRzc2lnbmFsaW5nLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgRG9taW5hbnRTcGVha2VyU2lnbmFsaW5nID0gcmVxdWlyZSgnLi9kb21pbmFudHNwZWFrZXJzaWduYWxpbmcnKTtcbnZhciBOZXR3b3JrUXVhbGl0eU1vbml0b3IgPSByZXF1aXJlKCcuL25ldHdvcmtxdWFsaXR5bW9uaXRvcicpO1xudmFyIE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nID0gcmVxdWlyZSgnLi9uZXR3b3JrcXVhbGl0eXNpZ25hbGluZycpO1xudmFyIFJlY29yZGluZ1YyID0gcmVxdWlyZSgnLi9yZWNvcmRpbmcnKTtcbnZhciBSb29tU2lnbmFsaW5nID0gcmVxdWlyZSgnLi4vcm9vbScpO1xudmFyIFJlbW90ZVBhcnRpY2lwYW50VjIgPSByZXF1aXJlKCcuL3JlbW90ZXBhcnRpY2lwYW50Jyk7XG52YXIgU3RhdHNSZXBvcnQgPSByZXF1aXJlKCcuLi8uLi9zdGF0cy9zdGF0c3JlcG9ydCcpO1xudmFyIFRyYWNrUHJpb3JpdHlTaWduYWxpbmcgPSByZXF1aXJlKCcuL3RyYWNrcHJpb3JpdHlzaWduYWxpbmcnKTtcbnZhciBUcmFja1N3aXRjaE9mZlNpZ25hbGluZyA9IHJlcXVpcmUoJy4vdHJhY2tzd2l0Y2hvZmZzaWduYWxpbmcnKTtcbnZhciBSZW5kZXJIaW50c1NpZ25hbGluZyA9IHJlcXVpcmUoJy4vcmVuZGVyaGludHNzaWduYWxpbmcnKTtcbnZhciBQdWJsaXNoZXJIaW50c1NpZ25hbGluZyA9IHJlcXVpcmUoJy4vcHVibGlzaGVyaGludHNpZ25hbGluZy5qcycpO1xudmFyIF9hID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLCBERUZBVUxUX1NFU1NJT05fVElNRU9VVF9TRUMgPSBfYS5jb25zdGFudHMuREVGQVVMVF9TRVNTSU9OX1RJTUVPVVRfU0VDLCBjcmVhdGVCYW5kd2lkdGhQcm9maWxlUGF5bG9hZCA9IF9hLmNyZWF0ZUJhbmR3aWR0aFByb2ZpbGVQYXlsb2FkLCBkZWZlciA9IF9hLmRlZmVyLCBkaWZmZXJlbmNlID0gX2EuZGlmZmVyZW5jZSwgZmlsdGVyT2JqZWN0ID0gX2EuZmlsdGVyT2JqZWN0LCBmbGF0TWFwID0gX2EuZmxhdE1hcCwgb25jZVBlclRpY2sgPSBfYS5vbmNlUGVyVGljaztcbnZhciBNb3ZpbmdBdmVyYWdlRGVsdGEgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vdmluZ2F2ZXJhZ2VkZWx0YScpO1xudmFyIGNyZWF0ZVR3aWxpb0Vycm9yID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90d2lsaW8tdmlkZW8tZXJyb3JzJykuY3JlYXRlVHdpbGlvRXJyb3I7XG52YXIgU1RBVFNfUFVCTElTSF9JTlRFUlZBTF9NUyA9IDEwMDAwO1xuLyoqXG4gKiBAZXh0ZW5kcyBSb29tU2lnbmFsaW5nXG4gKi9cbnZhciBSb29tVjIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21WMiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tVjIobG9jYWxQYXJ0aWNpcGFudCwgaW5pdGlhbFN0YXRlLCB0cmFuc3BvcnQsIHBlZXJDb25uZWN0aW9uTWFuYWdlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpbml0aWFsU3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgc2Vzc2lvbl90aW1lb3V0OiBERUZBVUxUX1NFU1NJT05fVElNRU9VVF9TRUNcbiAgICAgICAgfSwgaW5pdGlhbFN0YXRlLm9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBEb21pbmFudFNwZWFrZXJTaWduYWxpbmc6IERvbWluYW50U3BlYWtlclNpZ25hbGluZyxcbiAgICAgICAgICAgIE5ldHdvcmtRdWFsaXR5TW9uaXRvcjogTmV0d29ya1F1YWxpdHlNb25pdG9yLFxuICAgICAgICAgICAgTmV0d29ya1F1YWxpdHlTaWduYWxpbmc6IE5ldHdvcmtRdWFsaXR5U2lnbmFsaW5nLFxuICAgICAgICAgICAgUmVjb3JkaW5nU2lnbmFsaW5nOiBSZWNvcmRpbmdWMixcbiAgICAgICAgICAgIFJlbW90ZVBhcnRpY2lwYW50VjI6IFJlbW90ZVBhcnRpY2lwYW50VjIsXG4gICAgICAgICAgICBUcmFja1ByaW9yaXR5U2lnbmFsaW5nOiBUcmFja1ByaW9yaXR5U2lnbmFsaW5nLFxuICAgICAgICAgICAgVHJhY2tTd2l0Y2hPZmZTaWduYWxpbmc6IFRyYWNrU3dpdGNoT2ZmU2lnbmFsaW5nLFxuICAgICAgICAgICAgYmFuZHdpZHRoUHJvZmlsZTogbnVsbCxcbiAgICAgICAgICAgIHNlc3Npb25UaW1lb3V0OiBpbml0aWFsU3RhdGUub3B0aW9ucy5zZXNzaW9uX3RpbWVvdXQgKiAxMDAwLFxuICAgICAgICAgICAgc3RhdHNQdWJsaXNoSW50ZXJ2YWxNczogU1RBVFNfUFVCTElTSF9JTlRFUlZBTF9NU1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgbG9jYWxQYXJ0aWNpcGFudC5zZXRCYW5kd2lkdGhQcm9maWxlKG9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZSk7XG4gICAgICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5zZXRJY2VSZWNvbm5lY3RUaW1lb3V0KG9wdGlvbnMuc2Vzc2lvblRpbWVvdXQpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxvY2FsUGFydGljaXBhbnQsIGluaXRpYWxTdGF0ZS5zaWQsIGluaXRpYWxTdGF0ZS5uYW1lLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICB2YXIgZ2V0VHJhY2tSZWNlaXZlciA9IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gX3RoaXMuX2dldFRyYWNrUmVjZWl2ZXIoaWQpOyB9O1xuICAgICAgICB2YXIgbG9nID0gX3RoaXMuX2xvZztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9kaXNjb25uZWN0ZWRQYXJ0aWNpcGFudFJldmlzaW9uczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfTmV0d29ya1F1YWxpdHlNb25pdG9yOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuTmV0d29ya1F1YWxpdHlNb25pdG9yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xhc3RCYW5kd2lkdGhQcm9maWxlUmV2aXNpb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbG9jYWxQYXJ0aWNpcGFudC5iYW5kd2lkdGhQcm9maWxlUmV2aXNpb24sXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbmV0d29ya1F1YWxpdHlNb25pdG9yOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGxvY2FsUGFydGljaXBhbnQubmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3BlZXJDb25uZWN0aW9uTWFuYWdlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwZWVyQ29ubmVjdGlvbk1hbmFnZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcHVibGlzaGVkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9wdWJsaXNoZWRSZXZpc2lvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX1JlbW90ZVBhcnRpY2lwYW50VjI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5SZW1vdGVQYXJ0aWNpcGFudFYyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3N1YnNjcmliZWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3N1YnNjcmliZWRSZXZpc2lvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3N1YnNjcmlwdGlvbkZhaWx1cmVzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kb21pbmFudFNwZWFrZXJTaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IG9wdGlvbnMuRG9taW5hbnRTcGVha2VyU2lnbmFsaW5nKGdldFRyYWNrUmVjZWl2ZXIsIHsgbG9nOiBsb2cgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbmV0d29ya1F1YWxpdHlTaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IG9wdGlvbnMuTmV0d29ya1F1YWxpdHlTaWduYWxpbmcoZ2V0VHJhY2tSZWNlaXZlciwgbG9jYWxQYXJ0aWNpcGFudC5uZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24sIHsgbG9nOiBsb2cgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVuZGVySGludHNTaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFJlbmRlckhpbnRzU2lnbmFsaW5nKGdldFRyYWNrUmVjZWl2ZXIsIHsgbG9nOiBsb2cgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3B1Ymxpc2hlckhpbnRzU2lnbmFsaW5nOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBQdWJsaXNoZXJIaW50c1NpZ25hbGluZyhnZXRUcmFja1JlY2VpdmVyLCB7IGxvZzogbG9nIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90cmFja1ByaW9yaXR5U2lnbmFsaW5nOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBvcHRpb25zLlRyYWNrUHJpb3JpdHlTaWduYWxpbmcoZ2V0VHJhY2tSZWNlaXZlciwgeyBsb2c6IGxvZyB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdHJhY2tTd2l0Y2hPZmZTaWduYWxpbmc6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IG9wdGlvbnMuVHJhY2tTd2l0Y2hPZmZTaWduYWxpbmcoZ2V0VHJhY2tSZWNlaXZlciwgeyBsb2c6IGxvZyB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcGVuZGluZ1N3aXRjaE9mZlN0YXRlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdHJhbnNwb3J0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRyYW5zcG9ydFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90cmFja1JlY2VpdmVyRGVmZXJyZWRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lZGlhUmVnaW9uOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5pdGlhbFN0YXRlLm9wdGlvbnMubWVkaWFfcmVnaW9uIHx8IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLl9pbml0VHJhY2tTd2l0Y2hPZmZTaWduYWxpbmcoKTtcbiAgICAgICAgX3RoaXMuX2luaXREb21pbmFudFNwZWFrZXJTaWduYWxpbmcoKTtcbiAgICAgICAgX3RoaXMuX2luaXROZXR3b3JrUXVhbGl0eU1vbml0b3JTaWduYWxpbmcoKTtcbiAgICAgICAgX3RoaXMuX2luaXRQdWJsaXNoZXJIaW50U2lnbmFsaW5nKCk7XG4gICAgICAgIGhhbmRsZUxvY2FsUGFydGljaXBhbnRFdmVudHMoX3RoaXMsIGxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICBoYW5kbGVQZWVyQ29ubmVjdGlvbkV2ZW50cyhfdGhpcywgcGVlckNvbm5lY3Rpb25NYW5hZ2VyKTtcbiAgICAgICAgaGFuZGxlVHJhbnNwb3J0RXZlbnRzKF90aGlzLCB0cmFuc3BvcnQpO1xuICAgICAgICBwZXJpb2RpY2FsbHlQdWJsaXNoU3RhdHMoX3RoaXMsIHRyYW5zcG9ydCwgb3B0aW9ucy5zdGF0c1B1Ymxpc2hJbnRlcnZhbE1zKTtcbiAgICAgICAgX3RoaXMuX3VwZGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb29tVjIucHJvdG90eXBlLCBcImNvbm5lY3Rpb25TdGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgUGVlckNvbm5lY3Rpb24gc3RhdGUuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7UlRDUGVlckNvbm5lY3Rpb25TdGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uU3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm9vbVYyLnByb3RvdHlwZSwgXCJzaWduYWxpbmdDb25uZWN0aW9uU3RhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFNpZ25hbGluZyBDb25uZWN0aW9uIFN0YXRlLlxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gLSBcImNvbm5lY3RlZFwiLCBcInJlY29ubmVjdGluZ1wiLCBcImRpc2Nvbm5lY3RlZFwiXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc3RhdGUgPT09ICdzeW5jaW5nJ1xuICAgICAgICAgICAgICAgID8gJ3JlY29ubmVjdGluZydcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3RyYW5zcG9ydC5zdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb29tVjIucHJvdG90eXBlLCBcImljZUNvbm5lY3Rpb25TdGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSWNlIENvbm5lY3Rpb24gU3RhdGUuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7UlRDSWNlQ29ubmVjdGlvblN0YXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb25NYW5hZ2VyLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUm9vbVYyLnByb3RvdHlwZS5fZGVsZXRlVHJhY2tSZWNlaXZlckRlZmVycmVkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja1JlY2VpdmVyRGVmZXJyZWRzLmRlbGV0ZShpZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX2dldE9yQ3JlYXRlVHJhY2tSZWNlaXZlckRlZmVycmVkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IHRoaXMuX3RyYWNrUmVjZWl2ZXJEZWZlcnJlZHMuZ2V0KGlkKSB8fCBkZWZlcigpO1xuICAgICAgICB2YXIgdHJhY2tSZWNlaXZlcnMgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhY2tSZWNlaXZlcnMoKTtcbiAgICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogSW4gRmlyZWZveCwgdGhlcmUgY2FuIGJlIGluc3RhbmNlcyB3aGVyZSBhIE1lZGlhU3RyZWFtVHJhY2tcbiAgICAgICAgLy8gZm9yIHRoZSBnaXZlbiBUcmFjayBJRCBhbHJlYWR5IGV4aXN0cywgZm9yIGV4YW1wbGUsIHdoZW4gYSBUcmFjayBpcyByZW1vdmVkXG4gICAgICAgIC8vIGFuZCBhZGRlZCBiYWNrLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCB0aGVuIHdlIHNob3VsZCByZXNvbHZlICdkZWZlcnJlZCcuXG4gICAgICAgIHZhciB0cmFja1JlY2VpdmVyID0gdHJhY2tSZWNlaXZlcnMuZmluZChmdW5jdGlvbiAodHJhY2tSZWNlaXZlcikgeyByZXR1cm4gdHJhY2tSZWNlaXZlci5pZCA9PT0gaWQgJiYgdHJhY2tSZWNlaXZlci5yZWFkeVN0YXRlICE9PSAnZW5kZWQnOyB9KTtcbiAgICAgICAgaWYgKHRyYWNrUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodHJhY2tSZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBPbmx5IGFkZCB0aGUgJ2RlZmVycmVkJyB0byB0aGUgbWFwIGlmIGl0J3Mgbm90XG4gICAgICAgICAgICAvLyByZXNvbHZlZC4gVGhpcyB3aWxsIHByZXZlbnQgb2xkIGNvcGllcyBvZiB0aGUgTWVkaWFTdHJlYW1UcmFjayBmcm9tXG4gICAgICAgICAgICAvLyBiZWluZyB1c2VkIHdoZW4gdGhlIHJlbW90ZSBwZWVyIHJlbW92ZXMgYW5kIHJlLWFkZHMgYSBNZWRpYVN0cmVhbVRyYWNrLlxuICAgICAgICAgICAgdGhpcy5fdHJhY2tSZWNlaXZlckRlZmVycmVkcy5zZXQoaWQsIGRlZmVycmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX2FkZFRyYWNrUmVjZWl2ZXIgPSBmdW5jdGlvbiAodHJhY2tSZWNlaXZlcikge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSB0aGlzLl9nZXRPckNyZWF0ZVRyYWNrUmVjZWl2ZXJEZWZlcnJlZCh0cmFja1JlY2VpdmVyLmlkKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0cmFja1JlY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX2Rpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdmFyIGRpZERpc2Nvbm5lY3QgPSBfc3VwZXIucHJvdG90eXBlLl9kaXNjb25uZWN0LmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICBpZiAoZGlkRGlzY29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5fdGVhcmRvd25OZXR3b3JrUXVhbGl0eU1vbml0b3IoKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICB0cmFjay5wdWJsaXNoRmFpbGVkKGVycm9yIHx8IG5ldyBFcnJvcignTG9jYWxQYXJ0aWNpcGFudCBkaXNjb25uZWN0ZWQnKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGlkRGlzY29ubmVjdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUm9vbVYyLnByb3RvdHlwZS5fZ2V0VHJhY2tSZWNlaXZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVUcmFja1JlY2VpdmVyRGVmZXJyZWQoaWQpLnByb21pc2UudGhlbihmdW5jdGlvbiAodHJhY2tSZWNlaXZlcikge1xuICAgICAgICAgICAgX3RoaXMuX2RlbGV0ZVRyYWNrUmVjZWl2ZXJEZWZlcnJlZChpZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2tSZWNlaXZlcjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX2dldEluaXRpYWxUcmFja1N3aXRjaE9mZlN0YXRlID0gZnVuY3Rpb24gKHRyYWNrU2lkKSB7XG4gICAgICAgIHZhciBpbml0aWFsbHlTd2l0Y2hlZE9mZiA9IHRoaXMuX3BlbmRpbmdTd2l0Y2hPZmZTdGF0ZXMuZ2V0KHRyYWNrU2lkKSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1N3aXRjaE9mZlN0YXRlcy5kZWxldGUodHJhY2tTaWQpO1xuICAgICAgICBpZiAoaW5pdGlhbGx5U3dpdGNoZWRPZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiW1wiICsgdHJhY2tTaWQgKyBcIl0gd2FzIGluaXRpYWxseSBzd2l0Y2hlZCBvZmYhIFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5pdGlhbGx5U3dpdGNoZWRPZmY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX2dldFRyYWNrU2lkc1RvVHJhY2tTaWduYWxpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJhY2tTaWRzVG9UcmFja1NpZ25hbGluZ3MgPSBmbGF0TWFwKHRoaXMucGFydGljaXBhbnRzLCBmdW5jdGlvbiAocGFydGljaXBhbnQpIHsgcmV0dXJuIEFycmF5LmZyb20ocGFydGljaXBhbnQudHJhY2tzKTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKHRyYWNrU2lkc1RvVHJhY2tTaWduYWxpbmdzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUm9vbVYyLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVSZW1vdGVQYXJ0aWNpcGFudCA9IGZ1bmN0aW9uIChwYXJ0aWNpcGFudFN0YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBSZW1vdGVQYXJ0aWNpcGFudFYyID0gdGhpcy5fUmVtb3RlUGFydGljaXBhbnRWMjtcbiAgICAgICAgdmFyIHBhcnRpY2lwYW50ID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHBhcnRpY2lwYW50U3RhdGUuc2lkKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICBwYXJ0aWNpcGFudCA9IG5ldyBSZW1vdGVQYXJ0aWNpcGFudFYyKHBhcnRpY2lwYW50U3RhdGUsIGZ1bmN0aW9uICh0cmFja1NpZCkgeyByZXR1cm4gX3RoaXMuX2dldEluaXRpYWxUcmFja1N3aXRjaE9mZlN0YXRlKHRyYWNrU2lkKTsgfSwgZnVuY3Rpb24gKHRyYWNrU2lkLCBwcmlvcml0eSkgeyByZXR1cm4gX3RoaXMuX3RyYWNrUHJpb3JpdHlTaWduYWxpbmcuc2VuZFRyYWNrUHJpb3JpdHlVcGRhdGUodHJhY2tTaWQsICdzdWJzY3JpYmUnLCBwcmlvcml0eSk7IH0sIGZ1bmN0aW9uICh0cmFja1NpZCwgaGludCkgeyByZXR1cm4gX3RoaXMuX3JlbmRlckhpbnRzU2lnbmFsaW5nLnNldFRyYWNrSGludCh0cmFja1NpZCwgaGludCk7IH0sIGZ1bmN0aW9uICh0cmFja1NpZCkgeyByZXR1cm4gX3RoaXMuX3JlbmRlckhpbnRzU2lnbmFsaW5nLmNsZWFyVHJhY2tIaW50KHRyYWNrU2lkKTsgfSk7XG4gICAgICAgICAgICBwYXJ0aWNpcGFudC5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gc3RhdGVDaGFuZ2VkKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudC5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJ0aWNpcGFudHMuZGVsZXRlKHBhcnRpY2lwYW50LnNpZCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2Rpc2Nvbm5lY3RlZFBhcnRpY2lwYW50UmV2aXNpb25zLnNldChwYXJ0aWNpcGFudC5zaWQsIHBhcnRpY2lwYW50LnJldmlzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFBhcnRpY2lwYW50KHBhcnRpY2lwYW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydGljaXBhbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX2dldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFydGljaXBhbnQ6IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5nZXRTdGF0ZSgpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX21heWJlQWRkQmFuZHdpZHRoUHJvZmlsZSA9IGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LCBiYW5kd2lkdGhQcm9maWxlID0gX2EuYmFuZHdpZHRoUHJvZmlsZSwgYmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uID0gX2EuYmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uO1xuICAgICAgICBpZiAoYmFuZHdpZHRoUHJvZmlsZSAmJiB0aGlzLl9sYXN0QmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uIDwgYmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0QmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uID0gYmFuZHdpZHRoUHJvZmlsZVJldmlzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIGJhbmR3aWR0aF9wcm9maWxlOiBjcmVhdGVCYW5kd2lkdGhQcm9maWxlUGF5bG9hZChiYW5kd2lkdGhQcm9maWxlKVxuICAgICAgICAgICAgfSwgdXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSb29tVjIucHJvdG90eXBlLl9wdWJsaXNoTmV3TG9jYWxQYXJ0aWNpcGFudFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQucHVibGlzaCh0aGlzLl9tYXliZUFkZEJhbmR3aWR0aFByb2ZpbGUodGhpcy5fZ2V0U3RhdGUoKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSb29tVjIucHJvdG90eXBlLl9wdWJsaXNoUGVlckNvbm5lY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChwZWVyQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgIC8qIGVzbGludCBjYW1lbGNhc2U6MCAqL1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQucHVibGlzaChPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHBlZXJfY29ubmVjdGlvbnM6IFtwZWVyQ29ubmVjdGlvblN0YXRlXVxuICAgICAgICB9LCB0aGlzLl9nZXRTdGF0ZSgpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJvb21WMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChyb29tU3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHJvb21TdGF0ZS5zdWJzY3JpYmVkICYmIHJvb21TdGF0ZS5zdWJzY3JpYmVkLnJldmlzaW9uID4gdGhpcy5fc3Vic2NyaWJlZFJldmlzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVkUmV2aXNpb24gPSByb29tU3RhdGUuc3Vic2NyaWJlZC5yZXZpc2lvbjtcbiAgICAgICAgICAgIHJvb21TdGF0ZS5zdWJzY3JpYmVkLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrU3RhdGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvbkZhaWx1cmVzLmRlbGV0ZSh0cmFja1N0YXRlLnNpZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpYmVkLnNldCh0cmFja1N0YXRlLnNpZCwgdHJhY2tTdGF0ZS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyYWNrU3RhdGUuZXJyb3IgJiYgIV90aGlzLl9zdWJzY3JpcHRpb25GYWlsdXJlcy5oYXModHJhY2tTdGF0ZS5zaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25GYWlsdXJlcy5zZXQodHJhY2tTdGF0ZS5zaWQsIHRyYWNrU3RhdGUuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHN1YnNjcmliZWRUcmFja1NpZHNfMSA9IG5ldyBTZXQocm9vbVN0YXRlLnN1YnNjcmliZWQudHJhY2tzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodHJhY2tTdGF0ZSkgeyByZXR1cm4gISF0cmFja1N0YXRlLmlkOyB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHRyYWNrU3RhdGUpIHsgcmV0dXJuIHRyYWNrU3RhdGUuc2lkOyB9KSk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVkLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrSWQsIHRyYWNrU2lkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVkVHJhY2tTaWRzXzEuaGFzKHRyYWNrU2lkKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3Vic2NyaWJlZC5kZWxldGUodHJhY2tTaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0aWNpcGFudHNUb0tlZXAgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby13YXJuaW5nLWNvbW1lbnRzXG4gICAgICAgIC8vIFRPRE8obXJvYmVydHMpOiBSZW1vdmUgbWUgb25jZSB0aGUgU2VydmVyIGlzIGZpeGVkLlxuICAgICAgICAocm9vbVN0YXRlLnBhcnRpY2lwYW50cyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAocGFydGljaXBhbnRTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHBhcnRpY2lwYW50U3RhdGUuc2lkID09PSBfdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IElmIHRoZSBpbmNvbWluZyByZXZpc2lvbiBmb3IgYSBkaXNjb25uZWN0ZWQgUGFydGljaXBhbnQgaXMgbGVzcyB0aGFuIG9yXG4gICAgICAgICAgICAvLyBlcXVhbCB0byB0aGUgcmV2aXNpb24gd2hlbiBpdCB3YXMgZGlzY29ubmVjdGVkLCB0aGVuIHRoZSBzdGF0ZSBpcyBvbGQgYW5kIGNhbiBiZSBpZ25vcmVkLlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgUGFydGljaXBhbnQgd2FzIG1vc3QgbGlrZWx5IGRpc2Nvbm5lY3RlZCBpbiBhIExhcmdlIEdyb3VwIFJvb20gd2hlbiBpdFxuICAgICAgICAgICAgLy8gc3RvcHBlZCBwdWJsaXNoaW5nIG1lZGlhLCBhbmQgaGVuY2UgbmVlZHMgdG8gYmUgcmUtYWRkZWQuXG4gICAgICAgICAgICB2YXIgZGlzY29ubmVjdGVkUGFydGljaXBhbnRSZXZpc2lvbiA9IF90aGlzLl9kaXNjb25uZWN0ZWRQYXJ0aWNpcGFudFJldmlzaW9ucy5nZXQocGFydGljaXBhbnRTdGF0ZS5zaWQpO1xuICAgICAgICAgICAgaWYgKGRpc2Nvbm5lY3RlZFBhcnRpY2lwYW50UmV2aXNpb24gJiYgcGFydGljaXBhbnRTdGF0ZS5yZXZpc2lvbiA8PSBkaXNjb25uZWN0ZWRQYXJ0aWNpcGFudFJldmlzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc2Nvbm5lY3RlZFBhcnRpY2lwYW50UmV2aXNpb24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGlzY29ubmVjdGVkUGFydGljaXBhbnRSZXZpc2lvbnMuZGVsZXRlKHBhcnRpY2lwYW50U3RhdGUuc2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJ0aWNpcGFudCA9IF90aGlzLl9nZXRPckNyZWF0ZVJlbW90ZVBhcnRpY2lwYW50KHBhcnRpY2lwYW50U3RhdGUpO1xuICAgICAgICAgICAgcGFydGljaXBhbnQudXBkYXRlKHBhcnRpY2lwYW50U3RhdGUpO1xuICAgICAgICAgICAgcGFydGljaXBhbnRzVG9LZWVwLmFkZChwYXJ0aWNpcGFudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocm9vbVN0YXRlLnR5cGUgPT09ICdzeW5jZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2lwYW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgICAgIGlmICghcGFydGljaXBhbnRzVG9LZWVwLmhhcyhwYXJ0aWNpcGFudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVN1YnNjcmlwdGlvbnModGhpcyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby13YXJuaW5nLWNvbW1lbnRzXG4gICAgICAgIC8vIFRPRE8obXJvYmVydHMpOiBSZW1vdmUgbWUgb25jZSB0aGUgU2VydmVyIGlzIGZpeGVkLlxuICAgICAgICAvKiBlc2xpbnQgY2FtZWxjYXNlOjAgKi9cbiAgICAgICAgaWYgKHJvb21TdGF0ZS5wZWVyX2Nvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbk1hbmFnZXIudXBkYXRlKHJvb21TdGF0ZS5wZWVyX2Nvbm5lY3Rpb25zLCByb29tU3RhdGUudHlwZSA9PT0gJ3N5bmNlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb29tU3RhdGUucmVjb3JkaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29yZGluZy51cGRhdGUocm9vbVN0YXRlLnJlY29yZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb21TdGF0ZS5wdWJsaXNoZWQgJiYgcm9vbVN0YXRlLnB1Ymxpc2hlZC5yZXZpc2lvbiA+IHRoaXMuX3B1Ymxpc2hlZFJldmlzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9wdWJsaXNoZWRSZXZpc2lvbiA9IHJvb21TdGF0ZS5wdWJsaXNoZWQucmV2aXNpb247XG4gICAgICAgICAgICByb29tU3RhdGUucHVibGlzaGVkLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0cmFjay5zaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlZC5zZXQodHJhY2suaWQsIHRyYWNrLnNpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlKHJvb21TdGF0ZS5wdWJsaXNoZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb29tU3RhdGUucGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5jb25uZWN0KHJvb21TdGF0ZS5wYXJ0aWNpcGFudC5zaWQsIHJvb21TdGF0ZS5wYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgW1xuICAgICAgICAgICAgdGhpcy5fZG9taW5hbnRTcGVha2VyU2lnbmFsaW5nLFxuICAgICAgICAgICAgdGhpcy5fbmV0d29ya1F1YWxpdHlTaWduYWxpbmcsXG4gICAgICAgICAgICB0aGlzLl90cmFja1ByaW9yaXR5U2lnbmFsaW5nLFxuICAgICAgICAgICAgdGhpcy5fdHJhY2tTd2l0Y2hPZmZTaWduYWxpbmcsXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJIaW50c1NpZ25hbGluZyxcbiAgICAgICAgICAgIHRoaXMuX3B1Ymxpc2hlckhpbnRzU2lnbmFsaW5nXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAobWVkaWFTaWduYWxpbmcpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gbWVkaWFTaWduYWxpbmcuY2hhbm5lbDtcbiAgICAgICAgICAgIGlmICghbWVkaWFTaWduYWxpbmcuaXNTZXR1cFxuICAgICAgICAgICAgICAgICYmIHJvb21TdGF0ZS5tZWRpYV9zaWduYWxpbmdcbiAgICAgICAgICAgICAgICAmJiByb29tU3RhdGUubWVkaWFfc2lnbmFsaW5nW2NoYW5uZWxdXG4gICAgICAgICAgICAgICAgJiYgcm9vbVN0YXRlLm1lZGlhX3NpZ25hbGluZ1tjaGFubmVsXS50cmFuc3BvcnRcbiAgICAgICAgICAgICAgICAmJiByb29tU3RhdGUubWVkaWFfc2lnbmFsaW5nW2NoYW5uZWxdLnRyYW5zcG9ydC50eXBlID09PSAnZGF0YS1jaGFubmVsJykge1xuICAgICAgICAgICAgICAgIG1lZGlhU2lnbmFsaW5nLnNldHVwKHJvb21TdGF0ZS5tZWRpYV9zaWduYWxpbmdbY2hhbm5lbF0udHJhbnNwb3J0LmxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUm9vbVYyLnByb3RvdHlwZS5faW5pdFB1Ymxpc2hlckhpbnRTaWduYWxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3B1Ymxpc2hlckhpbnRzU2lnbmFsaW5nLm9uKCd1cGRhdGVkJywgZnVuY3Rpb24gKGhpbnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0UHVibGlzaGVySGludHMoaGludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5lcnJvcignX2luaXRQdWJsaXNoZXJIaW50U2lnbmFsaW5nIGZhaWxlZCB0byBzZXRQdWJsaXNoZXJIaW50czogJywgZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJvb21WMi5wcm90b3R5cGUuX2luaXRUcmFja1N3aXRjaE9mZlNpZ25hbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdHJhY2tTd2l0Y2hPZmZTaWduYWxpbmcub24oJ3VwZGF0ZWQnLCBmdW5jdGlvbiAodHJhY2tzT2ZmLCB0cmFja3NPbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKCdyZWNlaXZlZCB0cmFja1N3aXRjaDogJywgeyB0cmFja3NPbjogdHJhY2tzT24sIHRyYWNrc09mZjogdHJhY2tzT2ZmIH0pO1xuICAgICAgICAgICAgICAgIHZhciB0cmFja1VwZGF0ZXNfMSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB0cmFja3NPbi5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja1NpZCkgeyByZXR1cm4gdHJhY2tVcGRhdGVzXzEuc2V0KHRyYWNrU2lkLCB0cnVlKTsgfSk7XG4gICAgICAgICAgICAgICAgdHJhY2tzT2ZmLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrU2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja1VwZGF0ZXNfMS5nZXQodHJhY2tTaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogVGhpcyBtZWFucyB0aGF0IFZJREVPLTM3NjIgaGFzIGJlZW4gcmVwcm9kdWNlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cud2Fybih0cmFja1NpZCArIFwiIGlzIERVUExJQ0FURUQgaW4gYm90aCB0cmFja3NPZmYgYW5kIHRyYWNrc09uIGxpc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJhY2tVcGRhdGVzXzEuc2V0KHRyYWNrU2lkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMucGFydGljaXBhbnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50LnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzT24gPSB0cmFja1VwZGF0ZXNfMS5nZXQodHJhY2suc2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXNPbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5zZXRTd2l0Y2hlZE9mZighaXNPbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tVcGRhdGVzXzEuZGVsZXRlKHRyYWNrLnNpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBDYWNoZSBhbnkgbm90aWZpY2F0aW9uIGFib3V0IHRoZSB0cmFja3MgdGhhdCB3ZSBkbyBub3QgeWV0IGtub3cgYWJvdXQuXG4gICAgICAgICAgICAgICAgdHJhY2tVcGRhdGVzXzEuZm9yRWFjaChmdW5jdGlvbiAoaXNPbiwgdHJhY2tTaWQpIHsgcmV0dXJuIF90aGlzLl9wZW5kaW5nU3dpdGNoT2ZmU3RhdGVzLnNldCh0cmFja1NpZCwgIWlzT24pOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZXJyb3IoJ2Vycm9yIHByb2Nlc3NpbmcgdHJhY2sgc3dpdGNoIG9mZjonLCBleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUm9vbVYyLnByb3RvdHlwZS5faW5pdERvbWluYW50U3BlYWtlclNpZ25hbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZG9taW5hbnRTcGVha2VyU2lnbmFsaW5nLm9uKCd1cGRhdGVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2V0RG9taW5hbnRTcGVha2VyKF90aGlzLl9kb21pbmFudFNwZWFrZXJTaWduYWxpbmcubG91ZGVzdFBhcnRpY2lwYW50U2lkKTsgfSk7XG4gICAgfTtcbiAgICBSb29tVjIucHJvdG90eXBlLl9pbml0TmV0d29ya1F1YWxpdHlNb25pdG9yU2lnbmFsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9uZXR3b3JrUXVhbGl0eVNpZ25hbGluZy5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV0d29ya1F1YWxpdHlNb25pdG9yID0gbmV3IF90aGlzLl9OZXR3b3JrUXVhbGl0eU1vbml0b3IoX3RoaXMuX3BlZXJDb25uZWN0aW9uTWFuYWdlciwgX3RoaXMuX25ldHdvcmtRdWFsaXR5U2lnbmFsaW5nKTtcbiAgICAgICAgICAgIF90aGlzLl9uZXR3b3JrUXVhbGl0eU1vbml0b3IgPSBuZXR3b3JrUXVhbGl0eU1vbml0b3I7XG4gICAgICAgICAgICBuZXR3b3JrUXVhbGl0eU1vbml0b3Iub24oJ3VwZGF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldE5ldHdvcmtRdWFsaXR5TGV2ZWwobmV0d29ya1F1YWxpdHlNb25pdG9yLmxldmVsLCBuZXR3b3JrUXVhbGl0eU1vbml0b3IubGV2ZWxzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJ0aWNpcGFudHMuZm9yRWFjaChmdW5jdGlvbiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxldmVscyA9IG5ldHdvcmtRdWFsaXR5TW9uaXRvci5yZW1vdGVMZXZlbHMuZ2V0KHBhcnRpY2lwYW50LnNpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZXZlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50LnNldE5ldHdvcmtRdWFsaXR5TGV2ZWwobGV2ZWxzLmxldmVsLCBsZXZlbHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5ldHdvcmtRdWFsaXR5TW9uaXRvci5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbmV0d29ya1F1YWxpdHlTaWduYWxpbmcub24oJ3RlYXJkb3duJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3RlYXJkb3duTmV0d29ya1F1YWxpdHlNb25pdG9yKCk7IH0pO1xuICAgIH07XG4gICAgUm9vbVYyLnByb3RvdHlwZS5fdGVhcmRvd25OZXR3b3JrUXVhbGl0eU1vbml0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9uZXR3b3JrUXVhbGl0eU1vbml0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX25ldHdvcmtRdWFsaXR5TW9uaXRvci5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9uZXR3b3JrUXVhbGl0eU1vbml0b3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHtAbGluayBSb29tVjJ9J3MgbWVkaWEgc3RhdGlzdGljcy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48TWFwPFBlZXJDb25uZWN0aW9uVjIjaWQsIFN0YW5kYXJkaXplZFN0YXRzUmVzcG9uc2U+Pn1cbiAgICAgKi9cbiAgICBSb29tVjIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb25NYW5hZ2VyLmdldFN0YXRzKCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcChBcnJheS5mcm9tKHJlc3BvbnNlcykubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIGlkID0gX2JbMF0sIHJlc3BvbnNlID0gX2JbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtpZCwgT2JqZWN0LmFzc2lnbih7fSwgcmVzcG9uc2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQXVkaW9UcmFja1N0YXRzOiBmaWx0ZXJBbmRBZGRMb2NhbFRyYWNrU2lkcyhfdGhpcywgcmVzcG9uc2UubG9jYWxBdWRpb1RyYWNrU3RhdHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxWaWRlb1RyYWNrU3RhdHM6IGZpbHRlckFuZEFkZExvY2FsVHJhY2tTaWRzKF90aGlzLCByZXNwb25zZS5sb2NhbFZpZGVvVHJhY2tTdGF0cyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVBdWRpb1RyYWNrU3RhdHM6IGZpbHRlckFuZEFkZFJlbW90ZVRyYWNrU2lkcyhfdGhpcywgcmVzcG9uc2UucmVtb3RlQXVkaW9UcmFja1N0YXRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZVZpZGVvVHJhY2tTdGF0czogZmlsdGVyQW5kQWRkUmVtb3RlVHJhY2tTaWRzKF90aGlzLCByZXNwb25zZS5yZW1vdGVWaWRlb1RyYWNrU3RhdHMpXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUm9vbVYyO1xufShSb29tU2lnbmFsaW5nKSk7XG4vKipcbiAqIEZpbHRlciBvdXQge0BsaW5rIFRyYWNrU3RhdHN9IHRoYXQgYXJlbid0IGluIHRoZSBjb2xsZWN0aW9uIHdoaWxlIGFsc29cbiAqIHN0YW1waW5nIHRoZWlyIFRyYWNrIFNJRHMuXG4gKiBAcGFyYW0ge01hcDxJRCwgU0lEPn0gaWRUb1NpZFxuICogQHBhcmFtIHtBcnJheTxUcmFja1N0YXRzPn0gdHJhY2tTdGF0c1xuICogQHJldHVybnMge0FycmF5PFRyYWNrU3RhdHM+fVxuICovXG5mdW5jdGlvbiBmaWx0ZXJBbmRBZGRUcmFja1NpZHMoaWRUb1NpZCwgdHJhY2tTdGF0cykge1xuICAgIHJldHVybiB0cmFja1N0YXRzLnJlZHVjZShmdW5jdGlvbiAodHJhY2tTdGF0cywgdHJhY2tTdGF0KSB7XG4gICAgICAgIHZhciB0cmFja1NpZCA9IGlkVG9TaWQuZ2V0KHRyYWNrU3RhdC50cmFja0lkKTtcbiAgICAgICAgcmV0dXJuIHRyYWNrU2lkXG4gICAgICAgICAgICA/IFtPYmplY3QuYXNzaWduKHt9LCB0cmFja1N0YXQsIHsgdHJhY2tTaWQ6IHRyYWNrU2lkIH0pXS5jb25jYXQodHJhY2tTdGF0cylcbiAgICAgICAgICAgIDogdHJhY2tTdGF0cztcbiAgICB9LCBbXSk7XG59XG4vKipcbiAqIEZpbHRlciBvdXQge0BsaW5rIExvY2FsVHJhY2tTdGF0c30gdGhhdCBhcmVuJ3QgY3VycmVudGx5IHB1Ymxpc2hlZCB3aGlsZSBhbHNvXG4gKiBzdGFtcGluZyB0aGVpciBUcmFjayBTSURzLlxuICogQHBhcmFtIHtSb29tVjJ9IHJvb21WMlxuICogQHBhcmFtIHtBcnJheTxMb2NhbFRyYWNrU3RhdHM+fSBsb2NhbFRyYWNrU3RhdHNcbiAqIEByZXR1cm5zIHtBcnJheTxMb2NhbFRyYWNrU3RhdHM+fVxuICovXG5mdW5jdGlvbiBmaWx0ZXJBbmRBZGRMb2NhbFRyYWNrU2lkcyhyb29tVjIsIGxvY2FsVHJhY2tTdGF0cykge1xuICAgIHJldHVybiBmaWx0ZXJBbmRBZGRUcmFja1NpZHMocm9vbVYyLl9wdWJsaXNoZWQsIGxvY2FsVHJhY2tTdGF0cyk7XG59XG4vKipcbiAqIEZpbHRlciBvdXQge0BsaW5rIFJlbW90ZVRyYWNrU3RhdHN9IHRoYXQgYXJlbid0IGN1cnJlbnRseSBzdWJzY3JpYmVkIHdoaWxlXG4gKiBhbHNvIHN0YW1waW5nIHRoZWlyIFRyYWNrIFNJRHMuXG4gKiBAcGFyYW0ge1Jvb21WMn0gcm9vbVYyXG4gKiBAcGFyYW0ge0FycmF5PFJlbW90ZVRyYWNrU3RhdHM+fSByZW1vdGVUcmFja1N0YXRzXG4gKiBAcmV0dXJucyB7QXJyYXk8UmVtb3RlVHJhY2tTdGF0cz59XG4gKi9cbmZ1bmN0aW9uIGZpbHRlckFuZEFkZFJlbW90ZVRyYWNrU2lkcyhyb29tVjIsIHJlbW90ZVRyYWNrU3RhdHMpIHtcbiAgICB2YXIgaWRUb1NpZCA9IG5ldyBNYXAoQXJyYXkuZnJvbShyb29tVjIuX3N1YnNjcmliZWQuZW50cmllcygpKS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHNpZCA9IF9iWzBdLCBpZCA9IF9iWzFdO1xuICAgICAgICByZXR1cm4gW2lkLCBzaWRdO1xuICAgIH0pKTtcbiAgICByZXR1cm4gZmlsdGVyQW5kQWRkVHJhY2tTaWRzKGlkVG9TaWQsIHJlbW90ZVRyYWNrU3RhdHMpO1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBSb29tVjIjUmVwcmVzZW50YXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge0xvY2FsUGFydGljaXBhbnRWMiNSZXByZXNlbnRhdGlvbn0gcGFydGljaXBhbnRcbiAqIEBwcm9wZXJ0eSB7P0FycmF5PFJlbW90ZVBhcnRpY2lwYW50VjIjUmVwcmVzZW50YXRpb24+fSBwYXJ0aWNpcGFudHNcbiAqIEBwcm9wZXJ0eSB7P0FycmF5PFBlZXJDb25uZWN0aW9uVjIjUmVwcmVzZW50YXRpb24+fSBwZWVyX2Nvbm5lY3Rpb25zXG4gKiBAcHJvcGVydHkgez9SZWNvcmRpbmdWMiNSZXByZXNlbnRhdGlvbn0gcmVjb3JkaW5nXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2lkXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUxvY2FsUGFydGljaXBhbnRFdmVudHMocm9vbVYyLCBsb2NhbFBhcnRpY2lwYW50KSB7XG4gICAgdmFyIGxvY2FsUGFydGljaXBhbnRVcGRhdGVkID0gb25jZVBlclRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICByb29tVjIuX3B1Ymxpc2hOZXdMb2NhbFBhcnRpY2lwYW50U3RhdGUoKTtcbiAgICB9KTtcbiAgICB2YXIgcmVuZWdvdGlhdGUgPSBvbmNlUGVyVGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmFja1NlbmRlcnMgPSBmbGF0TWFwKGxvY2FsUGFydGljaXBhbnQudHJhY2tzLCBmdW5jdGlvbiAodHJhY2tWMikgeyByZXR1cm4gdHJhY2tWMi50cmFja1RyYW5zY2VpdmVyOyB9KTtcbiAgICAgICAgcm9vbVYyLl9wZWVyQ29ubmVjdGlvbk1hbmFnZXIuc2V0VHJhY2tTZW5kZXJzKHRyYWNrU2VuZGVycyk7XG4gICAgfSk7XG4gICAgbG9jYWxQYXJ0aWNpcGFudC5vbigndHJhY2tBZGRlZCcsIHJlbmVnb3RpYXRlKTtcbiAgICBsb2NhbFBhcnRpY2lwYW50Lm9uKCd0cmFja1JlbW92ZWQnLCByZW5lZ290aWF0ZSk7XG4gICAgbG9jYWxQYXJ0aWNpcGFudC5vbigndXBkYXRlZCcsIGxvY2FsUGFydGljaXBhbnRVcGRhdGVkKTtcbiAgICByb29tVjIub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICBsb2NhbFBhcnRpY2lwYW50LnJlbW92ZUxpc3RlbmVyKCd0cmFja0FkZGVkJywgcmVuZWdvdGlhdGUpO1xuICAgICAgICAgICAgbG9jYWxQYXJ0aWNpcGFudC5yZW1vdmVMaXN0ZW5lcigndHJhY2tSZW1vdmVkJywgcmVuZWdvdGlhdGUpO1xuICAgICAgICAgICAgbG9jYWxQYXJ0aWNpcGFudC5yZW1vdmVMaXN0ZW5lcigndXBkYXRlZCcsIGxvY2FsUGFydGljaXBhbnRVcGRhdGVkKTtcbiAgICAgICAgICAgIHJvb21WMi5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgICAgIGxvY2FsUGFydGljaXBhbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcm9vbVYyLm9uKCdzaWduYWxpbmdDb25uZWN0aW9uU3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9jYWxQYXJ0aWNpcGFudCA9IHJvb21WMi5sb2NhbFBhcnRpY2lwYW50LCBzaWduYWxpbmdDb25uZWN0aW9uU3RhdGUgPSByb29tVjIuc2lnbmFsaW5nQ29ubmVjdGlvblN0YXRlO1xuICAgICAgICB2YXIgaWRlbnRpdHkgPSBsb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5LCBzaWQgPSBsb2NhbFBhcnRpY2lwYW50LnNpZDtcbiAgICAgICAgc3dpdGNoIChzaWduYWxpbmdDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgbG9jYWxQYXJ0aWNpcGFudC5jb25uZWN0KHNpZCwgaWRlbnRpdHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICBsb2NhbFBhcnRpY2lwYW50LnJlY29ubmVjdGluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVQZWVyQ29ubmVjdGlvbkV2ZW50cyhyb29tVjIsIHBlZXJDb25uZWN0aW9uTWFuYWdlcikge1xuICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5vbignZGVzY3JpcHRpb24nLCBmdW5jdGlvbiBvbkRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJvb21WMi5fcHVibGlzaFBlZXJDb25uZWN0aW9uU3RhdGUoZGVzY3JpcHRpb24pO1xuICAgIH0pO1xuICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5kZXF1ZXVlKCdkZXNjcmlwdGlvbicpO1xuICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5vbignY2FuZGlkYXRlcycsIGZ1bmN0aW9uIG9uQ2FuZGlkYXRlcyhjYW5kaWRhdGVzKSB7XG4gICAgICAgIHJvb21WMi5fcHVibGlzaFBlZXJDb25uZWN0aW9uU3RhdGUoY2FuZGlkYXRlcyk7XG4gICAgfSk7XG4gICAgcGVlckNvbm5lY3Rpb25NYW5hZ2VyLmRlcXVldWUoJ2NhbmRpZGF0ZXMnKTtcbiAgICBwZWVyQ29ubmVjdGlvbk1hbmFnZXIub24oJ3RyYWNrQWRkZWQnLCByb29tVjIuX2FkZFRyYWNrUmVjZWl2ZXIuYmluZChyb29tVjIpKTtcbiAgICBwZWVyQ29ubmVjdGlvbk1hbmFnZXIuZGVxdWV1ZSgndHJhY2tBZGRlZCcpO1xuICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFja1JlY2VpdmVycygpLmZvckVhY2gocm9vbVYyLl9hZGRUcmFja1JlY2VpdmVyLCByb29tVjIpO1xuICAgIHBlZXJDb25uZWN0aW9uTWFuYWdlci5vbignY29ubmVjdGlvblN0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vbVYyLmVtaXQoJ2Nvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnKTtcbiAgICB9KTtcbiAgICBwZWVyQ29ubmVjdGlvbk1hbmFnZXIub24oJ2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb21WMi5lbWl0KCdpY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2VkJyk7XG4gICAgICAgIGlmIChyb29tVjIuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgaWYgKHJvb21WMi5sb2NhbFBhcnRpY2lwYW50Lm5ldHdvcmtRdWFsaXR5TGV2ZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByb29tVjIubG9jYWxQYXJ0aWNpcGFudC5zZXROZXR3b3JrUXVhbGl0eUxldmVsKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vbVYyLnBhcnRpY2lwYW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWNpcGFudC5uZXR3b3JrUXVhbGl0eUxldmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50LnNldE5ldHdvcmtRdWFsaXR5TGV2ZWwoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVRyYW5zcG9ydEV2ZW50cyhyb29tVjIsIHRyYW5zcG9ydCkge1xuICAgIHRyYW5zcG9ydC5vbignbWVzc2FnZScsIHJvb21WMi5fdXBkYXRlLmJpbmQocm9vbVYyKSk7XG4gICAgdHJhbnNwb3J0Lm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBzdGF0ZUNoYW5nZWQoc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIGlmIChyb29tVjIuc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgcm9vbVYyLl9kaXNjb25uZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgfVxuICAgICAgICByb29tVjIuZW1pdCgnc2lnbmFsaW5nQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCcpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBQZXJpb2RpY2FsbHkgcHVibGlzaCB7QGxpbmsgU3RhdHNSZXBvcnR9cy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1Jvb21WMn0gcm9vbVYyXG4gKiBAcGFyYW0ge1RyYW5zcG9ydH0gdHJhbnNwb3J0XG4gKiBAcGFyYW0ge051bWJlcn0gaW50ZXJ2YWxNc1xuICovXG5mdW5jdGlvbiBwZXJpb2RpY2FsbHlQdWJsaXNoU3RhdHMocm9vbVYyLCB0cmFuc3BvcnQsIGludGVydmFsTXMpIHtcbiAgICB2YXIgbW92aW5nQXZlcmFnZURlbHRhcyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgb2RkUHVibGlzaENvdW50ID0gZmFsc2U7XG4gICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICByb29tVjIuZ2V0U3RhdHMoKS50aGVuKGZ1bmN0aW9uIChzdGF0cykge1xuICAgICAgICAgICAgb2RkUHVibGlzaENvdW50ID0gIW9kZFB1Ymxpc2hDb3VudDtcbiAgICAgICAgICAgIHN0YXRzLmZvckVhY2goZnVuY3Rpb24gKHJlc3BvbnNlLCBpZCkge1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IEEgU3RhdHNSZXBvcnQgaXMgdXNlZCB0byBwdWJsaXNoIGEgXCJzdGF0cy1yZXBvcnRcIlxuICAgICAgICAgICAgICAgIC8vIGV2ZW50IGluc3RlYWQgb2YgdXNpbmcgU3RhbmRhcmRpemVkU3RhdHNSZXNwb25zZSBkaXJlY3RseSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gU3RhdHNSZXBvcnQgd2lsbCBhZGQgemVyb3MgdG8gcHJvcGVydGllcyB0aGF0IGRvIG5vdCBleGlzdC5cbiAgICAgICAgICAgICAgICB2YXIgcmVwb3J0ID0gbmV3IFN0YXRzUmVwb3J0KGlkLCByZXNwb25zZSwgdHJ1ZSAvKiBwcmVwYXJlRm9ySW5zaWdodHMgKi8pO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFNpbmNlIEEvViBzeW5jIG1ldHJpY3MgYXJlIG5vdCBwYXJ0IG9mIHRoZSBTdGF0c1JlcG9ydCBjbGFzcyxcbiAgICAgICAgICAgICAgICAvLyB3ZSBhZGQgdGhlbSB0byB0aGUgaW5zaWdodHMgcGF5bG9hZCBoZXJlLlxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5wdWJsaXNoRXZlbnQoJ3F1YWxpdHknLCAnc3RhdHMtcmVwb3J0JywgJ2luZm8nLCB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2tTdGF0czogcmVwb3J0LnJlbW90ZUF1ZGlvVHJhY2tTdGF0cy5tYXAoZnVuY3Rpb24gKHRyYWNrU3RhdCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZEFWU3luY01ldHJpY3NUb1JlbW90ZVRyYWNrU3RhdHModHJhY2tTdGF0LCByZXNwb25zZS5yZW1vdGVBdWRpb1RyYWNrU3RhdHNbaV0sIG1vdmluZ0F2ZXJhZ2VEZWx0YXMpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxBdWRpb1RyYWNrU3RhdHM6IHJlcG9ydC5sb2NhbEF1ZGlvVHJhY2tTdGF0cy5tYXAoZnVuY3Rpb24gKHRyYWNrU3RhdCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZEFWU3luY01ldHJpY3NUb0xvY2FsVHJhY2tTdGF0cyh0cmFja1N0YXQsIHJlc3BvbnNlLmxvY2FsQXVkaW9UcmFja1N0YXRzW2ldLCBtb3ZpbmdBdmVyYWdlRGVsdGFzKTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsVmlkZW9UcmFja1N0YXRzOiByZXBvcnQubG9jYWxWaWRlb1RyYWNrU3RhdHMubWFwKGZ1bmN0aW9uICh0cmFja1N0YXQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRBVlN5bmNNZXRyaWNzVG9Mb2NhbFRyYWNrU3RhdHModHJhY2tTdGF0LCByZXNwb25zZS5sb2NhbFZpZGVvVHJhY2tTdGF0c1tpXSwgbW92aW5nQXZlcmFnZURlbHRhcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBwZWVyQ29ubmVjdGlvbklkOiByZXBvcnQucGVlckNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9UcmFja1N0YXRzOiByZXBvcnQucmVtb3RlVmlkZW9UcmFja1N0YXRzLm1hcChmdW5jdGlvbiAodHJhY2tTdGF0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkQVZTeW5jTWV0cmljc1RvUmVtb3RlVHJhY2tTdGF0cyh0cmFja1N0YXQsIHJlc3BvbnNlLnJlbW90ZVZpZGVvVHJhY2tTdGF0c1tpXSwgbW92aW5nQXZlcmFnZURlbHRhcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IENsZWFuIHVwIGVudHJpZXMgZm9yIFRyYWNrcyB0aGF0IGFyZSBubyBsb25nZXIgcHVibGlzaGVkIG9yIHN1YnNjcmliZWQgdG8uXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBmbGF0TWFwKFtcbiAgICAgICAgICAgICAgICAgICAgJ2xvY2FsQXVkaW9UcmFja1N0YXRzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2xvY2FsVmlkZW9UcmFja1N0YXRzJyxcbiAgICAgICAgICAgICAgICAgICAgJ3JlbW90ZUF1ZGlvVHJhY2tTdGF0cycsXG4gICAgICAgICAgICAgICAgICAgICdyZW1vdGVWaWRlb1RyYWNrU3RhdHMnXG4gICAgICAgICAgICAgICAgXSwgZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHJlcG9ydFtwcm9wXS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzc3JjID0gX2Euc3NyYywgdHJhY2tTaWQgPSBfYS50cmFja1NpZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNrU2lkICsgXCIrXCIgKyBzc3JjO1xuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbW92aW5nQXZlcmFnZURlbHRhS2V5c1RvQmVSZW1vdmVkID0gZGlmZmVyZW5jZShBcnJheS5mcm9tKG1vdmluZ0F2ZXJhZ2VEZWx0YXMua2V5cygpKSwga2V5cyk7XG4gICAgICAgICAgICAgICAgbW92aW5nQXZlcmFnZURlbHRhS2V5c1RvQmVSZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbW92aW5nQXZlcmFnZURlbHRhcy5kZWxldGUoa2V5KTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG9kZFB1Ymxpc2hDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBudWxsIHByb3BlcnRpZXMgb2YgdGhlIFwiYWN0aXZlLWljZS1jYW5kaWRhdGUtcGFpclwiXG4gICAgICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgYXJlIGFzc2lnbmVkIGRlZmF1bHQgdmFsdWVzIHVudGlsIHRoZSBJbnNpZ2h0cyBnYXRld2F5XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY2VwdHMgbnVsbCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVJY2VDYW5kaWRhdGVQYWlyID0gcmVwbGFjZU51bGxzV2l0aERlZmF1bHRzKHJlc3BvbnNlLmFjdGl2ZUljZUNhbmRpZGF0ZVBhaXIsIHJlcG9ydC5wZWVyQ29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnB1Ymxpc2hFdmVudCgncXVhbGl0eScsICdhY3RpdmUtaWNlLWNhbmRpZGF0ZS1wYWlyJywgJ2luZm8nLCBhY3RpdmVJY2VDYW5kaWRhdGVQYWlyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgfSk7XG4gICAgfSwgaW50ZXJ2YWxNcyk7XG4gICAgcm9vbVYyLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbiBvblN0YXRlQ2hhbmdlZChzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgIHJvb21WMi5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgb25TdGF0ZUNoYW5nZWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVTdWJzY3JpcHRpb25zKHJvb20pIHtcbiAgICB2YXIgdHJhY2tTaWRzVG9UcmFja1NpZ25hbGluZ3MgPSByb29tLl9nZXRUcmFja1NpZHNUb1RyYWNrU2lnbmFsaW5ncygpO1xuICAgIHJvb20uX3N1YnNjcmlwdGlvbkZhaWx1cmVzLmZvckVhY2goZnVuY3Rpb24gKGVycm9yLCB0cmFja1NpZCkge1xuICAgICAgICB2YXIgdHJhY2tTaWduYWxpbmcgPSB0cmFja1NpZHNUb1RyYWNrU2lnbmFsaW5ncy5nZXQodHJhY2tTaWQpO1xuICAgICAgICBpZiAodHJhY2tTaWduYWxpbmcpIHtcbiAgICAgICAgICAgIHJvb20uX3N1YnNjcmlwdGlvbkZhaWx1cmVzLmRlbGV0ZSh0cmFja1NpZCk7XG4gICAgICAgICAgICB0cmFja1NpZ25hbGluZy5zdWJzY3JpYmVGYWlsZWQoY3JlYXRlVHdpbGlvRXJyb3IoZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdHJhY2tTaWRzVG9UcmFja1NpZ25hbGluZ3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tTaWduYWxpbmcpIHtcbiAgICAgICAgdmFyIHRyYWNrSWQgPSByb29tLl9zdWJzY3JpYmVkLmdldCh0cmFja1NpZ25hbGluZy5zaWQpO1xuICAgICAgICBpZiAoIXRyYWNrSWQgfHwgKHRyYWNrU2lnbmFsaW5nLmlzU3Vic2NyaWJlZCAmJiB0cmFja1NpZ25hbGluZy50cmFja1RyYW5zY2VpdmVyLmlkICE9PSB0cmFja0lkKSkge1xuICAgICAgICAgICAgdHJhY2tTaWduYWxpbmcuc2V0VHJhY2tUcmFuc2NlaXZlcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2tJZCkge1xuICAgICAgICAgICAgcm9vbS5fZ2V0VHJhY2tSZWNlaXZlcih0cmFja0lkKS50aGVuKGZ1bmN0aW9uICh0cmFja1JlY2VpdmVyKSB7IHJldHVybiB0cmFja1NpZ25hbGluZy5zZXRUcmFja1RyYW5zY2VpdmVyKHRyYWNrUmVjZWl2ZXIpOyB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBOT1RFKG1tYWxhdmFsbGkpOiBTaW5jZSBBL1Ygc3luYyBtZXRyaWNzIGFyZSBub3QgcGFydCBvZiB0aGUgcHVibGljIFN0YXRzUmVwb3J0IGNsYXNzLCB3ZSBhZGQgdGhlbVxuICogb25seSBmb3IgcmVwb3J0aW5nIHB1cnBvc2VzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkQVZTeW5jTWV0cmljc1RvTG9jYWxUcmFja1N0YXRzKHRyYWNrU3RhdHMsIHRyYWNrUmVzcG9uc2UsIG1vdmluZ0F2ZXJhZ2VEZWx0YXMpIHtcbiAgICB2YXIgZnJhbWVzRW5jb2RlZCA9IHRyYWNrUmVzcG9uc2UuZnJhbWVzRW5jb2RlZCwgcGFja2V0c1NlbnQgPSB0cmFja1Jlc3BvbnNlLnBhY2tldHNTZW50LCB0b3RhbEVuY29kZVRpbWUgPSB0cmFja1Jlc3BvbnNlLnRvdGFsRW5jb2RlVGltZSwgdG90YWxQYWNrZXRTZW5kRGVsYXkgPSB0cmFja1Jlc3BvbnNlLnRvdGFsUGFja2V0U2VuZERlbGF5O1xuICAgIHZhciBhdWdtZW50ZWRUcmFja1N0YXRzID0gT2JqZWN0LmFzc2lnbih7fSwgdHJhY2tTdGF0cyk7XG4gICAgdmFyIGtleSA9IHRyYWNrU3RhdHMudHJhY2tTaWQgKyBcIitcIiArIHRyYWNrU3RhdHMuc3NyYztcbiAgICB2YXIgdHJhY2tNb3ZpbmdBdmVyYWdlRGVsdGFzID0gbW92aW5nQXZlcmFnZURlbHRhcy5nZXQoa2V5KSB8fCBuZXcgTWFwKCk7XG4gICAgaWYgKHR5cGVvZiB0b3RhbEVuY29kZVRpbWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBmcmFtZXNFbmNvZGVkID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgdHJhY2tBdmdFbmNvZGVEZWxheU1vdmluZ0F2ZXJhZ2VEZWx0YSA9IHRyYWNrTW92aW5nQXZlcmFnZURlbHRhcy5nZXQoJ2F2Z0VuY29kZURlbGF5JylcbiAgICAgICAgICAgIHx8IG5ldyBNb3ZpbmdBdmVyYWdlRGVsdGEoKTtcbiAgICAgICAgdHJhY2tBdmdFbmNvZGVEZWxheU1vdmluZ0F2ZXJhZ2VEZWx0YS5wdXRTYW1wbGUodG90YWxFbmNvZGVUaW1lICogMTAwMCwgZnJhbWVzRW5jb2RlZCk7XG4gICAgICAgIGF1Z21lbnRlZFRyYWNrU3RhdHMuYXZnRW5jb2RlRGVsYXkgPSBNYXRoLnJvdW5kKHRyYWNrQXZnRW5jb2RlRGVsYXlNb3ZpbmdBdmVyYWdlRGVsdGEuZ2V0KCkpO1xuICAgICAgICB0cmFja01vdmluZ0F2ZXJhZ2VEZWx0YXMuc2V0KCdhdmdFbmNvZGVEZWxheScsIHRyYWNrQXZnRW5jb2RlRGVsYXlNb3ZpbmdBdmVyYWdlRGVsdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRvdGFsUGFja2V0U2VuZERlbGF5ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcGFja2V0c1NlbnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciB0cmFja0F2Z1BhY2tldFNlbmREZWxheU1vdmluZ0F2ZXJhZ2VEZWx0YSA9IHRyYWNrTW92aW5nQXZlcmFnZURlbHRhcy5nZXQoJ2F2Z1BhY2tldFNlbmREZWxheScpXG4gICAgICAgICAgICB8fCBuZXcgTW92aW5nQXZlcmFnZURlbHRhKCk7XG4gICAgICAgIHRyYWNrQXZnUGFja2V0U2VuZERlbGF5TW92aW5nQXZlcmFnZURlbHRhLnB1dFNhbXBsZSh0b3RhbFBhY2tldFNlbmREZWxheSAqIDEwMDAsIHBhY2tldHNTZW50KTtcbiAgICAgICAgYXVnbWVudGVkVHJhY2tTdGF0cy5hdmdQYWNrZXRTZW5kRGVsYXkgPSBNYXRoLnJvdW5kKHRyYWNrQXZnUGFja2V0U2VuZERlbGF5TW92aW5nQXZlcmFnZURlbHRhLmdldCgpKTtcbiAgICAgICAgdHJhY2tNb3ZpbmdBdmVyYWdlRGVsdGFzLnNldCgnYXZnUGFja2V0U2VuZERlbGF5JywgdHJhY2tBdmdQYWNrZXRTZW5kRGVsYXlNb3ZpbmdBdmVyYWdlRGVsdGEpO1xuICAgIH1cbiAgICBtb3ZpbmdBdmVyYWdlRGVsdGFzLnNldChrZXksIHRyYWNrTW92aW5nQXZlcmFnZURlbHRhcyk7XG4gICAgcmV0dXJuIGF1Z21lbnRlZFRyYWNrU3RhdHM7XG59XG4vKipcbiAqIE5PVEUobW1hbGF2YWxsaSk6IFNpbmNlIEEvViBzeW5jIG1ldHJpY3MgYXJlIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgU3RhdHNSZXBvcnQgY2xhc3MsIHdlIGFkZCB0aGVtXG4gKiBvbmx5IGZvciByZXBvcnRpbmcgcHVycG9zZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRBVlN5bmNNZXRyaWNzVG9SZW1vdGVUcmFja1N0YXRzKHRyYWNrU3RhdHMsIHRyYWNrUmVzcG9uc2UsIG1vdmluZ0F2ZXJhZ2VEZWx0YXMpIHtcbiAgICB2YXIgZXN0aW1hdGVkUGxheW91dFRpbWVzdGFtcCA9IHRyYWNrUmVzcG9uc2UuZXN0aW1hdGVkUGxheW91dFRpbWVzdGFtcCwgZnJhbWVzRGVjb2RlZCA9IHRyYWNrUmVzcG9uc2UuZnJhbWVzRGVjb2RlZCwgaml0dGVyQnVmZmVyRGVsYXkgPSB0cmFja1Jlc3BvbnNlLmppdHRlckJ1ZmZlckRlbGF5LCBqaXR0ZXJCdWZmZXJFbWl0dGVkQ291bnQgPSB0cmFja1Jlc3BvbnNlLmppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudCwgdG90YWxEZWNvZGVUaW1lID0gdHJhY2tSZXNwb25zZS50b3RhbERlY29kZVRpbWU7XG4gICAgdmFyIGF1Z21lbnRlZFRyYWNrU3RhdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0cmFja1N0YXRzKTtcbiAgICB2YXIga2V5ID0gdHJhY2tTdGF0cy50cmFja1NpZCArIFwiK1wiICsgdHJhY2tTdGF0cy5zc3JjO1xuICAgIHZhciB0cmFja01vdmluZ0F2ZXJhZ2VEZWx0YXMgPSBtb3ZpbmdBdmVyYWdlRGVsdGFzLmdldChrZXkpIHx8IG5ldyBNYXAoKTtcbiAgICBpZiAodHlwZW9mIGVzdGltYXRlZFBsYXlvdXRUaW1lc3RhbXAgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGF1Z21lbnRlZFRyYWNrU3RhdHMuZXN0aW1hdGVkUGxheW91dFRpbWVzdGFtcCA9IGVzdGltYXRlZFBsYXlvdXRUaW1lc3RhbXA7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZnJhbWVzRGVjb2RlZCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHRvdGFsRGVjb2RlVGltZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHRyYWNrQXZnRGVjb2RlRGVsYXlNb3ZpbmdBdmVyYWdlRGVsdGEgPSB0cmFja01vdmluZ0F2ZXJhZ2VEZWx0YXMuZ2V0KCdhdmdEZWNvZGVEZWxheScpXG4gICAgICAgICAgICB8fCBuZXcgTW92aW5nQXZlcmFnZURlbHRhKCk7XG4gICAgICAgIHRyYWNrQXZnRGVjb2RlRGVsYXlNb3ZpbmdBdmVyYWdlRGVsdGEucHV0U2FtcGxlKHRvdGFsRGVjb2RlVGltZSAqIDEwMDAsIGZyYW1lc0RlY29kZWQpO1xuICAgICAgICBhdWdtZW50ZWRUcmFja1N0YXRzLmF2Z0RlY29kZURlbGF5ID0gTWF0aC5yb3VuZCh0cmFja0F2Z0RlY29kZURlbGF5TW92aW5nQXZlcmFnZURlbHRhLmdldCgpKTtcbiAgICAgICAgdHJhY2tNb3ZpbmdBdmVyYWdlRGVsdGFzLnNldCgnYXZnRGVjb2RlRGVsYXknLCB0cmFja0F2Z0RlY29kZURlbGF5TW92aW5nQXZlcmFnZURlbHRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqaXR0ZXJCdWZmZXJEZWxheSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHRyYWNrQXZnSml0dGVyQnVmZmVyRGVsYXlNb3ZpbmdBdmVyYWdlRGVsdGEgPSB0cmFja01vdmluZ0F2ZXJhZ2VEZWx0YXMuZ2V0KCdhdmdKaXR0ZXJCdWZmZXJEZWxheScpXG4gICAgICAgICAgICB8fCBuZXcgTW92aW5nQXZlcmFnZURlbHRhKCk7XG4gICAgICAgIHRyYWNrQXZnSml0dGVyQnVmZmVyRGVsYXlNb3ZpbmdBdmVyYWdlRGVsdGEucHV0U2FtcGxlKGppdHRlckJ1ZmZlckRlbGF5ICogMTAwMCwgaml0dGVyQnVmZmVyRW1pdHRlZENvdW50KTtcbiAgICAgICAgYXVnbWVudGVkVHJhY2tTdGF0cy5hdmdKaXR0ZXJCdWZmZXJEZWxheSA9IE1hdGgucm91bmQodHJhY2tBdmdKaXR0ZXJCdWZmZXJEZWxheU1vdmluZ0F2ZXJhZ2VEZWx0YS5nZXQoKSk7XG4gICAgICAgIHRyYWNrTW92aW5nQXZlcmFnZURlbHRhcy5zZXQoJ2F2Z0ppdHRlckJ1ZmZlckRlbGF5JywgdHJhY2tBdmdKaXR0ZXJCdWZmZXJEZWxheU1vdmluZ0F2ZXJhZ2VEZWx0YSk7XG4gICAgfVxuICAgIG1vdmluZ0F2ZXJhZ2VEZWx0YXMuc2V0KGtleSwgdHJhY2tNb3ZpbmdBdmVyYWdlRGVsdGFzKTtcbiAgICByZXR1cm4gYXVnbWVudGVkVHJhY2tTdGF0cztcbn1cbmZ1bmN0aW9uIHJlcGxhY2VOdWxsc1dpdGhEZWZhdWx0cyhhY3RpdmVJY2VDYW5kaWRhdGVQYWlyLCBwZWVyQ29ubmVjdGlvbklkKSB7XG4gICAgYWN0aXZlSWNlQ2FuZGlkYXRlUGFpciA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBhdmFpbGFibGVJbmNvbWluZ0JpdHJhdGU6IDAsXG4gICAgICAgIGF2YWlsYWJsZU91dGdvaW5nQml0cmF0ZTogMCxcbiAgICAgICAgYnl0ZXNSZWNlaXZlZDogMCxcbiAgICAgICAgYnl0ZXNTZW50OiAwLFxuICAgICAgICBjb25zZW50UmVxdWVzdHNTZW50OiAwLFxuICAgICAgICBjdXJyZW50Um91bmRUcmlwVGltZTogMCxcbiAgICAgICAgbGFzdFBhY2tldFJlY2VpdmVkVGltZXN0YW1wOiAwLFxuICAgICAgICBsYXN0UGFja2V0U2VudFRpbWVzdGFtcDogMCxcbiAgICAgICAgbm9taW5hdGVkOiBmYWxzZSxcbiAgICAgICAgcGVlckNvbm5lY3Rpb25JZDogcGVlckNvbm5lY3Rpb25JZCxcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIHJlYWRhYmxlOiBmYWxzZSxcbiAgICAgICAgcmVxdWVzdHNSZWNlaXZlZDogMCxcbiAgICAgICAgcmVxdWVzdHNTZW50OiAwLFxuICAgICAgICByZXNwb25zZXNSZWNlaXZlZDogMCxcbiAgICAgICAgcmVzcG9uc2VzU2VudDogMCxcbiAgICAgICAgcmV0cmFuc21pc3Npb25zUmVjZWl2ZWQ6IDAsXG4gICAgICAgIHJldHJhbnNtaXNzaW9uc1NlbnQ6IDAsXG4gICAgICAgIHN0YXRlOiAnZmFpbGVkJyxcbiAgICAgICAgdG90YWxSb3VuZFRyaXBUaW1lOiAwLFxuICAgICAgICB0cmFuc3BvcnRJZDogJycsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0sIGZpbHRlck9iamVjdChhY3RpdmVJY2VDYW5kaWRhdGVQYWlyIHx8IHt9LCBudWxsKSk7XG4gICAgYWN0aXZlSWNlQ2FuZGlkYXRlUGFpci5sb2NhbENhbmRpZGF0ZSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjYW5kaWRhdGVUeXBlOiAnaG9zdCcsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBpcDogJycsXG4gICAgICAgIHBvcnQ6IDAsXG4gICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICBwcm90b2NvbDogJ3VkcCcsXG4gICAgICAgIHVybDogJydcbiAgICB9LCBmaWx0ZXJPYmplY3QoYWN0aXZlSWNlQ2FuZGlkYXRlUGFpci5sb2NhbENhbmRpZGF0ZSB8fCB7fSwgbnVsbCkpO1xuICAgIGFjdGl2ZUljZUNhbmRpZGF0ZVBhaXIucmVtb3RlQ2FuZGlkYXRlID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNhbmRpZGF0ZVR5cGU6ICdob3N0JyxcbiAgICAgICAgaXA6ICcnLFxuICAgICAgICBwb3J0OiAwLFxuICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgcHJvdG9jb2w6ICd1ZHAnLFxuICAgICAgICB1cmw6ICcnXG4gICAgfSwgZmlsdGVyT2JqZWN0KGFjdGl2ZUljZUNhbmRpZGF0ZVBhaXIucmVtb3RlQ2FuZGlkYXRlIHx8IHt9LCBudWxsKSk7XG4gICAgcmV0dXJuIGFjdGl2ZUljZUNhbmRpZGF0ZVBhaXI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IFJvb21WMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvb20uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBNZWRpYVNpZ25hbGluZyA9IHJlcXVpcmUoJy4vbWVkaWFzaWduYWxpbmcnKTtcbnZhciBUcmFja1ByaW9yaXR5U2lnbmFsaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFja1ByaW9yaXR5U2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBUcmFja1ByaW9yaXR5U2lnbmFsaW5nfS5cbiAgICAgKiBAcGFyYW0ge1Byb21pc2U8RGF0YVRyYWNrUmVjZWl2ZXI+fSBnZXRSZWNlaXZlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYWNrUHJpb3JpdHlTaWduYWxpbmcoZ2V0UmVjZWl2ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ2V0UmVjZWl2ZXIsICd0cmFja19wcmlvcml0eScsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfZW5xdWV1ZWRQcmlvcml0eVVwZGF0ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMub24oJ3JlYWR5JywgZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgQXJyYXkuZnJvbShfdGhpcy5fZW5xdWV1ZWRQcmlvcml0eVVwZGF0ZXMua2V5cygpKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja1NpZCkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RyYWNrX3ByaW9yaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2s6IHRyYWNrU2lkLFxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IF90aGlzLl9lbnF1ZXVlZFByaW9yaXR5VXBkYXRlcy5nZXQodHJhY2tTaWQpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gTk9URShtcGF0d2FyZGhhbiktIHdlIGRvIG5vdCBjbGVhciBfZW5xdWV1ZWRQcmlvcml0eVVwZGF0ZXMgaW50ZW50aW9uYWxseSxcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNhY2hlIHdpbGwgaXMgdXNlZCB0byByZS1zZW5kIHRoZSBwcmlvcml0aWVzIGluIGNhc2Ugb2YgVk1TLUZhaWxPdmVyLlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VHJhY2suU0lEfSB0cmFja1NpZFxuICAgICAqIEBwYXJhbSB7J3B1Ymxpc2gnfCdzdWJzY3JpYmUnfSBwdWJsaXNoT3JTdWJzY3JpYmVcbiAgICAgKiBAcGFyYW0ge1RyYWNrLlByaW9yaXR5fSBwcmlvcml0eVxuICAgICAqL1xuICAgIFRyYWNrUHJpb3JpdHlTaWduYWxpbmcucHJvdG90eXBlLnNlbmRUcmFja1ByaW9yaXR5VXBkYXRlID0gZnVuY3Rpb24gKHRyYWNrU2lkLCBwdWJsaXNoT3JTdWJzY3JpYmUsIHByaW9yaXR5KSB7XG4gICAgICAgIGlmIChwdWJsaXNoT3JTdWJzY3JpYmUgIT09ICdzdWJzY3JpYmUnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgc3Vic2NyaWJlIHByaW9yaXRpZXMgYXJlIHN1cHBvcnRlZCwgZm91bmQ6ICcgKyBwdWJsaXNoT3JTdWJzY3JpYmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VucXVldWVkUHJpb3JpdHlVcGRhdGVzLnNldCh0cmFja1NpZCwgcHJpb3JpdHkpO1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc3BvcnQucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RyYWNrX3ByaW9yaXR5JyxcbiAgICAgICAgICAgICAgICB0cmFjazogdHJhY2tTaWQsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlOiBwcmlvcml0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUcmFja1ByaW9yaXR5U2lnbmFsaW5nO1xufShNZWRpYVNpZ25hbGluZykpO1xubW9kdWxlLmV4cG9ydHMgPSBUcmFja1ByaW9yaXR5U2lnbmFsaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2twcmlvcml0eXNpZ25hbGluZy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIE1lZGlhU2lnbmFsaW5nID0gcmVxdWlyZSgnLi9tZWRpYXNpZ25hbGluZycpO1xuLyoqXG4gKiBAZW1pdHMgVHJhY2tTd2l0Y2hPZmZTaWduYWxpbmdpbmcjdXBkYXRlZFxuICovXG52YXIgVHJhY2tTd2l0Y2hPZmZTaWduYWxpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYWNrU3dpdGNoT2ZmU2lnbmFsaW5nLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBUcmFja1N3aXRjaE9mZlNpZ25hbGluZ30uXG4gICAgICogQHBhcmFtIHtQcm9taXNlPERhdGFUcmFja1JlY2VpdmVyPn0gZ2V0UmVjZWl2ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFja1N3aXRjaE9mZlNpZ25hbGluZyhnZXRSZWNlaXZlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBnZXRSZWNlaXZlciwgJ3RyYWNrX3N3aXRjaF9vZmYnLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vbigncmVhZHknLCBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RyYWNrX3N3aXRjaF9vZmYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldFRyYWNrU3dpdGNoT2ZmVXBkYXRlcyhtZXNzYWdlLm9mZiB8fCBbXSwgbWVzc2FnZS5vbiB8fCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7W1RyYWNrLlNJRF19IHRyYWNrc1N3aXRjaGVkT2ZmXG4gICAgICogQHBhcmFtIHtbVHJhY2suU0lEXX0gdHJhY2tzU3dpdGNoZWRPblxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFRyYWNrU3dpdGNoT2ZmU2lnbmFsaW5nLnByb3RvdHlwZS5fc2V0VHJhY2tTd2l0Y2hPZmZVcGRhdGVzID0gZnVuY3Rpb24gKHRyYWNrc1N3aXRjaGVkT2ZmLCB0cmFja3NTd2l0Y2hlZE9uKSB7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlZCcsIHRyYWNrc1N3aXRjaGVkT2ZmLCB0cmFja3NTd2l0Y2hlZE9uKTtcbiAgICB9O1xuICAgIHJldHVybiBUcmFja1N3aXRjaE9mZlNpZ25hbGluZztcbn0oTWVkaWFTaWduYWxpbmcpKTtcbi8qKlxuICogQGV2ZW50IFRyYWNrU3dpdGNoT2ZmU2lnbmFsaW5nI3VwZGF0ZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBUcmFja1N3aXRjaE9mZlNpZ25hbGluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNrc3dpdGNob2Zmc2lnbmFsaW5nLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgZ2V0U2RwRm9ybWF0ID0gcmVxdWlyZSgnQHR3aWxpby93ZWJydGMvbGliL3V0aWwvc2RwJykuZ2V0U2RwRm9ybWF0O1xudmFyIHBhY2thZ2VJbmZvID0gcmVxdWlyZSgnLi4vLi4vLi4vcGFja2FnZS5qc29uJyk7XG52YXIgSW5zaWdodHNQdWJsaXNoZXIgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luc2lnaHRzcHVibGlzaGVyJyk7XG52YXIgTnVsbEluc2lnaHRzUHVibGlzaGVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbnNpZ2h0c3B1Ymxpc2hlci9udWxsJyk7XG52YXIgU3RhdGVNYWNoaW5lID0gcmVxdWlyZSgnLi4vLi4vc3RhdGVtYWNoaW5lJyk7XG52YXIgVHdpbGlvQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R3aWxpb2Nvbm5lY3Rpb24nKTtcbnZhciBEZWZhdWx0QmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvZmYnKTtcbnZhciByZWNvbm5lY3RCYWNrb2ZmQ29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25zdGFudHMnKS5yZWNvbm5lY3RCYWNrb2ZmQ29uZmlnO1xudmFyIFRpbWVvdXQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3RpbWVvdXQnKTtcbnZhciBfYSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKSwgY3JlYXRlQmFuZHdpZHRoUHJvZmlsZVBheWxvYWQgPSBfYS5jcmVhdGVCYW5kd2lkdGhQcm9maWxlUGF5bG9hZCwgY3JlYXRlTWVkaWFTaWduYWxpbmdQYXlsb2FkID0gX2EuY3JlYXRlTWVkaWFTaWduYWxpbmdQYXlsb2FkLCBjcmVhdGVTdWJzY3JpYmVQYXlsb2FkID0gX2EuY3JlYXRlU3Vic2NyaWJlUGF5bG9hZCwgZ2V0VXNlckFnZW50ID0gX2EuZ2V0VXNlckFnZW50LCBpc05vbkFycmF5T2JqZWN0ID0gX2EuaXNOb25BcnJheU9iamVjdDtcbnZhciBfYiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdHdpbGlvLXZpZGVvLWVycm9ycycpLCBjcmVhdGVUd2lsaW9FcnJvciA9IF9iLmNyZWF0ZVR3aWxpb0Vycm9yLCBSb29tQ29tcGxldGVkRXJyb3IgPSBfYi5Sb29tQ29tcGxldGVkRXJyb3IsIFNpZ25hbGluZ0Nvbm5lY3Rpb25FcnJvciA9IF9iLlNpZ25hbGluZ0Nvbm5lY3Rpb25FcnJvciwgU2lnbmFsaW5nU2VydmVyQnVzeUVycm9yID0gX2IuU2lnbmFsaW5nU2VydmVyQnVzeUVycm9yO1xudmFyIElDRV9WRVJTSU9OID0gMTtcbnZhciBSU1BfVkVSU0lPTiA9IDI7XG52YXIgU0RLX05BTUUgPSBwYWNrYWdlSW5mby5uYW1lICsgXCIuanNcIjtcbnZhciBTREtfVkVSU0lPTiA9IHBhY2thZ2VJbmZvLnZlcnNpb247XG4vKlxuVHdpbGlvQ29ubmVjdGlvblRyYW5zcG9ydCBTdGF0ZXNcbi0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgfCAgc3luY2luZyAgfC0tLS0tLS0tLStcbiAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLSsgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgXiAgICAgfCAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8ICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHYgICAgICAgICAgICB2XG4gICAgKy0tLS0tLS0tLS0tLSsgICAgKy0tLS0tLS0tLS0tKyAgICArLS0tLS0tLS0tLS0tLS0rXG4gICAgfCAgICAgICAgICAgIHwgICAgfCAgICAgICAgICAgfCAgICB8ICAgICAgICAgICAgICB8XG4gICAgfCBjb25uZWN0aW5nIHwtLS0+fCBjb25uZWN0ZWQgfC0tLT58IGRpc2Nvbm5lY3RlZCB8XG4gICAgfCAgICAgICAgICAgIHwgICAgfCAgICAgICAgICAgfCAgICB8ICAgICAgICAgICAgICB8XG4gICAgKy0tLS0tLS0tLS0tLSsgICAgKy0tLS0tLS0tLS0tKyAgICArLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcblxuKi9cbnZhciBzdGF0ZXMgPSB7XG4gICAgY29ubmVjdGluZzogW1xuICAgICAgICAnY29ubmVjdGVkJyxcbiAgICAgICAgJ2Rpc2Nvbm5lY3RlZCdcbiAgICBdLFxuICAgIGNvbm5lY3RlZDogW1xuICAgICAgICAnZGlzY29ubmVjdGVkJyxcbiAgICAgICAgJ3N5bmNpbmcnXG4gICAgXSxcbiAgICBzeW5jaW5nOiBbXG4gICAgICAgICdjb25uZWN0ZWQnLFxuICAgICAgICAnZGlzY29ubmVjdGVkJ1xuICAgIF0sXG4gICAgZGlzY29ubmVjdGVkOiBbXVxufTtcbi8qKlxuICogQSB7QGxpbmsgVHdpbGlvQ29ubmVjdGlvblRyYW5zcG9ydH0gc3VwcG9ydHMgc2VuZGluZyBhbmQgcmVjZWl2aW5nIFJvb20gU2lnbmFsaW5nIFByb3RvY29sXG4gKiAoUlNQKSBtZXNzYWdlcy4gSXQgYWxzbyBzdXBwb3J0cyBSU1AgcmVxdWVzdHMsIHN1Y2ggYXMgU3luYyBhbmQgRGlzY29ubmVjdC5cbiAqIEBleHRlbmRzIFN0YXRlTWFjaGluZVxuICogQGVtaXRzIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQjY29ubmVjdGVkXG4gKiBAZW1pdHMgVHdpbGlvQ29ubmVjdGlvblRyYW5zcG9ydCNtZXNzYWdlXG4gKi9cbnZhciBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0fS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW5cbiAgICAgKiBAcGFyYW0ge1BhcnRpY2lwYW50U2lnbmFsaW5nfSBsb2NhbFBhcnRpY2lwYW50XG4gICAgICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvbk1hbmFnZXJ9IHBlZXJDb25uZWN0aW9uTWFuYWdlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3c1NlcnZlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0KG5hbWUsIGFjY2Vzc1Rva2VuLCBsb2NhbFBhcnRpY2lwYW50LCBwZWVyQ29ubmVjdGlvbk1hbmFnZXIsIHdzU2VydmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIEJhY2tvZmY6IERlZmF1bHRCYWNrb2ZmLFxuICAgICAgICAgICAgSW5zaWdodHNQdWJsaXNoZXI6IEluc2lnaHRzUHVibGlzaGVyLFxuICAgICAgICAgICAgTnVsbEluc2lnaHRzUHVibGlzaGVyOiBOdWxsSW5zaWdodHNQdWJsaXNoZXIsXG4gICAgICAgICAgICBUd2lsaW9Db25uZWN0aW9uOiBUd2lsaW9Db25uZWN0aW9uLFxuICAgICAgICAgICAgaWNlU2VydmVyczogbnVsbCxcbiAgICAgICAgICAgIHNkcEZvcm1hdDogZ2V0U2RwRm9ybWF0KG9wdGlvbnMuc2RwU2VtYW50aWNzKSxcbiAgICAgICAgICAgIHRyYWNrUHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgICB0cmFja1N3aXRjaE9mZjogdHJ1ZSxcbiAgICAgICAgICAgIHJlbmRlckhpbnRzOiB0cnVlLFxuICAgICAgICAgICAgdXNlckFnZW50OiBnZXRVc2VyQWdlbnQoKVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnY29ubmVjdGluZycsIHN0YXRlcykgfHwgdGhpcztcbiAgICAgICAgdmFyIGV2ZW50UHVibGlzaGVyT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy53c1NlcnZlckluc2lnaHRzKSB7XG4gICAgICAgICAgICBldmVudFB1Ymxpc2hlck9wdGlvbnMuZ2F0ZXdheSA9IG9wdGlvbnMud3NTZXJ2ZXJJbnNpZ2h0cztcbiAgICAgICAgfVxuICAgICAgICB2YXIgRXZlbnRQdWJsaXNoZXIgPSBvcHRpb25zLmluc2lnaHRzID8gb3B0aW9ucy5JbnNpZ2h0c1B1Ymxpc2hlciA6IG9wdGlvbnMuTnVsbEluc2lnaHRzUHVibGlzaGVyO1xuICAgICAgICB2YXIgZXZlbnRQdWJsaXNoZXIgPSBuZXcgRXZlbnRQdWJsaXNoZXIoYWNjZXNzVG9rZW4sIFNES19OQU1FLCBTREtfVkVSU0lPTiwgb3B0aW9ucy5lbnZpcm9ubWVudCwgb3B0aW9ucy5yZWFsbSwgZXZlbnRQdWJsaXNoZXJPcHRpb25zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9hY2Nlc3NUb2tlbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBhY2Nlc3NUb2tlblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hdXRvbWF0aWNTdWJzY3JpcHRpb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5hdXRvbWF0aWNTdWJzY3JpcHRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYmFuZHdpZHRoUHJvZmlsZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZGlzY29ubmVjdEV2ZW50UHVibGlzaGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50UHVibGlzaGVyLmRpc2Nvbm5lY3QoKTsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kb21pbmFudFNwZWFrZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5kb21pbmFudFNwZWFrZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZXZlbnRPYnNlcnZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmV2ZW50T2JzZXJ2ZXIsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlbmRlckhpbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMucmVuZGVySGludHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaWNlU2VydmVyc1N0YXR1czoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBBcnJheS5pc0FycmF5KG9wdGlvbnMuaWNlU2VydmVycylcbiAgICAgICAgICAgICAgICAgICAgPyAnb3ZlcnJvZGUnXG4gICAgICAgICAgICAgICAgICAgIDogJ2FjcXVpcmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xvY2FsUGFydGljaXBhbnQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbG9jYWxQYXJ0aWNpcGFudFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX25ldHdvcmtRdWFsaXR5OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGlzTm9uQXJyYXlPYmplY3Qob3B0aW9ucy5uZXR3b3JrUXVhbGl0eSkgfHwgb3B0aW9ucy5uZXR3b3JrUXVhbGl0eVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcGVlckNvbm5lY3Rpb25NYW5hZ2VyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBlZXJDb25uZWN0aW9uTWFuYWdlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZXNzaW9uVGltZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZXNzaW9uVGltZW91dE1TOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVjb25uZWN0QmFja29mZjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLkJhY2tvZmYuZXhwb25lbnRpYWwocmVjb25uZWN0QmFja29mZkNvbmZpZylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2Vzc2lvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RyYWNrUHJpb3JpdHk6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy50cmFja1ByaW9yaXR5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RyYWNrU3dpdGNoT2ZmOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMudHJhY2tTd2l0Y2hPZmZcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdHdpbGlvQ29ubmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3VwZGF0ZXNSZWNlaXZlZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF91cGRhdGVzVG9TZW5kOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3VzZXJBZ2VudDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnVzZXJBZ2VudFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF93c1NlcnZlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB3c1NlcnZlclxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXdhcm5pbmctY29tbWVudHNcbiAgICAgICAgLy8gVE9ETyhtbWFsYXZhbGxpKTogQ3JlYXRlIGFuZCBzZXQgRXZlbnRQdWJsaXNoZXIgb3V0c2lkZSB0aGlzIGNsYXNzLCBzb1xuICAgICAgICAvLyB0aGF0IHRoZSBFdmVudFB1Ymxpc2hlciBjb25zdHJ1Y3RvciBpcyBubyBsb25nZXIgYSBkZXBlbmRlbmN5LlxuICAgICAgICBfdGhpcy5fZXZlbnRPYnNlcnZlci5zZXRQdWJsaXNoZXIoZXZlbnRQdWJsaXNoZXIpO1xuICAgICAgICBzZXR1cFRyYW5zcG9ydChfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uY2UoJ2Nvbm5lY3RlZCcsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHNpZCA9IF9hLnNpZCwgcGFydGljaXBhbnQgPSBfYS5wYXJ0aWNpcGFudDtcbiAgICAgICAgICAgIGV2ZW50UHVibGlzaGVyLmNvbm5lY3Qoc2lkLCBwYXJ0aWNpcGFudC5zaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBDb25uZWN0LCBTeW5jIG9yIERpc2Nvbm5lY3QgUlNQIG1lc3NhZ2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7P29iamVjdH1cbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0LnByb3RvdHlwZS5fY3JlYXRlQ29ubmVjdE9yU3luY09yRGlzY29ubmVjdE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNlc3Npb246IHRoaXMuX3Nlc3Npb24sXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Rpc2Nvbm5lY3QnLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IFJTUF9WRVJTSU9OXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0ge1xuICAgICAgICAgICAgY29ubmVjdGluZzogJ2Nvbm5lY3QnLFxuICAgICAgICAgICAgc3luY2luZzogJ3N5bmMnXG4gICAgICAgIH1bdGhpcy5zdGF0ZV07XG4gICAgICAgIHZhciBtZXNzYWdlID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5fbmFtZSxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50OiB0aGlzLl9sb2NhbFBhcnRpY2lwYW50LmdldFN0YXRlKCksXG4gICAgICAgICAgICBwZWVyX2Nvbm5lY3Rpb25zOiB0aGlzLl9wZWVyQ29ubmVjdGlvbk1hbmFnZXIuZ2V0U3RhdGVzKCksXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmVyc2lvbjogUlNQX1ZFUlNJT05cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ2Nvbm5lY3QnKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmljZV9zZXJ2ZXJzID0gdGhpcy5faWNlU2VydmVyc1N0YXR1cztcbiAgICAgICAgICAgIG1lc3NhZ2UucHVibGlzaGVyID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IFNES19OQU1FLFxuICAgICAgICAgICAgICAgIHNka192ZXJzaW9uOiBTREtfVkVSU0lPTixcbiAgICAgICAgICAgICAgICB1c2VyX2FnZW50OiB0aGlzLl91c2VyQWdlbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5fYmFuZHdpZHRoUHJvZmlsZSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmFuZHdpZHRoX3Byb2ZpbGUgPSBjcmVhdGVCYW5kd2lkdGhQcm9maWxlUGF5bG9hZCh0aGlzLl9iYW5kd2lkdGhQcm9maWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2UubWVkaWFfc2lnbmFsaW5nID0gY3JlYXRlTWVkaWFTaWduYWxpbmdQYXlsb2FkKHRoaXMuX2RvbWluYW50U3BlYWtlciwgdGhpcy5fbmV0d29ya1F1YWxpdHksIHRoaXMuX3RyYWNrUHJpb3JpdHksIHRoaXMuX3RyYWNrU3dpdGNoT2ZmLCB0aGlzLl9yZW5kZXJIaW50cyk7XG4gICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmliZSA9IGNyZWF0ZVN1YnNjcmliZVBheWxvYWQodGhpcy5fYXV0b21hdGljU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHZhciBzZHBGb3JtYXQgPSB0aGlzLl9vcHRpb25zLnNkcEZvcm1hdDtcbiAgICAgICAgICAgIGlmIChzZHBGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmZvcm1hdCA9IHNkcEZvcm1hdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2UudG9rZW4gPSB0aGlzLl9hY2Nlc3NUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICdzeW5jJykge1xuICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uID0gdGhpcy5fc2Vzc2lvbjtcbiAgICAgICAgICAgIG1lc3NhZ2UudG9rZW4gPSB0aGlzLl9hY2Nlc3NUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnNlc3Npb24gPSB0aGlzLl9zZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIFwiaWNlXCIgbWVzc2FnZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQucHJvdG90eXBlLl9jcmVhdGVJY2VNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWRnZTogJ3JvYW1pbmcnLFxuICAgICAgICAgICAgdG9rZW46IHRoaXMuX2FjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgdHlwZTogJ2ljZScsXG4gICAgICAgICAgICB2ZXJzaW9uOiBJQ0VfVkVSU0lPTlxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIENvbm5lY3QsIFN5bmMgb3IgRGlzY29ubmVjdCBSU1AgbWVzc2FnZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQucHJvdG90eXBlLl9zZW5kQ29ubmVjdE9yU3luY09yRGlzY29ubmVjdE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fY3JlYXRlQ29ubmVjdE9yU3luY09yRGlzY29ubmVjdE1lc3NhZ2UoKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3R3aWxpb0Nvbm5lY3Rpb24uc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgdGhlIHtAbGluayBUd2lsaW9Db25uZWN0aW9uVHJhbnNwb3J0fS4gUmV0dXJucyB0cnVlIGlmIGNhbGxpbmcgdGhlIG1ldGhvZCByZXN1bHRlZFxuICAgICAqIGluIGRpc2Nvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIHtUd2lsaW9FcnJvcn0gW2Vycm9yXVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnByZWVtcHQoJ2Rpc2Nvbm5lY3RlZCcsIG51bGwsIFtlcnJvcl0pO1xuICAgICAgICAgICAgdGhpcy5fc2VuZENvbm5lY3RPclN5bmNPckRpc2Nvbm5lY3RNZXNzYWdlKCk7XG4gICAgICAgICAgICB0aGlzLl90d2lsaW9Db25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9kaXNjb25uZWN0RXZlbnRQdWJsaXNoZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggYW4gUlNQIFVwZGF0ZS4gUmV0dXJucyB0cnVlIGlmIGNhbGxpbmcgdGhlIG1ldGhvZCByZXN1bHRlZCBpblxuICAgICAqIHB1Ymxpc2hpbmcgKG9yIGV2ZW50dWFsbHkgcHVibGlzaGluZykgdGhlIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVHdpbGlvQ29ubmVjdGlvblRyYW5zcG9ydC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX3R3aWxpb0Nvbm5lY3Rpb24uc2VuZE1lc3NhZ2UoT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb246IHRoaXMuX3Nlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1cGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBSU1BfVkVSU0lPTlxuICAgICAgICAgICAgICAgIH0sIHVwZGF0ZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAnY29ubmVjdGluZyc6XG4gICAgICAgICAgICBjYXNlICdzeW5jaW5nJzpcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVzVG9TZW5kLnB1c2godXBkYXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVibGlzaCAob3IgcXVldWUpIGFuIGV2ZW50IHRvIHRoZSBJbnNpZ2h0cyBnYXRld2F5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBncm91cCAtIEV2ZW50IGdyb3VwIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIEV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGV2ZWwgLSBFdmVudCBsZXZlbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXlsb2FkIC0gRXZlbnQgcGF5bG9hZFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQucHJvdG90eXBlLnB1Ymxpc2hFdmVudCA9IGZ1bmN0aW9uIChncm91cCwgbmFtZSwgbGV2ZWwsIHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRPYnNlcnZlci5lbWl0KCdldmVudCcsIHsgZ3JvdXA6IGdyb3VwLCBuYW1lOiBuYW1lLCBsZXZlbDogbGV2ZWwsIHBheWxvYWQ6IHBheWxvYWQgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTeW5jIHRoZSB7QGxpbmsgVHdpbGlvQ29ubmVjdGlvblRyYW5zcG9ydH0uIFJldHVybnMgdHJ1ZSBpZiBjYWxsaW5nIHRoZSBtZXRob2QgcmVzdWx0ZWQgaW5cbiAgICAgKiBzeW5jaW5nLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgdGhpcy5wcmVlbXB0KCdzeW5jaW5nJyk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29ubmVjdE9yU3luY09yRGlzY29ubmVjdE1lc3NhZ2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgVHdpbGlvQ29ubmVjdGlvblRyYW5zcG9ydC5wcm90b3R5cGUuX3NldFNlc3Npb24gPSBmdW5jdGlvbiAoc2Vzc2lvbiwgc2Vzc2lvblRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5fc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuX3Nlc3Npb25UaW1lb3V0TVMgPSBzZXNzaW9uVGltZW91dCAqIDEwMDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHdlIHNob3VsZCBhdHRlbXB0IHJlY29ubmVjdC5cbiAgICAgKiByZXR1cm5zIGEgUHJvbWlzZSB0byB3YWl0IG9uIGJlZm9yZSBhdHRlbXB0aW5nIHRvXG4gICAgICogcmVjb25uZWN0LiByZXR1cm5zIG51bGwgaWYgaXRzIG5vdCBva2F5IHRvIHJlY29ubmVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQucHJvdG90eXBlLl9nZXRSZWNvbm5lY3RUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3Nlc3Npb25UaW1lb3V0TVMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgZWl0aGVyIHdlIGhhdmUgbmV2ZXIgY29ubmVjdGVkLlxuICAgICAgICAgICAgLy8gb3Igd2UgdGltZWQgb3V0IHdoaWxlIHRyeWluZyB0byByZWNvbm5lY3RcbiAgICAgICAgICAgIC8vIEluIGVpdGhlciBjYXNlIHdlIGRvIG5vdCB3YW50IHRvIHJlY29ubmVjdC5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0YXJ0IHNlc3Npb24gdGltZXJcbiAgICAgICAgaWYgKCF0aGlzLl9zZXNzaW9uVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nlc3Npb25UaW1lciA9IG5ldyBUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCBfY2xlYXJSZWNvbm5lY3RUaW1lciB3YXNuJ3RcbiAgICAgICAgICAgICAgICAvLyBjYWxsZWQgd2hpbGUgd2Ugd2VyZSB3YWl0aW5nLlxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc2Vzc2lvblRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBhbGxvdyBhbnkgbW9yZSByZWNvbm5lY3QgYXR0ZW1wdHMuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXNzaW9uVGltZW91dE1TID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzLl9zZXNzaW9uVGltZW91dE1TKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gcHJvbWlzZSB0aGF0IHdhaXRzIHdpdGggZXhwb25lbnRpYWwgYmFja29mZi5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVjb25uZWN0QmFja29mZi5vbmNlKCdyZWFkeScsIHJlc29sdmUpO1xuICAgICAgICAgICAgX3RoaXMuX3JlY29ubmVjdEJhY2tvZmYuYmFja29mZigpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNsZWFycyB0aGUgc2Vzc2lvbiByZWNvbm5lY3QgdGltZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQucHJvdG90eXBlLl9jbGVhclJlY29ubmVjdFRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3RCYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIGlmICh0aGlzLl9zZXNzaW9uVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nlc3Npb25UaW1lci5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5fc2Vzc2lvblRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQ7XG59KFN0YXRlTWFjaGluZSkpO1xuLyoqXG4gKiBAZXZlbnQgVHdpbGlvQ29ubmVjdGlvblRyYW5zcG9ydCNjb25uZWN0ZWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbml0aWFsU3RhdGVcbiAqL1xuLyoqXG4gKiBAZXZlbnQgVHdpbGlvQ29ubmVjdGlvblRyYW5zcG9ydCNtZXNzYWdlXG4gKiBAcGFyYW0ge29iamVjdH0gcGVlckNvbm5lY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZVBlZXJDb25uZWN0aW9ucyhwZWVyQ29ubmVjdGlvbnMpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwZWVyQ29ubmVjdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChwZWVyQ29ubmVjdGlvbnNCeUlkLCB1cGRhdGUpIHtcbiAgICAgICAgdmFyIHJlZHVjZWQgPSBwZWVyQ29ubmVjdGlvbnNCeUlkLmdldCh1cGRhdGUuaWQpIHx8IHVwZGF0ZTtcbiAgICAgICAgLy8gRmlyc3QsIHJlZHVjZSB0aGUgdG9wLWxldmVsIGBkZXNjcmlwdGlvbmAgcHJvcGVydHkuXG4gICAgICAgIGlmICghcmVkdWNlZC5kZXNjcmlwdGlvbiAmJiB1cGRhdGUuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJlZHVjZWQuZGVzY3JpcHRpb24gPSB1cGRhdGUuZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVkdWNlZC5kZXNjcmlwdGlvbiAmJiB1cGRhdGUuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZGVzY3JpcHRpb24ucmV2aXNpb24gPiByZWR1Y2VkLmRlc2NyaXB0aW9uLnJldmlzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmVkdWNlZC5kZXNjcmlwdGlvbiA9IHVwZGF0ZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVuLCByZWR1Y2UgdGhlIHRvcC1sZXZlbCBgaWNlYCBwcm9wZXJ0eS5cbiAgICAgICAgaWYgKCFyZWR1Y2VkLmljZSAmJiB1cGRhdGUuaWNlKSB7XG4gICAgICAgICAgICByZWR1Y2VkLmljZSA9IHVwZGF0ZS5pY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVkdWNlZC5pY2UgJiYgdXBkYXRlLmljZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5pY2UucmV2aXNpb24gPiByZWR1Y2VkLmljZS5yZXZpc2lvbikge1xuICAgICAgICAgICAgICAgIHJlZHVjZWQuaWNlID0gdXBkYXRlLmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5hbGx5LCB1cGRhdGUgdGhlIG1hcC5cbiAgICAgICAgcGVlckNvbm5lY3Rpb25zQnlJZC5zZXQocmVkdWNlZC5pZCwgcmVkdWNlZCk7XG4gICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbnNCeUlkO1xuICAgIH0sIG5ldyBNYXAoKSkudmFsdWVzKCkpO1xufVxuZnVuY3Rpb24gcmVkdWNlVXBkYXRlcyh1cGRhdGVzKSB7XG4gICAgcmV0dXJuIHVwZGF0ZXMucmVkdWNlKGZ1bmN0aW9uIChyZWR1Y2VkLCB1cGRhdGUpIHtcbiAgICAgICAgLy8gRmlyc3QsIHJlZHVjZSB0aGUgdG9wLWxldmVsIGBwYXJ0aWNpcGFudGAgcHJvcGVydHkuXG4gICAgICAgIGlmICghcmVkdWNlZC5wYXJ0aWNpcGFudCAmJiB1cGRhdGUucGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIHJlZHVjZWQucGFydGljaXBhbnQgPSB1cGRhdGUucGFydGljaXBhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVkdWNlZC5wYXJ0aWNpcGFudCAmJiB1cGRhdGUucGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUucGFydGljaXBhbnQucmV2aXNpb24gPiByZWR1Y2VkLnBhcnRpY2lwYW50LnJldmlzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmVkdWNlZC5wYXJ0aWNpcGFudCA9IHVwZGF0ZS5wYXJ0aWNpcGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVuLCByZWR1Y2UgdGhlIHRvcC1sZXZlbCBgcGVlcl9jb25uZWN0aW9uc2AgcHJvcGVydHkuXG4gICAgICAgIC8qIGVzbGludCBjYW1lbGNhc2U6MCAqL1xuICAgICAgICBpZiAoIXJlZHVjZWQucGVlcl9jb25uZWN0aW9ucyAmJiB1cGRhdGUucGVlcl9jb25uZWN0aW9ucykge1xuICAgICAgICAgICAgcmVkdWNlZC5wZWVyX2Nvbm5lY3Rpb25zID0gcmVkdWNlUGVlckNvbm5lY3Rpb25zKHVwZGF0ZS5wZWVyX2Nvbm5lY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWR1Y2VkLnBlZXJfY29ubmVjdGlvbnMgJiYgdXBkYXRlLnBlZXJfY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIHJlZHVjZWQucGVlcl9jb25uZWN0aW9ucyA9IHJlZHVjZVBlZXJDb25uZWN0aW9ucyhyZWR1Y2VkLnBlZXJfY29ubmVjdGlvbnMuY29uY2F0KHVwZGF0ZS5wZWVyX2Nvbm5lY3Rpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gc2V0dXBUcmFuc3BvcnQodHJhbnNwb3J0KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlT3JSZXNldFR3aWxpb0Nvbm5lY3Rpb24oKSB7XG4gICAgICAgIGlmICh0cmFuc3BvcnQuc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zcG9ydC5fdHdpbGlvQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgdHJhbnNwb3J0Ll90d2lsaW9Db25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9pY2VTZXJ2ZXJzU3RhdHVzID0gdHJhbnNwb3J0Ll9pY2VTZXJ2ZXJzU3RhdHVzLCBfb3B0aW9ucyA9IHRyYW5zcG9ydC5fb3B0aW9ucywgX3dzU2VydmVyID0gdHJhbnNwb3J0Ll93c1NlcnZlciwgc3RhdGUgPSB0cmFuc3BvcnQuc3RhdGU7XG4gICAgICAgIHZhciBUd2lsaW9Db25uZWN0aW9uID0gX29wdGlvbnMuVHdpbGlvQ29ubmVjdGlvbjtcbiAgICAgICAgdmFyIHR3aWxpb0Nvbm5lY3Rpb24gPSBuZXcgVHdpbGlvQ29ubmVjdGlvbihfd3NTZXJ2ZXIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgaGVsbG9Cb2R5OiBzdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnICYmIF9pY2VTZXJ2ZXJzU3RhdHVzID09PSAnYWNxdWlyZSdcbiAgICAgICAgICAgICAgICA/IHRyYW5zcG9ydC5fY3JlYXRlSWNlTWVzc2FnZSgpXG4gICAgICAgICAgICAgICAgOiB0cmFuc3BvcnQuX2NyZWF0ZUNvbm5lY3RPclN5bmNPckRpc2Nvbm5lY3RNZXNzYWdlKClcbiAgICAgICAgfSwgX29wdGlvbnMpKTtcbiAgICAgICAgdHdpbGlvQ29ubmVjdGlvbi5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChyZWFzb24gPT09IFR3aWxpb0Nvbm5lY3Rpb24uQ2xvc2VSZWFzb24uTE9DQUwpIHtcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHR3aWxpb0Nvbm5lY3Rpb24ub24oJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgdHJhbnNwb3J0Ll90d2lsaW9Db25uZWN0aW9uID0gdHdpbGlvQ29ubmVjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzY29ubmVjdChlcnJvcikge1xuICAgICAgICBpZiAodHJhbnNwb3J0LnN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY29ubmVjdFRpbWVyID0gdHJhbnNwb3J0Ll9nZXRSZWNvbm5lY3RUaW1lcigpO1xuICAgICAgICBpZiAoIXJlY29ubmVjdFRpbWVyKSB7XG4gICAgICAgICAgICB2YXIgdHdpbGlvRXJyb3IgPSBlcnJvci5tZXNzYWdlID09PSBUd2lsaW9Db25uZWN0aW9uLkNsb3NlUmVhc29uLkJVU1lcbiAgICAgICAgICAgICAgICA/IG5ldyBTaWduYWxpbmdTZXJ2ZXJCdXN5RXJyb3IoKVxuICAgICAgICAgICAgICAgIDogbmV3IFNpZ25hbGluZ0Nvbm5lY3Rpb25FcnJvcigpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QodHdpbGlvRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc3BvcnQuc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQucHJlZW1wdCgnc3luY2luZycpO1xuICAgICAgICB9XG4gICAgICAgIHJlY29ubmVjdFRpbWVyLnRoZW4oY3JlYXRlT3JSZXNldFR3aWxpb0Nvbm5lY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYW5zcG9ydC5zdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdChjcmVhdGVUd2lsaW9FcnJvcihtZXNzYWdlLmNvZGUsIG1lc3NhZ2UubWVzc2FnZSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHJhbnNwb3J0LnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N5bmNlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QobWVzc2FnZS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgUm9vbUNvbXBsZXRlZEVycm9yKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpY2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5fb3B0aW9ucy5vbkljZWQobWVzc2FnZS5pY2Vfc2VydmVycykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0Ll9zZW5kQ29ubmVjdE9yU3luY09yRGlzY29ubmVjdE1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0Ll9zZXRTZXNzaW9uKG1lc3NhZ2Uuc2Vzc2lvbiwgbWVzc2FnZS5vcHRpb25zLnNlc3Npb25fdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuZW1pdCgnY29ubmVjdGVkJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQucHJlZW1wdCgnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N5bmNlZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuX3VwZGF0ZXNSZWNlaXZlZC5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QobWVzc2FnZS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgUm9vbUNvbXBsZXRlZEVycm9yKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzeW5jaW5nJzpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0Ll91cGRhdGVzUmVjZWl2ZWQucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3luY2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5fY2xlYXJSZWNvbm5lY3RUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5wcmVlbXB0KCdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KG1lc3NhZ2Uuc3RhdHVzID09PSAnY29tcGxldGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IFJvb21Db21wbGV0ZWRFcnJvcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBJbXBvc3NpYmxlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zcG9ydC5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gc3RhdGVDaGFuZ2VkKHN0YXRlKSB7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6IHtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlcyA9IHRyYW5zcG9ydC5fdXBkYXRlc1RvU2VuZC5zcGxpY2UoMCk7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5wdWJsaXNoKHJlZHVjZVVwZGF0ZXModXBkYXRlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuX3VwZGF0ZXNSZWNlaXZlZC5zcGxpY2UoMCkuZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7IHJldHVybiB0cmFuc3BvcnQuZW1pdCgnbWVzc2FnZScsIHVwZGF0ZSk7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0Ll90d2lsaW9Db25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdzdGF0ZUNoYW5nZWQnLCBzdGF0ZUNoYW5nZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3N5bmNpbmcnOlxuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBJbXBvc3NpYmxlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9vcHRpb25zID0gdHJhbnNwb3J0Ll9vcHRpb25zLCBfaWNlU2VydmVyc1N0YXR1cyA9IHRyYW5zcG9ydC5faWNlU2VydmVyc1N0YXR1cztcbiAgICB2YXIgaWNlU2VydmVycyA9IF9vcHRpb25zLmljZVNlcnZlcnMsIG9uSWNlZCA9IF9vcHRpb25zLm9uSWNlZDtcbiAgICBpZiAoX2ljZVNlcnZlcnNTdGF0dXMgPT09ICdvdmVycm9kZScpIHtcbiAgICAgICAgb25JY2VkKGljZVNlcnZlcnMpLnRoZW4oY3JlYXRlT3JSZXNldFR3aWxpb0Nvbm5lY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY3JlYXRlT3JSZXNldFR3aWxpb0Nvbm5lY3Rpb24oKTtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFR3aWxpb0Nvbm5lY3Rpb25UcmFuc3BvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10d2lsaW9jb25uZWN0aW9udHJhbnNwb3J0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICByZXR1cm4gdG87XG59O1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4vKipcbiAqIHtAbGluayBTdGF0ZU1hY2hpbmV9IHJlcHJlc2VudHMgYSBzdGF0ZSBtYWNoaW5lLiBUaGUgc3RhdGUgbWFjaGluZSBzdXBwb3J0cyBhXG4gKiByZWVudHJhbnQgbG9ja2luZyBtZWNoYW5pc20gdG8gYWxsb3cgYXN5bmNocm9ub3VzIHN0YXRlIHRyYW5zaXRpb25zIHRvIGVuc3VyZVxuICogdGhleSBoYXZlIG5vdCBiZWVuIHByZWVtcHRlZC4gQ2FsbHMgdG8ge0BsaW5rIFN0YXRlTWFjaGluZSN0YWtlTG9ja30gYXJlXG4gKiBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGluIEZJRk8gb3JkZXIuXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNMb2NrZWQgLSB3aGV0aGVyIG9yIG5vdCB0aGUge0BsaW5rIFN0YXRlTWFjaGluZX0gaXNcbiAqICAgbG9ja2VkIHBlcmZvcm1pbmcgYXN5bmNocm9ub3VzIHN0YXRlIHRyYW5zaXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0ZSAtIHRoZSBjdXJyZW50IHN0YXRlXG4gKiBAZW1pdHMge0BsaW5rIFN0YXRlTWFjaGluZSNzdGF0ZUNoYW5nZWR9XG4gKi9cbnZhciBTdGF0ZU1hY2hpbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YXRlTWFjaGluZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgU3RhdGVNYWNoaW5lfS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5pdGlhbFN0YXRlIC0gdGhlIGludGlpYWwgc3RhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3RhdGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGVNYWNoaW5lKGluaXRpYWxTdGF0ZSwgc3RhdGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIHZhciBsb2NrID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICBzdGF0ZXMgPSB0cmFuc2Zvcm1TdGF0ZXMoc3RhdGVzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9sb2NrOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NrO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2xvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jayA9IF9sb2NrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVhY2hhYmxlU3RhdGVzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlYWNoYWJsZShzdGF0ZXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3N0YXRlOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IF9zdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3N0YXRlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzdGF0ZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfd2hlbkRlZmVycmVkczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0xvY2tlZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NrICE9PSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICBfdGhpcy5fd2hlbkRlZmVycmVkcy5mb3JFYWNoKGZ1bmN0aW9uIChkZWZlcnJlZCkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLndoZW4oc3RhdGUsIGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2Ugd2hvc2UgZXhlY3V0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGVhY2ggc3RhdGUgY2hhbmdlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RhdGU6IHN0cmluZywgcmVzb2x2ZTogZnVuY3Rpb24sIHJlamVjdDogZnVuY3Rpb24pOiB2b2lkfSB3aGVuXG4gICAgICogQHJldHVybnMge1Byb21pc2UuPCo+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5fd2hlblByb21pc2UgPSBmdW5jdGlvbiAod2hlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHdoZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ3doZW4oKSBleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlZmVycmVkID0gdXRpbC5kZWZlcigpO1xuICAgICAgICBkZWZlcnJlZC53aGVuID0gd2hlbjtcbiAgICAgICAgdGhpcy5fd2hlbkRlZmVycmVkcy5hZGQoZGVmZXJyZWQpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICBfdGhpcy5fd2hlbkRlZmVycmVkcy5kZWxldGUoZGVmZXJyZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMuX3doZW5EZWZlcnJlZHMuZGVsZXRlKGRlZmVycmVkKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIGEgbG9jayBhbmQgcGFzc2VzIHRoZSB7QGxpbmsgU3RhdGVNYWNoaW5lI0tleX0gdG8geW91clxuICAgICAqIHRyYW5zaXRpb24gZnVuY3Rpb24uIFlvdSBtYXkgcGVyZm9ybSB6ZXJvIG9yIG1vcmUgc3RhdGUgdHJhbnNpdGlvbnMgaW4geW91clxuICAgICAqIHRyYW5zaXRpb24gZnVuY3Rpb24sIGJ1dCB5b3Ugc2hvdWxkIGNoZWNrIGZvciBwcmVlbXB0aW9uIGluIGVhY2ggdGljay4gWW91XG4gICAgICogbWF5IGFsc28gcmVlbnRlciB0aGUgbG9jay4gT25jZSB0aGUgUHJvbWlzZSByZXR1cm5lZCBieSB5b3VyIHRyYW5zaXRpb25cbiAgICAgKiBmdW5jdGlvbiByZXNvbHZlcyBvciByZWplY3RzLCB0aGlzIG1ldGhvZCByZWxlYXNlcyB0aGUgbG9jayBpdCBhY3F1aXJlZCBmb3JcbiAgICAgKiB5b3UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBhIG5hbWUgZm9yIHRoZSBsb2NrXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihTdGF0ZU1hY2hpbmUjS2V5KTogUHJvbWlzZX0gdHJhbnNpdGlvbkZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgLy8gTk9URShtcm9iZXJ0cyk6IFRoaXMgbWV0aG9kIGlzIG5hbWVkIGFmdGVyIGEgSGFza2VsbCBmdW5jdGlvbjpcbiAgICAvLyBodHRwczovL2hhY2thZ2UuaGFza2VsbC5vcmcvcGFja2FnZS9iYXNlLTQuOC4yLjAvZG9jcy9Db250cm9sLUV4Y2VwdGlvbi5odG1sI3Y6YnJhY2tldFxuICAgIFN0YXRlTWFjaGluZS5wcm90b3R5cGUuYnJhY2tldCA9IGZ1bmN0aW9uIChuYW1lLCB0cmFuc2l0aW9uRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiByZWxlYXNlTG9jayhlcnJvcikge1xuICAgICAgICAgICAgaWYgKHNlbGYuaGFzTG9jayhrZXkpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWxlYXNlTG9ja0NvbXBsZXRlbHkoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRha2VMb2NrKG5hbWUpLnRoZW4oZnVuY3Rpb24gZ290S2V5KF9rZXkpIHtcbiAgICAgICAgICAgIGtleSA9IF9rZXk7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbkZ1bmN0aW9uKGtleSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gc3VjY2VzcyhyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCByZWxlYXNlTG9jayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIG9yIG5vdCBhIHtAbGluayBTdGF0ZU1hY2hpbmUjS2V5fSBtYXRjaGVzIHRoZSBsb2NrLlxuICAgICAqIEBwYXJhbSB7U3RhdGVNYWNoaW5lI0tleX0ga2V5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5oYXNMb2NrID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jayA9PT0ga2V5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJlZW1wdCBhbnkgcGVuZGluZyBzdGF0ZSB0cmFuc2l0aW9ucyBhbmQgaW1tZWRpYXRlbHkgdHJhbnNpdGlvbiB0byB0aGUgbmV3XG4gICAgICogc3RhdGUuIElmIGEgbG9jayBuYW1lIGlzIHNwZWNpZmllZCwgdGFrZSB0aGUgbG9jayBhbmQgcmV0dXJuIHRoZVxuICAgICAqIHtAbGluayBTdGF0ZU1hY2hpbmUjS2V5fS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3U3RhdGVcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IFtuYW1lPW51bGxdIC0gYSBuYW1lIGZvciB0aGUgbG9ja1xuICAgICAqIEBwYXJhbSB7QXJyYXk8Kj59IFtwYXlsb2FkPVtdXVxuICAgICAqIEByZXR1cm5zIHs/U3RhdGVNYWNoaW5lI0tleX1cbiAgICAgKi9cbiAgICBTdGF0ZU1hY2hpbmUucHJvdG90eXBlLnByZWVtcHQgPSBmdW5jdGlvbiAobmV3U3RhdGUsIG5hbWUsIHBheWxvYWQpIHtcbiAgICAgICAgLy8gMS4gQ2hlY2sgdGhhdCB0aGUgbmV3IHN0YXRlIGlzIHZhbGlkLlxuICAgICAgICBpZiAoIWlzVmFsaWRUcmFuc2l0aW9uKHRoaXMuX3N0YXRlcywgdGhpcy5zdGF0ZSwgbmV3U3RhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdHJhbnNpdGlvbiBmcm9tIFxcXCJcIiArIHRoaXMuc3RhdGUgKyBcIlxcXCIgdG8gXFxcIlwiICsgbmV3U3RhdGUgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMi4gUmVsZWFzZSB0aGUgb2xkIGxvY2ssIGlmIGFueS5cbiAgICAgICAgdmFyIG9sZExvY2s7XG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICBvbGRMb2NrID0gdGhpcy5fbG9jaztcbiAgICAgICAgICAgIHRoaXMuX2xvY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuIFRha2UgdGhlIGxvY2ssIGlmIHJlcXVlc3RlZC5cbiAgICAgICAgdmFyIGtleSA9IG51bGw7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLnRha2VMb2NrU3luYyhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA0LiBJZiBhIGxvY2sgd2Fzbid0IHJlcXVlc3RlZCwgdGFrZSBhIFwicHJlZW1wdGlvblwiIGxvY2sgaW4gb3JkZXIgdG9cbiAgICAgICAgLy8gbWFpbnRhaW4gRklGTyBvcmRlciBvZiB0aG9zZSB0YWtpbmcgbG9ja3MuXG4gICAgICAgIHZhciBwcmVlbXB0aW9uS2V5ID0ga2V5ID8gbnVsbCA6IHRoaXMudGFrZUxvY2tTeW5jKCdwcmVlbXB0aW9uJyk7XG4gICAgICAgIC8vIDUuIFRyYW5zaXRpb24uXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbihuZXdTdGF0ZSwga2V5IHx8IHByZWVtcHRpb25LZXksIHBheWxvYWQpO1xuICAgICAgICAvLyA2LiBQcmVlbXB0IGFueW9uZSBibG9ja2VkIG9uIHRoZSBvbGQgbG9jay5cbiAgICAgICAgaWYgKG9sZExvY2spIHtcbiAgICAgICAgICAgIG9sZExvY2sucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuIFJlbGVhc2UgdGhlIFwicHJlZW1wdGlvblwiIGxvY2ssIGlmIHdlIHRvb2sgaXQuXG4gICAgICAgIGlmIChwcmVlbXB0aW9uS2V5KSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VMb2NrKHByZWVtcHRpb25LZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIGEgbG9jay4gVGhpcyBtZXRob2Qgc3VjY2VlZHMgb25seSBpZiB0aGUge0BsaW5rIFN0YXRlTWFjaGluZX0gaXNcbiAgICAgKiBzdGlsbCBsb2NrZWQgYW5kIGhhcyBub3QgYmVlbiBwcmVlbXB0ZWQuXG4gICAgICogQHBhcmFtIHtTdGF0ZU1hY2hpbmUjS2V5fSBrZXlcbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICovXG4gICAgU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5yZWxlYXNlTG9jayA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVsZWFzZSB0aGUgbG9jayBmb3IgXCIgKyBrZXkubmFtZSArIFwiIGJlY2F1c2UgdGhlIFN0YXRlTWFjaGluZSBpcyBub3QgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmhhc0xvY2soa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlbGVhc2UgdGhlIGxvY2sgZm9yIFwiICsga2V5Lm5hbWUgKyBcIiBiZWNhdXNlIFwiICsgdGhpcy5fbG9jay5uYW1lICsgXCIgaGFzIHRoZSBsb2NrXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2sgPSBudWxsO1xuICAgICAgICAgICAga2V5LnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleS5kZXB0aC0tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIGEgbG9jayBjb21wbGV0ZWx5LCBldmVuIGlmIGl0IGhhcyBiZWVuIHJlZW50ZXJlZC4gVGhpcyBtZXRob2RcbiAgICAgKiBzdWNjZWVkcyBvbmx5IGlmIHRoZSB7QGxpbmsgU3RhdGVNYWNoaW5lfSBpcyBzdGlsbCBsb2NrZWQgYW5kIGhhcyBub3QgYmVlblxuICAgICAqIHByZWVtcHRlZC5cbiAgICAgKiBAcGFyYW0ge1N0YXRlTWFjaGluZSNLZXl9IGtleVxuICAgICAqIEB0aHJvd3MgRXJyb3JcbiAgICAgKi9cbiAgICBTdGF0ZU1hY2hpbmUucHJvdG90eXBlLnJlbGVhc2VMb2NrQ29tcGxldGVseSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVsZWFzZSB0aGUgbG9jayBmb3IgXCIgKyBrZXkubmFtZSArIFwiIGJlY2F1c2UgdGhlIFN0YXRlTWFjaGluZSBpcyBub3QgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmhhc0xvY2soa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlbGVhc2UgdGhlIGxvY2sgZm9yIFwiICsga2V5Lm5hbWUgKyBcIiBiZWNhdXNlIFwiICsgdGhpcy5fbG9jay5uYW1lICsgXCIgaGFzIHRoZSBsb2NrXCIpO1xuICAgICAgICB9XG4gICAgICAgIGtleS5kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuX2xvY2sgPSBudWxsO1xuICAgICAgICBrZXkucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGFrZSBhIGxvY2ssIHJldHVybmluZyBhIFByb21pc2UgZm9yIHRoZSB7QGxpbmsgU3RhdGVNYWNoaW5lI0tleX0uIFlvdSBzaG91bGRcbiAgICAgKiB0YWtlIGEgbG9jayBhbnl0aW1lIHlvdSBpbnRlbmQgdG8gcGVyZm9ybSBhc3luY2hyb25vdXMgdHJhbnNpdGlvbnMuIENhbGxzIHRvXG4gICAgICogdGhpcyBtZXRob2QgYXJlIGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaW4gRklGTyBvcmRlci4gWW91IG1heSByZWVudGVyXG4gICAgICogYSBsb2NrIGJ5IHBhc3NpbmcgaXRzIHtAbGluayBTdGF0ZU1hY2hpbmUjS2V5fS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xTdGF0ZU1hY2hpbmUjS2V5fSBuYW1lT3JLZXkgLSBhIG5hbWUgZm9yIHRoZSBsb2NrIG9yIGFuXG4gICAgICogZXhpc3Rpbmcge0BsaW5rIFN0YXRlTWFjaGluZSNLZXl9XG4gICAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn1cbiAgICAgKi9cbiAgICBTdGF0ZU1hY2hpbmUucHJvdG90eXBlLnRha2VMb2NrID0gZnVuY3Rpb24gKG5hbWVPcktleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBSZWVudHJhbnQgbG9ja1xuICAgICAgICBpZiAodHlwZW9mIG5hbWVPcktleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhciBrZXlfMSA9IG5hbWVPcktleTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMudGFrZUxvY2tTeW5jKGtleV8xKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZXcgbG9ja1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVPcktleTtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHZhciB0YWtlTG9jayA9IHRoaXMudGFrZUxvY2suYmluZCh0aGlzLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NrLnByb21pc2UudGhlbih0YWtlTG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnRha2VMb2NrU3luYyhuYW1lKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUYWtlIGEgbG9jaywgcmV0dXJuaW5nIHRoZSB7QExpbmsgU3RhdGVNYWNoaW5lI0tleX0uIFRoaXMgbWV0aG9kIHRocm93cyBpZlxuICAgICAqIHRoZSB7QGxpbmsgU3RhdGVNYWNoaW5lfSBpcyBsb2NrZWQgb3IgdGhlIHdyb25nIHtAbGluayBTdGF0ZU1hY2hpbmUjS2V5fSBpc1xuICAgICAqIHByb3ZpZGVkLiBZb3UgbWF5IHJlZW50ZXIgYSBsb2NrIGJ5IHBhc3NpbmcgaXRzIHtAbGluayBTdGF0ZU1hY2hpbmUjS2V5fS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xTdGF0ZU1hY2hpbmUjS2V5fSBuYW1lT3JLZXkgLSBhIG5hbWUgZm9yIHRoZSBsb2NrIG9yIGFuXG4gICAgICogZXhpc3Rpbmcge0BsaW5rIFN0YXRlTWFjaGluZSNLZXl9XG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICovXG4gICAgU3RhdGVNYWNoaW5lLnByb3RvdHlwZS50YWtlTG9ja1N5bmMgPSBmdW5jdGlvbiAobmFtZU9yS2V5KSB7XG4gICAgICAgIHZhciBrZXkgPSB0eXBlb2YgbmFtZU9yS2V5ID09PSAnc3RyaW5nJyA/IG51bGwgOiBuYW1lT3JLZXk7XG4gICAgICAgIHZhciBuYW1lID0ga2V5ID8ga2V5Lm5hbWUgOiBuYW1lT3JLZXk7XG4gICAgICAgIGlmIChrZXkgJiYgIXRoaXMuaGFzTG9jayhrZXkpIHx8ICFrZXkgJiYgdGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHRha2UgdGhlIGxvY2sgZm9yIFwiICsgbmFtZSArIFwiIGJlY2F1c2UgdGhlIGxvY2sgZm9yIFwiICsgdGhpcy5fbG9jay5uYW1lICsgXCIgd2FzIG5vdCByZWxlYXNlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWVudHJhbnQgbG9ja1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBrZXkuZGVwdGgrKztcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV3IGxvY2tcbiAgICAgICAgdmFyIGxvY2sgPSBtYWtlTG9jayhuYW1lKTtcbiAgICAgICAgdGhpcy5fbG9jayA9IGxvY2s7XG4gICAgICAgIHJldHVybiBsb2NrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbiB0byBhIG5ldyBzdGF0ZS4gSWYgdGhlIHtAbGluayBTdGF0ZU1hY2hpbmV9IGlzIGxvY2tlZCwgeW91IG11c3RcbiAgICAgKiBwcm92aWRlIHRoZSB7QGxpbmsgU3RhdGVNYWNoaW5lI0tleX0uIEFuIGludmFsaWQgc3RhdGUgb3IgdGhlIHdyb25nXG4gICAgICoge0BsaW5rIFN0YXRlTWFjaGluZSNLZXl9IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1N0YXRlXG4gICAgICogQHBhcmFtIHs/U3RhdGVNYWNoaW5lI0tleX0gW2tleT1udWxsXVxuICAgICAqIEBwYXJhbSB7QXJyYXk8Kj59IFtwYXlsb2FkPVtdXVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqL1xuICAgIFN0YXRlTWFjaGluZS5wcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwga2V5LCBwYXlsb2FkKSB7XG4gICAgICAgIHBheWxvYWQgPSBwYXlsb2FkIHx8IFtdO1xuICAgICAgICAvLyAxLiBJZiB3ZSdyZSBsb2NrZWQsIHJlcXVpcmVkIHRoZSBrZXkuXG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSB0aGUga2V5IGluIG9yZGVyIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAndHJhbnNpdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGFzTG9jayhrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHRyYW5zaXRpb24gdXNpbmcgdGhlIGtleSBmb3IgXCIgKyBrZXkubmFtZSArIFwiIGJlY2F1c2UgXCIgKyB0aGlzLl9sb2NrLm5hbWUgKyBcIiBoYXMgdGhlIGxvY2tcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgcHJvdmlkZWQgZm9yIFwiICsga2V5Lm5hbWUgKyBcIiwgYnV0IHRoZSBTdGF0ZU1hY2hpbmUgd2FzIG5vdCBsb2NrZWQgKHBvc3NpYmx5IGR1ZSB0byBwcmVlbXB0aW9uKVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAyLiBDaGVjayB0aGF0IHRoZSBuZXcgc3RhdGUgaXMgdmFsaWQuXG4gICAgICAgIGlmICghaXNWYWxpZFRyYW5zaXRpb24odGhpcy5fc3RhdGVzLCB0aGlzLnN0YXRlLCBuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0cmFuc2l0aW9uIGZyb20gXFxcIlwiICsgdGhpcy5zdGF0ZSArIFwiXFxcIiB0byBcXFwiXCIgKyBuZXdTdGF0ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBVcGRhdGUgdGhlIHN0YXRlIGFuZCBlbWl0IGFuIGV2ZW50LlxuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKFsnc3RhdGVDaGFuZ2VkJywgbmV3U3RhdGVdLmNvbmNhdChwYXlsb2FkKSkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gdHJhbnNpdGlvbiB0byBhIG5ldyBzdGF0ZS4gVW5saWtlIHtAbGluayBTdGF0ZU1hY2hpbmUjdHJhbnNpdGlvbn0sXG4gICAgICogdGhpcyBtZXRob2QgZG9lcyBub3QgdGhyb3cuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1N0YXRlXG4gICAgICogQHBhcmFtIHs/U3RhdGVNYWNoaW5lI0tleX0gW2tleT1udWxsXVxuICAgICAqIEBwYXJhbSB7QXJyYXk8Kj59IFtwYXlsb2FkPVtdXVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFN0YXRlTWFjaGluZS5wcm90b3R5cGUudHJ5VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwga2V5LCBwYXlsb2FkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24obmV3U3RhdGUsIGtleSwgcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUge0BsaW5rIFN0YXRlTWFjaGluZX0gdHJhbnNpdGlvbnMgdG9cbiAgICAgKiB0aGUgc3BlY2lmaWVkIHN0YXRlLiBJZiB0aGUge0BsaW5rIFN0YXRlTWFjaGluZX0gdHJhbnNpdGlvbnMgc3VjaCB0aGF0IHRoZVxuICAgICAqIHJlcXVlc3RlZCBzdGF0ZSBiZWNvbWVzIHVucmVhY2hhYmxlLCB0aGUgUHJvbWlzZSByZWplY3RzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHRoaXM+fVxuICAgICAqL1xuICAgIFN0YXRlTWFjaGluZS5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzVmFsaWRUcmFuc2l0aW9uKHRoaXMuX3JlYWNoYWJsZVN0YXRlcywgdGhpcy5zdGF0ZSwgc3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY3JlYXRlVW5yZWFjaGFibGVFcnJvcih0aGlzLnN0YXRlLCBzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93aGVuUHJvbWlzZShmdW5jdGlvbiAobmV3U3RhdGUsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVmFsaWRUcmFuc2l0aW9uKF90aGlzLl9yZWFjaGFibGVTdGF0ZXMsIG5ld1N0YXRlLCBzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoY3JlYXRlVW5yZWFjaGFibGVFcnJvcihuZXdTdGF0ZSwgc3RhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVNYWNoaW5lO1xufShFdmVudEVtaXR0ZXIpKTtcbi8qKlxuICogQGV2ZW50IFN0YXRlTWFjaGluZSNzdGF0ZUNoYW5nZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdTdGF0ZVxuICovXG4vKipcbiAqIENoZWNrIGlmIGEgdHJhbnNpdGlvbiBpcyB2YWxpZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge01hcDwqLCBTZXQ8Kj4+fSBncmFwaFxuICogQHBhcmFtIHsqfSBmcm9tXG4gKiBAcGFyYW0geyp9IHRvXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFRyYW5zaXRpb24oZ3JhcGgsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGdyYXBoLmdldChmcm9tKS5oYXModG8pO1xufVxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTdGF0ZU1hY2hpbmUjS2V5XG4gKi9cbmZ1bmN0aW9uIG1ha2VMb2NrKG5hbWUpIHtcbiAgICB2YXIgbG9jayA9IHV0aWwuZGVmZXIoKTtcbiAgICBsb2NrLm5hbWUgPSBuYW1lO1xuICAgIGxvY2suZGVwdGggPSAwO1xuICAgIHJldHVybiBsb2NrO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSB0cmFuc2l0aXZlIGNsb3N1cmUgb2YgYSBncmFwaCAoaS5lLiB3aGF0IG5vZGVzIGFyZSByZWFjaGFibGUgZnJvbVxuICogd2hlcmUpLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TWFwPCosIFNldDwqPj59IGdyYXBoXG4gKiBAcmV0dXJucyB7TWFwPCosIFNldDwqPj59XG4gKi9cbmZ1bmN0aW9uIHJlYWNoYWJsZShncmFwaCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGdyYXBoLmtleXMoKSkucmVkdWNlKGZ1bmN0aW9uIChuZXdHcmFwaCwgZnJvbSkgeyByZXR1cm4gbmV3R3JhcGguc2V0KGZyb20sIHJlYWNoYWJsZUZyb20oZ3JhcGgsIGZyb20pKTsgfSwgbmV3IE1hcCgpKTtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgU2V0IG9mIG5vZGUgcmVhY2hhYmxlIGZyb20gYSBwYXJ0aWN1bGFyIG5vZGUgaW4gdGhlIGdyYXBoLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TWFwPCosIFNldDwqPj59IGdyYXBoXG4gKiBAcGFyYW0geyp9IGZyb21cbiAqIEBwYXJhbSB7U2V0PCo+fSBbdG9dXG4gKiBAcmV0dXJucyB7U2V0PCo+fVxuICovXG5mdW5jdGlvbiByZWFjaGFibGVGcm9tKGdyYXBoLCBmcm9tLCB0bykge1xuICAgIHRvID0gdG8gfHwgbmV3IFNldCgpO1xuICAgIGdyYXBoLmdldChmcm9tKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghdG8uaGFzKG5vZGUpKSB7XG4gICAgICAgICAgICB0by5hZGQobm9kZSk7XG4gICAgICAgICAgICByZWFjaGFibGVGcm9tKGdyYXBoLCBub2RlLCB0bykuZm9yRWFjaCh0by5hZGQsIHRvKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0bztcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlcyhzdGF0ZXMpIHtcbiAgICB2YXIgbmV3U3RhdGVzID0gbmV3IE1hcCgpO1xuICAgIGZvciAodmFyIGtleSBpbiBzdGF0ZXMpIHtcbiAgICAgICAgbmV3U3RhdGVzLnNldChrZXksIG5ldyBTZXQoc3RhdGVzW2tleV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0YXRlcztcbn1cbi8qKlxuICogQ3JlYXRlIGFuIFwidW5yZWFjaGFibGUgc3RhdGVcIiBFcnJvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGhlcmVcbiAqIEByZXR1cm5zIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVW5yZWFjaGFibGVFcnJvcihoZXJlLCB0aGVyZSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJcXFwiXCIgKyB0aGVyZSArIFwiXFxcIiBjYW5ub3QgYmUgcmVhY2hlZCBmcm9tIFxcXCJcIiArIGhlcmUgKyBcIlxcXCJcIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlTWFjaGluZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlbWFjaGluZS5qcy5tYXAiLCIvKiBlc2xpbnQgbm8tdW5kZWZpbmVkOjAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXJ8dW5kZWZpbmVkPn0geHNcbiAqIEByZXR1cm5zIHtudW1iZXJ8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBhdmVyYWdlKHhzKSB7XG4gICAgeHMgPSB4cy5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHR5cGVvZiB4ID09PSAnbnVtYmVyJzsgfSk7XG4gICAgcmV0dXJuIHhzLmxlbmd0aCA8IDEgPyB1bmRlZmluZWQgOiB4cy5yZWR1Y2UoZnVuY3Rpb24gKHksIHgpIHsgcmV0dXJuIHggKyB5OyB9KSAvIHhzLmxlbmd0aDtcbn1cbm1vZHVsZS5leHBvcnRzID0gYXZlcmFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF2ZXJhZ2UuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2F2YWlsYWJsZVNlbmRdIC0gYnBzICh1bmRlZmluZWQgaW4gRmlyZWZveClcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWN2IC0gYnBzXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3J0dF0gLSBzICh1bmRlZmluZWQgaW4gRmlyZWZveClcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZW5kIC0gYnBzXG4gKi9cbnZhciBJY2VSZXBvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIHtAbGluayBJY2VSZXBvcnR9LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZW5kIC0gYnBzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlY3YgLSBicHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3J0dF0gLSBzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthdmFpbGFibGVTZW5kXSAtIGJwc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEljZVJlcG9ydChzZW5kLCByZWN2LCBhdmFpbGFibGVTZW5kLCBydHQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgYXZhaWxhYmxlU2VuZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGF2YWlsYWJsZVNlbmRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWN2OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVjdlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ0dDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJ0dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbmQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzZW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JUQ1N0YXRzfSBvbGRlclN0YXRzXG4gICAgICogQHBhcmFtIHtSVENTdGF0c30gbmV3ZXJTdGF0c1xuICAgICAqIEByZXR1cm5zIHtJY2VSZXBvcnR9XG4gICAgICovXG4gICAgSWNlUmVwb3J0Lm9mID0gZnVuY3Rpb24gKG9sZGVyU3RhdHMsIG5ld2VyU3RhdHMpIHtcbiAgICAgICAgdmFyIHNlY29uZHNFbGFwc2VkID0gKG5ld2VyU3RhdHMudGltZXN0YW1wIC0gb2xkZXJTdGF0cy50aW1lc3RhbXApIC8gMTAwMDtcbiAgICAgICAgdmFyIGRlbHRhQnl0ZXNTZW50ID0gbmV3ZXJTdGF0cy5ieXRlc1NlbnQgLSBvbGRlclN0YXRzLmJ5dGVzU2VudDtcbiAgICAgICAgdmFyIGRlbHRhQnl0ZXNSZWNlaXZlZCA9IG5ld2VyU3RhdHMuYnl0ZXNSZWNlaXZlZCAtIG9sZGVyU3RhdHMuYnl0ZXNSZWNlaXZlZDtcbiAgICAgICAgdmFyIHNlbmQgPSBzZWNvbmRzRWxhcHNlZCA+IDBcbiAgICAgICAgICAgID8gKGRlbHRhQnl0ZXNTZW50IC8gc2Vjb25kc0VsYXBzZWQpICogOFxuICAgICAgICAgICAgOiAwO1xuICAgICAgICB2YXIgcmVjdiA9IHNlY29uZHNFbGFwc2VkID4gMFxuICAgICAgICAgICAgPyAoZGVsdGFCeXRlc1JlY2VpdmVkIC8gc2Vjb25kc0VsYXBzZWQpICogOFxuICAgICAgICAgICAgOiAwO1xuICAgICAgICB2YXIgYXZhaWxhYmxlU2VuZCA9IG5ld2VyU3RhdHMuYXZhaWxhYmxlT3V0Z29pbmdCaXRyYXRlLCBydHQgPSBuZXdlclN0YXRzLmN1cnJlbnRSb3VuZFRyaXBUaW1lO1xuICAgICAgICByZXR1cm4gbmV3IEljZVJlcG9ydChzZW5kLCByZWN2LCBhdmFpbGFibGVTZW5kLCBydHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEljZVJlcG9ydDtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IEljZVJlcG9ydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWljZXJlcG9ydC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgSWNlUmVwb3J0ID0gcmVxdWlyZSgnLi9pY2VyZXBvcnQnKTtcbi8qKlxuICogQHByb3BlcnR5IHtJY2VSZXBvcnR9IGxhc3RSZXBvcnRcbiAqIEBwcm9wZXJ0eSB7P1JUQ1N0YXRzfSBsYXN0U3RhdHNcbiAqL1xudmFyIEljZVJlcG9ydEZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIHtAbGluayBJY2VSZXBvcnRGYWN0b3J5fS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJY2VSZXBvcnRGYWN0b3J5KCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBsYXN0UmVwb3J0OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IEljZVJlcG9ydCgwLCAwKSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3RTdGF0czoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiB7QGxpbmsgSWNlUmVwb3J0fS5cbiAgICAgKiBAcGFyYW0ge1JUQ1N0YXRzfSBuZXdlclN0YXRzO1xuICAgICAqIEByZXR1cm5zIHtJY2VSZXBvcnR9XG4gICAgICovXG4gICAgSWNlUmVwb3J0RmFjdG9yeS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChuZXdlclN0YXRzKSB7XG4gICAgICAgIHZhciBvbGRlclN0YXRzID0gdGhpcy5sYXN0U3RhdHM7XG4gICAgICAgIHRoaXMubGFzdFN0YXRzID0gbmV3ZXJTdGF0cztcbiAgICAgICAgaWYgKG9sZGVyU3RhdHMpIHtcbiAgICAgICAgICAgIHZhciByZXBvcnQgPSBvbGRlclN0YXRzLmlkID09PSBuZXdlclN0YXRzLmlkXG4gICAgICAgICAgICAgICAgPyBJY2VSZXBvcnQub2Yob2xkZXJTdGF0cywgbmV3ZXJTdGF0cylcbiAgICAgICAgICAgICAgICA6IG5ldyBJY2VSZXBvcnQoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZXBvcnQgPSByZXBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFJlcG9ydDtcbiAgICB9O1xuICAgIHJldHVybiBJY2VSZXBvcnRGYWN0b3J5O1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gSWNlUmVwb3J0RmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWljZXJlcG9ydGZhY3RvcnkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBMb2NhbFRyYWNrU3RhdHMgPSByZXF1aXJlKCcuL2xvY2FsdHJhY2tzdGF0cycpO1xuLyoqXG4gKiBTdGF0aXN0aWNzIGZvciBhIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9LlxuICogQGV4dGVuZHMgTG9jYWxUcmFja1N0YXRzXG4gKiBAcHJvcGVydHkgez9BdWRpb0xldmVsfSBhdWRpb0xldmVsIC0gSW5wdXQge0BsaW5rIEF1ZGlvTGV2ZWx9XG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IGppdHRlciAtIEF1ZGlvIGppdHRlciBpbiBtaWxsaXNlY29uZHNcbiAqL1xudmFyIExvY2FsQXVkaW9UcmFja1N0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhbEF1ZGlvVHJhY2tTdGF0cywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhY2tJZCAtIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9IElEXG4gICAgICogQHBhcmFtIHtTdGFuZGFyZGl6ZWRUcmFja1N0YXRzUmVwb3J0fSBzdGF0c1JlcG9ydFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJlcGFyZUZvckluc2lnaHRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9jYWxBdWRpb1RyYWNrU3RhdHModHJhY2tJZCwgc3RhdHNSZXBvcnQsIHByZXBhcmVGb3JJbnNpZ2h0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0cmFja0lkLCBzdGF0c1JlcG9ydCwgcHJlcGFyZUZvckluc2lnaHRzKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgYXVkaW9MZXZlbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlb2Ygc3RhdHNSZXBvcnQuYXVkaW9JbnB1dExldmVsID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICA/IHN0YXRzUmVwb3J0LmF1ZGlvSW5wdXRMZXZlbFxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGppdHRlcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlb2Ygc3RhdHNSZXBvcnQuaml0dGVyID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICA/IHN0YXRzUmVwb3J0LmppdHRlclxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTG9jYWxBdWRpb1RyYWNrU3RhdHM7XG59KExvY2FsVHJhY2tTdGF0cykpO1xuLyoqXG4gKiBUaGUgbWF4aW11bSBhYnNvbHV0ZSBhbXBsaXR1ZGUgb2YgYSBzZXQgb2YgYXVkaW8gc2FtcGxlcyBpbiB0aGVcbiAqIHJhbmdlIG9mIDAgdG8gMzI3NjcgaW5jbHVzaXZlLlxuICogQHR5cGVkZWYge251bWJlcn0gQXVkaW9MZXZlbFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsQXVkaW9UcmFja1N0YXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxhdWRpb3RyYWNrc3RhdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBUcmFja1N0YXRzID0gcmVxdWlyZSgnLi90cmFja3N0YXRzJyk7XG4vKipcbiAqIFN0YXRpc3RpY3MgZm9yIGEge0BsaW5rIExvY2FsVHJhY2t9LlxuICogQGV4dGVuZHMgVHJhY2tTdGF0c1xuICogQHByb3BlcnR5IHs/bnVtYmVyfSBieXRlc1NlbnQgLSBOdW1iZXIgb2YgYnl0ZXMgc2VudFxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBwYWNrZXRzU2VudCAtIE51bWJlciBvZiBwYWNrZXRzIHNlbnRcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gcm91bmRUcmlwVGltZSAtIFJvdW5kIHRyaXAgdGltZSBpbiBtaWxsaXNlY29uZHNcbiAqL1xudmFyIExvY2FsVHJhY2tTdGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9jYWxUcmFja1N0YXRzLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFja0lkIC0ge0BsaW5rIExvY2FsVHJhY2t9IElEXG4gICAgICogQHBhcmFtIHtTdGFuZGFyZGl6ZWRUcmFja1N0YXRzUmVwb3J0fSBzdGF0c1JlcG9ydFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJlcGFyZUZvckluc2lnaHRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9jYWxUcmFja1N0YXRzKHRyYWNrSWQsIHN0YXRzUmVwb3J0LCBwcmVwYXJlRm9ySW5zaWdodHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhY2tJZCwgc3RhdHNSZXBvcnQpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBieXRlc1NlbnQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHN0YXRzUmVwb3J0LmJ5dGVzU2VudCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBzdGF0c1JlcG9ydC5ieXRlc1NlbnRcbiAgICAgICAgICAgICAgICAgICAgOiBwcmVwYXJlRm9ySW5zaWdodHMgPyAwIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFja2V0c1NlbnQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHN0YXRzUmVwb3J0LnBhY2tldHNTZW50ID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICA/IHN0YXRzUmVwb3J0LnBhY2tldHNTZW50XG4gICAgICAgICAgICAgICAgICAgIDogcHJlcGFyZUZvckluc2lnaHRzID8gMCA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvdW5kVHJpcFRpbWU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHN0YXRzUmVwb3J0LnJvdW5kVHJpcFRpbWUgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdHNSZXBvcnQucm91bmRUcmlwVGltZVxuICAgICAgICAgICAgICAgICAgICA6IHByZXBhcmVGb3JJbnNpZ2h0cyA/IDAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExvY2FsVHJhY2tTdGF0cztcbn0oVHJhY2tTdGF0cykpO1xubW9kdWxlLmV4cG9ydHMgPSBMb2NhbFRyYWNrU3RhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbHRyYWNrc3RhdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBMb2NhbFRyYWNrU3RhdHMgPSByZXF1aXJlKCcuL2xvY2FsdHJhY2tzdGF0cycpO1xuLyoqXG4gKiBTdGF0aXN0aWNzIGZvciBhIHtAbGluayBMb2NhbFZpZGVvVHJhY2t9LlxuICogQGV4dGVuZHMgTG9jYWxUcmFja1N0YXRzXG4gKiBAcHJvcGVydHkgez9WaWRlb1RyYWNrI0RpbWVuc2lvbnN9IGNhcHR1cmVEaW1lbnNpb25zIC0gVmlkZW8gY2FwdHVyZSByZXNvbHV0aW9uXG4gKiBAcHJvcGVydHkgez9WaWRlb1RyYWNrI0RpbWVuc2lvbnN9IGRpbWVuc2lvbnMgLSBWaWRlbyBlbmNvZGluZyByZXNvbHV0aW9uXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IGNhcHR1cmVGcmFtZVJhdGUgLSBWaWRlbyBjYXB0dXJlIGZyYW1lIHJhdGVcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gZnJhbWVSYXRlIC0gVmlkZW8gZW5jb2RpbmcgZnJhbWUgcmF0ZVxuICovXG52YXIgTG9jYWxWaWRlb1RyYWNrU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvY2FsVmlkZW9UcmFja1N0YXRzLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFja0lkIC0ge0BsaW5rIExvY2FsVmlkZW9UcmFja30gSURcbiAgICAgKiBAcGFyYW0ge1N0YW5kYXJkaXplZFRyYWNrU3RhdHNSZXBvcnR9IHN0YXRzUmVwb3J0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBwcmVwYXJlRm9ySW5zaWdodHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2NhbFZpZGVvVHJhY2tTdGF0cyh0cmFja0lkLCBzdGF0c1JlcG9ydCwgcHJlcGFyZUZvckluc2lnaHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYWNrSWQsIHN0YXRzUmVwb3J0LCBwcmVwYXJlRm9ySW5zaWdodHMpIHx8IHRoaXM7XG4gICAgICAgIHZhciBjYXB0dXJlRGltZW5zaW9ucyA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdHNSZXBvcnQuZnJhbWVXaWR0aElucHV0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHN0YXRzUmVwb3J0LmZyYW1lSGVpZ2h0SW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjYXB0dXJlRGltZW5zaW9ucyA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FwdHVyZURpbWVuc2lvbnMsIHtcbiAgICAgICAgICAgICAgICB3aWR0aDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RhdHNSZXBvcnQuZnJhbWVXaWR0aElucHV0LFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0YXRzUmVwb3J0LmZyYW1lSGVpZ2h0SW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdHNSZXBvcnQuZnJhbWVXaWR0aFNlbnQgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICB0eXBlb2Ygc3RhdHNSZXBvcnQuZnJhbWVIZWlnaHRTZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGltZW5zaW9ucywge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdGF0c1JlcG9ydC5mcmFtZVdpZHRoU2VudCxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdGF0c1JlcG9ydC5mcmFtZUhlaWdodFNlbnQsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgY2FwdHVyZURpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2FwdHVyZURpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FwdHVyZUZyYW1lUmF0ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlb2Ygc3RhdHNSZXBvcnQuZnJhbWVSYXRlSW5wdXQgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdHNSZXBvcnQuZnJhbWVSYXRlSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcmFtZVJhdGU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHN0YXRzUmVwb3J0LmZyYW1lUmF0ZVNlbnQgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdHNSZXBvcnQuZnJhbWVSYXRlU2VudFxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTG9jYWxWaWRlb1RyYWNrU3RhdHM7XG59KExvY2FsVHJhY2tTdGF0cykpO1xubW9kdWxlLmV4cG9ydHMgPSBMb2NhbFZpZGVvVHJhY2tTdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsdmlkZW90cmFja3N0YXRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzID0gcmVxdWlyZSgnLi9uZXR3b3JrcXVhbGl0eW1lZGlhc3RhdHMnKTtcbi8qKlxuICoge0BsaW5rIE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0c30gZm9yIGEge0BsaW5rIFBhcnRpY2lwYW50fSdzIGF1ZGlvLlxuICovXG52YXIgTmV0d29ya1F1YWxpdHlBdWRpb1N0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXR3b3JrUXVhbGl0eUF1ZGlvU3RhdHMsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIE5ldHdvcmtRdWFsaXR5QXVkaW9TdGF0c30uXG4gICAgICogQHBhcmFtIHtNZWRpYUxldmVsc30gbWVkaWFMZXZlbHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZXR3b3JrUXVhbGl0eUF1ZGlvU3RhdHMobWVkaWFMZXZlbHMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG1lZGlhTGV2ZWxzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTmV0d29ya1F1YWxpdHlBdWRpb1N0YXRzO1xufShOZXR3b3JrUXVhbGl0eU1lZGlhU3RhdHMpKTtcbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya1F1YWxpdHlBdWRpb1N0YXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29ya3F1YWxpdHlhdWRpb3N0YXRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQmFuZHdpZHRoIG5ldHdvcmsgcXVhbGl0eSBzdGF0aXN0aWNzLlxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBhY3R1YWwgLSB0aGUgYWN0dWFsIGJhbmR3aWR0aCB1c2VkLCBpbiBiaXRzIHBlciBzZWNvbmRcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gYXZhaWxhYmxlIC0gYW4gZXN0aW1hdGUgb2YgYXZhaWxhYmxlIHVzZWFibGUgYmFuZHdpZHRoLCBpbiBiaXRzIHBlciBzZWNvbmRcbiAqIEBwcm9wZXJ0eSB7P05ldHdvcmtRdWFsaXR5TGV2ZWx9IGxldmVsIC0ge0BsaW5rIE5ldHdvcmtRdWFsaXR5TGV2ZWx9IGZvciBiYW5kd2lkdGhcbiAqL1xudmFyIE5ldHdvcmtRdWFsaXR5QmFuZHdpZHRoU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIE5ldHdvcmtRdWFsaXR5QmFuZHdpZHRoU3RhdHN9LlxuICAgICAqIEBwYXJhbSB7QmFuZHdpZHRoU3RhdHN9IGJhbmR3aWR0aFN0YXRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTmV0d29ya1F1YWxpdHlCYW5kd2lkdGhTdGF0cyhfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYS5hY3R1YWwsIGFjdHVhbCA9IF9iID09PSB2b2lkIDAgPyBudWxsIDogX2IsIF9jID0gX2EuYXZhaWxhYmxlLCBhdmFpbGFibGUgPSBfYyA9PT0gdm9pZCAwID8gbnVsbCA6IF9jLCBfZCA9IF9hLmxldmVsLCBsZXZlbCA9IF9kID09PSB2b2lkIDAgPyBudWxsIDogX2Q7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGFjdHVhbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBhY3R1YWwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF2YWlsYWJsZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBhdmFpbGFibGUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxldmVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGxldmVsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBOZXR3b3JrUXVhbGl0eUJhbmR3aWR0aFN0YXRzO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya1F1YWxpdHlCYW5kd2lkdGhTdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmtxdWFsaXR5YmFuZHdpZHRoc3RhdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBGcmFjdGlvbiBsb3N0IG5ldHdvcmsgcXVhbGl0eSBzdGF0aXN0aWNzLlxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBmcmFjdGlvbkxvc3QgLSBwYWNrZXRzIGxvc3RcbiAqIEBwcm9wZXJ0eSB7P05ldHdvcmtRdWFsaXR5TGV2ZWx9IGxldmVsIC0ge0BsaW5rIE5ldHdvcmtRdWFsaXR5TGV2ZWx9IGZvciBmcmFjdGlvbiBsb3N0XG4gKi9cbnZhciBOZXR3b3JrUXVhbGl0eUZyYWN0aW9uTG9zdFN0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBOZXR3b3JrUXVhbGl0eUZyYWN0aW9uTG9zdFN0YXRzfS5cbiAgICAgKiBAcGFyYW0ge0ZyYWN0aW9uTG9zdFN0YXRzfSBmcmFjdGlvbkxvc3RTdGF0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5ldHdvcmtRdWFsaXR5RnJhY3Rpb25Mb3N0U3RhdHMoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EuZnJhY3Rpb25Mb3N0LCBmcmFjdGlvbkxvc3QgPSBfYiA9PT0gdm9pZCAwID8gbnVsbCA6IF9iLCBfYyA9IF9hLmxldmVsLCBsZXZlbCA9IF9jID09PSB2b2lkIDAgPyBudWxsIDogX2M7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWN0aW9uTG9zdDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmcmFjdGlvbkxvc3QsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxldmVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGxldmVsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBOZXR3b3JrUXVhbGl0eUZyYWN0aW9uTG9zdFN0YXRzO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya1F1YWxpdHlGcmFjdGlvbkxvc3RTdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmtxdWFsaXR5ZnJhY3Rpb25sb3N0c3RhdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBMYXRlbmN5IG5ldHdvcmsgcXVhbGl0eSBzdGF0aXN0aWNzLlxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBqaXR0ZXIgLSBtZWRpYSBqaXR0ZXIgaW4gc2Vjb25kc1xuICogQHByb3BlcnR5IHs/bnVtYmVyfSBydHQgLSByb3VuZCB0cmlwIHRpbWUgaW4gc2Vjb25kc1xuICogQHByb3BlcnR5IHs/TmV0d29ya1F1YWxpdHlMZXZlbH0gbGV2ZWwgLSB7QGxpbmsgTmV0d29ya1F1YWxpdHlMZXZlbH0gZm9yIGxhdGVuY3lcbiAqL1xudmFyIE5ldHdvcmtRdWFsaXR5TGF0ZW5jeVN0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBOZXR3b3JrUXVhbGl0eUxhdGVuY3lTdGF0c30uXG4gICAgICogQHBhcmFtIHtMYXRlbmN5U3RhdHN9IGxhdGVuY3lTdGF0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5ldHdvcmtRdWFsaXR5TGF0ZW5jeVN0YXRzKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hLmppdHRlciwgaml0dGVyID0gX2IgPT09IHZvaWQgMCA/IG51bGwgOiBfYiwgX2MgPSBfYS5ydHQsIHJ0dCA9IF9jID09PSB2b2lkIDAgPyBudWxsIDogX2MsIF9kID0gX2EubGV2ZWwsIGxldmVsID0gX2QgPT09IHZvaWQgMCA/IG51bGwgOiBfZDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgaml0dGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGppdHRlcixcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnR0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHJ0dCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGV2ZWw6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGV2ZWwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE5ldHdvcmtRdWFsaXR5TGF0ZW5jeVN0YXRzO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya1F1YWxpdHlMYXRlbmN5U3RhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrcXVhbGl0eWxhdGVuY3lzdGF0cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgTmV0d29ya1F1YWxpdHlTZW5kU3RhdHMgPSByZXF1aXJlKCcuL25ldHdvcmtxdWFsaXR5c2VuZHN0YXRzJyk7XG52YXIgTmV0d29ya1F1YWxpdHlSZWN2U3RhdHMgPSByZXF1aXJlKCcuL25ldHdvcmtxdWFsaXR5cmVjdnN0YXRzJyk7XG4vKipcbiAqIE5ldHdvcmsgcXVhbGl0eSBzdGF0aXN0aWNzIHNoYXJlZCBiZXR3ZWVuIGEge0BsaW5rIFBhcnRpY2lwYW50fSdzIGF1ZGlvIG9yIHZpZGVvLlxuICogQHByb3BlcnR5IHtOZXR3b3JrUXVhbGl0eUxldmVsfSBzZW5kIC0ge0BsaW5rIE5ldHdvcmtRdWFsaXR5TGV2ZWx9IG9mIHRoZVxuICogIHtAbGluayBQYXJ0aWNpcGFudH0ncyBwdWJsaXNoZWQgYXVkaW8gb3IgdmlkZW9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWN2IC0ge0BsaW5rIE5ldHdvcmtRdWFsaXR5TGV2ZWx9IG9mIHRoZVxuICogIHtAbGluayBQYXJ0aWNpcGFudH0ncyBzdWJzY3JpYmVkIGF1ZGlvIG9yIHZpZGVvXG4gKiBAcHJvcGVydHkgez9OZXR3b3JrUXVhbGl0eVNlbmRPclJlY3ZTdGF0c30gc2VuZFN0YXRzIC0ge0BsaW5rIE5ldHdvcmtRdWFsaXR5U2VuZE9yUmVjdlN0YXRzfVxuICogICBiYXNlZCBvbiB3aGljaCB7QGxpbmsgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzfTxjb2RlIHN0eWxlPVwicGFkZGluZzowIDBcIj4jc2VuZDwvY29kZT5cbiAqICAgaXMgY2FsY3VsYXRlZFxuICogQHByb3BlcnR5IHs/TmV0d29ya1F1YWxpdHlTZW5kT3JSZWN2U3RhdHN9IHJlY3ZTdGF0cyAtIHtAbGluayBOZXR3b3JrUXVhbGl0eVNlbmRPclJlY3ZTdGF0c31cbiAqICAgYmFzZWQgb24gd2hpY2gge0BsaW5rIE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0c308Y29kZSBzdHlsZT1cInBhZGRpbmc6MCAwXCI+I3JlY3Y8L2NvZGU+XG4gKiAgIGlzIGNhbGN1bGF0ZWRcbiAqL1xudmFyIE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzfS5cbiAgICAgKiBAcGFyYW0ge01lZGlhTGV2ZWxzfSBtZWRpYUxldmVsc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0cyhfYSkge1xuICAgICAgICB2YXIgc2VuZCA9IF9hLnNlbmQsIHJlY3YgPSBfYS5yZWN2LCBfYiA9IF9hLnNlbmRTdGF0cywgc2VuZFN0YXRzID0gX2IgPT09IHZvaWQgMCA/IG51bGwgOiBfYiwgX2MgPSBfYS5yZWN2U3RhdHMsIHJlY3ZTdGF0cyA9IF9jID09PSB2b2lkIDAgPyBudWxsIDogX2M7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHNlbmQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2VuZCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjdjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiByZWN2LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZW5kU3RhdHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2VuZFN0YXRzID8gbmV3IE5ldHdvcmtRdWFsaXR5U2VuZFN0YXRzKHNlbmRTdGF0cykgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWN2U3RhdHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVjdlN0YXRzID8gbmV3IE5ldHdvcmtRdWFsaXR5UmVjdlN0YXRzKHJlY3ZTdGF0cykgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBOZXR3b3JrUXVhbGl0eU1lZGlhU3RhdHM7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrUXVhbGl0eU1lZGlhU3RhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrcXVhbGl0eW1lZGlhc3RhdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBOZXR3b3JrUXVhbGl0eVNlbmRPclJlY3ZTdGF0cyA9IHJlcXVpcmUoJy4vbmV0d29ya3F1YWxpdHlzZW5kb3JyZWN2c3RhdHMnKTtcbi8qKlxuICoge0BsaW5rIE5ldHdvcmtRdWFsaXR5U2VuZE9yUmVjdlN0YXRzfSBiYXNlZCBvbiB3aGljaCBhIHtAbGluayBQYXJ0aWNpcGFudH0nc1xuICoge0BsaW5rIE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0c308Y29kZSBzdHlsZT1cInBhZGRpbmc6MCAwXCI+I3JlY3Y8L2NvZGU+IGlzIGNhbGN1bGF0ZWQuXG4gKi9cbnZhciBOZXR3b3JrUXVhbGl0eVJlY3ZTdGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV0d29ya1F1YWxpdHlSZWN2U3RhdHMsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIE5ldHdvcmtRdWFsaXR5UmVjdlN0YXRzfS5cbiAgICAgKiBAcGFyYW0ge1NlbmRPclJlY3ZTdGF0c30gc2VuZE9yUmVjdlN0YXRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTmV0d29ya1F1YWxpdHlSZWN2U3RhdHMoc2VuZE9yUmVjdlN0YXRzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzZW5kT3JSZWN2U3RhdHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBOZXR3b3JrUXVhbGl0eVJlY3ZTdGF0cztcbn0oTmV0d29ya1F1YWxpdHlTZW5kT3JSZWN2U3RhdHMpKTtcbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya1F1YWxpdHlSZWN2U3RhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrcXVhbGl0eXJlY3ZzdGF0cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgTmV0d29ya1F1YWxpdHlCYW5kd2lkdGhTdGF0cyA9IHJlcXVpcmUoJy4vbmV0d29ya3F1YWxpdHliYW5kd2lkdGhzdGF0cycpO1xudmFyIE5ldHdvcmtRdWFsaXR5RnJhY3Rpb25Mb3N0U3RhdHMgPSByZXF1aXJlKCcuL25ldHdvcmtxdWFsaXR5ZnJhY3Rpb25sb3N0c3RhdHMnKTtcbnZhciBOZXR3b3JrUXVhbGl0eUxhdGVuY3lTdGF0cyA9IHJlcXVpcmUoJy4vbmV0d29ya3F1YWxpdHlsYXRlbmN5c3RhdHMnKTtcbi8qKlxuICogTmV0d29yayBxdWFsaXR5IHN0YXRpc3RpY3Mgc2hhcmVkIGJldHdlZW4ge0BsaW5rIE5ldHdvcmtRdWFsaXR5U2VuZFN0YXRzfSBhbmRcbiAqIHtAbGluayBOZXR3b3JrUXVhbGl0eVJlY3ZTdGF0c30gYmFzZWQgb24gd2hpY2ggYSB7QGxpbmsgUGFydGljaXBhbnR9J3NcbiAqIHtAbGluayBOZXR3b3JrUXVhbGl0eU1lZGlhU3RhdHN9PGNvZGUgc3R5bGU9XCJwYWRkaW5nOjAgMFwiPiNzZW5kPC9jb2RlPiBvclxuICoge0BsaW5rIE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0c308Y29kZSBzdHlsZT1cInBhZGRpbmc6MCAwXCI+I3JlY3Y8L2NvZGU+IGlzIGNhbGN1bGF0ZWQuXG4gKiBAcHJvcGVydHkgez9OZXR3b3JrUXVhbGl0eUJhbmR3aWR0aFN0YXRzfSBiYW5kd2lkdGggLSBiYW5kd2lkdGggc3RhdGlzdGljc1xuICogQHByb3BlcnR5IHs/TmV0d29ya1F1YWxpdHlMYXRlbmN5U3RhdHN9IGxhdGVuY3kgLSBsYXRlbmN5IHN0YXRpc3RpY3NcbiAqIEBwcm9wZXJ0eSB7P05ldHdvcmtRdWFsaXR5RnJhY3Rpb25Mb3N0U3RhdHN9IGZyYWN0aW9uTG9zdCAtIGZyYWN0aW9uIGxvc3Qgc3RhdGlzdGljc1xuICovXG52YXIgTmV0d29ya1F1YWxpdHlTZW5kT3JSZWN2U3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIE5ldHdvcmtRdWFsaXR5U2VuZE9yUmVjdlN0YXRzfS5cbiAgICAgKiBAcGFyYW0ge1NlbmRPclJlY3ZTdGF0c30gc2VuZE9yUmVjdlN0YXRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTmV0d29ya1F1YWxpdHlTZW5kT3JSZWN2U3RhdHMoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EuYmFuZHdpZHRoLCBiYW5kd2lkdGggPSBfYiA9PT0gdm9pZCAwID8gbnVsbCA6IF9iLCBfYyA9IF9hLmZyYWN0aW9uTG9zdCwgZnJhY3Rpb25Mb3N0ID0gX2MgPT09IHZvaWQgMCA/IG51bGwgOiBfYywgX2QgPSBfYS5sYXRlbmN5LCBsYXRlbmN5ID0gX2QgPT09IHZvaWQgMCA/IG51bGwgOiBfZDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgYmFuZHdpZHRoOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGJhbmR3aWR0aCA/IG5ldyBOZXR3b3JrUXVhbGl0eUJhbmR3aWR0aFN0YXRzKGJhbmR3aWR0aCkgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcmFjdGlvbkxvc3Q6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnJhY3Rpb25Mb3N0ID8gbmV3IE5ldHdvcmtRdWFsaXR5RnJhY3Rpb25Mb3N0U3RhdHMoZnJhY3Rpb25Mb3N0KSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhdGVuY3k6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGF0ZW5jeSA/IG5ldyBOZXR3b3JrUXVhbGl0eUxhdGVuY3lTdGF0cyhsYXRlbmN5KSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE5ldHdvcmtRdWFsaXR5U2VuZE9yUmVjdlN0YXRzO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gTmV0d29ya1F1YWxpdHlTZW5kT3JSZWN2U3RhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrcXVhbGl0eXNlbmRvcnJlY3ZzdGF0cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIE5ldHdvcmtRdWFsaXR5U2VuZE9yUmVjdlN0YXRzID0gcmVxdWlyZSgnLi9uZXR3b3JrcXVhbGl0eXNlbmRvcnJlY3ZzdGF0cycpO1xuLyoqXG4gKiB7QGxpbmsgTmV0d29ya1F1YWxpdHlTZW5kT3JSZWN2U3RhdHN9IGJhc2VkIG9uIHdoaWNoIGEge0BsaW5rIFBhcnRpY2lwYW50fSdzXG4gKiB7QGxpbmsgTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzfTxjb2RlIHN0eWxlPVwicGFkZGluZzowIDBcIj4jc2VuZDwvY29kZT4gaXMgY2FsY3VsYXRlZC5cbiAqL1xudmFyIE5ldHdvcmtRdWFsaXR5U2VuZFN0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXR3b3JrUXVhbGl0eVNlbmRTdGF0cywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgTmV0d29ya1F1YWxpdHlTZW5kU3RhdHN9LlxuICAgICAqIEBwYXJhbSB7U2VuZE9yUmVjdlN0YXRzfSBzZW5kT3JSZWN2U3RhdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZXR3b3JrUXVhbGl0eVNlbmRTdGF0cyhzZW5kT3JSZWN2U3RhdHMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNlbmRPclJlY3ZTdGF0cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE5ldHdvcmtRdWFsaXR5U2VuZFN0YXRzO1xufShOZXR3b3JrUXVhbGl0eVNlbmRPclJlY3ZTdGF0cykpO1xubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrUXVhbGl0eVNlbmRTdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmtxdWFsaXR5c2VuZHN0YXRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBOZXR3b3JrUXVhbGl0eUF1ZGlvU3RhdHMgPSByZXF1aXJlKCcuL25ldHdvcmtxdWFsaXR5YXVkaW9zdGF0cycpO1xudmFyIE5ldHdvcmtRdWFsaXR5VmlkZW9TdGF0cyA9IHJlcXVpcmUoJy4vbmV0d29ya3F1YWxpdHl2aWRlb3N0YXRzJyk7XG4vKipcbiAqIE5ldHdvcmsgcXVhbGl0eSBzdGF0aXN0aWNzIGZvciBhIHtAbGluayBQYXJ0aWNpcGFudH0uXG4gKiBAcHJvcGVydHkge05ldHdvcmtRdWFsaXR5TGV2ZWx9IGxldmVsIC0ge0BsaW5rIE5ldHdvcmtRdWFsaXR5TGV2ZWx9IG9mIHRoZSB7QGxpbmsgUGFydGljaXBhbnR9XG4gKiBAcHJvcGVydHkgez9OZXR3b3JrUXVhbGl0eUF1ZGlvU3RhdHN9IGF1ZGlvIC0ge0BsaW5rIE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0c31cbiAqICAgZm9yIGF1ZGlvOyA8Y29kZT5udWxsPC9jb2RlPiBpZiB7QGxpbmsgTmV0d29ya1F1YWxpdHlWZXJib3NpdHl9IGlzIHtAbGluayBOZXR3b3JrUXVhbGl0eVZlcmJvc2l0eX08Y29kZSBzdHlsZT1cInBhZGRpbmc6MCAwXCI+I21pbmltYWw8L2NvZGU+XG4gKiAgIG9yIGJlbG93XG4gKiBAcHJvcGVydHkgez9OZXR3b3JrUXVhbGl0eVZpZGVvU3RhdHN9IHZpZGVvIC0ge0BsaW5rIE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0c31cbiAqICAgZm9yIHZpZGVvOyA8Y29kZT5udWxsPC9jb2RlPiBpZiB7QGxpbmsgTmV0d29ya1F1YWxpdHlWZXJib3NpdHl9IGlzIHtAbGluayBOZXR3b3JrUXVhbGl0eVZlcmJvc2l0eX08Y29kZSBzdHlsZT1cInBhZGRpbmc6MCAwXCI+I21pbmltYWw8L2NvZGU+XG4gKiAgIG9yIGJlbG93XG4gKi9cbnZhciBOZXR3b3JrUXVhbGl0eVN0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBOZXR3b3JrUXVhbGl0eVN0YXRzfS5cbiAgICAgKiBAcGFyYW0ge05ldHdvcmtRdWFsaXR5TGV2ZWxzfSBuZXR3b3JrUXVhbGl0eUxldmVsc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5ldHdvcmtRdWFsaXR5U3RhdHMoX2EpIHtcbiAgICAgICAgdmFyIGxldmVsID0gX2EubGV2ZWwsIGF1ZGlvID0gX2EuYXVkaW8sIHZpZGVvID0gX2EudmlkZW87XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGxldmVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGxldmVsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdWRpbzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBhdWRpbyA/IG5ldyBOZXR3b3JrUXVhbGl0eUF1ZGlvU3RhdHMoYXVkaW8pIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmlkZW8gPyBuZXcgTmV0d29ya1F1YWxpdHlWaWRlb1N0YXRzKHZpZGVvKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE5ldHdvcmtRdWFsaXR5U3RhdHM7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrUXVhbGl0eVN0YXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29ya3F1YWxpdHlzdGF0cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIE5ldHdvcmtRdWFsaXR5TWVkaWFTdGF0cyA9IHJlcXVpcmUoJy4vbmV0d29ya3F1YWxpdHltZWRpYXN0YXRzJyk7XG4vKipcbiAqIHtAbGluayBOZXR3b3JrUXVhbGl0eU1lZGlhU3RhdHN9IGZvciBhIHtAbGluayBQYXJ0aWNpcGFudH0ncyB2aWRlby5cbiAqL1xudmFyIE5ldHdvcmtRdWFsaXR5VmlkZW9TdGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV0d29ya1F1YWxpdHlWaWRlb1N0YXRzLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBOZXR3b3JrUXVhbGl0eVZpZGVvU3RhdHN9LlxuICAgICAqIEBwYXJhbSB7TWVkaWFMZXZlbHN9IG1lZGlhTGV2ZWxzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTmV0d29ya1F1YWxpdHlWaWRlb1N0YXRzKG1lZGlhTGV2ZWxzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBtZWRpYUxldmVscykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE5ldHdvcmtRdWFsaXR5VmlkZW9TdGF0cztcbn0oTmV0d29ya1F1YWxpdHlNZWRpYVN0YXRzKSk7XG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtRdWFsaXR5VmlkZW9TdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmtxdWFsaXR5dmlkZW9zdGF0cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgUmVjZWl2ZXJSZXBvcnQgPSByZXF1aXJlKCcuL3JlY2VpdmVycmVwb3J0Jyk7XG52YXIgU2VuZGVyUmVwb3J0ID0gcmVxdWlyZSgnLi9zZW5kZXJyZXBvcnQnKTtcbi8qKlxuICogQGludGVyZmFjZSBTZW5kZXJBbmRSZWNlaXZlclJlcG9ydHNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8U2VuZGVyUmVwb3J0Pn0gc2VuZFxuICogQHByb3BlcnR5IHtBcnJheTxSZWNlaXZlclJlcG9ydD59IHJlY3ZcbiAqL1xuLyoqXG4gKiBAaW50ZXJmYWNlIFNlbmRlckFuZFJlY2VpdmVyU3VtbWFyeVxuICogQHByb3BlcnR5IHtTZW5kZXJTdW1tYXJ5fSBzZW5kXG4gKiBAcHJvcGVydHkge1JlY2VpdmVyU3VtbWFyeX0gcmVjdlxuICovXG4vKipcbiAqIEBpbnRlcmZhY2UgUGVlckNvbm5lY3Rpb25TdW1tYXJ5XG4gKiBAcHJvcGVydHkge0ljZVJlcG9ydH0gaWNlXG4gKiBAcHJvcGVydHkge1NlbmRlclN1bW1hcnl9IHNlbmRcbiAqIEBwcm9wZXJ0eSB7UmVjZWl2ZXJTdW1tYXJ5fSByZWN2XG4gKiBAcHJvcGVydHkge1NlbmRlckFuZFJlY2VpdmVyU3VtbWFyeX0gYXVkaW9cbiAqIEBwcm9wZXJ0eSB7U2VuZGVyQW5kUmVjZWl2ZXJTdW1tYXJ5fSB2aWRlb1xuICovXG4vKipcbiAqIEBwcm9wZXJ0eSB7SWNlUmVwb3J0fSBpY2VcbiAqIEByb3BlcnR5IHtTZW5kZXJBbmRSZWNlaXZlclJlcG9ydHN9IGF1ZGlvXG4gKiBAcm9wZXJ0eSB7U2VuZGVyQW5kUmVjZWl2ZXJSZXBvcnRzfSB2aWRlb1xuICovXG52YXIgUGVlckNvbm5lY3Rpb25SZXBvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFBlZXJDb25uZWN0aW9uUmVwb3J0fS5cbiAgICAgKiBAcGFyYW0ge0ljZVJlcG9ydH0gaWNlXG4gICAgICogQHBhcmFtIHtTZW5kZXJBbmRSZWNlaXZlclJlcG9ydHN9IGF1ZGlvXG4gICAgICogQHBhcmFtIHtTZW5kZXJBbmRSZWNlaXZlclJlcG9ydHN9IHZpZGVvXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGVlckNvbm5lY3Rpb25SZXBvcnQoaWNlLCBhdWRpbywgdmlkZW8pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgaWNlOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaWNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXVkaW86IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhdWRpb1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmlkZW9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1bW1hcml6ZSB0aGUge0BsaW5rIFBlZXJDb25uZWN0aW9uUmVwb3J0fSBieSBzdW1tYXJpemluZyBpdHNcbiAgICAgKiB7QGxpbmsgU2VuZGVyUmVwb3J0fXMgYW5kIHtAbGluayBSZWNlaXZlclJlcG9ydH1zLlxuICAgICAqIEByZXR1cm5zIHtQZWVyQ29ubmVjdGlvblN1bW1hcnl9XG4gICAgICovXG4gICAgUGVlckNvbm5lY3Rpb25SZXBvcnQucHJvdG90eXBlLnN1bW1hcml6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbmRlclJlcG9ydHMgPSB0aGlzLmF1ZGlvLnNlbmQuY29uY2F0KHRoaXMudmlkZW8uc2VuZCk7XG4gICAgICAgIHZhciBzZW5kID0gU2VuZGVyUmVwb3J0LnN1bW1hcml6ZShzZW5kZXJSZXBvcnRzKTtcbiAgICAgICAgdmFyIHJlY2VpdmVyUmVwb3J0cyA9IHRoaXMuYXVkaW8ucmVjdi5jb25jYXQodGhpcy52aWRlby5yZWN2KTtcbiAgICAgICAgdmFyIHJlY3YgPSBSZWNlaXZlclJlcG9ydC5zdW1tYXJpemUocmVjZWl2ZXJSZXBvcnRzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGljZTogdGhpcy5pY2UsXG4gICAgICAgICAgICBzZW5kOiBzZW5kLFxuICAgICAgICAgICAgcmVjdjogcmVjdixcbiAgICAgICAgICAgIGF1ZGlvOiB7XG4gICAgICAgICAgICAgICAgc2VuZDogU2VuZGVyUmVwb3J0LnN1bW1hcml6ZSh0aGlzLmF1ZGlvLnNlbmQpLFxuICAgICAgICAgICAgICAgIHJlY3Y6IFJlY2VpdmVyUmVwb3J0LnN1bW1hcml6ZSh0aGlzLmF1ZGlvLnJlY3YpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICAgICAgICBzZW5kOiBTZW5kZXJSZXBvcnQuc3VtbWFyaXplKHRoaXMudmlkZW8uc2VuZCksXG4gICAgICAgICAgICAgICAgcmVjdjogUmVjZWl2ZXJSZXBvcnQuc3VtbWFyaXplKHRoaXMudmlkZW8ucmVjdilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBQZWVyQ29ubmVjdGlvblJlcG9ydDtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFBlZXJDb25uZWN0aW9uUmVwb3J0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVlcmNvbm5lY3Rpb25yZXBvcnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgICAgICB0b1tqXSA9IGZyb21baV07XG4gICAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBndWVzc0Jyb3dzZXIgPSByZXF1aXJlKCdAdHdpbGlvL3dlYnJ0Yy9saWIvdXRpbCcpLmd1ZXNzQnJvd3NlcjtcbnZhciBJY2VSZXBvcnRGYWN0b3J5ID0gcmVxdWlyZSgnLi9pY2VyZXBvcnRmYWN0b3J5Jyk7XG52YXIgUGVlckNvbm5lY3Rpb25SZXBvcnQgPSByZXF1aXJlKCcuL3BlZXJjb25uZWN0aW9ucmVwb3J0Jyk7XG52YXIgUmVjZWl2ZXJSZXBvcnRGYWN0b3J5ID0gcmVxdWlyZSgnLi9yZWNlaXZlcnJlcG9ydGZhY3RvcnknKTtcbnZhciBTZW5kZXJSZXBvcnRGYWN0b3J5ID0gcmVxdWlyZSgnLi9zZW5kZXJyZXBvcnRmYWN0b3J5Jyk7XG4vKipcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IFRyYWNrSWRcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBTdGF0c0lkXG4gKi9cbi8qKlxuICogQGludGVyZmFjZSBTZW5kZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZVxuICogQHByb3BlcnR5IHtNYXA8U3RhdHNJZCwgU2VuZGVyUmVwb3J0RmFjdG9yeT59IGF1ZGlvXG4gKiBAcHJvcGVydHkge01hcDxTdGF0c0lkLCBTZW5kZXJSZXBvcnRGYWN0b3J5Pn0gdmlkZW9cbiAqL1xuLyoqXG4gKiBAaW50ZXJmYWNlIFJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGVcbiAqIEBwcm9wZXJ0eSB7TWFwPFN0YXRzSWQsIFJlY2VpdmVyUmVwb3J0RmFjdG9yeT59IGF1ZGlvXG4gKiBAcHJvcGVydHkge01hcDxTdGF0c0lkLCBSZWNlaXZlclJlcG9ydEZhY3Rvcnk+fSB2aWRlb1xuICovXG4vKipcbiAqIEBpbnRlcmZhY2UgU2VuZGVyQW5kUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNcbiAqIEBwcm9wZXJ0eSB7TWFwPFN0YXRzSWQsIFNlbmRlclJlcG9ydEZhY3Rvcmllcz59IHNlbmRcbiAqIEBwcm9wZXJ0eSB7TWFwPFN0YXRzSWQsIFJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzPn0gcmVjdlxuICovXG4vKipcbiAqIEBpbnRlcmZhY2Uge1N0YXRzSWRzQnlNZWRpYVR5cGV9XG4gKiBAcHJvcGVydHkge1NldDxTdGF0c0lkPn0gYXVkaW9cbiAqIEBwcm9wZXJ0eSB7U2V0PFN0YXRzSWQ+fSB2aWRlb1xuICovXG4vKipcbiAqIEBwcm9wZXJ0eSB7UlRDUGVlckNvbm5lY3Rpb259IHBjXG4gKiBAcHJvcGVydHkge0ljZVJlcG9ydEZhY3Rvcnl9IGljZVJlcG9ydEZhY3RvcnlcbiAqIEBwcm9wZXJ0eSB7U2VuZGVyQW5kUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXN9IGF1ZGlvXG4gKiBAcHJvcGVydHkge1NlbmRlckFuZFJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzfSB2aWRlb1xuICogQHByb3BlcnR5IHs/UGVlckNvbm5lY3Rpb25SZXBvcnR9IGxhc3RSZXBvcnRcbiAqL1xudmFyIFBlZXJDb25uZWN0aW9uUmVwb3J0RmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgUGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5fS5cbiAgICAgKiBAcGFyYW0ge1JUQ1BlZXJDb25uZWN0aW9ufSBwY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBlZXJDb25uZWN0aW9uUmVwb3J0RmFjdG9yeShwYykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBwYzoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBjXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWNlOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IEljZVJlcG9ydEZhY3RvcnkoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF1ZGlvOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBzZW5kOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIHJlY3Y6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aWRlbzoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgICAgICByZWN2OiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdFJlcG9ydDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHtAbGluayBQZWVyQ29ubmVjdGlvblJlcG9ydH0uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UGVlckNvbm5lY3Rpb25SZXBvcnQ+fVxuICAgICAqL1xuICAgIFBlZXJDb25uZWN0aW9uUmVwb3J0RmFjdG9yeS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVwZGF0ZVByb21pc2UgPSBndWVzc0Jyb3dzZXIoKSA9PT0gJ2ZpcmVmb3gnXG4gICAgICAgICAgICA/IHVwZGF0ZUZpcmVmb3godGhpcylcbiAgICAgICAgICAgIDogdXBkYXRlQ2hyb21lKHRoaXMpO1xuICAgICAgICByZXR1cm4gdXBkYXRlUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb1NlbmRlclJlcG9ydEZhY3RvcmllcyA9IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChfdGhpcy5hdWRpby5zZW5kLnZhbHVlcygpKSk7XG4gICAgICAgICAgICB2YXIgdmlkZW9TZW5kZXJSZXBvcnRGYWN0b3JpZXMgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoX3RoaXMudmlkZW8uc2VuZC52YWx1ZXMoKSkpO1xuICAgICAgICAgICAgdmFyIGF1ZGlvUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXMgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoX3RoaXMuYXVkaW8ucmVjdi52YWx1ZXMoKSkpO1xuICAgICAgICAgICAgdmFyIHZpZGVvUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXMgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoX3RoaXMudmlkZW8ucmVjdi52YWx1ZXMoKSkpO1xuICAgICAgICAgICAgdmFyIHJlcG9ydCA9IG5ldyBQZWVyQ29ubmVjdGlvblJlcG9ydChfdGhpcy5pY2UubGFzdFJlcG9ydCwge1xuICAgICAgICAgICAgICAgIHNlbmQ6IGF1ZGlvU2VuZGVyUmVwb3J0RmFjdG9yaWVzLm1hcChmdW5jdGlvbiAoZmFjdG9yeSkgeyByZXR1cm4gZmFjdG9yeS5sYXN0UmVwb3J0OyB9KS5maWx0ZXIoZnVuY3Rpb24gKHJlcG9ydCkgeyByZXR1cm4gcmVwb3J0OyB9KSxcbiAgICAgICAgICAgICAgICByZWN2OiBhdWRpb1JlY2VpdmVyUmVwb3J0RmFjdG9yaWVzLm1hcChmdW5jdGlvbiAoZmFjdG9yeSkgeyByZXR1cm4gZmFjdG9yeS5sYXN0UmVwb3J0OyB9KS5maWx0ZXIoZnVuY3Rpb24gKHJlcG9ydCkgeyByZXR1cm4gcmVwb3J0OyB9KVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHNlbmQ6IHZpZGVvU2VuZGVyUmVwb3J0RmFjdG9yaWVzLm1hcChmdW5jdGlvbiAoZmFjdG9yeSkgeyByZXR1cm4gZmFjdG9yeS5sYXN0UmVwb3J0OyB9KS5maWx0ZXIoZnVuY3Rpb24gKHJlcG9ydCkgeyByZXR1cm4gcmVwb3J0OyB9KSxcbiAgICAgICAgICAgICAgICByZWN2OiB2aWRlb1JlY2VpdmVyUmVwb3J0RmFjdG9yaWVzLm1hcChmdW5jdGlvbiAoZmFjdG9yeSkgeyByZXR1cm4gZmFjdG9yeS5sYXN0UmVwb3J0OyB9KS5maWx0ZXIoZnVuY3Rpb24gKHJlcG9ydCkgeyByZXR1cm4gcmVwb3J0OyB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5sYXN0UmVwb3J0ID0gcmVwb3J0O1xuICAgICAgICAgICAgcmV0dXJuIHJlcG9ydDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5O1xufSgpKTtcbi8qKlxuICogQ29uc3RydWN0IGEgTWFwIGZyb20gTWVkaWFTdHJlYW1UcmFjayBJZHMgdG8gUlRDU3RhdHNSZXBvcnRzLlxuICogQHBhcmFtIHtBcnJheTxSVENSdHBTZW5kZXI+fEFycmF5PFJUQ1J0cFJlY2VpdmVyPn0gc2VuZGVyc09yUmVjZWl2ZXJzIC0gZWFjaFxuICogICBSVENSdHBTZW5kZXIgc2hvdWxkIGhhdmUgYSBub24tbnVsbCB0cmFja1xuICogQHJldHVybnMge1Byb21pc2U8TWFwPFRyYWNrSWQsIFJUQ1N0YXRzPj59XG4gKi9cbmZ1bmN0aW9uIGdldFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRzKHNlbmRlcnNPclJlY2VpdmVycykge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChzZW5kZXJzT3JSZWNlaXZlcnMubWFwKGZ1bmN0aW9uIChzZW5kZXJPclJlY2VpdmVyKSB7XG4gICAgICAgIHZhciB0cmFja0lkID0gc2VuZGVyT3JSZWNlaXZlci50cmFjay5pZDtcbiAgICAgICAgcmV0dXJuIHNlbmRlck9yUmVjZWl2ZXIuZ2V0U3RhdHMoKS50aGVuKGZ1bmN0aW9uIChyZXBvcnQpIHtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1yb2JlcnRzKTogV2UgaGF2ZSB0byByZXdyaXRlIElkcyBkdWUgdG8gdGhpcyBidWc6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0NjM0MzBcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMocmVwb3J0LnZhbHVlcygpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHMgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRzLnR5cGUgPT09ICdpbmJvdW5kLXJ0cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLmlkID0gdHJhY2tJZCArIFwiLVwiICsgc3RhdHMuaWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3RyYWNrSWQsIHJlcG9ydF07XG4gICAgICAgIH0pO1xuICAgIH0pKS50aGVuKGZ1bmN0aW9uIChwYWlycykgeyByZXR1cm4gbmV3IE1hcChwYWlycyk7IH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge1NlbmRlclJlcG9ydEZhY3RvcnkuY29uc3RydWN0b3J9IFNlbmRlclJlcG9ydEZhY3RvcnlcbiAqIEBwYXJhbSB7U2VuZGVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGV9IHNlbmRlcnNCeU1lZGlhVHlwZVxuICogQHBhcmFtIHtSVENTdGF0c1JlcG9ydH0gcmVwb3J0XG4gKiBAcGFyYW0ge1JUQ1N0YXRzfSBzdGF0c1xuICogQHBhcmFtIHtUcmFja0lkfSBbdHJhY2tJZF1cbiAqIEByZXR1cm5zIHs/U2VuZGVyUmVwb3J0RmFjdG9yeX1cbiAqLyAvKipcbiogQHBhcmFtIHtSZWNlaXZlclJlcG9ydEZhY3RvcnkuY29uc3RydWN0b3J9IFJlY2VpdmVyUmVwb3J0RmFjdG9yeVxuKiBAcGFyYW0ge1JlY2VpdmVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGV9IHJlY2VpdmVyc0J5TWVkaWFUeXBlXG4qIEBwYXJhbSB7UlRDU3RhdHNSZXBvcnR9IHJlcG9ydFxuKiBAcGFyYW0ge1JUQ1N0YXRzfSBzdGF0c1xuKiBAcGFyYW0ge1RyYWNrSWR9IFt0cmFja0lkXVxuKiBAcmV0dXJucyB7P1JlY2VpdmVyUmVwb3J0RmFjdG9yeX1cbiovXG5mdW5jdGlvbiBnZXRPckNyZWF0ZVNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5KFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5LCBzZW5kZXJzT3JSZWNlaXZlcnNCeU1lZGlhVHlwZSwgcmVwb3J0LCBzdGF0cywgdHJhY2tJZCkge1xuICAgIHZhciBzZW5kZXJzT3JSZWNlaXZlcnMgPSBzZW5kZXJzT3JSZWNlaXZlcnNCeU1lZGlhVHlwZVtzdGF0cy5tZWRpYVR5cGVdO1xuICAgIGlmICghdHJhY2tJZCkge1xuICAgICAgICB2YXIgdHJhY2tTdGF0cyA9IHJlcG9ydC5nZXQoc3RhdHMudHJhY2tJZCk7XG4gICAgICAgIGlmICh0cmFja1N0YXRzKSB7XG4gICAgICAgICAgICB0cmFja0lkID0gdHJhY2tTdGF0cy50cmFja0lkZW50aWZpZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbmRlcnNPclJlY2VpdmVycyAmJiB0cmFja0lkKSB7XG4gICAgICAgIGlmIChzZW5kZXJzT3JSZWNlaXZlcnMuaGFzKHN0YXRzLmlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbmRlcnNPclJlY2VpdmVycy5nZXQoc3RhdHMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZW5kZXJPclJlY2VpdmVyRmFjdG9yeSA9IG5ldyBTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeSh0cmFja0lkLCBzdGF0cyk7XG4gICAgICAgIHNlbmRlcnNPclJlY2VpdmVycy5zZXQoc3RhdHMuaWQsIHNlbmRlck9yUmVjZWl2ZXJGYWN0b3J5KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5fSBmYWN0b3J5XG4gKiBAcmV0dXJucyB7U2VuZGVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbmRlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlKGZhY3RvcnkpIHtcbiAgICByZXR1cm4geyBhdWRpbzogZmFjdG9yeS5hdWRpby5zZW5kLCB2aWRlbzogZmFjdG9yeS52aWRlby5zZW5kIH07XG59XG4vKipcbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5fSBmYWN0b3J5XG4gKiBAcmV0dXJucyB7UmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZX1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZShmYWN0b3J5KSB7XG4gICAgcmV0dXJuIHsgYXVkaW86IGZhY3RvcnkuYXVkaW8ucmVjdiwgdmlkZW86IGZhY3RvcnkudmlkZW8ucmVjdiB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge1BlZXJDb25uZWN0aW9uUmVwb3J0RmFjdG9yeX0gZmFjdG9yeVxuICogQHBhcmFtIHtSVENTdGF0c1JlcG9ydH0gcmVwb3J0XG4gKiBAcGFyYW0ge1JUQ1N0YXRzfSBzdGF0c1xuICogQHBhcmFtIHtUcmFja0lkfSBbdHJhY2tJZF1cbiAqIEByZXR1cm5zIHs/U2VuZGVyUmVwb3J0RmFjdG9yeX1cbiAqL1xuZnVuY3Rpb24gZ2V0T3JDcmVhdGVTZW5kZXJSZXBvcnRGYWN0b3J5KGZhY3RvcnksIHJlcG9ydCwgc3RhdHMsIHRyYWNrSWQpIHtcbiAgICByZXR1cm4gZ2V0T3JDcmVhdGVTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeShTZW5kZXJSZXBvcnRGYWN0b3J5LCBnZXRTZW5kZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZShmYWN0b3J5KSwgcmVwb3J0LCBzdGF0cywgdHJhY2tJZCk7XG59XG4vKipcbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5fSBmYWN0b3J5XG4gKiBAcGFyYW0ge1JUQ1N0YXRzUmVwb3J0fSByZXBvcnRcbiAqIEBwYXJhbSB7UlRDU3RhdHN9IHN0YXRzXG4gKiBAcGFyYW0ge1RyYWNrSWR9IFt0cmFja0lkXVxuICogQHJldHVybnMgez9SZWNlaXZlclJlcG9ydEZhY3Rvcnl9XG4gKi9cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlUmVjZWl2ZXJSZXBvcnRGYWN0b3J5KGZhY3RvcnksIHJlcG9ydCwgc3RhdHMsIHRyYWNrSWQpIHtcbiAgICByZXR1cm4gZ2V0T3JDcmVhdGVTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeShSZWNlaXZlclJlcG9ydEZhY3RvcnksIGdldFJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGUoZmFjdG9yeSksIHJlcG9ydCwgc3RhdHMsIHRyYWNrSWQpO1xufVxuLyoqXG4gKiBAcGFyYW0ge1BlZXJDb25uZWN0aW9uUmVwb3J0RmFjdG9yeX0gZmFjdG9yeVxuICogQHJldHVucyB7U3RhdHNJZHNCeU1lZGlhVHlwZX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VuZGVyUmVwb3J0RmFjdG9yeUlkc0J5TWVkaWFUeXBlKGZhY3RvcnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhdWRpbzogbmV3IFNldChmYWN0b3J5LmF1ZGlvLnNlbmQua2V5cygpKSxcbiAgICAgICAgdmlkZW86IG5ldyBTZXQoZmFjdG9yeS52aWRlby5zZW5kLmtleXMoKSlcbiAgICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge1BlZXJDb25uZWN0aW9uUmVwb3J0RmFjdG9yeX0gZmFjdG9yeVxuICogQHJldHVucyB7U3RhdHNJZHNCeU1lZGlhVHlwZX1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzQnlNZWRpYVR5cGUoZmFjdG9yeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGF1ZGlvOiBuZXcgU2V0KGZhY3RvcnkuYXVkaW8ucmVjdi5rZXlzKCkpLFxuICAgICAgICB2aWRlbzogbmV3IFNldChmYWN0b3J5LnZpZGVvLnJlY3Yua2V5cygpKVxuICAgIH07XG59XG4vKipcbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5fSBmYWN0b3J5XG4gKiBAcGFyYW0ge1JUQ1N0YXRzUmVwb3J0fSByZXBvcnRcbiAqIEBwYXJhbSB7U3RhdHNJZHNCeU1lZGlhVHlwZX0gc2VuZGVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGVcbiAqIEBwYXJhbSB7VHJhY2tJZH0gW3RyYWNrSWRdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gdXBkYXRlU2VuZGVyUmVwb3J0cyhmYWN0b3J5LCByZXBvcnQsIHNlbmRlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZUJ5TWVkaWFUeXBlLCB0cmFja0lkKSB7XG4gICAgdmFyIGVfMiwgX2E7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhyZXBvcnQudmFsdWVzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgc3RhdHMgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIGlmIChzdGF0cy50eXBlID09PSAnb3V0Ym91bmQtcnRwJyAmJiAhc3RhdHMuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3Vlc3NCcm93c2VyKCkgIT09ICdmaXJlZm94JyAmJiAhc3RhdHMudHJhY2tJZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNlbmRlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZSA9IHNlbmRlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZUJ5TWVkaWFUeXBlW3N0YXRzLm1lZGlhVHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKHNlbmRlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZW5kZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGUuZGVsZXRlKHN0YXRzLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNlbmRlclJlcG9ydEZhY3RvcnkgPSBnZXRPckNyZWF0ZVNlbmRlclJlcG9ydEZhY3RvcnkoZmFjdG9yeSwgcmVwb3J0LCBzdGF0cywgdHJhY2tJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbmRlclJlcG9ydEZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW90ZUluYm91bmRTdGF0cyA9IHJlcG9ydC5nZXQoc3RhdHMucmVtb3RlSWQpO1xuICAgICAgICAgICAgICAgICAgICBzZW5kZXJSZXBvcnRGYWN0b3J5Lm5leHQodHJhY2tJZCB8fCBzZW5kZXJSZXBvcnRGYWN0b3J5LnRyYWNrSWQsIHN0YXRzLCByZW1vdGVJbmJvdW5kU3RhdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5fSBmYWN0b3J5XG4gKiBAcGFyYW0ge1JUQ1N0YXRzUmVwb3J0fSByZXBvcnRcbiAqIEBwYXJhbSB7U3RhdHNJZHNCeU1lZGlhVHlwZX0gcmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGVCeU1lZGlhVHlwZVxuICogQHBhcmFtIHtUcmFja0lkfSBbdHJhY2tJZF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGVSZWNlaXZlclJlcG9ydHMoZmFjdG9yeSwgcmVwb3J0LCByZWNlaXZlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZUJ5TWVkaWFUeXBlLCB0cmFja0lkKSB7XG4gICAgdmFyIGVfMywgX2E7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhyZXBvcnQudmFsdWVzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgc3RhdHMgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIGlmIChzdGF0cy50eXBlID09PSAnaW5ib3VuZC1ydHAnICYmICFzdGF0cy5pc1JlbW90ZSkge1xuICAgICAgICAgICAgICAgIHZhciByZWNlaXZlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZSA9IHJlY2VpdmVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGVbc3RhdHMubWVkaWFUeXBlXTtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGUuZGVsZXRlKHN0YXRzLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyUmVwb3J0RmFjdG9yeSA9IGdldE9yQ3JlYXRlUmVjZWl2ZXJSZXBvcnRGYWN0b3J5KGZhY3RvcnksIHJlcG9ydCwgc3RhdHMsIHRyYWNrSWQpO1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlclJlcG9ydEZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXJSZXBvcnRGYWN0b3J5Lm5leHQodHJhY2tJZCB8fCByZWNlaXZlclJlcG9ydEZhY3RvcnkudHJhY2tJZCwgc3RhdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7U2VuZGVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGV8UmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZX0gc2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlXG4gKiBAcGFyYW0ge1N0YXRzSWRzQnlNZWRpYVR5cGV9IHNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzQnlNZWRpYVR5cGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZWxldGVTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzKHNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZSwgc2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcnlJZHNCeU1lZGlhVHlwZSkge1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKG1lZGlhVHlwZSkge1xuICAgICAgICB2YXIgc2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcmllcyA9IHNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZVttZWRpYVR5cGVdO1xuICAgICAgICB2YXIgc2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcnlJZHMgPSBzZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeUlkc0J5TWVkaWFUeXBlW21lZGlhVHlwZV07XG4gICAgICAgIHNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWQpIHsgcmV0dXJuIHNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXMuZGVsZXRlKHNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWQpOyB9KTtcbiAgICB9O1xuICAgIGZvciAodmFyIG1lZGlhVHlwZSBpbiBzZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeUlkc0J5TWVkaWFUeXBlKSB7XG4gICAgICAgIF9sb29wXzEobWVkaWFUeXBlKTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7SWNlUmVwb3J0RmFjdG9yeX0gaWNlXG4gKiBAcGFyYW0ge1JUQ1N0YXRzUmVwb3J0fSByZXBvcnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGVJY2VSZXBvcnQoaWNlLCByZXBvcnQpIHtcbiAgICB2YXIgZV80LCBfYSwgZV81LCBfYjtcbiAgICB2YXIgc2VsZWN0ZWRDYW5kaWRhdGVQYWlyO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXMocmVwb3J0LnZhbHVlcygpKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHN0YXRzID0gX2QudmFsdWU7XG4gICAgICAgICAgICBpZiAoc3RhdHMudHlwZSA9PT0gJ3RyYW5zcG9ydCcpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZENhbmRpZGF0ZVBhaXIgPSByZXBvcnQuZ2V0KHN0YXRzLnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdGVkQ2FuZGlkYXRlUGFpcikge1xuICAgICAgICBpY2UubmV4dChzZWxlY3RlZENhbmRpZGF0ZVBhaXIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9lID0gX192YWx1ZXMocmVwb3J0LnZhbHVlcygpKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHN0YXRzID0gX2YudmFsdWU7XG4gICAgICAgICAgICBpZiAoc3RhdHMudHlwZSA9PT0gJ2NhbmRpZGF0ZS1wYWlyJ1xuICAgICAgICAgICAgICAgICYmIHN0YXRzLm5vbWluYXRlZFxuICAgICAgICAgICAgICAgICYmICgnc2VsZWN0ZWQnIGluIHN0YXRzID8gc3RhdHMuc2VsZWN0ZWQgOiB0cnVlKSkge1xuICAgICAgICAgICAgICAgIGljZS5uZXh0KHN0YXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV81XzEpIHsgZV81ID0geyBlcnJvcjogZV81XzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7IH1cbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5fSBmYWN0b3J5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxQZWVyQ29ubmVjdGlvblJlcG9ydD59XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUZpcmVmb3goZmFjdG9yeSkge1xuICAgIHZhciBzZW5kZXJzID0gZmFjdG9yeS5wYy5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh0cmFuc2NlaXZlcikgeyByZXR1cm4gdHJhbnNjZWl2ZXIuY3VycmVudERpcmVjdGlvbiAmJiB0cmFuc2NlaXZlci5jdXJyZW50RGlyZWN0aW9uLm1hdGNoKC9zZW5kLykgJiYgdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh0cmFuc2NlaXZlcikgeyByZXR1cm4gdHJhbnNjZWl2ZXIuc2VuZGVyOyB9KTtcbiAgICB2YXIgcmVjZWl2ZXJzID0gZmFjdG9yeS5wYy5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh0cmFuc2NlaXZlcikgeyByZXR1cm4gdHJhbnNjZWl2ZXIuY3VycmVudERpcmVjdGlvbiAmJiB0cmFuc2NlaXZlci5jdXJyZW50RGlyZWN0aW9uLm1hdGNoKC9yZWN2Lyk7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHRyYW5zY2VpdmVyKSB7IHJldHVybiB0cmFuc2NlaXZlci5yZWNlaXZlcjsgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0U2VuZGVyT3JSZWNlaXZlclJlcG9ydHMoc2VuZGVycyksXG4gICAgICAgIGdldFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRzKHJlY2VpdmVycyksXG4gICAgICAgIGZhY3RvcnkucGMuZ2V0U3RhdHMoKVxuICAgIF0pLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMyksIHNlbmRlclJlcG9ydHMgPSBfYlswXSwgcmVjZWl2ZXJSZXBvcnRzID0gX2JbMV0sIHBjUmVwb3J0ID0gX2JbMl07XG4gICAgICAgIHZhciBzZW5kZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZSA9IGdldFNlbmRlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlKGZhY3RvcnkpO1xuICAgICAgICB2YXIgc2VuZGVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGUgPSBnZXRTZW5kZXJSZXBvcnRGYWN0b3J5SWRzQnlNZWRpYVR5cGUoZmFjdG9yeSk7XG4gICAgICAgIHNlbmRlclJlcG9ydHMuZm9yRWFjaChmdW5jdGlvbiAocmVwb3J0LCB0cmFja0lkKSB7IHJldHVybiB1cGRhdGVTZW5kZXJSZXBvcnRzKGZhY3RvcnksIHJlcG9ydCwgc2VuZGVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGUsIHRyYWNrSWQpOyB9KTtcbiAgICAgICAgZGVsZXRlU2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcmllcyhzZW5kZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZSwgc2VuZGVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGUpO1xuICAgICAgICB2YXIgcmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZSA9IGdldFJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGUoZmFjdG9yeSk7XG4gICAgICAgIHZhciByZWNlaXZlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZUJ5TWVkaWFUeXBlID0gZ2V0UmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzQnlNZWRpYVR5cGUoZmFjdG9yeSk7XG4gICAgICAgIHJlY2VpdmVyUmVwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXBvcnQsIHRyYWNrSWQpIHsgcmV0dXJuIHVwZGF0ZVJlY2VpdmVyUmVwb3J0cyhmYWN0b3J5LCByZXBvcnQsIHJlY2VpdmVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGUsIHRyYWNrSWQpOyB9KTtcbiAgICAgICAgZGVsZXRlU2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcmllcyhyZWNlaXZlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlLCByZWNlaXZlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZUJ5TWVkaWFUeXBlKTtcbiAgICAgICAgdXBkYXRlSWNlUmVwb3J0KGZhY3RvcnkuaWNlLCBwY1JlcG9ydCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb25SZXBvcnRGYWN0b3J5fSBmYWN0b3J5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxQZWVyQ29ubmVjdGlvblJlcG9ydD59XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUNocm9tZShmYWN0b3J5KSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucGMuZ2V0U3RhdHMoKS50aGVuKGZ1bmN0aW9uIChyZXBvcnQpIHtcbiAgICAgICAgdmFyIHNlbmRlclJlcG9ydEZhY3Rvcmllc0J5TWVkaWFUeXBlID0gZ2V0U2VuZGVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGUoZmFjdG9yeSk7XG4gICAgICAgIHZhciBzZW5kZXJSZXBvcnRGYWN0b3J5SWRzVG9EZWxldGVCeU1lZGlhVHlwZSA9IGdldFNlbmRlclJlcG9ydEZhY3RvcnlJZHNCeU1lZGlhVHlwZShmYWN0b3J5KTtcbiAgICAgICAgdXBkYXRlU2VuZGVyUmVwb3J0cyhmYWN0b3J5LCByZXBvcnQsIHNlbmRlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZUJ5TWVkaWFUeXBlKTtcbiAgICAgICAgZGVsZXRlU2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcmllcyhzZW5kZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZSwgc2VuZGVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGUpO1xuICAgICAgICB2YXIgcmVjZWl2ZXJSZXBvcnRGYWN0b3JpZXNCeU1lZGlhVHlwZSA9IGdldFJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGUoZmFjdG9yeSk7XG4gICAgICAgIHZhciByZWNlaXZlclJlcG9ydEZhY3RvcnlJZHNUb0RlbGV0ZUJ5TWVkaWFUeXBlID0gZ2V0UmVjZWl2ZXJSZXBvcnRGYWN0b3J5SWRzQnlNZWRpYVR5cGUoZmFjdG9yeSk7XG4gICAgICAgIHVwZGF0ZVJlY2VpdmVyUmVwb3J0cyhmYWN0b3J5LCByZXBvcnQsIHJlY2VpdmVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGUpO1xuICAgICAgICBkZWxldGVTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzKHJlY2VpdmVyUmVwb3J0RmFjdG9yaWVzQnlNZWRpYVR5cGUsIHJlY2VpdmVyUmVwb3J0RmFjdG9yeUlkc1RvRGVsZXRlQnlNZWRpYVR5cGUpO1xuICAgICAgICB1cGRhdGVJY2VSZXBvcnQoZmFjdG9yeS5pY2UsIHJlcG9ydCk7XG4gICAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IFBlZXJDb25uZWN0aW9uUmVwb3J0RmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlZXJjb25uZWN0aW9ucmVwb3J0ZmFjdG9yeS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIGF2ZXJhZ2UgPSByZXF1aXJlKCcuL2F2ZXJhZ2UnKTtcbnZhciBTZW5kZXJPclJlY2VpdmVyUmVwb3J0ID0gcmVxdWlyZSgnLi9zZW5kZXJvcnJlY2VpdmVycmVwb3J0Jyk7XG52YXIgc3VtID0gcmVxdWlyZSgnLi9zdW0nKTtcbi8qKlxuICogQGludGVyZmFjZSBSZWNlaXZlclN1bW1hcnlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiaXRyYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZnJhY3Rpb25Mb3N0IC0gMOKAkzFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaml0dGVyXSAtIHMgKHVuZGVmaW5lZCBmb3IgdmlkZW8gdHJhY2tzIGluIENocm9tZSlcbiAqL1xuLyoqXG4gKiBAZXh0ZW5kcyBTZW5kZXJPclJlY2VpdmVyUmVwb3J0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVsdGFQYWNrZXRzTG9zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlbHRhUGFja2V0c1JlY2VpdmVkXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZyYWN0aW9uTG9zdF0gLSAw4oCTMSAodW5kZWZpbmVkIGluIEZpcmVmb3gpXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ppdHRlcl0gLSBzICh1bmRlZmluZWQgZm9yIHZpZGVvIHRyYWNrcyBpbiBDaHJvbWUpXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGhvbnlQYWNrZXRzTG9zdCAtIDDigJMxXG4gKi9cbnZhciBSZWNlaXZlclJlcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVjZWl2ZXJSZXBvcnQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdGF0c0lkfSBpZFxuICAgICAqIEBwYXJhbSB7VHJhY2tJZH0gdHJhY2tJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRyYXRlIC0gYnBzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhUGFja2V0c0xvc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFQYWNrZXRzUmVjZWl2ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2ZyYWN0aW9uTG9zdF0gLSAw4oCTMSAodW5kZWZpbmVkIGluIEZpcmVmb3gpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtqaXR0ZXJdIC0gcyAodW5kZWZpbmVkIGZvciB2aWRlbyB0cmFja3MgaW4gQ2hyb21lKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlY2VpdmVyUmVwb3J0KGlkLCB0cmFja0lkLCBiaXRyYXRlLCBkZWx0YVBhY2tldHNMb3N0LCBkZWx0YVBhY2tldHNSZWNlaXZlZCwgZnJhY3Rpb25Mb3N0LCBqaXR0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaWQsIHRyYWNrSWQsIGJpdHJhdGUpIHx8IHRoaXM7XG4gICAgICAgIHZhciBwaG9ueUZyYWN0aW9uTG9zdCA9IGRlbHRhUGFja2V0c1JlY2VpdmVkID4gMFxuICAgICAgICAgICAgPyBkZWx0YVBhY2tldHNMb3N0IC8gZGVsdGFQYWNrZXRzUmVjZWl2ZWRcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIGRlbHRhUGFja2V0c0xvc3Q6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkZWx0YVBhY2tldHNMb3N0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsdGFQYWNrZXRzUmVjZWl2ZWQ6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkZWx0YVBhY2tldHNSZWNlaXZlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyYWN0aW9uTG9zdDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZyYWN0aW9uTG9zdFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGppdHRlcjoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGppdHRlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBob255RnJhY3Rpb25Mb3N0OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGhvbnlGcmFjdGlvbkxvc3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEge0BsaW5rIFJlY2VpdmVyUmVwb3J0fS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhY2tJZFxuICAgICAqIEBwYXJhbSB7UlRDU3RhdHN9IG9sZGVyU3RhdHNcbiAgICAgKiBAcGFyYW0ge1JUQ1N0YXRzfSBuZXdlclN0YXRzXG4gICAgICogQHJldHVybnMge1JlY2VpdmVyUmVwb3J0fVxuICAgICAqL1xuICAgIFJlY2VpdmVyUmVwb3J0Lm9mID0gZnVuY3Rpb24gKHRyYWNrSWQsIG9sZGVyU3RhdHMsIG5ld2VyU3RhdHMpIHtcbiAgICAgICAgaWYgKG9sZGVyU3RhdHMuaWQgIT09IG5ld2VyU3RhdHMuaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUlRDU3RhdHMgSURzIG11c3QgbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vjb25kc0VsYXBzZWQgPSAobmV3ZXJTdGF0cy50aW1lc3RhbXAgLSBvbGRlclN0YXRzLnRpbWVzdGFtcCkgLyAxMDAwO1xuICAgICAgICB2YXIgZGVsdGFCeXRlc1JlY2VpdmVkID0gbmV3ZXJTdGF0cy5ieXRlc1JlY2VpdmVkIC0gb2xkZXJTdGF0cy5ieXRlc1JlY2VpdmVkO1xuICAgICAgICB2YXIgYml0cmF0ZSA9IHNlY29uZHNFbGFwc2VkID4gMFxuICAgICAgICAgICAgPyAoZGVsdGFCeXRlc1JlY2VpdmVkIC8gc2Vjb25kc0VsYXBzZWQpICogOFxuICAgICAgICAgICAgOiAwO1xuICAgICAgICB2YXIgZGVsdGFQYWNrZXRzTG9zdCA9IE1hdGgubWF4KG5ld2VyU3RhdHMucGFja2V0c0xvc3QgLSBvbGRlclN0YXRzLnBhY2tldHNMb3N0LCAwKTtcbiAgICAgICAgdmFyIGRlbHRhUGFja2V0c1JlY2VpdmVkID0gbmV3ZXJTdGF0cy5wYWNrZXRzUmVjZWl2ZWQgLSBvbGRlclN0YXRzLnBhY2tldHNSZWNlaXZlZDtcbiAgICAgICAgdmFyIGZyYWN0aW9uTG9zdCA9IG5ld2VyU3RhdHMuZnJhY3Rpb25Mb3N0LCBqaXR0ZXIgPSBuZXdlclN0YXRzLmppdHRlcjtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWNlaXZlclJlcG9ydChvbGRlclN0YXRzLmlkLCB0cmFja0lkLCBiaXRyYXRlLCBkZWx0YVBhY2tldHNMb3N0LCBkZWx0YVBhY2tldHNSZWNlaXZlZCwgZnJhY3Rpb25Mb3N0LCBqaXR0ZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3VtbWFyaXplIHtAbGluayBSZWNlaXZlclJlcG9ydH1zIGJ5IHN1bW1pbmcgYW5kIGF2ZXJhZ2luZyB0aGVpciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheTxSZWNlaXZlclJlcG9ydD59IHJlcG9ydHNcbiAgICAgKiBAcmV0dXJucyB7UmVjZWl2ZXJTdW1tYXJ5fVxuICAgICAqL1xuICAgIFJlY2VpdmVyUmVwb3J0LnN1bW1hcml6ZSA9IGZ1bmN0aW9uIChyZXBvcnRzKSB7XG4gICAgICAgIHZhciBzdW1tYXJpZXMgPSByZXBvcnRzLm1hcChmdW5jdGlvbiAocmVwb3J0KSB7IHJldHVybiByZXBvcnQuc3VtbWFyaXplKCk7IH0pO1xuICAgICAgICB2YXIgYml0cmF0ZSA9IHN1bShzdW1tYXJpZXMubWFwKGZ1bmN0aW9uIChzdW1tYXJ5KSB7IHJldHVybiBzdW1tYXJ5LmJpdHJhdGU7IH0pKTtcbiAgICAgICAgdmFyIGZyYWN0aW9uTG9zdCA9IGF2ZXJhZ2Uoc3VtbWFyaWVzLm1hcChmdW5jdGlvbiAoc3VtbWFyeSkgeyByZXR1cm4gc3VtbWFyeS5mcmFjdGlvbkxvc3Q7IH0pKTtcbiAgICAgICAgdmFyIGppdHRlciA9IGF2ZXJhZ2Uoc3VtbWFyaWVzLm1hcChmdW5jdGlvbiAoc3VtbWFyeSkgeyByZXR1cm4gc3VtbWFyeS5qaXR0ZXI7IH0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJpdHJhdGU6IGJpdHJhdGUsXG4gICAgICAgICAgICBmcmFjdGlvbkxvc3Q6IGZyYWN0aW9uTG9zdCxcbiAgICAgICAgICAgIGppdHRlcjogaml0dGVyXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdW1tYXJpemUgdGhlIHtAbGluayBSZWNlaXZlUmVwb3J0fS5cbiAgICAgKiBAcmV0dXJucyB7UmVjZWl2ZXJTdW1tYXJ5fVxuICAgICAqL1xuICAgIFJlY2VpdmVyUmVwb3J0LnByb3RvdHlwZS5zdW1tYXJpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiaXRyYXRlOiB0aGlzLmJpdHJhdGUsXG4gICAgICAgICAgICBmcmFjdGlvbkxvc3Q6IHR5cGVvZiB0aGlzLmZyYWN0aW9uTG9zdCA9PT0gJ251bWJlcicgPyB0aGlzLmZyYWN0aW9uTG9zdCA6IHRoaXMucGhvbnlGcmFjdGlvbkxvc3QsXG4gICAgICAgICAgICBqaXR0ZXI6IHRoaXMuaml0dGVyXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gUmVjZWl2ZXJSZXBvcnQ7XG59KFNlbmRlck9yUmVjZWl2ZXJSZXBvcnQpKTtcbm1vZHVsZS5leHBvcnRzID0gUmVjZWl2ZXJSZXBvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNlaXZlcnJlcG9ydC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFJlY2VpdmVyUmVwb3J0ID0gcmVxdWlyZSgnLi9yZWNlaXZlcnJlcG9ydCcpO1xudmFyIFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5ID0gcmVxdWlyZSgnLi9zZW5kZXJvcnJlY2VpdmVycmVwb3J0ZmFjdG9yeScpO1xuLyoqXG4gKiBAZXh0ZW5kcyBTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeVxuICogQHBhcmFtIHs/UmVjZWl2ZXJSZXBvcnR9IGxhc3RSZXBvcnRcbiAqL1xudmFyIFJlY2VpdmVyUmVwb3J0RmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVjZWl2ZXJSZXBvcnRGYWN0b3J5LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBSZWNlaXZlclJlcG9ydEZhY3Rvcnl9LlxuICAgICAqIEBwYXJhbSB7VHJhY2tJZH0gdHJhY2tJZFxuICAgICAqIEBwYXJhbSB7UlRDU3RhdHN9IGluaXRpYWxTdGF0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlY2VpdmVyUmVwb3J0RmFjdG9yeSh0cmFja0lkLCBpbml0aWFsU3RhdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbFN0YXRzLmlkLCB0cmFja0lkLCBpbml0aWFsU3RhdHMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBsYXN0UmVwb3J0OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB7QGxpbmsgUmVjZWl2ZXJSZXBvcnR9LlxuICAgICAqIEBwYXJhbSB7VHJhY2tJZH0gdHJhY2tJZFxuICAgICAqIEBwYXJhbSB7UlRDU3RhdHN9IG5ld2VyU3RhdHNcbiAgICAgKiBAcmV0dXJucyB7UmVjZWl2ZXJSZXBvcnR9XG4gICAgICovXG4gICAgUmVjZWl2ZXJSZXBvcnRGYWN0b3J5LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHRyYWNrSWQsIG5ld2VyU3RhdHMpIHtcbiAgICAgICAgdmFyIG9sZGVyU3RhdHMgPSB0aGlzLmxhc3RTdGF0cztcbiAgICAgICAgdGhpcy5sYXN0U3RhdHMgPSBuZXdlclN0YXRzO1xuICAgICAgICB0aGlzLnRyYWNrSWQgPSB0cmFja0lkO1xuICAgICAgICB2YXIgcmVwb3J0ID0gUmVjZWl2ZXJSZXBvcnQub2YodHJhY2tJZCwgb2xkZXJTdGF0cywgbmV3ZXJTdGF0cyk7XG4gICAgICAgIHRoaXMubGFzdFJlcG9ydCA9IHJlcG9ydDtcbiAgICAgICAgcmV0dXJuIHJlcG9ydDtcbiAgICB9O1xuICAgIHJldHVybiBSZWNlaXZlclJlcG9ydEZhY3Rvcnk7XG59KFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5KSk7XG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyUmVwb3J0RmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY2VpdmVycmVwb3J0ZmFjdG9yeS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIFJlbW90ZVRyYWNrU3RhdHMgPSByZXF1aXJlKCcuL3JlbW90ZXRyYWNrc3RhdHMnKTtcbi8qKlxuICogU3RhdGlzdGljcyBmb3IgYW4ge0BsaW5rIEF1ZGlvVHJhY2t9LlxuICogQGV4dGVuZHMgUmVtb3RlVHJhY2tTdGF0c1xuICogQHByb3BlcnR5IHs/QXVkaW9MZXZlbH0gYXVkaW9MZXZlbCAtIE91dHB1dCB7QGxpbmsgQXVkaW9MZXZlbH1cbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gaml0dGVyIC0gQXVkaW8gaml0dGVyIGluIG1pbGxpc2Vjb25kc1xuICovXG52YXIgUmVtb3RlQXVkaW9UcmFja1N0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW1vdGVBdWRpb1RyYWNrU3RhdHMsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWNrSWQgLSB7QGxpbmsgQXVkaW9UcmFja30gSURcbiAgICAgKiBAcGFyYW0ge1N0YW5kYXJkaXplZFRyYWNrU3RhdHNSZXBvcnR9IHN0YXRzUmVwb3J0XG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVtb3RlQXVkaW9UcmFja1N0YXRzKHRyYWNrSWQsIHN0YXRzUmVwb3J0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYWNrSWQsIHN0YXRzUmVwb3J0KSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgYXVkaW9MZXZlbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlb2Ygc3RhdHNSZXBvcnQuYXVkaW9PdXRwdXRMZXZlbCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBzdGF0c1JlcG9ydC5hdWRpb091dHB1dExldmVsXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaml0dGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHR5cGVvZiBzdGF0c1JlcG9ydC5qaXR0ZXIgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdHNSZXBvcnQuaml0dGVyXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZW1vdGVBdWRpb1RyYWNrU3RhdHM7XG59KFJlbW90ZVRyYWNrU3RhdHMpKTtcbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlQXVkaW9UcmFja1N0YXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RlYXVkaW90cmFja3N0YXRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgVHJhY2tTdGF0cyA9IHJlcXVpcmUoJy4vdHJhY2tzdGF0cycpO1xuLyoqXG4gKiBTdGF0aXN0aWNzIGZvciBhIHJlbW90ZSB7QGxpbmsgVHJhY2t9LlxuICogQGV4dGVuZHMgVHJhY2tTdGF0c1xuICogQHByb3BlcnR5IHs/bnVtYmVyfSBieXRlc1JlY2VpdmVkIC0gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IHBhY2tldHNSZWNlaXZlZCAtIE51bWJlciBvZiBwYWNrZXRzIHJlY2VpdmVkXG4gKi9cbnZhciBSZW1vdGVUcmFja1N0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW1vdGVUcmFja1N0YXRzLCBfc3VwZXIpO1xuICAgIC8qXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWNrSWQgLSB7QGxpbmsgVHJhY2t9IElEXG4gICAgICogQHBhcmFtIHtTdGFuZGFyZGl6ZWRUcmFja1N0YXRzUmVwb3J0fSBzdGF0c1JlcG9ydFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlbW90ZVRyYWNrU3RhdHModHJhY2tJZCwgc3RhdHNSZXBvcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhY2tJZCwgc3RhdHNSZXBvcnQpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBieXRlc1JlY2VpdmVkOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHR5cGVvZiBzdGF0c1JlcG9ydC5ieXRlc1JlY2VpdmVkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICA/IHN0YXRzUmVwb3J0LmJ5dGVzUmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYWNrZXRzUmVjZWl2ZWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHN0YXRzUmVwb3J0LnBhY2tldHNSZWNlaXZlZCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBzdGF0c1JlcG9ydC5wYWNrZXRzUmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlbW90ZVRyYWNrU3RhdHM7XG59KFRyYWNrU3RhdHMpKTtcbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlVHJhY2tTdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW90ZXRyYWNrc3RhdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBSZW1vdGVUcmFja1N0YXRzID0gcmVxdWlyZSgnLi9yZW1vdGV0cmFja3N0YXRzJyk7XG4vKipcbiAqIFN0YXRpc3RpY3MgZm9yIGEge0BsaW5rIFZpZGVvVHJhY2t9LlxuICogQGV4dGVuZHMgUmVtb3RlVHJhY2tTdGF0c1xuICogQHByb3BlcnR5IHs/VmlkZW9UcmFjayNEaW1lbnNpb25zfSBkaW1lbnNpb25zIC0gUmVjZWl2ZWQgdmlkZW8gcmVzb2x1dGlvblxuICogQHByb3BlcnR5IHs/bnVtYmVyfSBmcmFtZVJhdGUgLSBSZWNlaXZlZCB2aWRlbyBmcmFtZSByYXRlXG4gKi9cbnZhciBSZW1vdGVWaWRlb1RyYWNrU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbW90ZVZpZGVvVHJhY2tTdGF0cywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhY2tJZCAtIHtAbGluayBWaWRlb1RyYWNrfSBJRFxuICAgICAqIEBwYXJhbSB7U3RhbmRhcmRpemVkVHJhY2tTdGF0c1JlcG9ydH0gc3RhdHNSZXBvcnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZW1vdGVWaWRlb1RyYWNrU3RhdHModHJhY2tJZCwgc3RhdHNSZXBvcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhY2tJZCwgc3RhdHNSZXBvcnQpIHx8IHRoaXM7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0c1JlcG9ydC5mcmFtZVdpZHRoUmVjZWl2ZWQgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICB0eXBlb2Ygc3RhdHNSZXBvcnQuZnJhbWVIZWlnaHRSZWNlaXZlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGRpbWVuc2lvbnMsIHtcbiAgICAgICAgICAgICAgICB3aWR0aDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RhdHNSZXBvcnQuZnJhbWVXaWR0aFJlY2VpdmVkLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0YXRzUmVwb3J0LmZyYW1lSGVpZ2h0UmVjZWl2ZWQsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcmFtZVJhdGU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHN0YXRzUmVwb3J0LmZyYW1lUmF0ZVJlY2VpdmVkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICA/IHN0YXRzUmVwb3J0LmZyYW1lUmF0ZVJlY2VpdmVkXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZW1vdGVWaWRlb1RyYWNrU3RhdHM7XG59KFJlbW90ZVRyYWNrU3RhdHMpKTtcbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlVmlkZW9UcmFja1N0YXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3RldmlkZW90cmFja3N0YXRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQHByb3BlcnR5IHtTdGF0c0lkfSBpZFxuICogQHByb3BlcnR5IHtUcmFja0lkfSB0cmFja0lkXG4gKiBAcHJvcGVydHkge251bWJlcn0gYml0cmF0ZSAtIGJwc1xuICovXG52YXIgU2VuZGVyT3JSZWNlaXZlclJlcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgU2VuZGVyT3JSZWNlaXZlclJlcG9ydH0uXG4gICAgICogQHBhcmFtIHtTdGF0c0lkfSBpZFxuICAgICAqIEBwYXJhbSB7VHJhY2tJZH0gdHJhY2tJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRyYXRlIC0gYnBzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VuZGVyT3JSZWNlaXZlclJlcG9ydChpZCwgdHJhY2tJZCwgYml0cmF0ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2tJZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRyYWNrSWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiaXRyYXRlOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYml0cmF0ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFNlbmRlck9yUmVjZWl2ZXJSZXBvcnQ7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXJPclJlY2VpdmVyUmVwb3J0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VuZGVyb3JyZWNlaXZlcnJlcG9ydC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBwcm9wZXJ0eSB7U3RhdHNJZH0gaWRcbiAqIEBwcm9wZXJ0eSB7VHJhY2tJZH0gdHJhY2tJZFxuICogQHByb3BlcnR5IHtSVENTdGF0c30gbGFzdFN0YXRzXG4gKi9cbnZhciBTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0YXRzSWR9IGlkXG4gICAgICogQHBhcmFtIHtUcmFja0lkfSB0cmFja0lkXG4gICAgICogQHBhcmFtIHtSVENTdGF0c30gaW5pdGlhbFN0YXRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3RvcnkoaWQsIHRyYWNrSWQsIGluaXRpYWxTdGF0cykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2tJZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRyYWNrSWQsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0U3RhdHM6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbml0aWFsU3RhdHMsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeTtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlck9yUmVjZWl2ZXJSZXBvcnRGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VuZGVyb3JyZWNlaXZlcnJlcG9ydGZhY3RvcnkuanMubWFwIiwiLyogZXNsaW50IG5vLXVuZGVmaW5lZDowICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIGF2ZXJhZ2UgPSByZXF1aXJlKCcuL2F2ZXJhZ2UnKTtcbnZhciBTZW5kZXJPclJlY2VpdmVyUmVwb3J0ID0gcmVxdWlyZSgnLi9zZW5kZXJvcnJlY2VpdmVycmVwb3J0Jyk7XG52YXIgc3VtID0gcmVxdWlyZSgnLi9zdW0nKTtcbi8qKlxuICogQGludGVyZmFjZSBTZW5kZXJTdW1tYXJ5XG4gKiBAcHJvcGVydHkge251bWJlcn0gYml0cmF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtydHRdIC0gcyAodW5kZWZpbmVkIGluIENocm9tZSlcbiAqL1xuLyoqXG4gKiBAZXh0ZW5kcyBTZW5kZXJPclJlY2VpdmVyUmVwb3J0XG4gKiBAcHJvcGVydHkge251bWJlcn0gW3J0dF0gLSBzICh1bmRlZmluZWQgaW4gQ2hyb21lKVxuICovXG52YXIgU2VuZGVyUmVwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZW5kZXJSZXBvcnQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFNlbmRlclJlcG9ydH0uXG4gICAgICogQHBhcmFtIHtTdGF0c0lkfSBpZFxuICAgICAqIEBwYXJhbSB7VHJhY2tJZH0gdHJhY2tJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRyYXRlIC0gYnBzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtydHRdIC0gc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlbmRlclJlcG9ydChpZCwgdHJhY2tJZCwgYml0cmF0ZSwgcnR0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGlkLCB0cmFja0lkLCBiaXRyYXRlKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgcnR0OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcnR0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHtAbGluayBTZW5kZXJSZXBvcnR9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFja0lkXG4gICAgICogQHBhcmFtIHtSVENTdGF0c30gb2xkZXJTdGF0c1xuICAgICAqIEBwYXJhbSB7UlRDU3RhdHN9IG5ld2VyU3RhdHNcbiAgICAgKiBAcGFyYW0ge1JUQ1JlbW90ZUluYm91bmRSdHBTdHJlYW1TdGF0c30gW25ld2VyUmVtb3RlU3RhdHNdXG4gICAgICogQHJldHVybnMge1NlbmRlclJlcG9ydH1cbiAgICAgKi9cbiAgICBTZW5kZXJSZXBvcnQub2YgPSBmdW5jdGlvbiAodHJhY2tJZCwgb2xkZXJTdGF0cywgbmV3ZXJTdGF0cywgbmV3ZXJSZW1vdGVTdGF0cykge1xuICAgICAgICBpZiAob2xkZXJTdGF0cy5pZCAhPT0gbmV3ZXJTdGF0cy5pZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSVENTdGF0cyBJRHMgbXVzdCBtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWNvbmRzRWxhcHNlZCA9IChuZXdlclN0YXRzLnRpbWVzdGFtcCAtIG9sZGVyU3RhdHMudGltZXN0YW1wKSAvIDEwMDA7XG4gICAgICAgIHZhciBkZWx0YUJ5dGVzU2VudCA9IG5ld2VyU3RhdHMuYnl0ZXNTZW50IC0gb2xkZXJTdGF0cy5ieXRlc1NlbnQ7XG4gICAgICAgIHZhciBiaXRyYXRlID0gc2Vjb25kc0VsYXBzZWQgPiAwXG4gICAgICAgICAgICA/IChkZWx0YUJ5dGVzU2VudCAvIHNlY29uZHNFbGFwc2VkKSAqIDhcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgdmFyIHJ0dCA9IG5ld2VyUmVtb3RlU3RhdHMgJiYgdHlwZW9mIG5ld2VyUmVtb3RlU3RhdHMucm91bmRUcmlwVGltZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gbmV3ZXJSZW1vdGVTdGF0cy5yb3VuZFRyaXBUaW1lIC8gMTAwMFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBuZXcgU2VuZGVyUmVwb3J0KG9sZGVyU3RhdHMuaWQsIHRyYWNrSWQsIGJpdHJhdGUsIHJ0dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdW1tYXJpemUge0BsaW5rIFNlbmRlclJlcG9ydH1zIGJ5IHN1bW1pbmcgYW5kIGF2ZXJhZ2luZyB0aGVpciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheTxTZW5kZXJSZXBvcnQ+fSByZXBvcnRzXG4gICAgICogQHJldHVybnMge1NlbmRlclN1bW1hcnl9XG4gICAgICovXG4gICAgU2VuZGVyUmVwb3J0LnN1bW1hcml6ZSA9IGZ1bmN0aW9uIChyZXBvcnRzKSB7XG4gICAgICAgIHZhciBiaXRyYXRlID0gc3VtKHJlcG9ydHMubWFwKGZ1bmN0aW9uIChyZXBvcnQpIHsgcmV0dXJuIHJlcG9ydC5iaXRyYXRlOyB9KSk7XG4gICAgICAgIHZhciBydHQgPSBhdmVyYWdlKHJlcG9ydHMubWFwKGZ1bmN0aW9uIChyZXBvcnQpIHsgcmV0dXJuIHJlcG9ydC5ydHQ7IH0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJpdHJhdGU6IGJpdHJhdGUsXG4gICAgICAgICAgICBydHQ6IHJ0dFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFNlbmRlclJlcG9ydDtcbn0oU2VuZGVyT3JSZWNlaXZlclJlcG9ydCkpO1xubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXJSZXBvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW5kZXJyZXBvcnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeSA9IHJlcXVpcmUoJy4vc2VuZGVyb3JyZWNlaXZlcnJlcG9ydGZhY3RvcnknKTtcbnZhciBTZW5kZXJSZXBvcnQgPSByZXF1aXJlKCcuL3NlbmRlcnJlcG9ydCcpO1xuLyoqXG4gKiBAZXh0ZW5kcyB7U2VuZGVyT3JSZWNlaXZlclJlcG9ydEZhY3Rvcnl9XG4gKiBAcHJvcGVydHkgez9TZW5kZXJSZXBvcnR9IGxhc3RSZXBvcnRcbiAqL1xudmFyIFNlbmRlclJlcG9ydEZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlbmRlclJlcG9ydEZhY3RvcnksIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFNlbmRlclJlcG9ydEZhY3Rvcnl9LlxuICAgICAqIEBwYXJhbSB7VHJhY2tJZH0gdHJhY2tJZFxuICAgICAqIEBwYXJhbSB7UlRDU3RhdHN9IGluaXRpYWxTdGF0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlbmRlclJlcG9ydEZhY3RvcnkodHJhY2tJZCwgaW5pdGlhbFN0YXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxTdGF0cy5pZCwgdHJhY2tJZCwgaW5pdGlhbFN0YXRzKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpcywge1xuICAgICAgICAgICAgbGFzdFJlcG9ydDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmFja0lkfSB0cmFja0lkXG4gICAgICogQHBhcmFtIHtSVENTdGF0c30gbmV3ZXJTdGF0c1xuICAgICAqIEBwYXJhbSB7UlRDUmVtb3RlSW5ib3VuZFJ0cFN0cmVhbVN0YXRzfSBbbmV3ZXJSZW1vdGVTdGF0c11cbiAgICAgKiBAcmV0dXJucyB7U2VuZGVyUmVwb3J0fVxuICAgICAqL1xuICAgIFNlbmRlclJlcG9ydEZhY3RvcnkucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodHJhY2tJZCwgbmV3ZXJTdGF0cywgbmV3ZXJSZW1vdGVTdGF0cykge1xuICAgICAgICB2YXIgb2xkZXJTdGF0cyA9IHRoaXMubGFzdFN0YXRzO1xuICAgICAgICB0aGlzLmxhc3RTdGF0cyA9IG5ld2VyU3RhdHM7XG4gICAgICAgIHRoaXMudHJhY2tJZCA9IHRyYWNrSWQ7XG4gICAgICAgIHZhciByZXBvcnQgPSBTZW5kZXJSZXBvcnQub2YodHJhY2tJZCwgb2xkZXJTdGF0cywgbmV3ZXJTdGF0cywgbmV3ZXJSZW1vdGVTdGF0cyk7XG4gICAgICAgIHRoaXMubGFzdFJlcG9ydCA9IHJlcG9ydDtcbiAgICAgICAgcmV0dXJuIHJlcG9ydDtcbiAgICB9O1xuICAgIHJldHVybiBTZW5kZXJSZXBvcnRGYWN0b3J5O1xufShTZW5kZXJPclJlY2VpdmVyUmVwb3J0RmFjdG9yeSkpO1xubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXJSZXBvcnRGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VuZGVycmVwb3J0ZmFjdG9yeS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgTG9jYWxBdWRpb1RyYWNrU3RhdHMgPSByZXF1aXJlKCcuL2xvY2FsYXVkaW90cmFja3N0YXRzJyk7XG52YXIgTG9jYWxWaWRlb1RyYWNrU3RhdHMgPSByZXF1aXJlKCcuL2xvY2FsdmlkZW90cmFja3N0YXRzJyk7XG52YXIgUmVtb3RlQXVkaW9UcmFja1N0YXRzID0gcmVxdWlyZSgnLi9yZW1vdGVhdWRpb3RyYWNrc3RhdHMnKTtcbnZhciBSZW1vdGVWaWRlb1RyYWNrU3RhdHMgPSByZXF1aXJlKCcuL3JlbW90ZXZpZGVvdHJhY2tzdGF0cycpO1xuLyoqXG4gKiBTdGF0aXN0aWNzIHJlcG9ydCBmb3IgYW4gUlRDUGVlckNvbm5lY3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGVlckNvbm5lY3Rpb25JZCAtIElEIG9mIHRoZSBSVENQZWVyQ29ubmVjdGlvblxuICogQHByb3BlcnR5IHtBcnJheTxMb2NhbEF1ZGlvVHJhY2tTdGF0cz59IGxvY2FsQXVkaW9UcmFja1N0YXRzIC0gTGlzdCBvZiB7QGxpbmsgTG9jYWxBdWRpb1RyYWNrU3RhdHN9XG4gKiBAcHJvcGVydHkge0FycmF5PExvY2FsVmlkZW9UcmFja1N0YXRzPn0gbG9jYWxWaWRlb1RyYWNrU3RhdHMgLSBMaXN0IG9mIHtAbGluayBMb2NhbFZpZGVvVHJhY2tTdGF0c31cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8UmVtb3RlQXVkaW9UcmFja1N0YXRzPn0gcmVtb3RlQXVkaW9UcmFja1N0YXRzIC0gTGlzdCBvZiB7QGxpbmsgUmVtb3RlQXVkaW9UcmFja1N0YXRzfVxuICogQHByb3BlcnR5IHtBcnJheTxSZW1vdGVWaWRlb1RyYWNrU3RhdHM+fSByZW1vdGVWaWRlb1RyYWNrU3RhdHMgLSBMaXN0IG9mIHtAbGluayBSZW1vdGVWaWRlb1RyYWNrU3RhdHN9XG4gKi9cbnZhciBTdGF0c1JlcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGVlckNvbm5lY3Rpb25JZCAtIFJUQ1BlZXJDb25uZWN0aW9uIElEXG4gICAgICogQHBhcmFtIHtTdGFuZGFyZGl6ZWRTdGF0c1Jlc3BvbnNlfSBzdGF0c1Jlc3BvbnNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwcmVwYXJlRm9ySW5zaWdodHMgLSBpZiByZXBvcnQgaXMgYmVpbmcgcHJlcGFyZWQgdG8gc2VuZCB0byBpbnNpZ2h0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGF0c1JlcG9ydChwZWVyQ29ubmVjdGlvbklkLCBzdGF0c1Jlc3BvbnNlLCBwcmVwYXJlRm9ySW5zaWdodHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwZWVyQ29ubmVjdGlvbklkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSVENQZWVyQ29ubmVjdGlvbiBpZCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25JZDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwZWVyQ29ubmVjdGlvbklkLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2NhbEF1ZGlvVHJhY2tTdGF0czoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzdGF0c1Jlc3BvbnNlLmxvY2FsQXVkaW9UcmFja1N0YXRzLm1hcChmdW5jdGlvbiAocmVwb3J0KSB7IHJldHVybiBuZXcgTG9jYWxBdWRpb1RyYWNrU3RhdHMocmVwb3J0LnRyYWNrSWQsIHJlcG9ydCwgcHJlcGFyZUZvckluc2lnaHRzKTsgfSksXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvY2FsVmlkZW9UcmFja1N0YXRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0YXRzUmVzcG9uc2UubG9jYWxWaWRlb1RyYWNrU3RhdHMubWFwKGZ1bmN0aW9uIChyZXBvcnQpIHsgcmV0dXJuIG5ldyBMb2NhbFZpZGVvVHJhY2tTdGF0cyhyZXBvcnQudHJhY2tJZCwgcmVwb3J0LCBwcmVwYXJlRm9ySW5zaWdodHMpOyB9KSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3RlQXVkaW9UcmFja1N0YXRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0YXRzUmVzcG9uc2UucmVtb3RlQXVkaW9UcmFja1N0YXRzLm1hcChmdW5jdGlvbiAocmVwb3J0KSB7IHJldHVybiBuZXcgUmVtb3RlQXVkaW9UcmFja1N0YXRzKHJlcG9ydC50cmFja0lkLCByZXBvcnQpOyB9KSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3RlVmlkZW9UcmFja1N0YXRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0YXRzUmVzcG9uc2UucmVtb3RlVmlkZW9UcmFja1N0YXRzLm1hcChmdW5jdGlvbiAocmVwb3J0KSB7IHJldHVybiBuZXcgUmVtb3RlVmlkZW9UcmFja1N0YXRzKHJlcG9ydC50cmFja0lkLCByZXBvcnQpOyB9KSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gU3RhdHNSZXBvcnQ7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBTdGF0c1JlcG9ydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRzcmVwb3J0LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXJ8dW5kZWZpbmVkPn0geHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHN1bSh4cykge1xuICAgIHJldHVybiB4cy5yZWR1Y2UoZnVuY3Rpb24gKHksIHgpIHsgcmV0dXJuIHR5cGVvZiB4ID09PSAnbnVtYmVyJyA/IHggKyB5IDogeTsgfSwgMCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHN1bTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1bS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIFN0YXRpc3RpY3MgZm9yIGEge0BsaW5rIFRyYWNrfS5cbiAqIEBwcm9wZXJ0eSB7VHJhY2suSUR9IHRyYWNrSWQgLSBUaGUge0BsaW5rIFRyYWNrfSBJRFxuICogQHByb3BlcnR5IHtUcmFjay5TSUR9IHRyYWNrU2lkIC0gVGhlIHtAbGluayBUcmFja30ncyBTSUQgd2hlbiBwdWJsaXNoZWQgaW5cbiAqICBpbiBhIHtAbGluayBSb29tfVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVzdGFtcCAtIEEgVW5peCB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzIGluZGljYXRpbmdcbiAqICAgd2hlbiB0aGUge0BsaW5rIFRyYWNrU3RhdHN9IHdlcmUgZ2F0aGVyZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzc3JjIC0gVGhlIHtAbGluayBUcmFja30ncyBTU1JDIHdoZW4gdHJhbnNtaXR0ZWQgb3ZlciB0aGVcbiAqICAgUlRDUGVlckNvbm5lY3Rpb25cbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gcGFja2V0c0xvc3QgLSBUaGUgbnVtYmVyIG9mIHBhY2tldHMgbG9zdFxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBjb2RlYyAtIFRoZSBuYW1lIG9mIHRoZSBjb2RlYyB1c2VkIHRvIGVuY29kZSB0aGVcbiAqICAge0BsaW5rIFRyYWNrfSdzIG1lZGlhXG4gKi9cbnZhciBUcmFja1N0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFja0lkIC0ge0BsaW5rIFRyYWNrfSBJRFxuICAgICAqIEBwYXJhbSB7U3RhbmRhcmRpemVkVHJhY2tTdGF0c1JlcG9ydH0gc3RhdHNSZXBvcnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFja1N0YXRzKHRyYWNrSWQsIHN0YXRzUmVwb3J0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhY2tJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhY2sgaWQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHRyYWNrSWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhY2tJZCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2tTaWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RhdHNSZXBvcnQudHJhY2tTaWQsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzdGF0c1JlcG9ydC50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNzcmM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RhdHNSZXBvcnQuc3NyYyxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFja2V0c0xvc3Q6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHN0YXRzUmVwb3J0LnBhY2tldHNMb3N0ID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICA/IHN0YXRzUmVwb3J0LnBhY2tldHNMb3N0XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29kZWM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHN0YXRzUmVwb3J0LmNvZGVjTmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBzdGF0c1JlcG9ydC5jb2RlY05hbWVcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBUcmFja1N0YXRzO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gVHJhY2tTdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNrc3RhdHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4vKipcbiAqIEEge0BsaW5rIFRyYWNrVHJhbnNjZWl2ZXJ9IHJlcHJlc2VudHMgZWl0aGVyIG9uZSBvciBtb3JlIGxvY2FsIFJUQ1J0cFNlbmRlcnNcbiAqIG9yIFJUQ0RhdGFDaGFubmVscywgb3IgYSBzaW5nbGUgUlRDUnRwUmVjZWl2ZXIgb3IgcmVtb3RlIFJUQ0RhdGFDaGFubmVsLlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAcHJvcGVydHkge1RyYWNrLklEfSBpZFxuICogQHByb3BlcnR5IHtUcmFjay5raW5kfSBraW5kXG4gKi9cbnZhciBUcmFja1RyYW5zY2VpdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFja1RyYW5zY2VpdmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBUcmFja1RyYW5zY2VpdmVyfS5cbiAgICAgKiBAcGFyYW0ge1RyYWNrLklEfSBpZFxuICAgICAqIEBwYXJhbSB7VHJhY2sua2luZH0ga2luZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYWNrVHJhbnNjZWl2ZXIoaWQsIGtpbmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBraW5kOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZToga2luZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSB7QGxpbmsgVHJhY2tUcmFuc2NlaXZlcn0uXG4gICAgICogI2VtaXRzIFRyYWNrVHJhbnNjZWl2ZXIjc3RvcHBlZFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFRyYWNrVHJhbnNjZWl2ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RvcHBlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYWNrVHJhbnNjZWl2ZXI7XG59KEV2ZW50RW1pdHRlcikpO1xuLyoqXG4gKiBUaGUge0BsaW5rIFRyYWNrVHJhbnNjZWl2ZXJ9IHdhcyBzdG9wcGVkLlxuICogQGV2ZW50IFRyYWNrVHJhbnNjZWl2ZXIjc3RvcHBlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFRyYWNrVHJhbnNjZWl2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2NlaXZlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgICAgICB0b1tqXSA9IGZyb21baV07XG4gICAgcmV0dXJuIHRvO1xufTtcbnZhciBTdGF0ZU1hY2hpbmUgPSByZXF1aXJlKCcuL3N0YXRlbWFjaGluZScpO1xudmFyIF9hID0gcmVxdWlyZSgnLi91dGlsJyksIGJ1aWxkTG9nTGV2ZWxzID0gX2EuYnVpbGRMb2dMZXZlbHMsIG1ha2VVVUlEID0gX2EubWFrZVVVSUQ7XG52YXIgTG9nID0gcmVxdWlyZSgnLi91dGlsL2xvZycpO1xudmFyIE5ldHdvcmtNb25pdG9yID0gcmVxdWlyZSgnLi91dGlsL25ldHdvcmttb25pdG9yJyk7XG52YXIgVGltZW91dCA9IHJlcXVpcmUoJy4vdXRpbC90aW1lb3V0Jyk7XG52YXIgbkluc3RhbmNlcyA9IDA7XG4vKlxuICBUd2lsaW9Db25uZWN0aW9uIHN0YXRlc1xuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2XG4gICstLS0tLS0tLS0rICAgICAgICstLS0tLS0tLS0tLS0tLSsgICAgICAgKy0tLS0tLS0tLS0rXG4gIHwgIGVhcmx5ICB8IC0tLS0+IHwgIGNvbm5lY3RpbmcgIHwgLS0tLT4gfCAgY2xvc2VkICB8XG4gICstLS0tLS0tLS0rICAgICAgICstLS0tLS0tLS0tLS0tLSsgICAgICAgKy0tLS0tLS0tLS0rXG4gICAgXiAgICAgICAgICAgICAgICAgICAgIHwgXiB8ICAgICAgICAgICAgICAgICBeIF5cbiAgICB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IHwgICAgICAgICAgICAgICAgIHwgfFxuICAgIHwgfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAgICAgICAgICAgICAgICAgfCB8XG4gICAgfCB8IHwgLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAgICB8IHYgfCB8ICAgICAgICAgICAgICAgICAgIHYgICAgICAgICAgICAgICAgICAgfFxuICArLS0tLS0tLS0tLSsgICAgICAgICAgICstLS0tLS0tLSsgICAgICAgICAgICAgICB8XG4gIHwgd2FpdGluZyAgfCAtLS0tLS0tLT4gfCAgb3BlbiAgfCAtLS0tLS0tLS0tLS0tLS1cbiAgKy0tLS0tLS0tLS0rICAgICAgICAgICArLS0tLS0tLS0rXG4gKi9cbnZhciBzdGF0ZXMgPSB7XG4gICAgY2xvc2VkOiBbXSxcbiAgICBjb25uZWN0aW5nOiBbJ2Nsb3NlZCcsICdvcGVuJywgJ3dhaXRpbmcnXSxcbiAgICBlYXJseTogWydjbG9zZWQnLCAnY29ubmVjdGluZyddLFxuICAgIG9wZW46IFsnY2xvc2VkJ10sXG4gICAgd2FpdGluZzogWydjbG9zZWQnLCAnY29ubmVjdGluZycsICdlYXJseScsICdvcGVuJ11cbn07XG52YXIgZXZlbnRzID0ge1xuICAgIGNsb3NlZDogJ2Nsb3NlJyxcbiAgICBvcGVuOiAnb3BlbicsXG4gICAgd2FpdGluZzogJ3dhaXRpbmcnXG59O1xudmFyIFRDTVBfVkVSU0lPTiA9IDI7XG52YXIgREVGQVVMVF9NQVhfQ09OU0VDVVRJVkVfTUlTU0VEX0hFQVJUQkVBVFMgPSAzO1xudmFyIERFRkFVTFRfTUFYX0NPTlNFQ1VUSVZFX0ZBSUxFRF9IRUxMT1MgPSAzO1xudmFyIERFRkFVTFRfTUFYX1JFUVVFU1RFRF9IRUFSVEJFQVRfVElNRU9VVCA9IDUwMDA7XG52YXIgREVGQVVMVF9PUEVOX1RJTUVPVVQgPSAxNTAwMDtcbnZhciBERUZBVUxUX1dFTENPTUVfVElNRU9VVCA9IDUwMDA7XG52YXIgT1VUR09JTkdfSEVBUlRCRUFUX09GRlNFVCA9IDIwMDtcbnZhciBXU19DTE9TRV9OT1JNQUwgPSAxMDAwO1xudmFyIFdTX0NMT1NFX1dFTENPTUVfVElNRU9VVCA9IDMwMDA7XG52YXIgV1NfQ0xPU0VfSEVBUlRCRUFUU19NSVNTRUQgPSAzMDAxO1xudmFyIFdTX0NMT1NFX0hFTExPX0ZBSUxFRCA9IDMwMDI7XG52YXIgV1NfQ0xPU0VfU0VORF9GQUlMRUQgPSAzMDAzO1xudmFyIFdTX0NMT1NFX05FVFdPUktfQ0hBTkdFRCA9IDMwMDQ7XG52YXIgV1NfQ0xPU0VfQlVTWV9XQUlUID0gMzAwNTtcbnZhciBXU19DTE9TRV9TRVJWRVJfQlVTWSA9IDMwMDY7XG52YXIgV1NfQ0xPU0VfT1BFTl9USU1FT1VUID0gMzAwNztcbnZhciB0b3BsZXZlbCA9IGdsb2JhbC53aW5kb3cgfHwgZ2xvYmFsO1xudmFyIFdlYlNvY2tldCA9IHRvcGxldmVsLldlYlNvY2tldCA/IHRvcGxldmVsLldlYlNvY2tldCA6IHJlcXVpcmUoJ3dzJyk7XG52YXIgQ2xvc2VSZWFzb24gPSB7XG4gICAgQlVTWTogJ2J1c3knLFxuICAgIEZBSUxFRDogJ2ZhaWxlZCcsXG4gICAgTE9DQUw6ICdsb2NhbCcsXG4gICAgUkVNT1RFOiAncmVtb3RlJyxcbiAgICBUSU1FT1VUOiAndGltZW91dCdcbn07XG52YXIgd3NDbG9zZUNvZGVzVG9DbG9zZVJlYXNvbnMgPSBuZXcgTWFwKFtcbiAgICBbV1NfQ0xPU0VfV0VMQ09NRV9USU1FT1VULCBDbG9zZVJlYXNvbi5USU1FT1VUXSxcbiAgICBbV1NfQ0xPU0VfSEVBUlRCRUFUU19NSVNTRUQsIENsb3NlUmVhc29uLlRJTUVPVVRdLFxuICAgIFtXU19DTE9TRV9IRUxMT19GQUlMRUQsIENsb3NlUmVhc29uLkZBSUxFRF0sXG4gICAgW1dTX0NMT1NFX1NFTkRfRkFJTEVELCBDbG9zZVJlYXNvbi5GQUlMRURdLFxuICAgIFtXU19DTE9TRV9ORVRXT1JLX0NIQU5HRUQsIENsb3NlUmVhc29uLlRJTUVPVVRdLFxuICAgIFtXU19DTE9TRV9TRVJWRVJfQlVTWSwgQ2xvc2VSZWFzb24uQlVTWV0sXG4gICAgW1dTX0NMT1NFX09QRU5fVElNRU9VVCwgQ2xvc2VSZWFzb24uVElNRU9VVF1cbl0pO1xuLyoqXG4gKiBBIHtAbGluayBUd2lsaW9Db25uZWN0aW9ufSByZXByZXNlbnRzIGEgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAqIHRvIGEgVHdpbGlvIENvbm5lY3Rpb25zIE1lc3NhZ2luZyBQcm90b2NvbCAoVENNUCkgc2VydmVyLlxuICogQGZpcmVzIFR3aWxpb0Nvbm5lY3Rpb24jY2xvc2VcbiAqIEBmaXJlcyBUd2lsaW9Db25uZWN0aW9uI2Vycm9yXG4gKiBAZmlyZXMgVHdpbGlvQ29ubmVjdGlvbiNtZXNzYWdlXG4gKiBAZmlyZXMgVHdpbGlvQ29ubmVjdGlvbiNvcGVuXG4gKiBAZmlyZXMgVHdpbGlvQ29ubmVjdGlvbiN3YWl0aW5nXG4gKi9cbnZhciBUd2lsaW9Db25uZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUd2lsaW9Db25uZWN0aW9uLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBUd2lsaW9Db25uZWN0aW9ufS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyVXJsIC0gVENNUCBzZXJ2ZXIgdXJsXG4gICAgICogQHBhcmFtIHtUd2lsaW9Db25uZWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIHtAbGluayBUd2lsaW9Db25uZWN0aW9ufSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHdpbGlvQ29ubmVjdGlvbihzZXJ2ZXJVcmwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ2Vhcmx5Jywgc3RhdGVzKSB8fCB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBoZWxsb0JvZHk6IG51bGwsXG4gICAgICAgICAgICBtYXhDb25zZWN1dGl2ZUZhaWxlZEhlbGxvczogREVGQVVMVF9NQVhfQ09OU0VDVVRJVkVfRkFJTEVEX0hFTExPUyxcbiAgICAgICAgICAgIG1heENvbnNlY3V0aXZlTWlzc2VkSGVhcnRiZWF0czogREVGQVVMVF9NQVhfQ09OU0VDVVRJVkVfTUlTU0VEX0hFQVJUQkVBVFMsXG4gICAgICAgICAgICByZXF1ZXN0ZWRIZWFydGJlYXRUaW1lb3V0OiBERUZBVUxUX01BWF9SRVFVRVNURURfSEVBUlRCRUFUX1RJTUVPVVQsXG4gICAgICAgICAgICBvcGVuVGltZW91dDogREVGQVVMVF9PUEVOX1RJTUVPVVQsXG4gICAgICAgICAgICB3ZWxjb21lVGltZW91dDogREVGQVVMVF9XRUxDT01FX1RJTUVPVVQsXG4gICAgICAgICAgICBMb2c6IExvZyxcbiAgICAgICAgICAgIFdlYlNvY2tldDogV2ViU29ja2V0XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgbG9nTGV2ZWxzID0gYnVpbGRMb2dMZXZlbHMob3B0aW9ucy5sb2dMZXZlbCk7XG4gICAgICAgIHZhciBsb2cgPSBuZXcgb3B0aW9ucy5Mb2coJ2RlZmF1bHQnLCBfdGhpcywgbG9nTGV2ZWxzLCBvcHRpb25zLmxvZ2dlck5hbWUpO1xuICAgICAgICB2YXIgbmV0d29ya01vbml0b3IgPSBvcHRpb25zLm5ldHdvcmtNb25pdG9yID8gbmV3IE5ldHdvcmtNb25pdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbmV0d29ya01vbml0b3IudHlwZTtcbiAgICAgICAgICAgIHZhciByZWFzb24gPSBcIk5ldHdvcmsgY2hhbmdlZFwiICsgKHR5cGUgPyBcIiB0byBcIiArIHR5cGUgOiAnJyk7XG4gICAgICAgICAgICBsb2cuZGVidWcocmVhc29uKTtcbiAgICAgICAgICAgIF90aGlzLl9jbG9zZSh7IGNvZGU6IFdTX0NMT1NFX05FVFdPUktfQ0hBTkdFRCwgcmVhc29uOiByZWFzb24gfSk7XG4gICAgICAgIH0pIDogbnVsbDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9idXN5V2FpdFRpbWVvdXQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jb25zZWN1dGl2ZUhlYXJ0YmVhdHNNaXNzZWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jb29raWU6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9ldmVudE9ic2VydmVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuZXZlbnRPYnNlcnZlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9oZWFydGJlYXRUaW1lb3V0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaGVsbG9zTGVmdDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLm1heENvbnNlY3V0aXZlRmFpbGVkSGVsbG9zLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2luc3RhbmNlSWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogKytuSW5zdGFuY2VzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xvZzoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsb2dcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWVzc2FnZVF1ZXVlOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX25ldHdvcmtNb25pdG9yOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldHdvcmtNb25pdG9yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9uc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vcGVuVGltZW91dDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NlbmRIZWFydGJlYXRUaW1lb3V0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2VydmVyVXJsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHNlcnZlclVybFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF93ZWxjb21lVGltZW91dDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3dzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBldmVudHNUb0xldmVscyA9IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpbmc6ICdpbmZvJyxcbiAgICAgICAgICAgIGVhcmx5OiAnaW5mbycsXG4gICAgICAgICAgICBvcGVuOiAnaW5mbycsXG4gICAgICAgICAgICB3YWl0aW5nOiAnd2FybmluZycsXG4gICAgICAgICAgICBjbG9zZWQ6ICdpbmZvJ1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlIGluIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQuYXBwbHkoX3RoaXMsIF9fc3ByZWFkQXJyYXkoW2V2ZW50c1tzdGF0ZV1dLCBfX3JlYWQoYXJncykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldmVudCA9IHsgbmFtZTogc3RhdGUsIGdyb3VwOiAnc2lnbmFsaW5nJywgbGV2ZWw6IGV2ZW50c1RvTGV2ZWxzW190aGlzLnN0YXRlXSB9O1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChhcmdzLCAxKSwgcmVhc29uID0gX2FbMF07XG4gICAgICAgICAgICAgICAgZXZlbnQucGF5bG9hZCA9IHsgcmVhc29uOiByZWFzb24gfTtcbiAgICAgICAgICAgICAgICBldmVudC5sZXZlbCA9IHJlYXNvbiA9PT0gQ2xvc2VSZWFzb24uTE9DQUwgPyAnaW5mbycgOiAnZXJyb3InO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX2V2ZW50T2JzZXJ2ZXIuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5fZXZlbnRPYnNlcnZlci5lbWl0KCdldmVudCcsIHsgbmFtZTogX3RoaXMuc3RhdGUsIGdyb3VwOiAnc2lnbmFsaW5nJywgbGV2ZWw6IGV2ZW50c1RvTGV2ZWxzW190aGlzLnN0YXRlXSB9KTtcbiAgICAgICAgX3RoaXMuX2Nvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUd2lsaW9Db25uZWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW1R3aWxpb0Nvbm5lY3Rpb24gI1wiICsgdGhpcy5faW5zdGFuY2VJZCArIFwiOiBcIiArIHRoaXMuX3dzLnVybCArIFwiXVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIHtAbGluayBUd2lsaW9Db25uZWN0aW9ufS5cbiAgICAgKiBAcGFyYW0ge3tjb2RlOiBudW1iZXIsIHJlYXNvbjogc3RyaW5nfX0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb24ucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29kZSA9IF9hLmNvZGUsIHJlYXNvbiA9IF9hLnJlYXNvbjtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wZW5UaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuVGltZW91dC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl93ZWxjb21lVGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5fd2VsY29tZVRpbWVvdXQuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faGVhcnRiZWF0VGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0VGltZW91dC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zZW5kSGVhcnRiZWF0VGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5fc2VuZEhlYXJ0YmVhdFRpbWVvdXQuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbmV0d29ya01vbml0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX25ldHdvcmtNb25pdG9yLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYnVzeVdhaXRUaW1lb3V0ICYmIGNvZGUgIT09IFdTX0NMT1NFX0JVU1lfV0FJVCkge1xuICAgICAgICAgICAgdGhpcy5fYnVzeVdhaXRUaW1lb3V0LmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWVzc2FnZVF1ZXVlLnNwbGljZSgwKTtcbiAgICAgICAgdmFyIGxvZyA9IHRoaXMuX2xvZztcbiAgICAgICAgaWYgKGNvZGUgPT09IFdTX0NMT1NFX05PUk1BTCkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKCdDbG9zZWQnKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbignY2xvc2VkJywgbnVsbCwgW0Nsb3NlUmVhc29uLkxPQ0FMXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2cud2FybihcIkNsb3NlZDogXCIgKyBjb2RlICsgXCIgLSBcIiArIHJlYXNvbik7XG4gICAgICAgICAgICBpZiAoY29kZSAhPT0gV1NfQ0xPU0VfQlVTWV9XQUlUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uKCdjbG9zZWQnLCBudWxsLCBbXG4gICAgICAgICAgICAgICAgICAgIHdzQ2xvc2VDb2Rlc1RvQ2xvc2VSZWFzb25zLmdldChjb2RlKSB8fCBDbG9zZVJlYXNvbi5SRU1PVEVcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVhZHlTdGF0ZSA9IHRoaXMuX3dzLnJlYWR5U3RhdGU7XG4gICAgICAgIHZhciBXZWJTb2NrZXQgPSB0aGlzLl9vcHRpb25zLldlYlNvY2tldDtcbiAgICAgICAgaWYgKHJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DTE9TSU5HICYmIHJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DTE9TRUQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dzLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gdGhlIFRDTVAgc2VydmVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHdpbGlvQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnd2FpdGluZycpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbignZWFybHknKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlICE9PSAnZWFybHknKSB7XG4gICAgICAgICAgICBsb2cud2FybihcIlVuZXhwZWN0ZWQgc3RhdGUgXFxcIlwiICsgdGhpcy5zdGF0ZSArIFwiXFxcIiBmb3IgY29ubmVjdGluZyB0byB0aGVcIlxuICAgICAgICAgICAgICAgICsgJyBUQ01QIHNlcnZlci4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cyA9IG5ldyB0aGlzLl9vcHRpb25zLldlYlNvY2tldCh0aGlzLl9zZXJ2ZXJVcmwpO1xuICAgICAgICB2YXIgd3MgPSB0aGlzLl93cztcbiAgICAgICAgbG9nLmRlYnVnKCdDcmVhdGVkIGEgbmV3IFdlYlNvY2tldDonLCB3cyk7XG4gICAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5fY2xvc2UoZXZlbnQpOyB9KTtcbiAgICAgICAgdmFyIG9wZW5UaW1lb3V0ID0gdGhpcy5fb3B0aW9ucy5vcGVuVGltZW91dDtcbiAgICAgICAgLy8gQWRkIGEgdGltZW91dCBmb3IgZ2V0dGluZyB0aGUgb25vcGVuIGV2ZW50IG9uIHRoZSBXZWJTb2NrZXQgKDE1IHNlYykuIEFmdGVyIHRoYXQsIGF0dGVtcHQgdG8gcmVjb25uZWN0IG9ubHkgaWYgdGhpcyBpcyBub3QgdGhlIGZpcnN0IGF0dGVtcHQuXG4gICAgICAgIHRoaXMuX29wZW5UaW1lb3V0ID0gbmV3IFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlYXNvbiA9IFwiRmFpbGVkIHRvIG9wZW4gaW4gXCIgKyBvcGVuVGltZW91dCArIFwiIG1zXCI7XG4gICAgICAgICAgICBfdGhpcy5fY2xvc2UoeyBjb2RlOiBXU19DTE9TRV9PUEVOX1RJTUVPVVQsIHJlYXNvbjogcmVhc29uIH0pO1xuICAgICAgICB9LCBvcGVuVGltZW91dCk7XG4gICAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoJ1dlYlNvY2tldCBvcGVuZWQ6Jywgd3MpO1xuICAgICAgICAgICAgX3RoaXMuX29wZW5UaW1lb3V0LmNsZWFyKCk7XG4gICAgICAgICAgICBfdGhpcy5fc3RhcnRIYW5kc2hha2UoKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fbmV0d29ya01vbml0b3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbmV0d29ya01vbml0b3Iuc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwiSW5jb21pbmc6IFwiICsgbWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmFkJzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUJhZChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYnVzeSc6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVCdXN5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdieWUnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtc2cnOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogRWFjaCBpbmNvbWluZyBtZXNzYWdlIHNob3VsZCBiZSB0cmVhdGVkIGFzIGFuIGluY29taW5nXG4gICAgICAgICAgICAgICAgLy8gaGVhcnRiZWF0IGludGVudGlvbmFsbHkgZmFsbGluZyB0aHJvdWdoIHRvICdoZWFydGJlYXQnIGNhc2UuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgY2FzZSAnaGVhcnRiZWF0JzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUhlYXJ0YmVhdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWxjb21lJzpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZVdlbGNvbWUobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoXCJVbmtub3duIG1lc3NhZ2UgdHlwZTogXCIgKyBtZXNzYWdlLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihcIlVua25vd24gbWVzc2FnZSB0eXBlOiBcIiArIG1lc3NhZ2UudHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW4gaW5jb21pbmcgXCJiYWRcIiBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7e3JlYXNvbjogc3RyaW5nfX0gbWVzc2FnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHdpbGlvQ29ubmVjdGlvbi5wcm90b3R5cGUuX2hhbmRsZUJhZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgcmVhc29uID0gX2EucmVhc29uO1xuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBpZiAoIVsnY29ubmVjdGluZycsICdvcGVuJ10uaW5jbHVkZXModGhpcy5zdGF0ZSkpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiVW5leHBlY3RlZCBzdGF0ZSBcXFwiXCIgKyB0aGlzLnN0YXRlICsgXCJcXFwiIGZvciBoYW5kbGluZyBhIFxcXCJiYWRcXFwiIG1lc3NhZ2VcIlxuICAgICAgICAgICAgICAgICsgJyBmcm9tIHRoZSBUQ01QIHNlcnZlci4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICBsb2cud2FybihcIkNsb3Npbmc6IFwiICsgV1NfQ0xPU0VfSEVMTE9fRkFJTEVEICsgXCIgLSBcIiArIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZSh7IGNvZGU6IFdTX0NMT1NFX0hFTExPX0ZBSUxFRCwgcmVhc29uOiByZWFzb24gfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nLmRlYnVnKFwiRXJyb3I6IFwiICsgcmVhc29uKTtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbiBpbmNvbWluZyBcImJ1c3lcIiBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7e2Nvb2tpZTogP3N0cmluZywga2VlcEFsaXZlOiBib29sZWFuLCByZXRyeUFmdGVyOiBudW1iZXJ9fSBtZXNzYWdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uLnByb3RvdHlwZS5faGFuZGxlQnVzeSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29va2llID0gX2EuY29va2llLCBrZWVwQWxpdmUgPSBfYS5rZWVwQWxpdmUsIHJldHJ5QWZ0ZXIgPSBfYS5yZXRyeUFmdGVyO1xuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBpZiAoIVsnY29ubmVjdGluZycsICd3YWl0aW5nJ10uaW5jbHVkZXModGhpcy5zdGF0ZSkpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiVW5leHBlY3RlZCBzdGF0ZSBcXFwiXCIgKyB0aGlzLnN0YXRlICsgXCJcXFwiIGZvciBoYW5kbGluZyBhIFxcXCJidXN5XFxcIiBtZXNzYWdlXCJcbiAgICAgICAgICAgICAgICArICcgZnJvbSB0aGUgVENNUCBzZXJ2ZXIuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2J1c3lXYWl0VGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5fYnVzeVdhaXRUaW1lb3V0LmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3dlbGNvbWVUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLl93ZWxjb21lVGltZW91dC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWFzb24gPSByZXRyeUFmdGVyIDwgMFxuICAgICAgICAgICAgPyAnUmVjZWl2ZWQgdGVybWluYWwgXCJidXN5XCIgbWVzc2FnZSdcbiAgICAgICAgICAgIDogXCJSZWNlaXZlZCBcXFwiYnVzeVxcXCIgbWVzc2FnZSwgcmV0cnlpbmcgYWZ0ZXIgXCIgKyByZXRyeUFmdGVyICsgXCIgbXNcIjtcbiAgICAgICAgaWYgKHJldHJ5QWZ0ZXIgPCAwKSB7XG4gICAgICAgICAgICBsb2cud2FybihcIkNsb3Npbmc6IFwiICsgV1NfQ0xPU0VfU0VSVkVSX0JVU1kgKyBcIiAtIFwiICsgcmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlKHsgY29kZTogV1NfQ0xPU0VfU0VSVkVSX0JVU1ksIHJlYXNvbjogcmVhc29uIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhDb25zZWN1dGl2ZUZhaWxlZEhlbGxvcyA9IHRoaXMuX29wdGlvbnMubWF4Q29uc2VjdXRpdmVGYWlsZWRIZWxsb3M7XG4gICAgICAgIHRoaXMuX2hlbGxvc0xlZnQgPSBtYXhDb25zZWN1dGl2ZUZhaWxlZEhlbGxvcztcbiAgICAgICAgdGhpcy5fY29va2llID0gY29va2llIHx8IG51bGw7XG4gICAgICAgIGlmIChrZWVwQWxpdmUpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLl9idXN5V2FpdFRpbWVvdXQgPSBuZXcgVGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc3RhcnRIYW5kc2hha2UoKTsgfSwgcmV0cnlBZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2cud2FybihcIkNsb3Npbmc6IFwiICsgV1NfQ0xPU0VfQlVTWV9XQUlUICsgXCIgLSBcIiArIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZSh7IGNvZGU6IFdTX0NMT1NFX0JVU1lfV0FJVCwgcmVhc29uOiByZWFzb24gfSk7XG4gICAgICAgICAgICB0aGlzLl9idXN5V2FpdFRpbWVvdXQgPSBuZXcgVGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fY29ubmVjdCgpOyB9LCByZXRyeUFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zaXRpb24oJ3dhaXRpbmcnLCBudWxsLCBba2VlcEFsaXZlLCByZXRyeUFmdGVyXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW4gaW5jb21pbmcgXCJoZWFydGJlYXRcIiBtZXNzYWdlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHdpbGlvQ29ubmVjdGlvbi5wcm90b3R5cGUuX2hhbmRsZUhlYXJ0YmVhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJVbmV4cGVjdGVkIHN0YXRlIFxcXCJcIiArIHRoaXMuc3RhdGUgKyBcIlxcXCIgZm9yIGhhbmRsaW5nIGEgXFxcImhlYXJ0YmVhdFxcXCJcIlxuICAgICAgICAgICAgICAgICsgJyBtZXNzYWdlIGZyb20gdGhlIFRDTVAgc2VydmVyLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdFRpbWVvdXQucmVzZXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIG1pc3NlZCBcImhlYXJ0YmVhdFwiIG1lc3NhZ2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uLnByb3RvdHlwZS5faGFuZGxlSGVhcnRiZWF0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIHZhciBtYXhDb25zZWN1dGl2ZU1pc3NlZEhlYXJ0YmVhdHMgPSB0aGlzLl9vcHRpb25zLm1heENvbnNlY3V0aXZlTWlzc2VkSGVhcnRiZWF0cztcbiAgICAgICAgbG9nLmRlYnVnKFwiQ29uc2VjdXRpdmUgaGVhcnRiZWF0cyBtaXNzZWQ6IFwiICsgbWF4Q29uc2VjdXRpdmVNaXNzZWRIZWFydGJlYXRzKTtcbiAgICAgICAgdmFyIHJlYXNvbiA9IFwiTWlzc2VkIFwiICsgbWF4Q29uc2VjdXRpdmVNaXNzZWRIZWFydGJlYXRzICsgXCIgXFxcImhlYXJ0YmVhdFxcXCIgbWVzc2FnZXNcIjtcbiAgICAgICAgbG9nLndhcm4oXCJDbG9zaW5nOiBcIiArIFdTX0NMT1NFX0hFQVJUQkVBVFNfTUlTU0VEICsgXCIgLSBcIiArIHJlYXNvbik7XG4gICAgICAgIHRoaXMuX2Nsb3NlKHsgY29kZTogV1NfQ0xPU0VfSEVBUlRCRUFUU19NSVNTRUQsIHJlYXNvbjogcmVhc29uIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFuIGluY29taW5nIFwibXNnXCIgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge3tib2R5OiBvYmplY3R9fSBtZXNzYWdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uLnByb3RvdHlwZS5faGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgYm9keSA9IF9hLmJvZHk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiVW5leHBlY3RlZCBzdGF0ZSBcXFwiXCIgKyB0aGlzLnN0YXRlICsgXCJcXFwiIGZvciBoYW5kbGluZyBhIFxcXCJtc2dcXFwiIG1lc3NhZ2VcIlxuICAgICAgICAgICAgICAgICsgJyBmcm9tIHRoZSBUQ01QIHNlcnZlci4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBib2R5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbiBpbmNvbWluZyBcIndlbGNvbWVcIiBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7eyBuZWdvdGlhdGVkVGltZW91dDogbnVtYmVyIH19IG1lc3NhZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb24ucHJvdG90eXBlLl9oYW5kbGVXZWxjb21lID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBuZWdvdGlhdGVkVGltZW91dCA9IF9hLm5lZ290aWF0ZWRUaW1lb3V0O1xuICAgICAgICB2YXIgbG9nID0gdGhpcy5fbG9nO1xuICAgICAgICBpZiAoIVsnY29ubmVjdGluZycsICd3YWl0aW5nJ10uaW5jbHVkZXModGhpcy5zdGF0ZSkpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiVW5leHBlY3RlZCBzdGF0ZSBcXFwiXCIgKyB0aGlzLnN0YXRlICsgXCJcXFwiIGZvciBoYW5kbGluZyBhIFxcXCJ3ZWxjb21lXFxcIlwiXG4gICAgICAgICAgICAgICAgKyAnIG1lc3NhZ2UgZnJvbSB0aGUgVENNUCBzZXJ2ZXIuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICd3YWl0aW5nJykge1xuICAgICAgICAgICAgbG9nLmRlYnVnKCdSZWNlaXZlZCBcIndlbGNvbWVcIiBtZXNzYWdlLCBubyBuZWVkIHRvIHJldHJ5IGNvbm5lY3Rpb24uJyk7XG4gICAgICAgICAgICB0aGlzLl9idXN5V2FpdFRpbWVvdXQuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4Q29uc2VjdXRpdmVNaXNzZWRIZWFydGJlYXRzID0gdGhpcy5fb3B0aW9ucy5tYXhDb25zZWN1dGl2ZU1pc3NlZEhlYXJ0YmVhdHM7XG4gICAgICAgIHZhciBoZWFydGJlYXRUaW1lb3V0ID0gbmVnb3RpYXRlZFRpbWVvdXQgKiBtYXhDb25zZWN1dGl2ZU1pc3NlZEhlYXJ0YmVhdHM7XG4gICAgICAgIHZhciBvdXRnb2luZ0hlYXJ0YmVhdFRpbWVvdXQgPSBuZWdvdGlhdGVkVGltZW91dCAtIE9VVEdPSU5HX0hFQVJUQkVBVF9PRkZTRVQ7XG4gICAgICAgIHRoaXMuX3dlbGNvbWVUaW1lb3V0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdFRpbWVvdXQgPSBuZXcgVGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faGFuZGxlSGVhcnRiZWF0VGltZW91dCgpOyB9LCBoZWFydGJlYXRUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZVF1ZXVlLnNwbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBfdGhpcy5fc2VuZChtZXNzYWdlKTsgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRIZWFydGJlYXRUaW1lb3V0ID0gbmV3IFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NlbmRIZWFydGJlYXQoKTsgfSwgb3V0Z29pbmdIZWFydGJlYXRUaW1lb3V0KTtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uKCdvcGVuJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYSBtaXNzZWQgXCJ3ZWxjb21lXCIgbWVzc2FnZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb24ucHJvdG90eXBlLl9oYW5kbGVXZWxjb21lVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2cgPSB0aGlzLl9sb2c7XG4gICAgICAgIGlmICh0aGlzLl9oZWxsb3NMZWZ0IDw9IDApIHtcbiAgICAgICAgICAgIHZhciByZWFzb24gPSAnQWxsIGhhbmRzaGFrZSBhdHRlbXB0cyBmYWlsZWQnO1xuICAgICAgICAgICAgbG9nLndhcm4oXCJDbG9zaW5nOiBcIiArIFdTX0NMT1NFX1dFTENPTUVfVElNRU9VVCArIFwiIC0gXCIgKyByZWFzb24pO1xuICAgICAgICAgICAgdGhpcy5fY2xvc2UoeyBjb2RlOiBXU19DTE9TRV9XRUxDT01FX1RJTUVPVVQsIHJlYXNvbjogcmVhc29uIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhDb25zZWN1dGl2ZUZhaWxlZEhlbGxvcyA9IHRoaXMuX29wdGlvbnMubWF4Q29uc2VjdXRpdmVGYWlsZWRIZWxsb3M7XG4gICAgICAgIGxvZy53YXJuKFwiSGFuZHNoYWtlIGF0dGVtcHQgXCIgKyAobWF4Q29uc2VjdXRpdmVGYWlsZWRIZWxsb3MgLSB0aGlzLl9oZWxsb3NMZWZ0KSArIFwiIGZhaWxlZFwiKTtcbiAgICAgICAgdGhpcy5fc3RhcnRIYW5kc2hha2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBUQ01QIHNlcnZlci5cbiAgICAgKiBAcGFyYW0geyp9IG1lc3NhZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb24ucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHJlYWR5U3RhdGUgPSB0aGlzLl93cy5yZWFkeVN0YXRlO1xuICAgICAgICB2YXIgV2ViU29ja2V0ID0gdGhpcy5fb3B0aW9ucy5XZWJTb2NrZXQ7XG4gICAgICAgIGlmIChyZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeShtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIk91dGdvaW5nOiBcIiArIGRhdGEpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl93cy5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZW5kSGVhcnRiZWF0VGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIG91dGdvaW5nIG1lc3NhZ2UgaXMgdG8gYmUgdHJlYXRlZCBhcyBhbiBvdXRnb2luZyBoZWFydGJlYXQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRIZWFydGJlYXRUaW1lb3V0LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9ICdGYWlsZWQgdG8gc2VuZCBtZXNzYWdlJztcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIkNsb3Npbmc6IFwiICsgV1NfQ0xPU0VfU0VORF9GQUlMRUQgKyBcIiAtIFwiICsgcmVhc29uKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZSh7IGNvZGU6IFdTX0NMT1NFX1NFTkRfRkFJTEVELCByZWFzb246IHJlYXNvbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIFwiaGVhcnRiZWF0XCIgbWVzc2FnZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb24ucHJvdG90eXBlLl9zZW5kSGVhcnRiZWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZW5kKHsgdHlwZTogJ2hlYXJ0YmVhdCcgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIGEgXCJoZWxsb1wiIG1lc3NhZ2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uLnByb3RvdHlwZS5fc2VuZEhlbGxvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9vcHRpb25zLCBoZWxsb0JvZHkgPSBfYS5oZWxsb0JvZHksIHRpbWVvdXQgPSBfYS5yZXF1ZXN0ZWRIZWFydGJlYXRUaW1lb3V0O1xuICAgICAgICB2YXIgaGVsbG8gPSB7XG4gICAgICAgICAgICBpZDogbWFrZVVVSUQoKSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICAgICAgICB0eXBlOiAnaGVsbG8nLFxuICAgICAgICAgICAgdmVyc2lvbjogVENNUF9WRVJTSU9OXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9jb29raWUpIHtcbiAgICAgICAgICAgIGhlbGxvLmNvb2tpZSA9IHRoaXMuX2Nvb2tpZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVsbG9Cb2R5KSB7XG4gICAgICAgICAgICBoZWxsby5ib2R5ID0gaGVsbG9Cb2R5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlbmQoaGVsbG8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBvciBlbnF1ZXVlIGEgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0geyp9IG1lc3NhZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb24ucHJvdG90eXBlLl9zZW5kT3JFbnF1ZXVlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbmRPckVucXVldWUgPSB0aGlzLnN0YXRlID09PSAnb3BlbidcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIF90aGlzLl9zZW5kKG1lc3NhZ2UpOyB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBfdGhpcy5fbWVzc2FnZVF1ZXVlLnB1c2gobWVzc2FnZSk7IH07XG4gICAgICAgIHNlbmRPckVucXVldWUobWVzc2FnZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgVENNUCBoYW5kc2hha2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUd2lsaW9Db25uZWN0aW9uLnByb3RvdHlwZS5fc3RhcnRIYW5kc2hha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChbJ2Vhcmx5JywgJ3dhaXRpbmcnXS5pbmNsdWRlcyh0aGlzLnN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uKCdjb25uZWN0aW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlbGxvc0xlZnQtLTtcbiAgICAgICAgdGhpcy5fc2VuZEhlbGxvKCk7XG4gICAgICAgIHZhciB3ZWxjb21lVGltZW91dCA9IHRoaXMuX29wdGlvbnMud2VsY29tZVRpbWVvdXQ7XG4gICAgICAgIHRoaXMuX3dlbGNvbWVUaW1lb3V0ID0gbmV3IFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2hhbmRsZVdlbGNvbWVUaW1lb3V0KCk7IH0sIHdlbGNvbWVUaW1lb3V0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSB7QGxpbmsgVHdpbGlvQ29ubmVjdGlvbn0uXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgVHdpbGlvQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlbmRPckVucXVldWUoeyB0eXBlOiAnYnllJyB9KTtcbiAgICAgICAgdGhpcy5fY2xvc2UoeyBjb2RlOiBXU19DTE9TRV9OT1JNQUwsIHJlYXNvbjogJ05vcm1hbCcgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIGEgXCJtc2dcIiBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7Kn0gYm9keVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFR3aWxpb0Nvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgdGhpcy5fc2VuZE9yRW5xdWV1ZSh7IGJvZHk6IGJvZHksIHR5cGU6ICdtc2cnIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFR3aWxpb0Nvbm5lY3Rpb247XG59KFN0YXRlTWFjaGluZSkpO1xuLyoqXG4gKiBBIHVuaXF1ZSBzdHJpbmcgZGVwaWN0aW5nIHRoZSByZWFzb24gZm9yIHRoZSB7QGxpbmsgVHdpbGlvQ29ubmVjdGlvbn0gYmVpbmcgY2xvc2VkLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuVHdpbGlvQ29ubmVjdGlvbi5DbG9zZVJlYXNvbiA9IENsb3NlUmVhc29uO1xuLyoqXG4gKiBBIHtAbGluayBUd2lsaW9Db25uZWN0aW9ufSB3YXMgY2xvc2VkLlxuICogQGV2ZW50IFR3aWxpb0Nvbm5lY3Rpb24jY2xvc2VcbiAqIEBwYXJhbSB7Q2xvc2VSZWFzb259IHJlYXNvbiAtIFRoZSByZWFzb24gZm9yIHRoZSB7QGxpbmsgVHdpbGlvQ29ubmVjdGlvbn0gYmVpbmcgY2xvc2VkXG4gKi9cbi8qKlxuICogQSB7QGxpbmsgVHdpbGlvQ29ubmVjdGlvbn0gcmVjZWl2ZWQgYW4gZXJyb3IgZnJvbSB0aGUgVENNUCBzZXJ2ZXIuXG4gKiBAZXZlbnQgVHdpbGlvQ29ubmVjdGlvbiNlcnJvclxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgLSBUaGUgVENNUCBzZXJ2ZXIgZXJyb3JcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBUd2lsaW9Db25uZWN0aW9ufSByZWNlaXZlZCBhIG1lc3NhZ2UgZnJvbSB0aGUgVENNUCBzZXJ2ZXIuXG4gKiBAZXZlbnQgVHdpbGlvQ29ubmVjdGlvbiNtZXNzYWdlXG4gKiBAcGFyYW0geyp9IGJvZHkgLSBNZXNzYWdlIGJvZHlcbiAqL1xuLyoqXG4gKiBBIHtAbGluayBUd2lsaW9Db25uZWN0aW9ufSBjb21wbGV0ZWQgYSBoZWxsby93ZWxjb21lIGhhbmRzaGFrZSB3aXRoIHRoZSBUQ01QIHNlcnZlci5cbiAqIEBldmVudCBUd2lsaW9Db25uZWN0aW9uI29wZW5cbiAqL1xuLyoqXG4gKiBBIHtAbGluayBUd2lsaW9Db25uZWN0aW9ufSByZWNlaXZlZCBhIFwiYnVzeVwiIG1lc3NhZ2UgZnJvbSB0aGUgVENNUCBzZXJ2ZXIuXG4gKiBAZXZlbnQgVHdpbGlvQ29ubmVjdGlvbiN3YWl0aW5nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBBbGl2ZSAtIHRydWUgaWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIHJldGFpbmVkXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cnlBZnRlciAtIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCBhIHJldHJ5IGlzIGF0dGVtcHRlZFxuICovXG4vKipcbiAqIHtAbGluayBUd2lsaW9Db25uZWN0aW9ufSBvcHRpb25zXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUd2lsaW9Db25uZWN0aW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtFdmVudE9ic2VydmVyfSBbZXZlbnRPYnNlcnZlcl0gLSBPcHRpb25hbCBldmVudCBvYnNlcnZlclxuICogQHByb3BlcnR5IHsqfSBbaGVsbG9Cb2R5PW51bGxdIC0gT3B0aW9uYWwgYm9keSBmb3IgXCJoZWxsb1wiIG1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7TG9nTGV2ZWx9IFtsb2dMZXZlbD13YXJuXSAtIExvZyBsZXZlbCBvZiB0aGUge0BsaW5rIFR3aWxpb0Nvbm5lY3Rpb259XG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heENvbnNlY3V0aXZlRmFpbGVkSGVsbG9zPTNdIC0gTWF4LiBudW1iZXIgb2YgY29uc2VjdXRpdmUgZmFpbGVkIFwiaGVsbG9cInNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Q29uc2VjdXRpdmVNaXNzZWRIZWFydGJlYXRzPTNdIC0gTWF4LiBudW1iZXIgb2YgKGVmZmVjdGl2ZSkgY29uc2VjdXRpdmUgXCJoZWFydGJlYXRcIiBtZXNzYWdlcyB0aGF0IGNhbiBiZSBtaXNzZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVxdWVzdGVkSGVhcnRiZWF0VGltZW91dD01MDAwXSAtIFwiaGVhcnRiZWF0XCIgdGltZW91dCAobXMpIHJlcXVlc3RlZCBieSB0aGUge0BsaW5rIFR3aWxpb0Nvbm5lY3Rpb259XG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dlbGNvbWVUaW1lb3V0PTUwMDBdIC0gVGltZSAobXMpIHRvIHdhaXQgZm9yIHRoZSBcIndlbGNvbWVcIiBtZXNzYWdlIGFmdGVyIHNlbmRpbmcgdGhlIFwiaGVsbG9cIiBtZXNzYWdlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVHdpbGlvQ29ubmVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR3aWxpb2Nvbm5lY3Rpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmVyID0gcmVxdWlyZSgnLi8nKS5kZWZlcjtcbi8qKlxuICogQW4ge0BsaW5rIEFzeW5jVmFyfSBpcyBhbiBcImFzeW5jaHJvbm91cyB2YXJpYWJsZVwiIHdoaWNoIG1heSBvciBtYXkgbm90XG4gKiBjb250YWluIGEgdmFsdWUgb2Ygc29tZSB0eXBlIFQuIFlvdSBjYW4gcHV0IGEgdmFsdWUgaW50byB0aGUge0BsaW5rIEFzeW5jVmFyfVxuICogd2l0aCB7QGxpbmsgQXN5bmNWYXIjcHV0fS4gQ2FsbGVycyBjYW4gdGFrZSBhIHZhbHVlIG91dCBvZiB0aGVcbiAqIHtAbGluayBBc3luY1Zhcn0gYnkgcXVldWVpbmcgdXAgd2l0aCB7QGxpbmsgQXN5bmNWYXIjdGFrZX0uIE4gY2FsbHMgdG9cbiAqIHtAbGluayBBc3luY1ZhciN0YWtlfSByZXF1aXJlIE4gY2FsbHMgdG8ge0BsaW5rIEFzeW5jVmFyI3B1dH0gdG8gcmVzb2x2ZSwgYW5kXG4gKiB0aGV5IHJlc29sdmUgaW4gb3JkZXIuXG4gKi9cbnZhciBBc3luY1ZhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4ge0BsaW5rIEFzeW5jVmFyfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY1ZhcigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgX2RlZmVycmVkczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9oYXNWYWx1ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF92YWx1ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXQgYSB2YWx1ZSBpbnRvIHRoZSB7QGxpbmsgQXN5bmNWYXJ9LlxuICAgICAqIEBwYXJhbSB7VH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBBc3luY1Zhci5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gdGhpcy5fZGVmZXJyZWRzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChkZWZlcnJlZCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUYWtlIHRoZSB2YWx1ZSBvdXQgb2YgdGhlIHtAbGluayBBc3luY1Zhcn0uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VD59XG4gICAgICovXG4gICAgQXN5bmNWYXIucHJvdG90eXBlLnRha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9oYXNWYWx1ZSAmJiAhdGhpcy5fZGVmZXJyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5faGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIHRoaXMuX2RlZmVycmVkcy5wdXNoKGRlZmVycmVkKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIF90aGlzLl9oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBc3luY1Zhcjtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IEFzeW5jVmFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmN2YXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgICAgICB0b1tqXSA9IGZyb21baV07XG4gICAgcmV0dXJuIHRvO1xufTtcbi8qKlxuICogQSBQcm9taXNlIHRoYXQgY2FuIGJlIGNhbmNlbGVkIHdpdGgge0BsaW5rIENhbmNlbGFibGVQcm9taXNlI2NhbmNlbH0uXG4gKiBAZXh0ZW5kcyBQcm9taXNlXG4qL1xudmFyIENhbmNlbGFibGVQcm9taXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyB7QGxpbmsgQ2FuY2VsYWJsZVByb21pc2V9LlxuICAgICAqIEBwYXJhbSB7Q2FuY2VsYWJsZVByb21pc2UuT25DcmVhdGV9IG9uQ3JlYXRlXG4gICAgICogQHBhcmFtIHtDYW5jZWxhYmxlUHJvbWlzZS5PbkNhbmNlbH0gb25DYW5jZWxcbiAgICAqLyAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiB7QGxpbmsgQ2FuY2VsYWJsZVByb21pc2V9IGNyZWF0aW9uXG4gICAgICogQHR5cGVkZWYge2Z1bmN0aW9ufSBDYW5jZWxhYmxlUHJvbWlzZS5PbkNyZWF0ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IHJlc29sdmVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCopfSByZWplY3RcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IGJvb2xlYW59IGlzQ2FuY2VsZWRcbiAgICAqLyAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHtAbGluayBDYW5jZWxhYmxlUHJvbWlzZSNjYW5jZWx9IGlzIGNhbGxlZFxuICAgICAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gQ2FuY2VsYWJsZVByb21pc2UuT25DYW5jZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDYW5jZWxhYmxlUHJvbWlzZShvbkNyZWF0ZSwgb25DYW5jZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgX2lzQ2FuY2VsYWJsZToge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzQ2FuY2VsZWQ6IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25DYW5jZWw6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb25DYW5jZWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3Byb21pc2UnLCB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIG9uQ3JlYXRlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNDYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzQ2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faXNDYW5jZWxlZDsgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc3luY2hyb25vdXNseS1yZWplY3RlZCB7QGxpbmsgQ2FuY2VsYWJsZVByb21pc2V9LlxuICAgICAqIEBwYXJhbSB7Kn0gcmVhc29uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgQ2FuY2VsYWJsZVByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gbmV3IENhbmNlbGFibGVQcm9taXNlKGZ1bmN0aW9uIHJlamVjdGVkKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0sIGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzeW5jaHJvbm91c2x5LXJlc29sdmVkIHtAbGluayBDYW5jZWxhYmxlUHJvbWlzZX0uXG4gICAgICogQHBhcmFtIHsqfFByb21pc2U8Kj58VGhlbmFibGU8Kj59IHJlc3VsdFxuICAgICAqIEByZXR1cm5zIHtDYW5jZWxhYmxlUHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICBDYW5jZWxhYmxlUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbmV3IENhbmNlbGFibGVQcm9taXNlKGZ1bmN0aW9uIHJlc29sdmVkKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gb25DYW5jZWwoKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gY2FuY2VsIHRoZSB7QGxpbmsgQ2FuY2VsYWJsZVByb21pc2V9LlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIENhbmNlbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0NhbmNlbGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fb25DYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7Q2FuY2VsYWJsZVByb21pc2V9XG4gICAgICovXG4gICAgQ2FuY2VsYWJsZVByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlO1xuICAgICAgICByZXR1cm4gbmV3IENhbmNlbGFibGVQcm9taXNlKGZ1bmN0aW9uIG9uQ3JlYXRlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcHJvbWlzZS5jYXRjaC5hcHBseShwcm9taXNlLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncykpKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0sIHRoaXMuX29uQ2FuY2VsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBvblJlc29sdmVkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW29uUmVqZWN0ZWRdXG4gICAgICogQHJldHVybnMge0NhbmNlbGFibGVQcm9taXNlfVxuICAgICAqL1xuICAgIENhbmNlbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlO1xuICAgICAgICByZXR1cm4gbmV3IENhbmNlbGFibGVQcm9taXNlKGZ1bmN0aW9uIG9uQ3JlYXRlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuLmFwcGx5KHByb21pc2UsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSkpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSwgdGhpcy5fb25DYW5jZWwpO1xuICAgIH07XG4gICAgcmV0dXJuIENhbmNlbGFibGVQcm9taXNlO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsYWJsZVByb21pc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYW5jZWxhYmxlcHJvbWlzZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX0VOVklST05NRU5UID0gJ3Byb2QnO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9SRUFMTSA9ICd1czEnO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9SRUdJT04gPSAnZ2xsJztcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfTE9HX0xFVkVMID0gJ3dhcm4nO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9MT0dHRVJfTkFNRSA9ICd0d2lsaW8tdmlkZW8nO1xubW9kdWxlLmV4cG9ydHMuV1NfU0VSVkVSID0gZnVuY3Rpb24gKGVudmlyb25tZW50LCByZWdpb24pIHtcbiAgICByZWdpb24gPSByZWdpb24gPT09ICdnbGwnID8gJ2dsb2JhbCcgOiBlbmNvZGVVUklDb21wb25lbnQocmVnaW9uKTtcbiAgICByZXR1cm4gZW52aXJvbm1lbnQgPT09ICdwcm9kJ1xuICAgICAgICA/IFwid3NzOi8vXCIgKyByZWdpb24gKyBcIi52c3MudHdpbGlvLmNvbS9zaWduYWxpbmdcIlxuICAgICAgICA6IFwid3NzOi8vXCIgKyByZWdpb24gKyBcIi52c3MuXCIgKyBlbnZpcm9ubWVudCArIFwiLnR3aWxpby5jb20vc2lnbmFsaW5nXCI7XG59O1xubW9kdWxlLmV4cG9ydHMuUFVCTElTSF9NQVhfQVRURU1QVFMgPSA1O1xubW9kdWxlLmV4cG9ydHMuUFVCTElTSF9CQUNLT0ZGX0pJVFRFUiA9IDEwO1xubW9kdWxlLmV4cG9ydHMuUFVCTElTSF9CQUNLT0ZGX01TID0gMjA7XG4vKipcbiAqIFJldHVybnMgdGhlIGFwcHJvcHJpYXRlIGluZGVmaW5pdGUgYXJ0aWNsZSAoXCJhXCIgfCBcImFuXCIpLlxuICogQHBhcmFtIHtzdHJpbmd9IHdvcmQgLSBUaGUgd29yZCB3aGljaCBkZXRlcm1pbmVzIHdoZXRoZXIgXCJhXCIgfCBcImFuXCIgaXMgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFwiYVwiIGlmIHdvcmQncyBmaXJzdCBsZXR0ZXIgaXMgYSB2b3dlbCwgXCJhblwiIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBhcnRpY2xlKHdvcmQpIHtcbiAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBUaGlzIHdpbGwgbm90IGJlIGFjY3VyYXRlIGZvciB3b3JkcyBsaWtlIFwiaG91clwiLFxuICAgIC8vIHdoaWNoIGhhdmUgY29uc29uYW50cyBhcyB0aGVpciBmaXJzdCBjaGFyYWN0ZXIsIGJ1dCBhcmUgcHJvbm91bmNlZCBsaWtlXG4gICAgLy8gdm93ZWxzLiBXZSBjYW4gYWRkcmVzcyB0aGlzIGlzc3VlIGlmIHRoZSBuZWVkIGFyaXNlcy5cbiAgICByZXR1cm4gWydhJywgJ2UnLCAnaScsICdvJywgJ3UnXS5pbmNsdWRlcyh3b3JkLnRvTG93ZXJDYXNlKClbMF0pID8gJ2FuJyA6ICdhJztcbn1cbm1vZHVsZS5leHBvcnRzLnR5cGVFcnJvcnMgPSB7XG4gICAgSUxMRUdBTF9JTlZPS0U6IGZ1bmN0aW9uIChuYW1lLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBjYWxsIHRvIFwiICsgbmFtZSArIFwiOiBcIiArIGNvbnRleHQpO1xuICAgIH0sXG4gICAgSU5WQUxJRF9UWVBFOiBmdW5jdGlvbiAobmFtZSwgdHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihuYW1lICsgXCIgbXVzdCBiZSBcIiArIGFydGljbGUodHlwZSkgKyBcIiBcIiArIHR5cGUpO1xuICAgIH0sXG4gICAgSU5WQUxJRF9WQUxVRTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlRXJyb3IobmFtZSArIFwiIG11c3QgYmUgb25lIG9mIFwiICsgdmFsdWVzLmpvaW4oJywgJykpO1xuICAgIH0sXG4gICAgUkVRVUlSRURfQVJHVU1FTlQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKG5hbWUgKyBcIiBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9GUkFNRV9SQVRFID0gMjQ7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX1ZJREVPX1BST0NFU1NPUl9TVEFUU19JTlRFUlZBTF9NUyA9IDEwMDAwO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9JQ0VfR0FUSEVSSU5HX1RJTUVPVVRfTVMgPSAxNTAwMDtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfU0VTU0lPTl9USU1FT1VUX1NFQyA9IDMwO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9OUV9MRVZFTF9MT0NBTCA9IDE7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX05RX0xFVkVMX1JFTU9URSA9IDA7XG5tb2R1bGUuZXhwb3J0cy5NQVhfTlFfTEVWRUwgPSAzO1xubW9kdWxlLmV4cG9ydHMuSUNFX0FDVElWSVRZX0NIRUNLX1BFUklPRF9NUyA9IDEwMDA7XG5tb2R1bGUuZXhwb3J0cy5JQ0VfSU5BQ1RJVklUWV9USFJFU0hPTERfTVMgPSAzMDAwO1xubW9kdWxlLmV4cG9ydHMuaWNlUmVzdGFydEJhY2tvZmZDb25maWcgPSB7XG4gICAgZmFjdG9yOiAxLjEsXG4gICAgaW5pdGlhbERlbGF5OiAxLFxuICAgIG1heERlbGF5OiBtb2R1bGUuZXhwb3J0cy5ERUZBVUxUX1NFU1NJT05fVElNRU9VVF9TRUMgKiAxMDAwLFxuICAgIHJhbmRvbWlzYXRpb25GYWN0b3I6IDAuNVxufTtcbm1vZHVsZS5leHBvcnRzLnJlY29ubmVjdEJhY2tvZmZDb25maWcgPSB7XG4gICAgZmFjdG9yOiAxLjUsXG4gICAgaW5pdGlhbERlbGF5OiA4MCxcbiAgICByYW5kb21pc2F0aW9uRmFjdG9yOiAwLjVcbn07XG5tb2R1bGUuZXhwb3J0cy5zdWJzY3JpcHRpb25Nb2RlID0ge1xuICAgIE1PREVfQ09MTEFCT1JBVElPTjogJ2NvbGxhYm9yYXRpb24nLFxuICAgIE1PREVfR1JJRDogJ2dyaWQnLFxuICAgIE1PREVfUFJFU0VOVEFUSU9OOiAncHJlc2VudGF0aW9uJ1xufTtcbm1vZHVsZS5leHBvcnRzLnRyYWNrU3dpdGNoT2ZmTW9kZSA9IHtcbiAgICBNT0RFX0RJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIE1PREVfREVURUNURUQ6ICdkZXRlY3RlZCcsXG4gICAgTU9ERV9QUkVESUNURUQ6ICdwcmVkaWN0ZWQnXG59O1xubW9kdWxlLmV4cG9ydHMudHJhY2tQcmlvcml0eSA9IHtcbiAgICBQUklPUklUWV9ISUdIOiAnaGlnaCcsXG4gICAgUFJJT1JJVFlfTE9XOiAnbG93JyxcbiAgICBQUklPUklUWV9TVEFOREFSRDogJ3N0YW5kYXJkJ1xufTtcbm1vZHVsZS5leHBvcnRzLmNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCA9IHtcbiAgICBNT0RFX0FVVE86ICdhdXRvJyxcbiAgICBNT0RFX01BTlVBTDogJ21hbnVhbCdcbn07XG5tb2R1bGUuZXhwb3J0cy52aWRlb0NvbnRlbnRQcmVmZXJlbmNlc01vZGUgPSB7XG4gICAgTU9ERV9BVVRPOiAnYXV0bycsXG4gICAgTU9ERV9NQU5VQUw6ICdtYW51YWwnXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBkZXRlY3RTaWxlbmNlID0gcmVxdWlyZSgnLi4vd2ViYXVkaW8vZGV0ZWN0c2lsZW5jZScpO1xudmFyIE5fQVRURU1QVFMgPSAzO1xudmFyIEFUVEVNUFRfRFVSQVRJT05fTVMgPSAyNTA7XG4vKipcbiAqIERldGVjdCB3aGV0aGVyIHRoZSBhdWRpbyBzdHJlYW0gcmVuZGVyZWQgYnkgdGhlIGdpdmVuIEhUTUxWaWRlb0VsZW1lbnQgaXMgc2lsZW50LlxuICogQHBhcmFtIHtIVE1MQXVkaW9FbGVtZW50fSBlbFxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHRydWUgaWYgc2lsZW50LCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdFNpbGVudEF1ZGlvKGVsKSB7XG4gICAgLy8gTk9URShtbWFsYXZhbGxpKTogV2UgaGF2ZSB0byBkZWxheSByZXF1aXJlLWluZyBBdWRpb0NvbnRleHRGYWN0b3J5LCBiZWNhdXNlXG4gICAgLy8gaXQgZXhwb3J0cyBhIGRlZmF1bHQgaW5zdGFuY2Ugd2hvc2UgY29uc3RydWN0b3IgY2FsbHMgT2JqZWN0LmFzc2lnbi5cbiAgICB2YXIgQXVkaW9Db250ZXh0RmFjdG9yeSA9IHJlcXVpcmUoJy4uL3dlYmF1ZGlvL2F1ZGlvY29udGV4dCcpO1xuICAgIHZhciBob2xkZXIgPSB7fTtcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gQXVkaW9Db250ZXh0RmFjdG9yeS5nZXRPckNyZWF0ZShob2xkZXIpO1xuICAgIHZhciBhdHRlbXB0c0xlZnQgPSBOX0FUVEVNUFRTO1xuICAgIGZ1bmN0aW9uIGRvQ2hlY2tTaWxlbmNlKCkge1xuICAgICAgICBhdHRlbXB0c0xlZnQtLTtcbiAgICAgICAgcmV0dXJuIGRldGVjdFNpbGVuY2UoYXVkaW9Db250ZXh0LCBlbC5zcmNPYmplY3QsIEFUVEVNUFRfRFVSQVRJT05fTVMpLnRoZW4oZnVuY3Rpb24gKGlzU2lsZW50KSB7XG4gICAgICAgICAgICBpZiAoIWlzU2lsZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0dGVtcHRzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9DaGVja1NpbGVuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBJZiBhbiBlcnJvciBpcyB0aHJvd24gd2hpbGUgZGV0ZWN0IHNpbGVuY2UsIHRoZSBhdWRpb1xuICAgICAgICAgICAgLy8gc3RyZWFtIGlzIGFzc3VtZWQgdG8gYmUgc2lsZW50LlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZXNvbHZlIHRoZSByZXR1cm5lZCBQcm9taXNlIHdpdGggdHJ1ZSBpZiAzIGNvbnNlY3V0aXZlIGF0dGVtcHRzXG4gICAgLy8gdG8gZGV0ZWN0IHNpbGVudCBhdWRpbyBhcmUgc3VjY2Vzc2Z1bC5cbiAgICByZXR1cm4gZG9DaGVja1NpbGVuY2UoKS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQXVkaW9Db250ZXh0RmFjdG9yeS5yZWxlYXNlKGhvbGRlcik7XG4gICAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRldGVjdFNpbGVudEF1ZGlvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0c2lsZW50YXVkaW8uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQ2FjaGVkIGNvcHkgb2YgdGhlIDxjYW52YXM+IHVzZWQgdG8gY2hlY2sgc2lsZW50IHZpZGVvIGZyYW1lcy5cbnZhciBjYW52YXMgPSBudWxsO1xudmFyIE5fU0FNUExFUyA9IDM7XG52YXIgU0FNUExFX0hFSUdIVCA9IDUwO1xudmFyIFNBTVBMRV9JTlRFUlZBTF9NUyA9IDI1MDtcbnZhciBTQU1QTEVfV0lEVEggPSA1MDtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgY3VycmVudCB2aWRlbyBmcmFtZSBpcyBzaWxlbnQgYnkgc2VsZWN0aW5nIGEgNTB4NTBcbiAqIHNhbXBsZSBhbmQgY2FsY3VsYXRpbmcgdGhlIG1heCB2YWx1ZSBvZiB0aGUgcGl4ZWwgZGF0YS4gSWYgaXQgaXMgMCwgdGhlblxuICogdGhlIGZyYW1lIGlzIGNvbnNpZGVyZWQgdG8gYmUgc2lsZW50LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudH0gZWxcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHNpbGVudCwgZmFsc2UgaWYgbm90XG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2lsZW5jZShlbCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGVsLCAwLCAwLCBTQU1QTEVfV0lEVEgsIFNBTVBMRV9IRUlHSFQpO1xuICAgICAgICB2YXIgZnJhbWUgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBTQU1QTEVfV0lEVEgsIFNBTVBMRV9IRUlHSFQpO1xuICAgICAgICB2YXIgZnJhbWVEYXRhV2l0aG91dEFscGhhID0gZnJhbWUuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGkpIHsgcmV0dXJuIChpICsgMSkgJSA0OyB9KTtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGZyYW1lRGF0YVdpdGhvdXRBbHBoYSk7XG4gICAgICAgIHJldHVybiBtYXggPT09IDA7XG4gICAgfVxuICAgIGNhdGNoIChleCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgY2hlY2tpbmcgc2lsZW5jZTogJywgZXgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlY3Qgd2hldGhlciB0aGUgdmlkZW8gc3RyZWFtIHJlbmRlcmVkIGJ5IHRoZSBnaXZlbiBIVE1MVmlkZW9FbGVtZW50IGlzIHNpbGVudC5cbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudH0gZWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSB0cnVlIGlmIHNpbGVudCwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBkZXRlY3RTaWxlbnRWaWRlbyhlbCkge1xuICAgIC8vIENyZWF0ZSB0aGUgY2FudmFzIHdoZW4gZGV0ZWN0U2lsZW50VmlkZW8oKSBpcyBjYWxsZWQgZm9yIHRoZVxuICAgIC8vIGZpcnN0IHRpbWUuXG4gICAgY2FudmFzID0gY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIC8vIFJlc29sdmUgdGhlIHJldHVybmVkIFByb21pc2Ugd2l0aCB0cnVlIGlmIDMgY29uc2VjdXRpdmUgc2FtcGxlXG4gICAgLy8gZnJhbWVzIGZyb20gdGhlIHZpZGVvIGJlaW5nIHBsYXllZCBieSB0aGUgSFRNTFZpZGVvRWxlbWVudCBhcmVcbiAgICAvLyBzaWxlbnQuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciBzYW1wbGVzTGVmdCA9IE5fU0FNUExFUztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiBkb0NoZWNrU2lsZW5jZSgpIHtcbiAgICAgICAgICAgIHNhbXBsZXNMZWZ0LS07XG4gICAgICAgICAgICBpZiAoIWNoZWNrU2lsZW5jZShlbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2FtcGxlc0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZG9DaGVja1NpbGVuY2UsIFNBTVBMRV9JTlRFUlZBTF9NUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfSwgU0FNUExFX0lOVEVSVkFMX01TKTtcbiAgICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZGV0ZWN0U2lsZW50VmlkZW87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3RzaWxlbnR2aWRlby5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIFRoZSB7QGxpbmsgRG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvcn0gbW9uaXRvcnMgdGhlIHZpc2liaWxpdHkgc3RhdGUgb2YgdGhlIERPTVxuICogYW5kIGV4ZWN1dGVzIHRoZSBhdHRhY2hlZCBsaXN0ZW5lcnMgaW4gcGhhc2Ugb3JkZXIgd2hlbiB0aGUgRE9NIGlzIHZpc2libGUuXG4gKi9cbnZhciBEb2N1bWVudFZpc2liaWxpdHlNb25pdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbblBoYXNlcz0xXSAtIHRoZSBudW1iZXIgb2YgcGhhc2VzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvcihuUGhhc2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChuUGhhc2VzID09PSB2b2lkIDApIHsgblBoYXNlcyA9IDE7IH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgX2xpc3RlbmVyczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblZpc2liaWxpdHlDaGFuZ2U6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZW1pdFZpc2libGUoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBoYXNlczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogY2xlYXJzIHRoZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudFZpc2liaWxpdHlNb25pdG9yLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5QaGFzZXMgPSB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QaGFzZXM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2ldID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvY3VtZW50VmlzaWJpbGl0eU1vbml0b3IucHJvdG90eXBlLl9saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIHBoYXNlTGlzdGVuZXJzKSB7IHJldHVybiBjb3VudCArIHBoYXNlTGlzdGVuZXJzLmxlbmd0aDsgfSwgMCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsIGFsbCB0aGUgbGlzdGVuZXJzLiBNYWtlcyBzdXJlIHRoYXQgYWxsIGxpc3RlbmVycyBmb3IgYSBnaXZlbiBwaGFzZVxuICAgICAqIGFyZSBleGVjdXRlZCBiZWZvcmUgY2FsbGluZyB0aGUgbGlzdGVuZXJzIG9mIHRoZSBuZXh0IHBoYXNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvci5wcm90b3R5cGUuX2VtaXRWaXNpYmxlID0gZnVuY3Rpb24gKGlzVmlzaWJsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChwaGFzZSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZW1pdFZpc2libGVQaGFzZShwaGFzZSwgaXNWaXNpYmxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIHBoYXNlID0gMTsgcGhhc2UgPD0gdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDsgcGhhc2UrKykge1xuICAgICAgICAgICAgX2xvb3BfMShwaGFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsIGFsbCB0aGUgbGlzdGVuZXJzIGZvciBhIGdpdmVuIHBoYXNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvci5wcm90b3R5cGUuX2VtaXRWaXNpYmxlUGhhc2UgPSBmdW5jdGlvbiAocGhhc2UsIGlzVmlzaWJsZSkge1xuICAgICAgICB2YXIgcGhhc2VMaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbcGhhc2UgLSAxXTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBoYXNlTGlzdGVuZXJzLm1hcChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBsaXN0ZW5lcihpc1Zpc2libGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJldCBpbnN0YW5jZW9mIFByb21pc2UgPyByZXQgOiBQcm9taXNlLnJlc29sdmUocmV0KTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnQgbGlzdGVuaW5nIHRvIHRoZSBET00gdmlzaWJpbGl0eSBzdGF0ZSBjaGFuZ2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEb2N1bWVudFZpc2liaWxpdHlNb25pdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcCBsaXN0ZW5pbmcgdG8gdGhlIERPTSB2aXNpYmlsaXR5IHN0YXRlIGNoYW5nZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERvY3VtZW50VmlzaWJpbGl0eU1vbml0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgdGhlIERPTSB2aXNpYmlsaXR5IGNoYW5nZXMgYXQgdGhlIGdpdmVuIHBoYXNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaGFzZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgRG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvci5wcm90b3R5cGUub25WaXNpYmlsaXR5Q2hhbmdlID0gZnVuY3Rpb24gKHBoYXNlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodHlwZW9mIHBoYXNlICE9PSAnbnVtYmVyJyB8fCBwaGFzZSA8PSAwIHx8IHBoYXNlID4gdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBoYXNlOiAnLCBwaGFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBoYXNlTGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3BoYXNlIC0gMV07XG4gICAgICAgIHBoYXNlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJDb3VudCgpID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcCBsaXN0ZW5pbmcgZm9yIHRoZSBET00gdmlzaWJpbGl0eSBjaGFuZ2UgYXQgdGhlIGdpdmVuIHBoYXNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaGFzZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgRG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvci5wcm90b3R5cGUub2ZmVmlzaWJpbGl0eUNoYW5nZSA9IGZ1bmN0aW9uIChwaGFzZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwaGFzZSAhPT0gJ251bWJlcicgfHwgcGhhc2UgPD0gMCB8fCBwaGFzZSA+IHRoaXMuX2xpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwaGFzZTogJywgcGhhc2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwaGFzZUxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1twaGFzZSAtIDFdO1xuICAgICAgICB2YXIgaW5kZXggPSBwaGFzZUxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgcGhhc2VMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saXN0ZW5lckNvdW50KCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gRG9jdW1lbnRWaXNpYmlsaXR5TW9uaXRvcjtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBEb2N1bWVudFZpc2liaWxpdHlNb25pdG9yKDIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9jdW1lbnR2aXNpYmlsaXR5bW9uaXRvci5qcy5tYXAiLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBWQUxJRF9HUk9VUFMgPSBbXG4gICAgJ3NpZ25hbGluZycsXG4gICAgJ3Jvb20nLFxuICAgICdtZWRpYScsXG4gICAgJ3F1YWxpdHknLFxuICAgICd2aWRlby1wcm9jZXNzb3InXG5dO1xudmFyIFZBTElEX0xFVkVMUyA9IFtcbiAgICAnZGVidWcnLFxuICAgICdlcnJvcicsXG4gICAgJ2luZm8nLFxuICAgICd3YXJuaW5nJ1xuXTtcbi8qKlxuICogRXZlbnRPYnNlcnZlciBsaXN0ZW5zIHRvIFNESyBldmVudHMgYW5kIHJlLWVtaXRzIHRoZW0gb24gdGhlXG4gKiBAbGluayBFdmVudExpc3RlbmVyfSB3aXRoIHNvbWUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQGVtaXRzIEV2ZW50T2JzZXJ2ZXIjZXZlbnRcbiAqL1xudmFyIEV2ZW50T2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV2ZW50T2JzZXJ2ZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbm5lY3RUaW1lc3RhbXBcbiAgICAgKiBAcGFyYW0ge0xvZ30gbG9nXG4gICAgICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBbZXZlbnRMaXN0ZW5lcl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFdmVudE9ic2VydmVyKGNvbm5lY3RUaW1lc3RhbXAsIGxvZywgZXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBpZiAoZXZlbnRMaXN0ZW5lciA9PT0gdm9pZCAwKSB7IGV2ZW50TGlzdGVuZXIgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzLCB7XG4gICAgICAgICAgICBfcHVibGlzaGVyOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uKCdldmVudCcsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCBncm91cCA9IF9hLmdyb3VwLCBsZXZlbCA9IF9hLmxldmVsLCBwYXlsb2FkID0gX2EucGF5bG9hZDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgbmFtZTogJywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVZBTElEX0dST1VQUy5pbmNsdWRlcyhncm91cCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZ3JvdXA6ICcsIGdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghVkFMSURfTEVWRUxTLmluY2x1ZGVzKGxldmVsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBsZXZlbDogJywgbGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSB0aW1lc3RhbXAgLSBjb25uZWN0VGltZXN0YW1wO1xuICAgICAgICAgICAgaWYgKF90aGlzLl9wdWJsaXNoZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHVibGlzaGVyUGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oeyBlbGFwc2VkVGltZTogZWxhcHNlZFRpbWUsIGxldmVsOiBsZXZlbCB9LCBwYXlsb2FkID8gcGF5bG9hZCA6IHt9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHVibGlzaGVyLnB1Ymxpc2goZ3JvdXAsIG5hbWUsIHB1Ymxpc2hlclBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV2ZW50ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgZWxhcHNlZFRpbWU6IGVsYXBzZWRUaW1lLFxuICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cCxcbiAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcFxuICAgICAgICAgICAgfSwgcGF5bG9hZCA/IHsgcGF5bG9hZDogcGF5bG9hZCB9IDoge30pO1xuICAgICAgICAgICAgdmFyIGxvZ0xldmVsID0ge1xuICAgICAgICAgICAgICAgIGRlYnVnOiAnZGVidWcnLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGluZm86ICdpbmZvJyxcbiAgICAgICAgICAgICAgICB3YXJuaW5nOiAnd2FybicsXG4gICAgICAgICAgICB9W2xldmVsXTtcbiAgICAgICAgICAgIGxvZ1tsb2dMZXZlbF0oJ2V2ZW50JywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKGV2ZW50TGlzdGVuZXIgJiYgZ3JvdXAgPT09ICdzaWduYWxpbmcnKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lci5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0cyB0aGUgcHVibGlzaGVyIG9iamVjdC4gT25jZSBzZXQgZXZlbnRzIHdpbGwgYmUgc2VudCB0byBwdWJsaXNoZXIuXG4gICAgICogQHBhcmFtIHtJbnNpZ2h0c1B1Ymxpc2hlcn0gcHVibGlzaGVyXG4gICAgKi9cbiAgICBFdmVudE9ic2VydmVyLnByb3RvdHlwZS5zZXRQdWJsaXNoZXIgPSBmdW5jdGlvbiAocHVibGlzaGVyKSB7XG4gICAgICAgIHRoaXMuX3B1Ymxpc2hlciA9IHB1Ymxpc2hlcjtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudE9ic2VydmVyO1xufShFdmVudEVtaXR0ZXIpKTtcbi8qKlxuICogQW4gU0RLIGV2ZW50LlxuICogQGV2ZW50IEV2ZW50T2JzZXJ2ZXIjZXZlbnRcbiAqIEBwYXJhbSB7e25hbWU6IHN0cmluZywgcGF5bG9hZDogKn19IGV2ZW50XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRPYnNlcnZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50b2JzZXJ2ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEZpbHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWx0ZXIob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBnZXRLZXk6IGZ1bmN0aW9uIGRlZmF1bHRHZXRLZXkoYSkgeyByZXR1cm4gYTsgfSxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0R2V0VmFsdWUoYSkgeyByZXR1cm4gYTsgfSxcbiAgICAgICAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG86IGZ1bmN0aW9uIGRlZmF1bHRJc0xlc3NUaGFuT3JFcXVhbFRvKGEsIGIpIHsgcmV0dXJuIGEgPD0gYjsgfVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgX2dldEtleToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmdldEtleVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRWYWx1ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmdldFZhbHVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzTGVzc1RoYW5PckVxdWFsVG86IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5pc0xlc3NUaGFuT3JFcXVhbFRvXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21hcDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIEZpbHRlci5wcm90b3R5cGUudG9NYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKHRoaXMuX21hcCk7XG4gICAgfTtcbiAgICBGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZUFuZEZpbHRlciA9IGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgIHJldHVybiBlbnRyaWVzLmZpbHRlcih0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgfTtcbiAgICBGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5fZ2V0S2V5KGVudHJ5KTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0VmFsdWUoZW50cnkpO1xuICAgICAgICBpZiAodGhpcy5fbWFwLmhhcyhrZXkpICYmXG4gICAgICAgICAgICB0aGlzLl9pc0xlc3NUaGFuT3JFcXVhbFRvKHZhbHVlLCB0aGlzLl9tYXAuZ2V0KGtleSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICByZXR1cm4gdG87XG59O1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG52YXIgRSA9IGNvbnN0YW50cy50eXBlRXJyb3JzLCB0cmFja1ByaW9yaXR5ID0gY29uc3RhbnRzLnRyYWNrUHJpb3JpdHk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ0B0d2lsaW8vd2VicnRjL2xpYi91dGlsJyk7XG4vKipcbiAqIFJldHVybiB0aGUgZ2l2ZW4ge0BsaW5rIExvY2FsVHJhY2t9IG9yIGEgbmV3IHtAbGluayBMb2NhbFRyYWNrfSBmb3IgdGhlXG4gKiBnaXZlbiBNZWRpYVN0cmVhbVRyYWNrLlxuICogQHBhcmFtIHtMb2NhbFRyYWNrfE1lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge0xvY2FsVHJhY2t9XG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGFzTG9jYWxUcmFjayh0cmFjaywgb3B0aW9ucykge1xuICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIG9wdGlvbnMuTG9jYWxBdWRpb1RyYWNrXG4gICAgICAgIHx8IHRyYWNrIGluc3RhbmNlb2Ygb3B0aW9ucy5Mb2NhbFZpZGVvVHJhY2tcbiAgICAgICAgfHwgdHJhY2sgaW5zdGFuY2VvZiBvcHRpb25zLkxvY2FsRGF0YVRyYWNrKSB7XG4gICAgICAgIHJldHVybiB0cmFjaztcbiAgICB9XG4gICAgaWYgKHRyYWNrIGluc3RhbmNlb2Ygb3B0aW9ucy5NZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIHJldHVybiB0cmFjay5raW5kID09PSAnYXVkaW8nXG4gICAgICAgICAgICA/IG5ldyBvcHRpb25zLkxvY2FsQXVkaW9UcmFjayh0cmFjaywgb3B0aW9ucylcbiAgICAgICAgICAgIDogbmV3IG9wdGlvbnMuTG9jYWxWaWRlb1RyYWNrKHRyYWNrLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyogZXNsaW50IG5ldy1jYXA6MCAqL1xuICAgIHRocm93IEUuSU5WQUxJRF9UWVBFKCd0cmFjaycsICdMb2NhbEF1ZGlvVHJhY2ssIExvY2FsVmlkZW9UcmFjaywgTG9jYWxEYXRhVHJhY2ssIG9yIE1lZGlhU3RyZWFtVHJhY2snKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHtAbGluayBMb2NhbFRyYWNrUHVibGljYXRpb259IGZvciB0aGUgZ2l2ZW4ge0BsaW5rIExvY2FsVHJhY2t9LlxuICogQHBhcmFtIHtMb2NhbFRyYWNrfSB0cmFja1xuICogQHBhcmFtIHtMb2NhbFRyYWNrUHVibGljYXRpb25TaWduYWxpbmd9IHNpZ25hbGluZ1xuICogQHBhcmFtIHtmdW5jdGlvbih0cmFjazogTG9jYWxUcmFja1B1YmxpY2F0aW9uKTogdm9pZH0gdW5wdWJsaXNoXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhc0xvY2FsVHJhY2tQdWJsaWNhdGlvbih0cmFjaywgc2lnbmFsaW5nLCB1bnB1Ymxpc2gsIG9wdGlvbnMpIHtcbiAgICB2YXIgTG9jYWxUcmFja1B1YmxpY2F0aW9uID0ge1xuICAgICAgICBhdWRpbzogb3B0aW9ucy5Mb2NhbEF1ZGlvVHJhY2tQdWJsaWNhdGlvbixcbiAgICAgICAgdmlkZW86IG9wdGlvbnMuTG9jYWxWaWRlb1RyYWNrUHVibGljYXRpb24sXG4gICAgICAgIGRhdGE6IG9wdGlvbnMuTG9jYWxEYXRhVHJhY2tQdWJsaWNhdGlvblxuICAgIH1bdHJhY2sua2luZF07XG4gICAgcmV0dXJuIG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24oc2lnbmFsaW5nLCB0cmFjaywgdW5wdWJsaXNoLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHdvcmQuXG4gKiBAcGFyYW0ge3N0cmluZ30gd29yZFxuICogQHJldHVybnMge3N0cmluZ30gY2FwaXRhbGl6ZWRcbiAqL1xuZnVuY3Rpb24gY2FwaXRhbGl6ZSh3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmRbMF0udG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSk7XG59XG4vKipcbiAqIExvZyBkZXByZWNhdGlvbiB3YXJuaW5ncyBmb3IgdGhlIGdpdmVuIGV2ZW50cyBvZiBhbiBFdmVudEVtaXR0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXJcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgc3RyaW5nPn0gZXZlbnRzXG4gKiBAcGFyYW0ge0xvZ30gbG9nXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZUV2ZW50cyhuYW1lLCBlbWl0dGVyLCBldmVudHMsIGxvZykge1xuICAgIHZhciB3YXJuaW5nc1Nob3duID0gbmV3IFNldCgpO1xuICAgIGVtaXR0ZXIub24oJ25ld0xpc3RlbmVyJywgZnVuY3Rpb24gbmV3TGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50cy5oYXMoZXZlbnQpICYmICF3YXJuaW5nc1Nob3duLmhhcyhldmVudCkpIHtcbiAgICAgICAgICAgIGxvZy5kZXByZWNhdGVkKG5hbWUgKyBcIiNcIiArIGV2ZW50ICsgXCIgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgc2NoZWR1bGVkIGZvciByZW1vdmFsIGluIHR3aWxpby12aWRlby5qc0AyLjAuMC5cIiArIChldmVudHMuZ2V0KGV2ZW50KVxuICAgICAgICAgICAgICAgID8gXCIgVXNlIFwiICsgbmFtZSArIFwiI1wiICsgZXZlbnRzLmdldChldmVudCkgKyBcIiBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICAgOiAnJykpO1xuICAgICAgICAgICAgd2FybmluZ3NTaG93bi5hZGQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3YXJuaW5nc1Nob3duLnNpemUgPj0gZXZlbnRzLnNpemUpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ25ld0xpc3RlbmVyJywgbmV3TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIEZpbmRzIHRoZSBpdGVtcyBpbiBsaXN0MSB0aGF0IGFyZSBub3QgaW4gbGlzdDIuXG4gKiBAcGFyYW0ge0FycmF5PCo+fE1hcDwqPnxTZXQ8Kj59IGxpc3QxXG4gKiBAcGFyYW0ge0FycmF5PCo+fE1hcDwqPnxTZXQ8Kj59IGxpc3QyXG4gKiBAcmV0dXJucyB7U2V0fVxuICovXG5mdW5jdGlvbiBkaWZmZXJlbmNlKGxpc3QxLCBsaXN0Mikge1xuICAgIGxpc3QxID0gQXJyYXkuaXNBcnJheShsaXN0MSkgPyBuZXcgU2V0KGxpc3QxKSA6IG5ldyBTZXQobGlzdDEudmFsdWVzKCkpO1xuICAgIGxpc3QyID0gQXJyYXkuaXNBcnJheShsaXN0MikgPyBuZXcgU2V0KGxpc3QyKSA6IG5ldyBTZXQobGlzdDIudmFsdWVzKCkpO1xuICAgIHZhciBkaWZmZXJlbmNlID0gbmV3IFNldCgpO1xuICAgIGxpc3QxLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFsaXN0Mi5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgIGRpZmZlcmVuY2UuYWRkKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRpZmZlcmVuY2U7XG59XG4vKipcbiAqIEZpbHRlciBvdXQgdGhlIGtleXMgaW4gYW4gb2JqZWN0IHdpdGggYSBnaXZlbiB2YWx1ZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgLSBPYmplY3QgdG8gYmUgZmlsdGVyZWRcbiAqIEBwYXJhbSB7Kn0gW2ZpbHRlclZhbHVlXSAtIFZhbHVlIHRvIGJlIGZpbHRlcmVkIG91dDsgSWYgbm90IHNwZWNpZmllZCwgdGhlblxuICogICBmaWx0ZXJzIG91dCBhbGwga2V5cyB3aGljaCBoYXZlIGFuIGV4cGxpY2l0IHZhbHVlIG9mIFwidW5kZWZpbmVkXCJcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gRmlsdGVyZWQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGZpbHRlck9iamVjdChvYmplY3QsIGZpbHRlclZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkucmVkdWNlKGZ1bmN0aW9uIChmaWx0ZXJlZCwga2V5KSB7XG4gICAgICAgIGlmIChvYmplY3Rba2V5XSAhPT0gZmlsdGVyVmFsdWUpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiBNYXAgYSBsaXN0IHRvIGFuIGFycmF5IG9mIGFycmF5cywgYW5kIHJldHVybiB0aGUgZmxhdHRlbmVkIHJlc3VsdC5cbiAqIEBwYXJhbSB7QXJyYXk8Kj58U2V0PCo+fE1hcDwqPn0gbGlzdFxuICogQHBhcmFtIHtmdW5jdGlvbigqKTogQXJyYXk8Kj59IFttYXBGbl1cbiAqIEByZXR1cm5zIEFycmF5PCo+XG4gKi9cbmZ1bmN0aW9uIGZsYXRNYXAobGlzdCwgbWFwRm4pIHtcbiAgICB2YXIgbGlzdEFycmF5ID0gbGlzdCBpbnN0YW5jZW9mIE1hcCB8fCBsaXN0IGluc3RhbmNlb2YgU2V0XG4gICAgICAgID8gQXJyYXkuZnJvbShsaXN0LnZhbHVlcygpKVxuICAgICAgICA6IGxpc3Q7XG4gICAgbWFwRm4gPSBtYXBGbiB8fCBmdW5jdGlvbiBtYXBGbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG4gICAgcmV0dXJuIGxpc3RBcnJheS5yZWR1Y2UoZnVuY3Rpb24gKGZsYXR0ZW5lZCwgaXRlbSkge1xuICAgICAgICB2YXIgbWFwcGVkID0gbWFwRm4oaXRlbSk7XG4gICAgICAgIHJldHVybiBmbGF0dGVuZWQuY29uY2F0KG1hcHBlZCk7XG4gICAgfSwgW10pO1xufVxuLyoqXG4gKiBHZXQgdGhlIHVzZXIgYWdlbnQgc3RyaW5nLCBvciByZXR1cm4gXCJVbmtub3duXCIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnRcbiAgICAgICAgPyBuYXZpZ2F0b3IudXNlckFnZW50XG4gICAgICAgIDogJ1Vua25vd24nO1xufVxuLyoqXG4gKiBHZXQgdGhlIHBsYXRmb3JtIGNvbXBvbmVudCBvZiB0aGUgdXNlciBhZ2VudCBzdHJpbmcuXG4gKiBFeGFtcGxlOlxuICogICBJbnB1dCAtIE1vemlsbGEvNS4wIChNYWNpbnRvc2g7IEludGVsIE1hYyBPUyBYIDEwXzE0XzYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS84OS4wLjQzODkuODIgU2FmYXJpLzUzNy4zNlxuICogICBPdXRwdXQgLSBtYWNpbnRvc2hcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICAgIHZhciB1c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnQoKTtcbiAgICB2YXIgX2EgPSBfX3JlYWQodXNlckFnZW50Lm1hdGNoKC9cXCgoW14pXSspXFwpLykgfHwgW10sIDIpLCBfYiA9IF9hWzFdLCBtYXRjaCA9IF9iID09PSB2b2lkIDAgPyAndW5rbm93bicgOiBfYjtcbiAgICB2YXIgX2MgPSBfX3JlYWQobWF0Y2guc3BsaXQoJzsnKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS50cmltKCk7IH0pLCAxKSwgcGxhdGZvcm0gPSBfY1swXTtcbiAgICByZXR1cm4gcGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgdW5pcXVlIGlkZW50aWZpZXIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBtYWtlVVVJRCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgICAgIHZhciB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCB0aGUgZ2l2ZW4gZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgcGVyIHRpY2suXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIEZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IC0gU2NoZWR1bGVzIHRoZSBnaXZlbiBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gdGhlIG5leHQgdGlja1xuICovXG5mdW5jdGlvbiBvbmNlUGVyVGljayhmbikge1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICBmdW5jdGlvbiBuZXh0VGljaygpIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGZuKCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBzY2hlZHVsZU5leHRUaWNrKCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG5leHRUaWNrKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcHJvbWlzZUZyb21FdmVudHMob3BlcmF0aW9uLCBldmVudEVtaXR0ZXIsIHN1Y2Nlc3NFdmVudCwgZmFpbHVyZUV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGZhaWx1cmVFdmVudCwgb25GYWlsdXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncykpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbkZhaWx1cmUoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lcihzdWNjZXNzRXZlbnQsIG9uU3VjY2Vzcyk7XG4gICAgICAgICAgICByZWplY3QuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncykpKTtcbiAgICAgICAgfVxuICAgICAgICBldmVudEVtaXR0ZXIub25jZShzdWNjZXNzRXZlbnQsIG9uU3VjY2Vzcyk7XG4gICAgICAgIGlmIChmYWlsdXJlRXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlci5vbmNlKGZhaWx1cmVFdmVudCwgb25GYWlsdXJlKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVyYXRpb24oKTtcbiAgICB9KTtcbn1cbi8qKlxuICogVHJhdmVyc2UgZG93biBtdWx0aXBsZSBub2RlcyBvbiBhbiBvYmplY3QgYW5kIHJldHVybiBudWxsIGlmXG4gKiBhbnkgbGluayBpbiB0aGUgcGF0aCBpcyB1bmF2YWlsYWJsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBPYmplY3QgdG8gdHJhdmVyc2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gUGF0aCB0byB0cmF2ZXJzZS4gUGVyaW9kLXNlcGFyYXRlZC5cbiAqIEByZXR1cm5zIHtBbnl8bnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0T3JOdWxsKG9iaiwgcGF0aCkge1xuICAgIHJldHVybiBwYXRoLnNwbGl0KCcuJykucmVkdWNlKGZ1bmN0aW9uIChvdXRwdXQsIHN0ZXApIHtcbiAgICAgICAgaWYgKCFvdXRwdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXRbc3RlcF07XG4gICAgfSwgb2JqKTtcbn1cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gRGVmZXJyZWRcbiAqIEBwcm9wZXJ0eSB7UHJvbWlzZX0gcHJvbWlzZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcmVqZWN0XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSByZXNvbHZlXG4gKi9cbi8qKlxuICogQ3JlYXRlIGEge0BsaW5rIERlZmVycmVkfS5cbiAqIEByZXR1cm5zIHtEZWZlcnJlZH1cbiAqL1xuZnVuY3Rpb24gZGVmZXIoKSB7XG4gICAgdmFyIGRlZmVycmVkID0ge307XG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59XG4vKipcbiAqIENvcHkgYSBtZXRob2QgZnJvbSBhIGBzb3VyY2VgIHByb3RvdHlwZSBvbnRvIGEgYHdyYXBwZXJgIHByb3RvdHlwZS4gSW52b2tpbmdcbiAqIHRoZSBtZXRob2Qgb24gdGhlIGB3cmFwcGVyYCBwcm90b3R5cGUgd2lsbCBpbnZva2UgdGhlIGNvcnJlc3BvbmRpbmcgbWV0aG9kXG4gKiBvbiBhbiBpbnN0YW5jZSBhY2Nlc3NlZCBieSBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSB3cmFwcGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZGVsZWdhdGVNZXRob2Qoc291cmNlLCB3cmFwcGVyLCB0YXJnZXQsIG1ldGhvZE5hbWUpIHtcbiAgICBpZiAobWV0aG9kTmFtZSBpbiB3cmFwcGVyKSB7XG4gICAgICAgIC8vIFNraXAgYW55IG1ldGhvZHMgYWxyZWFkeSBzZXQuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0aG9kTmFtZS5tYXRjaCgvXm9uW2Etel0rJC8pKSB7XG4gICAgICAgIC8vIFNraXAgRXZlbnRIYW5kbGVycyAodGhlc2UgYXJlIGhhbmRsZWQgaW4gdGhlIGNvbnN0cnVjdG9yKS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdHlwZTtcbiAgICB0cnkge1xuICAgICAgICB0eXBlID0gdHlwZW9mIHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIE5PVEUobXJvYmVydHMpOiBBdHRlbXB0aW5nIHRvIGNoZWNrIHRoZSB0eXBlIG9mIG5vbi1mdW5jdGlvbiBtZW1iZXJzXG4gICAgICAgIC8vIG9uIHRoZSBwcm90b3R5cGUgdGhyb3dzIGFuIGVycm9yIGZvciBzb21lIHR5cGVzLlxuICAgIH1cbiAgICBpZiAodHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBTa2lwIG5vbi1mdW5jdGlvbiBtZW1iZXJzLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIGVzbGludCBuby1sb29wLWZ1bmM6MCAqL1xuICAgIHdyYXBwZXJbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9hID0gdGhpc1t0YXJnZXRdKVttZXRob2ROYW1lXS5hcHBseShfYSwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpKSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ29weSBtZXRob2RzIGZyb20gYSBgc291cmNlYCBwcm90b3R5cGUgb250byBhIGB3cmFwcGVyYCBwcm90b3R5cGUuIEludm9raW5nXG4gKiB0aGUgbWV0aG9kcyBvbiB0aGUgYHdyYXBwZXJgIHByb3RvdHlwZSB3aWxsIGludm9rZSB0aGUgY29ycmVzcG9uZGluZyBtZXRob2RcbiAqIG9uIGFuIGluc3RhbmNlIGFjY2Vzc2VkIGJ5IGB0YXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZVxuICogQHBhcmFtIHtvYmplY3R9IHdyYXBwZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGRlbGVnYXRlTWV0aG9kcyhzb3VyY2UsIHdyYXBwZXIsIHRhcmdldCkge1xuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gc291cmNlKSB7XG4gICAgICAgIGRlbGVnYXRlTWV0aG9kKHNvdXJjZSwgd3JhcHBlciwgdGFyZ2V0LCBtZXRob2ROYW1lKTtcbiAgICB9XG59XG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHR3byB2YWx1ZXMgYXJlIGRlZXBseSBlcXVhbC5cbiAqIEBwYXJhbSB7Kn0gdmFsMVxuICogQHBhcmFtIHsqfSB2YWwyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEZWVwRXF1YWwodmFsMSwgdmFsMikge1xuICAgIGlmICh2YWwxID09PSB2YWwyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbDEgIT09IHR5cGVvZiB2YWwyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbDEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDIgPT09IG51bGw7XG4gICAgfVxuICAgIGlmICh2YWwyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsMSkpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsMilcbiAgICAgICAgICAgICYmIHZhbDEubGVuZ3RoID09PSB2YWwyLmxlbmd0aFxuICAgICAgICAgICAgJiYgdmFsMS5ldmVyeShmdW5jdGlvbiAodmFsLCBpKSB7IHJldHVybiBpc0RlZXBFcXVhbCh2YWwsIHZhbDJbaV0pOyB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWwxID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgdmFsMUtleXMgPSBPYmplY3Qua2V5cyh2YWwxKS5zb3J0KCk7XG4gICAgICAgIHZhciB2YWwyS2V5cyA9IE9iamVjdC5rZXlzKHZhbDIpLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHZhbDIpXG4gICAgICAgICAgICAmJiBpc0RlZXBFcXVhbCh2YWwxS2V5cywgdmFsMktleXMpXG4gICAgICAgICAgICAmJiB2YWwxS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBpc0RlZXBFcXVhbCh2YWwxW2tleV0sIHZhbDJba2V5XSk7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIGEgbm9uLWFycmF5IG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc05vbkFycmF5T2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmplY3QpO1xufVxuLyoqXG4gKiBGb3IgZWFjaCBwcm9wZXJ0eSBuYW1lIG9uIHRoZSBgc291cmNlYCBwcm90b3R5cGUsIGFkZCBnZXR0ZXJzIGFuZC9vciBzZXR0ZXJzXG4gKiB0byBgd3JhcHBlcmAgdGhhdCBwcm94eSB0byBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSB3cmFwcGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBwcm94eVByb3BlcnRpZXMoc291cmNlLCB3cmFwcGVyLCB0YXJnZXQpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgICAgICBwcm94eVByb3BlcnR5KHNvdXJjZSwgd3JhcHBlciwgdGFyZ2V0LCBwcm9wZXJ0eU5hbWUpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBGb3IgdGhlIHByb3BlcnR5IG5hbWUgb24gdGhlIGBzb3VyY2VgIHByb3RvdHlwZSwgYWRkIGEgZ2V0dGVyIGFuZC9vciBzZXR0ZXJcbiAqIHRvIGB3cmFwcGVyYCB0aGF0IHByb3hpZXMgdG8gYHRhcmdldGAuXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlXG4gKiBAcGFyYW0ge29iamVjdH0gd3JhcHBlclxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gcHJveHlQcm9wZXJ0eShzb3VyY2UsIHdyYXBwZXIsIHRhcmdldCwgcHJvcGVydHlOYW1lKSB7XG4gICAgaWYgKHByb3BlcnR5TmFtZSBpbiB3cmFwcGVyKSB7XG4gICAgICAgIC8vIFNraXAgYW55IHByb3BlcnRpZXMgYWxyZWFkeSBzZXQuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvcGVydHlOYW1lLm1hdGNoKC9eb25bYS16XSskLykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdyYXBwZXIsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIocHJvcGVydHlOYW1lLnNsaWNlKDIpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cmFwcGVyLmRpc3BhdGNoRXZlbnQuYXBwbHkod3JhcHBlciwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cmFwcGVyLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5TmFtZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogVGhpcyBpcyBhIGZ1bmN0aW9uIGZvciB0dXJuaW5nIGEgUHJvbWlzZSBpbnRvIHRoZSBraW5kIHJlZmVyZW5jZWQgaW4gdGhlXG4gKiBMZWdhY3kgSW50ZXJmYWNlIEV4dGVuc2lvbnMgc2VjdGlvbiBvZiB0aGUgV2ViUlRDIHNwZWMuXG4gKiBAcGFyYW0ge1Byb21pc2U8Kj59IHByb21pc2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb248Kj59IG9uU3VjY2Vzc1xuICogQHBhcmFtIHtmdW5jdGlvbjxFcnJvcj59IG9uRmFpbHVyZVxuICogQHJldHVybnMge1Byb21pc2U8dW5kZWZpbmVkPn1cbiAqL1xuZnVuY3Rpb24gbGVnYWN5UHJvbWlzZShwcm9taXNlLCBvblN1Y2Nlc3MsIG9uRmFpbHVyZSkge1xuICAgIGlmIChvblN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBvblN1Y2Nlc3MocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBvbkZhaWx1cmUoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG4vKipcbiAqIEJ1aWxkIHRoZSB7QGxpbmsgTG9nTGV2ZWxzfSBvYmplY3QuXG4gKiBAcGFyYW0ge1N0cmluZ3xMb2dMZXZlbH0gbG9nTGV2ZWwgLSBMb2cgbGV2ZWwgbmFtZSBvciBvYmplY3RcbiAqIEByZXR1cm5zIHtMb2dMZXZlbHN9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTG9nTGV2ZWxzKGxvZ0xldmVsKSB7XG4gICAgaWYgKHR5cGVvZiBsb2dMZXZlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IGxvZ0xldmVsLFxuICAgICAgICAgICAgbWVkaWE6IGxvZ0xldmVsLFxuICAgICAgICAgICAgc2lnbmFsaW5nOiBsb2dMZXZlbCxcbiAgICAgICAgICAgIHdlYnJ0YzogbG9nTGV2ZWxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ0xldmVsO1xufVxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBUcmFja30ncyBkZXJpdmVkIGNsYXNzIG5hbWVcbiAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrXG4gKiBAcGFyYW0gez9ib29sZWFufSBbbG9jYWw9dW5kZWZpbmVkXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdHJhY2tDbGFzcyh0cmFjaywgbG9jYWwpIHtcbiAgICBsb2NhbCA9IGxvY2FsID8gJ0xvY2FsJyA6ICcnO1xuICAgIHJldHVybiBsb2NhbCArICh0cmFjay5raW5kIHx8ICcnKS5yZXBsYWNlKC9cXHd7MX0vLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbS50b1VwcGVyQ2FzZSgpOyB9KSArIFwiVHJhY2tcIjtcbn1cbi8qKlxuICogR2V0IHRoZSB7QGxpbmsgVHJhY2tQdWJsaWNhdGlvbn0ncyBkZXJpdmVkIGNsYXNzIG5hbWVcbiAqIEBwYXJhbSB7VHJhY2tQdWJsaWNhdGlvbn0gcHVibGljYXRpb25cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IFtsb2NhbD11bmRlZmluZWRdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0cmFja1B1YmxpY2F0aW9uQ2xhc3MocHVibGljYXRpb24sIGxvY2FsKSB7XG4gICAgbG9jYWwgPSBsb2NhbCA/ICdMb2NhbCcgOiAnJztcbiAgICByZXR1cm4gbG9jYWwgKyAocHVibGljYXRpb24ua2luZCB8fCAnJykucmVwbGFjZSgvXFx3ezF9LywgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0udG9VcHBlckNhc2UoKTsgfSkgKyBcIlRyYWNrUHVibGljYXRpb25cIjtcbn1cbi8qKlxuICogU2V0cyBhbGwgdW5kZXJzY29yZS1wcmVmaXhlZCBwcm9wZXJ0aWVzIG9uIGBvYmplY3RgIG5vbi1lbnVtZXJhYmxlLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGhpZGVQcml2YXRlUHJvcGVydGllcyhvYmplY3QpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnXycpKSB7XG4gICAgICAgICAgICBoaWRlUHJvcGVydHkob2JqZWN0LCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHN1YmNsYXNzIHdoaWNoLCBpbiB0aGUgY29uc3RydWN0b3IsIHNldHMgYWxsIHVuZGVyc2NvcmUtcHJlZml4ZWRcbiAqIHByb3BlcnRpZXMgYW5kIHRoZSBnaXZlbiBwdWJsaWMgcHJvcGVydGllcyBub24tZW51bWVyYWJsZS4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gKiBwYXRjaGluZyB1cCBjbGFzc2VzIGxpa2UgRXZlbnRFbWl0dGVyIHdoaWNoIG1heSBzZXQgcHJvcGVydGllcyBsaWtlIGBfZXZlbnRzYFxuICogYW5kIGBkb21haW5gLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2xhc3NcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcHJvcHNcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gc3ViY2xhc3NcbiAqL1xuZnVuY3Rpb24gaGlkZVByaXZhdGVBbmRDZXJ0YWluUHVibGljUHJvcGVydGllc0luQ2xhc3Moa2xhc3MsIHByb3BzKSB7XG4gICAgLy8gTk9URShtcm9iZXJ0cyk6IFdlIGRvIHRoaXMgdG8gYXZvaWQgZ2l2aW5nIHRoZSBjbGFzcyBhIG5hbWUuXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpKSkgfHwgdGhpcztcbiAgICAgICAgICAgIGhpZGVQcml2YXRlUHJvcGVydGllcyhfdGhpcyk7XG4gICAgICAgICAgICBoaWRlUHVibGljUHJvcGVydGllcyhfdGhpcywgcHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oa2xhc3MpKTtcbn1cbi8qKlxuICogSGlkZSBhIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGhpZGVQcm9wZXJ0eShvYmplY3QsIG5hbWUpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBuYW1lKTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbn1cbi8qKlxuICogSGlkZSB0aGUgZ2l2ZW4gcHVibGljIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LlxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbcHJvcHM9W11dXG4gKi9cbmZ1bmN0aW9uIGhpZGVQdWJsaWNQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkgeyBwcm9wcyA9IFtdOyB9XG4gICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIGhpZGVQcm9wZXJ0eShvYmplY3QsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXkgb2YgdmFsdWVzIHRvIGFuIEFycmF5IG9mIEpTT04gdmFsdWVzIGJ5IGNhbGxpbmdcbiAqIGB2YWx1ZVRvSlNPTmAgb24gZWFjaCB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFycmF5XG4gKiBAcmV0dXJucyB7QXJyYXk8Kj59XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9KU09OKGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5Lm1hcCh2YWx1ZVRvSlNPTik7XG59XG4vKipcbiAqIENvbnZlcnQgYSBTZXQgb2YgdmFsdWVzIHRvIGFuIEFycmF5IG9mIEpTT04gdmFsdWVzIGJ5IGNhbGxpbmcgYHZhbHVlVG9KU09OYFxuICogb24gZWFjaCB2YWx1ZS5cbiAqIEBwYXJhbSB7U2V0PCo+fSBzZXRcbiAqIEByZXR1cm5zIHtBcnJheTwqPn1cbiAqL1xuZnVuY3Rpb24gc2V0VG9KU09OKHNldCkge1xuICAgIHJldHVybiBhcnJheVRvSlNPTihfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoc2V0KSkpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgTWFwIGZyb20gc3RyaW5ncyB0byB2YWx1ZXMgdG8gYW4gb2JqZWN0IG9mIEpTT04gdmFsdWVzIGJ5IGNhbGxpbmdcbiAqIGB2YWx1ZVRvSlNPTmAgb24gZWFjaCB2YWx1ZS5cbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgKj59IG1hcFxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFwVG9KU09OKG1hcCkge1xuICAgIHJldHVybiBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobWFwLmVudHJpZXMoKSkpLnJlZHVjZShmdW5jdGlvbiAoanNvbiwgX2EpIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB2YXIgX2MgPSBfX3JlYWQoX2EsIDIpLCBrZXkgPSBfY1swXSwgdmFsdWUgPSBfY1sxXTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oKF9iID0ge30sIF9iW2tleV0gPSB2YWx1ZVRvSlNPTih2YWx1ZSksIF9iKSwganNvbik7XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCB0byBhIEpTT04gdmFsdWUgYnkgY2FsbGluZyBgdmFsdWVUb0pTT05gIG9uIGl0cyBlbnVtZXJhYmxlXG4gKiBrZXlzLlxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9KU09OKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhvYmplY3QpLnJlZHVjZShmdW5jdGlvbiAoanNvbiwgX2EpIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB2YXIgX2MgPSBfX3JlYWQoX2EsIDIpLCBrZXkgPSBfY1swXSwgdmFsdWUgPSBfY1sxXTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oKF9iID0ge30sIF9iW2tleV0gPSB2YWx1ZVRvSlNPTih2YWx1ZSksIF9iKSwganNvbik7XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIEpTT04gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gdmFsdWVUb0pTT04odmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5VG9KU09OKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIHNldFRvSlNPTih2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJldHVybiBtYXBUb0pTT04odmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RUb0pTT04odmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjcmVhdGVSb29tQ29ubmVjdEV2ZW50UGF5bG9hZChjb25uZWN0T3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGJvb2xUb1N0cmluZyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgfVxuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAvLyBhcnJheXMgcHJvcHMgY29udmVydGVkIHRvIGxlbmd0aHMuXG4gICAgICAgIGljZVNlcnZlcnM6IChjb25uZWN0T3B0aW9ucy5pY2VTZXJ2ZXJzIHx8IFtdKS5sZW5ndGgsXG4gICAgICAgIGF1ZGlvVHJhY2tzOiAoY29ubmVjdE9wdGlvbnMudHJhY2tzIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7IHJldHVybiB0cmFjay5raW5kID09PSAnYXVkaW8nOyB9KS5sZW5ndGgsXG4gICAgICAgIHZpZGVvVHJhY2tzOiAoY29ubmVjdE9wdGlvbnMudHJhY2tzIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7IHJldHVybiB0cmFjay5raW5kID09PSAndmlkZW8nOyB9KS5sZW5ndGgsXG4gICAgICAgIGRhdGFUcmFja3M6IChjb25uZWN0T3B0aW9ucy50cmFja3MgfHwgW10pLmZpbHRlcihmdW5jdGlvbiAodHJhY2spIHsgcmV0dXJuIHRyYWNrLmtpbmQgPT09ICdkYXRhJzsgfSkubGVuZ3RoLFxuICAgIH07XG4gICAgLy8gYm9vbGVhbiBwcm9wZXJ0aWVzLlxuICAgIFtbJ2F1ZGlvJ10sIFsnYXV0b21hdGljU3Vic2NyaXB0aW9uJ10sIFsnZW5hYmxlRHNjcCddLCBbJ2V2ZW50TGlzdGVuZXInXSwgWydwcmVmbGlnaHQnXSwgWyd2aWRlbyddLCBbJ2RvbWluYW50U3BlYWtlcicsICdlbmFibGVEb21pbmFudFNwZWFrZXInXV0uZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgcHJvcCA9IF9iWzBdLCBldmVudFByb3AgPSBfYlsxXTtcbiAgICAgICAgZXZlbnRQcm9wID0gZXZlbnRQcm9wIHx8IHByb3A7XG4gICAgICAgIHBheWxvYWRbZXZlbnRQcm9wXSA9IGJvb2xUb1N0cmluZyghIWNvbm5lY3RPcHRpb25zW3Byb3BdKTtcbiAgICB9KTtcbiAgICAvLyBudW1iZXJzIGFuZCBzdHJpbmcgcHJvcGVydGllcy5cbiAgICBbWydtYXhWaWRlb0JpdHJhdGUnXSwgWydtYXhBdWRpb0JpdHJhdGUnXSwgWydpY2VUcmFuc3BvcnRQb2xpY3knXSwgWydyZWdpb24nXSwgWyduYW1lJywgJ3Jvb21OYW1lJ11dLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHByb3AgPSBfYlswXSwgZXZlbnRQcm9wID0gX2JbMV07XG4gICAgICAgIGV2ZW50UHJvcCA9IGV2ZW50UHJvcCB8fCBwcm9wO1xuICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3RPcHRpb25zW3Byb3BdID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgY29ubmVjdE9wdGlvbnNbcHJvcF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXlsb2FkW2V2ZW50UHJvcF0gPSBjb25uZWN0T3B0aW9uc1twcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGFycmF5IHByb3BzIHN0cmluZ2lmaWVkLlxuICAgIFsncHJlZmVycmVkQXVkaW9Db2RlY3MnLCAncHJlZmVycmVkVmlkZW9Db2RlY3MnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wIGluIGNvbm5lY3RPcHRpb25zKSB7XG4gICAgICAgICAgICBwYXlsb2FkW3Byb3BdID0gSlNPTi5zdHJpbmdpZnkoY29ubmVjdE9wdGlvbnNbcHJvcF0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCduZXR3b3JrUXVhbGl0eScgaW4gY29ubmVjdE9wdGlvbnMpIHtcbiAgICAgICAgcGF5bG9hZC5uZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGlzTm9uQXJyYXlPYmplY3QoY29ubmVjdE9wdGlvbnMubmV0d29ya1F1YWxpdHkpKSB7XG4gICAgICAgICAgICBbJ2xvY2FsJywgJ3JlbW90ZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3RPcHRpb25zLm5ldHdvcmtRdWFsaXR5W3Byb3BdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLm5ldHdvcmtRdWFsaXR5Q29uZmlndXJhdGlvbltwcm9wXSA9IGNvbm5lY3RPcHRpb25zLm5ldHdvcmtRdWFsaXR5W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF5bG9hZC5uZXR3b3JrUXVhbGl0eUNvbmZpZ3VyYXRpb24ucmVtb3RlID0gMDtcbiAgICAgICAgICAgIHBheWxvYWQubmV0d29ya1F1YWxpdHlDb25maWd1cmF0aW9uLmxvY2FsID0gY29ubmVjdE9wdGlvbnMubmV0d29ya1F1YWxpdHkgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29ubmVjdE9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZSAmJiBjb25uZWN0T3B0aW9ucy5iYW5kd2lkdGhQcm9maWxlLnZpZGVvKSB7XG4gICAgICAgIHZhciB2aWRlb0JQT3B0aW9uc18xID0gY29ubmVjdE9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlbyB8fCB7fTtcbiAgICAgICAgcGF5bG9hZC5iYW5kd2lkdGhQcm9maWxlT3B0aW9ucyA9IHt9O1xuICAgICAgICBbJ21vZGUnLCAnbWF4VHJhY2tzJywgJ3RyYWNrU3dpdGNoT2ZmTW9kZScsICdkb21pbmFudFNwZWFrZXJQcmlvcml0eScsICdtYXhTdWJzY3JpcHRpb25CaXRyYXRlJywgJ3JlbmRlckRpbWVuc2lvbnMnLCAnY29udGVudFByZWZlcmVuY2VzTW9kZScsICdjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZpZGVvQlBPcHRpb25zXzFbcHJvcF0gPT09ICdudW1iZXInIHx8IHR5cGVvZiB2aWRlb0JQT3B0aW9uc18xW3Byb3BdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuYmFuZHdpZHRoUHJvZmlsZU9wdGlvbnNbcHJvcF0gPSB2aWRlb0JQT3B0aW9uc18xW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZpZGVvQlBPcHRpb25zXzFbcHJvcF0gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuYmFuZHdpZHRoUHJvZmlsZU9wdGlvbnNbcHJvcF0gPSBib29sVG9TdHJpbmcodmlkZW9CUE9wdGlvbnNfMVtwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmlkZW9CUE9wdGlvbnNfMVtwcm9wXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmJhbmR3aWR0aFByb2ZpbGVPcHRpb25zW3Byb3BdID0gSlNPTi5zdHJpbmdpZnkodmlkZW9CUE9wdGlvbnNfMVtwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBncm91cDogJ3Jvb20nLFxuICAgICAgICBuYW1lOiAnY29ubmVjdCcsXG4gICAgICAgIGxldmVsOiAnaW5mbycsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIGJhbmR3aWR0aCBwcm9maWxlIHBheWxvYWQgaW5jbHVkZWQgaW4gYW4gUlNQIGNvbm5lY3QgbWVzc2FnZS5cbiAqIEBwYXJhbSB7QmFuZHdpZHRoUHJvZmlsZU9wdGlvbnN9IGJhbmR3aWR0aFByb2ZpbGVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhbmR3aWR0aFByb2ZpbGVQYXlsb2FkKGJhbmR3aWR0aFByb2ZpbGUpIHtcbiAgICByZXR1cm4gY3JlYXRlUlNQUGF5bG9hZChiYW5kd2lkdGhQcm9maWxlLCBbXG4gICAgICAgIHsgcHJvcDogJ3ZpZGVvJywgdHlwZTogJ29iamVjdCcsIHRyYW5zZm9ybTogY3JlYXRlQmFuZHdpZHRoUHJvZmlsZVZpZGVvUGF5bG9hZCB9XG4gICAgXSk7XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgYmFuZHdpZHRoIHByb2ZpbGUgdmlkZW8gcGF5bG9hZCBpbmNsdWRlZCBpbiBhbiBSU1AgY29ubmVjdCBtZXNzYWdlLlxuICogQHBhcmFtIHtWaWRlb0JhbmR3aWR0aFByb2ZpbGVPcHRpb25zfSBiYW5kd2lkdGhQcm9maWxlVmlkZW9cbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhbmR3aWR0aFByb2ZpbGVWaWRlb1BheWxvYWQoYmFuZHdpZHRoUHJvZmlsZVZpZGVvKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJTUFBheWxvYWQoYmFuZHdpZHRoUHJvZmlsZVZpZGVvLCBbXG4gICAgICAgIHsgcHJvcDogJ2RvbWluYW50U3BlYWtlclByaW9yaXR5JywgdHlwZTogJ3N0cmluZycsIHBheWxvYWRQcm9wOiAnYWN0aXZlX3NwZWFrZXJfcHJpb3JpdHknIH0sXG4gICAgICAgIHsgcHJvcDogJ21heFN1YnNjcmlwdGlvbkJpdHJhdGUnLCB0eXBlOiAnbnVtYmVyJywgcGF5bG9hZFByb3A6ICdtYXhfc3Vic2NyaXB0aW9uX2JhbmR3aWR0aCcgfSxcbiAgICAgICAgeyBwcm9wOiAnbWF4VHJhY2tzJywgdHlwZTogJ251bWJlcicsIHBheWxvYWRQcm9wOiAnbWF4X3RyYWNrcycgfSxcbiAgICAgICAgeyBwcm9wOiAnbW9kZScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsgcHJvcDogJ3JlbmRlckRpbWVuc2lvbnMnLCB0eXBlOiAnb2JqZWN0JywgcGF5bG9hZFByb3A6ICdyZW5kZXJfZGltZW5zaW9ucycsIHRyYW5zZm9ybTogY3JlYXRlUmVuZGVyRGltZW5zaW9uc1BheWxvYWQgfSxcbiAgICAgICAgeyBwcm9wOiAndHJhY2tTd2l0Y2hPZmZNb2RlJywgdHlwZTogJ3N0cmluZycsIHBheWxvYWRQcm9wOiAndHJhY2tfc3dpdGNoX29mZicgfVxuICAgIF0pO1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIE1lZGlhIFNpZ25hbGluZyBwYXlsb2FkIGluY2x1ZGVkIGluIGFuIFJTUCBjb25uZWN0IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRvbWluYW50U3BlYWtlciAtIHdoZXRoZXIgdG8gZW5hYmxlIHRoZSBEb21pbmFudCBTcGVha2VyXG4gKiAgIHByb3RvY29sIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBuZXR3b3JrUXVhbGl0eSAtIHdoZXRoZXIgdG8gZW5hYmxlIHRoZSBOZXR3b3JrIFF1YWxpdHlcbiAqICAgcHJvdG9jb2wgb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRyYWNrUHJpb3JpdHkgLSB3aGV0aGVyIHRvIGVuYWJsZSB0aGUgVHJhY2sgUHJpb3JpdHlcbiAqICAgcHJvdG9jb2wgb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRyYWNrU3dpdGNoT2ZmIC0gd2hldGhlciB0byBlbmFibGUgdGhlIFRyYWNrIFN3aXRjaC1PZmZcbiAqICAgcHJvdG9jb2wgb3Igbm90LlxuICogQHBhcmFtIHtib29sZWFufSByZW5kZXJIaW50cyAtIHdoZXRoZXIgdG8gZW5hYmxlIHRoZSByZW5kZXJIaW50c1xuICogICBwcm90b2NvbCBvciBub3QuXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZWRpYVNpZ25hbGluZ1BheWxvYWQoZG9taW5hbnRTcGVha2VyLCBuZXR3b3JrUXVhbGl0eSwgdHJhY2tQcmlvcml0eSwgdHJhY2tTd2l0Y2hPZmYsIHJlbmRlckhpbnRzKSB7XG4gICAgdmFyIHRyYW5zcG9ydHMgPSB7IHRyYW5zcG9ydHM6IFt7IHR5cGU6ICdkYXRhLWNoYW5uZWwnIH1dIH07XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZG9taW5hbnRTcGVha2VyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICA/IHsgYWN0aXZlX3NwZWFrZXI6IHRyYW5zcG9ydHMgfVxuICAgICAgICA6IHt9LCBuZXR3b3JrUXVhbGl0eVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgPyB7IG5ldHdvcmtfcXVhbGl0eTogdHJhbnNwb3J0cyB9XG4gICAgICAgIDoge30sIHJlbmRlckhpbnRzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICA/IHsgcmVuZGVyX2hpbnRzOiB0cmFuc3BvcnRzLCBwdWJsaXNoZXJfaGludHM6IHRyYW5zcG9ydHMgfVxuICAgICAgICA6IHt9LCB0cmFja1ByaW9yaXR5XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICA/IHsgdHJhY2tfcHJpb3JpdHk6IHRyYW5zcG9ydHMgfVxuICAgICAgICA6IHt9LCB0cmFja1N3aXRjaE9mZlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgPyB7IHRyYWNrX3N3aXRjaF9vZmY6IHRyYW5zcG9ydHMgfVxuICAgICAgICA6IHt9KTtcbn1cbi8qKlxuICogQ3JlYXRlIHtAbGluayBWaWRlb1RyYWNrLkRpbWVuc2lvbnN9IFJTUCBwYXlsb2FkLlxuICogQHBhcmFtIHtWaWRlb1RyYWNrLkRpbWVuc2lvbnN9IFtkaW1lbnNpb25zXVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGltZW5zaW9uc1BheWxvYWQoZGltZW5zaW9ucykge1xuICAgIHJldHVybiBjcmVhdGVSU1BQYXlsb2FkKGRpbWVuc2lvbnMsIFtcbiAgICAgICAgeyBwcm9wOiAnaGVpZ2h0JywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgICAgeyBwcm9wOiAnd2lkdGgnLCB0eXBlOiAnbnVtYmVyJyB9XG4gICAgXSk7XG59XG4vKipcbiAqIENyZWF0ZSB7QGxpbmsgVmlkZW9SZW5kZXJEaW1lbnNpb25zfSBSU1AgcGF5bG9hZC5cbiAqIEBwYXJhbSByZW5kZXJEaW1lbnNpb25zXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJEaW1lbnNpb25zUGF5bG9hZChyZW5kZXJEaW1lbnNpb25zKSB7XG4gICAgdmFyIFBSSU9SSVRZX0hJR0ggPSB0cmFja1ByaW9yaXR5LlBSSU9SSVRZX0hJR0gsIFBSSU9SSVRZX0xPVyA9IHRyYWNrUHJpb3JpdHkuUFJJT1JJVFlfTE9XLCBQUklPUklUWV9TVEFOREFSRCA9IHRyYWNrUHJpb3JpdHkuUFJJT1JJVFlfU1RBTkRBUkQ7XG4gICAgcmV0dXJuIGNyZWF0ZVJTUFBheWxvYWQocmVuZGVyRGltZW5zaW9ucywgW1xuICAgICAgICB7IHByb3A6IFBSSU9SSVRZX0hJR0gsIHR5cGU6ICdvYmplY3QnLCB0cmFuc2Zvcm06IGNyZWF0ZURpbWVuc2lvbnNQYXlsb2FkIH0sXG4gICAgICAgIHsgcHJvcDogUFJJT1JJVFlfTE9XLCB0eXBlOiAnb2JqZWN0JywgdHJhbnNmb3JtOiBjcmVhdGVEaW1lbnNpb25zUGF5bG9hZCB9LFxuICAgICAgICB7IHByb3A6IFBSSU9SSVRZX1NUQU5EQVJELCB0eXBlOiAnb2JqZWN0JywgdHJhbnNmb3JtOiBjcmVhdGVEaW1lbnNpb25zUGF5bG9hZCB9XG4gICAgXSk7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBSU1AgcGF5bG9hZCBmb3IgdGhlIGdpdmVuIG9iamVjdC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgLSBvYmplY3QgZm9yIHdoaWNoIFJTUCBwYXlsb2FkIGlzIHRvIGJlIGdlbmVyYXRlZFxuICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBwcm9wQ29udmVyc2lvbnMgLSBjb252ZXJzaW9uIHJ1bGVzIGZvciBvYmplY3QgcHJvcGVydGllcztcbiAqICAgdGhleSBzcGVjaWZ5IGhvdyBvYmplY3QgcHJvcGVydGllcyBzaG91bGQgYmUgY29udmVydGVkIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqICAgUlNQIHBheWxvYWQgcHJvcGVydGllc1xuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUlNQUGF5bG9hZChvYmplY3QsIHByb3BDb252ZXJzaW9ucykge1xuICAgIHJldHVybiBwcm9wQ29udmVyc2lvbnMucmVkdWNlKGZ1bmN0aW9uIChwYXlsb2FkLCBfYSkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciBwcm9wID0gX2EucHJvcCwgdHlwZSA9IF9hLnR5cGUsIF9jID0gX2EucGF5bG9hZFByb3AsIHBheWxvYWRQcm9wID0gX2MgPT09IHZvaWQgMCA/IHByb3AgOiBfYywgX2QgPSBfYS50cmFuc2Zvcm0sIHRyYW5zZm9ybSA9IF9kID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9kO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iamVjdFtwcm9wXSA9PT0gdHlwZVxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKChfYiA9IHt9LCBfYltwYXlsb2FkUHJvcF0gPSB0cmFuc2Zvcm0ob2JqZWN0W3Byb3BdKSwgX2IpLCBwYXlsb2FkKVxuICAgICAgICAgICAgOiBwYXlsb2FkO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBzdWJzY3JpYmUgcGF5bG9hZCBpbmNsdWRlZCBpbiBhbiBSU1AgY29ubmVjdC91cGRhdGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b21hdGljU3Vic2NyaXB0aW9uIC0gd2hldGhlciB0byBzdWJzY3JpYmUgdG8gYWxsIFJlbW90ZVRyYWNrc1xuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3Vic2NyaWJlUGF5bG9hZChhdXRvbWF0aWNTdWJzY3JpcHRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBydWxlczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBhdXRvbWF0aWNTdWJzY3JpcHRpb24gPyAnaW5jbHVkZScgOiAnZXhjbHVkZScsXG4gICAgICAgICAgICAgICAgYWxsOiB0cnVlXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgcmV2aXNpb246IDFcbiAgICB9O1xufVxuLyoqXG4gKiBBZGQgcmFuZG9tIGppdHRlciB0byBhIGdpdmVuIHZhbHVlIGluIHRoZSByYW5nZSBbLWppdHRlciwgaml0dGVyXS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBqaXR0ZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlICsgcmFuZG9tKC1qaXR0ZXIsICtqaXR0ZXIpXG4gKi9cbmZ1bmN0aW9uIHdpdGhKaXR0ZXIodmFsdWUsIGppdHRlcikge1xuICAgIHZhciByYW5kID0gTWF0aC5yYW5kb20oKTtcbiAgICByZXR1cm4gdmFsdWUgLSBqaXR0ZXIgKyBNYXRoLmZsb29yKDIgKiBqaXR0ZXIgKiByYW5kICsgMC41KTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhIG51bWJlciBpcyBpbiB0aGUgcmFuZ2UgW21pbiwgbWF4XS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bX0gbnVtXG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpblJhbmdlKG51bSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gbWluIDw9IG51bSAmJiBudW0gPD0gbWF4O1xufVxuLyoqXG4gKiByZXR1cm5zIHRydWUgaWYgZ2l2ZW4gTWVkaWFTdHJlYW1UcmFjayBpcyBhIHNjcmVlbiBzaGFyZSB0cmFja1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Nocm9tZVNjcmVlblNoYXJlVHJhY2sodHJhY2spIHtcbiAgICAvLyBOT1RFKG1wYXR3YXJkaGFuKTogQ2hyb21lIGNyZWF0ZXMgc2NyZWVuIHNoYXJlIHRyYWNrcyB3aXRoIGxhYmVsIGxpa2U6IFwic2NyZWVuOjY5NzM0MjcyKlwiXG4gICAgLy8gd2Ugd2lsbCBjaGVjayBmb3IgbGFiZWwgdGhhdCBzdGFydHMgd2l0aCBcInNjcmVlbjpEXCIgd2hlcmUgRCBiZWluZyBhIGRpZ2l0LlxuICAgIHZhciBpc0Nocm9tZSA9IHV0aWwuZ3Vlc3NCcm93c2VyKCkgPT09ICdjaHJvbWUnO1xuICAgIHJldHVybiBpc0Nocm9tZSAmJiB0cmFjay5raW5kID09PSAndmlkZW8nICYmIHRyYWNrLmxhYmVsICYmICgvXnNjcmVlbjpbMC05XSsvLnRlc3QodHJhY2subGFiZWwpIHx8IC9ed2ViLWNvbnRlbnRzLW1lZGlhLXN0cmVhbTpbMC05L10rLy50ZXN0KHRyYWNrLmxhYmVsKSB8fCAvXndpbmRvdzpbMC05XSsvLnRlc3QodHJhY2subGFiZWwpKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlIGFmdGVyIHRpbWVvdXRNUyBoYXZlIHBhc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TVMgLSB0aW1lIHRvIHdhaXQgaW4gbWlsbGlzZWNvbmRzLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmZ1bmN0aW9uIHdhaXRGb3JTb21ldGltZSh0aW1lb3V0TVMpIHtcbiAgICBpZiAodGltZW91dE1TID09PSB2b2lkIDApIHsgdGltZW91dE1TID0gMTA7IH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dE1TKTsgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZSBhZnRlciBldmVudCBpcyByZWNlaXZlZFxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmZ1bmN0aW9uIHdhaXRGb3JFdmVudChldmVudFRhcmdldCwgZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuY3Rpb24gb25ldmVudChlKSB7XG4gICAgICAgICAgICBldmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbmV2ZW50KTtcbiAgICAgICAgICAgIHJlc29sdmUoZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jb25zdGFudHMgPSBjb25zdGFudHM7XG5leHBvcnRzLmNyZWF0ZUJhbmR3aWR0aFByb2ZpbGVQYXlsb2FkID0gY3JlYXRlQmFuZHdpZHRoUHJvZmlsZVBheWxvYWQ7XG5leHBvcnRzLmNyZWF0ZU1lZGlhU2lnbmFsaW5nUGF5bG9hZCA9IGNyZWF0ZU1lZGlhU2lnbmFsaW5nUGF5bG9hZDtcbmV4cG9ydHMuY3JlYXRlUm9vbUNvbm5lY3RFdmVudFBheWxvYWQgPSBjcmVhdGVSb29tQ29ubmVjdEV2ZW50UGF5bG9hZDtcbmV4cG9ydHMuY3JlYXRlU3Vic2NyaWJlUGF5bG9hZCA9IGNyZWF0ZVN1YnNjcmliZVBheWxvYWQ7XG5leHBvcnRzLmFzTG9jYWxUcmFjayA9IGFzTG9jYWxUcmFjaztcbmV4cG9ydHMuYXNMb2NhbFRyYWNrUHVibGljYXRpb24gPSBhc0xvY2FsVHJhY2tQdWJsaWNhdGlvbjtcbmV4cG9ydHMuY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG5leHBvcnRzLmRlcHJlY2F0ZUV2ZW50cyA9IGRlcHJlY2F0ZUV2ZW50cztcbmV4cG9ydHMuZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG5leHBvcnRzLmZpbHRlck9iamVjdCA9IGZpbHRlck9iamVjdDtcbmV4cG9ydHMuZmxhdE1hcCA9IGZsYXRNYXA7XG5leHBvcnRzLmdldFBsYXRmb3JtID0gZ2V0UGxhdGZvcm07XG5leHBvcnRzLmdldFVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudDtcbmV4cG9ydHMuaGlkZVByaXZhdGVQcm9wZXJ0aWVzID0gaGlkZVByaXZhdGVQcm9wZXJ0aWVzO1xuZXhwb3J0cy5oaWRlUHJpdmF0ZUFuZENlcnRhaW5QdWJsaWNQcm9wZXJ0aWVzSW5DbGFzcyA9IGhpZGVQcml2YXRlQW5kQ2VydGFpblB1YmxpY1Byb3BlcnRpZXNJbkNsYXNzO1xuZXhwb3J0cy5pc0RlZXBFcXVhbCA9IGlzRGVlcEVxdWFsO1xuZXhwb3J0cy5pc05vbkFycmF5T2JqZWN0ID0gaXNOb25BcnJheU9iamVjdDtcbmV4cG9ydHMuaW5SYW5nZSA9IGluUmFuZ2U7XG5leHBvcnRzLm1ha2VVVUlEID0gbWFrZVVVSUQ7XG5leHBvcnRzLm9uY2VQZXJUaWNrID0gb25jZVBlclRpY2s7XG5leHBvcnRzLnByb21pc2VGcm9tRXZlbnRzID0gcHJvbWlzZUZyb21FdmVudHM7XG5leHBvcnRzLmdldE9yTnVsbCA9IGdldE9yTnVsbDtcbmV4cG9ydHMuZGVmZXIgPSBkZWZlcjtcbmV4cG9ydHMuZGVsZWdhdGVNZXRob2RzID0gZGVsZWdhdGVNZXRob2RzO1xuZXhwb3J0cy5wcm94eVByb3BlcnRpZXMgPSBwcm94eVByb3BlcnRpZXM7XG5leHBvcnRzLmxlZ2FjeVByb21pc2UgPSBsZWdhY3lQcm9taXNlO1xuZXhwb3J0cy5idWlsZExvZ0xldmVscyA9IGJ1aWxkTG9nTGV2ZWxzO1xuZXhwb3J0cy50cmFja0NsYXNzID0gdHJhY2tDbGFzcztcbmV4cG9ydHMudHJhY2tQdWJsaWNhdGlvbkNsYXNzID0gdHJhY2tQdWJsaWNhdGlvbkNsYXNzO1xuZXhwb3J0cy52YWx1ZVRvSlNPTiA9IHZhbHVlVG9KU09OO1xuZXhwb3J0cy53aXRoSml0dGVyID0gd2l0aEppdHRlcjtcbmV4cG9ydHMuaXNDaHJvbWVTY3JlZW5TaGFyZVRyYWNrID0gaXNDaHJvbWVTY3JlZW5TaGFyZVRyYWNrO1xuZXhwb3J0cy53YWl0Rm9yU29tZXRpbWUgPSB3YWl0Rm9yU29tZXRpbWU7XG5leHBvcnRzLndhaXRGb3JFdmVudCA9IHdhaXRGb3JFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGdldFVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uJykuZ2V0VXNlckFnZW50O1xudmFyIE1BWF9SRUNPTk5FQ1RfQVRURU1QVFMgPSA1O1xudmFyIFJFQ09OTkVDVF9JTlRFUlZBTF9NUyA9IDUwO1xudmFyIFdTX0NMT1NFX05PUk1BTCA9IDEwMDA7XG52YXIgdG9wbGV2ZWwgPSBnbG9iYWwud2luZG93IHx8IGdsb2JhbDtcbnZhciBXZWJTb2NrZXQgPSB0b3BsZXZlbC5XZWJTb2NrZXQgPyB0b3BsZXZlbC5XZWJTb2NrZXQgOiByZXF1aXJlKCd3cycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG4vKipcbiAqIFB1Ymxpc2ggZXZlbnRzIHRvIHRoZSBJbnNpZ2h0cyBnYXRld2F5LlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAZW1pdHMgSW5zaWdodHNQdWJsaXNoZXIjY29ubmVjdGVkXG4gKiBAZW1pdHMgSW5zaWdodHNQdWJsaXNoZXIjZGlzY29ubmVjdGVkXG4gKiBAZW1pdHMgSW5zaWdodHNQdWJsaXNoZXIjcmVjb25uZWN0aW5nXG4gKi9cbnZhciBJbnNpZ2h0c1B1Ymxpc2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5zaWdodHNQdWJsaXNoZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gSW5zaWdodHMgZ2F0ZXdheSB0b2tlblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZGtOYW1lIC0gTmFtZSBvZiB0aGUgU0RLIHVzaW5nIHRoZSB7QGxpbmsgSW5zaWdodHNQdWJsaXNoZXJ9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNka1ZlcnNpb24gLSBWZXJzaW9uIG9mIHRoZSBTREsgdXNpbmcgdGhlIHtAbGluayBJbnNpZ2h0c1B1Ymxpc2hlcn1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW52aXJvbm1lbnQgLSBPbmUgb2YgJ2RldicsICdzdGFnZScgb3IgJ3Byb2QnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlYWxtIC0gUmVnaW9uIGlkZW50aWZpZXJcbiAgICAgKiBAcGFyYW0ge0luc2lnaHRzUHVibGlzaGVyT3B0aW9uc30gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbnNpZ2h0c1B1Ymxpc2hlcih0b2tlbiwgc2RrTmFtZSwgc2RrVmVyc2lvbiwgZW52aXJvbm1lbnQsIHJlYWxtLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGdhdGV3YXk6IGNyZWF0ZUdhdGV3YXkoZW52aXJvbm1lbnQsIHJlYWxtKSArIFwiL3YxL1ZpZGVvRXZlbnRzXCIsXG4gICAgICAgICAgICBtYXhSZWNvbm5lY3RBdHRlbXB0czogTUFYX1JFQ09OTkVDVF9BVFRFTVBUUyxcbiAgICAgICAgICAgIHJlY29ubmVjdEludGVydmFsTXM6IFJFQ09OTkVDVF9JTlRFUlZBTF9NUyxcbiAgICAgICAgICAgIHVzZXJBZ2VudDogZ2V0VXNlckFnZW50KCksXG4gICAgICAgICAgICBXZWJTb2NrZXQ6IFdlYlNvY2tldFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgICAgIF9jb25uZWN0VGltZXN0YW1wOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZXZlbnRRdWV1ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZWFkeVRvQ29ubmVjdDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB1dGlsLmRlZmVyKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVjb25uZWN0QXR0ZW1wdHNMZWZ0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMubWF4UmVjb25uZWN0QXR0ZW1wdHMsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfd3M6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9XZWJTb2NrZXQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5XZWJTb2NrZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLl9yZWFkeVRvQ29ubmVjdC5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgcm9vbVNpZCA9IF9hLnJvb21TaWQsIHBhcnRpY2lwYW50U2lkID0gX2EucGFydGljaXBhbnRTaWQ7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IF90aGlzO1xuICAgICAgICAgICAgX3RoaXMub24oJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uIG1heWJlUmVjb25uZWN0KGVycm9yKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yICYmIHNlbGYuX3JlY29ubmVjdEF0dGVtcHRzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdyZWNvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjb25uZWN0KHNlbGYsIHRva2VuLCBzZGtOYW1lLCBzZGtWZXJzaW9uLCByb29tU2lkLCBwYXJ0aWNpcGFudFNpZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignZGlzY29ubmVjdGVkJywgbWF5YmVSZWNvbm5lY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25uZWN0KF90aGlzLCB0b2tlbiwgc2RrTmFtZSwgc2RrVmVyc2lvbiwgcm9vbVNpZCwgcGFydGljaXBhbnRTaWQsIG9wdGlvbnMpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZmFpbHVyZXMgdG8gY29ubmVjdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBjb25uZWN0aW5nIHRvIHRoZSBJbnNpZ2h0cyBnYXRld2F5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb29tU2lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcnRpY2lwYW50U2lkXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgSW5zaWdodHNQdWJsaXNoZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAocm9vbVNpZCwgcGFydGljaXBhbnRTaWQpIHtcbiAgICAgICAgdGhpcy5fcmVhZHlUb0Nvbm5lY3QucmVzb2x2ZSh7IHJvb21TaWQ6IHJvb21TaWQsIHBhcnRpY2lwYW50U2lkOiBwYXJ0aWNpcGFudFNpZCB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggYW4gZXZlbnQgdG8gdGhlIEluc2lnaHRzIGdhdGV3YXkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IGV2ZW50XG4gICAgICovXG4gICAgSW5zaWdodHNQdWJsaXNoZXIucHJvdG90eXBlLl9wdWJsaXNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnNlc3Npb24gPSB0aGlzLl9zZXNzaW9uO1xuICAgICAgICB0aGlzLl93cy5zZW5kKEpTT04uc3RyaW5naWZ5KGV2ZW50KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGZyb20gdGhlIEluc2lnaHRzIGdhdGV3YXkuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgY2FsbGVkIHdoZW4gY29ubmVjdGluZy9vcGVuLCBmYWxzZSBpZiBub3RcbiAgICAgKi9cbiAgICBJbnNpZ2h0c1B1Ymxpc2hlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dzID09PSBudWxsXG4gICAgICAgICAgICB8fCB0aGlzLl93cy5yZWFkeVN0YXRlID09PSB0aGlzLl9XZWJTb2NrZXQuQ0xPU0lOR1xuICAgICAgICAgICAgfHwgdGhpcy5fd3MucmVhZHlTdGF0ZSA9PT0gdGhpcy5fV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl93cy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggKG9yIHF1ZXVlLCBpZiBub3QgY29ubmVjdGVkKSBhbiBldmVudCB0byB0aGUgSW5zaWdodHMgZ2F0ZXdheS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBOYW1lIC0gRXZlbnQgZ3JvdXAgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBFdmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBheWxvYWQgLSBFdmVudCBwYXlsb2FkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgcXVldWVkIG9yIHB1Ymxpc2hlZCwgZmFsc2UgaWYgZGlzY29ubmVjdCgpIGNhbGxlZFxuICAgICAqL1xuICAgIEluc2lnaHRzUHVibGlzaGVyLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKGdyb3VwTmFtZSwgZXZlbnROYW1lLCBwYXlsb2FkKSB7XG4gICAgICAgIGlmICh0aGlzLl93cyAhPT0gbnVsbFxuICAgICAgICAgICAgJiYgKHRoaXMuX3dzLnJlYWR5U3RhdGUgPT09IHRoaXMuX1dlYlNvY2tldC5DTE9TSU5HXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fd3MucmVhZHlTdGF0ZSA9PT0gdGhpcy5fV2ViU29ja2V0LkNMT1NFRCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHVibGlzaE9yRW5xdWV1ZSA9IHR5cGVvZiB0aGlzLl9zZXNzaW9uID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB0aGlzLl9wdWJsaXNoLmJpbmQodGhpcylcbiAgICAgICAgICAgIDogdGhpcy5fZXZlbnRRdWV1ZS5wdXNoLmJpbmQodGhpcy5fZXZlbnRRdWV1ZSk7XG4gICAgICAgIHB1Ymxpc2hPckVucXVldWUoe1xuICAgICAgICAgICAgZ3JvdXA6IGdyb3VwTmFtZSxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgdmVyc2lvbjogMVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gSW5zaWdodHNQdWJsaXNoZXI7XG59KEV2ZW50RW1pdHRlcikpO1xuLyoqXG4gKiBTdGFydCBjb25uZWN0aW5nIHRvIHRoZSBJbnNpZ2h0cyBnYXRld2F5LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SW5zaWdodHNQdWJsaXNoZXJ9IHB1Ymxpc2hlclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHNka05hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZGtWZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVNpZFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcnRpY2lwYW50U2lkXG4gKiBAcGFyYW0ge0luc2lnaHRzUHVibGlzaGVyT3B0aW9uc30gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjb25uZWN0KHB1Ymxpc2hlciwgdG9rZW4sIHNka05hbWUsIHNka1ZlcnNpb24sIHJvb21TaWQsIHBhcnRpY2lwYW50U2lkLCBvcHRpb25zKSB7XG4gICAgcHVibGlzaGVyLl9jb25uZWN0VGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBwdWJsaXNoZXIuX3JlY29ubmVjdEF0dGVtcHRzTGVmdC0tO1xuICAgIHB1Ymxpc2hlci5fd3MgPSBuZXcgb3B0aW9ucy5XZWJTb2NrZXQob3B0aW9ucy5nYXRld2F5KTtcbiAgICB2YXIgd3MgPSBwdWJsaXNoZXIuX3dzO1xuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5jb2RlID09PSBXU19DTE9TRV9OT1JNQUwpIHtcbiAgICAgICAgICAgIHB1Ymxpc2hlci5lbWl0KCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwdWJsaXNoZXIuZW1pdCgnZGlzY29ubmVjdGVkJywgbmV3IEVycm9yKFwiV2ViU29ja2V0IEVycm9yIFwiICsgZXZlbnQuY29kZSArIFwiOiBcIiArIGV2ZW50LnJlYXNvbikpO1xuICAgIH0pO1xuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBoYW5kbGVDb25uZWN0UmVzcG9uc2UocHVibGlzaGVyLCBKU09OLnBhcnNlKG1lc3NhZ2UuZGF0YSksIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0UmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdjb25uZWN0JyxcbiAgICAgICAgICAgIHRva2VuOiB0b2tlbixcbiAgICAgICAgICAgIHZlcnNpb246IDFcbiAgICAgICAgfTtcbiAgICAgICAgY29ubmVjdFJlcXVlc3QucHVibGlzaGVyID0ge1xuICAgICAgICAgICAgbmFtZTogc2RrTmFtZSxcbiAgICAgICAgICAgIHNka1ZlcnNpb246IHNka1ZlcnNpb24sXG4gICAgICAgICAgICB1c2VyQWdlbnQ6IG9wdGlvbnMudXNlckFnZW50LFxuICAgICAgICAgICAgcGFydGljaXBhbnRTaWQ6IHBhcnRpY2lwYW50U2lkLFxuICAgICAgICAgICAgcm9vbVNpZDogcm9vbVNpZCxcbiAgICAgICAgfTtcbiAgICAgICAgd3Muc2VuZChKU09OLnN0cmluZ2lmeShjb25uZWN0UmVxdWVzdCkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIEluc2lnaHRzIFdlYnNvY2tldCBnYXRld2F5IFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbnZpcm9ubWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHJlYWxtXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjcmVhdGVHYXRld2F5KGVudmlyb25tZW50LCByZWFsbSkge1xuICAgIHJldHVybiBlbnZpcm9ubWVudCA9PT0gJ3Byb2QnID8gXCJ3c3M6Ly9zZGtndy5cIiArIHJlYWxtICsgXCIudHdpbGlvLmNvbVwiXG4gICAgICAgIDogXCJ3c3M6Ly9zZGtndy5cIiArIGVudmlyb25tZW50ICsgXCItXCIgKyByZWFsbSArIFwiLnR3aWxpby5jb21cIjtcbn1cbi8qKlxuICogSGFuZGxlIGNvbm5lY3QgcmVzcG9uc2UgZnJvbSB0aGUgSW5zaWdodHMgZ2F0ZXdheS5cbiAqIEBwYXJhbSB7SW5zaWdodHNQdWJsaXNoZXJ9IHB1Ymxpc2hlclxuICogQHBhcmFtIHsqfSByZXNwb25zZVxuICogQHBhcmFtIHtJbnNpZ2h0c1B1Ymxpc2hlck9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gaGFuZGxlQ29ubmVjdFJlc3BvbnNlKHB1Ymxpc2hlciwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICBzd2l0Y2ggKHJlc3BvbnNlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgIHB1Ymxpc2hlci5fc2Vzc2lvbiA9IHJlc3BvbnNlLnNlc3Npb247XG4gICAgICAgICAgICBwdWJsaXNoZXIuX3JlY29ubmVjdEF0dGVtcHRzTGVmdCA9IG9wdGlvbnMubWF4UmVjb25uZWN0QXR0ZW1wdHM7XG4gICAgICAgICAgICBwdWJsaXNoZXIuX2V2ZW50UXVldWUuc3BsaWNlKDApLmZvckVhY2gocHVibGlzaGVyLl9wdWJsaXNoLCBwdWJsaXNoZXIpO1xuICAgICAgICAgICAgcHVibGlzaGVyLmVtaXQoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgIHB1Ymxpc2hlci5fd3MuY2xvc2UoKTtcbiAgICAgICAgICAgIHB1Ymxpc2hlci5lbWl0KCdkaXNjb25uZWN0ZWQnLCBuZXcgRXJyb3IocmVzcG9uc2UubWVzc2FnZSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuLyoqXG4gKiBTdGFydCByZS1jb25uZWN0aW5nIHRvIHRoZSBJbnNpZ2h0cyBnYXRld2F5IHdpdGggYW4gYXBwcm9wcmlhdGUgZGVsYXkgYmFzZWRcbiAqIG9uIEluc2lnaHRzUHVibGlzaGVyT3B0aW9ucyNyZWNvbm5lY3RJbnRlcnZhbE1zLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SW5zaWdodHNQdWJsaXNoZXJ9IHB1Ymxpc2hlclxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RrTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHNka1ZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSByb29tU2lkXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFydGljaXBhbnRTaWRcbiAqIEBwYXJhbSB7SW5zaWdodHNQdWJsaXNoZXJPcHRpb25zfSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHJlY29ubmVjdChwdWJsaXNoZXIsIHRva2VuLCBzZGtOYW1lLCBzZGtWZXJzaW9uLCByb29tU2lkLCBwYXJ0aWNpcGFudFNpZCwgb3B0aW9ucykge1xuICAgIHZhciBjb25uZWN0SW50ZXJ2YWwgPSBEYXRlLm5vdygpIC0gcHVibGlzaGVyLl9jb25uZWN0VGltZXN0YW1wO1xuICAgIHZhciB0aW1lVG9XYWl0ID0gb3B0aW9ucy5yZWNvbm5lY3RJbnRlcnZhbE1zIC0gY29ubmVjdEludGVydmFsO1xuICAgIGlmICh0aW1lVG9XYWl0ID4gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbm5lY3QocHVibGlzaGVyLCB0b2tlbiwgc2RrTmFtZSwgc2RrVmVyc2lvbiwgcm9vbVNpZCwgcGFydGljaXBhbnRTaWQsIG9wdGlvbnMpO1xuICAgICAgICB9LCB0aW1lVG9XYWl0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25uZWN0KHB1Ymxpc2hlciwgdG9rZW4sIHNka05hbWUsIHNka1ZlcnNpb24sIHJvb21TaWQsIHBhcnRpY2lwYW50U2lkLCBvcHRpb25zKTtcbn1cbi8qKlxuICogVGhlIHtAbGluayBJbnNpZ2h0c1B1Ymxpc2hlcn0gaXMgY29ubmVjdGVkIHRvIHRoZSBnYXRld2F5LlxuICogQGV2ZW50IEluc2lnaHRzUHVibGlzaGVyI2Nvbm5lY3RlZFxuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgSW5zaWdodHNQdWJsaXNoZXJ9IGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBnYXRld2F5LlxuICogQGV2ZW50IEluc2lnaHRzUHVibGlzaGVyI2Rpc2Nvbm5lY3RlZFxuICogQHBhcmFtIHtFcnJvcn0gW2Vycm9yXSAtIE9wdGlvbmFsIGVycm9yIGlmIGRpc2Nvbm5lY3RlZCB1bmludGVudGlvbmFsbHlcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIEluc2lnaHRzUHVibGlzaGVyfSBpcyByZS1jb25uZWN0aW5nIHRvIHRoZSBnYXRld2F5LlxuICogQGV2ZW50IEluc2lnaHRzUHVibGlzaGVyI3JlY29ubmVjdGluZ1xuICovXG4vKipcbiAqIHtAbGluayBJbnNpZ2h0c1B1Ymxpc2hlcn0gb3B0aW9ucy5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IEluc2lnaHRzUHVibGlzaGVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtnYXRld2F5PXNka2d3LntlbnZpcm9ubWVudH0te3JlYWxtfS50d2lsaW8uY29tXSAtIEluc2lnaHRzIFdlYlNvY2tldCBnYXRld2F5IHVybFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZWNvbm5lY3RBdHRlbXB0cz01XSAtIE1heCByZS1jb25uZWN0IGF0dGVtcHRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlY29ubmVjdEludGVydmFsTXM9NTBdIC0gUmUtY29ubmVjdCBpbnRlcnZhbCBpbiBtc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IEluc2lnaHRzUHVibGlzaGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXdhcm5pbmctY29tbWVudHNcbi8vIFRPRE8obXJvYmVydHMpOiBUaGlzIHNob3VsZCBiZSBkZXNjcmliZWQgYXMgaW1wbGVtZW50aW5nIHNvbWVcbi8vIEluc2lnaHRzUHVibGlzaGVyIGludGVyZmFjZS5cbid1c2Ugc3RyaWN0Jztcbi8qKlxuICogTnVsbCBJbnNpZ2h0cyBwdWJsaXNoZXIuXG4gKi9cbnZhciBJbnNpZ2h0c1B1Ymxpc2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnNpZ2h0c1B1Ymxpc2hlcigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgX2Nvbm5lY3RlZDoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0XG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgSW5zaWdodHNQdWJsaXNoZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIEluc2lnaHRzUHVibGlzaGVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1Ymxpc2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgSW5zaWdodHNQdWJsaXNoZXIucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0ZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gSW5zaWdodHNQdWJsaXNoZXI7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBJbnNpZ2h0c1B1Ymxpc2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bGwuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmVyID0gcmVxdWlyZSgnLi8nKS5kZWZlcjtcbi8qKlxuICogVGhpcyBpcyBhIHBhaXIgb2YgRGVmZXJyZWRzIHRoYXQgYXJlIHNldCB3aGVuZXZlciBsb2NhbCBtZWRpYSBpcyBtdXRlZCBhbmRcbiAqIHJlc29sdmVkIHdoZW5ldmVyIGxvY2FsIG1lZGlhIGlzIHVubXV0ZWQvZW5kZWQgYW5kIHJlc3RhcnRlZCBpZiBuZWNlc3NhcnkuXG4gKi9cbnZhciBMb2NhbE1lZGlhUmVzdGFydERlZmVycmVkcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2NhbE1lZGlhUmVzdGFydERlZmVycmVkcygpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgX2F1ZGlvOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlZmVyKCksXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdmlkZW86IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGVmZXIoKSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSW5pdGlhbGx5LCByZXNvbHZlIGJvdGggdGhlIERlZmVycmVkcy5cbiAgICAgICAgdGhpcy5fYXVkaW8ucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLl92aWRlby5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgdGhlIERlZmVycmVkIGZvciBhdWRpbyBvciB2aWRlby5cbiAgICAgKiBAcGFyYW0geydhdWRpbyd8J3ZpZGVvJ30ga2luZFxuICAgICAqL1xuICAgIExvY2FsTWVkaWFSZXN0YXJ0RGVmZXJyZWRzLnByb3RvdHlwZS5yZXNvbHZlRGVmZXJyZWQgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgICAgICBpZiAoa2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgdGhpcy5fYXVkaW8ucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdmlkZW8ucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgRGVmZXJyZWQgZm9yIGF1ZGlvIG9yIHZpZGVvLlxuICAgICAqIEBwYXJhbSB7J2F1ZGlvJyB8ICd2aWRlbyd9IGtpbmRcbiAgICAgKi9cbiAgICBMb2NhbE1lZGlhUmVzdGFydERlZmVycmVkcy5wcm90b3R5cGUuc3RhcnREZWZlcnJlZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgICAgIGlmIChraW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB0aGlzLl9hdWRpbyA9IGRlZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92aWRlbyA9IGRlZmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdhaXQgdW50aWwgdGhlIERlZmVycmVkIGZvciBhdWRpbyBvciB2aWRlbyBpcyByZXNvbHZlZC5cbiAgICAgKiBAcGFyYW0geydhdWRpbyd8J3ZpZGVvJ30ga2luZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIExvY2FsTWVkaWFSZXN0YXJ0RGVmZXJyZWRzLnByb3RvdHlwZS53aGVuUmVzb2x2ZWQgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgICAgICByZXR1cm4ga2luZCA9PT0gJ2F1ZGlvJyA/IHRoaXMuX2F1ZGlvLnByb21pc2UgOiB0aGlzLl92aWRlby5wcm9taXNlO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2FsTWVkaWFSZXN0YXJ0RGVmZXJyZWRzO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gbmV3IExvY2FsTWVkaWFSZXN0YXJ0RGVmZXJyZWRzKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbG1lZGlhcmVzdGFydGRlZmVycmVkcy5qcy5tYXAiLCIvKiBlc2xpbnQgbmV3LWNhcDowICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICByZXR1cm4gdG87XG59O1xudmFyIGRlZmF1bHRHZXRMb2dnZXIgPSByZXF1aXJlKCcuLi92ZW5kb3IvbG9nbGV2ZWwnKS5nZXRMb2dnZXI7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBERUZBVUxUX0xPR19MRVZFTCA9IGNvbnN0YW50cy5ERUZBVUxUX0xPR19MRVZFTCwgREVGQVVMVF9MT0dHRVJfTkFNRSA9IGNvbnN0YW50cy5ERUZBVUxUX0xPR0dFUl9OQU1FO1xudmFyIEUgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLnR5cGVFcnJvcnM7XG52YXIgZGVwcmVjYXRpb25XYXJuaW5nc0J5Q29tcG9uZW50Q29uc3RydWN0b3I7XG5mdW5jdGlvbiBnZXREZXByZWNhdGlvbldhcm5pbmdzKGNvbXBvbmVudENvbnN0cnVjdG9yKSB7XG4gICAgZGVwcmVjYXRpb25XYXJuaW5nc0J5Q29tcG9uZW50Q29uc3RydWN0b3IgPSBkZXByZWNhdGlvbldhcm5pbmdzQnlDb21wb25lbnRDb25zdHJ1Y3RvciB8fCBuZXcgTWFwKCk7XG4gICAgaWYgKGRlcHJlY2F0aW9uV2FybmluZ3NCeUNvbXBvbmVudENvbnN0cnVjdG9yLmhhcyhjb21wb25lbnRDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgcmV0dXJuIGRlcHJlY2F0aW9uV2FybmluZ3NCeUNvbXBvbmVudENvbnN0cnVjdG9yLmdldChjb21wb25lbnRDb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIHZhciBkZXByZWNhdGlvbldhcm5pbmdzID0gbmV3IFNldCgpO1xuICAgIGRlcHJlY2F0aW9uV2FybmluZ3NCeUNvbXBvbmVudENvbnN0cnVjdG9yLnNldChjb21wb25lbnRDb25zdHJ1Y3RvciwgZGVwcmVjYXRpb25XYXJuaW5ncyk7XG4gICAgcmV0dXJuIGRlcHJlY2F0aW9uV2FybmluZ3M7XG59XG4vKipcbiAqIFNlbGVjdGl2ZWx5IG91dHB1dHMgbWVzc2FnZXMgdG8gY29uc29sZSBiYXNlZCBvbiBzcGVjaWZpZWQgbWluaW11bSBtb2R1bGVcbiAqIHNwZWNpZmljIGxvZyBsZXZlbHMuXG4gKlxuICogTk9URTogVGhlIHZhbHVlcyBpbiB0aGUgbG9nTGV2ZWxzIG9iamVjdCBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIGlzIGNoYW5nZWRcbiAqICAgICAgIGJ5IHN1YnNlcXVlbnQgY2FsbHMgdG8ge0BsaW5rIExvZyNzZXRMZXZlbHN9LlxuICovXG52YXIgTG9nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyB7QGxpbmsgTG9nfSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZHVsZU5hbWUgLSBOYW1lIG9mIHRoZSBsb2dnaW5nIG1vZHVsZSAod2VicnRjL21lZGlhL3NpZ25hbGluZylcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IC0gQ29tcG9uZW50IG93bmluZyB0aGlzIGluc3RhbmNlIG9mIHtAbGluayBMb2d9XG4gICAgICogQHBhcmFtIHtMb2dMZXZlbHN9IGxvZ0xldmVscyAtIExvZ2dpbmcgbGV2ZWxzLiBTZWUge0BsaW5rIExvZ0xldmVsc31cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbG9nZ2VyTmFtZSAtIE5hbWUgb2YgdGhlIGxvZ2dlciBpbnN0YW5jZS4gVXNlZCB3aGVuIGNhbGxpbmcgZ2V0TG9nZ2VyIGZyb20gbG9nbGV2ZWwgbW9kdWxlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2dldExvZ2dlcl0gLSBvcHRpb25hbCBtZXRob2QgdXNlZCBpbnRlcm5hbGx5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZyhtb2R1bGVOYW1lLCBjb21wb25lbnQsIGxvZ0xldmVscywgbG9nZ2VyTmFtZSwgZ2V0TG9nZ2VyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IEUuSU5WQUxJRF9UWVBFKCdtb2R1bGVOYW1lJywgJ3N0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBFLlJFUVVJUkVEX0FSR1VNRU5UKCdjb21wb25lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxvZ0xldmVscyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGxvZ0xldmVscyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGdldExvZ2dlciA9IGdldExvZ2dlciB8fCBkZWZhdWx0R2V0TG9nZ2VyO1xuICAgICAgICB2YWxpZGF0ZUxvZ0xldmVscyhsb2dMZXZlbHMpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBfY29tcG9uZW50OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGNvbXBvbmVudFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sb2dMZXZlbHM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbG9nTGV2ZWxzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3dhcm5pbmdzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sb2dnZXJOYW1lOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbG9nZ2VyTmFtZSAmJiB0eXBlb2YgbG9nZ2VyTmFtZSA9PT0gJ3N0cmluZycgPyBsb2dnZXJOYW1lIDogREVGQVVMVF9MT0dHRVJfTkFNRTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9sb2dMZXZlbHNFcXVhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUgKyBcIi1cIiArIG1vZHVsZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sb2dnZXI6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ2dlciA9IGdldExvZ2dlcih0aGlzLl9sb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5fbG9nTGV2ZWxzW21vZHVsZU5hbWVdIHx8IERFRkFVTFRfTE9HX0xFVkVMO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyAnb2ZmJyBpbiB0aGUgbG9nZ2VyIG1vZHVsZS4gSXQgdXNlcyAnc2lsZW50JyBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgICAgIGxldmVsID0gbGV2ZWwgPT09ICdvZmYnID8gJ3NpbGVudCcgOiBsZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnNldERlZmF1bHRMZXZlbChsZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9sb2dMZXZlbHNFcXVhbDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnVlIGlmIGFsbCBsZXZlbHMgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmV3IFNldChPYmplY3QudmFsdWVzKHRoaXMuX2xvZ0xldmVscykpLnNpemUpID09PSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2dMZXZlbDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTG9nLmdldExldmVsQnlOYW1lKGxvZ0xldmVsc1ttb2R1bGVOYW1lXSB8fCBERUZBVUxUX0xPR19MRVZFTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHsgZ2V0OiBjb21wb25lbnQudG9TdHJpbmcuYmluZChjb21wb25lbnQpIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbG9nIGxldmVsIChudW1iZXIpIGJ5IGl0cyBuYW1lIChzdHJpbmcpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsb2cgbGV2ZWxcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXF1ZXN0ZWQgbG9nIGxldmVsXG4gICAgICogQHRocm93cyB7VHdpbGlvRXJyb3J9IElOVkFMSURfTE9HX0xFVkVMICgzMjA1NilcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTG9nLmdldExldmVsQnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKCFpc05hTihuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG5hbWUsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YWxpZGF0ZUxvZ0xldmVsKG5hbWUpO1xuICAgICAgICByZXR1cm4gTG9nW25hbWVdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY2hpbGQge0BsaW5rIExvZ30gaW5zdGFuY2Ugd2l0aCB0aGlzLl9sb2dMZXZlbHNcbiAgICAgKiBAcGFyYW0gbW9kdWxlTmFtZSAtIE5hbWUgb2YgdGhlIGxvZ2dpbmcgbW9kdWxlXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCAtIENvbXBvbmVudCBvd25pbmcgdGhpcyBpbnN0YW5jZSBvZiB7QGxpbmsgTG9nfVxuICAgICAqIEByZXR1cm5zIHtMb2d9IHRoaXNcbiAgICAgKi9cbiAgICBMb2cucHJvdG90eXBlLmNyZWF0ZUxvZyA9IGZ1bmN0aW9uIChtb2R1bGVOYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLl9sb2dnZXJOYW1lO1xuICAgICAgICAvLyBHcmFiIHRoZSBvcmlnaW5hbCBsb2dnZXIgbmFtZVxuICAgICAgICBpZiAoIXRoaXMuX2xvZ0xldmVsc0VxdWFsKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5sYXN0SW5kZXhPZignLScpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExvZyhtb2R1bGVOYW1lLCBjb21wb25lbnQsIHRoaXMuX2xvZ0xldmVscywgbmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgbmV3IGxvZyBsZXZlbHMuXG4gICAgICogVGhpcyBjaGFuZ2VzIHRoZSBsZXZlbHMgZm9yIGFsbCBpdHMgYW5jZXN0b3JzLFxuICAgICAqIHNpYmxpbmdzLCBhbmQgY2hpbGRyZW4gYW5kIGRlc2NlbmRhbnRzIGluc3RhbmNlcyBvZiB7QGxpbmsgTG9nfS5cbiAgICAgKiBAcGFyYW0ge0xvZ0xldmVsc30gbGV2ZWxzIC0gTmV3IGxvZyBsZXZlbHNcbiAgICAgKiBAdGhyb3dzIHtUd2lsaW9FcnJvcn0gSU5WQUxJRF9BUkdVTUVOVFxuICAgICAqIEByZXR1cm5zIHtMb2d9IHRoaXNcbiAgICAgKi9cbiAgICBMb2cucHJvdG90eXBlLnNldExldmVscyA9IGZ1bmN0aW9uIChsZXZlbHMpIHtcbiAgICAgICAgdmFsaWRhdGVMb2dMZXZlbHMobGV2ZWxzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9sb2dMZXZlbHMsIGxldmVscyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIGEgbWVzc2FnZSB1c2luZyB0aGUgbG9nZ2VyIG1ldGhvZCBhcHByb3ByaWF0ZSBmb3IgdGhlIHNwZWNpZmllZCBsb2dMZXZlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsb2dMZXZlbCAtIExvZyBsZXZlbCBvZiB0aGUgbWVzc2FnZSBiZWluZyBsb2dnZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtZXNzYWdlcyAtIE1lc3NhZ2UocykgdG8gbG9nXG4gICAgICogQHJldHVybnMge0xvZ30gVGhpcyBpbnN0YW5jZSBvZiB7QGxpbmsgTG9nfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBMb2cucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsb2dMZXZlbCwgbWVzc2FnZXMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBMb2cuX2xldmVsc1tsb2dMZXZlbF07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IEUuSU5WQUxJRF9WQUxVRSgnbG9nTGV2ZWwnLCBMT0dfTEVWRUxfVkFMVUVTKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgcHJlZml4ID0gW25ldyBEYXRlKCkudG9JU09TdHJpbmcoKSwgbmFtZSwgdGhpcy5uYW1lXTtcbiAgICAgICAgKHRoaXMuX2xvZ2dlcltuYW1lXSB8fCBmdW5jdGlvbiBub29wKCkgeyB9KS5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwcmVmaXguY29uY2F0KG1lc3NhZ2VzKSkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2cgYSBkZWJ1ZyBtZXNzYWdlXG4gICAgICogQHBhcmFtIHsuLi5TdHJpbmd9IG1lc3NhZ2VzIC0gTWVzc2FnZShzKSB0byBwYXNzIHRvIHRoZSBsb2dnZXJcbiAgICAgKiBAcmV0dXJucyB7TG9nfSBUaGlzIGluc3RhbmNlIG9mIHtAbGluayBMb2d9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIExvZy5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZyhMb2cuREVCVUcsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2cgYSBkZXByZWNhdGlvbiB3YXJuaW5nLiBEZXByZWNhdGlvbiB3YXJuaW5ncyBhcmUgbG9nZ2VkIGFzIHdhcm5pbmdzIGFuZFxuICAgICAqIHRoZXkgYXJlIG9ubHkgZXZlciBsb2dnZWQgb25jZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVwcmVjYXRpb25XYXJuaW5nIC0gVGhlIGRlcHJlY2F0aW9uIHdhcm5pbmdcbiAgICAgKiBAcmV0dXJucyB7TG9nfSBUaGlzIGluc3RhbmNlIG9mIHtAbGluayBMb2d9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIExvZy5wcm90b3R5cGUuZGVwcmVjYXRlZCA9IGZ1bmN0aW9uIChkZXByZWNhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgdmFyIGRlcHJlY2F0aW9uV2FybmluZ3MgPSBnZXREZXByZWNhdGlvbldhcm5pbmdzKHRoaXMuX2NvbXBvbmVudC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmIChkZXByZWNhdGlvbldhcm5pbmdzLmhhcyhkZXByZWNhdGlvbldhcm5pbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkZXByZWNhdGlvbldhcm5pbmdzLmFkZChkZXByZWNhdGlvbldhcm5pbmcpO1xuICAgICAgICByZXR1cm4gdGhpcy53YXJuKGRlcHJlY2F0aW9uV2FybmluZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2cgYW4gaW5mbyBtZXNzYWdlXG4gICAgICogQHBhcmFtIHsuLi5TdHJpbmd9IG1lc3NhZ2VzIC0gTWVzc2FnZShzKSB0byBwYXNzIHRvIHRoZSBsb2dnZXJcbiAgICAgKiBAcmV0dXJucyB7TG9nfSBUaGlzIGluc3RhbmNlIG9mIHtAbGluayBMb2d9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIExvZy5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nKExvZy5JTkZPLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIGEgd2FybiBtZXNzYWdlXG4gICAgICogQHBhcmFtIHsuLi5TdHJpbmd9IG1lc3NhZ2VzIC0gTWVzc2FnZShzKSB0byBwYXNzIHRvIHRoZSBsb2dnZXJcbiAgICAgKiBAcmV0dXJucyB7TG9nfSBUaGlzIGluc3RhbmNlIG9mIHtAbGluayBMb2d9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIExvZy5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nKExvZy5XQVJOLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIGEgd2FybmluZyBvbmNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3YXJuaW5nXG4gICAgICogQHJldHVybnMge0xvZ30gVGhpcyBpbnN0YW5jZSBvZiB7QGxpbmsgTG9nfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBMb2cucHJvdG90eXBlLndhcm5PbmNlID0gZnVuY3Rpb24gKHdhcm5pbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhcm5pbmdzLmhhcyh3YXJuaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2FybmluZ3MuYWRkKHdhcm5pbmcpO1xuICAgICAgICByZXR1cm4gdGhpcy53YXJuKHdhcm5pbmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gey4uLlN0cmluZ30gbWVzc2FnZXMgLSBNZXNzYWdlKHMpIHRvIHBhc3MgdG8gdGhlIGxvZ2dlclxuICAgICAqIEByZXR1cm5zIHtMb2d9IFRoaXMgaW5zdGFuY2Ugb2Yge0BsaW5rIExvZ31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTG9nLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nKExvZy5FUlJPUiwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZyBhbiBlcnJvciBtZXNzYWdlIGFuZCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICAgKiBAcGFyYW0ge1R3aWxpb0Vycm9yfSBlcnJvciAtIEVycm9yIHRvIHRocm93XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGN1c3RvbU1lc3NhZ2UgLSBDdXN0b20gbWVzc2FnZSBmb3IgdGhlIGVycm9yXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIExvZy5wcm90b3R5cGUudGhyb3cgPSBmdW5jdGlvbiAoZXJyb3IsIGN1c3RvbU1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGVycm9yLmNsb25lKSB7XG4gICAgICAgICAgICBlcnJvciA9IGVycm9yLmNsb25lKGN1c3RvbU1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nKExvZy5FUlJPUiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9O1xuICAgIHJldHVybiBMb2c7XG59KCkpO1xuLy8gU2luZ2xldG9uIENvbnN0YW50c1xuLyogZXNsaW50IGtleS1zcGFjaW5nOjAgKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhMb2csIHtcbiAgICBERUJVRzogeyB2YWx1ZTogMCB9LFxuICAgIElORk86IHsgdmFsdWU6IDEgfSxcbiAgICBXQVJOOiB7IHZhbHVlOiAyIH0sXG4gICAgRVJST1I6IHsgdmFsdWU6IDMgfSxcbiAgICBPRkY6IHsgdmFsdWU6IDQgfSxcbiAgICBfbGV2ZWxzOiB7XG4gICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAnREVCVUcnLFxuICAgICAgICAgICAgJ0lORk8nLFxuICAgICAgICAgICAgJ1dBUk4nLFxuICAgICAgICAgICAgJ0VSUk9SJyxcbiAgICAgICAgICAgICdPRkYnLFxuICAgICAgICBdXG4gICAgfVxufSk7XG52YXIgTE9HX0xFVkVMU19TRVQgPSB7fTtcbnZhciBMT0dfTEVWRUxfVkFMVUVTID0gW107XG52YXIgTE9HX0xFVkVMX05BTUVTID0gTG9nLl9sZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCwgaSkge1xuICAgIExPR19MRVZFTFNfU0VUW2xldmVsXSA9IHRydWU7XG4gICAgTE9HX0xFVkVMX1ZBTFVFUy5wdXNoKGkpO1xuICAgIHJldHVybiBsZXZlbDtcbn0pO1xuZnVuY3Rpb24gdmFsaWRhdGVMb2dMZXZlbChsZXZlbCkge1xuICAgIGlmICghKGxldmVsIGluIExPR19MRVZFTFNfU0VUKSkge1xuICAgICAgICB0aHJvdyBFLklOVkFMSURfVkFMVUUoJ2xldmVsJywgTE9HX0xFVkVMX05BTUVTKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUxvZ0xldmVscyhsZXZlbHMpIHtcbiAgICBPYmplY3Qua2V5cyhsZXZlbHMpLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZU5hbWUpIHtcbiAgICAgICAgdmFsaWRhdGVMb2dMZXZlbChsZXZlbHNbbW9kdWxlTmFtZV0udG9VcHBlckNhc2UoKSk7XG4gICAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IExvZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG1vdmluZyBhdmVyYWdlIGRlbHRhIGZvciB0aGUgZ2l2ZW4gcGFpciBvZnNhbXBsZXMuIEEgc2FtcGxlIChTKVxuICogY29uc2lzdHMgb2YgYSBudW1lcmF0b3IgKFNuKSBhbmQgYSBkZW5vbWluYXRvciAoU2QpLlRoZSBtb3ZpbmcgYXZlcmFnZSBkZWx0YSBpc1xuICogY2FsY3VsYXRlZCBhcyBmb2xsb3dzOlxuICpcbiAqIE1vdmluZ0F2Z0RlbHRhID0gKFNuWzFdIC0gU25bMF0pIC8gKFNkWzFdIC0gU2RbMF0pXG4gKi9cbnZhciBNb3ZpbmdBdmVyYWdlRGVsdGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTW92aW5nQXZlcmFnZURlbHRhKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBfc2FtcGxlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgZGVub21pbmF0b3I6IDAsIG51bWVyYXRvcjogMCB9LFxuICAgICAgICAgICAgICAgICAgICB7IGRlbm9taW5hdG9yOiAwLCBudW1lcmF0b3I6IDAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1vdmluZyBhdmVyYWdlIGRlbHRhLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgTW92aW5nQXZlcmFnZURlbHRhLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzYW1wbGVzID0gdGhpcy5fc2FtcGxlcztcbiAgICAgICAgdmFyIGRlbm9taW5hdG9yRGVsdGEgPSAoc2FtcGxlc1sxXS5kZW5vbWluYXRvciAtIHNhbXBsZXNbMF0uZGVub21pbmF0b3IpIHx8IEluZmluaXR5O1xuICAgICAgICB2YXIgbnVtZXJhdG9yRGVsdGEgPSBzYW1wbGVzWzFdLm51bWVyYXRvciAtIHNhbXBsZXNbMF0ubnVtZXJhdG9yO1xuICAgICAgICByZXR1cm4gbnVtZXJhdG9yRGVsdGEgLyBkZW5vbWluYXRvckRlbHRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHV0IGEgc2FtcGxlIGFuZCBnZXQgcmlkIG9mIHRoZSBvbGRlciBzYW1wbGUgdG8gbWFpbnRhaW4gc2FtcGxlIHNpemUgb2YgMi5cbiAgICAgKiBAcGFyYW0gbnVtZXJhdG9yXG4gICAgICogQHBhcmFtIGRlbm9taW5hdG9yXG4gICAgICovXG4gICAgTW92aW5nQXZlcmFnZURlbHRhLnByb3RvdHlwZS5wdXRTYW1wbGUgPSBmdW5jdGlvbiAobnVtZXJhdG9yLCBkZW5vbWluYXRvcikge1xuICAgICAgICB2YXIgc2FtcGxlcyA9IHRoaXMuX3NhbXBsZXM7XG4gICAgICAgIHNhbXBsZXMuc2hpZnQoKTtcbiAgICAgICAgc2FtcGxlcy5wdXNoKHsgZGVub21pbmF0b3I6IGRlbm9taW5hdG9yLCBudW1lcmF0b3I6IG51bWVyYXRvciB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNb3ZpbmdBdmVyYWdlRGVsdGE7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBNb3ZpbmdBdmVyYWdlRGVsdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb3ZpbmdhdmVyYWdlZGVsdGEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBNb25pdG9yIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24gc3RhdHVzIHRvIGRldGVjdCBpbnRlcnJ1cHRpb25zIGFuZCBoYW5kb2Zmcy5cbiAqL1xudmFyIE5ldHdvcmtNb25pdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBOZXR3b3JrTW9uaXRvcn0uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25OZXR3b3JrQ2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gTmV0d29ya01vbml0b3Iob25OZXR3b3JrQ2hhbmdlZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcixcbiAgICAgICAgICAgIHdpbmRvdzogd2luZG93LFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG5hdiA9IG9wdGlvbnMubmF2aWdhdG9yO1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IG5hdi5jb25uZWN0aW9uIHx8IHsgdHlwZTogbnVsbCB9O1xuICAgICAgICB2YXIgdHlwZSA9IGNvbm5lY3Rpb24udHlwZTtcbiAgICAgICAgdmFyIF9hID0gY29ubmVjdGlvbi50eXBlID8ge1xuICAgICAgICAgICAgX2V2ZW50czoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbJ2NoYW5nZScsICd0eXBlY2hhbmdlJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbGlzdGVuZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV0d29ya0NoYW5nZWQgPSB0eXBlICE9PSBfdGhpcy50eXBlICYmIF90aGlzLmlzT25saW5lO1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gX3RoaXMudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ldHdvcmtDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbk5ldHdvcmtDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RhcmdldDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjb25uZWN0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBfZXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFsnb25saW5lJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbGlzdGVuZXI6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb25OZXR3b3JrQ2hhbmdlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy53aW5kb3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgX2V2ZW50cyA9IF9hLl9ldmVudHMsIF9saXN0ZW5lciA9IF9hLl9saXN0ZW5lciwgX3RhcmdldCA9IF9hLl90YXJnZXQ7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGlzT25saW5lOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBuYXYub25MaW5lID09PSAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmF2Lm9uTGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24udHlwZSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbGlzdGVuZXI6IF9saXN0ZW5lcixcbiAgICAgICAgICAgIF9ldmVudHM6IF9ldmVudHMsXG4gICAgICAgICAgICBfdGFyZ2V0OiBfdGFyZ2V0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUge0BsaW5rIE5ldHdvcmtNb25pdG9yfS5cbiAgICAgKi9cbiAgICBOZXR3b3JrTW9uaXRvci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpcy5fbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIHtAbGluayBOZXR3b3JrTW9uaXRvcn0uXG4gICAgICovXG4gICAgTmV0d29ya01vbml0b3IucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpcy5fbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBOZXR3b3JrTW9uaXRvcjtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtNb25pdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29ya21vbml0b3IuanMubWFwIiwiLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBOdWxsT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVsbE9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIF9jYWxsYmFjazoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjYWxsYmFja1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgTnVsbE9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgTnVsbE9ic2VydmVyLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICBOdWxsT2JzZXJ2ZXIucHJvdG90eXBlLm1ha2VWaXNpYmxlID0gZnVuY3Rpb24gKHZpZGVvRWwpIHtcbiAgICAgICAgdmFyIHZpc2libGVFbnRyeSA9IHRoaXMuX21ha2VGYWtlRW50cnkodmlkZW9FbCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrKFt2aXNpYmxlRW50cnldKTtcbiAgICB9O1xuICAgIE51bGxPYnNlcnZlci5wcm90b3R5cGUubWFrZUludmlzaWJsZSA9IGZ1bmN0aW9uICh2aWRlb0VsKSB7XG4gICAgICAgIHZhciBpbnZpc2libGVFbnRyeSA9IHRoaXMuX21ha2VGYWtlRW50cnkodmlkZW9FbCwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9jYWxsYmFjayhbaW52aXNpYmxlRW50cnldKTtcbiAgICB9O1xuICAgIE51bGxPYnNlcnZlci5wcm90b3R5cGUuX21ha2VGYWtlRW50cnkgPSBmdW5jdGlvbiAodmlkZW9FbGVtZW50LCBpc0ludGVyc2VjdGluZykge1xuICAgICAgICByZXR1cm4geyB0YXJnZXQ6IHZpZGVvRWxlbWVudCwgaXNJbnRlcnNlY3Rpbmc6IGlzSW50ZXJzZWN0aW5nIH07XG4gICAgfTtcbiAgICByZXR1cm4gTnVsbE9ic2VydmVyO1xufSgpKTtcbnZhciBOdWxsSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE51bGxJbnRlcnNlY3Rpb25PYnNlcnZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOdWxsSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE51bGxJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbn0oTnVsbE9ic2VydmVyKSk7XG52YXIgTnVsbFJlc2l6ZU9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOdWxsUmVzaXplT2JzZXJ2ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTnVsbFJlc2l6ZU9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE51bGxSZXNpemVPYnNlcnZlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHZpZGVvRWwpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fbWFrZUZha2VFbnRyeSh2aWRlb0VsLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2soW2VudHJ5XSk7XG4gICAgfTtcbiAgICByZXR1cm4gTnVsbFJlc2l6ZU9ic2VydmVyO1xufShOdWxsT2JzZXJ2ZXIpKTtcbm1vZHVsZS5leHBvcnRzID0geyBOdWxsSW50ZXJzZWN0aW9uT2JzZXJ2ZXI6IE51bGxJbnRlcnNlY3Rpb25PYnNlcnZlciwgTnVsbFJlc2l6ZU9ic2VydmVyOiBOdWxsUmVzaXplT2JzZXJ2ZXIsIE51bGxPYnNlcnZlcjogTnVsbE9ic2VydmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsb2JzZXJ2ZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9hID0gcmVxdWlyZSgnLi4vJyksIGRpZmZlcmVuY2UgPSBfYS5kaWZmZXJlbmNlLCBmbGF0TWFwID0gX2EuZmxhdE1hcDtcbnZhciBzZXRTaW11bGNhc3RJbk1lZGlhU2VjdGlvbiA9IHJlcXVpcmUoJy4vc2ltdWxjYXN0Jyk7XG52YXIgcHRUb0ZpeGVkQml0cmF0ZUF1ZGlvQ29kZWNOYW1lID0ge1xuICAgIDA6ICdQQ01VJyxcbiAgICA4OiAnUENNQSdcbn07XG4vKipcbiAqIEEgcGF5bG9hZCB0eXBlXG4gKiBAdHlwZWRlZiB7bnVtYmVyfSBQVFxuICovXG4vKipcbiAqIEFuIHtAbGluayBBdWRpb0NvZGVjfSBvciB7QGxpbmsgVmlkZW9Db2RlY31cbiAqIEB0eXBlZGVmIHtBdWRpb0NvZGVjfFZpZGVvQ29kZWN9IENvZGVjXG4gKi9cbi8vIE5PVEUobW1hbGF2YWxsaSk6IFRoaXMgdmFsdWUgaXMgZGVyaXZlZCBmcm9tIHRoZSBJRVRGIHNwZWNcbi8vIGZvciBKU0VQLCBhbmQgaXQgaXMgdXNlZCB0byBjb252ZXJ0IGEgJ2I9VElBUycgdmFsdWUgaW4gYnBzXG4vLyB0byBhICdiPUFTJyB2YWx1ZSBpbiBrYnBzLlxuLy8gU3BlYzogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtcnRjd2ViLWpzZXAtMjEjc2VjdGlvbi01LjlcbnZhciBSVENQX0JJVFJBVEUgPSAxNjAwMDtcbi8qKlxuICogQ29uc3RydWN0IGEgYj0gbGluZSBzdHJpbmcgZm9yIHRoZSBnaXZlbiBtYXggYml0cmF0ZSBpbiBicHMuIElmIHRoZSBtb2RpZmllclxuICogaXMgJ0FTJywgdGhlbiB0aGUgbWF4IGJpdHJhdGUgd2lsbCBiZSBjb252ZXJ0ZWQgdG8ga2JwcyB1c2luZyB0aGUgZm9ybXVsYVxuICogc3BlY2lmaWVkIGluIHRoZSBJRVRGIHNwZWMgZm9yIEpTRVAgbWVudGlvbmVkIGFib3ZlLlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZGlmaWVyIC0gJ0FTJyB8ICdUSUFTJ1xuICogQHBhcmFtIHs/bnVtYmVyfSBtYXhCaXRyYXRlIC0gTWF4IG91dGdvaW5nIGJpdHJhdGUgKGJwcylcbiAqIEByZXR1cm5zIHs/c3RyaW5nfSAtIElmIFwibWF4Qml0cmF0ZVwiIGlzIG51bGwsIHRoZW4gcmV0dXJucyBudWxsO1xuICogICBvdGhlcndpc2UgcmV0dXJuIHRoZSBjb25zdHJ1Y3RlZCBiPSBsaW5lIHN0cmluZ1xuICovXG5mdW5jdGlvbiBjcmVhdGVCTGluZShtb2RpZmllciwgbWF4Qml0cmF0ZSkge1xuICAgIGlmICghbWF4Qml0cmF0ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxyXFxuYj1cIiArIG1vZGlmaWVyICsgXCI6XCIgKyAobW9kaWZpZXIgPT09ICdBUydcbiAgICAgICAgPyBNYXRoLnJvdW5kKChtYXhCaXRyYXRlICsgUlRDUF9CSVRSQVRFKSAvIDk1MClcbiAgICAgICAgOiBtYXhCaXRyYXRlKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgQ29kZWMgTWFwIGZvciB0aGUgZ2l2ZW4gbT0gc2VjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uIC0gVGhlIGdpdmVuIG09IHNlY3Rpb25cbiAqIEByZXR1cm5zIHtNYXA8Q29kZWMsIEFycmF5PFBUPj59XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvZGVjTWFwRm9yTWVkaWFTZWN0aW9uKHNlY3Rpb24pIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShjcmVhdGVQdFRvQ29kZWNOYW1lKHNlY3Rpb24pKS5yZWR1Y2UoZnVuY3Rpb24gKGNvZGVjTWFwLCBwYWlyKSB7XG4gICAgICAgIHZhciBwdCA9IHBhaXJbMF07XG4gICAgICAgIHZhciBjb2RlY05hbWUgPSBwYWlyWzFdO1xuICAgICAgICB2YXIgcHRzID0gY29kZWNNYXAuZ2V0KGNvZGVjTmFtZSkgfHwgW107XG4gICAgICAgIHJldHVybiBjb2RlY01hcC5zZXQoY29kZWNOYW1lLCBwdHMuY29uY2F0KHB0KSk7XG4gICAgfSwgbmV3IE1hcCgpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgTWFwIG9mIE1JRHMgdG8gbT0gc2VjdGlvbnMgZm9yIHRoZSBnaXZlbiBTRFAuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWlkVG9NZWRpYVNlY3Rpb25NYXAoc2RwKSB7XG4gICAgcmV0dXJuIGdldE1lZGlhU2VjdGlvbnMoc2RwKS5yZWR1Y2UoZnVuY3Rpb24gKG1pZHNUb01lZGlhU2VjdGlvbnMsIG1lZGlhU2VjdGlvbikge1xuICAgICAgICB2YXIgbWlkID0gZ2V0TWlkRm9yTWVkaWFTZWN0aW9uKG1lZGlhU2VjdGlvbik7XG4gICAgICAgIHJldHVybiBtaWQgPyBtaWRzVG9NZWRpYVNlY3Rpb25zLnNldChtaWQsIG1lZGlhU2VjdGlvbikgOiBtaWRzVG9NZWRpYVNlY3Rpb25zO1xuICAgIH0sIG5ldyBNYXAoKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIE1hcCBmcm9tIFBUcyB0byBjb2RlYyBuYW1lcyBmb3IgdGhlIGdpdmVuIG09IHNlY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVkaWFTZWN0aW9uIC0gVGhlIGdpdmVuIG09IHNlY3Rpb24uXG4gKiBAcmV0dXJucyB7TWFwPFBULCBDb2RlYz59IHB0VG9Db2RlY05hbWVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHRUb0NvZGVjTmFtZShtZWRpYVNlY3Rpb24pIHtcbiAgICByZXR1cm4gZ2V0UGF5bG9hZFR5cGVzSW5NZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKS5yZWR1Y2UoZnVuY3Rpb24gKHB0VG9Db2RlY05hbWUsIHB0KSB7XG4gICAgICAgIHZhciBydHBtYXBQYXR0ZXJuID0gbmV3IFJlZ0V4cChcImE9cnRwbWFwOlwiICsgcHQgKyBcIiAoW14vXSspXCIpO1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IG1lZGlhU2VjdGlvbi5tYXRjaChydHBtYXBQYXR0ZXJuKTtcbiAgICAgICAgdmFyIGNvZGVjTmFtZSA9IG1hdGNoZXNcbiAgICAgICAgICAgID8gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICA6IHB0VG9GaXhlZEJpdHJhdGVBdWRpb0NvZGVjTmFtZVtwdF1cbiAgICAgICAgICAgICAgICA/IHB0VG9GaXhlZEJpdHJhdGVBdWRpb0NvZGVjTmFtZVtwdF0udG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgIHJldHVybiBwdFRvQ29kZWNOYW1lLnNldChwdCwgY29kZWNOYW1lKTtcbiAgICB9LCBuZXcgTWFwKCkpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGFzc29jaWF0ZWQgZm10cCBhdHRyaWJ1dGVzIGZvciB0aGUgZ2l2ZW4gUGF5bG9hZCBUeXBlIGluIGFuIG09IHNlY3Rpb24uXG4gKiBAcGFyYW0ge1BUfSBwdFxuICogQHBhcmFtIHtzdHJpbmd9IG1lZGlhU2VjdGlvblxuICogQHJldHVybnMgez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldEZtdHBBdHRyaWJ1dGVzRm9yUHQocHQsIG1lZGlhU2VjdGlvbikge1xuICAgIC8vIEluIFwiYT1mbXRwOjxwdD4gPG5hbWU+PTx2YWx1ZT5bOzxuYW1lPj08dmFsdWU+XSpcIiwgdGhlIHJlZ2V4IG1hdGNoZXMgdGhlIGNvZGVjXG4gICAgLy8gcHJvZmlsZSBwYXJhbWV0ZXJzIGV4cHJlc3NlZCBhcyBuYW1lL3ZhbHVlIHBhaXJzIHNlcGFyYXRlZCBieSBcIjtcIi5cbiAgICB2YXIgZm10cFJlZ2V4ID0gbmV3IFJlZ0V4cChcIl5hPWZtdHA6XCIgKyBwdCArIFwiICguKykkXCIsICdtJyk7XG4gICAgdmFyIG1hdGNoZXMgPSBtZWRpYVNlY3Rpb24ubWF0Y2goZm10cFJlZ2V4KTtcbiAgICByZXR1cm4gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdLnNwbGl0KCc7JykucmVkdWNlKGZ1bmN0aW9uIChhdHRycywgbnZQYWlyKSB7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChudlBhaXIuc3BsaXQoJz0nKSwgMiksIG5hbWUgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcbiAgICAgICAgYXR0cnNbbmFtZV0gPSBpc05hTih2YWx1ZSkgPyB2YWx1ZSA6IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgIHJldHVybiBhdHRycztcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqIEdldCB0aGUgTUlEIGZvciB0aGUgZ2l2ZW4gbT0gc2VjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZWRpYVNlY3Rpb25cbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldE1pZEZvck1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgICAvLyBJbiBcImE9bWlkOjxtaWQ+XCIsIHRoZSByZWdleCBtYXRjaGVzIDxtaWQ+LlxuICAgIHZhciBtaWRNYXRjaGVzID0gbWVkaWFTZWN0aW9uLm1hdGNoKC9eYT1taWQ6KC4rKSQvbSk7XG4gICAgcmV0dXJuIG1pZE1hdGNoZXMgJiYgbWlkTWF0Y2hlc1sxXTtcbn1cbi8qKlxuICogR2V0IHRoZSBtPSBzZWN0aW9ucyBvZiBhIHBhcnRpY3VsYXIga2luZCBhbmQgZGlyZWN0aW9uIGZyb20gYW4gc2RwLlxuICogQHBhcmFtIHtzdHJpbmd9IHNkcCAtIFNEUCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBba2luZF0gLSBQYXR0ZXJuIGZvciBtYXRjaGluZyBraW5kXG4gKiBAcGFyYW0ge3N0cmluZ30gW2RpcmVjdGlvbl0gLSBQYXR0ZXJuIGZvciBtYXRjaGluZyBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBtZWRpYVNlY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGdldE1lZGlhU2VjdGlvbnMoc2RwLCBraW5kLCBkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gc2RwLnJlcGxhY2UoL1xcclxcblxcclxcbiQvLCAnXFxyXFxuJykuc3BsaXQoJ1xcclxcbm09Jykuc2xpY2UoMSkubWFwKGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHsgcmV0dXJuIFwibT1cIiArIG1lZGlhU2VjdGlvbjsgfSkuZmlsdGVyKGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgdmFyIGtpbmRQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIm09XCIgKyAoa2luZCB8fCAnLionKSwgJ2dtJyk7XG4gICAgICAgIHZhciBkaXJlY3Rpb25QYXR0ZXJuID0gbmV3IFJlZ0V4cChcImE9XCIgKyAoZGlyZWN0aW9uIHx8ICcuKicpLCAnZ20nKTtcbiAgICAgICAgcmV0dXJuIGtpbmRQYXR0ZXJuLnRlc3QobWVkaWFTZWN0aW9uKSAmJiBkaXJlY3Rpb25QYXR0ZXJuLnRlc3QobWVkaWFTZWN0aW9uKTtcbiAgICB9KTtcbn1cbi8qKlxuICogR2V0IHRoZSBDb2RlYyBQYXlsb2FkIFR5cGVzIHByZXNlbnQgaW4gdGhlIGZpcnN0IGxpbmUgb2YgdGhlIGdpdmVuIG09IHNlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uIC0gVGhlIG09IHNlY3Rpb25cbiAqIEByZXR1cm5zIHtBcnJheTxQVD59IFBheWxvYWQgVHlwZXNcbiAqL1xuZnVuY3Rpb24gZ2V0UGF5bG9hZFR5cGVzSW5NZWRpYVNlY3Rpb24oc2VjdGlvbikge1xuICAgIHZhciBtTGluZSA9IHNlY3Rpb24uc3BsaXQoJ1xcclxcbicpWzBdO1xuICAgIC8vIEluIFwibT08a2luZD4gPHBvcnQ+IDxwcm90bz4gPHBheWxvYWRfdHlwZV8xPiA8cGF5bG9hZF90eXBlXzI+IC4uLiA8cGF5bG9hZF90eXBlX24+XCIsXG4gICAgLy8gdGhlIHJlZ2V4IG1hdGNoZXMgPHBvcnQ+IGFuZCB0aGUgUGF5bG9hZCBUeXBlcy5cbiAgICB2YXIgbWF0Y2hlcyA9IG1MaW5lLm1hdGNoKC8oWzAtOV0rKS9nKTtcbiAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBidXQgaW4gY2FzZSB0aGVyZSBhcmUgbm8gUGF5bG9hZCBUeXBlcyBpblxuICAgIC8vIHRoZSBtPSBsaW5lLCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuXG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLy8gU2luY2Ugb25seSB0aGUgUGF5bG9hZCBUeXBlcyBhcmUgbmVlZGVkLCB3ZSBkaXNjYXJkIHRoZSA8cG9ydD4uXG4gICAgcmV0dXJuIG1hdGNoZXMuc2xpY2UoMSkubWFwKGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gcGFyc2VJbnQobWF0Y2gsIDEwKTsgfSk7XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgcmVvcmRlcmVkIENvZGVjIFBheWxvYWQgVHlwZXMgYmFzZWQgb24gdGhlIHByZWZlcnJlZCBDb2RlYyBOYW1lcy5cbiAqIEBwYXJhbSB7TWFwPENvZGVjLCBBcnJheTxQVD4+fSBjb2RlY01hcCAtIENvZGVjIE1hcFxuICogQHBhcmFtIHtBcnJheTxBdWRpb0NvZGVjU2V0dGluZ3N8VmlkZW9Db2RlY1NldHRpbmdzPn0gcHJlZmVycmVkQ29kZWNzIC0gUHJlZmVycmVkIENvZGVjc1xuICogQHJldHVybnMge0FycmF5PFBUPn0gUmVvcmRlcmVkIFBheWxvYWQgVHlwZXNcbiAqL1xuZnVuY3Rpb24gZ2V0UmVvcmRlcmVkUGF5bG9hZFR5cGVzKGNvZGVjTWFwLCBwcmVmZXJyZWRDb2RlY3MpIHtcbiAgICBwcmVmZXJyZWRDb2RlY3MgPSBwcmVmZXJyZWRDb2RlY3MubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29kZWMgPSBfYS5jb2RlYztcbiAgICAgICAgcmV0dXJuIGNvZGVjLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgdmFyIHByZWZlcnJlZFBheWxvYWRUeXBlcyA9IGZsYXRNYXAocHJlZmVycmVkQ29kZWNzLCBmdW5jdGlvbiAoY29kZWNOYW1lKSB7IHJldHVybiBjb2RlY01hcC5nZXQoY29kZWNOYW1lKSB8fCBbXTsgfSk7XG4gICAgdmFyIHJlbWFpbmluZ0NvZGVjcyA9IGRpZmZlcmVuY2UoQXJyYXkuZnJvbShjb2RlY01hcC5rZXlzKCkpLCBwcmVmZXJyZWRDb2RlY3MpO1xuICAgIHZhciByZW1haW5pbmdQYXlsb2FkVHlwZXMgPSBmbGF0TWFwKHJlbWFpbmluZ0NvZGVjcywgZnVuY3Rpb24gKGNvZGVjTmFtZSkgeyByZXR1cm4gY29kZWNNYXAuZ2V0KGNvZGVjTmFtZSk7IH0pO1xuICAgIHJldHVybiBwcmVmZXJyZWRQYXlsb2FkVHlwZXMuY29uY2F0KHJlbWFpbmluZ1BheWxvYWRUeXBlcyk7XG59XG4vKipcbiAqIFNldCB0aGUgc3BlY2lmaWVkIG1heCBiaXRyYXRlIGluIHRoZSBnaXZlbiBtPSBzZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZGlmaWVyIC0gJ0FTJyB8ICdUSUFTJ1xuICogQHBhcmFtIHs/bnVtYmVyfSBtYXhCaXRyYXRlIC0gTWF4IG91dGdvaW5nIGJpdHJhdGUgKGJwcylcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uIC0gbT0gc2VjdGlvbiBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB1cGRhdGVkIG09IHNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gc2V0Qml0cmF0ZUluTWVkaWFTZWN0aW9uKG1vZGlmaWVyLCBtYXhCaXRyYXRlLCBzZWN0aW9uKSB7XG4gICAgdmFyIGJMaW5lID0gY3JlYXRlQkxpbmUobW9kaWZpZXIsIG1heEJpdHJhdGUpIHx8ICcnO1xuICAgIHZhciBiTGluZVBhdHRlcm4gPSAvXFxyXFxuYj0oQVN8VElBUyk6KFswLTldKykvO1xuICAgIHZhciBiTGluZU1hdGNoZWQgPSBzZWN0aW9uLm1hdGNoKGJMaW5lUGF0dGVybik7XG4gICAgaWYgKCFiTGluZU1hdGNoZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb24ucmVwbGFjZSgvKFxcclxcbik/JC8sIGJMaW5lICsgXCIkMVwiKTtcbiAgICB9XG4gICAgdmFyIG1heEJpdHJhdGVNYXRjaGVkID0gcGFyc2VJbnQoYkxpbmVNYXRjaGVkWzJdLCAxMCk7XG4gICAgbWF4Qml0cmF0ZSA9IG1heEJpdHJhdGUgfHwgSW5maW5pdHk7XG4gICAgYkxpbmUgPSBjcmVhdGVCTGluZShtb2RpZmllciwgTWF0aC5taW4obWF4Qml0cmF0ZU1hdGNoZWQsIG1heEJpdHJhdGUpKTtcbiAgICByZXR1cm4gc2VjdGlvbi5yZXBsYWNlKGJMaW5lUGF0dGVybiwgYkxpbmUpO1xufVxuLyoqXG4gKiBTZXQgbWF4aW11bSBiaXRyYXRlcyB0byB0aGUgbWVkaWEgc2VjdGlvbnMgaW4gYSBnaXZlbiBzZHAuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwIC0gc2RwIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IG1vZGlmaWVyIC0gJ0FTJyB8ICdUSUFTXCJcbiAqIEBwYXJhbSB7P251bWJlcn0gbWF4QXVkaW9CaXRyYXRlIC0gTWF4IG91dGdvaW5nIGF1ZGlvIGJpdHJhdGUgKGJwcyksIG51bGxcbiAqICAgaWYgbm8gbGltaXQgaXMgdG8gYmUgYXBwbGllZFxuICogQHBhcmFtIHs/bnVtYmVyfSBtYXhWaWRlb0JpdHJhdGUgLSBNYXggb3V0Z29pbmcgdmlkZW8gYml0cmF0ZSAoYnBzKSwgbnVsbFxuICogICBpZiBubyBsaW1pdCBpcyB0byBiZSBhcHBsaWVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSB1cGRhdGVkIHNkcCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gc2V0Qml0cmF0ZVBhcmFtZXRlcnMoc2RwLCBtb2RpZmllciwgbWF4QXVkaW9CaXRyYXRlLCBtYXhWaWRlb0JpdHJhdGUpIHtcbiAgICB2YXIgbWVkaWFTZWN0aW9ucyA9IGdldE1lZGlhU2VjdGlvbnMoc2RwKTtcbiAgICB2YXIgc2Vzc2lvbiA9IHNkcC5zcGxpdCgnXFxyXFxubT0nKVswXTtcbiAgICByZXR1cm4gW3Nlc3Npb25dLmNvbmNhdChtZWRpYVNlY3Rpb25zLm1hcChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICAvLyBCaXRyYXRlIHBhcmFtZXRlcnMgc2hvdWxkIG5vdCBiZSBhcHBsaWVkIHRvIG09YXBwbGljYXRpb24gc2VjdGlvbnNcbiAgICAgICAgLy8gb3IgdG8gbT0oYXVkaW98dmlkZW8pIHNlY3Rpb25zIHRoYXQgZG8gbm90IHJlY2VpdmUgbWVkaWEuXG4gICAgICAgIGlmICghL15tPShhdWRpb3x2aWRlbykvLnRlc3Qoc2VjdGlvbikgfHwgIS9hPShyZWN2b25seXxzZW5kcmVjdikvLnRlc3Qoc2VjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBraW5kID0gc2VjdGlvbi5tYXRjaCgvXm09KGF1ZGlvfHZpZGVvKS8pWzFdO1xuICAgICAgICB2YXIgbWF4Qml0cmF0ZSA9IGtpbmQgPT09ICdhdWRpbycgPyBtYXhBdWRpb0JpdHJhdGUgOiBtYXhWaWRlb0JpdHJhdGU7XG4gICAgICAgIHJldHVybiBzZXRCaXRyYXRlSW5NZWRpYVNlY3Rpb24obW9kaWZpZXIsIG1heEJpdHJhdGUsIHNlY3Rpb24pO1xuICAgIH0pKS5qb2luKCdcXHJcXG4nKTtcbn1cbi8qKlxuICogU2V0IHRoZSBnaXZlbiBDb2RlYyBQYXlsb2FkIFR5cGVzIGluIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBnaXZlbiBtPSBzZWN0aW9uLlxuICogQHBhcmFtIHtBcnJheTxQVD59IHBheWxvYWRUeXBlcyAtIFBheWxvYWQgVHlwZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uIC0gR2l2ZW4gbT0gc2VjdGlvblxuICogQHJldHVybnMge3N0cmluZ30gLSBVcGRhdGVkIG09IHNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gc2V0UGF5bG9hZFR5cGVzSW5NZWRpYVNlY3Rpb24ocGF5bG9hZFR5cGVzLCBzZWN0aW9uKSB7XG4gICAgdmFyIGxpbmVzID0gc2VjdGlvbi5zcGxpdCgnXFxyXFxuJyk7XG4gICAgdmFyIG1MaW5lID0gbGluZXNbMF07XG4gICAgdmFyIG90aGVyTGluZXMgPSBsaW5lcy5zbGljZSgxKTtcbiAgICBtTGluZSA9IG1MaW5lLnJlcGxhY2UoLyhbMC05XStcXHM/KSskLywgcGF5bG9hZFR5cGVzLmpvaW4oJyAnKSk7XG4gICAgcmV0dXJuIFttTGluZV0uY29uY2F0KG90aGVyTGluZXMpLmpvaW4oJ1xcclxcbicpO1xufVxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgU0RQIHN0cmluZyB3aXRoIHRoZSByZS1vcmRlcmVkIGNvZGVjIHByZWZlcmVuY2VzLlxuICogQHBhcmFtIHtzdHJpbmd9IHNkcFxuICogQHBhcmFtIHtBcnJheTxBdWRpb0NvZGVjPn0gcHJlZmVycmVkQXVkaW9Db2RlY3MgLSBJZiBlbXB0eSwgdGhlIGV4aXN0aW5nIG9yZGVyXG4gKiAgIG9mIGF1ZGlvIGNvZGVjcyBpcyBwcmVzZXJ2ZWRcbiAqIEBwYXJhbSB7QXJyYXk8VmlkZW9Db2RlY1NldHRpbmdzPn0gcHJlZmVycmVkVmlkZW9Db2RlY3MgLSBJZiBlbXB0eSwgdGhlXG4gKiAgIGV4aXN0aW5nIG9yZGVyIG9mIHZpZGVvIGNvZGVjcyBpcyBwcmVzZXJ2ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVwZGF0ZWQgU0RQIHN0cmluZ1xuICovXG5mdW5jdGlvbiBzZXRDb2RlY1ByZWZlcmVuY2VzKHNkcCwgcHJlZmVycmVkQXVkaW9Db2RlY3MsIHByZWZlcnJlZFZpZGVvQ29kZWNzKSB7XG4gICAgdmFyIG1lZGlhU2VjdGlvbnMgPSBnZXRNZWRpYVNlY3Rpb25zKHNkcCk7XG4gICAgdmFyIHNlc3Npb24gPSBzZHAuc3BsaXQoJ1xcclxcbm09JylbMF07XG4gICAgcmV0dXJuIFtzZXNzaW9uXS5jb25jYXQobWVkaWFTZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgICAgICAgLy8gQ29kZWMgcHJlZmVyZW5jZXMgc2hvdWxkIG5vdCBiZSBhcHBsaWVkIHRvIG09YXBwbGljYXRpb24gc2VjdGlvbnMuXG4gICAgICAgIGlmICghL15tPShhdWRpb3x2aWRlbykvLnRlc3Qoc2VjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBraW5kID0gc2VjdGlvbi5tYXRjaCgvXm09KGF1ZGlvfHZpZGVvKS8pWzFdO1xuICAgICAgICB2YXIgY29kZWNNYXAgPSBjcmVhdGVDb2RlY01hcEZvck1lZGlhU2VjdGlvbihzZWN0aW9uKTtcbiAgICAgICAgdmFyIHByZWZlcnJlZENvZGVjcyA9IGtpbmQgPT09ICdhdWRpbycgPyBwcmVmZXJyZWRBdWRpb0NvZGVjcyA6IHByZWZlcnJlZFZpZGVvQ29kZWNzO1xuICAgICAgICB2YXIgcGF5bG9hZFR5cGVzID0gZ2V0UmVvcmRlcmVkUGF5bG9hZFR5cGVzKGNvZGVjTWFwLCBwcmVmZXJyZWRDb2RlY3MpO1xuICAgICAgICB2YXIgbmV3U2VjdGlvbiA9IHNldFBheWxvYWRUeXBlc0luTWVkaWFTZWN0aW9uKHBheWxvYWRUeXBlcywgc2VjdGlvbik7XG4gICAgICAgIHZhciBwY21hUGF5bG9hZFR5cGVzID0gY29kZWNNYXAuZ2V0KCdwY21hJykgfHwgW107XG4gICAgICAgIHZhciBwY211UGF5bG9hZFR5cGVzID0gY29kZWNNYXAuZ2V0KCdwY211JykgfHwgW107XG4gICAgICAgIHZhciBmaXhlZEJpdHJhdGVQYXlsb2FkVHlwZXMgPSBraW5kID09PSAnYXVkaW8nXG4gICAgICAgICAgICA/IG5ldyBTZXQocGNtYVBheWxvYWRUeXBlcy5jb25jYXQocGNtdVBheWxvYWRUeXBlcykpXG4gICAgICAgICAgICA6IG5ldyBTZXQoKTtcbiAgICAgICAgcmV0dXJuIGZpeGVkQml0cmF0ZVBheWxvYWRUeXBlcy5oYXMocGF5bG9hZFR5cGVzWzBdKVxuICAgICAgICAgICAgPyBuZXdTZWN0aW9uLnJlcGxhY2UoL1xcclxcbmI9KEFTfFRJQVMpOihbMC05XSspL2csICcnKVxuICAgICAgICAgICAgOiBuZXdTZWN0aW9uO1xuICAgIH0pKS5qb2luKCdcXHJcXG4nKTtcbn1cbi8qKlxuICogUmV0dXJuIGEgbmV3IFNEUCBzdHJpbmcgd2l0aCBzaW11bGNhc3Qgc2V0dGluZ3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwXG4gKiBAcGFyYW0geydwbGFuYicgfCAndW5pZmllZCd9IHNkcEZvcm1hdFxuICogQHBhcmFtIHtNYXA8VHJhY2suSUQsIFRyYWNrQXR0cmlidXRlcz59IHRyYWNrSWRzVG9BdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBVcGRhdGVkIFNEUCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gc2V0U2ltdWxjYXN0KHNkcCwgc2RwRm9ybWF0LCB0cmFja0lkc1RvQXR0cmlidXRlcykge1xuICAgIHZhciBtZWRpYVNlY3Rpb25zID0gZ2V0TWVkaWFTZWN0aW9ucyhzZHApO1xuICAgIHZhciBzZXNzaW9uID0gc2RwLnNwbGl0KCdcXHJcXG5tPScpWzBdO1xuICAgIHJldHVybiBbc2Vzc2lvbl0uY29uY2F0KG1lZGlhU2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgIHNlY3Rpb24gPSBzZWN0aW9uLnJlcGxhY2UoL1xcclxcbiQvLCAnJyk7XG4gICAgICAgIGlmICghL15tPXZpZGVvLy50ZXN0KHNlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29kZWNNYXAgPSBjcmVhdGVDb2RlY01hcEZvck1lZGlhU2VjdGlvbihzZWN0aW9uKTtcbiAgICAgICAgdmFyIHBheWxvYWRUeXBlcyA9IGdldFBheWxvYWRUeXBlc0luTWVkaWFTZWN0aW9uKHNlY3Rpb24pO1xuICAgICAgICB2YXIgdnA4UGF5bG9hZFR5cGVzID0gbmV3IFNldChjb2RlY01hcC5nZXQoJ3ZwOCcpIHx8IFtdKTtcbiAgICAgICAgdmFyIGhhc1ZQOFBheWxvYWRUeXBlID0gcGF5bG9hZFR5cGVzLnNvbWUoZnVuY3Rpb24gKHBheWxvYWRUeXBlKSB7IHJldHVybiB2cDhQYXlsb2FkVHlwZXMuaGFzKHBheWxvYWRUeXBlKTsgfSk7XG4gICAgICAgIHJldHVybiBoYXNWUDhQYXlsb2FkVHlwZVxuICAgICAgICAgICAgPyBzZXRTaW11bGNhc3RJbk1lZGlhU2VjdGlvbihzZWN0aW9uLCBzZHBGb3JtYXQsIHRyYWNrSWRzVG9BdHRyaWJ1dGVzKVxuICAgICAgICAgICAgOiBzZWN0aW9uO1xuICAgIH0pKS5jb25jYXQoJycpLmpvaW4oJ1xcclxcbicpO1xufVxuLyoqXG4gKiBHZXQgdGhlIG1hdGNoaW5nIFBheWxvYWQgVHlwZXMgaW4gYSB1bmlmaWVkIHBsYW4gbT0gc2VjdGlvbiBmb3IgYSBwYXJ0aWN1bGFyIHBlZXIgY29kZWMuXG4gKiBAcGFyYW0ge0NvZGVjfSBwZWVyQ29kZWNcbiAqIEBwYXJhbSB7UFR9IHBlZXJQdFxuICogQHBhcmFtIHtNYXA8Q29kZWMsIFBUPn0gY29kZWNzVG9QdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGVlclNlY3Rpb25cbiAqIEByZXR1cm5zIHtBcnJheTxQVD59XG4gKi9cbmZ1bmN0aW9uIHVuaWZpZWRQbGFuR2V0TWF0Y2hpbmdQYXlsb2FkVHlwZXMocGVlckNvZGVjLCBwZWVyUHQsIGNvZGVjc1RvUHRzLCBzZWN0aW9uLCBwZWVyU2VjdGlvbikge1xuICAgIC8vIElmIHRoZXJlIGlzIGF0IG1vc3Qgb25lIGxvY2FsIFBheWxvYWQgVHlwZSB0aGF0IG1hdGNoZXMgdGhlIHJlbW90ZSBjb2RlYywgcmV0YWluIGl0LlxuICAgIHZhciBtYXRjaGluZ1B0cyA9IGNvZGVjc1RvUHRzLmdldChwZWVyQ29kZWMpIHx8IFtdO1xuICAgIGlmIChtYXRjaGluZ1B0cy5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hpbmdQdHM7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBmbXRwIGF0dHJpYnV0ZXMgZm9yIHRoZSBjb2RlYyBpbiB0aGUgcGVlciBtPSBzZWN0aW9uLCB0aGVuIHdlXG4gICAgLy8gY2Fubm90IGdldCBhIG1hdGNoIGluIHRoZSAgbT0gc2VjdGlvbi4gSW4gdGhhdCBjYXNlLCByZXRhaW4gYWxsIG1hdGNoaW5nIFBheWxvYWRcbiAgICAvLyBUeXBlcy5cbiAgICB2YXIgcGVlckZtdHBBdHRycyA9IGdldEZtdHBBdHRyaWJ1dGVzRm9yUHQocGVlclB0LCBwZWVyU2VjdGlvbik7XG4gICAgaWYgKCFwZWVyRm10cEF0dHJzKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGluZ1B0cztcbiAgICB9XG4gICAgLy8gQW1vbmcgdGhlIG1hdGNoZWQgbG9jYWwgUGF5bG9hZCBUeXBlcywgZmluZCB0aGUgb25lIHRoYXQgbWF0Y2hlcyB0aGUgcmVtb3RlXG4gICAgLy8gZm10cCBhdHRyaWJ1dGVzLlxuICAgIHZhciBtYXRjaGluZ1B0ID0gbWF0Y2hpbmdQdHMuZmluZChmdW5jdGlvbiAocHQpIHtcbiAgICAgICAgdmFyIGZtdHBBdHRycyA9IGdldEZtdHBBdHRyaWJ1dGVzRm9yUHQocHQsIHNlY3Rpb24pO1xuICAgICAgICByZXR1cm4gZm10cEF0dHJzICYmIE9iamVjdC5rZXlzKHBlZXJGbXRwQXR0cnMpLmV2ZXJ5KGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGVlckZtdHBBdHRyc1thdHRyXSA9PT0gZm10cEF0dHJzW2F0dHJdO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBJZiBub25lIG9mIHRoZSBtYXRjaGVkIFBheWxvYWQgVHlwZXMgYWxzbyBoYXZlIG1hdGNoaW5nIGZtdHAgYXR0cmlidXRlcyxcbiAgICAvLyB0aGVuIHJldGFpbiBhbGwgb2YgdGhlbSwgb3RoZXJ3aXNlIHJldGFpbiBvbmx5IHRoZSBQYXlsb2FkIFR5cGUgdGhhdFxuICAgIC8vIG1hdGNoZXMgdGhlIHBlZXIgZm10cCBhdHRyaWJ1dGVzLlxuICAgIHJldHVybiB0eXBlb2YgbWF0Y2hpbmdQdCA9PT0gJ251bWJlcicgPyBbbWF0Y2hpbmdQdF0gOiBtYXRjaGluZ1B0cztcbn1cbi8qKlxuICogRmlsdGVyIGNvZGVjcyBpbiBhIHVuaWZpZWQgcGxhbiBtPSBzZWN0aW9uIGJhc2VkIG9uIGl0cyBwZWVyIG09IHNlY3Rpb24uXG4gKiBmcm9tIHRoZSBvdGhlciBwZWVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHNlY3Rpb25cbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgc3RyaW5nPn0gcGVlck1pZHNUb01lZGlhU2VjdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gY29kZWNzVG9SZW1vdmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHVuaWZpZWRQbGFuRmlsdGVyQ29kZWNzSW5NZWRpYVNlY3Rpb24oc2VjdGlvbiwgcGVlck1pZHNUb01lZGlhU2VjdGlvbnMsIGNvZGVjc1RvUmVtb3ZlKSB7XG4gICAgLy8gRG8gbm90aGluZyBpZiB0aGUgbT0gc2VjdGlvbiByZXByZXNlbnRzIG5laXRoZXIgYXVkaW8gbm9yIHZpZGVvLlxuICAgIGlmICghL15tPShhdWRpb3x2aWRlbykvLnRlc3Qoc2VjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgfVxuICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIG09IHNlY3Rpb24gZG9lcyBub3QgaGF2ZSBhbiBlcXVpdmFsZW50IHJlbW90ZSBtPSBzZWN0aW9uLlxuICAgIHZhciBtaWQgPSBnZXRNaWRGb3JNZWRpYVNlY3Rpb24oc2VjdGlvbik7XG4gICAgdmFyIHBlZXJTZWN0aW9uID0gbWlkICYmIHBlZXJNaWRzVG9NZWRpYVNlY3Rpb25zLmdldChtaWQpO1xuICAgIGlmICghcGVlclNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgfVxuICAgIC8vIENvbnN0cnVjdCBhIE1hcCBvZiB0aGUgcGVlciBQYXlsb2FkIFR5cGVzIHRvIHRoZWlyIGNvZGVjIG5hbWVzLlxuICAgIHZhciBwZWVyUHRUb0NvZGVjcyA9IGNyZWF0ZVB0VG9Db2RlY05hbWUocGVlclNlY3Rpb24pO1xuICAgIC8vIENvbnN0cnVjdCBhIE1hcCBvZiB0aGUgY29kZWMgbmFtZXMgdG8gdGhlaXIgUGF5bG9hZCBUeXBlcy5cbiAgICB2YXIgY29kZWNzVG9QdHMgPSBjcmVhdGVDb2RlY01hcEZvck1lZGlhU2VjdGlvbihzZWN0aW9uKTtcbiAgICAvLyBNYWludGFpbiBhIGxpc3Qgb2Ygbm9uLXJ0eCBQYXlsb2FkIFR5cGVzIHRvIHJldGFpbi5cbiAgICB2YXIgcHRzID0gZmxhdE1hcChBcnJheS5mcm9tKHBlZXJQdFRvQ29kZWNzKSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHBlZXJQdCA9IF9iWzBdLCBwZWVyQ29kZWMgPSBfYlsxXTtcbiAgICAgICAgcmV0dXJuIHBlZXJDb2RlYyAhPT0gJ3J0eCcgJiYgIWNvZGVjc1RvUmVtb3ZlLmluY2x1ZGVzKHBlZXJDb2RlYylcbiAgICAgICAgICAgID8gdW5pZmllZFBsYW5HZXRNYXRjaGluZ1BheWxvYWRUeXBlcyhwZWVyQ29kZWMsIHBlZXJQdCwgY29kZWNzVG9QdHMsIHNlY3Rpb24sIHBlZXJTZWN0aW9uKVxuICAgICAgICAgICAgOiBbXTtcbiAgICB9KTtcbiAgICAvLyBGb3IgZWFjaCBQYXlsb2FkIFR5cGUgdGhhdCB3aWxsIGJlIHJldGFpbmVkLCByZXRhaW4gdGhlaXIgY29ycmVzcG9uZGluZyBydHhcbiAgICAvLyBQYXlsb2FkIFR5cGUgaWYgcHJlc2VudC5cbiAgICB2YXIgcnR4UHRzID0gY29kZWNzVG9QdHMuZ2V0KCdydHgnKSB8fCBbXTtcbiAgICAvLyBJbiBcImE9Zm10cDo8cnR4UHQ+IGFwdD08YXB0PlwiLCBleHRyYWN0IHRoZSBjb2RlYyBQVCA8YXB0PiBhc3NvY2lhdGVkIHdpdGggcnR4UHQuXG4gICAgcHRzID0gcHRzLmNvbmNhdChydHhQdHMuZmlsdGVyKGZ1bmN0aW9uIChydHhQdCkge1xuICAgICAgICB2YXIgZm10cEF0dHJzID0gZ2V0Rm10cEF0dHJpYnV0ZXNGb3JQdChydHhQdCwgc2VjdGlvbik7XG4gICAgICAgIHJldHVybiBmbXRwQXR0cnMgJiYgcHRzLmluY2x1ZGVzKGZtdHBBdHRycy5hcHQpO1xuICAgIH0pKTtcbiAgICAvLyBGaWx0ZXIgb3V0IHRoZSBiZWxvdyBtZW50aW9uZWQgYXR0cmlidXRlIGxpbmVzIGluIHRoZSBtPSBzZWN0aW9uIHRoYXQgZG8gbm90XG4gICAgLy8gYmVsb25nIHRvIG9uZSBvZiB0aGUgUGF5bG9hZCBUeXBlcyB0aGF0IGFyZSB0byBiZSByZXRhaW5lZC5cbiAgICAvLyAxLiBcImE9cnRwbWFwOjxwdD4gPGNvZGVjPlwiXG4gICAgLy8gMi4gXCJhPXJ0Y3AtZmI6PHB0PiA8YXR0cj5bIDxhdHRyPl0qXCJcbiAgICAvLyAzLiBcImE9Zm10cDo8cHQ+IDxuYW1lPj08dmFsdWU+Wzs8bmFtZT49PHZhbHVlPl0qXCJcbiAgICB2YXIgbGluZXMgPSBzZWN0aW9uLnNwbGl0KCdcXHJcXG4nKS5maWx0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHB0TWF0Y2hlcyA9IGxpbmUubWF0Y2goL15hPShydHBtYXB8Zm10cHxydGNwLWZiKTooLispIC4rJC8pO1xuICAgICAgICB2YXIgcHQgPSBwdE1hdGNoZXMgJiYgcHRNYXRjaGVzWzJdO1xuICAgICAgICByZXR1cm4gIXB0TWF0Y2hlcyB8fCAocHQgJiYgcHRzLmluY2x1ZGVzKHBhcnNlSW50KHB0LCAxMCkpKTtcbiAgICB9KTtcbiAgICAvLyBGaWx0ZXIgdGhlIGxpc3Qgb2YgUGF5bG9hZCBUeXBlcyBpbiB0aGUgZmlyc3QgbGluZSBvZiB0aGUgbT0gc2VjdGlvbi5cbiAgICB2YXIgb3JkZXJlZFB0cyA9IGdldFBheWxvYWRUeXBlc0luTWVkaWFTZWN0aW9uKHNlY3Rpb24pLmZpbHRlcihmdW5jdGlvbiAocHQpIHsgcmV0dXJuIHB0cy5pbmNsdWRlcyhwdCk7IH0pO1xuICAgIHJldHVybiBzZXRQYXlsb2FkVHlwZXNJbk1lZGlhU2VjdGlvbihvcmRlcmVkUHRzLCBsaW5lcy5qb2luKCdcXHJcXG4nKSk7XG59XG4vKipcbiAqIEZpbHRlciBsb2NhbCBjb2RlY3MgYmFzZWQgb24gdGhlIHJlbW90ZSB1bmlmaWVkIHBsYW4gU0RQLlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsU2RwXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlU2RwXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVwZGF0ZWQgbG9jYWwgU0RQXG4gKi9cbmZ1bmN0aW9uIHVuaWZpZWRQbGFuRmlsdGVyTG9jYWxDb2RlY3MobG9jYWxTZHAsIHJlbW90ZVNkcCkge1xuICAgIHZhciBsb2NhbE1lZGlhU2VjdGlvbnMgPSBnZXRNZWRpYVNlY3Rpb25zKGxvY2FsU2RwKTtcbiAgICB2YXIgbG9jYWxTZXNzaW9uID0gbG9jYWxTZHAuc3BsaXQoJ1xcclxcbm09JylbMF07XG4gICAgdmFyIHJlbW90ZU1pZHNUb01lZGlhU2VjdGlvbnMgPSBjcmVhdGVNaWRUb01lZGlhU2VjdGlvbk1hcChyZW1vdGVTZHApO1xuICAgIHJldHVybiBbbG9jYWxTZXNzaW9uXS5jb25jYXQobG9jYWxNZWRpYVNlY3Rpb25zLm1hcChmdW5jdGlvbiAobG9jYWxTZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB1bmlmaWVkUGxhbkZpbHRlckNvZGVjc0luTWVkaWFTZWN0aW9uKGxvY2FsU2VjdGlvbiwgcmVtb3RlTWlkc1RvTWVkaWFTZWN0aW9ucywgW10pO1xuICAgIH0pKS5qb2luKCdcXHJcXG4nKTtcbn1cbi8qKlxuICogUmV0dXJuIGEgbmV3IFNEUCBzdHJpbmcgYWZ0ZXIgcmV2ZXJ0aW5nIHNpbXVsY2FzdCBmb3Igbm9uIHZwOCBzZWN0aW9ucyBpbiByZW1vdGUgc2RwLlxuICogQHBhcmFtIGxvY2FsU2RwIC0gc2ltdWxjYXN0IGVuYWJsZWQgbG9jYWwgc2RwXG4gKiBAcGFyYW0gbG9jYWxTZHBXaXRob3V0U2ltdWxjYXN0IC0gbG9jYWwgc2RwIGJlZm9yZSBzaW11bGNhc3Qgd2FzIHNldFxuICogQHBhcmFtIHJlbW90ZVNkcCAtIHJlbW90ZSBzZHBcbiAqIEByZXR1cm4ge3N0cmluZ30gVXBkYXRlZCBTRFAgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHJldmVydFNpbXVsY2FzdEZvck5vblZQOE1lZGlhU2VjdGlvbnMobG9jYWxTZHAsIGxvY2FsU2RwV2l0aG91dFNpbXVsY2FzdCwgcmVtb3RlU2RwKSB7XG4gICAgdmFyIHJlbW90ZU1pZFRvTWVkaWFTZWN0aW9ucyA9IGNyZWF0ZU1pZFRvTWVkaWFTZWN0aW9uTWFwKHJlbW90ZVNkcCk7XG4gICAgdmFyIGxvY2FsTWlkVG9NZWRpYVNlY3Rpb25zV2l0aG91dFNpbXVsY2FzdCA9IGNyZWF0ZU1pZFRvTWVkaWFTZWN0aW9uTWFwKGxvY2FsU2RwV2l0aG91dFNpbXVsY2FzdCk7XG4gICAgdmFyIG1lZGlhU2VjdGlvbnMgPSBnZXRNZWRpYVNlY3Rpb25zKGxvY2FsU2RwKTtcbiAgICB2YXIgc2Vzc2lvbiA9IGxvY2FsU2RwLnNwbGl0KCdcXHJcXG5tPScpWzBdO1xuICAgIHJldHVybiBbc2Vzc2lvbl0uY29uY2F0KG1lZGlhU2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgIHNlY3Rpb24gPSBzZWN0aW9uLnJlcGxhY2UoL1xcclxcbiQvLCAnJyk7XG4gICAgICAgIGlmICghL15tPXZpZGVvLy50ZXN0KHNlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWlkTWF0Y2hlcyA9IHNlY3Rpb24ubWF0Y2goL15hPW1pZDooLispJC9tKTtcbiAgICAgICAgdmFyIG1pZCA9IG1pZE1hdGNoZXMgJiYgbWlkTWF0Y2hlc1sxXTtcbiAgICAgICAgaWYgKCFtaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZW1vdGVTZWN0aW9uID0gcmVtb3RlTWlkVG9NZWRpYVNlY3Rpb25zLmdldChtaWQpO1xuICAgICAgICB2YXIgcmVtb3RlUHRUb0NvZGVjcyA9IGNyZWF0ZVB0VG9Db2RlY05hbWUocmVtb3RlU2VjdGlvbik7XG4gICAgICAgIHZhciByZW1vdGVQYXlsb2FkVHlwZXMgPSBnZXRQYXlsb2FkVHlwZXNJbk1lZGlhU2VjdGlvbihyZW1vdGVTZWN0aW9uKTtcbiAgICAgICAgdmFyIGlzVlA4VGhlUHJlZmVycmVkQ29kZWMgPSByZW1vdGVQYXlsb2FkVHlwZXMubGVuZ3RoICYmIHJlbW90ZVB0VG9Db2RlY3MuZ2V0KHJlbW90ZVBheWxvYWRUeXBlc1swXSkgPT09ICd2cDgnO1xuICAgICAgICByZXR1cm4gaXNWUDhUaGVQcmVmZXJyZWRDb2RlYyA/IHNlY3Rpb24gOiBsb2NhbE1pZFRvTWVkaWFTZWN0aW9uc1dpdGhvdXRTaW11bGNhc3QuZ2V0KG1pZCkucmVwbGFjZSgvXFxyXFxuJC8sICcnKTtcbiAgICB9KSkuY29uY2F0KCcnKS5qb2luKCdcXHJcXG4nKTtcbn1cbi8qKlxuICogQWRkIG9yIHJld3JpdGUgTVNJRHMgZm9yIG5ldyBtPSBzZWN0aW9ucyBpbiB0aGUgZ2l2ZW4gVW5pZmllZCBQbGFuIFNEUCB3aXRoIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIGxvY2FsIE1lZGlhU3RyZWFtVHJhY2sgSURzLiBUaGVzZSBjYW4gYmUgZGlmZmVyZW50IHdoZW4gcHJldmlvdXNseVxuICogcmVtb3ZlZCBNZWRpYVN0cmVhbVRyYWNrcyBhcmUgYWRkZWQgYmFjayAob3IgVHJhY2sgSURzIG1heSBub3QgYmUgcHJlc2VudCBpbiB0aGVcbiAqIFNEUHMgYXQgYWxsIG9uY2UgYnJvd3NlcnMgaW1wbGVtZW50IHRoZSBsYXRlc3QgV2ViUlRDIHNwZWMpLlxuICogQHBhcmFtIHtzdHJpbmd9IHNkcFxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBUcmFjay5JRD59IGFjdGl2ZU1pZHNUb1RyYWNrSWRzXG4gKiBAcGFyYW0ge01hcDxUcmFjay5LaW5kLCBBcnJheTxUcmFjay5JRD4+fSB0cmFja0lkc0J5S2luZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdW5pZmllZFBsYW5BZGRPclJld3JpdGVOZXdUcmFja0lkcyhzZHAsIGFjdGl2ZU1pZHNUb1RyYWNrSWRzLCB0cmFja0lkc0J5S2luZCkge1xuICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFRoZSBtPSBzZWN0aW9ucyBmb3IgdGhlIG5ldyBNZWRpYVN0cmVhbVRyYWNrcyBhcmUgdXN1YWxseVxuICAgIC8vIHByZXNlbnQgYWZ0ZXIgdGhlIG09IHNlY3Rpb25zIGZvciB0aGUgZXhpc3RpbmcgTWVkaWFTdHJlYW1UcmFja3MsIGluIG9yZGVyXG4gICAgLy8gb2YgYWRkaXRpb24uXG4gICAgdmFyIG5ld01pZHNUb1RyYWNrSWRzID0gQXJyYXkuZnJvbSh0cmFja0lkc0J5S2luZCkucmVkdWNlKGZ1bmN0aW9uIChtaWRzVG9UcmFja0lkcywgX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwga2luZCA9IF9iWzBdLCB0cmFja0lkcyA9IF9iWzFdO1xuICAgICAgICB2YXIgbWVkaWFTZWN0aW9ucyA9IGdldE1lZGlhU2VjdGlvbnMoc2RwLCBraW5kLCAnc2VuZChvbmx5fHJlY3YpJyk7XG4gICAgICAgIHZhciBuZXdNaWRzID0gbWVkaWFTZWN0aW9ucy5tYXAoZ2V0TWlkRm9yTWVkaWFTZWN0aW9uKS5maWx0ZXIoZnVuY3Rpb24gKG1pZCkgeyByZXR1cm4gIWFjdGl2ZU1pZHNUb1RyYWNrSWRzLmhhcyhtaWQpOyB9KTtcbiAgICAgICAgbmV3TWlkcy5mb3JFYWNoKGZ1bmN0aW9uIChtaWQsIGkpIHsgcmV0dXJuIG1pZHNUb1RyYWNrSWRzLnNldChtaWQsIHRyYWNrSWRzW2ldKTsgfSk7XG4gICAgICAgIHJldHVybiBtaWRzVG9UcmFja0lkcztcbiAgICB9LCBuZXcgTWFwKCkpO1xuICAgIHJldHVybiB1bmlmaWVkUGxhbkFkZE9yUmV3cml0ZVRyYWNrSWRzKHNkcCwgbmV3TWlkc1RvVHJhY2tJZHMpO1xufVxuLyoqXG4gKiBBZGQgb3IgcmV3cml0ZSBNU0lEcyBpbiB0aGUgZ2l2ZW4gVW5pZmllZCBQbGFuIFNEUCB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgbG9jYWxcbiAqIE1lZGlhU3RyZWFtVHJhY2sgSURzLiBUaGVzZSBJRHMgbmVlZCBub3QgYmUgdGhlIHNhbWUgKG9yIFRyYWNrIElEcyBtYXkgbm90IGJlXG4gKiBwcmVzZW50IGluIHRoZSBTRFBzIGF0IGFsbCBvbmNlIGJyb3dzZXJzIGltcGxlbWVudCB0aGUgbGF0ZXN0IFdlYlJUQyBzcGVjKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHBcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgVHJhY2suSUQ+fSBtaWRzVG9UcmFja0lkc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdW5pZmllZFBsYW5BZGRPclJld3JpdGVUcmFja0lkcyhzZHAsIG1pZHNUb1RyYWNrSWRzKSB7XG4gICAgdmFyIG1lZGlhU2VjdGlvbnMgPSBnZXRNZWRpYVNlY3Rpb25zKHNkcCk7XG4gICAgdmFyIHNlc3Npb24gPSBzZHAuc3BsaXQoJ1xcclxcbm09JylbMF07XG4gICAgcmV0dXJuIFtzZXNzaW9uXS5jb25jYXQobWVkaWFTZWN0aW9ucy5tYXAoZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSBtPSBzZWN0aW9uIHJlcHJlc2VudHMgbmVpdGhlciBhdWRpbyBub3IgdmlkZW8uXG4gICAgICAgIGlmICghL15tPShhdWRpb3x2aWRlbykvLnRlc3QobWVkaWFTZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lZGlhU2VjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4sIGJ1dCBpbiBjYXNlIHRoZXJlIGlzIG5vIE1JRCBmb3IgdGhlIG09IHNlY3Rpb24sIGRvIG5vdGhpbmcuXG4gICAgICAgIHZhciBtaWQgPSBnZXRNaWRGb3JNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICAgICAgaWYgKCFtaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZWRpYVNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBubyBUcmFjayBJRCBmb3IgdGhlIGdpdmVuIE1JRCBpbiB0aGUgbWFwLCBkbyBub3RoaW5nLlxuICAgICAgICB2YXIgdHJhY2tJZCA9IG1pZHNUb1RyYWNrSWRzLmdldChtaWQpO1xuICAgICAgICBpZiAoIXRyYWNrSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZWRpYVNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBidXQgaW4gY2FzZSB0aGVyZSBpcyBubyBhPW1zaWQ6IGxpbmUsIGRvIG5vdGhpbmcuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gKG1lZGlhU2VjdGlvbi5tYXRjaCgvXmE9bXNpZDooLispJC9tKSB8fCBbXSlbMV07XG4gICAgICAgIGlmICghYXR0cmlidXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1lZGlhU2VjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgYT1tc2lkOiBsaW5lIGNvbnRhaW5zIHRoZSBcImFwcGRhdGFcIiBmaWVsZCwgdGhlbiByZXBsYWNlIGl0IHdpdGggdGhlIFRyYWNrIElELFxuICAgICAgICAvLyBvdGhlcndpc2UgYXBwZW5kIHRoZSBUcmFjayBJRC5cbiAgICAgICAgdmFyIF9hID0gX19yZWFkKGF0dHJpYnV0ZXMuc3BsaXQoJyAnKSwgMiksIG1zaWQgPSBfYVswXSwgdHJhY2tJZFRvUmV3cml0ZSA9IF9hWzFdO1xuICAgICAgICB2YXIgbXNpZFJlZ2V4ID0gbmV3IFJlZ0V4cChcIm1zaWQ6XCIgKyBtc2lkICsgKHRyYWNrSWRUb1Jld3JpdGUgPyBcIiBcIiArIHRyYWNrSWRUb1Jld3JpdGUgOiAnJykgKyBcIiRcIiwgJ2dtJyk7XG4gICAgICAgIHJldHVybiBtZWRpYVNlY3Rpb24ucmVwbGFjZShtc2lkUmVnZXgsIFwibXNpZDpcIiArIG1zaWQgKyBcIiBcIiArIHRyYWNrSWQpO1xuICAgIH0pKS5qb2luKCdcXHJcXG4nKTtcbn1cbi8qKlxuICogcmVtb3ZlcyBzcGVjaWZpZWQgc3NyYyBhdHRyaWJ1dGVzIGZyb20gZ2l2ZW4gc2RwXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHNzcmNBdHRyaWJ1dGVzVG9SZW1vdmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVNTUkNBdHRyaWJ1dGVzKHNkcCwgc3NyY0F0dHJpYnV0ZXNUb1JlbW92ZSkge1xuICAgIHJldHVybiBzZHAuc3BsaXQoJ1xcclxcbicpLmZpbHRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgICByZXR1cm4gIXNzcmNBdHRyaWJ1dGVzVG9SZW1vdmUuZmluZChmdW5jdGlvbiAoc3JjQXR0cmlidXRlKSB7IHJldHVybiBuZXcgUmVnRXhwKCdhPXNzcmM6LionICsgc3JjQXR0cmlidXRlICsgJzonLCAnZycpLnRlc3QobGluZSk7IH0pO1xuICAgIH0pLmpvaW4oJ1xcclxcbicpO1xufVxuLyoqXG4gKiBEaXNhYmxlIFJUWCBpbiBhIGdpdmVuIHNkcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHBcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHNkcCB3aXRob3V0IFJUWFxuICovXG5mdW5jdGlvbiBkaXNhYmxlUnR4KHNkcCkge1xuICAgIHZhciBtZWRpYVNlY3Rpb25zID0gZ2V0TWVkaWFTZWN0aW9ucyhzZHApO1xuICAgIHZhciBzZXNzaW9uID0gc2RwLnNwbGl0KCdcXHJcXG5tPScpWzBdO1xuICAgIHJldHVybiBbc2Vzc2lvbl0uY29uY2F0KG1lZGlhU2VjdGlvbnMubWFwKGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgbT0gc2VjdGlvbiBkb2VzIG5vdCByZXByZXNlbnQgYSB2aWRlbyB0cmFjay5cbiAgICAgICAgaWYgKCEvXm09dmlkZW8vLnRlc3QobWVkaWFTZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lZGlhU2VjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBtYXAgb2YgY29kZWNzIHRvIHBheWxvYWQgdHlwZXMuXG4gICAgICAgIHZhciBjb2RlY3NUb1B0cyA9IGNyZWF0ZUNvZGVjTWFwRm9yTWVkaWFTZWN0aW9uKG1lZGlhU2VjdGlvbik7XG4gICAgICAgIC8vIEdldCB0aGUgUlRYIHBheWxvYWQgdHlwZXMuXG4gICAgICAgIHZhciBydHhQdHMgPSBjb2RlY3NUb1B0cy5nZXQoJ3J0eCcpO1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZXJlIGFyZSBubyBSVFggcGF5bG9hZCB0eXBlcy5cbiAgICAgICAgaWYgKCFydHhQdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBtZWRpYVNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBSVFggcGF5bG9hZCB0eXBlcy5cbiAgICAgICAgdmFyIHB0cyA9IG5ldyBTZXQoZ2V0UGF5bG9hZFR5cGVzSW5NZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKSk7XG4gICAgICAgIHJ0eFB0cy5mb3JFYWNoKGZ1bmN0aW9uIChydHhQdCkgeyByZXR1cm4gcHRzLmRlbGV0ZShydHhQdCk7IH0pO1xuICAgICAgICAvLyBHZXQgdGhlIFJUWCBTU1JDLlxuICAgICAgICB2YXIgcnR4U1NSQ01hdGNoZXMgPSBtZWRpYVNlY3Rpb24ubWF0Y2goL2E9c3NyYy1ncm91cDpGSUQgWzAtOV0rIChbMC05XSspLyk7XG4gICAgICAgIHZhciBydHhTU1JDID0gcnR4U1NSQ01hdGNoZXMgJiYgcnR4U1NSQ01hdGNoZXNbMV07XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZm9sbG93aW5nIGxpbmVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgUlRYIHBheWxvYWQgdHlwZXM6XG4gICAgICAgIC8vIDEuIFwiYT1mbXRwOjxydHhQdD4gYXB0PTxwdD5cIlxuICAgICAgICAvLyAyLiBcImE9cnRwbWFwOjxydHhQdD4gcnR4Ly4uLlwiXG4gICAgICAgIC8vIDMuIFwiYT1zc3JjOjxydHhTU1JDPiBjbmFtZTouLi5cIlxuICAgICAgICAvLyA0LiBcImE9c3NyYy1ncm91cDpGSUQgPFNTUkM+IDxydHhTU1JDPlwiXG4gICAgICAgIHZhciBmaWx0ZXJSZWdleGVzID0gW1xuICAgICAgICAgICAgL15hPWZtdHA6LisgYXB0PS4rJC8sXG4gICAgICAgICAgICAvXmE9cnRwbWFwOi4rIHJ0eFxcLy4rJC8sXG4gICAgICAgICAgICAvXmE9c3NyYy1ncm91cDouKyQvXG4gICAgICAgIF0uY29uY2F0KHJ0eFNTUkNcbiAgICAgICAgICAgID8gW25ldyBSZWdFeHAoXCJeYT1zc3JjOlwiICsgcnR4U1NSQyArIFwiIC4rJFwiKV1cbiAgICAgICAgICAgIDogW10pO1xuICAgICAgICBtZWRpYVNlY3Rpb24gPSBtZWRpYVNlY3Rpb24uc3BsaXQoJ1xcclxcbicpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7IHJldHVybiBmaWx0ZXJSZWdleGVzLmV2ZXJ5KGZ1bmN0aW9uIChyZWdleCkgeyByZXR1cm4gIXJlZ2V4LnRlc3QobGluZSk7IH0pOyB9KVxuICAgICAgICAgICAgLmpvaW4oJ1xcclxcbicpO1xuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgbT0gc2VjdGlvbiB3aXRob3V0IHRoZSBSVFggcGF5bG9hZCB0eXBlcy5cbiAgICAgICAgcmV0dXJuIHNldFBheWxvYWRUeXBlc0luTWVkaWFTZWN0aW9uKEFycmF5LmZyb20ocHRzKSwgbWVkaWFTZWN0aW9uKTtcbiAgICB9KSkuam9pbignXFxyXFxuJyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGFuIGE9Zm10cDogbGluZSBmcm9tIHRoZSBnaXZlbiBwYXlsb2FkIHR5cGUgYW5kIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge1BUfSBwdFxuICogQHBhcmFtIHsqfSBmbXRwQXR0cnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlRm10cExpbmVGcm9tUHRBbmRBdHRyaWJ1dGVzKHB0LCBmbXRwQXR0cnMpIHtcbiAgICB2YXIgc2VyaWFsaXplZEZtdHBBdHRycyA9IE9iamVjdC5lbnRyaWVzKGZtdHBBdHRycykubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBuYW1lID0gX2JbMF0sIHZhbHVlID0gX2JbMV07XG4gICAgICAgIHJldHVybiBuYW1lICsgXCI9XCIgKyB2YWx1ZTtcbiAgICB9KS5qb2luKCc7Jyk7XG4gICAgcmV0dXJuIFwiYT1mbXRwOlwiICsgcHQgKyBcIiBcIiArIHNlcmlhbGl6ZWRGbXRwQXR0cnM7XG59XG4vKipcbiAqIEVuYWJsZSBEVFggZm9yIG9wdXMgaW4gdGhlIG09IHNlY3Rpb25zIGZvciB0aGUgZ2l2ZW4gTUlEcy5gXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFttaWRzXSAtIElmIG5vdCBzcGVjaWZpZWQsIGVuYWJsZXMgb3B1cyBEVFggZm9yIGFsbFxuICogICBhdWRpbyBtPSBsaW5lcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUR0eEZvck9wdXMoc2RwLCBtaWRzKSB7XG4gICAgdmFyIG1lZGlhU2VjdGlvbnMgPSBnZXRNZWRpYVNlY3Rpb25zKHNkcCk7XG4gICAgdmFyIHNlc3Npb24gPSBzZHAuc3BsaXQoJ1xcclxcbm09JylbMF07XG4gICAgbWlkcyA9IG1pZHMgfHwgbWVkaWFTZWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzZWN0aW9uKSB7IHJldHVybiAvXm09YXVkaW8vLnRlc3Qoc2VjdGlvbik7IH0pXG4gICAgICAgIC5tYXAoZ2V0TWlkRm9yTWVkaWFTZWN0aW9uKTtcbiAgICByZXR1cm4gW3Nlc3Npb25dLmNvbmNhdChtZWRpYVNlY3Rpb25zLm1hcChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSBtPSBzZWN0aW9uIGlzIG5vdCBhdWRpby5cbiAgICAgICAgaWYgKCEvXm09YXVkaW8vLnRlc3Qoc2VjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIGEgbWFwIGNvZGVjcyB0byBwYXlsb2FkIHR5cGVzLlxuICAgICAgICB2YXIgY29kZWNzVG9QdHMgPSBjcmVhdGVDb2RlY01hcEZvck1lZGlhU2VjdGlvbihzZWN0aW9uKTtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBhIHBheWxvYWQgdHlwZSBmb3Igb3B1cyBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgdmFyIG9wdXNQdCA9IGNvZGVjc1RvUHRzLmdldCgnb3B1cycpO1xuICAgICAgICBpZiAoIW9wdXNQdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gZm10cCBhdHRyaWJ1dGVzIGFyZSBmb3VuZCBmb3Igb3B1cywgZG8gbm90aGluZy5cbiAgICAgICAgdmFyIG9wdXNGbXRwQXR0cnMgPSBnZXRGbXRwQXR0cmlidXRlc0ZvclB0KG9wdXNQdCwgc2VjdGlvbik7XG4gICAgICAgIGlmICghb3B1c0ZtdHBBdHRycykge1xuICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHVzZWR0eD0xIHRvIHRoZSBhPWZtdHA6IGxpbmUgZm9yIG9wdXMuXG4gICAgICAgIHZhciBvcmlnT3B1c0ZtdHBMaW5lID0gZ2VuZXJhdGVGbXRwTGluZUZyb21QdEFuZEF0dHJpYnV0ZXMob3B1c1B0LCBvcHVzRm10cEF0dHJzKTtcbiAgICAgICAgdmFyIG9yaWdPcHVzRm10cFJlZ2V4ID0gbmV3IFJlZ0V4cChvcmlnT3B1c0ZtdHBMaW5lKTtcbiAgICAgICAgLy8gSWYgdGhlIG09IHNlY3Rpb24ncyBNSUQgaXMgaW4gdGhlIGxpc3Qgb2YgTUlEcywgdGhlbiBlbmFibGUgZHR4LiBPdGhlcndpc2UgZGlzYWJsZSBpdC5cbiAgICAgICAgdmFyIG1pZCA9IGdldE1pZEZvck1lZGlhU2VjdGlvbihzZWN0aW9uKTtcbiAgICAgICAgaWYgKG1pZHMuaW5jbHVkZXMobWlkKSkge1xuICAgICAgICAgICAgb3B1c0ZtdHBBdHRycy51c2VkdHggPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG9wdXNGbXRwQXR0cnMudXNlZHR4O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHVzRm10cExpbmVXaXRoRHR4ID0gZ2VuZXJhdGVGbXRwTGluZUZyb21QdEFuZEF0dHJpYnV0ZXMob3B1c1B0LCBvcHVzRm10cEF0dHJzKTtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb24ucmVwbGFjZShvcmlnT3B1c0ZtdHBSZWdleCwgb3B1c0ZtdHBMaW5lV2l0aER0eCk7XG4gICAgfSkpLmpvaW4oJ1xcclxcbicpO1xufVxuZXhwb3J0cy5jcmVhdGVDb2RlY01hcEZvck1lZGlhU2VjdGlvbiA9IGNyZWF0ZUNvZGVjTWFwRm9yTWVkaWFTZWN0aW9uO1xuZXhwb3J0cy5jcmVhdGVQdFRvQ29kZWNOYW1lID0gY3JlYXRlUHRUb0NvZGVjTmFtZTtcbmV4cG9ydHMuZGlzYWJsZVJ0eCA9IGRpc2FibGVSdHg7XG5leHBvcnRzLmVuYWJsZUR0eEZvck9wdXMgPSBlbmFibGVEdHhGb3JPcHVzO1xuZXhwb3J0cy5nZXRNZWRpYVNlY3Rpb25zID0gZ2V0TWVkaWFTZWN0aW9ucztcbmV4cG9ydHMucmVtb3ZlU1NSQ0F0dHJpYnV0ZXMgPSByZW1vdmVTU1JDQXR0cmlidXRlcztcbmV4cG9ydHMucmV2ZXJ0U2ltdWxjYXN0Rm9yTm9uVlA4TWVkaWFTZWN0aW9ucyA9IHJldmVydFNpbXVsY2FzdEZvck5vblZQOE1lZGlhU2VjdGlvbnM7XG5leHBvcnRzLnNldEJpdHJhdGVQYXJhbWV0ZXJzID0gc2V0Qml0cmF0ZVBhcmFtZXRlcnM7XG5leHBvcnRzLnNldENvZGVjUHJlZmVyZW5jZXMgPSBzZXRDb2RlY1ByZWZlcmVuY2VzO1xuZXhwb3J0cy5zZXRTaW11bGNhc3QgPSBzZXRTaW11bGNhc3Q7XG5leHBvcnRzLnVuaWZpZWRQbGFuRmlsdGVyTG9jYWxDb2RlY3MgPSB1bmlmaWVkUGxhbkZpbHRlckxvY2FsQ29kZWNzO1xuZXhwb3J0cy51bmlmaWVkUGxhbkFkZE9yUmV3cml0ZU5ld1RyYWNrSWRzID0gdW5pZmllZFBsYW5BZGRPclJld3JpdGVOZXdUcmFja0lkcztcbmV4cG9ydHMudW5pZmllZFBsYW5BZGRPclJld3JpdGVUcmFja0lkcyA9IHVuaWZpZWRQbGFuQWRkT3JSZXdyaXRlVHJhY2tJZHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID0gcmVxdWlyZSgnQHR3aWxpby93ZWJydGMnKS5SVENTZXNzaW9uRGVzY3JpcHRpb247XG52YXIgY3JlYXRlUHRUb0NvZGVjTmFtZSA9IHJlcXVpcmUoJy4vJykuY3JlYXRlUHRUb0NvZGVjTmFtZTtcbnZhciBnZXRNZWRpYVNlY3Rpb25zID0gcmVxdWlyZSgnLi8nKS5nZXRNZWRpYVNlY3Rpb25zO1xuLyoqXG4gKiBBbiBSVFggcGF5bG9hZCB0eXBlXG4gKiBAdHlwZWRlZiB7UFR9IFJ0eFBUXG4gKi9cbi8qKlxuICogQSBub24tUlRYIHBheWxvYWQgdHlwZVxuICogQHR5cGVkZWYge1BUfSBOb25SdHhQVFxuICovXG4vKipcbiAqIEEgU2V0IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnRcbiAqIEB0eXBlZGVmIHtTZXR9IE5vbkVtcHR5U2V0XG4gKi9cbi8qKlxuICogQXBwbHkgdGhlIHdvcmthcm91bmQgZm9yIElzc3VlIDgzMjkgdG8gYW4gUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdC5cbiAqIEBwYXJhbSB7UlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdH0gZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtSVENTZXNzaW9uRGVzY3JpcHRpb259IG5ld0Rlc2NyaXB0aW9uXG4gKi9cbmZ1bmN0aW9uIHdvcmthcm91bmQoZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgZGVzY3JpcHRpb25Jbml0ID0geyB0eXBlOiBkZXNjcmlwdGlvbi50eXBlIH07XG4gICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgIT09ICdyb2xsYmFjaycpIHtcbiAgICAgICAgZGVzY3JpcHRpb25Jbml0LnNkcCA9IHNkcFdvcmthcm91bmQoZGVzY3JpcHRpb24uc2RwKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oZGVzY3JpcHRpb25Jbml0KTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNkcFxuICogQHJldHVybnMge3N0cmluZ30gbmV3U2RwXG4gKi9cbmZ1bmN0aW9uIHNkcFdvcmthcm91bmQoc2RwKSB7XG4gICAgdmFyIG1lZGlhU2VjdGlvbnMgPSBnZXRNZWRpYVNlY3Rpb25zKHNkcCk7XG4gICAgdmFyIHNlc3Npb24gPSBzZHAuc3BsaXQoJ1xcclxcbm09JylbMF07XG4gICAgcmV0dXJuIFtzZXNzaW9uXVxuICAgICAgICAuY29uY2F0KG1lZGlhU2VjdGlvbnMubWFwKG1lZGlhU2VjdGlvbldvcmthcm91bmQpKVxuICAgICAgICAuam9pbignXFxyXFxuJyk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZWRpYVNlY3Rpb25cbiAqIEByZXR1cm5zIHtzdHJpbmd9IG5ld01lZGlhU2VjdGlvblxuICovXG5mdW5jdGlvbiBtZWRpYVNlY3Rpb25Xb3JrYXJvdW5kKG1lZGlhU2VjdGlvbikge1xuICAgIHZhciBwdFRvQ29kZWNOYW1lID0gY3JlYXRlUHRUb0NvZGVjTmFtZShtZWRpYVNlY3Rpb24pO1xuICAgIG1lZGlhU2VjdGlvbiA9IGRlbGV0ZUR1cGxpY2F0ZVJ0eFB0cyhtZWRpYVNlY3Rpb24sIHB0VG9Db2RlY05hbWUpO1xuICAgIHZhciBjb2RlY05hbWVUb1B0cyA9IGNyZWF0ZUNvZGVjTmFtZVRvUHRzKHB0VG9Db2RlY05hbWUpO1xuICAgIHZhciBydHhQdHMgPSBjb2RlY05hbWVUb1B0cy5nZXQoJ3J0eCcpIHx8IG5ldyBTZXQoKTtcbiAgICB2YXIgaW52YWxpZFJ0eFB0cyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgcnR4UHRUb0Fzc29jaWF0ZWRQdCA9IGNyZWF0ZVJ0eFB0VG9Bc3NvY2lhdGVkUHQobWVkaWFTZWN0aW9uLCBwdFRvQ29kZWNOYW1lLCBydHhQdHMsIGludmFsaWRSdHhQdHMpO1xuICAgIHZhciBhc3NvY2lhdGVkUHRUb1J0eFB0ID0gY3JlYXRlQXNzb2NpYXRlZFB0VG9SdHhQdChydHhQdFRvQXNzb2NpYXRlZFB0LCBpbnZhbGlkUnR4UHRzKTtcbiAgICB2YXIgdW5hc3NvY2lhdGVkUnR4UHRzID0gQXJyYXkuZnJvbShpbnZhbGlkUnR4UHRzKTtcbiAgICAvLyBOT1RFKG1yb2JlcnRzKTogV2Ugbm9ybWFsaXplIHRvIGxvd2VyY2FzZS5cbiAgICB2YXIga25vd25Db2RlY05hbWVzID0gWydoMjY0JywgJ3ZwOCcsICd2cDknXTtcbiAgICB2YXIgdW5hc3NvY2lhdGVkUHRzID0ga25vd25Db2RlY05hbWVzLnJlZHVjZShmdW5jdGlvbiAodW5hc3NvY2lhdGVkUHRzLCBjb2RlY05hbWUpIHtcbiAgICAgICAgdmFyIHB0cyA9IGNvZGVjTmFtZVRvUHRzLmdldChjb2RlY05hbWUpIHx8IG5ldyBTZXQoKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocHRzKS5yZWR1Y2UoZnVuY3Rpb24gKHVuYXNzb2NpYXRlZFB0cywgcHQpIHsgcmV0dXJuIGFzc29jaWF0ZWRQdFRvUnR4UHQuaGFzKHB0KVxuICAgICAgICAgICAgPyB1bmFzc29jaWF0ZWRQdHNcbiAgICAgICAgICAgIDogdW5hc3NvY2lhdGVkUHRzLmFkZChwdCk7IH0sIHVuYXNzb2NpYXRlZFB0cyk7XG4gICAgfSwgbmV3IFNldCgpKTtcbiAgICB1bmFzc29jaWF0ZWRQdHMuZm9yRWFjaChmdW5jdGlvbiAocHQpIHtcbiAgICAgICAgaWYgKHVuYXNzb2NpYXRlZFJ0eFB0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBydHhQdCA9IHVuYXNzb2NpYXRlZFJ0eFB0cy5zaGlmdCgpO1xuICAgICAgICAgICAgbWVkaWFTZWN0aW9uID0gZGVsZXRlRm10cEF0dHJpYnV0ZXNGb3JSdHhQdChtZWRpYVNlY3Rpb24sIHJ0eFB0KTtcbiAgICAgICAgICAgIG1lZGlhU2VjdGlvbiA9IGFkZEZtdHBBdHRyaWJ1dGVGb3JSdHhQdChtZWRpYVNlY3Rpb24sIHJ0eFB0LCBwdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB1bmFzc29jaWF0ZWRSdHhQdHMuZm9yRWFjaChmdW5jdGlvbiAocnR4UHQpIHtcbiAgICAgICAgbWVkaWFTZWN0aW9uID0gZGVsZXRlRm10cEF0dHJpYnV0ZXNGb3JSdHhQdChtZWRpYVNlY3Rpb24sIHJ0eFB0KTtcbiAgICAgICAgbWVkaWFTZWN0aW9uID0gZGVsZXRlUnRwbWFwQXR0cmlidXRlc0ZvclJ0eFB0KG1lZGlhU2VjdGlvbiwgcnR4UHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBtZWRpYVNlY3Rpb247XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZWRpYVNlY3Rpb25cbiAqIEBwYXJhbSB7TWFwPFBULCBDb2RlYz59IHB0VG9Db2RlY05hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IG5ld01lZGlhU2VjdGlvblxuICovXG5mdW5jdGlvbiBkZWxldGVEdXBsaWNhdGVSdHhQdHMobWVkaWFTZWN0aW9uLCBwdFRvQ29kZWNOYW1lKSB7XG4gICAgLy8gTk9URShzeWVycmFwcmFnYWRhKTogSW4gc29tZSBjYXNlcyBDaHJvbWUgcHJvZHVjZXMgYW4gb2ZmZXIvYW5zd2VyXG4gICAgLy8gd2l0aCBkdXBsaWNhdGUgXCJydHhcIiBwYXlsb2FkIG1hcHBpbmcgaW4gbWVkaWEgc2VjdGlvbi4gV2hlbiBhcHBsaWVkLFxuICAgIC8vIENocm9tZSByZWplY3RzIHRoZSBTRFAuIFdlIHdvcmthcm91bmQgdGhpcyBieSBkZWxldGluZyBkdXBsaWNhdGVcbiAgICAvLyBcInJ0eFwiIG1hcHBpbmdzIGZvdW5kIGluIFNEUC5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShwdFRvQ29kZWNOYW1lLmtleXMoKSkucmVkdWNlKGZ1bmN0aW9uIChzZWN0aW9uLCBwdCkge1xuICAgICAgICB2YXIgcnRwbWFwUmVnZXggPSBuZXcgUmVnRXhwKFwiXmE9cnRwbWFwOlwiICsgcHQgKyBcIiBydHguKyRcIiwgJ2dtJyk7XG4gICAgICAgIHJldHVybiAoc2VjdGlvbi5tYXRjaChydHBtYXBSZWdleCkgfHwgW10pLnNsaWNlKHB0VG9Db2RlY05hbWUuZ2V0KHB0KSA9PT0gJ3J0eCcgPyAxIDogMCkucmVkdWNlKGZ1bmN0aW9uIChzZWN0aW9uLCBydHBtYXApIHtcbiAgICAgICAgICAgIHZhciBydHBtYXBSZWdleCA9IG5ldyBSZWdFeHAoXCJcXHJcXG5cIiArIHJ0cG1hcCk7XG4gICAgICAgICAgICB2YXIgZm10cG1hcFJlZ2V4ID0gbmV3IFJlZ0V4cChcIlxcclxcbmE9Zm10cDpcIiArIHB0ICsgXCIgYXB0PVswLTldK1wiKTtcbiAgICAgICAgICAgIHJldHVybiBzZWN0aW9uLnJlcGxhY2UocnRwbWFwUmVnZXgsICcnKS5yZXBsYWNlKGZtdHBtYXBSZWdleCwgJycpO1xuICAgICAgICB9LCBzZWN0aW9uKTtcbiAgICB9LCBtZWRpYVNlY3Rpb24pO1xufVxuLyoqXG4gKiBAcGFyYW0ge01hcDxQVCwgQ29kZWM+fSBwdFRvQ29kZWNOYW1lXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgTm9uRW1wdHlTZXQ8UFQ+Pn0gY29kZWNOYW1lVG9QdHNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29kZWNOYW1lVG9QdHMocHRUb0NvZGVjTmFtZSkge1xuICAgIHZhciBjb2RlY05hbWVUb1B0cyA9IG5ldyBNYXAoKTtcbiAgICBwdFRvQ29kZWNOYW1lLmZvckVhY2goZnVuY3Rpb24gKGNvZGVjTmFtZSwgcHQpIHtcbiAgICAgICAgdmFyIHB0cyA9IGNvZGVjTmFtZVRvUHRzLmdldChjb2RlY05hbWUpIHx8IG5ldyBTZXQoKTtcbiAgICAgICAgcmV0dXJuIGNvZGVjTmFtZVRvUHRzLnNldChjb2RlY05hbWUsIHB0cy5hZGQocHQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29kZWNOYW1lVG9QdHM7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZWRpYVNlY3Rpb25cbiAqIEBwYXJhbSB7TWFwPFBULCBDb2RlYz59IHB0VG9Db2RlY05hbWVcbiAqIEBwYXJhbSB7U2V0PFJ0eFBUPn0gcnR4UHRzXG4gKiBAcGFyYW0ge1NldDxSdHhQVD59IGludmFsaWRSdHhQdHNcbiAqIEByZXR1cm5zIHtNYXA8UnR4UFQsIE5vblJ0eFBUPn0gcnR4UHRUb0Fzc29jaWF0ZWRQdFxuICovXG5mdW5jdGlvbiBjcmVhdGVSdHhQdFRvQXNzb2NpYXRlZFB0KG1lZGlhU2VjdGlvbiwgcHRUb0NvZGVjTmFtZSwgcnR4UHRzLCBpbnZhbGlkUnR4UHRzKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocnR4UHRzKS5yZWR1Y2UoZnVuY3Rpb24gKHJ0eFB0VG9Bc3NvY2lhdGVkUHQsIHJ0eFB0KSB7XG4gICAgICAgIHZhciBmbXRwUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJhPWZtdHA6XCIgKyBydHhQdCArIFwiIGFwdD0oXFxcXGQrKVwiKTtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBtZWRpYVNlY3Rpb24ubWF0Y2goZm10cFBhdHRlcm4pO1xuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIGludmFsaWRSdHhQdHMuYWRkKHJ0eFB0KTtcbiAgICAgICAgICAgIHJldHVybiBydHhQdFRvQXNzb2NpYXRlZFB0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdCA9IE51bWJlci5wYXJzZUludChtYXRjaGVzWzFdKTtcbiAgICAgICAgaWYgKCFwdFRvQ29kZWNOYW1lLmhhcyhwdCkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgSXNzdWUgODMyOS5cbiAgICAgICAgICAgIGludmFsaWRSdHhQdHMuYWRkKHJ0eFB0KTtcbiAgICAgICAgICAgIHJldHVybiBydHhQdFRvQXNzb2NpYXRlZFB0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2RlY05hbWUgPSBwdFRvQ29kZWNOYW1lLmdldChwdCk7XG4gICAgICAgIGlmIChjb2RlY05hbWUgPT09ICdydHgnKSB7XG4gICAgICAgICAgICAvLyBTdHJhbmdlXG4gICAgICAgICAgICBpbnZhbGlkUnR4UHRzLmFkZChydHhQdCk7XG4gICAgICAgICAgICByZXR1cm4gcnR4UHRUb0Fzc29jaWF0ZWRQdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnR4UHRUb0Fzc29jaWF0ZWRQdC5zZXQocnR4UHQsIHB0KTtcbiAgICB9LCBuZXcgTWFwKCkpO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVkaWFTZWN0aW9uXG4gKiBAcGFyYW0ge01hcDxSdHhQVCwgTm9uUnR4UFQ+fSBydHhQdFRvQXNzb2NpYXRlZFB0XG4gKiBAcGFyYW0ge1NldDxSdHhQVD59IGludmFsaWRSdHhQdHNcbiAqIEByZXR1cm5zIHtNYXA8Tm9uUnR4UFQsIFJ0eFBUPn0gYXNzb2NpYXRlZFB0VG9SdHhQdFxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NvY2lhdGVkUHRUb1J0eFB0KHJ0eFB0VG9Bc3NvY2lhdGVkUHQsIGludmFsaWRSdHhQdHMpIHtcbiAgICAvLyBGaXJzdCwgd2UgY29uc3RydWN0IGEgTWFwPE5vblJ0eFBULCBOb25FbXB0eVNldDxSdHhQVD4+LlxuICAgIHZhciBhc3NvY2lhdGVkUHRUb1J0eFB0cyA9IEFycmF5LmZyb20ocnR4UHRUb0Fzc29jaWF0ZWRQdCkucmVkdWNlKGZ1bmN0aW9uIChhc3NvY2lhdGVkUHRUb1J0eFB0cywgcGFpcikge1xuICAgICAgICB2YXIgcnR4UHQgPSBwYWlyWzBdO1xuICAgICAgICB2YXIgcHQgPSBwYWlyWzFdO1xuICAgICAgICB2YXIgcnR4UHRzID0gYXNzb2NpYXRlZFB0VG9SdHhQdHMuZ2V0KHB0KSB8fCBuZXcgU2V0KCk7XG4gICAgICAgIHJldHVybiBhc3NvY2lhdGVkUHRUb1J0eFB0cy5zZXQocHQsIHJ0eFB0cy5hZGQocnR4UHQpKTtcbiAgICB9LCBuZXcgTWFwKCkpO1xuICAgIC8vIFRoZW4sIHdlIGZpbHRlciBkb3duIHRvIGEgTWFwPE5vblJ0eFBULCBSdHhQdD4uIEFueSBSdHhQVHMgdGhhdCBtYXAgdG8gdGhlXG4gICAgLy8gc2FtZSBOb25SdHhQVCBhcmUgcmVtb3ZlZCBhbmQgYWRkZWQgdG8gaW52YWxpZFJ0eFB0cy5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShhc3NvY2lhdGVkUHRUb1J0eFB0cykucmVkdWNlKGZ1bmN0aW9uIChhc3NvY2lhdGVkUHRUb1J0eFB0LCBwYWlyKSB7XG4gICAgICAgIHZhciBwdCA9IHBhaXJbMF07XG4gICAgICAgIHZhciBydHhQdHMgPSBBcnJheS5mcm9tKHBhaXJbMV0pO1xuICAgICAgICBpZiAocnR4UHRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJ0eFB0cy5mb3JFYWNoKGZ1bmN0aW9uIChydHhQdCkge1xuICAgICAgICAgICAgICAgIGludmFsaWRSdHhQdHMuYWRkKHJ0eFB0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFzc29jaWF0ZWRQdFRvUnR4UHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzc29jaWF0ZWRQdFRvUnR4UHQuc2V0KHB0LCBydHhQdHNbMF0pO1xuICAgIH0sIG5ldyBNYXAoKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZWRpYVNlY3Rpb25cbiAqIEBwYXJhbSB7UnR4UFR9IHJ0eFB0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBuZXdNZWRpYVNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGVsZXRlRm10cEF0dHJpYnV0ZXNGb3JSdHhQdChtZWRpYVNlY3Rpb24sIHJ0eFB0KSB7XG4gICAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiYT1mbXRwOlwiICsgcnR4UHQgKyBcIi4qXFxyXFxuXCIsICdnbScpO1xuICAgIHJldHVybiBtZWRpYVNlY3Rpb24ucmVwbGFjZShwYXR0ZXJuLCAnJyk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZWRpYVNlY3Rpb25cbiAqIEBwYXJhbSB7UnR4UFR9IHJ0eFB0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBuZXdNZWRpYVNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGVsZXRlUnRwbWFwQXR0cmlidXRlc0ZvclJ0eFB0KG1lZGlhU2VjdGlvbiwgcnR4UHQpIHtcbiAgICB2YXIgcGF0dGVybiA9IG5ldyBSZWdFeHAoXCJhPXJ0cG1hcDpcIiArIHJ0eFB0ICsgXCIuKlxcclxcblwiLCAnZ20nKTtcbiAgICByZXR1cm4gbWVkaWFTZWN0aW9uLnJlcGxhY2UocGF0dGVybiwgJycpO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVkaWFTZWN0aW9uXG4gKiBAcGFyYW0ge1J0eFBUfSBydHhQdFxuICogQHBhcmFtIHtOb25SdHhQVH0gcHRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IG5ld01lZGlhU2VjdGlvblxuICovXG5mdW5jdGlvbiBhZGRGbXRwQXR0cmlidXRlRm9yUnR4UHQobWVkaWFTZWN0aW9uLCBydHhQdCwgcHQpIHtcbiAgICByZXR1cm4gbWVkaWFTZWN0aW9uLmVuZHNXaXRoKCdcXHJcXG4nKVxuICAgICAgICA/IG1lZGlhU2VjdGlvbiArIFwiYT1mbXRwOlwiICsgcnR4UHQgKyBcIiBhcHQ9XCIgKyBwdCArIFwiXFxyXFxuXCJcbiAgICAgICAgOiBtZWRpYVNlY3Rpb24gKyBcIlxcclxcbmE9Zm10cDpcIiArIHJ0eFB0ICsgXCIgYXB0PVwiICsgcHQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHdvcmthcm91bmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc3N1ZTgzMjkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIGRpZmZlcmVuY2UgPSByZXF1aXJlKCcuLi8nKS5kaWZmZXJlbmNlO1xudmFyIGZsYXRNYXAgPSByZXF1aXJlKCcuLi8nKS5mbGF0TWFwO1xuLyoqXG4gKiBDcmVhdGUgYSByYW5kb20ge0BsaW5rIFNTUkN9LlxuICogQHJldHVybnMge1NTUkN9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNTUkMoKSB7XG4gICAgdmFyIHNzcmNNYXggPSAweGZmZmZmZmZmO1xuICAgIHJldHVybiBTdHJpbmcoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc3NyY01heCkpO1xufVxuLyoqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY05hbWVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTaW11bGNhc3RFbmFibGVkXG4gKiBAcHJvcGVydHkge01hcDxSdHhTU1JDLCBQcmltYXJ5U1NSQz59IHJ0eFBhaXJzXG4gKiBAcHJvcGVydHkge1NldDxQcmltYXJ5U1NSQz59IHByaW1hcnlTU1JDc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0cmVhbUlkXG4gKiBAcHJvcGVydHkge1RyYWNrLklEfSB0cmFja0lkXG4gKi9cbnZhciBUcmFja0F0dHJpYnV0ZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIE1lZGlhU3RyZWFtVHJhY2t9IGF0dHJpYnV0ZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0ge1RyYWNrLklEfSB0cmFja0lkIC0gVGhlIE1lZGlhU3RyZWFtVHJhY2sgSURcbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtSUR9IHN0cmVhbUlkIC0gVGhlIE1lZGlhU3RyZWFtIElEXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNOYW1lIC0gVGhlIE1lZGlhU3RyZWFtIGNuYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhY2tBdHRyaWJ1dGVzKHRyYWNrSWQsIHN0cmVhbUlkLCBjTmFtZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBjTmFtZToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNOYW1lXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNTaW11bGNhc3RFbmFibGVkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmltYXJ5U1NSQ3M6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydHhQYWlyczoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cmVhbUlkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RyZWFtSWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFja0lkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhY2tJZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHtAbGluayBTaW1TU1JDfXMgdG8gdGhlIHtAbGluayBUcmFja0F0dHJpYnV0ZXN9LlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFRyYWNrQXR0cmlidXRlcy5wcm90b3R5cGUuYWRkU2ltdWxjYXN0U1NSQ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2ltdWxjYXN0RW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaW11bGNhc3RTU1JDcyA9IFtjcmVhdGVTU1JDKCksIGNyZWF0ZVNTUkMoKV07XG4gICAgICAgIHNpbXVsY2FzdFNTUkNzLmZvckVhY2goZnVuY3Rpb24gKHNzcmMpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbWFyeVNTUkNzLmFkZChzc3JjKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLnJ0eFBhaXJzLnNpemUpIHtcbiAgICAgICAgICAgIHNpbXVsY2FzdFNTUkNzLmZvckVhY2goZnVuY3Rpb24gKHNzcmMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ0eFBhaXJzLnNldChjcmVhdGVTU1JDKCksIHNzcmMpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgZ2l2ZW4ge0BsaW5rIFByaW1hcnlTU1JDfSBvciB7QGxpbmsgUnR4U1NSQ30gdG8gdGhlIHtAbGluayBUcmFja0F0dHJpYnV0ZXN9XG4gICAgICogYW5kIHVwZGF0ZSB0aGUgXCJpc1NpbXVsY2FzdEVuYWJsZWRcIiBmbGFnIGlmIGl0IGlzIGFsc28gYSB7QGxpbmsgU2ltU1NSQ30uXG4gICAgICogQHBhcmFtIHtTU1JDfSBzc3JjIC0gVGhlIHtAbGluayBTU1JDfSB0byBiZSBhZGRlZFxuICAgICAqIEBwYXJhbSB7P1ByaW1hcnlTU1JDfSBwcmltYXJ5U1NSQyAtIFRoZSB7QGxpbmsgUHJpbWFyeVNTUkN9OyBpZiB0aGUgZ2l2ZW5cbiAgICAgKiAgIHtAbGluayBTU1JDfSBpdHNlbGYgaXMgdGhlIHtAbGluayBQcmltYXJ5U1NSQ30sIHRoZW4gdGhpcyBpcyBzZXQgdG8gbnVsbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTaW1TU1JDIC0gdHJ1ZSBpZiB0aGUgZ2l2ZW4ge0BsaW5rIFNTUkN9IGlzIGFcbiAgICAgKiAgIHtAbGluayBTaW1TU1JDfTsgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgVHJhY2tBdHRyaWJ1dGVzLnByb3RvdHlwZS5hZGRTU1JDID0gZnVuY3Rpb24gKHNzcmMsIHByaW1hcnlTU1JDLCBpc1NpbVNTUkMpIHtcbiAgICAgICAgaWYgKHByaW1hcnlTU1JDKSB7XG4gICAgICAgICAgICB0aGlzLnJ0eFBhaXJzLnNldChzc3JjLCBwcmltYXJ5U1NSQyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByaW1hcnlTU1JDcy5hZGQoc3NyYyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1NpbXVsY2FzdEVuYWJsZWQgPSB0aGlzLmlzU2ltdWxjYXN0RW5hYmxlZCB8fCBpc1NpbVNTUkM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgdGhlIFNEUCBsaW5lcyBmb3IgdGhlIHtAbGluayBUcmFja0F0dHJpYnV0ZXN9LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4Y2x1ZGVSdHg9ZmFsc2VdXG4gICAgICogQHJldHVybnMge0FycmF5PHN0cmluZz59IEFycmF5IG9mIFNEUCBsaW5lc1xuICAgICAqL1xuICAgIFRyYWNrQXR0cmlidXRlcy5wcm90b3R5cGUudG9TZHBMaW5lcyA9IGZ1bmN0aW9uIChleGNsdWRlUnR4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBydHhQYWlycyA9IGV4Y2x1ZGVSdHhcbiAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgIDogQXJyYXkuZnJvbSh0aGlzLnJ0eFBhaXJzLmVudHJpZXMoKSkubWFwKGZ1bmN0aW9uIChydHhQYWlyKSB7IHJldHVybiBydHhQYWlyLnJldmVyc2UoKTsgfSk7XG4gICAgICAgIHZhciBzaW1TU1JDcyA9IEFycmF5LmZyb20odGhpcy5wcmltYXJ5U1NSQ3MudmFsdWVzKCkpO1xuICAgICAgICB2YXIgc3NyY3MgPSBydHhQYWlycy5sZW5ndGggPyBmbGF0TWFwKHJ0eFBhaXJzKSA6IHNpbVNTUkNzO1xuICAgICAgICB2YXIgYXR0ckxpbmVzID0gZmxhdE1hcChzc3JjcywgZnVuY3Rpb24gKHNzcmMpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIFwiYT1zc3JjOlwiICsgc3NyYyArIFwiIGNuYW1lOlwiICsgX3RoaXMuY05hbWUsXG4gICAgICAgICAgICBcImE9c3NyYzpcIiArIHNzcmMgKyBcIiBtc2lkOlwiICsgX3RoaXMuc3RyZWFtSWQgKyBcIiBcIiArIF90aGlzLnRyYWNrSWRcbiAgICAgICAgXTsgfSk7XG4gICAgICAgIHZhciBydHhQYWlyTGluZXMgPSBydHhQYWlycy5tYXAoZnVuY3Rpb24gKHJ0eFBhaXIpIHsgcmV0dXJuIFwiYT1zc3JjLWdyb3VwOkZJRCBcIiArIHJ0eFBhaXIuam9pbignICcpOyB9KTtcbiAgICAgICAgdmFyIHNpbUdyb3VwTGluZXMgPSBbXG4gICAgICAgICAgICBcImE9c3NyYy1ncm91cDpTSU0gXCIgKyBzaW1TU1JDcy5qb2luKCcgJylcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHJ0eFBhaXJMaW5lcy5jb25jYXQoYXR0ckxpbmVzKS5jb25jYXQoc2ltR3JvdXBMaW5lcyk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhY2tBdHRyaWJ1dGVzO1xufSgpKTtcbi8qKlxuICogR2V0IHRoZSBtYXRjaGVzIGZvciBhIGdpdmVuIFJlZ0V4IHBhdHRlcm4uXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VjdGlvbiAtIFNEUCBtZWRpYSBzZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiAtIFJlZ0V4IHBhdHRlcm5cbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxzdHJpbmc+Pn0gLSBBcnJheSBvZiBwYXR0ZXJuIG1hdGNoZXNcbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hlcyhzZWN0aW9uLCBwYXR0ZXJuKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBzZWN0aW9uLm1hdGNoKG5ldyBSZWdFeHAocGF0dGVybiwgJ2dtJykpIHx8IFtdO1xuICAgIHJldHVybiBtYXRjaGVzLm1hcChmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBtYXRjaC5tYXRjaChuZXcgUmVnRXhwKHBhdHRlcm4pKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXMuc2xpY2UoMSk7XG4gICAgfSk7XG59XG4vKipcbiAqIEdldCB0aGUge0BsaW5rIFNpbVNTUkN9cyB0aGF0IGJlbG9uZyB0byBhIHNpbXVsY2FzdCBncm91cC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uIC0gU0RQIG1lZGlhIHNlY3Rpb25cbiAqIEByZXR1cm5zIHtTZXQ8U2ltU1NSQz59IFNldCBvZiBzaW11bGNhc3Qge0BsaW5rIFNTUkN9c1xuICovXG5mdW5jdGlvbiBnZXRTaW11bGNhc3RTU1JDcyhzZWN0aW9uKSB7XG4gICAgdmFyIHNpbUdyb3VwUGF0dGVybiA9ICdeYT1zc3JjLWdyb3VwOlNJTSAoWzAtOV0rKSAoWzAtOV0rKSAoWzAtOV0rKSQnO1xuICAgIHJldHVybiBuZXcgU2V0KGZsYXRNYXAoZ2V0TWF0Y2hlcyhzZWN0aW9uLCBzaW1Hcm91cFBhdHRlcm4pKSk7XG59XG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGF0dHJpYnV0ZSBmb3IgYW4gU1NSQy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uIC0gU0RQIG1lZGlhIHNlY3Rpb25cbiAqIEBwYXJhbSB7U1NSQ30gc3NyYyAtIHtAbGluayBTU1JDfSB3aG9zZSBhdHRyaWJ1dGUncyB2YWx1ZSBpcyB0byBiZSBkZXRlcm1pbmRlZFxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSAtIHtAbGluayBTU1JDfSBhdHRyaWJ1dGUgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IC0ge0BsaW5rIFNTUkN9IGF0dHJpYnV0ZSB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZXRTU1JDQXR0cmlidXRlKHNlY3Rpb24sIHNzcmMsIGF0dHJpYnV0ZSkge1xuICAgIHZhciBwYXR0ZXJuID0gXCJhPXNzcmM6XCIgKyBzc3JjICsgXCIgXCIgKyBhdHRyaWJ1dGUgKyBcIjooLispXCI7XG4gICAgcmV0dXJuIHNlY3Rpb24ubWF0Y2gobmV3IFJlZ0V4cChwYXR0ZXJuKSlbMV07XG59XG4vKipcbiAqIENyZWF0ZSBhIE1hcCBvZiB7QGxpbmsgUHJpbWFyeVNTUkN9cyBhbmQgdGhlaXIge0BsaW5rIFJ0eFNTUkN9cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uIC0gU0RQIG1lZGlhIHNlY3Rpb25cbiAqIEByZXR1cm5zIHtNYXA8UnR4U1NSQywgUHJpbWFyeVNTUkM+fSAtIE1hcCBvZiB7QGxpbmsgUnR4U1NSQ31zIGFuZCB0aGVpclxuICogICBjb3JyZXNwb25kaW5nIHtAbGluayBQcmltYXJ5U1NSQ31zXG4gKi9cbmZ1bmN0aW9uIGdldFNTUkNSdHhQYWlycyhzZWN0aW9uKSB7XG4gICAgdmFyIHJ0eFBhaXJQYXR0ZXJuID0gJ15hPXNzcmMtZ3JvdXA6RklEIChbMC05XSspIChbMC05XSspJCc7XG4gICAgcmV0dXJuIG5ldyBNYXAoZ2V0TWF0Y2hlcyhzZWN0aW9uLCBydHhQYWlyUGF0dGVybikubWFwKGZ1bmN0aW9uIChwYWlyKSB7IHJldHVybiBwYWlyLnJldmVyc2UoKTsgfSkpO1xufVxuLyoqXG4gKiBDcmVhdGUgU1NSQyBhdHRyaWJ1dGUgdHVwbGVzLlxuICogQHBhcmFtIHtzdHJpbmd9IHNlY3Rpb25cbiAqIEBwYXJhbSB7J3BsYW5iJyB8ICd1bmlmaWVkJ30gc2RwRm9ybWF0XG4gKiBAcmV0dXJucyB7QXJyYXk8W1NTUkMsIE1lZGlhU3RyZWFtSUQsIFRyYWNrLklEXT59XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNTUkNBdHRyaWJ1dGVUdXBsZXMoc2VjdGlvbiwgc2RwRm9ybWF0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGxhbmI6IGNyZWF0ZVBsYW5CU1NSQ0F0dHJpYnV0ZVR1cGxlcyxcbiAgICAgICAgdW5pZmllZDogY3JlYXRlVW5pZmllZFBsYW5TU1JDQXR0cmlidXRlVHVwbGVzXG4gICAgfVtzZHBGb3JtYXRdKHNlY3Rpb24pO1xufVxuLyoqXG4gKiBDcmVhdGUgXCJwbGFuLWJcIiBTU1JDIGF0dHJpYnV0ZSB0dXBsZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VjdGlvblxuICogQHJldHVybnMge0FycmF5PFtTU1JDLCBNZWRpYVN0cmVhbUlELCBUcmFjay5JRF0+fVxuICovXG5mdW5jdGlvbiBjcmVhdGVQbGFuQlNTUkNBdHRyaWJ1dGVUdXBsZXMoc2VjdGlvbikge1xuICAgIHJldHVybiBnZXRNYXRjaGVzKHNlY3Rpb24sICdeYT1zc3JjOihbMC05XSspIG1zaWQ6KFteXFxcXHNdKykgKFteXFxcXHNdKykkJyk7XG59XG4vKipcbiAqIENyZWF0ZSBcInVuaWZpZWQtcGxhblwiIFNTUkMgYXR0cmlidXRlIHR1cGxlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uXG4gKiBAcmV0dXJucyB7QXJyYXk8W1NTUkMsIE1lZGlhU3RyZWFtSUQsIFRyYWNrLklEXT59XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVuaWZpZWRQbGFuU1NSQ0F0dHJpYnV0ZVR1cGxlcyhzZWN0aW9uKSB7XG4gICAgdmFyIF9hID0gX19yZWFkKGZsYXRNYXAoZ2V0TWF0Y2hlcyhzZWN0aW9uLCAnXmE9bXNpZDooLispICguKykkJykpLCAyKSwgc3RyZWFtSWQgPSBfYVswXSwgdHJhY2tJZCA9IF9hWzFdO1xuICAgIHZhciBzc3JjcyA9IGZsYXRNYXAoZ2V0TWF0Y2hlcyhzZWN0aW9uLCAnXmE9c3NyYzooLispIGNuYW1lOi4rJCcpKTtcbiAgICByZXR1cm4gc3NyY3MubWFwKGZ1bmN0aW9uIChzc3JjKSB7IHJldHVybiBbc3NyYywgc3RyZWFtSWQsIHRyYWNrSWRdOyB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgTWFwIG9mIE1lZGlhU3RyZWFtVHJhY2sgSURzIGFuZCB0aGVpciB7QGxpbmsgVHJhY2tBdHRyaWJ1dGVzfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uIC0gU0RQIG1lZGlhIHNlY3Rpb25cbiAqIEBwYXJhbSB7J3BsYW5iJyB8ICd1bmlmaWVkJ30gc2RwRm9ybWF0XG4gKiBAcmV0dXJucyB7TWFwPFRyYWNrLklELCBUcmFja0F0dHJpYnV0ZXM+fVxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFja0lkc1RvQXR0cmlidXRlcyhzZWN0aW9uLCBzZHBGb3JtYXQpIHtcbiAgICB2YXIgc2ltU1NSQ3MgPSBnZXRTaW11bGNhc3RTU1JDcyhzZWN0aW9uKTtcbiAgICB2YXIgcnR4UGFpcnMgPSBnZXRTU1JDUnR4UGFpcnMoc2VjdGlvbik7XG4gICAgdmFyIHNzcmNBdHRyVHVwbGVzID0gY3JlYXRlU1NSQ0F0dHJpYnV0ZVR1cGxlcyhzZWN0aW9uLCBzZHBGb3JtYXQpO1xuICAgIHJldHVybiBzc3JjQXR0clR1cGxlcy5yZWR1Y2UoZnVuY3Rpb24gKHRyYWNrSWRzVG9TU1JDcywgdHVwbGUpIHtcbiAgICAgICAgdmFyIHNzcmMgPSB0dXBsZVswXTtcbiAgICAgICAgdmFyIHN0cmVhbUlkID0gdHVwbGVbMV07XG4gICAgICAgIHZhciB0cmFja0lkID0gdHVwbGVbMl07XG4gICAgICAgIHZhciB0cmFja0F0dHJpYnV0ZXMgPSB0cmFja0lkc1RvU1NSQ3MuZ2V0KHRyYWNrSWQpIHx8IG5ldyBUcmFja0F0dHJpYnV0ZXModHJhY2tJZCwgc3RyZWFtSWQsIGdldFNTUkNBdHRyaWJ1dGUoc2VjdGlvbiwgc3NyYywgJ2NuYW1lJykpO1xuICAgICAgICB2YXIgcHJpbWFyeVNTUkMgPSBydHhQYWlycy5nZXQoc3NyYykgfHwgbnVsbDtcbiAgICAgICAgdHJhY2tBdHRyaWJ1dGVzLmFkZFNTUkMoc3NyYywgcHJpbWFyeVNTUkMsIHNpbVNTUkNzLmhhcyhzc3JjKSk7XG4gICAgICAgIHJldHVybiB0cmFja0lkc1RvU1NSQ3Muc2V0KHRyYWNrSWQsIHRyYWNrQXR0cmlidXRlcyk7XG4gICAgfSwgbmV3IE1hcCgpKTtcbn1cbi8qKlxuICogQXBwbHkgc2ltdWxjYXN0IHNldHRpbmdzIHRvIHRoZSBnaXZlbiBTRFAgbWVkaWEgc2VjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWN0aW9uIC0gU0RQIG1lZGlhIHNlY3Rpb25cbiAqIEBwYXJhbSB7J3BsYW5iJyB8ICd1bmlmaWVkJ30gc2RwRm9ybWF0XG4gKiBAcGFyYW0ge01hcDxUcmFjay5JRCwgVHJhY2tBdHRyaWJ1dGVzPn0gdHJhY2tJZHNUb0F0dHJpYnV0ZXMgLSBFeGlzdGluZ1xuICogICBtYXAgd2hpY2ggd2lsbCBiZSB1cGRhdGVkIGZvciBuZXcgTWVkaWFTdHJlYW1UcmFjayBJRHNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIHRyYW5zZm9ybWVkIFNEUCBtZWRpYSBzZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIHNldFNpbXVsY2FzdEluTWVkaWFTZWN0aW9uKHNlY3Rpb24sIHNkcEZvcm1hdCwgdHJhY2tJZHNUb0F0dHJpYnV0ZXMpIHtcbiAgICB2YXIgbmV3VHJhY2tJZHNUb0F0dHJpYnV0ZXMgPSBjcmVhdGVUcmFja0lkc1RvQXR0cmlidXRlcyhzZWN0aW9uLCBzZHBGb3JtYXQpO1xuICAgIHZhciBuZXdUcmFja0lkcyA9IEFycmF5LmZyb20obmV3VHJhY2tJZHNUb0F0dHJpYnV0ZXMua2V5cygpKTtcbiAgICB2YXIgdHJhY2tJZHMgPSBBcnJheS5mcm9tKHRyYWNrSWRzVG9BdHRyaWJ1dGVzLmtleXMoKSk7XG4gICAgdmFyIHRyYWNrSWRzVG9BZGQgPSBkaWZmZXJlbmNlKG5ld1RyYWNrSWRzLCB0cmFja0lkcyk7XG4gICAgdmFyIHRyYWNrSWRzVG9JZ25vcmUgPSBkaWZmZXJlbmNlKHRyYWNrSWRzLCBuZXdUcmFja0lkcyk7XG4gICAgLy8gVXBkYXRlIFwidHJhY2tJZHNUb0F0dHJpYnV0ZXNcIiB3aXRoIFRyYWNrQXR0cmlidXRlcyBmb3IgbmV3XG4gICAgLy8gTWVkaWFTdHJlYW1UcmFjayBJRHMuXG4gICAgdmFyIHRyYWNrQXR0cmlidXRlc1RvQWRkID0gZmxhdE1hcCh0cmFja0lkc1RvQWRkLCBmdW5jdGlvbiAodHJhY2tJZCkgeyByZXR1cm4gbmV3VHJhY2tJZHNUb0F0dHJpYnV0ZXMuZ2V0KHRyYWNrSWQpOyB9KTtcbiAgICB0cmFja0F0dHJpYnV0ZXNUb0FkZC5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgdHJhY2tBdHRyaWJ1dGVzLmFkZFNpbXVsY2FzdFNTUkNzKCk7XG4gICAgICAgIHRyYWNrSWRzVG9BdHRyaWJ1dGVzLnNldCh0cmFja0F0dHJpYnV0ZXMudHJhY2tJZCwgdHJhY2tBdHRyaWJ1dGVzKTtcbiAgICB9KTtcbiAgICAvLyBHZXQgdGhlIFNEUCBsaW5lcyBvZiB0aGUgcmVsZXZhbnQgTWVkaWFTdHJlYW1UcmFjayBJRHMgZnJvbVxuICAgIC8vIFwidHJhY2tJZHNUb0F0dHJpYnV0ZXNcIi5cbiAgICB0cmFja0lkcyA9IEFycmF5LmZyb20odHJhY2tJZHNUb0F0dHJpYnV0ZXMua2V5cygpKTtcbiAgICB2YXIgcmVsZXZhbnRUcmFja0lkcyA9IGRpZmZlcmVuY2UodHJhY2tJZHMsIHRyYWNrSWRzVG9JZ25vcmUpO1xuICAgIHZhciByZWxldmFudFRyYWNrQXR0cmlidXRlcyA9IGZsYXRNYXAocmVsZXZhbnRUcmFja0lkcywgZnVuY3Rpb24gKHRyYWNrSWQpIHsgcmV0dXJuIHRyYWNrSWRzVG9BdHRyaWJ1dGVzLmdldCh0cmFja0lkKTsgfSk7XG4gICAgdmFyIGV4Y2x1ZGVSdHggPSAhc2VjdGlvbi5tYXRjaCgvYT1ydHBtYXA6WzAtOV0rIHJ0eC8pO1xuICAgIHZhciByZWxldmFudFNkcExpbmVzID0gZmxhdE1hcChyZWxldmFudFRyYWNrQXR0cmlidXRlcywgZnVuY3Rpb24gKHRyYWNrQXR0cmlidXRlcykgeyByZXR1cm4gdHJhY2tBdHRyaWJ1dGVzLnRvU2RwTGluZXMoZXhjbHVkZVJ0eCk7IH0pO1xuICAgIC8vIEFkZCB0aGUgc2ltdWxjYXN0IFNTUkMgU0RQIGxpbmVzIHRvIHRoZSBtZWRpYSBzZWN0aW9uLiBUaGUgU2V0IGVuc3VyZXNcbiAgICAvLyB0aGF0IHRoZSBkdXBsaWNhdGVzIG9mIHRoZSBTU1JDIFNEUCBsaW5lcyB0aGF0IGFyZSBpbiBib3RoIFwic2VjdGlvblwiIGFuZFxuICAgIC8vIFwicmVsZXZhbnRTZHBMaW5lc1wiIGFyZSByZW1vdmVkLlxuICAgIHZhciBzZWN0aW9uTGluZXMgPSBmbGF0TWFwKG5ldyBTZXQoc2VjdGlvbi5zcGxpdCgnXFxyXFxuJykuY29uY2F0KHJlbGV2YW50U2RwTGluZXMpKSk7XG4gICAgdmFyIHhHb29nbGVGbGFnQ29uZmVyZW5jZSA9ICdhPXgtZ29vZ2xlLWZsYWc6Y29uZmVyZW5jZSc7XG4gICAgaWYgKCFzZWN0aW9uLm1hdGNoKHhHb29nbGVGbGFnQ29uZmVyZW5jZSkpIHtcbiAgICAgICAgc2VjdGlvbkxpbmVzLnB1c2goeEdvb2dsZUZsYWdDb25mZXJlbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlY3Rpb25MaW5lcy5qb2luKCdcXHJcXG4nKTtcbn1cbi8qKlxuICogU3RyaW5nIHJlcHJlc2VudGluZyBhIE1lZGlhU3RyZWFtIElELlxuICogQHR5cGVkZWYge3N0cmluZ30gTWVkaWFTdHJlYW1JRFxuICovXG4vKipcbiAqIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIFNTUkMgb2YgYSBNZWRpYVN0cmVhbVRyYWNrLlxuICogQHR5cGVkZWYge3N0cmluZ30gU1NSQ1xuICovXG4vKipcbiAqIFByaW1hcnkgU1NSQy5cbiAqIEB0eXBlZGVmIHtTU1JDfSBQcmltYXJ5U1NSQ1xuICovXG4vKipcbiAqIFJldHJhbnNtaXNzaW9uIFNTUkMuXG4gKiBAdHlwZWRlZiB7U1NSQ30gUnR4U1NSQ1xuICovXG4vKipcbiAqIFNpbXVsY2FzdCBTU1JDLlxuICogQHR5cGVkZWYge1NTUkN9IFNpbVNTUkNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBzZXRTaW11bGNhc3RJbk1lZGlhU2VjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXVsY2FzdC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEFuIHtAbGluayBJZGVudGl0eVRyYWNrTWF0Y2hlcn0gbWF0Y2hlcyBSVENUcmFja0V2ZW50cyB3aXRoIHRoZWlyIHJlc3BlY3RpdmVcbiAqIE1lZGlhU3RyZWFtVHJhY2sgSURzLlxuICovXG52YXIgSWRlbnRpdHlUcmFja01hdGNoZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWRlbnRpdHlUcmFja01hdGNoZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICogTWF0Y2ggYSBnaXZlbiBNZWRpYVN0cmVhbVRyYWNrIHdpdGggaXRzIElELlxuICAgICogQHBhcmFtIHtSVENUcmFja0V2ZW50fSBldmVudFxuICAgICogQHJldHVybnMge1RyYWNrLklEfVxuICAgICovXG4gICAgSWRlbnRpdHlUcmFja01hdGNoZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC50cmFjay5pZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICogVXBkYXRlIHRoZSB7QGxpbmsgSWRlbnRpdHlUcmFja01hdGNoZXJ9IHdpdGggYSBuZXcgU0RQLlxuICAgICogQHBhcmFtIHtzdHJpbmd9IHNkcFxuICAgICovXG4gICAgSWRlbnRpdHlUcmFja01hdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gSWRlbnRpdHlUcmFja01hdGNoZXI7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBJZGVudGl0eVRyYWNrTWF0Y2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkZW50aXR5LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRNZWRpYVNlY3Rpb25zID0gcmVxdWlyZSgnLi4vJykuZ2V0TWVkaWFTZWN0aW9ucztcbi8qKlxuICogQW4ge0BsaW5rIE1JRFRyYWNrTWF0Y2hlcn0gbWF0Y2hlcyBhbiBSVENUcmFja0V2ZW50IHdpdGggYSBNZWRpYVN0cmVhbVRyYWNrXG4gKiBJRCBiYXNlZCBvbiB0aGUgTUlEIG9mIHRoZSB1bmRlcmx5aW5nIFJUQ1J0cFRyYW5zY2VpdmVyLlxuICovXG52YXIgTUlEVHJhY2tNYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiB7QGxpbmsgTUlEVHJhY2tNYXRjaGVyfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNSURUcmFja01hdGNoZXIoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIF9taWRzVG9UcmFja0lkczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIGEgZ2l2ZW4gTWVkaWFTdHJlYW1UcmFjayB3aXRoIGl0cyBJRC5cbiAgICAgKiBAcGFyYW0ge1JUQ1RyYWNrRXZlbnR9IGV2ZW50XG4gICAgICogQHJldHVybnMgez9UcmFjay5JRH1cbiAgICAgKi9cbiAgICBNSURUcmFja01hdGNoZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taWRzVG9UcmFja0lkcy5nZXQoZXZlbnQudHJhbnNjZWl2ZXIubWlkKSB8fCBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB7QGxpbmsgTUlEVHJhY2tNYXRjaGVyfSB3aXRoIGEgbmV3IFNEUC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2RwXG4gICAgICovXG4gICAgTUlEVHJhY2tNYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoc2RwKSB7XG4gICAgICAgIHZhciBzZWN0aW9ucyA9IGdldE1lZGlhU2VjdGlvbnMoc2RwLCAnKGF1ZGlvfHZpZGVvKScpO1xuICAgICAgICB0aGlzLl9taWRzVG9UcmFja0lkcyA9IHNlY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAobWlkc1RvVHJhY2tJZHMsIHNlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBtaWRNYXRjaGVzID0gc2VjdGlvbi5tYXRjaCgvXmE9bWlkOiguKykkL20pIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHRyYWNrSWRNYXRjaGVzID0gc2VjdGlvbi5tYXRjaCgvXmE9bXNpZDouKyAoLispJC9tKSB8fCBbXTtcbiAgICAgICAgICAgIHZhciBtaWQgPSBtaWRNYXRjaGVzWzFdO1xuICAgICAgICAgICAgdmFyIHRyYWNrSWQgPSB0cmFja0lkTWF0Y2hlc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBtaWQgJiYgdHJhY2tJZCA/IG1pZHNUb1RyYWNrSWRzLnNldChtaWQsIHRyYWNrSWQpIDogbWlkc1RvVHJhY2tJZHM7XG4gICAgICAgIH0sIHRoaXMuX21pZHNUb1RyYWNrSWRzKTtcbiAgICB9O1xuICAgIHJldHVybiBNSURUcmFja01hdGNoZXI7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBNSURUcmFja01hdGNoZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taWQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8nKTtcbnZhciBnZXRNZWRpYVNlY3Rpb25zID0gcmVxdWlyZSgnLi4vJykuZ2V0TWVkaWFTZWN0aW9ucztcbi8vIE5PVEUobXJvYmVydHMpOiBPcmRlcmVkVHJhY2tNYXRjaGVyIGlzIG1lYW50IHRvIHNvbHZlIHRoZSBwcm9ibGVtIGlkZW50aWZpZWQgaW5cbi8vXG4vLyAgIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzQ1MTlcbi8vXG4vLyBOYW1lbHkgdGhhdCwgd2l0aG91dCBNSURzLCB3ZSBjYW5ub3QgXCJjb3JyZWN0bHlcIiBpZGVudGlmeSBNZWRpYVN0cmVhbVRyYWNrc1xuLy8gaW4gU2FmYXJpJ3MgY3VycmVudCBXZWJSVEMgaW1wbGVtZW50YXRpb24uIFNvLCB0aGlzIG1vZHVsZSB0cmllcyB0byBoYWNrXG4vLyBhcm91bmQgdGhpcyBieSBtYWtpbmcgYSBwb3NzaWJseSBkYW5nZXJvdXMgYXNzdW1wdGlvbjogXCJ0cmFja1wiIGV2ZW50cyB3aWxsXG4vLyBiZSByYWlzZWQgZm9yIE1lZGlhU3RyZWFtVHJhY2tzIG9mIGEgcGFydGljdWxhciBraW5kIGluIHRoZSBzYW1lIG9yZGVyIHRoYXRcbi8vIHRob3NlIGtpbmRzJyBNU0lEcyBhcHBlYXIgaW4gdGhlIFNEUC4gQnkgY2FsbGluZyBgdXBkYXRlYCB3aXRoIGFuXG4vLyBSVENQZWVyQ29ubmVjdGlvbidzIGByZW1vdGVEZXNjcmlwdGlvbmAgYW5kIHRoZW4gaW52b2tpbmcgYG1hdGNoYCwgd2Ugb3VnaHRcbi8vIHRvIGJlIGFibGUgdG8gZGVxdWV1ZSBNZWRpYVN0cmVhbVRyYWNrIElEcyBpbiB0aGUgY29ycmVjdCBvcmRlciB0byBiZVxuLy8gYXNzaWduZWQgdG8gXCJ0cmFja1wiIGV2ZW50cy5cbi8qKlxuICogQGludGVyZmFjZSBNYXRjaGVkQW5kVW5tYXRjaGVkXG4gKiBAcHJvcGVydHkge1NldDxUcmFjay5JRD59IG1hdGNoZWRcbiAqIEBwcm9wZXJ0eSB7U2V0PFRyYWNrLklEPn0gdW5tYXRjaGVkXG4gKi9cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBNYXRjaGVkQW5kVW5tYXRjaGVkfS5cbiAqIEByZXR1cm5zIHtNYXRjaGVkQW5kVW5tYXRjaGVkfVxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlZDogbmV3IFNldCgpLFxuICAgICAgICB1bm1hdGNoZWQ6IG5ldyBTZXQoKVxuICAgIH07XG59XG4vKipcbiAqIEF0dGVtcHQgdG8gbWF0Y2ggYSBNZWRpYVN0cmVhbVRyYWNrIElELlxuICogQHBhcmFtIHtNYXRjaGVkQW5kVW5tYXRjaGVkfSBtQW5kTVxuICogQHJldHVybnMgez9UcmFjay5JRH0gaWRcbiAqL1xuZnVuY3Rpb24gbWF0Y2gobUFuZE0pIHtcbiAgICB2YXIgdW5tYXRjaGVkID0gQXJyYXkuZnJvbShtQW5kTS51bm1hdGNoZWQpO1xuICAgIGlmICghdW5tYXRjaGVkLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGlkID0gdW5tYXRjaGVkWzBdO1xuICAgIG1BbmRNLm1hdGNoZWQuYWRkKGlkKTtcbiAgICBtQW5kTS51bm1hdGNoZWQuZGVsZXRlKGlkKTtcbiAgICByZXR1cm4gaWQ7XG59XG4vKipcbiAqIFVwZGF0ZSBhIHtAbGluayBNYXRjaGVkQW5kVW5tYXRjaGVkfSdzIE1lZGlhU3RyZWFtVHJhY2sgSURzLlxuICogQHBhcmFtIHtNYXRjaGVkQW5kVW5tYXRjaGVkfSBtQW5kTVxuICogQHBhcmFtIHtTZXQ8VHJhY2suSUQ+fSBpZHNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGUobUFuZE0sIGlkcykge1xuICAgIGlkcyA9IG5ldyBTZXQoaWRzKTtcbiAgICB2YXIgcmVtb3ZlZE1hdGNoZWRJZHMgPSB1dGlsLmRpZmZlcmVuY2UobUFuZE0ubWF0Y2hlZCwgaWRzKTtcbiAgICByZW1vdmVkTWF0Y2hlZElkcy5mb3JFYWNoKG1BbmRNLm1hdGNoZWQuZGVsZXRlLCBtQW5kTS5tYXRjaGVkKTtcbiAgICBtQW5kTS51bm1hdGNoZWQgPSB1dGlsLmRpZmZlcmVuY2UoaWRzLCBtQW5kTS5tYXRjaGVkKTtcbn1cbi8qKlxuICogUGFyc2UgTWVkaWFTdHJlYW1UcmFjayBJRHMgb2YgYSBwYXJ0aWN1bGFyIGtpbmQgZnJvbSBhbiBTRFAuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICogQHBhcmFtIHtzdHJpbmd9IHNkcFxuICogQHJldHVybnMge1NldDxUcmFjay5JRD59IGlkc1xuICovXG5mdW5jdGlvbiBwYXJzZShraW5kLCBzZHApIHtcbiAgICB2YXIgbWVkaWFTZWN0aW9ucyA9IGdldE1lZGlhU2VjdGlvbnMoc2RwLCBraW5kKTtcbiAgICB2YXIgcGF0dGVybiA9ICdtc2lkOiA/KC4rKSArKC4rKSA/JCc7XG4gICAgcmV0dXJuIG5ldyBTZXQodXRpbC5mbGF0TWFwKG1lZGlhU2VjdGlvbnMsIGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHsgcmV0dXJuIG1lZGlhU2VjdGlvbi5tYXRjaChuZXcgUmVnRXhwKHBhdHRlcm4sICdtZycpKSB8fCBbXTsgfSkubWFwKGZ1bmN0aW9uIChtc2lkKSB7IHJldHVybiBtc2lkLm1hdGNoKG5ldyBSZWdFeHAocGF0dGVybikpWzJdOyB9KSk7XG59XG4vKipcbiAqIEEge0BsaW5rIE9yZGVyZWRUcmFja01hdGNoZXJ9IGlzIHVzZWQgdG8gbWF0Y2ggUlRDVHJhY2tFdmVudHMuXG4gKiBAcHJvcGVydHkge01hdGNoZWRBbmRVbm1hdGNoZWR9IGF1ZGlvXG4gKiBAcHJvcGVydHkge01hdGNoZWRBbmRVbm1hdGNoZWR9IHZpZGVvXG4gKi9cbnZhciBPcmRlcmVkVHJhY2tNYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9yZGVyZWRUcmFja01hdGNoZXIoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPcmRlcmVkVHJhY2tNYXRjaGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPcmRlcmVkVHJhY2tNYXRjaGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgYXVkaW86IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjcmVhdGUoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY3JlYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gbWF0Y2ggYSBuZXcgTWVkaWFTdHJlYW1UcmFjayBJRC5cbiAgICAgKiBAcGFyYW0ge1JUQ1RyYWNrRXZlbnR9IGV2ZW50XG4gICAgICogQHJldHVybnMgez9UcmFjay5JRH0gaWRcbiAgICAgKi9cbiAgICBPcmRlcmVkVHJhY2tNYXRjaGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gbWF0Y2godGhpc1tldmVudC50cmFjay5raW5kXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHtAbGluayBPcmRlcmVkVHJhY2tNYXRjaGVyfSB3aXRoIGEgbmV3IFNEUC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2RwXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgT3JkZXJlZFRyYWNrTWF0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHNkcCkge1xuICAgICAgICBbJ2F1ZGlvJywgJ3ZpZGVvJ10uZm9yRWFjaChmdW5jdGlvbiAoa2luZCkge1xuICAgICAgICAgICAgdXBkYXRlKHRoaXNba2luZF0sIHBhcnNlKGtpbmQsIHNkcCkpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBPcmRlcmVkVHJhY2tNYXRjaGVyO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gT3JkZXJlZFRyYWNrTWF0Y2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9yZGVyZWQuanMubWFwIiwiLyogZ2xvYmFscyBjaHJvbWUsIG5hdmlnYXRvciAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9hID0gcmVxdWlyZSgnQHR3aWxpby93ZWJydGMvbGliL3V0aWwnKSwgZ3Vlc3NCcm93c2VyID0gX2EuZ3Vlc3NCcm93c2VyLCBpc1dlYlJUQ1N1cHBvcnRlZCA9IF9hLnN1cHBvcnQ7XG52YXIgU1VQUE9SVEVEX0NIUk9NRV9CQVNFRF9CUk9XU0VSUyA9IFtcbiAgICAnZWRnJyxcbiAgICAnZWRnZScsXG4gICAgJ2VsZWN0cm9uJyxcbiAgICAnaGVhZGxlc3NjaHJvbWUnXG5dO1xudmFyIFNVUFBPUlRFRF9BTkRST0lEX0JST1dTRVJTID0gW1xuICAgICdjaHJvbWUnLFxuICAgICdmaXJlZm94J1xuXTtcbnZhciBTVVBQT1JURURfSU9TX0JST1dTRVJTID0gW1xuICAgICdzYWZhcmknXG5dO1xuLy8gQ3VycmVudGx5IG5vbmUuIEFkZCAnYnJhdmUnLCAnZWRnJywgYW5kICdlZGdlJyBoZXJlIG9uY2Ugd2Ugc3RhcnQgc3VwcG9ydGluZyB0aGVtXG52YXIgU1VQUE9SVEVEX01PQklMRV9XRUJLSVRfQkFTRURfQlJPV1NFUlMgPSBbXTtcbi8qKlxuICogR2V0IHRoZSB0b3AgbGV2ZWwgcGFyZW50aGVzaXplZCBzdWJzdHJpbmdzIHdpdGhpbiBhIGdpdmVuIHN0cmluZy4gVW5tYXRjaGVkXG4gKiBwYXJlbnRoZXNlcyBhcmUgaWdub3JlZC5cbiAqIEV4OiBcImFiYykgKGRlZikgZ2goaWopIChrbCAobW4pbykgKHBxclwiID0+IFtcIihkZWYpXCIsIFwiKGlqKVwiLCBcIihrbCAobW4pbylcIl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50aGVzaXplZFN1YnN0cmluZ3Moc3RyaW5nKSB7XG4gICAgdmFyIG9wZW5QYXJlbnRoZXNpc1Bvc2l0aW9ucyA9IFtdO1xuICAgIHZhciBzdWJzdHJpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cmluZ1tpXSA9PT0gJygnKSB7XG4gICAgICAgICAgICBvcGVuUGFyZW50aGVzaXNQb3NpdGlvbnMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJpbmdbaV0gPT09ICcpJyAmJiBvcGVuUGFyZW50aGVzaXNQb3NpdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIG9wZW5QYXJlbnRoZXNpc1Bvc2l0aW9uID0gb3BlblBhcmVudGhlc2lzUG9zaXRpb25zLnBvcCgpO1xuICAgICAgICAgICAgaWYgKG9wZW5QYXJlbnRoZXNpc1Bvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdWJzdHJpbmdzLnB1c2goc3RyaW5nLnN1YnN0cmluZyhvcGVuUGFyZW50aGVzaXNQb3NpdGlvbiwgaSArIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3Vic3RyaW5ncztcbn1cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIGlzIGEgbW9iaWxlIGJyb3dzZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyQWdlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vYmlsZSh1c2VyQWdlbnQpIHtcbiAgICB1c2VyQWdlbnQgPSB1c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICByZXR1cm4gL01vYmkvLnRlc3QodXNlckFnZW50KTtcbn1cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIGlzIG5vbi1DaHJvbWl1bSBFZGdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGJyb3dzZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc05vbkNocm9taXVtRWRnZShicm93c2VyKSB7XG4gICAgcmV0dXJuIGJyb3dzZXIgPT09ICdjaHJvbWUnICYmIC9FZGdlLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICh0eXBlb2YgY2hyb21lID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgY2hyb21lLnJ1bnRpbWUgPT09ICd1bmRlZmluZWQnKTtcbn1cbi8qKlxuICogR2V0IHRoZSBuYW1lIG9mIHRoZSByZWJyYW5kZWQgQ2hyb21pdW0gYnJvd3NlciwgaWYgYW55LiBSZS1icmFuZGVkIENocm9tZSdzIHVzZXJcbiAqIGFnZW50IGhhcyB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiAqIDxzb3VyY2U+Lzx2ZXJzaW9uPiAoPG9zPikgPGVuZ2luZT4vPHZlcnNpb24+ICg8ZW5naW5lX25hbWU+KSBDaHJvbWUvPHZlcnNpb24+IFtNb2JpbGVdIFNhZmFyaS88dmVyc2lvbj5cbiAqIEBwYXJhbSBicm93c2VyXG4gKiBAcmV0dXJucyB7P3N0cmluZ30gTmFtZSBvZiB0aGUgcmVicmFuZGVkIENocm9tZSBicm93c2VyLCBvciBudWxsIGlmIHRoZSBicm93c2VyXG4gKiAgIGlzIGVpdGhlciBub3QgQ2hyb21lIG9yIHZhbmlsbGEgQ2hyb21lLlxuICovXG5mdW5jdGlvbiByZWJyYW5kZWRDaHJvbWVCcm93c2VyKGJyb3dzZXIpIHtcbiAgICAvLyBJZiB0aGUgYnJvd3NlciBpcyBub3QgQ2hyb21lIGJhc2VkLCB0aGVuIGl0IGlzIG5vdCBhIHJlYnJhbmRlZCBDaHJvbWUgYnJvd3Nlci5cbiAgICBpZiAoYnJvd3NlciAhPT0gJ2Nocm9tZScpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIExhdGVzdCBkZXNrdG9wIEJyYXZlIGJyb3dzZXIgaGFzIGEgXCJicmF2ZVwiIHByb3BlcnR5IGluIG5hdmlnYXRvci5cbiAgICBpZiAoJ2JyYXZlJyBpbiBuYXZpZ2F0b3IpIHtcbiAgICAgICAgcmV0dXJuICdicmF2ZSc7XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgXCIoLispXCIgZW50cmllcyBmcm9tIHRoZSB1c2VyIGFnZW50IHRoZXJlYnkgcmV0YWluaW5nIG9ubHkgdGhlXG4gICAgLy8gPG5hbWU+Wy88dmVyc2lvbj5dIGVudHJpZXMuXG4gICAgdmFyIHBhcmVudGhlc2l6ZWRTdWJzdHJpbmdzID0gZ2V0UGFyZW50aGVzaXplZFN1YnN0cmluZ3MobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIG5hbWVBbmRWZXJzaW9ucyA9IHBhcmVudGhlc2l6ZWRTdWJzdHJpbmdzLnJlZHVjZShmdW5jdGlvbiAodXNlckFnZW50LCBzdWJzdHJpbmcpIHsgcmV0dXJuIHVzZXJBZ2VudC5yZXBsYWNlKHN1YnN0cmluZywgJycpOyB9LCBuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAvLyBFeHRyYWN0IHRoZSBwb3RlbnRpYWwgYnJvd3NlciA8bmFtZT5zIGJ5IGlnbm9yaW5nIHRoZSBmaXJzdCB0d28gbmFtZXMsIHdoaWNoXG4gICAgLy8gcG9pbnQgdG8gPHNvdXJjZT4gYW5kIDxlbmdpbmU+LlxuICAgIHZhciBtYXRjaGVzID0gbmFtZUFuZFZlcnNpb25zLm1hdGNoKC9bXlxcc10rL2cpIHx8IFtdO1xuICAgIHZhciBfYSA9IF9fcmVhZChtYXRjaGVzLm1hcChmdW5jdGlvbiAobmFtZUFuZFZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5hbWVBbmRWZXJzaW9uLnNwbGl0KCcvJylbMF0udG9Mb3dlckNhc2UoKTtcbiAgICB9KSksIGJyb3dzZXJOYW1lcyA9IF9hLnNsaWNlKDIpO1xuICAgIC8vIEV4dHJhY3QgdGhlIDxuYW1lPiB0aGF0IGlzIG5vdCBleHBlY3RlZCB0byBiZSBwcmVzZW50IGluIHRoZSB2YW5pbGxhIENocm9tZVxuICAgIC8vIGJyb3dzZXIsIHdoaWNoIGluZGljYXRlcyB0aGUgcmVicmFuZGVkIG5hbWUgKGV4OiBcImVkZ1tlXVwiLCBcImVsZWN0cm9uXCIpLiBJZiBudWxsLFxuICAgIC8vIHRoZW4gdGhpcyBpcyBhIHZhbmlsbGEgQ2hyb21lIGJyb3dzZXIuXG4gICAgcmV0dXJuIGJyb3dzZXJOYW1lcy5maW5kKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAhWydjaHJvbWUnLCAnbW9iaWxlJywgJ3NhZmFyaSddLmluY2x1ZGVzKG5hbWUpO1xuICAgIH0pIHx8IG51bGw7XG59XG4vKipcbiAqIEdldCB0aGUgbmFtZSBvZiB0aGUgbW9iaWxlIHdlYmtpdCBiYXNlZCBicm93c2VyLCBpZiBhbnkuXG4gKiBAcGFyYW0gYnJvd3NlclxuICogQHJldHVybnMgez9zdHJpbmd9IE5hbWUgb2YgdGhlIG1vYmlsZSB3ZWJraXQgYmFzZWQgYnJvd3Nlciwgb3IgbnVsbCBpZiB0aGUgYnJvd3NlclxuICogICBpcyBlaXRoZXIgbm90IHdlYmtpdCBiYXNlZCBvciBtb2JpbGUgc2FmYXJpLlxuICovXG5mdW5jdGlvbiBtb2JpbGVXZWJLaXRCcm93c2VyKGJyb3dzZXIpIHtcbiAgICBpZiAoYnJvd3NlciAhPT0gJ3NhZmFyaScpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgnYnJhdmUnIGluIG5hdmlnYXRvcikge1xuICAgICAgICByZXR1cm4gJ2JyYXZlJztcbiAgICB9XG4gICAgcmV0dXJuIFsnZWRnZScsICdlZGcnXS5maW5kKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobmFtZSk7XG4gICAgfSkgfHwgbnVsbDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBpcyBvZmZpY2lhbGx5IHN1cHBvcnRlZCBieSB0d2lsaW8tdmlkZW8uanMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgdmFyIGJyb3dzZXIgPSBndWVzc0Jyb3dzZXIoKTtcbiAgICAvLyBOT1RFIChjc2FudG9zKTogUmV0dXJuIHJpZ2h0IGF3YXkgaWYgdGhlcmUgaXMgbm8gYnJvd3NlciBkZXRlY3RlZFxuICAgIC8vIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgY2hlY2tzIHdoaWNoIGNvdWxkIGxlYWQgdG8gZXJyb3JzXG4gICAgaWYgKCFicm93c2VyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHJlYnJhbmRlZENocm9tZSA9IHJlYnJhbmRlZENocm9tZUJyb3dzZXIoYnJvd3Nlcik7XG4gICAgdmFyIG1vYmlsZVdlYktpdCA9IG1vYmlsZVdlYktpdEJyb3dzZXIoYnJvd3Nlcik7XG4gICAgdmFyIHN1cHBvcnRlZE1vYmlsZUJyb3dzZXJzID0gL2FuZHJvaWQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKSA/XG4gICAgICAgIFNVUFBPUlRFRF9BTkRST0lEX0JST1dTRVJTIDogU1VQUE9SVEVEX0lPU19CUk9XU0VSUztcbiAgICByZXR1cm4gISFicm93c2VyXG4gICAgICAgICYmIGlzV2ViUlRDU3VwcG9ydGVkKClcbiAgICAgICAgJiYgKCFyZWJyYW5kZWRDaHJvbWUgfHwgU1VQUE9SVEVEX0NIUk9NRV9CQVNFRF9CUk9XU0VSUy5pbmNsdWRlcyhyZWJyYW5kZWRDaHJvbWUpKVxuICAgICAgICAmJiAhaXNOb25DaHJvbWl1bUVkZ2UoYnJvd3NlcilcbiAgICAgICAgJiYgKCFtb2JpbGVXZWJLaXQgfHwgU1VQUE9SVEVEX01PQklMRV9XRUJLSVRfQkFTRURfQlJPV1NFUlMuaW5jbHVkZXMobW9iaWxlV2ViS2l0KSlcbiAgICAgICAgJiYgKCFpc01vYmlsZSgpIHx8IHN1cHBvcnRlZE1vYmlsZUJyb3dzZXJzLmluY2x1ZGVzKGJyb3dzZXIpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gaXNTdXBwb3J0ZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdXBwb3J0LmpzLm1hcCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQSB7QGxpbmsgVGltZW91dH0gcmVwcmVzZW50cyBhIHJlc2V0dGFibGUgYW5kIGNsZWFyYWJsZSB0aW1lb3V0LlxuICovXG52YXIgVGltZW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgVGltZW91dH0uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBGdW5jdGlvbiB0byBjYWxsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gRGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYXV0b1N0YXJ0PXRydWVdIC0gSWYgdHJ1ZSwgdGhlbiBzdGFydCB0aGUge0BsaW5rIFRpbWVvdXR9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRpbWVvdXQoZm4sIGRlbGF5LCBhdXRvU3RhcnQpIHtcbiAgICAgICAgaWYgKGF1dG9TdGFydCA9PT0gdm9pZCAwKSB7IGF1dG9TdGFydCA9IHRydWU7IH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgX2RlbGF5OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlbGF5LFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2ZuOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3RpbWVvdXQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGF1dG9TdGFydCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW1lb3V0LnByb3RvdHlwZSwgXCJkZWxheVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUge0BsaW5rIFRpbWVvdXR9IGRlbGF5IGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxheTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW1lb3V0LnByb3RvdHlwZSwgXCJpc1NldFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB7QGxpbmsgVGltZW91dH0gaXMgc2V0LlxuICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX3RpbWVvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHtAbGluayBUaW1lb3V0fSBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXlcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBUaW1lb3V0LnByb3RvdHlwZS5zZXREZWxheSA9IGZ1bmN0aW9uIChkZWxheSkge1xuICAgICAgICB0aGlzLl9kZWxheSA9IGRlbGF5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIHtAbGluayBUaW1lb3V0fSwgaWYgbm90IGFscmVhZHkgc3RhcnRlZC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBUaW1lb3V0LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlzU2V0KSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gX3RoaXMuX2ZuO1xuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0sIHRoaXMuX2RlbGF5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIHtAbGluayBUaW1lb3V0fS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBUaW1lb3V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSB7QGxpbmsgVGltZW91dH0uXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgVGltZW91dC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVvdXQ7XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBUaW1lb3V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZW91dC5qcy5tYXAiLCIvLyBOT1RFOiBEbyBub3QgZWRpdCB0aGlzIGZpbGUuIFRoaXMgY29kZSBpcyBhdXRvLWdlbmVyYXRlZC4gQ29udGFjdCB0aGVcbi8vIFR3aWxpbyBTREsgVGVhbSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgVHdpbGlvRXJyb3IgPSByZXF1aXJlKCcuL3R3aWxpb2Vycm9yJyk7XG52YXIgVHdpbGlvRXJyb3JCeUNvZGUgPSB7fTtcbi8qKlxuICogQ3JlYXRlIGEge0BsaW5rIFR3aWxpb0Vycm9yfSBmb3IgYSBnaXZlbiBjb2RlIGFuZCBtZXNzYWdlLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29kZV0gLSBFcnJvciBjb2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIC0gRXJyb3IgbWVzc2FnZVxuICogQHJldHVybnMge1R3aWxpb0Vycm9yfVxuICovXG5leHBvcnRzLmNyZWF0ZVR3aWxpb0Vycm9yID0gZnVuY3Rpb24gY3JlYXRlVHdpbGlvRXJyb3IoY29kZSwgbWVzc2FnZSkge1xuICAgIGNvZGUgPSB0eXBlb2YgY29kZSA9PT0gJ251bWJlcicgPyBjb2RlIDogMDtcbiAgICBtZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIG1lc3NhZ2UgPyBtZXNzYWdlIDogJ1Vua25vd24gZXJyb3InO1xuICAgIHJldHVybiBUd2lsaW9FcnJvckJ5Q29kZVtjb2RlXSA/IG5ldyBUd2lsaW9FcnJvckJ5Q29kZVtjb2RlXSgpIDogbmV3IFR3aWxpb0Vycm9yKGNvZGUsIG1lc3NhZ2UpO1xufTtcbi8vIE5vdGUobXBhdHdhcmRoYW4pOiBXZSBkZXJpdmUgdHdpbGlvIHNwZWNpZmljIGVycm9ycyBoZXJlLiBBZnRlciB0eXBlc2NyaXB0IGNvbXBpbGVzIHRvIGVzNSBgaW5zdGFuY2VvZmAgZG9lcyBub3Qgd29ya1xuLy8gb24gb2JqZWN0cyB0aGF0IGRlcml2ZSBmcm9tIEVycm9yL0FycmF5IHR5cGVzLiBUbyB3b3JrYXJvdW5kIHdlIGNhbGwgc2V0UHJvdG90eXBlT2YgYWZ0ZXIgY2FsbGluZyBzdXBlcigpXG4vLyBtb3JlIG9uIHRoaXMgYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC93aWtpL0JyZWFraW5nLUNoYW5nZXMjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrXG4vKipcbiAqIEBjbGFzcyBBY2Nlc3NUb2tlbkludmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgdGhlIEFjY2Vzc1Rva2VuIHVzZWQgZm9yIGNvbm5lY3RpbmcgdG8gYSBSb29tIGlzIGludmFsaWQuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSAyMDEwMVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnSW52YWxpZCBBY2Nlc3MgVG9rZW4nXG4gKi9cbnZhciBBY2Nlc3NUb2tlbkludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjZXNzVG9rZW5JbnZhbGlkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjZXNzVG9rZW5JbnZhbGlkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDIwMTAxLCAnSW52YWxpZCBBY2Nlc3MgVG9rZW4nKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIEFjY2Vzc1Rva2VuSW52YWxpZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFjY2Vzc1Rva2VuSW52YWxpZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5BY2Nlc3NUb2tlbkludmFsaWRFcnJvciA9IEFjY2Vzc1Rva2VuSW52YWxpZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCAyMDEwMSwgeyB2YWx1ZTogQWNjZXNzVG9rZW5JbnZhbGlkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBBY2Nlc3NUb2tlbkhlYWRlckludmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgdGhlIEFjY2Vzc1Rva2VuIHVzZWQgZm9yIGNvbm5lY3RpbmcgdG8gYSBSb29tIGhhcyBhbiBpbnZhbGlkIGhlYWRlci5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDIwMTAyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdJbnZhbGlkIEFjY2VzcyBUb2tlbiBoZWFkZXInXG4gKi9cbnZhciBBY2Nlc3NUb2tlbkhlYWRlckludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjZXNzVG9rZW5IZWFkZXJJbnZhbGlkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjZXNzVG9rZW5IZWFkZXJJbnZhbGlkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDIwMTAyLCAnSW52YWxpZCBBY2Nlc3MgVG9rZW4gaGVhZGVyJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBBY2Nlc3NUb2tlbkhlYWRlckludmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBY2Nlc3NUb2tlbkhlYWRlckludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuQWNjZXNzVG9rZW5IZWFkZXJJbnZhbGlkRXJyb3IgPSBBY2Nlc3NUb2tlbkhlYWRlckludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgMjAxMDIsIHsgdmFsdWU6IEFjY2Vzc1Rva2VuSGVhZGVySW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgQWNjZXNzVG9rZW5Jc3N1ZXJJbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIHRoZSBBY2Nlc3NUb2tlbiB1c2VkIGZvciBjb25uZWN0aW5nIHRvIGEgUm9vbSBjb250YWlucyBhbiBpbnZhbGlkIGlzc3VlciBvciBzdWJqZWN0LlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gMjAxMDNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ0ludmFsaWQgQWNjZXNzIFRva2VuIGlzc3Vlci9zdWJqZWN0J1xuICovXG52YXIgQWNjZXNzVG9rZW5Jc3N1ZXJJbnZhbGlkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY2Vzc1Rva2VuSXNzdWVySW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY2Vzc1Rva2VuSXNzdWVySW52YWxpZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAyMDEwMywgJ0ludmFsaWQgQWNjZXNzIFRva2VuIGlzc3Vlci9zdWJqZWN0JykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBBY2Nlc3NUb2tlbklzc3VlckludmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBY2Nlc3NUb2tlbklzc3VlckludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuQWNjZXNzVG9rZW5Jc3N1ZXJJbnZhbGlkRXJyb3IgPSBBY2Nlc3NUb2tlbklzc3VlckludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgMjAxMDMsIHsgdmFsdWU6IEFjY2Vzc1Rva2VuSXNzdWVySW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgQWNjZXNzVG9rZW5FeHBpcmVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIHRoZSBBY2Nlc3NUb2tlbiB1c2VkIGZvciBjb25uZWN0aW5nLCBvciByZWNvbm5lY3RpbmcgdG8gYSBSb29tIGhhcyBleHBpcmVkLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gMjAxMDRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ0FjY2VzcyBUb2tlbiBleHBpcmVkIG9yIGV4cGlyYXRpb24gZGF0ZSBpbnZhbGlkJ1xuICovXG52YXIgQWNjZXNzVG9rZW5FeHBpcmVkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY2Vzc1Rva2VuRXhwaXJlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY2Vzc1Rva2VuRXhwaXJlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAyMDEwNCwgJ0FjY2VzcyBUb2tlbiBleHBpcmVkIG9yIGV4cGlyYXRpb24gZGF0ZSBpbnZhbGlkJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBBY2Nlc3NUb2tlbkV4cGlyZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBY2Nlc3NUb2tlbkV4cGlyZWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuQWNjZXNzVG9rZW5FeHBpcmVkRXJyb3IgPSBBY2Nlc3NUb2tlbkV4cGlyZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgMjAxMDQsIHsgdmFsdWU6IEFjY2Vzc1Rva2VuRXhwaXJlZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgQWNjZXNzVG9rZW5Ob3RZZXRWYWxpZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciB0aGUgQWNjZXNzVG9rZW4gdXNlZCBmb3IgY29ubmVjdGluZyB0byBhIFJvb20gaXMgbm90IHlldCB2YWxpZC5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDIwMTA1XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdBY2Nlc3MgVG9rZW4gbm90IHlldCB2YWxpZCdcbiAqL1xudmFyIEFjY2Vzc1Rva2VuTm90WWV0VmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjZXNzVG9rZW5Ob3RZZXRWYWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY2Vzc1Rva2VuTm90WWV0VmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgMjAxMDUsICdBY2Nlc3MgVG9rZW4gbm90IHlldCB2YWxpZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgQWNjZXNzVG9rZW5Ob3RZZXRWYWxpZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFjY2Vzc1Rva2VuTm90WWV0VmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuQWNjZXNzVG9rZW5Ob3RZZXRWYWxpZEVycm9yID0gQWNjZXNzVG9rZW5Ob3RZZXRWYWxpZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCAyMDEwNSwgeyB2YWx1ZTogQWNjZXNzVG9rZW5Ob3RZZXRWYWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgQWNjZXNzVG9rZW5HcmFudHNJbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIHRoZSBBY2Nlc3NUb2tlbiB1c2VkIGZvciBjb25uZWN0aW5nIHRvIGEgUm9vbSBoYXMgaW52YWxpZCBncmFudHMuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSAyMDEwNlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnSW52YWxpZCBBY2Nlc3MgVG9rZW4gZ3JhbnRzJ1xuICovXG52YXIgQWNjZXNzVG9rZW5HcmFudHNJbnZhbGlkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY2Vzc1Rva2VuR3JhbnRzSW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY2Vzc1Rva2VuR3JhbnRzSW52YWxpZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAyMDEwNiwgJ0ludmFsaWQgQWNjZXNzIFRva2VuIGdyYW50cycpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgQWNjZXNzVG9rZW5HcmFudHNJbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQWNjZXNzVG9rZW5HcmFudHNJbnZhbGlkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLkFjY2Vzc1Rva2VuR3JhbnRzSW52YWxpZEVycm9yID0gQWNjZXNzVG9rZW5HcmFudHNJbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDIwMTA2LCB7IHZhbHVlOiBBY2Nlc3NUb2tlbkdyYW50c0ludmFsaWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIEFjY2Vzc1Rva2VuU2lnbmF0dXJlSW52YWxpZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciB0aGUgQWNjZXNzVG9rZW4gdXNlZCBmb3IgY29ubmVjdGluZyB0byBhIFJvb20gaGFzIGFuIGludmFsaWQgc2lnbmF0dXJlLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gMjAxMDdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ0ludmFsaWQgQWNjZXNzIFRva2VuIHNpZ25hdHVyZSdcbiAqL1xudmFyIEFjY2Vzc1Rva2VuU2lnbmF0dXJlSW52YWxpZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2Nlc3NUb2tlblNpZ25hdHVyZUludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2Nlc3NUb2tlblNpZ25hdHVyZUludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgMjAxMDcsICdJbnZhbGlkIEFjY2VzcyBUb2tlbiBzaWduYXR1cmUnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIEFjY2Vzc1Rva2VuU2lnbmF0dXJlSW52YWxpZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFjY2Vzc1Rva2VuU2lnbmF0dXJlSW52YWxpZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5BY2Nlc3NUb2tlblNpZ25hdHVyZUludmFsaWRFcnJvciA9IEFjY2Vzc1Rva2VuU2lnbmF0dXJlSW52YWxpZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCAyMDEwNywgeyB2YWx1ZTogQWNjZXNzVG9rZW5TaWduYXR1cmVJbnZhbGlkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBTaWduYWxpbmdDb25uZWN0aW9uRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGEgc2lnbmFsaW5nIGNvbm5lY3Rpb24gZXJyb3Igb2NjdXJzIHRoYXQgaXMgbm90IGNvdmVyZWQgYnkgYSBtb3JlIHNwZWNpZmljIGVycm9yIGNvZGUuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzAwMFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnU2lnbmFsaW5nIGNvbm5lY3Rpb24gZXJyb3InXG4gKi9cbnZhciBTaWduYWxpbmdDb25uZWN0aW9uRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ25hbGluZ0Nvbm5lY3Rpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaWduYWxpbmdDb25uZWN0aW9uRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMDAwLCAnU2lnbmFsaW5nIGNvbm5lY3Rpb24gZXJyb3InKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFNpZ25hbGluZ0Nvbm5lY3Rpb25FcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTaWduYWxpbmdDb25uZWN0aW9uRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlNpZ25hbGluZ0Nvbm5lY3Rpb25FcnJvciA9IFNpZ25hbGluZ0Nvbm5lY3Rpb25FcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMwMDAsIHsgdmFsdWU6IFNpZ25hbGluZ0Nvbm5lY3Rpb25FcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgdGhlIHNpZ25hbGluZyBjb25uZWN0aW9uIGlzIHVuZXhwZWN0ZWRseSBkaXNjb25uZWN0ZWQuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzAwMVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnU2lnbmFsaW5nIGNvbm5lY3Rpb24gZGlzY29ubmVjdGVkJ1xuICovXG52YXIgU2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWduYWxpbmdDb25uZWN0aW9uRGlzY29ubmVjdGVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzAwMSwgJ1NpZ25hbGluZyBjb25uZWN0aW9uIGRpc2Nvbm5lY3RlZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgU2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNpZ25hbGluZ0Nvbm5lY3Rpb25EaXNjb25uZWN0ZWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuU2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yID0gU2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzAwMSwgeyB2YWx1ZTogU2lnbmFsaW5nQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgU2lnbmFsaW5nQ29ubmVjdGlvblRpbWVvdXRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbiBjb25uZWN0aW9uIGxpdmVsaW5lc3MgY2hlY2tzIGZhaWwsIG9yIHdoZW4gdGhlIHNpZ25hbGluZyBzZXNzaW9uIGV4cGlyZXMuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzAwMlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnU2lnbmFsaW5nIGNvbm5lY3Rpb24gdGltZWQgb3V0J1xuICovXG52YXIgU2lnbmFsaW5nQ29ubmVjdGlvblRpbWVvdXRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbmFsaW5nQ29ubmVjdGlvblRpbWVvdXRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaWduYWxpbmdDb25uZWN0aW9uVGltZW91dEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzAwMiwgJ1NpZ25hbGluZyBjb25uZWN0aW9uIHRpbWVkIG91dCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgU2lnbmFsaW5nQ29ubmVjdGlvblRpbWVvdXRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTaWduYWxpbmdDb25uZWN0aW9uVGltZW91dEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5TaWduYWxpbmdDb25uZWN0aW9uVGltZW91dEVycm9yID0gU2lnbmFsaW5nQ29ubmVjdGlvblRpbWVvdXRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMwMDIsIHsgdmFsdWU6IFNpZ25hbGluZ0Nvbm5lY3Rpb25UaW1lb3V0RXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBTaWduYWxpbmdJbmNvbWluZ01lc3NhZ2VJbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIHRoZSBDbGllbnQgcmVjZWl2ZXMgYSBtZXNzYWdlIGZyb20gdGhlIFNlcnZlciB0aGF0IHRoZSBDbGllbnQgY2Fubm90IGhhbmRsZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMDAzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdDbGllbnQgcmVjZWl2ZWQgYW4gaW52YWxpZCBzaWduYWxpbmcgbWVzc2FnZSdcbiAqL1xudmFyIFNpZ25hbGluZ0luY29taW5nTWVzc2FnZUludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbmFsaW5nSW5jb21pbmdNZXNzYWdlSW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ25hbGluZ0luY29taW5nTWVzc2FnZUludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMwMDMsICdDbGllbnQgcmVjZWl2ZWQgYW4gaW52YWxpZCBzaWduYWxpbmcgbWVzc2FnZScpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgU2lnbmFsaW5nSW5jb21pbmdNZXNzYWdlSW52YWxpZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNpZ25hbGluZ0luY29taW5nTWVzc2FnZUludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuU2lnbmFsaW5nSW5jb21pbmdNZXNzYWdlSW52YWxpZEVycm9yID0gU2lnbmFsaW5nSW5jb21pbmdNZXNzYWdlSW52YWxpZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzAwMywgeyB2YWx1ZTogU2lnbmFsaW5nSW5jb21pbmdNZXNzYWdlSW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgU2lnbmFsaW5nT3V0Z29pbmdNZXNzYWdlSW52YWxpZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciB0aGUgQ2xpZW50IHNlbmRzIGEgbWVzc2FnZSB0byB0aGUgU2VydmVyIHRoYXQgdGhlIFNlcnZlciBjYW5ub3QgaGFuZGxlLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMwMDRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ0NsaWVudCBzZW50IGFuIGludmFsaWQgc2lnbmFsaW5nIG1lc3NhZ2UnXG4gKi9cbnZhciBTaWduYWxpbmdPdXRnb2luZ01lc3NhZ2VJbnZhbGlkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ25hbGluZ091dGdvaW5nTWVzc2FnZUludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaWduYWxpbmdPdXRnb2luZ01lc3NhZ2VJbnZhbGlkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMDA0LCAnQ2xpZW50IHNlbnQgYW4gaW52YWxpZCBzaWduYWxpbmcgbWVzc2FnZScpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgU2lnbmFsaW5nT3V0Z29pbmdNZXNzYWdlSW52YWxpZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNpZ25hbGluZ091dGdvaW5nTWVzc2FnZUludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuU2lnbmFsaW5nT3V0Z29pbmdNZXNzYWdlSW52YWxpZEVycm9yID0gU2lnbmFsaW5nT3V0Z29pbmdNZXNzYWdlSW52YWxpZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzAwNCwgeyB2YWx1ZTogU2lnbmFsaW5nT3V0Z29pbmdNZXNzYWdlSW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgU2lnbmFsaW5nU2VydmVyQnVzeUVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuIHRoZSBzZXJ2ZXIgaXMgdG9vIGJ1c3kgdG8gYWNjZXB0IG5ldyBjbGllbnRzLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMwMDZcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1ZpZGVvIHNlcnZlciBpcyBidXN5J1xuICovXG52YXIgU2lnbmFsaW5nU2VydmVyQnVzeUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWduYWxpbmdTZXJ2ZXJCdXN5RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2lnbmFsaW5nU2VydmVyQnVzeUVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzAwNiwgJ1ZpZGVvIHNlcnZlciBpcyBidXN5JykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBTaWduYWxpbmdTZXJ2ZXJCdXN5RXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2lnbmFsaW5nU2VydmVyQnVzeUVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5TaWduYWxpbmdTZXJ2ZXJCdXN5RXJyb3IgPSBTaWduYWxpbmdTZXJ2ZXJCdXN5RXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMDA2LCB7IHZhbHVlOiBTaWduYWxpbmdTZXJ2ZXJCdXN5RXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tTmFtZUludmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYSBSb29tIG5hbWUgaXMgaW52YWxpZCwgYW5kIHRoZSBzY2VuYXJpbyBpcyBub3QgY292ZXJlZCBieSBhIG1vcmUgc3BlY2lmaWMgZXJyb3IgY29kZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTAwXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdSb29tIG5hbWUgaXMgaW52YWxpZCdcbiAqL1xudmFyIFJvb21OYW1lSW52YWxpZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb29tTmFtZUludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tTmFtZUludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMxMDAsICdSb29tIG5hbWUgaXMgaW52YWxpZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbU5hbWVJbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbU5hbWVJbnZhbGlkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlJvb21OYW1lSW52YWxpZEVycm9yID0gUm9vbU5hbWVJbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTAwLCB7IHZhbHVlOiBSb29tTmFtZUludmFsaWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFJvb21OYW1lVG9vTG9uZ0Vycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciBhIFJvb20gbmFtZSBpcyB0b28gbG9uZy5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTAxXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdSb29tIG5hbWUgaXMgdG9vIGxvbmcnXG4gKi9cbnZhciBSb29tTmFtZVRvb0xvbmdFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbU5hbWVUb29Mb25nRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm9vbU5hbWVUb29Mb25nRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMTAxLCAnUm9vbSBuYW1lIGlzIHRvbyBsb25nJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSb29tTmFtZVRvb0xvbmdFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tTmFtZVRvb0xvbmdFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbU5hbWVUb29Mb25nRXJyb3IgPSBSb29tTmFtZVRvb0xvbmdFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMDEsIHsgdmFsdWU6IFJvb21OYW1lVG9vTG9uZ0Vycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbU5hbWVDaGFyc0ludmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYSBSb29tIG5hbWUgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMDJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1Jvb20gbmFtZSBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMnXG4gKi9cbnZhciBSb29tTmFtZUNoYXJzSW52YWxpZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb29tTmFtZUNoYXJzSW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21OYW1lQ2hhcnNJbnZhbGlkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMTAyLCAnUm9vbSBuYW1lIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycycpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbU5hbWVDaGFyc0ludmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tTmFtZUNoYXJzSW52YWxpZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Sb29tTmFtZUNoYXJzSW52YWxpZEVycm9yID0gUm9vbU5hbWVDaGFyc0ludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMDIsIHsgdmFsdWU6IFJvb21OYW1lQ2hhcnNJbnZhbGlkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tQ3JlYXRlRmFpbGVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIHRoZSBTZXJ2ZXIgaXMgdW5hYmxlIHRvIGNyZWF0ZSBhIFJvb20uXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzEwM1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnVW5hYmxlIHRvIGNyZWF0ZSBSb29tJ1xuICovXG52YXIgUm9vbUNyZWF0ZUZhaWxlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb29tQ3JlYXRlRmFpbGVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm9vbUNyZWF0ZUZhaWxlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzEwMywgJ1VuYWJsZSB0byBjcmVhdGUgUm9vbScpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbUNyZWF0ZUZhaWxlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvb21DcmVhdGVGYWlsZWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbUNyZWF0ZUZhaWxlZEVycm9yID0gUm9vbUNyZWF0ZUZhaWxlZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzEwMywgeyB2YWx1ZTogUm9vbUNyZWF0ZUZhaWxlZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbUNvbm5lY3RGYWlsZWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYSBDbGllbnQgaXMgdW5hYmxlIHRvIGNvbm5lY3QgdG8gYSBSb29tLCBhbmQgdGhlIHNjZW5hcmlvIGlzIG5vdCBjb3ZlcmVkIGJ5IGEgbW9yZSBzcGVjaWZpYyBlcnJvciBjb2RlLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMDRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1VuYWJsZSB0byBjb25uZWN0IHRvIFJvb20nXG4gKi9cbnZhciBSb29tQ29ubmVjdEZhaWxlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb29tQ29ubmVjdEZhaWxlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21Db25uZWN0RmFpbGVkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMTA0LCAnVW5hYmxlIHRvIGNvbm5lY3QgdG8gUm9vbScpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbUNvbm5lY3RGYWlsZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tQ29ubmVjdEZhaWxlZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Sb29tQ29ubmVjdEZhaWxlZEVycm9yID0gUm9vbUNvbm5lY3RGYWlsZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMDQsIHsgdmFsdWU6IFJvb21Db25uZWN0RmFpbGVkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tTWF4UGFydGljaXBhbnRzRXhjZWVkZWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYSBDbGllbnQgaXMgdW5hYmxlIHRvIGNvbm5lY3QgdG8gYSBSb29tIGJlY2F1c2UgdGhlIFJvb20gY29udGFpbnMgdG9vIG1hbnkgUGFydGljaXBhbnRzLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMDVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1Jvb20gY29udGFpbnMgdG9vIG1hbnkgUGFydGljaXBhbnRzJ1xuICovXG52YXIgUm9vbU1heFBhcnRpY2lwYW50c0V4Y2VlZGVkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21NYXhQYXJ0aWNpcGFudHNFeGNlZWRlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21NYXhQYXJ0aWNpcGFudHNFeGNlZWRlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzEwNSwgJ1Jvb20gY29udGFpbnMgdG9vIG1hbnkgUGFydGljaXBhbnRzJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSb29tTWF4UGFydGljaXBhbnRzRXhjZWVkZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tTWF4UGFydGljaXBhbnRzRXhjZWVkZWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbU1heFBhcnRpY2lwYW50c0V4Y2VlZGVkRXJyb3IgPSBSb29tTWF4UGFydGljaXBhbnRzRXhjZWVkZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMDUsIHsgdmFsdWU6IFJvb21NYXhQYXJ0aWNpcGFudHNFeGNlZWRlZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbU5vdEZvdW5kRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGF0dGVtcHRpbmcgb3BlcmF0aW9uIG9uIGEgbm9uLWV4aXN0ZW50IFJvb20uXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzEwNlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnUm9vbSBub3QgZm91bmQnXG4gKi9cbnZhciBSb29tTm90Rm91bmRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbU5vdEZvdW5kRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm9vbU5vdEZvdW5kRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMTA2LCAnUm9vbSBub3QgZm91bmQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJvb21Ob3RGb3VuZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvb21Ob3RGb3VuZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Sb29tTm90Rm91bmRFcnJvciA9IFJvb21Ob3RGb3VuZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzEwNiwgeyB2YWx1ZTogUm9vbU5vdEZvdW5kRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tTWF4UGFydGljaXBhbnRzT3V0T2ZSYW5nZUVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCBpbiB0aGUgUkVTVCBBUEkgd2hlbiBNYXhQYXJ0aWNpcGFudHMgaXMgc2V0IG91dCBvZiByYW5nZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTA3XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdNYXhQYXJ0aWNpcGFudHMgaXMgb3V0IG9mIHJhbmdlJ1xuICovXG52YXIgUm9vbU1heFBhcnRpY2lwYW50c091dE9mUmFuZ2VFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbU1heFBhcnRpY2lwYW50c091dE9mUmFuZ2VFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tTWF4UGFydGljaXBhbnRzT3V0T2ZSYW5nZUVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzEwNywgJ01heFBhcnRpY2lwYW50cyBpcyBvdXQgb2YgcmFuZ2UnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJvb21NYXhQYXJ0aWNpcGFudHNPdXRPZlJhbmdlRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbU1heFBhcnRpY2lwYW50c091dE9mUmFuZ2VFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbU1heFBhcnRpY2lwYW50c091dE9mUmFuZ2VFcnJvciA9IFJvb21NYXhQYXJ0aWNpcGFudHNPdXRPZlJhbmdlRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTA3LCB7IHZhbHVlOiBSb29tTWF4UGFydGljaXBhbnRzT3V0T2ZSYW5nZUVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbVR5cGVJbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIGluIHRoZSBSRVNUIEFQSSB3aGVuIHRoZSB1c2VyIGF0dGVtcHRzIHRvIGNyZWF0ZSBhIFJvb20gd2l0aCBhbiBpbnZhbGlkIFJvb21UeXBlXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzEwOFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnUm9vbVR5cGUgaXMgbm90IHZhbGlkJ1xuICovXG52YXIgUm9vbVR5cGVJbnZhbGlkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21UeXBlSW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21UeXBlSW52YWxpZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzEwOCwgJ1Jvb21UeXBlIGlzIG5vdCB2YWxpZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbU1heFBhcnRpY2lwYW50c091dE9mUmFuZ2VFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tVHlwZUludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbVR5cGVJbnZhbGlkRXJyb3IgPSBSb29tVHlwZUludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMDgsIHsgdmFsdWU6IFJvb21UeXBlSW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbVRpbWVvdXRPdXRPZlJhbmdlRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIGluIHRoZSBSRVNUIEFQSSB3aGVuIFRpbWVvdXQgaXMgc2V0IG91dCBvZiByYW5nZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTA5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdUaW1lb3V0IGlzIG91dCBvZiByYW5nZSdcbiAqL1xudmFyIFJvb21UaW1lb3V0T3V0T2ZSYW5nZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb29tVGltZW91dE91dE9mUmFuZ2VFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tVGltZW91dE91dE9mUmFuZ2VFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMxMDksICdUaW1lb3V0IGlzIG91dCBvZiByYW5nZScpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbVRpbWVvdXRPdXRPZlJhbmdlRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbVRpbWVvdXRPdXRPZlJhbmdlRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlJvb21UaW1lb3V0T3V0T2ZSYW5nZUVycm9yID0gUm9vbVRpbWVvdXRPdXRPZlJhbmdlRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTA5LCB7IHZhbHVlOiBSb29tVGltZW91dE91dE9mUmFuZ2VFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFJvb21TdGF0dXNDYWxsYmFja01ldGhvZEludmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgaW4gdGhlIFJFU1QgQVBJIHdoZW4gU3RhdHVzQ2FsbGJhY2tNZXRob2QgaXMgc2V0IHRvIGFuIGludmFsaWQgdmFsdWUuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzExMFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnU3RhdHVzQ2FsbGJhY2tNZXRob2QgaXMgaW52YWxpZCdcbiAqL1xudmFyIFJvb21TdGF0dXNDYWxsYmFja01ldGhvZEludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbVN0YXR1c0NhbGxiYWNrTWV0aG9kSW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21TdGF0dXNDYWxsYmFja01ldGhvZEludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMxMTAsICdTdGF0dXNDYWxsYmFja01ldGhvZCBpcyBpbnZhbGlkJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSb29tU3RhdHVzQ2FsbGJhY2tNZXRob2RJbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbVN0YXR1c0NhbGxiYWNrTWV0aG9kSW52YWxpZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Sb29tU3RhdHVzQ2FsbGJhY2tNZXRob2RJbnZhbGlkRXJyb3IgPSBSb29tU3RhdHVzQ2FsbGJhY2tNZXRob2RJbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTEwLCB7IHZhbHVlOiBSb29tU3RhdHVzQ2FsbGJhY2tNZXRob2RJbnZhbGlkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tU3RhdHVzQ2FsbGJhY2tJbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIGluIHRoZSBSRVNUIEFQSSB3aGVuIFN0YXR1c0NhbGxiYWNrIGlzIG5vdCBhIHZhbGlkIFVSTCBvciB0aGUgdXJsIGlzIHRvbyBsb25nLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMTFcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1N0YXR1c0NhbGxiYWNrIGlzIGludmFsaWQnXG4gKi9cbnZhciBSb29tU3RhdHVzQ2FsbGJhY2tJbnZhbGlkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21TdGF0dXNDYWxsYmFja0ludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tU3RhdHVzQ2FsbGJhY2tJbnZhbGlkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMTExLCAnU3RhdHVzQ2FsbGJhY2sgaXMgaW52YWxpZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbVN0YXR1c0NhbGxiYWNrSW52YWxpZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvb21TdGF0dXNDYWxsYmFja0ludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbVN0YXR1c0NhbGxiYWNrSW52YWxpZEVycm9yID0gUm9vbVN0YXR1c0NhbGxiYWNrSW52YWxpZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzExMSwgeyB2YWx1ZTogUm9vbVN0YXR1c0NhbGxiYWNrSW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbVN0YXR1c0ludmFsaWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgaW4gdGhlIFJFU1QgQVBJIHdoZW4gU3RhdHVzIGlzIG5vdCB2YWxpZCBvciB0aGUgUm9vbSBpcyBub3QgaW4tcHJvZ3Jlc3MuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzExMlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnU3RhdHVzIGlzIGludmFsaWQnXG4gKi9cbnZhciBSb29tU3RhdHVzSW52YWxpZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb29tU3RhdHVzSW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21TdGF0dXNJbnZhbGlkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMTEyLCAnU3RhdHVzIGlzIGludmFsaWQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJvb21TdGF0dXNJbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbVN0YXR1c0ludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbVN0YXR1c0ludmFsaWRFcnJvciA9IFJvb21TdGF0dXNJbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTEyLCB7IHZhbHVlOiBSb29tU3RhdHVzSW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbVJvb21FeGlzdHNFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgaW4gdGhlIFJFU1QgQVBJIHdoZW4gdGhlIFJvb20gY3JlYXRpb24gZmFpbHMgYmVjYXVzZSBhIFJvb20gZXhpc3RzIHdpdGggdGhlIHNhbWUgbmFtZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTEzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdSb29tIGV4aXN0cydcbiAqL1xudmFyIFJvb21Sb29tRXhpc3RzRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21Sb29tRXhpc3RzRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm9vbVJvb21FeGlzdHNFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMxMTMsICdSb29tIGV4aXN0cycpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbVJvb21FeGlzdHNFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tUm9vbUV4aXN0c0Vycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Sb29tUm9vbUV4aXN0c0Vycm9yID0gUm9vbVJvb21FeGlzdHNFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMTMsIHsgdmFsdWU6IFJvb21Sb29tRXhpc3RzRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tSW52YWxpZFBhcmFtZXRlcnNFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgaW4gdGhlIFJFU1QgQVBJIHdoZW4gb25lIG9yIG1vcmUgUm9vbSBjcmVhdGlvbiBwYXJhbWV0ZXIgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFJvb20gdHlwZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTE0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdSb29tIGNyZWF0aW9uIHBhcmFtZXRlcihzKSBpbmNvbXBhdGlibGUgd2l0aCB0aGUgUm9vbSB0eXBlJ1xuICovXG52YXIgUm9vbUludmFsaWRQYXJhbWV0ZXJzRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21JbnZhbGlkUGFyYW1ldGVyc0Vycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21JbnZhbGlkUGFyYW1ldGVyc0Vycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzExNCwgJ1Jvb20gY3JlYXRpb24gcGFyYW1ldGVyKHMpIGluY29tcGF0aWJsZSB3aXRoIHRoZSBSb29tIHR5cGUnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJvb21JbnZhbGlkUGFyYW1ldGVyc0Vycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvb21JbnZhbGlkUGFyYW1ldGVyc0Vycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Sb29tSW52YWxpZFBhcmFtZXRlcnNFcnJvciA9IFJvb21JbnZhbGlkUGFyYW1ldGVyc0Vycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzExNCwgeyB2YWx1ZTogUm9vbUludmFsaWRQYXJhbWV0ZXJzRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBSb29tTWVkaWFSZWdpb25JbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIGluIHRoZSBSRVNUIEFQSSB3aGVuIE1lZGlhUmVnaW9uIGlzIHNldCB0byBhbiBpbnZhbGlkIHZhbHVlLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMxMTVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ01lZGlhUmVnaW9uIGlzIGludmFsaWQnXG4gKi9cbnZhciBSb29tTWVkaWFSZWdpb25JbnZhbGlkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21NZWRpYVJlZ2lvbkludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tTWVkaWFSZWdpb25JbnZhbGlkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMTE1LCAnTWVkaWFSZWdpb24gaXMgaW52YWxpZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbU1lZGlhUmVnaW9uSW52YWxpZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvb21NZWRpYVJlZ2lvbkludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbU1lZGlhUmVnaW9uSW52YWxpZEVycm9yID0gUm9vbU1lZGlhUmVnaW9uSW52YWxpZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzExNSwgeyB2YWx1ZTogUm9vbU1lZGlhUmVnaW9uSW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbU1lZGlhUmVnaW9uVW5hdmFpbGFibGVFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgaW4gdGhlIFJFU1QgQVBJIHdoZW4gTWVkaWFSZWdpb24gaXMgc2V0IHRvIGEgdmFsaWQgdmFsdWUgYnV0IG5vIG1lZGlhIHNlcnZlcnMgYXJlIGF2YWlsYWJsZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTE2XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdUaGVyZSBhcmUgbm8gbWVkaWEgc2VydmVycyBhdmFpbGFibGUgaW4gdGhlIE1lZGlhUmVnaW9uJ1xuICovXG52YXIgUm9vbU1lZGlhUmVnaW9uVW5hdmFpbGFibGVFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbU1lZGlhUmVnaW9uVW5hdmFpbGFibGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tTWVkaWFSZWdpb25VbmF2YWlsYWJsZUVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzExNiwgJ1RoZXJlIGFyZSBubyBtZWRpYSBzZXJ2ZXJzIGF2YWlsYWJsZSBpbiB0aGUgTWVkaWFSZWdpb24nKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJvb21NZWRpYVJlZ2lvblVuYXZhaWxhYmxlRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUm9vbU1lZGlhUmVnaW9uVW5hdmFpbGFibGVFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbU1lZGlhUmVnaW9uVW5hdmFpbGFibGVFcnJvciA9IFJvb21NZWRpYVJlZ2lvblVuYXZhaWxhYmxlRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMTE2LCB7IHZhbHVlOiBSb29tTWVkaWFSZWdpb25VbmF2YWlsYWJsZUVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbVN1YnNjcmlwdGlvbk9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciB0aGUgc3Vic2NyaXB0aW9uIG9wZXJhdGlvbiByZXF1ZXN0ZWQgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhlIFJvb20gdHlwZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMTE3XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdUaGUgc3Vic2NyaXB0aW9uIG9wZXJhdGlvbiByZXF1ZXN0ZWQgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhlIFJvb20gdHlwZSdcbiAqL1xudmFyIFJvb21TdWJzY3JpcHRpb25PcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vbVN1YnNjcmlwdGlvbk9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvb21TdWJzY3JpcHRpb25PcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMxMTcsICdUaGUgc3Vic2NyaXB0aW9uIG9wZXJhdGlvbiByZXF1ZXN0ZWQgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhlIFJvb20gdHlwZScpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUm9vbVN1YnNjcmlwdGlvbk9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvb21TdWJzY3JpcHRpb25PcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUm9vbVN1YnNjcmlwdGlvbk9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yID0gUm9vbVN1YnNjcmlwdGlvbk9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzExNywgeyB2YWx1ZTogUm9vbVN1YnNjcmlwdGlvbk9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUm9vbUNvbXBsZXRlZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciBhIFJvb20gaXMgY29tcGxldGVkIHZpYSB0aGUgUkVTVCBBUEkuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzExOFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnUm9vbSBjb21wbGV0ZWQnXG4gKi9cbnZhciBSb29tQ29tcGxldGVkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvb21Db21wbGV0ZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSb29tQ29tcGxldGVkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMTE4LCAnUm9vbSBjb21wbGV0ZWQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJvb21Db21wbGV0ZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb29tQ29tcGxldGVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlJvb21Db21wbGV0ZWRFcnJvciA9IFJvb21Db21wbGV0ZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMxMTgsIHsgdmFsdWU6IFJvb21Db21wbGV0ZWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFBhcnRpY2lwYW50SWRlbnRpdHlJbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGEgUGFydGljaXBhbnQgaWRlbnRpdHkgaXMgaW52YWxpZCwgYW5kIHRoZSBzY2VuYXJpbyBpcyBub3QgY292ZXJlZCBieSBhIG1vcmUgc3BlY2lmaWMgZXJyb3IgY29kZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMjAwXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdQYXJ0aWNpcGFudCBpZGVudGl0eSBpcyBpbnZhbGlkJ1xuICovXG52YXIgUGFydGljaXBhbnRJZGVudGl0eUludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFydGljaXBhbnRJZGVudGl0eUludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJ0aWNpcGFudElkZW50aXR5SW52YWxpZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzIwMCwgJ1BhcnRpY2lwYW50IGlkZW50aXR5IGlzIGludmFsaWQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFBhcnRpY2lwYW50SWRlbnRpdHlJbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGFydGljaXBhbnRJZGVudGl0eUludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUGFydGljaXBhbnRJZGVudGl0eUludmFsaWRFcnJvciA9IFBhcnRpY2lwYW50SWRlbnRpdHlJbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMjAwLCB7IHZhbHVlOiBQYXJ0aWNpcGFudElkZW50aXR5SW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUGFydGljaXBhbnRJZGVudGl0eVRvb0xvbmdFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgYSBQYXJ0aWNpcGFudCBpZGVudGl0eSBpcyB0b28gbG9uZy5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMjAxXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdQYXJ0aWNpcGFudCBpZGVudGl0eSBpcyB0b28gbG9uZydcbiAqL1xudmFyIFBhcnRpY2lwYW50SWRlbnRpdHlUb29Mb25nRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcnRpY2lwYW50SWRlbnRpdHlUb29Mb25nRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFydGljaXBhbnRJZGVudGl0eVRvb0xvbmdFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMyMDEsICdQYXJ0aWNpcGFudCBpZGVudGl0eSBpcyB0b28gbG9uZycpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUGFydGljaXBhbnRJZGVudGl0eVRvb0xvbmdFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYXJ0aWNpcGFudElkZW50aXR5VG9vTG9uZ0Vycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5QYXJ0aWNpcGFudElkZW50aXR5VG9vTG9uZ0Vycm9yID0gUGFydGljaXBhbnRJZGVudGl0eVRvb0xvbmdFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMyMDEsIHsgdmFsdWU6IFBhcnRpY2lwYW50SWRlbnRpdHlUb29Mb25nRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBQYXJ0aWNpcGFudElkZW50aXR5Q2hhcnNJbnZhbGlkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGEgUGFydGljaXBhbnQgaWRlbnRpdHkgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMyMDJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1BhcnRpY2lwYW50IGlkZW50aXR5IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycydcbiAqL1xudmFyIFBhcnRpY2lwYW50SWRlbnRpdHlDaGFyc0ludmFsaWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFydGljaXBhbnRJZGVudGl0eUNoYXJzSW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhcnRpY2lwYW50SWRlbnRpdHlDaGFyc0ludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMyMDIsICdQYXJ0aWNpcGFudCBpZGVudGl0eSBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFBhcnRpY2lwYW50SWRlbnRpdHlDaGFyc0ludmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYXJ0aWNpcGFudElkZW50aXR5Q2hhcnNJbnZhbGlkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlBhcnRpY2lwYW50SWRlbnRpdHlDaGFyc0ludmFsaWRFcnJvciA9IFBhcnRpY2lwYW50SWRlbnRpdHlDaGFyc0ludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMyMDIsIHsgdmFsdWU6IFBhcnRpY2lwYW50SWRlbnRpdHlDaGFyc0ludmFsaWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbiB0aGUgUm9vbSBsaW1pdCBmb3IgcHVibGlzaGVkIHRyYWNrcyBoYXMgYmVlbiByZWFjaGVkIGFuZCBhIFBhcnRpY2lwYW50IHRyaWVzIHRvIHB1Ymxpc2ggYSB0cmFjayB0byB0aGUgUm9vbS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMjAzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdUaGUgbWF4aW11bSBudW1iZXIgb2YgcHVibGlzaGVkIHRyYWNrcyBhbGxvd2VkIGluIHRoZSBSb29tIGF0IHRoZSBzYW1lIHRpbWUgaGFzIGJlZW4gcmVhY2hlZCdcbiAqL1xudmFyIFBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFydGljaXBhbnRNYXhUcmFja3NFeGNlZWRlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMyMDMsICdUaGUgbWF4aW11bSBudW1iZXIgb2YgcHVibGlzaGVkIHRyYWNrcyBhbGxvd2VkIGluIHRoZSBSb29tIGF0IHRoZSBzYW1lIHRpbWUgaGFzIGJlZW4gcmVhY2hlZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUGFydGljaXBhbnRNYXhUcmFja3NFeGNlZWRlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhcnRpY2lwYW50TWF4VHJhY2tzRXhjZWVkZWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuUGFydGljaXBhbnRNYXhUcmFja3NFeGNlZWRlZEVycm9yID0gUGFydGljaXBhbnRNYXhUcmFja3NFeGNlZWRlZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzIwMywgeyB2YWx1ZTogUGFydGljaXBhbnRNYXhUcmFja3NFeGNlZWRlZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgUGFydGljaXBhbnROb3RGb3VuZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciBhdHRlbXB0aW5nIGFuIG9wZXJhdGlvbiBvbiBhIG5vbi1leGlzdGVudCBQYXJ0aWNpcGFudC5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMjA0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdQYXJ0aWNpcGFudCBub3QgZm91bmQnXG4gKi9cbnZhciBQYXJ0aWNpcGFudE5vdEZvdW5kRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcnRpY2lwYW50Tm90Rm91bmRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJ0aWNpcGFudE5vdEZvdW5kRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMjA0LCAnUGFydGljaXBhbnQgbm90IGZvdW5kJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBQYXJ0aWNpcGFudE5vdEZvdW5kRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGFydGljaXBhbnROb3RGb3VuZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5QYXJ0aWNpcGFudE5vdEZvdW5kRXJyb3IgPSBQYXJ0aWNpcGFudE5vdEZvdW5kRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMjA0LCB7IHZhbHVlOiBQYXJ0aWNpcGFudE5vdEZvdW5kRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBQYXJ0aWNpcGFudER1cGxpY2F0ZUlkZW50aXR5RXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIGJ5IHRoZSBzZXJ2ZXIgdG8gdGhlIGV4aXN0aW5nIFBhcnRpY2lwYW50IHdoZW4gYSBuZXcgUGFydGljaXBhbnQgam9pbnMgYSBSb29tIHdpdGggdGhlIHNhbWUgaWRlbnRpdHkgYXMgdGhlIGV4aXN0aW5nIFBhcnRpY2lwYW50LlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMyMDVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1BhcnRpY2lwYW50IGRpc2Nvbm5lY3RlZCBiZWNhdXNlIG9mIGR1cGxpY2F0ZSBpZGVudGl0eSdcbiAqL1xudmFyIFBhcnRpY2lwYW50RHVwbGljYXRlSWRlbnRpdHlFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFydGljaXBhbnREdXBsaWNhdGVJZGVudGl0eUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhcnRpY2lwYW50RHVwbGljYXRlSWRlbnRpdHlFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMyMDUsICdQYXJ0aWNpcGFudCBkaXNjb25uZWN0ZWQgYmVjYXVzZSBvZiBkdXBsaWNhdGUgaWRlbnRpdHknKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFBhcnRpY2lwYW50RHVwbGljYXRlSWRlbnRpdHlFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYXJ0aWNpcGFudER1cGxpY2F0ZUlkZW50aXR5RXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlBhcnRpY2lwYW50RHVwbGljYXRlSWRlbnRpdHlFcnJvciA9IFBhcnRpY2lwYW50RHVwbGljYXRlSWRlbnRpdHlFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMyMDUsIHsgdmFsdWU6IFBhcnRpY2lwYW50RHVwbGljYXRlSWRlbnRpdHlFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFRyYWNrSW52YWxpZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciBhIFRyYWNrIGlzIGludmFsaWQsIGFuZCB0aGUgc2NlbmFyaW8gaXMgbm90IGNvdmVyZWQgYnkgYSBtb3JlIHNwZWNpZmljIGVycm9yIGNvZGUuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzMwMFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnVHJhY2sgaXMgaW52YWxpZCdcbiAqL1xudmFyIFRyYWNrSW52YWxpZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFja0ludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFja0ludmFsaWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMzMDAsICdUcmFjayBpcyBpbnZhbGlkJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBUcmFja0ludmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUcmFja0ludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuVHJhY2tJbnZhbGlkRXJyb3IgPSBUcmFja0ludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMzMDAsIHsgdmFsdWU6IFRyYWNrSW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgVHJhY2tOYW1lSW52YWxpZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciBhIFRyYWNrIG5hbWUgaXMgaW52YWxpZCwgYW5kIHRoZSBzY2VuYXJpbyBpcyBub3QgY292ZXJlZCBieSBhIG1vcmUgc3BlY2lmaWMgZXJyb3IgY29kZS5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMzAxXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdUcmFjayBuYW1lIGlzIGludmFsaWQnXG4gKi9cbnZhciBUcmFja05hbWVJbnZhbGlkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYWNrTmFtZUludmFsaWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFja05hbWVJbnZhbGlkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzMzAxLCAnVHJhY2sgbmFtZSBpcyBpbnZhbGlkJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBUcmFja05hbWVJbnZhbGlkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVHJhY2tOYW1lSW52YWxpZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5UcmFja05hbWVJbnZhbGlkRXJyb3IgPSBUcmFja05hbWVJbnZhbGlkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMzAxLCB7IHZhbHVlOiBUcmFja05hbWVJbnZhbGlkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBUcmFja05hbWVUb29Mb25nRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGEgVHJhY2sgbmFtZSBpcyB0b28gbG9uZy5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzMzAyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdUcmFjayBuYW1lIGlzIHRvbyBsb25nJ1xuICovXG52YXIgVHJhY2tOYW1lVG9vTG9uZ0Vycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFja05hbWVUb29Mb25nRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJhY2tOYW1lVG9vTG9uZ0Vycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzMwMiwgJ1RyYWNrIG5hbWUgaXMgdG9vIGxvbmcnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFRyYWNrTmFtZVRvb0xvbmdFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUcmFja05hbWVUb29Mb25nRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlRyYWNrTmFtZVRvb0xvbmdFcnJvciA9IFRyYWNrTmFtZVRvb0xvbmdFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMzMDIsIHsgdmFsdWU6IFRyYWNrTmFtZVRvb0xvbmdFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFRyYWNrTmFtZUNoYXJzSW52YWxpZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciBhIFRyYWNrIG5hbWUgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMzMDNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1RyYWNrIG5hbWUgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzJ1xuICovXG52YXIgVHJhY2tOYW1lQ2hhcnNJbnZhbGlkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYWNrTmFtZUNoYXJzSW52YWxpZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyYWNrTmFtZUNoYXJzSW52YWxpZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzMwMywgJ1RyYWNrIG5hbWUgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBUcmFja05hbWVDaGFyc0ludmFsaWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUcmFja05hbWVDaGFyc0ludmFsaWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuVHJhY2tOYW1lQ2hhcnNJbnZhbGlkRXJyb3IgPSBUcmFja05hbWVDaGFyc0ludmFsaWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMzMDMsIHsgdmFsdWU6IFRyYWNrTmFtZUNoYXJzSW52YWxpZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgVHJhY2tOYW1lSXNEdXBsaWNhdGVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGEgUGFydGljaXBhbnQgaXMgY3VycmVudGx5IHB1Ymxpc2hpbmcgYSBUcmFjayB3aXRoIHRoZSBzYW1lIG5hbWUuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzMwNFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnVHJhY2sgbmFtZSBpcyBkdXBsaWNhdGVkJ1xuICovXG52YXIgVHJhY2tOYW1lSXNEdXBsaWNhdGVkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYWNrTmFtZUlzRHVwbGljYXRlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyYWNrTmFtZUlzRHVwbGljYXRlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzMwNCwgJ1RyYWNrIG5hbWUgaXMgZHVwbGljYXRlZCcpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgVHJhY2tOYW1lSXNEdXBsaWNhdGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVHJhY2tOYW1lSXNEdXBsaWNhdGVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlRyYWNrTmFtZUlzRHVwbGljYXRlZEVycm9yID0gVHJhY2tOYW1lSXNEdXBsaWNhdGVkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzMzA0LCB7IHZhbHVlOiBUcmFja05hbWVJc0R1cGxpY2F0ZWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIFRyYWNrU2VydmVyVHJhY2tDYXBhY2l0eVJlYWNoZWRFcnJvclxuICogQGNsYXNzZGVzYyBUaGUgc2VydmVyIGRvZXMgbm90IGhhdmUgZW5vdWdoIHJlc291cmNlcyBhdmFpbGFibGUgdG8gY3JlYXRlIGEgbmV3IFRyYWNrLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTMzMDVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1RoZSBzZXJ2ZXIgaGFzIHJlYWNoZWQgY2FwYWNpdHkgYW5kIGNhbm5vdCBmdWxmaWxsIHRoaXMgcmVxdWVzdCdcbiAqL1xudmFyIFRyYWNrU2VydmVyVHJhY2tDYXBhY2l0eVJlYWNoZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJhY2tTZXJ2ZXJUcmFja0NhcGFjaXR5UmVhY2hlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyYWNrU2VydmVyVHJhY2tDYXBhY2l0eVJlYWNoZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTMzMDUsICdUaGUgc2VydmVyIGhhcyByZWFjaGVkIGNhcGFjaXR5IGFuZCBjYW5ub3QgZnVsZmlsbCB0aGlzIHJlcXVlc3QnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFRyYWNrU2VydmVyVHJhY2tDYXBhY2l0eVJlYWNoZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUcmFja1NlcnZlclRyYWNrQ2FwYWNpdHlSZWFjaGVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLlRyYWNrU2VydmVyVHJhY2tDYXBhY2l0eVJlYWNoZWRFcnJvciA9IFRyYWNrU2VydmVyVHJhY2tDYXBhY2l0eVJlYWNoZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTMzMDUsIHsgdmFsdWU6IFRyYWNrU2VydmVyVHJhY2tDYXBhY2l0eVJlYWNoZWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIE1lZGlhQ2xpZW50TG9jYWxEZXNjRmFpbGVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIGEgQ2xpZW50IGlzIHVuYWJsZSB0byBjcmVhdGUgb3IgYXBwbHkgYSBsb2NhbCBtZWRpYSBkZXNjcmlwdGlvbi5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzNDAwXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdDbGllbnQgaXMgdW5hYmxlIHRvIGNyZWF0ZSBvciBhcHBseSBhIGxvY2FsIG1lZGlhIGRlc2NyaXB0aW9uJ1xuICovXG52YXIgTWVkaWFDbGllbnRMb2NhbERlc2NGYWlsZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVkaWFDbGllbnRMb2NhbERlc2NGYWlsZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZWRpYUNsaWVudExvY2FsRGVzY0ZhaWxlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzQwMCwgJ0NsaWVudCBpcyB1bmFibGUgdG8gY3JlYXRlIG9yIGFwcGx5IGEgbG9jYWwgbWVkaWEgZGVzY3JpcHRpb24nKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIE1lZGlhQ2xpZW50TG9jYWxEZXNjRmFpbGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWVkaWFDbGllbnRMb2NhbERlc2NGYWlsZWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuTWVkaWFDbGllbnRMb2NhbERlc2NGYWlsZWRFcnJvciA9IE1lZGlhQ2xpZW50TG9jYWxEZXNjRmFpbGVkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzNDAwLCB7IHZhbHVlOiBNZWRpYUNsaWVudExvY2FsRGVzY0ZhaWxlZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgTWVkaWFTZXJ2ZXJMb2NhbERlc2NGYWlsZWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgdGhlIFNlcnZlciBpcyB1bmFibGUgdG8gY3JlYXRlIG9yIGFwcGx5IGEgbG9jYWwgbWVkaWEgZGVzY3JpcHRpb24uXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzQwMVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnU2VydmVyIGlzIHVuYWJsZSB0byBjcmVhdGUgb3IgYXBwbHkgYSBsb2NhbCBtZWRpYSBkZXNjcmlwdGlvbidcbiAqL1xudmFyIE1lZGlhU2VydmVyTG9jYWxEZXNjRmFpbGVkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lZGlhU2VydmVyTG9jYWxEZXNjRmFpbGVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVkaWFTZXJ2ZXJMb2NhbERlc2NGYWlsZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTM0MDEsICdTZXJ2ZXIgaXMgdW5hYmxlIHRvIGNyZWF0ZSBvciBhcHBseSBhIGxvY2FsIG1lZGlhIGRlc2NyaXB0aW9uJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNZWRpYVNlcnZlckxvY2FsRGVzY0ZhaWxlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lZGlhU2VydmVyTG9jYWxEZXNjRmFpbGVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLk1lZGlhU2VydmVyTG9jYWxEZXNjRmFpbGVkRXJyb3IgPSBNZWRpYVNlcnZlckxvY2FsRGVzY0ZhaWxlZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzQwMSwgeyB2YWx1ZTogTWVkaWFTZXJ2ZXJMb2NhbERlc2NGYWlsZWRFcnJvciB9KTtcbi8qKlxuICogQGNsYXNzIE1lZGlhQ2xpZW50UmVtb3RlRGVzY0ZhaWxlZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciB0aGUgQ2xpZW50IHJlY2VpdmVzIGEgcmVtb3RlIG1lZGlhIGRlc2NyaXB0aW9uIGJ1dCBpcyB1bmFibGUgdG8gYXBwbHkgaXQuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzQwMlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnQ2xpZW50IGlzIHVuYWJsZSB0byBhcHBseSBhIHJlbW90ZSBtZWRpYSBkZXNjcmlwdGlvbidcbiAqL1xudmFyIE1lZGlhQ2xpZW50UmVtb3RlRGVzY0ZhaWxlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZWRpYUNsaWVudFJlbW90ZURlc2NGYWlsZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZWRpYUNsaWVudFJlbW90ZURlc2NGYWlsZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTM0MDIsICdDbGllbnQgaXMgdW5hYmxlIHRvIGFwcGx5IGEgcmVtb3RlIG1lZGlhIGRlc2NyaXB0aW9uJykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNZWRpYUNsaWVudFJlbW90ZURlc2NGYWlsZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZWRpYUNsaWVudFJlbW90ZURlc2NGYWlsZWRFcnJvcjtcbn0oVHdpbGlvRXJyb3IpKTtcbmV4cG9ydHMuTWVkaWFDbGllbnRSZW1vdGVEZXNjRmFpbGVkRXJyb3IgPSBNZWRpYUNsaWVudFJlbW90ZURlc2NGYWlsZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTM0MDIsIHsgdmFsdWU6IE1lZGlhQ2xpZW50UmVtb3RlRGVzY0ZhaWxlZEVycm9yIH0pO1xuLyoqXG4gKiBAY2xhc3MgTWVkaWFTZXJ2ZXJSZW1vdGVEZXNjRmFpbGVkRXJyb3JcbiAqIEBjbGFzc2Rlc2MgUmFpc2VkIHdoZW5ldmVyIHRoZSBTZXJ2ZXIgcmVjZWl2ZXMgYSByZW1vdGUgbWVkaWEgZGVzY3JpcHRpb24gYnV0IGlzIHVuYWJsZSB0byBhcHBseSBpdC5cbiAqIEBleHRlbmRzIFR3aWxpb0Vycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIDUzNDAzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtICdTZXJ2ZXIgaXMgdW5hYmxlIHRvIGFwcGx5IGEgcmVtb3RlIG1lZGlhIGRlc2NyaXB0aW9uJ1xuICovXG52YXIgTWVkaWFTZXJ2ZXJSZW1vdGVEZXNjRmFpbGVkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lZGlhU2VydmVyUmVtb3RlRGVzY0ZhaWxlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lZGlhU2VydmVyUmVtb3RlRGVzY0ZhaWxlZEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA1MzQwMywgJ1NlcnZlciBpcyB1bmFibGUgdG8gYXBwbHkgYSByZW1vdGUgbWVkaWEgZGVzY3JpcHRpb24nKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIE1lZGlhU2VydmVyUmVtb3RlRGVzY0ZhaWxlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lZGlhU2VydmVyUmVtb3RlRGVzY0ZhaWxlZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5NZWRpYVNlcnZlclJlbW90ZURlc2NGYWlsZWRFcnJvciA9IE1lZGlhU2VydmVyUmVtb3RlRGVzY0ZhaWxlZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzQwMywgeyB2YWx1ZTogTWVkaWFTZXJ2ZXJSZW1vdGVEZXNjRmFpbGVkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBNZWRpYU5vU3VwcG9ydGVkQ29kZWNFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgdGhlIGludGVyc2VjdGlvbiBvZiBjb2RlY3Mgc3VwcG9ydGVkIGJ5IHRoZSBDbGllbnQgYW5kIHRoZSBTZXJ2ZXIgKG9yLCBpbiBwZWVyLXRvLXBlZXIsIHRoZSBDbGllbnQgYW5kIGFub3RoZXIgUGFydGljaXBhbnQpIGlzIGVtcHR5LlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTM0MDRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ05vIHN1cHBvcnRlZCBjb2RlYydcbiAqL1xudmFyIE1lZGlhTm9TdXBwb3J0ZWRDb2RlY0Vycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZWRpYU5vU3VwcG9ydGVkQ29kZWNFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZWRpYU5vU3VwcG9ydGVkQ29kZWNFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTM0MDQsICdObyBzdXBwb3J0ZWQgY29kZWMnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIE1lZGlhTm9TdXBwb3J0ZWRDb2RlY0Vycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lZGlhTm9TdXBwb3J0ZWRDb2RlY0Vycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5NZWRpYU5vU3VwcG9ydGVkQ29kZWNFcnJvciA9IE1lZGlhTm9TdXBwb3J0ZWRDb2RlY0Vycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzQwNCwgeyB2YWx1ZTogTWVkaWFOb1N1cHBvcnRlZENvZGVjRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBNZWRpYUNvbm5lY3Rpb25FcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgYnkgdGhlIENsaWVudCBvciBTZXJ2ZXIgd2hlbmV2ZXIgYSBtZWRpYSBjb25uZWN0aW9uIGZhaWxzIG9yIHJhaXNlZCBieSB0aGUgQ2xpZW50IHdoZW5ldmVyIGl0IGRldGVjdHMgdGhhdCBtZWRpYSBoYXMgc3RvcHBlZCBmbG93aW5nLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTM0MDVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ01lZGlhIGNvbm5lY3Rpb24gZmFpbGVkIG9yIE1lZGlhIGFjdGl2aXR5IGNlYXNlZCdcbiAqL1xudmFyIE1lZGlhQ29ubmVjdGlvbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZWRpYUNvbm5lY3Rpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZWRpYUNvbm5lY3Rpb25FcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNTM0MDUsICdNZWRpYSBjb25uZWN0aW9uIGZhaWxlZCBvciBNZWRpYSBhY3Rpdml0eSBjZWFzZWQnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIE1lZGlhQ29ubmVjdGlvbkVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lZGlhQ29ubmVjdGlvbkVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5NZWRpYUNvbm5lY3Rpb25FcnJvciA9IE1lZGlhQ29ubmVjdGlvbkVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzQwNSwgeyB2YWx1ZTogTWVkaWFDb25uZWN0aW9uRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBNZWRpYURUTFNUcmFuc3BvcnRGYWlsZWRFcnJvclxuICogQGNsYXNzZGVzYyBUaGVyZSB3YXMgYSBwcm9ibGVtIHdoaWxlIG5lZ290aWF0aW5nIHdpdGggdGhlIHJlbW90ZSBEVExTIHBlZXIuIFRoZXJlZm9yZSB0aGUgUGFydGljaXBhbnQgd2lsbCBub3QgYmUgYWJsZSB0byBwdWJsaXNoIG9yIHN1YnNjcmliZSB0byBUcmFja3MuXG4gKiBAZXh0ZW5kcyBUd2lsaW9FcnJvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSA1MzQwN1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSAnTWVkaWEgY29ubmVjdGlvbiBmYWlsZWQgZHVlIHRvIERUTFMgaGFuZHNoYWtlIGZhaWx1cmUnXG4gKi9cbnZhciBNZWRpYURUTFNUcmFuc3BvcnRGYWlsZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVkaWFEVExTVHJhbnNwb3J0RmFpbGVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVkaWFEVExTVHJhbnNwb3J0RmFpbGVkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzNDA3LCAnTWVkaWEgY29ubmVjdGlvbiBmYWlsZWQgZHVlIHRvIERUTFMgaGFuZHNoYWtlIGZhaWx1cmUnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIE1lZGlhRFRMU1RyYW5zcG9ydEZhaWxlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lZGlhRFRMU1RyYW5zcG9ydEZhaWxlZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5NZWRpYURUTFNUcmFuc3BvcnRGYWlsZWRFcnJvciA9IE1lZGlhRFRMU1RyYW5zcG9ydEZhaWxlZEVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFR3aWxpb0Vycm9yQnlDb2RlLCA1MzQwNywgeyB2YWx1ZTogTWVkaWFEVExTVHJhbnNwb3J0RmFpbGVkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBDb25maWd1cmF0aW9uQWNxdWlyZUZhaWxlZEVycm9yXG4gKiBAY2xhc3NkZXNjIFJhaXNlZCB3aGVuZXZlciB0aGUgQ2xpZW50IGlzIHVuYWJsZSB0byBhY3F1aXJlIGNvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb24gZnJvbSB0aGUgU2VydmVyLlxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTM1MDBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1VuYWJsZSB0byBhY3F1aXJlIGNvbmZpZ3VyYXRpb24nXG4gKi9cbnZhciBDb25maWd1cmF0aW9uQWNxdWlyZUZhaWxlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25maWd1cmF0aW9uQWNxdWlyZUZhaWxlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmZpZ3VyYXRpb25BY3F1aXJlRmFpbGVkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzNTAwLCAnVW5hYmxlIHRvIGFjcXVpcmUgY29uZmlndXJhdGlvbicpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgQ29uZmlndXJhdGlvbkFjcXVpcmVGYWlsZWRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb25maWd1cmF0aW9uQWNxdWlyZUZhaWxlZEVycm9yO1xufShUd2lsaW9FcnJvcikpO1xuZXhwb3J0cy5Db25maWd1cmF0aW9uQWNxdWlyZUZhaWxlZEVycm9yID0gQ29uZmlndXJhdGlvbkFjcXVpcmVGYWlsZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUd2lsaW9FcnJvckJ5Q29kZSwgNTM1MDAsIHsgdmFsdWU6IENvbmZpZ3VyYXRpb25BY3F1aXJlRmFpbGVkRXJyb3IgfSk7XG4vKipcbiAqIEBjbGFzcyBDb25maWd1cmF0aW9uQWNxdWlyZVR1cm5GYWlsZWRFcnJvclxuICogQGNsYXNzZGVzYyBSYWlzZWQgd2hlbmV2ZXIgdGhlIFNlcnZlciBpcyB1bmFibGUgdG8gcmV0dXJuIFRVUk4gY3JlZGVudGlhbHMgdG8gdGhlIENsaWVudFxuICogQGV4dGVuZHMgVHdpbGlvRXJyb3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gNTM1MDFcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gJ1VuYWJsZSB0byBhY3F1aXJlIFRVUk4gY3JlZGVudGlhbHMnXG4gKi9cbnZhciBDb25maWd1cmF0aW9uQWNxdWlyZVR1cm5GYWlsZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uZmlndXJhdGlvbkFjcXVpcmVUdXJuRmFpbGVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uZmlndXJhdGlvbkFjcXVpcmVUdXJuRmFpbGVkRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUzNTAxLCAnVW5hYmxlIHRvIGFjcXVpcmUgVFVSTiBjcmVkZW50aWFscycpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgQ29uZmlndXJhdGlvbkFjcXVpcmVUdXJuRmFpbGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29uZmlndXJhdGlvbkFjcXVpcmVUdXJuRmFpbGVkRXJyb3I7XG59KFR3aWxpb0Vycm9yKSk7XG5leHBvcnRzLkNvbmZpZ3VyYXRpb25BY3F1aXJlVHVybkZhaWxlZEVycm9yID0gQ29uZmlndXJhdGlvbkFjcXVpcmVUdXJuRmFpbGVkRXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHdpbGlvRXJyb3JCeUNvZGUsIDUzNTAxLCB7IHZhbHVlOiBDb25maWd1cmF0aW9uQWNxdWlyZVR1cm5GYWlsZWRFcnJvciB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR3aWxpby12aWRlby1lcnJvcnMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xuICAgIHJldHVybiB0bztcbn07XG4vKipcbiAqIEBleHRlbmRzIEVycm9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSAtIEVycm9yIGNvZGVcbiAqL1xudmFyIFR3aWxpb0Vycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUd2lsaW9FcnJvciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBUd2lsaW9FcnJvcn1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29kZSAtIEVycm9yIGNvZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIC0gRXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZmlsZU5hbWVdIC0gTmFtZSBvZiB0aGUgc2NyaXB0IGZpbGUgd2hlcmUgZXJyb3Igd2FzIGdlbmVyYXRlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGluZU51bWJlcl0gLSBMaW5lIG51bWJlciBvZiB0aGUgc2NyaXB0IGZpbGUgd2hlcmUgZXJyb3Igd2FzIGdlbmVyYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFR3aWxpb0Vycm9yKGNvZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSkpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgVHdpbGlvRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgdmFyIGVycm9yID0gRXJyb3IuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgICAgICBlcnJvci5uYW1lID0gJ1R3aWxpb0Vycm9yJztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCAnY29kZScsIHtcbiAgICAgICAgICAgIHZhbHVlOiBjb2RlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXJyb3IpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGVycm9yW3Byb3BdLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBodW1hbiByZWFkYWJsZSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgZXJyb3IuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBUd2lsaW9FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5tZXNzYWdlID8gXCI6IFwiICsgdGhpcy5tZXNzYWdlIDogJyc7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIiBcIiArIHRoaXMuY29kZSArIG1lc3NhZ2U7XG4gICAgfTtcbiAgICByZXR1cm4gVHdpbGlvRXJyb3I7XG59KEVycm9yKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFR3aWxpb0Vycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHdpbGlvZXJyb3IuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzTm9uQXJyYXlPYmplY3QgPSByZXF1aXJlKCcuLycpLmlzTm9uQXJyYXlPYmplY3Q7XG52YXIgX2EgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLCBFID0gX2EudHlwZUVycm9ycywgY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sID0gX2EuY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sLCB2aWRlb0NvbnRlbnRQcmVmZXJlbmNlc01vZGUgPSBfYS52aWRlb0NvbnRlbnRQcmVmZXJlbmNlc01vZGUsIHN1YnNjcmlwdGlvbk1vZGUgPSBfYS5zdWJzY3JpcHRpb25Nb2RlLCB0cmFja1ByaW9yaXR5ID0gX2EudHJhY2tQcmlvcml0eSwgdHJhY2tTd2l0Y2hPZmZNb2RlID0gX2EudHJhY2tTd2l0Y2hPZmZNb2RlO1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGUge0BsaW5rIEJhbmR3aWR0aFByb2ZpbGVPcHRpb25zfSBvYmplY3QuXG4gKiBAcGFyYW0ge0JhbmR3aWR0aFByb2ZpbGVPcHRpb25zfSBiYW5kd2lkdGhQcm9maWxlXG4gKiBAcmV0dXJucyB7P0Vycm9yfSAtIG51bGwgaWYgdmFsaWQsIEVycm9yIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVCYW5kd2lkdGhQcm9maWxlKGJhbmR3aWR0aFByb2ZpbGUpIHtcbiAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZU9iamVjdChiYW5kd2lkdGhQcm9maWxlLCAnb3B0aW9ucy5iYW5kd2lkdGhQcm9maWxlJyk7XG4gICAgaWYgKCFiYW5kd2lkdGhQcm9maWxlIHx8IGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgZXJyb3IgPSB2YWxpZGF0ZU9iamVjdChiYW5kd2lkdGhQcm9maWxlLnZpZGVvLCAnb3B0aW9ucy5iYW5kd2lkdGhQcm9maWxlLnZpZGVvJywgW1xuICAgICAgICB7IHByb3A6ICdjb250ZW50UHJlZmVyZW5jZXNNb2RlJywgdmFsdWVzOiBPYmplY3QudmFsdWVzKHZpZGVvQ29udGVudFByZWZlcmVuY2VzTW9kZSkgfSxcbiAgICAgICAgeyBwcm9wOiAnZG9taW5hbnRTcGVha2VyUHJpb3JpdHknLCB2YWx1ZXM6IE9iamVjdC52YWx1ZXModHJhY2tQcmlvcml0eSkgfSxcbiAgICAgICAgeyBwcm9wOiAnbWF4U3Vic2NyaXB0aW9uQml0cmF0ZScsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsgcHJvcDogJ21heFRyYWNrcycsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsgcHJvcDogJ21vZGUnLCB2YWx1ZXM6IE9iamVjdC52YWx1ZXMoc3Vic2NyaXB0aW9uTW9kZSkgfSxcbiAgICAgICAgeyBwcm9wOiAnY2xpZW50VHJhY2tTd2l0Y2hPZmZDb250cm9sJywgdmFsdWVzOiBPYmplY3QudmFsdWVzKGNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCkgfSxcbiAgICAgICAgeyBwcm9wOiAndHJhY2tTd2l0Y2hPZmZNb2RlJywgdmFsdWVzOiBPYmplY3QudmFsdWVzKHRyYWNrU3dpdGNoT2ZmTW9kZSkgfVxuICAgIF0pO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGlmIChiYW5kd2lkdGhQcm9maWxlLnZpZGVvKSB7XG4gICAgICAgIC8vIG1heFRyYWNrcyBpcyByZXBsYWNlZCBieSBjbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wuXG4gICAgICAgIC8vIHRocm93IGFuIGVycm9yIGlmIGJvdGggYXJlIHNwZWNpZmllZC5cbiAgICAgICAgaWYgKCdtYXhUcmFja3MnIGluIGJhbmR3aWR0aFByb2ZpbGUudmlkZW8gJiYgJ2NsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbCcgaW4gYmFuZHdpZHRoUHJvZmlsZS52aWRlbykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlby5tYXhUcmFja3MgaXMgZGVwcmVjYXRlZC4gVXNlIG9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlby5jbGllbnRUcmFja1N3aXRjaE9mZkNvbnRyb2wgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW5kZXJEaW1lbnNpb25zIGlzIHJlcGxhY2VkIGJ5IGNvbnRlbnRQcmVmZXJlbmNlc01vZGUuXG4gICAgICAgIC8vIHRocm93IGFuIGVycm9yIGlmIGJvdGggYXJlIHNwZWNpZmllZC5cbiAgICAgICAgaWYgKCdyZW5kZXJEaW1lbnNpb25zJyBpbiBiYW5kd2lkdGhQcm9maWxlLnZpZGVvICYmICdjb250ZW50UHJlZmVyZW5jZXNNb2RlJyBpbiBiYW5kd2lkdGhQcm9maWxlLnZpZGVvKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignb3B0aW9ucy5iYW5kd2lkdGhQcm9maWxlLnZpZGVvLnJlbmRlckRpbWVuc2lvbnMgaXMgZGVwcmVjYXRlZC4gVXNlIG9wdGlvbnMuYmFuZHdpZHRoUHJvZmlsZS52aWRlby5jb250ZW50UHJlZmVyZW5jZXNNb2RlIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlUmVuZGVyRGltZW5zaW9ucyhiYW5kd2lkdGhQcm9maWxlLnZpZGVvLnJlbmRlckRpbWVuc2lvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogVGhyb3cgaWYgdGhlIGdpdmVuIHRyYWNrIGlzIG5vdCBhIHtAbGluayBMb2NhbEF1ZGlvVHJhY2t9LCBhXG4gKiB7QGxpbmsgTG9jYWxWaWRlb1RyYWNrfSBvciBhIE1lZGlhU3RyZWFtVHJhY2suXG4gKiBAcGFyYW0geyp9IHRyYWNrXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUxvY2FsVHJhY2sodHJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0cmFjayBpbnN0YW5jZW9mIG9wdGlvbnMuTG9jYWxBdWRpb1RyYWNrXG4gICAgICAgIHx8IHRyYWNrIGluc3RhbmNlb2Ygb3B0aW9ucy5Mb2NhbERhdGFUcmFja1xuICAgICAgICB8fCB0cmFjayBpbnN0YW5jZW9mIG9wdGlvbnMuTG9jYWxWaWRlb1RyYWNrXG4gICAgICAgIHx8IHRyYWNrIGluc3RhbmNlb2Ygb3B0aW9ucy5NZWRpYVN0cmVhbVRyYWNrKSkge1xuICAgICAgICAvKiBlc2xpbnQgbmV3LWNhcDowICovXG4gICAgICAgIHRocm93IEUuSU5WQUxJRF9UWVBFKCd0cmFjaycsICdMb2NhbEF1ZGlvVHJhY2ssIExvY2FsVmlkZW9UcmFjaywgTG9jYWxEYXRhVHJhY2ssIG9yIE1lZGlhU3RyZWFtVHJhY2snKTtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlIGFuIG9iamVjdC4gQW4gb2JqZWN0IGlzIHZhbGlkIGlmIGl0IGlzIHVuZGVmaW5lZCBvciBhIG5vbi1udWxsLCBub24tYXJyYXlcbiAqIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIHNhdGlzZnkgdGhlIHNwZWNpZmllZCBkYXRhLXR5cGUgb3IgdmFsdWUtcmFuZ2UgcmVxdWlyZW1lbnRzLlxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAtIHRoZSBvYmplY3QgdG8gYmUgdmFsaWRhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBvYmplY3QgbmFtZSB0byBiZSB1c2VkIHRvIGJ1aWxkIHRoZSBlcnJvciBtZXNzYWdlLCBpZiBpbnZhbGlkXG4gKiBAcGFyYW0ge0FycmF5PG9iamVjdD59IFtwcm9wQ2hlY2tzXSAtIG9wdGlvbmFsIGRhdGEtdHlwZSBvciB2YWx1ZS1yYW5nZSByZXF1aXJlbWVudHNcbiAqICAgZm9yIHRoZSBvYmplY3QncyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7P0Vycm9yfSAtIG51bGwgaWYgb2JqZWN0IGlzIHZhbGlkLCBFcnJvciBpZiBub3RcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCBuYW1lLCBwcm9wQ2hlY2tzKSB7XG4gICAgaWYgKHByb3BDaGVja3MgPT09IHZvaWQgMCkgeyBwcm9wQ2hlY2tzID0gW107IH1cbiAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBXZSBkZXRlcm1pbmUgdGhhdCBhbiB1bmRlZmluZWQgb2JqZWN0IGlzIHZhbGlkIGJlY2F1c2UgdGhpc1xuICAgIC8vIG1lYW5zIHRoZSBwYXJlbnQgb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gdGhpcyBvYmplY3QgYXMgYSBwcm9wZXJ0eSwgd2hpY2ggaXNcbiAgICAvLyBhIHZhbGlkIHNjZW5hcmlvLlxuICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTk9URShtbWFsYXZhbGxpKTogV2UgZGV0ZXJtaW5lIHRoYXQgaWYgdGhlIG9iamVjdCBpcyBudWxsLCBvciBhbiBBcnJheSwgb3JcbiAgICAvLyBhbnkgb3RoZXIgbm9uLW9iamVjdCB0eXBlLCB0aGVuIGl0IGlzIGludmFsaWQuXG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCAhaXNOb25BcnJheU9iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBFLklOVkFMSURfVFlQRShuYW1lLCAnb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFdlIGRldGVybWluZSB0aGF0IHRoZSBvYmplY3QgaXMgaW52YWxpZCBpZiBhdCBsZWFzdCBvbmUgb2ZcbiAgICAvLyBpdHMgcHJvcGVydGllcyBkb2VzIG5vdCBzYXRpc2Z5IGl0cyBkYXRhLXR5cGUgb3IgdmFsdWUtcmFuZ2UgcmVxdWlyZW1lbnQuXG4gICAgcmV0dXJuIHByb3BDaGVja3MucmVkdWNlKGZ1bmN0aW9uIChlcnJvciwgX2EpIHtcbiAgICAgICAgdmFyIHByb3AgPSBfYS5wcm9wLCB0eXBlID0gX2EudHlwZSwgdmFsdWVzID0gX2EudmFsdWVzO1xuICAgICAgICBpZiAoZXJyb3IgfHwgIShwcm9wIGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3RbcHJvcF07XG4gICAgICAgIGlmICh0eXBlICYmIHR5cGVvZiB2YWx1ZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIEUuSU5WQUxJRF9UWVBFKG5hbWUgKyBcIi5cIiArIHByb3AsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBFLklOVkFMSURfVFlQRShuYW1lICsgXCIuXCIgKyBwcm9wLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpICYmICF2YWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gRS5JTlZBTElEX1ZBTFVFKG5hbWUgKyBcIi5cIiArIHByb3AsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0sIG51bGwpO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIHJlbmRlckRpbWVuc2lvbnMgZmllbGQgdG8gYmUgXCJhdXRvXCIgb3Ige0BsaW5rIFZpZGVvUmVuZGVyRGltZW5zaW9uc30gb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd8VmlkZW9SZW5kZXJEaW1lbnNpb25zfSByZW5kZXJEaW1lbnNpb25zXG4gKiBAcmV0dXJucyB7P0Vycm9yfSAtIG51bGwgaWYgdmFsaWQsIEVycm9yIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSZW5kZXJEaW1lbnNpb25zKHJlbmRlckRpbWVuc2lvbnMpIHtcbiAgICB2YXIgbmFtZSA9ICdvcHRpb25zLmJhbmR3aWR0aFByb2ZpbGUudmlkZW8ucmVuZGVyRGltZW5zaW9ucyc7XG4gICAgdmFyIGVycm9yID0gdmFsaWRhdGVPYmplY3QocmVuZGVyRGltZW5zaW9ucywgbmFtZSk7XG4gICAgcmV0dXJuIHJlbmRlckRpbWVuc2lvbnMgPyBlcnJvciB8fCBPYmplY3QudmFsdWVzKHRyYWNrUHJpb3JpdHkpLnJlZHVjZShmdW5jdGlvbiAoZXJyb3IsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGVycm9yIHx8IHZhbGlkYXRlT2JqZWN0KHJlbmRlckRpbWVuc2lvbnNbcHJvcF0sIG5hbWUgKyBcIi5cIiArIHByb3AsIFtcbiAgICAgICAgICAgIHsgcHJvcDogJ2hlaWdodCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgICAgICB7IHByb3A6ICd3aWR0aCcsIHR5cGU6ICdudW1iZXInIH1cbiAgICAgICAgXSk7XG4gICAgfSwgbnVsbCkgOiBlcnJvcjtcbn1cbmV4cG9ydHMudmFsaWRhdGVCYW5kd2lkdGhQcm9maWxlID0gdmFsaWRhdGVCYW5kd2lkdGhQcm9maWxlO1xuZXhwb3J0cy52YWxpZGF0ZUxvY2FsVHJhY2sgPSB2YWxpZGF0ZUxvY2FsVHJhY2s7XG5leHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gdmFsaWRhdGVPYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0ZS5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqXG4gKiBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgKDEuNy4wKVxuICogYW5kIG1vZGlmaWVkIHRvIHJlbW92ZSBicm93c2VyIGFuZCBBTUQgbW9kdWxlIHN1cHBvcnQsIHdoaWxlIGtlZXBpbmcgQ29tbW9uSlMuXG4gKiBJdCB3YXMgY2F1c2luZyBhIGNvbmZsaWN0IHdoZW4gdGhpcyBpcyBidW5kbGVkIHVzaW5nIENvbW1vbkpTLCBhbmQgdGhlbiBsb2FkZWQgdmlhIFJlcXVpcmVKUy5cbiAqIFRoZSBwcm9wZXIgd2F5IHRvIGZpeCB0aGlzIG1vZHVsZSBpcyB0byBoYXZlIGEgYnVpbGQgdGhhdCBvdXRwdXRzIENvbW1vbkpTIGFuZCBBTUQgc2VwYXJhdGVseVxuICogd2hpY2ggbmVlZHMgdG8gYmUgc3VibWl0dGVkIHRvIHRoZSBvcmlnaW5hbCBtb2R1bGUncyByZXBvLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xudmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xudmFyIGlzSUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB1bmRlZmluZWRUeXBlKSAmJiAoL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKTtcbnZhciBsb2dNZXRob2RzID0gW1xuICAgIFwidHJhY2VcIixcbiAgICBcImRlYnVnXCIsXG4gICAgXCJpbmZvXCIsXG4gICAgXCJ3YXJuXCIsXG4gICAgXCJlcnJvclwiXG5dO1xuLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBUcmFjZSgpIGRvZXNuJ3QgcHJpbnQgdGhlIG1lc3NhZ2UgaW4gSUUsIHNvIGZvciB0aGF0IGNhc2Ugd2UgbmVlZCB0byB3cmFwIGl0XG5mdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJbiBvbGQgSUUsIG5hdGl2ZSBjb25zb2xlIG1ldGhvZHMgdGhlbXNlbHZlcyBkb24ndCBoYXZlIGFwcGx5KCkuXG4gICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29uc29sZS50cmFjZSlcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xufVxuLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4vLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbmZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgIH1cbiAgICBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG59XG4vLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5mdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgfVxuICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG59XG4vLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4vLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4vLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChpZ25vcmUpIHsgfVxuICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGlnbm9yZSkgeyB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChpZ25vcmUpIHsgfVxuICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmUpIHsgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgIH1cbiAgICAvKlxuICAgICAqXG4gICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWxmLm5hbWUgPSBuYW1lO1xuICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDUgfTtcbiAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgfTtcbiAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbiAocGVyc2lzdCkge1xuICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICB9O1xuICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uIChwZXJzaXN0KSB7XG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICB9O1xuICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICB9XG4gICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbn1cbi8qXG4gKlxuICogVG9wLWxldmVsIEFQSVxuICpcbiAqL1xudmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG52YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbmRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICBpZiAoKHR5cGVvZiBuYW1lICE9PSBcInN5bWJvbFwiICYmIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgIH1cbiAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlcjtcbn07XG4vLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbnZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbmRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn07XG5kZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbn07XG4vLyBFUzYgZGVmYXVsdCBleHBvcnQsIGZvciBjb21wYXRpYmlsaXR5XG5kZWZhdWx0TG9nZ2VyWydkZWZhdWx0J10gPSBkZWZhdWx0TG9nZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0TG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nbGV2ZWwuanMubWFwIiwiLyogZ2xvYmFscyB3ZWJraXRBdWRpb0NvbnRleHQsIEF1ZGlvQ29udGV4dCAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIE5hdGl2ZUF1ZGlvQ29udGV4dCA9IHR5cGVvZiBBdWRpb0NvbnRleHQgIT09ICd1bmRlZmluZWQnXG4gICAgPyBBdWRpb0NvbnRleHRcbiAgICA6IHR5cGVvZiB3ZWJraXRBdWRpb0NvbnRleHQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gd2Via2l0QXVkaW9Db250ZXh0XG4gICAgICAgIDogbnVsbDtcbi8qKlxuICogQGludGVyZmFjZSBBdWRpb0NvbnRleHRGYWN0b3J5T3B0aW9uc1xuICogQHByb3BlcnR5IHtBdWRpb0NvbnRleHR9IFtBdWRpb0NvbnRleHRdIC0gVGhlIEF1ZGlvQ29udGV4dCBjb25zdHJ1Y3RvclxuICovXG4vKipcbiAqIHtAbGluayBBdWRpb0NvbnRleHRGYWN0b3J5fSBlbnN1cmVzIHdlIGNvbnN0cnVjdCBhdCBtb3N0IG9uZSBBdWRpb0NvbnRleHRcbiAqIGF0IGEgdGltZSwgYW5kIHRoYXQgaXQgaXMgZXZlbnR1YWxseSBjbG9zZWQgd2hlbiB3ZSBubyBsb25nZXIgbmVlZCBpdC5cbiAqIEBwcm9wZXJ0eSB7QXVkaW9Db250ZXh0RmFjdG9yeX0gQXVkaW9Db250ZXh0RmFjdG9yeSAtIFRoZVxuICogICB7QGxpbmsgQXVkaW9Db250ZXh0RmFjdG9yeX0gY29uc3RydWN0b3JcbiAqL1xudmFyIEF1ZGlvQ29udGV4dEZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBdWRpb0NvbnRleHRGYWN0b3J5T3B0aW9uc30gW29wdGlvbnNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXVkaW9Db250ZXh0RmFjdG9yeShvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIEF1ZGlvQ29udGV4dDogTmF0aXZlQXVkaW9Db250ZXh0XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBfQXVkaW9Db250ZXh0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuQXVkaW9Db250ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2F1ZGlvQ29udGV4dDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2hvbGRlcnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFNldCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQXVkaW9Db250ZXh0RmFjdG9yeToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IEF1ZGlvQ29udGV4dEZhY3RvcnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhY2ggY2FsbCB0byB7QGxpbmsgQXVkaW9Db250ZXh0RmFjdG9yeSNnZXRPckNyZWF0ZX0gc2hvdWxkIGJlIHBhaXJlZCB3aXRoIGFcbiAgICAgKiBjYWxsIHRvIHtAbGluayBBdWRpb0NvbnRleHRGYWN0b3J5I3JlbGVhc2V9LiBDYWxsaW5nIHRoaXMgaW5jcmVtZW50cyBhblxuICAgICAqIGludGVybmFsIHJlZmVyZW5jZSBjb3VudC5cbiAgICAgKiBAcGFyYW0geyp9IGhvbGRlciAtIFRoZSBvYmplY3QgdG8gaG9sZCBhIHJlZmVyZW5jZSB0byB0aGUgQXVkaW9Db250ZXh0XG4gICAgICogQHJldHVybnMgez9BdWRpb0NvbnRleHR9XG4gICAgICovXG4gICAgQXVkaW9Db250ZXh0RmFjdG9yeS5wcm90b3R5cGUuZ2V0T3JDcmVhdGUgPSBmdW5jdGlvbiAoaG9sZGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5faG9sZGVycy5oYXMoaG9sZGVyKSkge1xuICAgICAgICAgICAgdGhpcy5faG9sZGVycy5hZGQoaG9sZGVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9BdWRpb0NvbnRleHQgJiYgIXRoaXMuX2F1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvQ29udGV4dCA9IG5ldyB0aGlzLl9BdWRpb0NvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hdWRpb0NvbnRleHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWNyZW1lbnQgdGhlIGludGVybmFsIHJlZmVyZW5jZSBjb3VudC4gSWYgaXQgcmVhY2hlcyB6ZXJvLCBjbG9zZSBhbmQgZGVzdHJveVxuICAgICAqIHRoZSBBdWRpb0NvbnRleHQuXG4gICAgICogQHBhcmFtIHsqfSBob2xkZXIgLSBUaGUgb2JqZWN0IHRoYXQgaGVsZCBhIHJlZmVyZW5jZSB0byB0aGUgQXVkaW9Db250ZXh0XG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgQXVkaW9Db250ZXh0RmFjdG9yeS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uIChob2xkZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hvbGRlcnMuaGFzKGhvbGRlcikpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvbGRlcnMuZGVsZXRlKGhvbGRlcik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hvbGRlcnMuc2l6ZSAmJiB0aGlzLl9hdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb0NvbnRleHQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXVkaW9Db250ZXh0RmFjdG9yeTtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBBdWRpb0NvbnRleHRGYWN0b3J5KCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdWRpb2NvbnRleHQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBSZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgYHRpbWVvdXRgIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7P251bWJlcn0gW3RpbWVvdXQ9MF1cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5mdW5jdGlvbiBkZWxheSh0aW1lb3V0KSB7XG4gICAgdGltZW91dCA9IHR5cGVvZiB0aW1lb3V0ID09PSAnbnVtYmVyJyA/IHRpbWVvdXQgOiAwO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KTsgfSk7XG59XG4vKipcbiAqIEF0dGVtcHQgdG8gZGV0ZWN0IHNpbGVuY2UuIFRoZSBQcm9taXNlIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gcmV0dXJuc1xuICogZmFsc2UgYXMgc29vbiBhcyBhdWRpbyBpcyBkZXRlY3RlZCBvciB0cnVlIGFmdGVyIGB0aW1lb3V0YCBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gYXVkaW9Db250ZXh0XG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAqIEBwYXJhbSB7P251bWJlcn0gW3RpbWVvdXQ9MjUwXVxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gKi9cbmZ1bmN0aW9uIGRldGVjdFNpbGVuY2UoYXVkaW9Db250ZXh0LCBzdHJlYW0sIHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0ID0gdHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInID8gdGltZW91dCA6IDI1MDtcbiAgICB2YXIgc291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSk7XG4gICAgdmFyIGFuYWx5c2VyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IDIwNDg7XG4gICAgc291cmNlLmNvbm5lY3QoYW5hbHlzZXIpO1xuICAgIHZhciBzYW1wbGVzID0gbmV3IFVpbnQ4QXJyYXkoYW5hbHlzZXIuZmZ0U2l6ZSk7XG4gICAgdmFyIHRpbWVvdXREaWRGaXJlID0gZmFsc2U7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRpbWVvdXREaWRGaXJlID0gdHJ1ZTsgfSwgdGltZW91dCk7XG4gICAgLyoqXG4gICAgICogV2UgY2FuJ3QgdXNlIGFzeW5jL2F3YWl0IHlldCwgc28gSSBuZWVkIHRvIGZhY3RvciB0aGlzIG91dC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0RldGVjdFNpbGVuY2UoKSB7XG4gICAgICAgIGlmICh0aW1lb3V0RGlkRmlyZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBhbmFseXNlci5nZXRCeXRlVGltZURvbWFpbkRhdGEoc2FtcGxlcyk7XG4gICAgICAgIC8vIE5PVEUobXBhdHdhcmRoYW4pOiBBbiBhdWRpbyBNZWRpYVN0cmVhbVRyYWNrIGNhbiBiZSBzaWxlbnQgZWl0aGVyIGR1ZSB0byBhbGwgc2FtcGxlc1xuICAgICAgICAvLyBiZWluZyBlcXVhbCB0byAxMjggb3IgYWxsIHNhbXBsZXMgYmVpbmcgZXF1YWwgdG8gMC5cbiAgICAgICAgcmV0dXJuIHNhbXBsZXMuc29tZShmdW5jdGlvbiAoc2FtcGxlKSB7IHJldHVybiBzYW1wbGUgIT09IDEyOCAmJiBzYW1wbGUgIT09IDA7IH0pXG4gICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZShmYWxzZSlcbiAgICAgICAgICAgIDogZGVsYXkoKS50aGVuKGRvRGV0ZWN0U2lsZW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBkb0RldGVjdFNpbGVuY2UoKS50aGVuKGZ1bmN0aW9uIChpc1NpbGVudCkge1xuICAgICAgICBzb3VyY2UuZGlzY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gaXNTaWxlbnQ7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHNvdXJjZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBkZXRlY3RTaWxlbmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0c2lsZW5jZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG52YXIgZGV0ZWN0U2lsZW5jZSA9IHJlcXVpcmUoJy4vZGV0ZWN0c2lsZW5jZScpO1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGF0dGVtcHRzIHRvIHdvcmthcm91bmQgV2ViS2l0IEJ1ZyAxODA3NDguIEl0IGRvZXMgc28gYnlcbiAqXG4gKiAgIDEuIENhbGxpbmcgYGdldFVzZXJNZWRpYWAsIGFuZFxuICogICAyLiBDaGVja2luZyB0byBzZWUgaWYgdGhlIHJlc3VsdGluZyBNZWRpYVN0cmVhbSBpcyBzaWxlbnQuXG4gKiAgIDMuIElmIHNvLCByZXBlYXQgU3RlcCAxOyBvdGhlcndpc2UsIHJldHVybiB0aGUgTWVkaWFTdHJlYW0uXG4gKlxuICogVGhlIGZ1bmN0aW9uIG9ubHkgcmVwZWF0cyB1cCB0byBgbmAgdGltZXMsIGFuZCBpdCBvbmx5IHdhaXRzIGB0aW1lb3V0YFxuICogbWlsbGlzZWNvbmRzIHdoZW4gZGV0ZWN0aW5nIHNpbGVuY2UuIEFzc3VtaW5nIGBnZXRVc2VyTWVkaWFgIGlzXG4gKiBpbnN0YW50YW5lb3VzLCBpbiB0aGUgYmVzdCBjYXNlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBQcm9taXNlIHRoYXRcbiAqIHJlc29sdmVzIGltbWVkaWF0ZWx5OyBpbiB0aGUgd29yc3QgY2FzZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgUHJvbWlzZSB0aGF0XG4gKiByZXNvbHZlcyBpbiBgbmAgKiBgdGltZW91dGAgbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7TG9nfSBsb2dcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oTWVkaWFTdHJlYW1Db25zdHJhaW50cyk6IFByb21pc2U8TWVkaWFTdHJlYW0+fSBnZXRVc2VyTWVkaWFcbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW1Db25zdHJhaW50c30gY29uc3RyYWludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbj0zXVxuICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0PTI1MF1cbiAqIEByZXR1cm5zIFByb21pc2U8TWVkaWFTdHJlYW0+XG4gKi9cbmZ1bmN0aW9uIHdvcmthcm91bmQobG9nLCBnZXRVc2VyTWVkaWEsIGNvbnN0cmFpbnRzLCBuLCB0aW1lb3V0KSB7XG4gICAgbiA9IHR5cGVvZiBuID09PSAnbnVtYmVyJyA/IG4gOiAzO1xuICAgIHZhciByZXRyeSA9IDA7XG4gICAgLy8gTk9URShtcm9iZXJ0cyk6IFdlIGhhdmUgdG8gZGVsYXkgcmVxdWlyZS1pbmcgQXVkaW9Db250ZXh0RmFjdG9yeSwgYmVjYXVzZVxuICAgIC8vIGl0IGV4cG9ydHMgYSBkZWZhdWx0IGluc3RhbmNlIHdob3NlIGNvbnN0cnVjdG9yIGNhbGxzIE9iamVjdC5hc3NpZ24uXG4gICAgdmFyIEF1ZGlvQ29udGV4dEZhY3RvcnkgPSByZXF1aXJlKCcuL2F1ZGlvY29udGV4dCcpO1xuICAgIHZhciBob2xkZXIgPSB7fTtcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gQXVkaW9Db250ZXh0RmFjdG9yeS5nZXRPckNyZWF0ZShob2xkZXIpO1xuICAgIC8qKlxuICAgICAqIFdlIGNhbid0IHVzZSBhc3luYy9hd2FpdCB5ZXQsIHNvIEkgbmVlZCB0byBmYWN0b3IgdGhpcyBvdXQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TWVkaWFTdHJlYW0+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvV29ya2Fyb3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgaXNTaWxlbnRQcm9taXNlID0gY29uc3RyYWludHMuYXVkaW9cbiAgICAgICAgICAgICAgICA/IGRldGVjdFNpbGVuY2UoYXVkaW9Db250ZXh0LCBzdHJlYW0sIHRpbWVvdXQpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oJ0VuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGRldGVjdGluZyBzaWxlbmNlJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gaXNTaWxlbnRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGlzU2lsZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1NpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBsb2cuaW5mbygnR290IGEgbm9uLXNpbGVudCBhdWRpbyBNZWRpYVN0cmVhbVRyYWNrOyByZXR1cm5pbmcgaXQuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG4gPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb2cud2FybignR290IGEgc2lsZW50IGF1ZGlvIE1lZGlhU3RyZWFtVHJhY2suIE5vcm1hbGx5IHdlIHdvdWxkIHRyeSBcXFxudG8gZ2V0IGEgbmV3IG9uZSwgYnV0IHdlXFwndmUgcnVuIG91dCBvZiByZXRyaWVzOyByZXR1cm5pbmcgaXQgYW55d2F5LicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2cud2FybihcIkdvdCBhIHNpbGVudCBhdWRpbyBNZWRpYVN0cmVhbVRyYWNrLiBTdG9wcGluZyBhbGwgTWVkaWFTdHJlYW1UcmFja3MgYW5kIGNhbGxpbmcgZ2V0VXNlck1lZGlhIGFnYWluLiBUaGlzIGlzIHJldHJ5ICNcIiArICsrcmV0cnkgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7IHJldHVybiB0cmFjay5zdG9wKCk7IH0pO1xuICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9Xb3JrYXJvdW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkb1dvcmthcm91bmQoKS50aGVuKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgQXVkaW9Db250ZXh0RmFjdG9yeS5yZWxlYXNlKGhvbGRlcik7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIEF1ZGlvQ29udGV4dEZhY3RvcnkucmVsZWFzZShob2xkZXIpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gd29ya2Fyb3VuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmthcm91bmQxODA3NDguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZmxhdE1hcCA9IHJlcXVpcmUoJy4vdXRpbCcpLmZsYXRNYXA7XG52YXIgZ3Vlc3NCcm93c2VyID0gcmVxdWlyZSgnLi91dGlsJykuZ3Vlc3NCcm93c2VyO1xudmFyIGd1ZXNzQnJvd3NlclZlcnNpb24gPSByZXF1aXJlKCcuL3V0aWwnKS5ndWVzc0Jyb3dzZXJWZXJzaW9uO1xudmFyIGdldFNkcEZvcm1hdCA9IHJlcXVpcmUoJy4vdXRpbC9zZHAnKS5nZXRTZHBGb3JtYXQ7XG5cbnZhciBndWVzcyA9IGd1ZXNzQnJvd3NlcigpO1xudmFyIGd1ZXNzVmVyc2lvbiA9IGd1ZXNzQnJvd3NlclZlcnNpb24oKTtcbnZhciBpc0Nocm9tZSA9IGd1ZXNzID09PSAnY2hyb21lJztcbnZhciBpc0ZpcmVmb3ggPSBndWVzcyA9PT0gJ2ZpcmVmb3gnO1xudmFyIGlzU2FmYXJpID0gZ3Vlc3MgPT09ICdzYWZhcmknO1xuXG52YXIgY2hyb21lTWFqb3JWZXJzaW9uID0gaXNDaHJvbWUgPyBndWVzc1ZlcnNpb24ubWFqb3IgOiBudWxsO1xuXG52YXIgQ0hST01FX0xFR0FDWV9NQVhfQVVESU9fTEVWRUwgPSAzMjc2NztcblxuLyoqXG4gKiBHZXQgdGhlIHN0YW5kYXJkaXplZCB7QGxpbmsgUlRDUGVlckNvbm5lY3Rpb259IHN0YXRpc3RpY3MuXG4gKiBAcGFyYW0ge1JUQ1BlZXJDb25uZWN0aW9ufSBwZWVyQ29ubmVjdGlvblxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFVzZWQgZm9yIHRlc3RpbmdcbiAqIEByZXR1cm5zIHtQcm9taXNlLjxTdGFuZGFyZGl6ZWRTdGF0c1Jlc3BvbnNlPn1cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdHMocGVlckNvbm5lY3Rpb24sIG9wdGlvbnMpIHtcbiAgaWYgKCEocGVlckNvbm5lY3Rpb24gJiYgdHlwZW9mIHBlZXJDb25uZWN0aW9uLmdldFN0YXRzID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0dpdmVuIFBlZXJDb25uZWN0aW9uIGRvZXMgbm90IHN1cHBvcnQgZ2V0U3RhdHMnKSk7XG4gIH1cbiAgcmV0dXJuIF9nZXRTdGF0cyhwZWVyQ29ubmVjdGlvbiwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogZ2V0U3RhdHMoKSBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSB7UlRDUGVlckNvbm5lY3Rpb259IHBlZXJDb25uZWN0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gVXNlZCBmb3IgdGVzdGluZ1xuICogQHJldHVybnMge1Byb21pc2UuPFN0YW5kYXJkaXplZFN0YXRzUmVzcG9uc2U+fVxuICovXG5mdW5jdGlvbiBfZ2V0U3RhdHMocGVlckNvbm5lY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIGxvY2FsQXVkaW9UcmFja3MgPSBnZXRUcmFja3MocGVlckNvbm5lY3Rpb24sICdhdWRpbycsICdsb2NhbCcpO1xuICB2YXIgbG9jYWxWaWRlb1RyYWNrcyA9IGdldFRyYWNrcyhwZWVyQ29ubmVjdGlvbiwgJ3ZpZGVvJywgJ2xvY2FsJyk7XG4gIHZhciByZW1vdGVBdWRpb1RyYWNrcyA9IGdldFRyYWNrcyhwZWVyQ29ubmVjdGlvbiwgJ2F1ZGlvJyk7XG4gIHZhciByZW1vdGVWaWRlb1RyYWNrcyA9IGdldFRyYWNrcyhwZWVyQ29ubmVjdGlvbiwgJ3ZpZGVvJyk7XG5cbiAgdmFyIHN0YXRzUmVzcG9uc2UgPSB7XG4gICAgYWN0aXZlSWNlQ2FuZGlkYXRlUGFpcjogbnVsbCxcbiAgICBsb2NhbEF1ZGlvVHJhY2tTdGF0czogW10sXG4gICAgbG9jYWxWaWRlb1RyYWNrU3RhdHM6IFtdLFxuICAgIHJlbW90ZUF1ZGlvVHJhY2tTdGF0czogW10sXG4gICAgcmVtb3RlVmlkZW9UcmFja1N0YXRzOiBbXVxuICB9O1xuXG4gIHZhciB0cmFja1N0YXRzUHJvbWlzZXMgPSBmbGF0TWFwKFtcbiAgICBbbG9jYWxBdWRpb1RyYWNrcywgJ2xvY2FsQXVkaW9UcmFja1N0YXRzJywgZmFsc2VdLFxuICAgIFtsb2NhbFZpZGVvVHJhY2tzLCAnbG9jYWxWaWRlb1RyYWNrU3RhdHMnLCBmYWxzZV0sXG4gICAgW3JlbW90ZUF1ZGlvVHJhY2tzLCAncmVtb3RlQXVkaW9UcmFja1N0YXRzJywgdHJ1ZV0sXG4gICAgW3JlbW90ZVZpZGVvVHJhY2tzLCAncmVtb3RlVmlkZW9UcmFja1N0YXRzJywgdHJ1ZV1cbiAgXSwgZnVuY3Rpb24odHJpcGxlKSB7XG4gICAgdmFyIHRyYWNrcyA9IHRyaXBsZVswXTtcbiAgICB2YXIgc3RhdHNBcnJheU5hbWUgPSB0cmlwbGVbMV07XG4gICAgdmFyIGlzUmVtb3RlID0gdHJpcGxlWzJdO1xuICAgIHJldHVybiB0cmFja3MubWFwKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICByZXR1cm4gZ2V0VHJhY2tTdGF0cyhwZWVyQ29ubmVjdGlvbiwgdHJhY2ssIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBpc1JlbW90ZTogaXNSZW1vdGVcbiAgICAgIH0sIG9wdGlvbnMpKS50aGVuKGZ1bmN0aW9uKHRyYWNrU3RhdHNBcnJheSkge1xuICAgICAgICB0cmFja1N0YXRzQXJyYXkuZm9yRWFjaChmdW5jdGlvbih0cmFja1N0YXRzKSB7XG4gICAgICAgICAgdHJhY2tTdGF0cy50cmFja0lkID0gdHJhY2suaWQ7XG4gICAgICAgICAgc3RhdHNSZXNwb25zZVtzdGF0c0FycmF5TmFtZV0ucHVzaCh0cmFja1N0YXRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKHRyYWNrU3RhdHNQcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2V0QWN0aXZlSWNlQ2FuZGlkYXRlUGFpclN0YXRzKHBlZXJDb25uZWN0aW9uLCBvcHRpb25zKTtcbiAgfSkudGhlbihmdW5jdGlvbihhY3RpdmVJY2VDYW5kaWRhdGVQYWlyU3RhdHNSZXBvcnQpIHtcbiAgICBzdGF0c1Jlc3BvbnNlLmFjdGl2ZUljZUNhbmRpZGF0ZVBhaXIgPSBhY3RpdmVJY2VDYW5kaWRhdGVQYWlyU3RhdHNSZXBvcnQ7XG4gICAgcmV0dXJuIHN0YXRzUmVzcG9uc2U7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSB7QGxpbmsgU3RhbmRhcmRpemVkQWN0aXZlSWNlQ2FuZGlkYXRlUGFpclN0YXRzUmVwb3J0fSBmb3IgdGhlXG4gKiB7QGxpbmsgUlRDUGVlckNvbm5lY3Rpb259LlxuICogQHBhcmFtIHtSVENQZWVyQ29ubmVjdGlvbn0gcGVlckNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPFN0YW5kYXJkaXplZEFjdGl2ZUljZUNhbmRpZGF0ZVBhaXJTdGF0c1JlcG9ydD59XG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZUljZUNhbmRpZGF0ZVBhaXJTdGF0cyhwZWVyQ29ubmVjdGlvbiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMudGVzdEZvckNocm9tZSAhPT0gJ3VuZGVmaW5lZCcgfHwgaXNDaHJvbWVcbiAgICB8fCB0eXBlb2Ygb3B0aW9ucy50ZXN0Rm9yU2FmYXJpICAhPT0gJ3VuZGVmaW5lZCcgfHwgaXNTYWZhcmkpIHtcbiAgICByZXR1cm4gcGVlckNvbm5lY3Rpb24uZ2V0U3RhdHMoKS50aGVuKFxuICAgICAgc3RhbmRhcmRpemVDaHJvbWVPclNhZmFyaUFjdGl2ZUljZUNhbmRpZGF0ZVBhaXJTdGF0cyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLnRlc3RGb3JGaXJlZm94ICE9PSAndW5kZWZpbmVkJyB8fCBpc0ZpcmVmb3gpIHtcbiAgICByZXR1cm4gcGVlckNvbm5lY3Rpb24uZ2V0U3RhdHMoKS50aGVuKHN0YW5kYXJkaXplRmlyZWZveEFjdGl2ZUljZUNhbmRpZGF0ZVBhaXJTdGF0cyk7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignUlRDUGVlckNvbm5lY3Rpb24jZ2V0U3RhdHMoKSBub3Qgc3VwcG9ydGVkJykpO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkaXplIHRoZSBhY3RpdmUgUlRDSWNlQ2FuZGlkYXRlIHBhaXIncyBzdGF0aXN0aWNzIGluIENocm9tZSBvciBTYWZhcmkuXG4gKiBAcGFyYW0ge1JUQ1N0YXRzUmVwb3J0fSBzdGF0c1xuICogQHJldHVybnMgez9TdGFuZGFyZGl6ZWRBY3RpdmVJY2VDYW5kaWRhdGVQYWlyU3RhdHNSZXBvcnR9XG4gKi9cbmZ1bmN0aW9uIHN0YW5kYXJkaXplQ2hyb21lT3JTYWZhcmlBY3RpdmVJY2VDYW5kaWRhdGVQYWlyU3RhdHMoc3RhdHMpIHtcbiAgdmFyIGFjdGl2ZUNhbmRpZGF0ZVBhaXJTdGF0cyA9IEFycmF5LmZyb20oc3RhdHMudmFsdWVzKCkpLmZpbmQoZnVuY3Rpb24oc3RhdCkge1xuICAgIHJldHVybiBzdGF0LnR5cGUgPT09ICdjYW5kaWRhdGUtcGFpcicgJiYgc3RhdC5ub21pbmF0ZWQ7XG4gIH0pO1xuXG4gIGlmICghYWN0aXZlQ2FuZGlkYXRlUGFpclN0YXRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYWN0aXZlTG9jYWxDYW5kaWRhdGVTdGF0cyA9IHN0YXRzLmdldChhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHMubG9jYWxDYW5kaWRhdGVJZCk7XG4gIHZhciBhY3RpdmVSZW1vdGVDYW5kaWRhdGVTdGF0cyA9IHN0YXRzLmdldChhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHMucmVtb3RlQ2FuZGlkYXRlSWQpO1xuXG4gIHZhciBzdGFuZGFyZGl6ZWRDYW5kaWRhdGVTdGF0c0tleXMgPSBbXG4gICAgeyBrZXk6ICdjYW5kaWRhdGVUeXBlJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICB7IGtleTogJ2lwJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICB7IGtleTogJ3BvcnQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAncHJpb3JpdHknLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAncHJvdG9jb2wnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgIHsga2V5OiAndXJsJywgdHlwZTogJ3N0cmluZycgfVxuICBdO1xuXG4gIHZhciBzdGFuZGFyZGl6ZWRMb2NhbENhbmRpZGF0ZVN0YXRzS2V5cyA9IHN0YW5kYXJkaXplZENhbmRpZGF0ZVN0YXRzS2V5cy5jb25jYXQoW1xuICAgIHsga2V5OiAnZGVsZXRlZCcsIHR5cGU6ICdib29sZWFuJyB9LFxuICAgIHsga2V5OiAncmVsYXlQcm90b2NvbCcsIHR5cGU6ICdzdHJpbmcnIH1cbiAgXSk7XG5cbiAgdmFyIHN0YW5kYXRkaXplZExvY2FsQ2FuZGlkYXRlU3RhdHNSZXBvcnQgPSBhY3RpdmVMb2NhbENhbmRpZGF0ZVN0YXRzXG4gICAgPyBzdGFuZGFyZGl6ZWRMb2NhbENhbmRpZGF0ZVN0YXRzS2V5cy5yZWR1Y2UoZnVuY3Rpb24ocmVwb3J0LCBrZXlJbmZvKSB7XG4gICAgICByZXBvcnRba2V5SW5mby5rZXldID0gdHlwZW9mIGFjdGl2ZUxvY2FsQ2FuZGlkYXRlU3RhdHNba2V5SW5mby5rZXldID09PSBrZXlJbmZvLnR5cGVcbiAgICAgICAgPyBhY3RpdmVMb2NhbENhbmRpZGF0ZVN0YXRzW2tleUluZm8ua2V5XVxuICAgICAgICA6IGtleUluZm8ua2V5ID09PSAnZGVsZXRlZCcgPyBmYWxzZSA6IG51bGw7XG4gICAgICByZXR1cm4gcmVwb3J0O1xuICAgIH0sIHt9KVxuICAgIDogbnVsbDtcblxuICB2YXIgc3RhbmRhcmRpemVkUmVtb3RlQ2FuZGlkYXRlU3RhdHNSZXBvcnQgPSBhY3RpdmVSZW1vdGVDYW5kaWRhdGVTdGF0c1xuICAgID8gc3RhbmRhcmRpemVkQ2FuZGlkYXRlU3RhdHNLZXlzLnJlZHVjZShmdW5jdGlvbihyZXBvcnQsIGtleUluZm8pIHtcbiAgICAgIHJlcG9ydFtrZXlJbmZvLmtleV0gPSB0eXBlb2YgYWN0aXZlUmVtb3RlQ2FuZGlkYXRlU3RhdHNba2V5SW5mby5rZXldID09PSBrZXlJbmZvLnR5cGVcbiAgICAgICAgPyBhY3RpdmVSZW1vdGVDYW5kaWRhdGVTdGF0c1trZXlJbmZvLmtleV1cbiAgICAgICAgOiBudWxsO1xuICAgICAgcmV0dXJuIHJlcG9ydDtcbiAgICB9LCB7fSlcbiAgICA6IG51bGw7XG5cbiAgcmV0dXJuIFtcbiAgICB7IGtleTogJ2F2YWlsYWJsZUluY29taW5nQml0cmF0ZScsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdhdmFpbGFibGVPdXRnb2luZ0JpdHJhdGUnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAnYnl0ZXNSZWNlaXZlZCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdieXRlc1NlbnQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAnY29uc2VudFJlcXVlc3RzU2VudCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdjdXJyZW50Um91bmRUcmlwVGltZScsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdsYXN0UGFja2V0UmVjZWl2ZWRUaW1lc3RhbXAnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAnbGFzdFBhY2tldFNlbnRUaW1lc3RhbXAnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAnbm9taW5hdGVkJywgdHlwZTogJ2Jvb2xlYW4nIH0sXG4gICAgeyBrZXk6ICdwcmlvcml0eScsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdyZWFkYWJsZScsIHR5cGU6ICdib29sZWFuJyB9LFxuICAgIHsga2V5OiAncmVxdWVzdHNSZWNlaXZlZCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdyZXF1ZXN0c1NlbnQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAncmVzcG9uc2VzUmVjZWl2ZWQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAncmVzcG9uc2VzU2VudCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdyZXRyYW5zbWlzc2lvbnNSZWNlaXZlZCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdyZXRyYW5zbWlzc2lvbnNTZW50JywgdHlwZTogJ251bWJlcicgfSxcbiAgICB7IGtleTogJ3N0YXRlJywgdHlwZTogJ3N0cmluZycsIGZpeHVwOiBmdW5jdGlvbihzdGF0ZSkgeyByZXR1cm4gc3RhdGUgPT09ICdpbnByb2dyZXNzJyA/ICdpbi1wcm9ncmVzcycgOiBzdGF0ZTsgfSB9LFxuICAgIHsga2V5OiAndG90YWxSb3VuZFRyaXBUaW1lJywgdHlwZTogJ251bWJlcicgfSxcbiAgICB7IGtleTogJ3RyYW5zcG9ydElkJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICB7IGtleTogJ3dyaXRhYmxlJywgdHlwZTogJ2Jvb2xlYW4nIH1cbiAgXS5yZWR1Y2UoZnVuY3Rpb24ocmVwb3J0LCBrZXlJbmZvKSB7XG4gICAgcmVwb3J0W2tleUluZm8ua2V5XSA9IHR5cGVvZiBhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHNba2V5SW5mby5rZXldID09PSBrZXlJbmZvLnR5cGVcbiAgICAgID8gKGtleUluZm8uZml4dXAgPyBrZXlJbmZvLmZpeHVwKGFjdGl2ZUNhbmRpZGF0ZVBhaXJTdGF0c1trZXlJbmZvLmtleV0pIDogYWN0aXZlQ2FuZGlkYXRlUGFpclN0YXRzW2tleUluZm8ua2V5XSlcbiAgICAgIDogbnVsbDtcbiAgICByZXR1cm4gcmVwb3J0O1xuICB9LCB7XG4gICAgbG9jYWxDYW5kaWRhdGU6IHN0YW5kYXRkaXplZExvY2FsQ2FuZGlkYXRlU3RhdHNSZXBvcnQsXG4gICAgcmVtb3RlQ2FuZGlkYXRlOiBzdGFuZGFyZGl6ZWRSZW1vdGVDYW5kaWRhdGVTdGF0c1JlcG9ydFxuICB9KTtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZGl6ZSB0aGUgYWN0aXZlIFJUQ0ljZUNhbmRpZGF0ZSBwYWlyJ3Mgc3RhdGlzdGljcyBpbiBGaXJlZm94LlxuICogQHBhcmFtIHtSVENTdGF0c1JlcG9ydH0gc3RhdHNcbiAqIEByZXR1cm5zIHs/U3RhbmRhcmRpemVkQWN0aXZlSWNlQ2FuZGlkYXRlUGFpclN0YXRzUmVwb3J0fVxuICovXG5mdW5jdGlvbiBzdGFuZGFyZGl6ZUZpcmVmb3hBY3RpdmVJY2VDYW5kaWRhdGVQYWlyU3RhdHMoc3RhdHMpIHtcbiAgdmFyIGFjdGl2ZUNhbmRpZGF0ZVBhaXJTdGF0cyA9IEFycmF5LmZyb20oc3RhdHMudmFsdWVzKCkpLmZpbmQoZnVuY3Rpb24oc3RhdCkge1xuICAgIHJldHVybiBzdGF0LnR5cGUgPT09ICdjYW5kaWRhdGUtcGFpcicgJiYgc3RhdC5ub21pbmF0ZWQ7XG4gIH0pO1xuXG4gIGlmICghYWN0aXZlQ2FuZGlkYXRlUGFpclN0YXRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYWN0aXZlTG9jYWxDYW5kaWRhdGVTdGF0cyA9IHN0YXRzLmdldChhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHMubG9jYWxDYW5kaWRhdGVJZCk7XG4gIHZhciBhY3RpdmVSZW1vdGVDYW5kaWRhdGVTdGF0cyA9IHN0YXRzLmdldChhY3RpdmVDYW5kaWRhdGVQYWlyU3RhdHMucmVtb3RlQ2FuZGlkYXRlSWQpO1xuXG4gIHZhciBzdGFuZGFyZGl6ZWRDYW5kaWRhdGVTdGF0c0tleXMgPSBbXG4gICAgeyBrZXk6ICdjYW5kaWRhdGVUeXBlJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICB7IGtleTogJ2lwJywgZmZLZXlzOiBbJ2FkZHJlc3MnLCAnaXBBZGRyZXNzJ10sIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgeyBrZXk6ICdwb3J0JywgZmZLZXlzOiBbJ3BvcnROdW1iZXInXSwgdHlwZTogJ251bWJlcicgfSxcbiAgICB7IGtleTogJ3ByaW9yaXR5JywgdHlwZTogJ251bWJlcicgfSxcbiAgICB7IGtleTogJ3Byb3RvY29sJywgZmZLZXlzOiBbJ3RyYW5zcG9ydCddLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgIHsga2V5OiAndXJsJywgdHlwZTogJ3N0cmluZycgfVxuICBdO1xuXG4gIHZhciBzdGFuZGFyZGl6ZWRMb2NhbENhbmRpZGF0ZVN0YXRzS2V5cyA9IHN0YW5kYXJkaXplZENhbmRpZGF0ZVN0YXRzS2V5cy5jb25jYXQoW1xuICAgIHsga2V5OiAnZGVsZXRlZCcsIHR5cGU6ICdib29sZWFuJyB9LFxuICAgIHsga2V5OiAncmVsYXlQcm90b2NvbCcsIHR5cGU6ICdzdHJpbmcnIH1cbiAgXSk7XG5cbiAgdmFyIGNhbmRpZGF0ZVR5cGVzID0ge1xuICAgIGhvc3Q6ICdob3N0JyxcbiAgICBwZWVycmVmbGV4aXZlOiAncHJmbHgnLFxuICAgIHJlbGF5ZWQ6ICdyZWxheScsXG4gICAgc2VydmVycmVmbGV4aXZlOiAnc3JmbHgnXG4gIH07XG5cbiAgdmFyIHN0YW5kYXRkaXplZExvY2FsQ2FuZGlkYXRlU3RhdHNSZXBvcnQgPSBhY3RpdmVMb2NhbENhbmRpZGF0ZVN0YXRzXG4gICAgPyBzdGFuZGFyZGl6ZWRMb2NhbENhbmRpZGF0ZVN0YXRzS2V5cy5yZWR1Y2UoZnVuY3Rpb24ocmVwb3J0LCBrZXlJbmZvKSB7XG4gICAgICB2YXIga2V5ID0ga2V5SW5mby5mZktleXMgJiYga2V5SW5mby5mZktleXMuZmluZChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiBhY3RpdmVMb2NhbENhbmRpZGF0ZVN0YXRzO1xuICAgICAgfSkgfHwga2V5SW5mby5rZXk7XG4gICAgICByZXBvcnRba2V5SW5mby5rZXldID0gdHlwZW9mIGFjdGl2ZUxvY2FsQ2FuZGlkYXRlU3RhdHNba2V5XSA9PT0ga2V5SW5mby50eXBlXG4gICAgICAgID8ga2V5ID09PSAnY2FuZGlkYXRlVHlwZSdcbiAgICAgICAgICA/IGNhbmRpZGF0ZVR5cGVzW2FjdGl2ZUxvY2FsQ2FuZGlkYXRlU3RhdHNba2V5XV0gfHwgYWN0aXZlTG9jYWxDYW5kaWRhdGVTdGF0c1trZXldXG4gICAgICAgICAgOiBhY3RpdmVMb2NhbENhbmRpZGF0ZVN0YXRzW2tleV1cbiAgICAgICAgOiBrZXkgPT09ICdkZWxldGVkJyA/IGZhbHNlIDogbnVsbDtcbiAgICAgIHJldHVybiByZXBvcnQ7XG4gICAgfSwge30pXG4gICAgOiBudWxsO1xuXG4gIHZhciBzdGFuZGFyZGl6ZWRSZW1vdGVDYW5kaWRhdGVTdGF0c1JlcG9ydCA9IGFjdGl2ZVJlbW90ZUNhbmRpZGF0ZVN0YXRzXG4gICAgPyBzdGFuZGFyZGl6ZWRDYW5kaWRhdGVTdGF0c0tleXMucmVkdWNlKGZ1bmN0aW9uKHJlcG9ydCwga2V5SW5mbykge1xuICAgICAgdmFyIGtleSA9IGtleUluZm8uZmZLZXlzICYmIGtleUluZm8uZmZLZXlzLmZpbmQoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gYWN0aXZlUmVtb3RlQ2FuZGlkYXRlU3RhdHM7XG4gICAgICB9KSB8fCBrZXlJbmZvLmtleTtcbiAgICAgIHJlcG9ydFtrZXlJbmZvLmtleV0gPSB0eXBlb2YgYWN0aXZlUmVtb3RlQ2FuZGlkYXRlU3RhdHNba2V5XSA9PT0ga2V5SW5mby50eXBlXG4gICAgICAgID8ga2V5ID09PSAnY2FuZGlkYXRlVHlwZSdcbiAgICAgICAgICA/IGNhbmRpZGF0ZVR5cGVzW2FjdGl2ZVJlbW90ZUNhbmRpZGF0ZVN0YXRzW2tleV1dIHx8IGFjdGl2ZVJlbW90ZUNhbmRpZGF0ZVN0YXRzW2tleV1cbiAgICAgICAgICA6IGFjdGl2ZVJlbW90ZUNhbmRpZGF0ZVN0YXRzW2tleV1cbiAgICAgICAgOiBudWxsO1xuICAgICAgcmV0dXJuIHJlcG9ydDtcbiAgICB9LCB7fSlcbiAgICA6IG51bGw7XG5cbiAgcmV0dXJuIFtcbiAgICB7IGtleTogJ2F2YWlsYWJsZUluY29taW5nQml0cmF0ZScsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdhdmFpbGFibGVPdXRnb2luZ0JpdHJhdGUnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAnYnl0ZXNSZWNlaXZlZCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdieXRlc1NlbnQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAnY29uc2VudFJlcXVlc3RzU2VudCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdjdXJyZW50Um91bmRUcmlwVGltZScsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdsYXN0UGFja2V0UmVjZWl2ZWRUaW1lc3RhbXAnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAnbGFzdFBhY2tldFNlbnRUaW1lc3RhbXAnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAnbm9taW5hdGVkJywgdHlwZTogJ2Jvb2xlYW4nIH0sXG4gICAgeyBrZXk6ICdwcmlvcml0eScsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdyZWFkYWJsZScsIHR5cGU6ICdib29sZWFuJyB9LFxuICAgIHsga2V5OiAncmVxdWVzdHNSZWNlaXZlZCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdyZXF1ZXN0c1NlbnQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAncmVzcG9uc2VzUmVjZWl2ZWQnLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsga2V5OiAncmVzcG9uc2VzU2VudCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdyZXRyYW5zbWlzc2lvbnNSZWNlaXZlZCcsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICdyZXRyYW5zbWlzc2lvbnNTZW50JywgdHlwZTogJ251bWJlcicgfSxcbiAgICB7IGtleTogJ3N0YXRlJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICB7IGtleTogJ3RvdGFsUm91bmRUcmlwVGltZScsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgeyBrZXk6ICd0cmFuc3BvcnRJZCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgeyBrZXk6ICd3cml0YWJsZScsIHR5cGU6ICdib29sZWFuJyB9XG4gIF0ucmVkdWNlKGZ1bmN0aW9uKHJlcG9ydCwga2V5SW5mbykge1xuICAgIHJlcG9ydFtrZXlJbmZvLmtleV0gPSB0eXBlb2YgYWN0aXZlQ2FuZGlkYXRlUGFpclN0YXRzW2tleUluZm8ua2V5XSA9PT0ga2V5SW5mby50eXBlXG4gICAgICA/IGFjdGl2ZUNhbmRpZGF0ZVBhaXJTdGF0c1trZXlJbmZvLmtleV1cbiAgICAgIDogbnVsbDtcbiAgICByZXR1cm4gcmVwb3J0O1xuICB9LCB7XG4gICAgbG9jYWxDYW5kaWRhdGU6IHN0YW5kYXRkaXplZExvY2FsQ2FuZGlkYXRlU3RhdHNSZXBvcnQsXG4gICAgcmVtb3RlQ2FuZGlkYXRlOiBzdGFuZGFyZGl6ZWRSZW1vdGVDYW5kaWRhdGVTdGF0c1JlcG9ydFxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgbG9jYWwvcmVtb3RlIGF1ZGlvL3ZpZGVvIE1lZGlhU3RyZWFtVHJhY2tzLlxuICogQHBhcmFtIHtSVENQZWVyQ29ubmVjdGlvbn0gcGVlckNvbm5lY3Rpb24gLSBUaGUgUlRDUGVlckNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBraW5kIC0gJ2F1ZGlvJyBvciAndmlkZW8nXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xvY2FsT3JSZW1vdGVdIC0gJ2xvY2FsJyBvciAncmVtb3RlJ1xuICogQHJldHVybnMge0FycmF5PE1lZGlhU3RyZWFtVHJhY2s+fVxuICovXG5mdW5jdGlvbiBnZXRUcmFja3MocGVlckNvbm5lY3Rpb24sIGtpbmQsIGxvY2FsT3JSZW1vdGUpIHtcbiAgdmFyIGdldFNlbmRlcnNPclJlY2VpdmVycyA9IGxvY2FsT3JSZW1vdGUgPT09ICdsb2NhbCcgPyAnZ2V0U2VuZGVycycgOiAnZ2V0UmVjZWl2ZXJzJztcbiAgaWYgKHBlZXJDb25uZWN0aW9uW2dldFNlbmRlcnNPclJlY2VpdmVyc10pIHtcbiAgICByZXR1cm4gcGVlckNvbm5lY3Rpb25bZ2V0U2VuZGVyc09yUmVjZWl2ZXJzXSgpLm1hcChmdW5jdGlvbihzZW5kZXJPclJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gc2VuZGVyT3JSZWNlaXZlci50cmFjaztcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24odHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjayAmJiB0cmFjay5raW5kID09PSBraW5kO1xuICAgIH0pO1xuICB9XG4gIHZhciBnZXRTdHJlYW1zID0gbG9jYWxPclJlbW90ZSA9PT0gJ2xvY2FsJyA/ICdnZXRMb2NhbFN0cmVhbXMnIDogJ2dldFJlbW90ZVN0cmVhbXMnO1xuICByZXR1cm4gZmxhdE1hcChwZWVyQ29ubmVjdGlvbltnZXRTdHJlYW1zXSgpLCBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgZ2V0VHJhY2tzID0ga2luZCA9PT0gJ2F1ZGlvJyA/ICdnZXRBdWRpb1RyYWNrcycgOiAnZ2V0VmlkZW9UcmFja3MnO1xuICAgIHJldHVybiBzdHJlYW1bZ2V0VHJhY2tzXSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHN0YW5kYXJkaXplZCBzdGF0aXN0aWNzIGZvciBhIHBhcnRpY3VsYXIgTWVkaWFTdHJlYW1UcmFjay5cbiAqIEBwYXJhbSB7UlRDUGVlckNvbm5lY3Rpb259IHBlZXJDb25uZWN0aW9uXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gVXNlZCBmb3IgdGVzdGluZ1xuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5PFN0YW5kYXJkaXplZFRyYWNrU3RhdHNSZXBvcnQ+Pn1cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhY2tTdGF0cyhwZWVyQ29ubmVjdGlvbiwgdHJhY2ssIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLnRlc3RGb3JDaHJvbWUgIT09ICd1bmRlZmluZWQnIHx8IGlzQ2hyb21lKSB7XG4gICAgcmV0dXJuIGNocm9tZU9yU2FmYXJpR2V0VHJhY2tTdGF0cyhwZWVyQ29ubmVjdGlvbiwgdHJhY2spO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy50ZXN0Rm9yRmlyZWZveCAgIT09ICd1bmRlZmluZWQnIHx8IGlzRmlyZWZveCkge1xuICAgIHJldHVybiBmaXJlZm94R2V0VHJhY2tTdGF0cyhwZWVyQ29ubmVjdGlvbiwgdHJhY2ssIG9wdGlvbnMuaXNSZW1vdGUpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy50ZXN0Rm9yU2FmYXJpICAhPT0gJ3VuZGVmaW5lZCcgfHwgaXNTYWZhcmkpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudGVzdEZvclNhZmFyaSAgIT09ICd1bmRlZmluZWQnIHx8IGdldFNkcEZvcm1hdCgpID09PSAndW5pZmllZCcpIHtcbiAgICAgIHJldHVybiBjaHJvbWVPclNhZmFyaUdldFRyYWNrU3RhdHMocGVlckNvbm5lY3Rpb24sIHRyYWNrKTtcbiAgICB9XG4gICAgLy8gTk9URShzeWVycmFwcmFnYWRhKTogZ2V0U3RhdHMoKSBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gICAgLy8gU2FmYXJpIHZlcnNpb25zIHdoZXJlIHBsYW4tYiBpcyB0aGUgU0RQIGZvcm1hdFxuICAgIC8vIGR1ZSB0byB0aGlzIGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5MjYwMVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoW1xuICAgICAgJ2dldFN0YXRzKCkgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIHZlcnNpb24gb2YgU2FmYXJpJyxcbiAgICAgICdkdWUgdG8gdGhpcyBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xOTI2MDEnXG4gICAgXS5qb2luKCcgJykpKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdSVENQZWVyQ29ubmVjdGlvbiNnZXRTdGF0cygpIG5vdCBzdXBwb3J0ZWQnKSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzdGFuZGFyZGl6ZWQgc3RhdGlzdGljcyBmb3IgYSBwYXJ0aWN1bGFyIE1lZGlhU3RyZWFtVHJhY2sgaW4gQ2hyb21lIG9yIFNhZmFyaS5cbiAqIEBwYXJhbSB7UlRDUGVlckNvbm5lY3Rpb259IHBlZXJDb25uZWN0aW9uXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXk8U3RhbmRhcmRpemVkVHJhY2tTdGF0c1JlcG9ydD4+fVxuICovXG5mdW5jdGlvbiBjaHJvbWVPclNhZmFyaUdldFRyYWNrU3RhdHMocGVlckNvbm5lY3Rpb24sIHRyYWNrKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoY2hyb21lTWFqb3JWZXJzaW9uICYmIGNocm9tZU1ham9yVmVyc2lvbiA8IDY3KSB7XG4gICAgICBwZWVyQ29ubmVjdGlvbi5nZXRTdGF0cyhmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICByZXNvbHZlKFtzdGFuZGFyZGl6ZUNocm9tZUxlZ2FjeVN0YXRzKHJlc3BvbnNlLCB0cmFjayldKTtcbiAgICAgIH0sIG51bGwsIHJlamVjdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlZXJDb25uZWN0aW9uLmdldFN0YXRzKHRyYWNrKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICByZXNvbHZlKHN0YW5kYXJkaXplQ2hyb21lT3JTYWZhcmlTdGF0cyhyZXNwb25zZSkpO1xuICAgIH0sIHJlamVjdCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3RhbmRhcmRpemVkIHN0YXRpc3RpY3MgZm9yIGEgcGFydGljdWxhciBNZWRpYVN0cmVhbVRyYWNrIGluIEZpcmVmb3guXG4gKiBAcGFyYW0ge1JUQ1BlZXJDb25uZWN0aW9ufSBwZWVyQ29ubmVjdGlvblxuICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICogQHBhcmFtIHtib29sZWFufSBpc1JlbW90ZVxuICogQHJldHVybnMge1Byb21pc2UuPEFycmF5PFN0YW5kYXJkaXplZFRyYWNrU3RhdHNSZXBvcnQ+Pn1cbiAqL1xuZnVuY3Rpb24gZmlyZWZveEdldFRyYWNrU3RhdHMocGVlckNvbm5lY3Rpb24sIHRyYWNrLCBpc1JlbW90ZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcGVlckNvbm5lY3Rpb24uZ2V0U3RhdHModHJhY2spLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHJlc29sdmUoW3N0YW5kYXJkaXplRmlyZWZveFN0YXRzKHJlc3BvbnNlLCBpc1JlbW90ZSldKTtcbiAgICB9LCByZWplY3QpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZGl6ZSB0aGUgTWVkaWFTdHJlYW1UcmFjaydzIGxlZ2FjeSBzdGF0aXN0aWNzIGluIENocm9tZS5cbiAqIEBwYXJhbSB7UlRDU3RhdHNSZXNwb25zZX0gcmVzcG9uc2VcbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAqIEByZXR1cm5zIHtTdGFuZGFyZGl6ZWRUcmFja1N0YXRzUmVwb3J0fVxuICovXG5mdW5jdGlvbiBzdGFuZGFyZGl6ZUNocm9tZUxlZ2FjeVN0YXRzKHJlc3BvbnNlLCB0cmFjaykge1xuICB2YXIgc3NyY1JlcG9ydCA9IHJlc3BvbnNlLnJlc3VsdCgpLmZpbmQoZnVuY3Rpb24ocmVwb3J0KSB7XG4gICAgcmV0dXJuIHJlcG9ydC50eXBlID09PSAnc3NyYycgJiYgcmVwb3J0LnN0YXQoJ2dvb2dUcmFja0lkJykgPT09IHRyYWNrLmlkO1xuICB9KTtcblxuICB2YXIgc3RhbmRhcmRpemVkU3RhdHMgPSB7fTtcblxuICBpZiAoc3NyY1JlcG9ydCkge1xuICAgIHN0YW5kYXJkaXplZFN0YXRzLnRpbWVzdGFtcCA9IE1hdGgucm91bmQoTnVtYmVyKHNzcmNSZXBvcnQudGltZXN0YW1wKSk7XG4gICAgc3RhbmRhcmRpemVkU3RhdHMgPSBzc3JjUmVwb3J0Lm5hbWVzKCkucmVkdWNlKGZ1bmN0aW9uKHN0YXRzLCBuYW1lKSB7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSAnZ29vZ0NvZGVjTmFtZSc6XG4gICAgICAgICAgc3RhdHMuY29kZWNOYW1lID0gc3NyY1JlcG9ydC5zdGF0KG5hbWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdnb29nUnR0JzpcbiAgICAgICAgICBzdGF0cy5yb3VuZFRyaXBUaW1lID0gTnVtYmVyKHNzcmNSZXBvcnQuc3RhdChuYW1lKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2dvb2dKaXR0ZXJSZWNlaXZlZCc6XG4gICAgICAgICAgc3RhdHMuaml0dGVyID0gTnVtYmVyKHNzcmNSZXBvcnQuc3RhdChuYW1lKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2dvb2dGcmFtZVdpZHRoSW5wdXQnOlxuICAgICAgICAgIHN0YXRzLmZyYW1lV2lkdGhJbnB1dCA9IE51bWJlcihzc3JjUmVwb3J0LnN0YXQobmFtZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdnb29nRnJhbWVIZWlnaHRJbnB1dCc6XG4gICAgICAgICAgc3RhdHMuZnJhbWVIZWlnaHRJbnB1dCA9IE51bWJlcihzc3JjUmVwb3J0LnN0YXQobmFtZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdnb29nRnJhbWVXaWR0aFNlbnQnOlxuICAgICAgICAgIHN0YXRzLmZyYW1lV2lkdGhTZW50ID0gTnVtYmVyKHNzcmNSZXBvcnQuc3RhdChuYW1lKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2dvb2dGcmFtZUhlaWdodFNlbnQnOlxuICAgICAgICAgIHN0YXRzLmZyYW1lSGVpZ2h0U2VudCA9IE51bWJlcihzc3JjUmVwb3J0LnN0YXQobmFtZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdnb29nRnJhbWVXaWR0aFJlY2VpdmVkJzpcbiAgICAgICAgICBzdGF0cy5mcmFtZVdpZHRoUmVjZWl2ZWQgPSBOdW1iZXIoc3NyY1JlcG9ydC5zdGF0KG5hbWUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZ29vZ0ZyYW1lSGVpZ2h0UmVjZWl2ZWQnOlxuICAgICAgICAgIHN0YXRzLmZyYW1lSGVpZ2h0UmVjZWl2ZWQgPSBOdW1iZXIoc3NyY1JlcG9ydC5zdGF0KG5hbWUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZ29vZ0ZyYW1lUmF0ZUlucHV0JzpcbiAgICAgICAgICBzdGF0cy5mcmFtZVJhdGVJbnB1dCA9IE51bWJlcihzc3JjUmVwb3J0LnN0YXQobmFtZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdnb29nRnJhbWVSYXRlU2VudCc6XG4gICAgICAgICAgc3RhdHMuZnJhbWVSYXRlU2VudCA9IE51bWJlcihzc3JjUmVwb3J0LnN0YXQobmFtZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdnb29nRnJhbWVSYXRlUmVjZWl2ZWQnOlxuICAgICAgICAgIHN0YXRzLmZyYW1lUmF0ZVJlY2VpdmVkID0gTnVtYmVyKHNzcmNSZXBvcnQuc3RhdChuYW1lKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NzcmMnOlxuICAgICAgICAgIHN0YXRzW25hbWVdID0gc3NyY1JlcG9ydC5zdGF0KG5hbWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdieXRlc1JlY2VpdmVkJzpcbiAgICAgICAgY2FzZSAnYnl0ZXNTZW50JzpcbiAgICAgICAgY2FzZSAncGFja2V0c0xvc3QnOlxuICAgICAgICBjYXNlICdwYWNrZXRzUmVjZWl2ZWQnOlxuICAgICAgICBjYXNlICdwYWNrZXRzU2VudCc6XG4gICAgICAgIGNhc2UgJ2F1ZGlvSW5wdXRMZXZlbCc6XG4gICAgICAgIGNhc2UgJ2F1ZGlvT3V0cHV0TGV2ZWwnOlxuICAgICAgICAgIHN0YXRzW25hbWVdID0gTnVtYmVyKHNzcmNSZXBvcnQuc3RhdChuYW1lKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9LCBzdGFuZGFyZGl6ZWRTdGF0cyk7XG4gIH1cblxuICByZXR1cm4gc3RhbmRhcmRpemVkU3RhdHM7XG59XG5cbi8qKlxuICogU3RhbmRhcmRpemUgdGhlIE1lZGlhU3RyZWFtVHJhY2sncyBzdGF0aXN0aWNzIGluIENocm9tZSBvciBTYWZhcmkuXG4gKiBAcGFyYW0ge1JUQ1N0YXRzUmVzcG9uc2V9IHJlc3BvbnNlXG4gKiBAcmV0dXJucyB7QXJyYXk8U3RhbmRhcmRpemVkVHJhY2tTdGF0c1JlcG9ydD59XG4gKi9cbmZ1bmN0aW9uIHN0YW5kYXJkaXplQ2hyb21lT3JTYWZhcmlTdGF0cyhyZXNwb25zZSkge1xuICB2YXIgaW5ib3VuZCA9IG51bGw7XG5cbiAgLy8gTk9URShtcGF0d2FyZGhhbik6IFdlIHNob3VsZCBleHBlY3QgbW9yZSB0aGFuIG9uZSBcIm91dGJvdW5kLXJ0cFwiIHN0YXRzIGZvciBhXG4gIC8vIFZQOCBzaW11bGNhc3QgTWVkaWFTdHJlYW1UcmFjay5cbiAgdmFyIG91dGJvdW5kID0gW107XG5cbiAgdmFyIHJlbW90ZUluYm91bmQgPSBudWxsO1xuICB2YXIgcmVtb3RlT3V0Ym91bmQgPSBudWxsO1xuICB2YXIgdHJhY2sgPSBudWxsO1xuICB2YXIgY29kZWMgPSBudWxsO1xuXG4gIHJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24oc3RhdCkge1xuICAgIHN3aXRjaCAoc3RhdC50eXBlKSB7XG4gICAgICBjYXNlICdpbmJvdW5kLXJ0cCc6XG4gICAgICAgIGluYm91bmQgPSBzdGF0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ291dGJvdW5kLXJ0cCc6XG4gICAgICAgIG91dGJvdW5kLnB1c2goc3RhdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndHJhY2snOlxuICAgICAgICB0cmFjayA9IHN0YXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29kZWMnOlxuICAgICAgICBjb2RlYyA9IHN0YXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVtb3RlLWluYm91bmQtcnRwJzpcbiAgICAgICAgcmVtb3RlSW5ib3VuZCA9IHN0YXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVtb3RlLW91dGJvdW5kLXJ0cCc6XG4gICAgICAgIHJlbW90ZU91dGJvdW5kID0gc3RhdDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcblxuICB2YXIgaXNSZW1vdGUgPSB0cmFjayAmJiB0cmFjay5yZW1vdGVTb3VyY2U7XG4gIHZhciBtYWluU291cmNlcyA9IGlzUmVtb3RlID8gW2luYm91bmRdIDogb3V0Ym91bmQ7XG4gIHZhciBzdGF0cyA9IFtdO1xuICB2YXIgcmVtb3RlU291cmNlID0gaXNSZW1vdGUgPyByZW1vdGVPdXRib3VuZCA6IHJlbW90ZUluYm91bmQ7IC8vIHJlbW90ZSBydHAgc3RhdHNcblxuICBtYWluU291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHZhciBzdGFuZGFyZGl6ZWRTdGF0cyA9IHt9O1xuICAgIHZhciBzdGF0U291cmNlcyA9IFtcbiAgICAgIHNvdXJjZSwgLy8gbG9jYWwgcnRwIHN0YXRzXG4gICAgICB0cmFjayxcbiAgICAgIGNvZGVjLFxuICAgICAgcmVtb3RlU291cmNlICYmIHJlbW90ZVNvdXJjZS5zc3JjID09PSBzb3VyY2Uuc3NyYyA/IHJlbW90ZVNvdXJjZSA6IG51bGwsIC8vIHJlbW90ZSBydHAgc3RhdHNcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gZ2V0U3RhdFZhbHVlKG5hbWUpIHtcbiAgICAgIHZhciBzb3VyY2VGb3VuZCA9IHN0YXRTb3VyY2VzLmZpbmQoZnVuY3Rpb24oc3RhdFNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc3RhdFNvdXJjZSAmJiB0eXBlb2Ygc3RhdFNvdXJjZVtuYW1lXSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICB9KSB8fCBudWxsO1xuXG4gICAgICByZXR1cm4gc291cmNlRm91bmQgPyBzb3VyY2VGb3VuZFtuYW1lXSA6IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHNzcmMgPSBnZXRTdGF0VmFsdWUoJ3NzcmMnKTtcbiAgICBpZiAodHlwZW9mIHNzcmMgPT09ICdudW1iZXInKSB7XG4gICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5zc3JjID0gU3RyaW5nKHNzcmMpO1xuICAgIH1cblxuICAgIHZhciB0aW1lc3RhbXAgPSBnZXRTdGF0VmFsdWUoJ3RpbWVzdGFtcCcpO1xuICAgIHN0YW5kYXJkaXplZFN0YXRzLnRpbWVzdGFtcCA9IE1hdGgucm91bmQodGltZXN0YW1wKTtcblxuICAgIHZhciBtaW1lVHlwZSA9IGdldFN0YXRWYWx1ZSgnbWltZVR5cGUnKTtcbiAgICBpZiAodHlwZW9mIG1pbWVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgbWltZVR5cGUgPSBtaW1lVHlwZS5zcGxpdCgnLycpO1xuICAgICAgc3RhbmRhcmRpemVkU3RhdHMuY29kZWNOYW1lID0gbWltZVR5cGVbbWltZVR5cGUubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kVHJpcFRpbWUgPSBnZXRTdGF0VmFsdWUoJ3JvdW5kVHJpcFRpbWUnKTtcbiAgICBpZiAodHlwZW9mIHJvdW5kVHJpcFRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5yb3VuZFRyaXBUaW1lID0gTWF0aC5yb3VuZChyb3VuZFRyaXBUaW1lICogMTAwMCk7XG4gICAgfVxuXG4gICAgdmFyIGppdHRlciA9IGdldFN0YXRWYWx1ZSgnaml0dGVyJyk7XG4gICAgaWYgKHR5cGVvZiBqaXR0ZXIgPT09ICdudW1iZXInKSB7XG4gICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5qaXR0ZXIgPSBNYXRoLnJvdW5kKGppdHRlciAqIDEwMDApO1xuICAgIH1cblxuICAgIHZhciBmcmFtZVdpZHRoID0gZ2V0U3RhdFZhbHVlKCdmcmFtZVdpZHRoJyk7XG4gICAgaWYgKHR5cGVvZiBmcmFtZVdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzUmVtb3RlKSB7XG4gICAgICAgIHN0YW5kYXJkaXplZFN0YXRzLmZyYW1lV2lkdGhSZWNlaXZlZCA9IGZyYW1lV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5mcmFtZVdpZHRoU2VudCA9IGZyYW1lV2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lSGVpZ2h0ID0gZ2V0U3RhdFZhbHVlKCdmcmFtZUhlaWdodCcpO1xuICAgIGlmICh0eXBlb2YgZnJhbWVIZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNSZW1vdGUpIHtcbiAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMuZnJhbWVIZWlnaHRSZWNlaXZlZCA9IGZyYW1lSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMuZnJhbWVIZWlnaHRTZW50ID0gZnJhbWVIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lc1BlclNlY29uZCA9IGdldFN0YXRWYWx1ZSgnZnJhbWVzUGVyU2Vjb25kJyk7XG4gICAgaWYgKHR5cGVvZiBmcmFtZXNQZXJTZWNvbmQgPT09ICdudW1iZXInKSB7XG4gICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5mcmFtZVJhdGVTZW50ID0gZnJhbWVzUGVyU2Vjb25kO1xuICAgIH1cblxuICAgIHZhciBieXRlc1JlY2VpdmVkID0gZ2V0U3RhdFZhbHVlKCdieXRlc1JlY2VpdmVkJyk7XG4gICAgaWYgKHR5cGVvZiBieXRlc1JlY2VpdmVkID09PSAnbnVtYmVyJykge1xuICAgICAgc3RhbmRhcmRpemVkU3RhdHMuYnl0ZXNSZWNlaXZlZCA9IGJ5dGVzUmVjZWl2ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGJ5dGVzU2VudCA9IGdldFN0YXRWYWx1ZSgnYnl0ZXNTZW50Jyk7XG4gICAgaWYgKHR5cGVvZiBieXRlc1NlbnQgPT09ICdudW1iZXInKSB7XG4gICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5ieXRlc1NlbnQgPSBieXRlc1NlbnQ7XG4gICAgfVxuXG4gICAgdmFyIHBhY2tldHNMb3N0ID0gZ2V0U3RhdFZhbHVlKCdwYWNrZXRzTG9zdCcpO1xuICAgIGlmICh0eXBlb2YgcGFja2V0c0xvc3QgPT09ICdudW1iZXInKSB7XG4gICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5wYWNrZXRzTG9zdCA9IHBhY2tldHNMb3N0O1xuICAgIH1cblxuICAgIHZhciBwYWNrZXRzUmVjZWl2ZWQgPSBnZXRTdGF0VmFsdWUoJ3BhY2tldHNSZWNlaXZlZCcpO1xuICAgIGlmICh0eXBlb2YgcGFja2V0c1JlY2VpdmVkID09PSAnbnVtYmVyJykge1xuICAgICAgc3RhbmRhcmRpemVkU3RhdHMucGFja2V0c1JlY2VpdmVkID0gcGFja2V0c1JlY2VpdmVkO1xuICAgIH1cblxuICAgIHZhciBwYWNrZXRzU2VudCA9IGdldFN0YXRWYWx1ZSgncGFja2V0c1NlbnQnKTtcbiAgICBpZiAodHlwZW9mIHBhY2tldHNTZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgc3RhbmRhcmRpemVkU3RhdHMucGFja2V0c1NlbnQgPSBwYWNrZXRzU2VudDtcbiAgICB9XG5cbiAgICB2YXIgYXVkaW9MZXZlbCA9IGdldFN0YXRWYWx1ZSgnYXVkaW9MZXZlbCcpO1xuICAgIGlmICh0eXBlb2YgYXVkaW9MZXZlbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGF1ZGlvTGV2ZWwgPSBNYXRoLnJvdW5kKGF1ZGlvTGV2ZWwgKiBDSFJPTUVfTEVHQUNZX01BWF9BVURJT19MRVZFTCk7XG4gICAgICBpZiAoaXNSZW1vdGUpIHtcbiAgICAgICAgc3RhbmRhcmRpemVkU3RhdHMuYXVkaW9PdXRwdXRMZXZlbCA9IGF1ZGlvTGV2ZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5hdWRpb0lucHV0TGV2ZWwgPSBhdWRpb0xldmVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0b3RhbFBhY2tldFNlbmREYWxheSA9IGdldFN0YXRWYWx1ZSgndG90YWxQYWNrZXRTZW5kRGVsYXknKTtcbiAgICBpZiAodHlwZW9mIHRvdGFsUGFja2V0U2VuZERhbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgc3RhbmRhcmRpemVkU3RhdHMudG90YWxQYWNrZXRTZW5kRGVsYXkgPSB0b3RhbFBhY2tldFNlbmREYWxheTtcbiAgICB9XG5cbiAgICB2YXIgdG90YWxFbmNvZGVUaW1lID0gZ2V0U3RhdFZhbHVlKCd0b3RhbEVuY29kZVRpbWUnKTtcbiAgICBpZiAodHlwZW9mIHRvdGFsRW5jb2RlVGltZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHN0YW5kYXJkaXplZFN0YXRzLnRvdGFsRW5jb2RlVGltZSA9IHRvdGFsRW5jb2RlVGltZTtcbiAgICB9XG5cbiAgICB2YXIgZnJhbWVzRW5jb2RlZCA9IGdldFN0YXRWYWx1ZSgnZnJhbWVzRW5jb2RlZCcpO1xuICAgIGlmICh0eXBlb2YgZnJhbWVzRW5jb2RlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHN0YW5kYXJkaXplZFN0YXRzLmZyYW1lc0VuY29kZWQgPSBmcmFtZXNFbmNvZGVkO1xuICAgIH1cblxuICAgIHZhciBlc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wID0gZ2V0U3RhdFZhbHVlKCdlc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wJyk7XG4gICAgaWYgKHR5cGVvZiBlc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wID09PSAnbnVtYmVyJykge1xuICAgICAgc3RhbmRhcmRpemVkU3RhdHMuZXN0aW1hdGVkUGxheW91dFRpbWVzdGFtcCA9IGVzdGltYXRlZFBsYXlvdXRUaW1lc3RhbXA7XG4gICAgfVxuXG4gICAgdmFyIHRvdGFsRGVjb2RlVGltZSA9IGdldFN0YXRWYWx1ZSgndG90YWxEZWNvZGVUaW1lJyk7XG4gICAgaWYgKHR5cGVvZiB0b3RhbERlY29kZVRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgICBzdGFuZGFyZGl6ZWRTdGF0cy50b3RhbERlY29kZVRpbWUgPSB0b3RhbERlY29kZVRpbWU7XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lc0RlY29kZWQgPSBnZXRTdGF0VmFsdWUoJ2ZyYW1lc0RlY29kZWQnKTtcbiAgICBpZiAodHlwZW9mIGZyYW1lc0RlY29kZWQgPT09ICdudW1iZXInKSB7XG4gICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5mcmFtZXNEZWNvZGVkID0gZnJhbWVzRGVjb2RlZDtcbiAgICB9XG5cbiAgICB2YXIgaml0dGVyQnVmZmVyRGVsYXkgPSBnZXRTdGF0VmFsdWUoJ2ppdHRlckJ1ZmZlckRlbGF5Jyk7XG4gICAgaWYgKHR5cGVvZiBqaXR0ZXJCdWZmZXJEZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHN0YW5kYXJkaXplZFN0YXRzLmppdHRlckJ1ZmZlckRlbGF5ID0gaml0dGVyQnVmZmVyRGVsYXk7XG4gICAgfVxuXG4gICAgdmFyIGppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudCA9IGdldFN0YXRWYWx1ZSgnaml0dGVyQnVmZmVyRW1pdHRlZENvdW50Jyk7XG4gICAgaWYgKHR5cGVvZiBqaXR0ZXJCdWZmZXJFbWl0dGVkQ291bnQgPT09ICdudW1iZXInKSB7XG4gICAgICBzdGFuZGFyZGl6ZWRTdGF0cy5qaXR0ZXJCdWZmZXJFbWl0dGVkQ291bnQgPSBqaXR0ZXJCdWZmZXJFbWl0dGVkQ291bnQ7XG4gICAgfVxuXG4gICAgc3RhdHMucHVzaChzdGFuZGFyZGl6ZWRTdGF0cyk7XG4gIH0pO1xuXG4gIHJldHVybiBzdGF0cztcbn1cblxuLyoqXG4gKiBTdGFuZGFyZGl6ZSB0aGUgTWVkaWFTdHJlYW1UcmFjaydzIHN0YXRpc3RpY3MgaW4gRmlyZWZveC5cbiAqIEBwYXJhbSB7UlRDU3RhdHNSZXBvcnR9IHJlc3BvbnNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzUmVtb3RlXG4gKiBAcmV0dXJucyB7U3RhbmRhcmRpemVkVHJhY2tTdGF0c1JlcG9ydH1cbiAqL1xuZnVuY3Rpb24gc3RhbmRhcmRpemVGaXJlZm94U3RhdHMocmVzcG9uc2UsIGlzUmVtb3RlKSB7XG4gIC8vIE5PVEUobXJvYmVydHMpOiBJZiBnZXRTdGF0cyBpcyBjYWxsZWQgb24gYSBjbG9zZWQgUlRDUGVlckNvbm5lY3Rpb24sXG4gIC8vIEZpcmVmb3ggcmV0dXJucyB1bmRlZmluZWQgaW5zdGVhZCBvZiBhbiBSVENTdGF0c1JlcG9ydC4gV2Ugd29ya2Fyb3VuZCB0aGlzXG4gIC8vIGhlcmUuIFNlZSB0aGUgZm9sbG93aW5nIGJ1ZyBmb3IgbW9yZSBkZXRhaWxzOlxuICAvL1xuICAvLyAgIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzcyMjVcbiAgLy9cbiAgcmVzcG9uc2UgPSByZXNwb25zZSB8fCBuZXcgTWFwKCk7XG5cbiAgdmFyIGluYm91bmQgPSBudWxsO1xuICB2YXIgb3V0Ym91bmQgPSBudWxsO1xuXG4gIC8vIE5PVEUobW1hbGF2YWxsaSk6IFN0YXJ0aW5nIGZyb20gRmlyZWZveCA2MywgUlRDe0luYm91bmQsIE91dGJvdW5kfVJUUFN0cmVhbVN0YXRzLmlzUmVtb3RlXG4gIC8vIHdpbGwgYmUgZGVwcmVjYXRlZCwgZm9sbG93ZWQgYnkgaXRzIHJlbW92YWwgaW4gRmlyZWZveCA2Ni4gQWxzbywgdHJ5aW5nIHRvXG4gIC8vIGFjY2VzcyBtZW1iZXJzIG9mIHRoZSByZW1vdGUgUlRDe0luYm91bmQsIE91dGJvdW5kfVJUUFN0cmVhbVN0YXRzIHdpdGhvdXRcbiAgLy8gdXNpbmcgUlRDU3RhdHNSZXBvcnQuZ2V0KHJlbW90ZUlkKSB3aWxsIHRyaWdnZXIgY29uc29sZSB3YXJuaW5ncy4gU28sIHdlXG4gIC8vIG5vIGxvbmdlciBkZXBlbmQgb24gXCJpc1JlbW90ZVwiLCBhbmQgd2UgY2FsbCBSVENTdGF0c1JlcG9ydC5nZXQocmVtb3RlSWQpXG4gIC8vIHRvIGFjY2VzcyB0aGUgcmVtb3RlIFJUQ3tJbmJvdW5kLCBPdXRib3VuZH1SVFBTdHJlYW1TdGF0cy5cbiAgLy9cbiAgLy8gU291cmNlOiBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2VicnRjL2dldHN0YXRzLWlzcmVtb3RlLTY1L1xuICAvL1xuICByZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uKHN0YXQpIHtcbiAgICBpZiAoc3RhdC5pc1JlbW90ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0YXQudHlwZSkge1xuICAgICAgY2FzZSAnaW5ib3VuZC1ydHAnOlxuICAgICAgICBpbmJvdW5kID0gc3RhdDtcbiAgICAgICAgb3V0Ym91bmQgPSByZXNwb25zZS5nZXQoc3RhdC5yZW1vdGVJZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3V0Ym91bmQtcnRwJzpcbiAgICAgICAgb3V0Ym91bmQgPSBzdGF0O1xuICAgICAgICBpbmJvdW5kID0gcmVzcG9uc2UuZ2V0KHN0YXQucmVtb3RlSWQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBmaXJzdCA9IGlzUmVtb3RlID8gaW5ib3VuZCA6IG91dGJvdW5kO1xuICB2YXIgc2Vjb25kID0gaXNSZW1vdGUgPyBvdXRib3VuZCA6IGluYm91bmQ7XG5cbiAgZnVuY3Rpb24gZ2V0U3RhdFZhbHVlKG5hbWUpIHtcbiAgICBpZiAoZmlyc3QgJiYgdHlwZW9mIGZpcnN0W25hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZpcnN0W25hbWVdO1xuICAgIH1cbiAgICBpZiAoc2Vjb25kICYmIHR5cGVvZiBzZWNvbmRbbmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gc2Vjb25kW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzdGFuZGFyZGl6ZWRTdGF0cyA9IHt9O1xuICB2YXIgdGltZXN0YW1wID0gZ2V0U3RhdFZhbHVlKCd0aW1lc3RhbXAnKTtcbiAgc3RhbmRhcmRpemVkU3RhdHMudGltZXN0YW1wID0gTWF0aC5yb3VuZCh0aW1lc3RhbXApO1xuXG4gIHZhciBzc3JjID0gZ2V0U3RhdFZhbHVlKCdzc3JjJyk7XG4gIGlmICh0eXBlb2Ygc3NyYyA9PT0gJ251bWJlcicpIHtcbiAgICBzdGFuZGFyZGl6ZWRTdGF0cy5zc3JjID0gU3RyaW5nKHNzcmMpO1xuICB9XG5cbiAgdmFyIGJ5dGVzU2VudCA9IGdldFN0YXRWYWx1ZSgnYnl0ZXNTZW50Jyk7XG4gIGlmICh0eXBlb2YgYnl0ZXNTZW50ID09PSAnbnVtYmVyJykge1xuICAgIHN0YW5kYXJkaXplZFN0YXRzLmJ5dGVzU2VudCA9IGJ5dGVzU2VudDtcbiAgfVxuXG4gIHZhciBwYWNrZXRzTG9zdCA9IGdldFN0YXRWYWx1ZSgncGFja2V0c0xvc3QnKTtcbiAgaWYgKHR5cGVvZiBwYWNrZXRzTG9zdCA9PT0gJ251bWJlcicpIHtcbiAgICBzdGFuZGFyZGl6ZWRTdGF0cy5wYWNrZXRzTG9zdCA9IHBhY2tldHNMb3N0O1xuICB9XG5cbiAgdmFyIHBhY2tldHNTZW50ID0gZ2V0U3RhdFZhbHVlKCdwYWNrZXRzU2VudCcpO1xuICBpZiAodHlwZW9mIHBhY2tldHNTZW50ID09PSAnbnVtYmVyJykge1xuICAgIHN0YW5kYXJkaXplZFN0YXRzLnBhY2tldHNTZW50ID0gcGFja2V0c1NlbnQ7XG4gIH1cblxuICB2YXIgcm91bmRUcmlwVGltZSA9IGdldFN0YXRWYWx1ZSgncm91bmRUcmlwVGltZScpO1xuICBpZiAodHlwZW9mIHJvdW5kVHJpcFRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgLy8gcm91bmRUcmlwVGltZSBpcyBkb3VibGUgLSBtZWFzdXJlZCBpbiBzZWNvbmRzLlxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJydGMtc3RhdHMvI2RvbS1ydGNyZW1vdGVpbmJvdW5kcnRwc3RyZWFtc3RhdHMtcm91bmR0cmlwdGltZVxuICAgIC8vIGNvdmVyIGl0IHRvIG1pbGxpc2Vjb25kcyAoYW5kIG1ha2UgaXQgaW50ZWdlcilcbiAgICBzdGFuZGFyZGl6ZWRTdGF0cy5yb3VuZFRyaXBUaW1lID0gTWF0aC5yb3VuZChyb3VuZFRyaXBUaW1lICogMTAwMCk7XG4gIH1cblxuICB2YXIgaml0dGVyID0gZ2V0U3RhdFZhbHVlKCdqaXR0ZXInKTtcbiAgaWYgKHR5cGVvZiBqaXR0ZXIgPT09ICdudW1iZXInKSB7XG4gICAgc3RhbmRhcmRpemVkU3RhdHMuaml0dGVyID0gTWF0aC5yb3VuZChqaXR0ZXIgKiAxMDAwKTtcbiAgfVxuXG4gIHZhciBmcmFtZVJhdGVTZW50ID0gZ2V0U3RhdFZhbHVlKCdmcmFtZXJhdGVNZWFuJyk7XG4gIGlmICh0eXBlb2YgZnJhbWVSYXRlU2VudCA9PT0gJ251bWJlcicpIHtcbiAgICBzdGFuZGFyZGl6ZWRTdGF0cy5mcmFtZVJhdGVTZW50ID0gTWF0aC5yb3VuZChmcmFtZVJhdGVTZW50KTtcbiAgfVxuXG4gIHZhciBieXRlc1JlY2VpdmVkID0gZ2V0U3RhdFZhbHVlKCdieXRlc1JlY2VpdmVkJyk7XG4gIGlmICh0eXBlb2YgYnl0ZXNSZWNlaXZlZCA9PT0gJ251bWJlcicpIHtcbiAgICBzdGFuZGFyZGl6ZWRTdGF0cy5ieXRlc1JlY2VpdmVkID0gYnl0ZXNSZWNlaXZlZDtcbiAgfVxuXG4gIHZhciBwYWNrZXRzUmVjZWl2ZWQgPSBnZXRTdGF0VmFsdWUoJ3BhY2tldHNSZWNlaXZlZCcpO1xuICBpZiAodHlwZW9mIHBhY2tldHNSZWNlaXZlZCA9PT0gJ251bWJlcicpIHtcbiAgICBzdGFuZGFyZGl6ZWRTdGF0cy5wYWNrZXRzUmVjZWl2ZWQgPSBwYWNrZXRzUmVjZWl2ZWQ7XG4gIH1cblxuICB2YXIgZnJhbWVSYXRlUmVjZWl2ZWQgPSBnZXRTdGF0VmFsdWUoJ2ZyYW1lcmF0ZU1lYW4nKTtcbiAgaWYgKHR5cGVvZiBmcmFtZVJhdGVSZWNlaXZlZCA9PT0gJ251bWJlcicpIHtcbiAgICBzdGFuZGFyZGl6ZWRTdGF0cy5mcmFtZVJhdGVSZWNlaXZlZCA9IE1hdGgucm91bmQoZnJhbWVSYXRlUmVjZWl2ZWQpO1xuICB9XG5cbiAgdmFyIHRvdGFsUGFja2V0U2VuZERhbGF5ID0gZ2V0U3RhdFZhbHVlKCd0b3RhbFBhY2tldFNlbmREZWxheScpO1xuICBpZiAodHlwZW9mIHRvdGFsUGFja2V0U2VuZERhbGF5ID09PSAnbnVtYmVyJykge1xuICAgIHN0YW5kYXJkaXplZFN0YXRzLnRvdGFsUGFja2V0U2VuZERlbGF5ID0gdG90YWxQYWNrZXRTZW5kRGFsYXk7XG4gIH1cblxuICB2YXIgdG90YWxFbmNvZGVUaW1lID0gZ2V0U3RhdFZhbHVlKCd0b3RhbEVuY29kZVRpbWUnKTtcbiAgaWYgKHR5cGVvZiB0b3RhbEVuY29kZVRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgc3RhbmRhcmRpemVkU3RhdHMudG90YWxFbmNvZGVUaW1lID0gdG90YWxFbmNvZGVUaW1lO1xuICB9XG5cbiAgdmFyIGZyYW1lc0VuY29kZWQgPSBnZXRTdGF0VmFsdWUoJ2ZyYW1lc0VuY29kZWQnKTtcbiAgaWYgKHR5cGVvZiBmcmFtZXNFbmNvZGVkID09PSAnbnVtYmVyJykge1xuICAgIHN0YW5kYXJkaXplZFN0YXRzLmZyYW1lc0VuY29kZWQgPSBmcmFtZXNFbmNvZGVkO1xuICB9XG5cbiAgdmFyIGVzdGltYXRlZFBsYXlvdXRUaW1lc3RhbXAgPSBnZXRTdGF0VmFsdWUoJ2VzdGltYXRlZFBsYXlvdXRUaW1lc3RhbXAnKTtcbiAgaWYgKHR5cGVvZiBlc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wID09PSAnbnVtYmVyJykge1xuICAgIHN0YW5kYXJkaXplZFN0YXRzLmVzdGltYXRlZFBsYXlvdXRUaW1lc3RhbXAgPSBlc3RpbWF0ZWRQbGF5b3V0VGltZXN0YW1wO1xuICB9XG5cbiAgdmFyIHRvdGFsRGVjb2RlVGltZSA9IGdldFN0YXRWYWx1ZSgndG90YWxEZWNvZGVUaW1lJyk7XG4gIGlmICh0eXBlb2YgdG90YWxEZWNvZGVUaW1lID09PSAnbnVtYmVyJykge1xuICAgIHN0YW5kYXJkaXplZFN0YXRzLnRvdGFsRGVjb2RlVGltZSA9IHRvdGFsRGVjb2RlVGltZTtcbiAgfVxuXG4gIHZhciBmcmFtZXNEZWNvZGVkID0gZ2V0U3RhdFZhbHVlKCdmcmFtZXNEZWNvZGVkJyk7XG4gIGlmICh0eXBlb2YgZnJhbWVzRGVjb2RlZCA9PT0gJ251bWJlcicpIHtcbiAgICBzdGFuZGFyZGl6ZWRTdGF0cy5mcmFtZXNEZWNvZGVkID0gZnJhbWVzRGVjb2RlZDtcbiAgfVxuXG4gIHZhciBqaXR0ZXJCdWZmZXJEZWxheSA9IGdldFN0YXRWYWx1ZSgnaml0dGVyQnVmZmVyRGVsYXknKTtcbiAgaWYgKHR5cGVvZiBqaXR0ZXJCdWZmZXJEZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICBzdGFuZGFyZGl6ZWRTdGF0cy5qaXR0ZXJCdWZmZXJEZWxheSA9IGppdHRlckJ1ZmZlckRlbGF5O1xuICB9XG5cbiAgdmFyIGppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudCA9IGdldFN0YXRWYWx1ZSgnaml0dGVyQnVmZmVyRW1pdHRlZENvdW50Jyk7XG4gIGlmICh0eXBlb2Ygaml0dGVyQnVmZmVyRW1pdHRlZENvdW50ID09PSAnbnVtYmVyJykge1xuICAgIHN0YW5kYXJkaXplZFN0YXRzLmppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudCA9IGppdHRlckJ1ZmZlckVtaXR0ZWRDb3VudDtcbiAgfVxuXG4gIHJldHVybiBzdGFuZGFyZGl6ZWRTdGF0cztcbn1cblxuLyoqXG4gKiBTdGFuZGFyZGl6ZWQgUlRDSWNlQ2FuZGlkYXRlIHN0YXRpc3RpY3MuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTdGFuZGFyZGl6ZWRJY2VDYW5kaWRhdGVTdGF0c1JlcG9ydFxuICogQHByb3BlcnR5IHsnaG9zdCd8J3ByZmx4J3wncmVsYXknfCdzcmZseCd9IGNhbmRpZGF0ZVR5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpcFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBvcnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcmlvcml0eVxuICogQHByb3BlcnR5IHsndGNwJ3wndWRwJ30gcHJvdG9jb2xcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmxcbiAqL1xuXG4vKipcbiAqIFN0YW5kYXJkaXplZCBsb2NhbCBSVENJY2VDYW5kaWRhdGUgc3RhdGlzdGljcy5cbiAqIEB0eXBlZGVmIHtTdGFuZGFyZGl6ZWRJY2VDYW5kaWRhdGVTdGF0c1JlcG9ydH0gU3RhbmRhcmRpemVkTG9jYWxJY2VDYW5kaWRhdGVTdGF0c1JlcG9ydFxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVsZXRlZD1mYWxzZV1cbiAqIEBwcm9wZXJ0eSB7J3RjcCd8J3Rscyd8J3VkcCd9IHJlbGF5UHJvdG9jb2xcbiAqL1xuXG4vKipcbiAqIFN0YW5kYXJkaXplZCBhY3RpdmUgUlRDSWNlQ2FuZGlkYXRlIHBhaXIgc3RhdGlzdGljcy5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IFN0YW5kYXJkaXplZEFjdGl2ZUljZUNhbmRpZGF0ZVBhaXJTdGF0c1JlcG9ydFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGF2YWlsYWJsZUluY29taW5nQml0cmF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGF2YWlsYWJsZU91dGdvaW5nQml0cmF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJ5dGVzUmVjZWl2ZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBieXRlc1NlbnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb25zZW50UmVxdWVzdHNTZW50XG4gKiBAcHJvcGVydHkge251bWJlcn0gY3VycmVudFJvdW5kVHJpcFRpbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0UGFja2V0UmVjZWl2ZWRUaW1lc3RhbXBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0UGFja2V0U2VudFRpbWVzdGFtcFxuICogQHByb3BlcnR5IHtTdGFuZGFyZGl6ZWRMb2NhbEljZUNhbmRpZGF0ZVN0YXRzUmVwb3J0fSBsb2NhbENhbmRpZGF0ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBub21pbmF0ZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcmlvcml0eVxuICogQHByb3BlcnR5IHtib29sZWFufSByZWFkYWJsZVxuICogQHByb3BlcnR5IHtTdGFuZGFyZGl6ZWRJY2VDYW5kaWRhdGVTdGF0c1JlcG9ydH0gcmVtb3RlQ2FuZGlkYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmVxdWVzdHNSZWNlaXZlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlcXVlc3RzU2VudFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlc3BvbnNlc1JlY2VpdmVkXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmVzcG9uc2VzU2VudFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJldHJhbnNtaXNzaW9uc1JlY2VpdmVkXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmV0cmFuc21pc3Npb25zU2VudFxuICogQHByb3BlcnR5IHsnZnJvemVuJ3wnd2FpdGluZyd8J2luLXByb2dyZXNzJ3wnZmFpbGVkJ3wnc3VjY2VlZGVkJ30gc3RhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3RhbFJvdW5kVHJpcFRpbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0cmFuc3BvcnRJZFxuICogQHByb3BlcnR5IHtib29sZWFufSB3cml0YWJsZVxuICovXG5cbi8qKlxuICogU3RhbmRhcmRpemVkIHtAbGluayBSVENQZWVyQ29ubmVjdGlvbn0gc3RhdGlzdGljcy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YW5kYXJkaXplZFN0YXRzUmVzcG9uc2VcbiAqIEBwcm9wZXJ0eSB7U3RhbmRhcmRpemVkQWN0aXZlSWNlQ2FuZGlkYXRlUGFpclN0YXRzUmVwb3J0fSBhY3RpdmVJY2VDYW5kaWRhdGVQYWlyIC0gU3RhdHMgZm9yIGFjdGl2ZSBJQ0UgY2FuZGlkYXRlIHBhaXJcbiAqIEBwcm9wZXJ0eSBBcnJheTxTdGFuZGFyZGl6ZWRUcmFja1N0YXRzUmVwb3J0PiBsb2NhbEF1ZGlvVHJhY2tTdGF0cyAtIFN0YXRzIGZvciBsb2NhbCBhdWRpbyBNZWRpYVN0cmVhbVRyYWNrc1xuICogQHByb3BlcnR5IEFycmF5PFN0YW5kYXJkaXplZFRyYWNrU3RhdHNSZXBvcnQ+IGxvY2FsVmlkZW9UcmFja1N0YXRzIC0gU3RhdHMgZm9yIGxvY2FsIHZpZGVvIE1lZGlhU3RyZWFtVHJhY2tzXG4gKiBAcHJvcGVydHkgQXJyYXk8U3RhbmRhcmRpemVkVHJhY2tTdGF0c1JlcG9ydD4gcmVtb3RlQXVkaW9UcmFja1N0YXRzIC0gU3RhdHMgZm9yIHJlbW90ZSBhdWRpbyBNZWRpYVN0cmVhbVRyYWNrc1xuICogQHByb3BlcnR5IEFycmF5PFN0YW5kYXJkaXplZFRyYWNrU3RhdHNSZXBvcnQ+IHJlbW90ZVZpZGVvVHJhY2tTdGF0cyAtIFN0YXRzIGZvciByZW1vdGUgdmlkZW8gTWVkaWFTdHJlYW1UcmFja3NcbiAqL1xuXG4vKipcbiAqIFN0YW5kYXJkaXplZCBNZWRpYVN0cmVhbVRyYWNrIHN0YXRpc3RpY3MuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGFuZGFyZGl6ZWRUcmFja1N0YXRzUmVwb3J0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHJhY2tJZCAtIE1lZGlhU3RyZWFtVHJhY2sgSURcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzc3JjIC0gU1NSQyBvZiB0aGUgTWVkaWFTdHJlYW1UcmFja1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVzdGFtcCAtIFRoZSBVbml4IHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29kZWNOYW1lXSAtIE5hbWUgb2YgdGhlIGNvZGVjIHVzZWQgdG8gZW5jb2RlIHRoZSBNZWRpYVN0cmVhbVRyYWNrJ3MgbWVkaWFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm91bmRUcmlwVGltZV0gLSBSb3VuZCB0cmlwIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ppdHRlcl0gLSBKaXR0ZXIgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZyYW1lV2lkdGhJbnB1dF0gLSBXaWR0aCBpbiBwaXhlbHMgb2YgdGhlIGxvY2FsIHZpZGVvIE1lZGlhU3RyZWFtVHJhY2sncyBjYXB0dXJlZCBmcmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmcmFtZUhlaWdodElucHV0XSAtIEhlaWdodCBpbiBwaXhlbHMgb2YgdGhlIGxvY2FsIHZpZGVvIE1lZGlhU3RyZWFtVHJhY2sncyBjYXB0dXJlZCBmcmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmcmFtZVdpZHRoU2VudF0gLSBXaWR0aCBpbiBwaXhlbHMgb2YgdGhlIGxvY2FsIHZpZGVvIE1lZGlhU3RyZWFtVHJhY2sncyBlbmNvZGVkIGZyYW1lXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZyYW1lSGVpZ2h0U2VudF0gLSBIZWlnaHQgaW4gcGl4ZWxzIG9mIHRoZSBsb2NhbCB2aWRlbyBNZWRpYVN0cmVhbVRyYWNrJ3MgZW5jb2RlZCBmcmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmcmFtZVdpZHRoUmVjZWl2ZWRdIC0gV2lkdGggaW4gcGl4ZWxzIG9mIHRoZSByZW1vdGUgdmlkZW8gTWVkaWFTdHJlYW1UcmFjaydzIHJlY2VpdmVkIGZyYW1lXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZyYW1lSGVpZ2h0UmVjZWl2ZWRdIC0gSGVpZ2h0IGluIHBpeGVscyBvZiB0aGUgcmVtb3RlIHZpZGVvIE1lZGlhU3RyZWFtVHJhY2sncyByZWNlaXZlZCBmcmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmcmFtZVJhdGVJbnB1dF0gLSBDYXB0dXJlZCBmcmFtZXMgcGVyIHNlY29uZCBvZiB0aGUgbG9jYWwgdmlkZW8gTWVkaWFTdHJlYW1UcmFja1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmcmFtZVJhdGVTZW50XSAtIEZyYW1lcyBwZXIgc2Vjb25kIG9mIHRoZSBsb2NhbCB2aWRlbyBNZWRpYVN0cmVhbVRyYWNrJ3MgZW5jb2RlZCB2aWRlb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmcmFtZVJhdGVSZWNlaXZlZF0gLSBGcmFtZXMgcGVyIHNlY29uZCBvZiB0aGUgcmVtb3RlIHZpZGVvIE1lZGlhU3RyZWFtVHJhY2sncyByZWNlaXZlZCB2aWRlb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtieXRlc1JlY2VpdmVkXSAtIE51bWJlciBvZiBieXRlcyBvZiB0aGUgcmVtb3RlIE1lZGlhU3RyZWFtVHJhY2sncyBtZWRpYSByZWNlaXZlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtieXRlc1NlbnRdIC0gTnVtYmVyIG9mIGJ5dGVzIG9mIHRoZSBsb2NhbCBNZWRpYVN0cmVhbVRyYWNrJ3MgbWVkaWEgc2VudFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwYWNrZXRzTG9zdF0gLSBOdW1iZXIgb2YgcGFja2V0cyBvZiB0aGUgTWVkaWFTdHJlYW1UcmFjaydzIG1lZGlhIGxvc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGFja2V0c1JlY2VpdmVkXSAtIE51bWJlciBvZiBwYWNrZXRzIG9mIHRoZSByZW1vdGUgTWVkaWFTdHJlYW1UcmFjaydzIG1lZGlhIHJlY2VpdmVkXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BhY2tldHNTZW50XSAtIE51bWJlciBvZiBwYWNrZXRzIG9mIHRoZSBsb2NhbCBNZWRpYVN0cmVhbVRyYWNrJ3MgbWVkaWEgc2VudFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0b3RhbFBhY2tldFNlbmREZWxheV0gLSBUaGUgdG90YWwgbnVtYmVyIG9mIHNlY29uZHMgdGhhdCB0aGUgbG9jYWwgTWVkaWFTdHJlYW1UcmFjaydzIHBhY2tldHNcbiAqICBoYXZlIHNwZW50IGJ1ZmZlcmVkIGxvY2FsbHkgYmVmb3JlIGJlaW5nIHNlbnQgb3ZlciB0aGUgbmV0d29ya1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0b3RhbEVuY29kZVRpbWVdIC0gVGhlIHRvdGFsIG51bWJlciBvZiBzZWNvbmRzIHNwZW50IG9uIGVuY29kaW5nIHRoZSBsb2NhbCBNZWRpYVN0cmVhbVRyYWNrJ3MgZnJhbWVzXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZyYW1lc0VuY29kZWRdIC0gVGhlIHRvdGFsIG51bWJlciBvZiBmcmFtZXMgb2YgdGhlIGxvY2FsIE1lZGlhU3RyZWFtVHJhY2sgdGhhdCBoYXZlIGJlZW4gZW5jb2RlZCBzb3IgZmFyXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2VzdGltYXRlZFBsYXlvdXRUaW1lc3RhbXBdIC0gVGhlIGVzdGltYXRlZCBwbGF5b3V0IHRpbWUgb2YgdGhlIHJlbW90ZSBNZWRpYVN0cmVhbVRyYWNrXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RvdGFsRGVjb2RlVGltZV0gLSBUaGUgdG90YWwgbnVtYmVyIG9mIHNlY29uZHMgc3BlbnQgb24gZGVjb2RpbmcgdGhlIHJlbW90ZSBNZWRpYVN0cmVhbVRyYWNrJ3MgZnJhbWVzXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZyYW1lc0RlY29kZWRdIC0gVGhlIHRvdGFsIG51bWJlciBvZiBmcmFtZXMgb2YgdGhlIHJlbW90ZSBNZWRpYVN0cmVhbVRyYWNrIHRoYXQgaGF2ZSBiZWVuIGRlY29kZWQgc29yIGZhclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtqaXR0ZXJCdWZmZXJEZWxheV0gLSBUaGUgc3VtIG9mIHRoZSB0aW1lLCBpbiBzZWNvbmRzLCBlYWNoIGF1ZGlvIHNhbXBsZSBvciBhIHZpZGVvIGZyYW1lIG9mIHRoZSByZW1vdGVcbiAqICAgTWVkaWFTdHJlYW1UcmFjayB0YWtlcyBmcm9tIHRoZSB0aW1lIHRoZSBmaXJzdCBwYWNrZXQgaXMgcmVjZWl2ZWQgYnkgdGhlIGppdHRlciBidWZmZXIgdG8gdGhlIHRpbWUgaXQgZXhpdHMgdGhlIGppdHRlciBidWZmZXJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaml0dGVyQnVmZmVyRW1pdHRlZENvdW50XSAtIFRoZSB0b3RhbCBudW1iZXIgb2YgYXVkaW8gc2FtcGxlcyBvciB2aWRlbyBmcmFtZXMgdGhhdCBoYXZlIGNvbWUgb3V0IG9mIHRoZSBqaXR0ZXIgYnVmZmVyXG4gKiBAcHJvcGVydHkge0F1ZGlvTGV2ZWx9IFthdWRpb0lucHV0TGV2ZWxdIC0gVGhlIHtAbGluayBBdWRpb0xldmVsfSBvZiB0aGUgbG9jYWwgYXVkaW8gTWVkaWFTdHJlYW1UcmFja1xuICogQHByb3BlcnR5IHtBdWRpb0xldmVsfSBbYXVkaW9PdXRwdXRMZXZlbF0gLSBUaGUge0BsaW5rIEF1ZGlvTGV2ZWx9IG9mIHRoZSByZW1vdGUgdmlkZW8gTWVkaWFTdHJlYW1UcmFja1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3RhdHM7XG4iLCIvKiBnbG9iYWxzIG5hdmlnYXRvciAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdmVyeSBzaW1pbGFyIHRvIDxjb2RlPm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhPC9jb2RlPlxuICogZXhjZXB0IHRoYXQgaWYgbm8gTWVkaWFTdHJlYW1Db25zdHJhaW50cyBhcmUgcHJvdmlkZWQsIHRoZW4gYm90IGF1ZGlvIGFuZCB2aWRlb1xuICogYXJlIHJlcXVlc3RlZC5cbiAqIEBmdW5jdGlvbiBnZXRVc2VyTWVkaWFcbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW1Db25zdHJhaW50c30gW2NvbnN0cmFpbnRzPXthdWRpbzp0cnVlLHZpZGVvOnRydWV9XSAtIHRoZVxuICogICBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzIG9iamVjdCBzcGVjaWZ5aW5nIHdoYXQga2luZCBvZiBNZWRpYVN0cmVhbSB0b1xuICogICByZXF1ZXN0IGZyb20gdGhlIGJyb3dzZXIgKGJ5IGRlZmF1bHQgYm90aCBhdWRpbyBhbmQgdmlkZW8pXG4gKiBAcmV0dXJucyBQcm9taXNlPE1lZGlhU3RyZWFtPlxuICovXG5mdW5jdGlvbiBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIG5hdmlnYXRvci5tZWRpYURldmljZXMgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3RyYWludHMgPSBjb25zdHJhaW50cyB8fCB7IGF1ZGlvOiB0cnVlLCB2aWRlbzogdHJ1ZSB9O1xuICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignZ2V0VXNlck1lZGlhIGlzIG5vdCBzdXBwb3J0ZWQnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VXNlck1lZGlhO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgV2ViUlRDID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdlYlJUQywge1xuICBnZXRTdGF0czoge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHJlcXVpcmUoJy4vZ2V0c3RhdHMnKVxuICB9LFxuICBnZXRVc2VyTWVkaWE6IHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiByZXF1aXJlKCcuL2dldHVzZXJtZWRpYScpXG4gIH0sXG4gIE1lZGlhU3RyZWFtOiB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogcmVxdWlyZSgnLi9tZWRpYXN0cmVhbScpXG4gIH0sXG4gIE1lZGlhU3RyZWFtVHJhY2s6IHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiByZXF1aXJlKCcuL21lZGlhc3RyZWFtdHJhY2snKVxuICB9LFxuICBSVENJY2VDYW5kaWRhdGU6IHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiByZXF1aXJlKCcuL3J0Y2ljZWNhbmRpZGF0ZScpXG4gIH0sXG4gIFJUQ1BlZXJDb25uZWN0aW9uOiB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogcmVxdWlyZSgnLi9ydGNwZWVyY29ubmVjdGlvbicpXG4gIH0sXG4gIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbjoge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHJlcXVpcmUoJy4vcnRjc2Vzc2lvbmRlc2NyaXB0aW9uJylcbiAgfSxcbiAgdmVyc2lvbjoge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViUlRDO1xuIiwiLyogZ2xvYmFscyBNZWRpYVN0cmVhbSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIE1lZGlhU3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gTWVkaWFTdHJlYW07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIE1lZGlhU3RyZWFtKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWVkaWFTdHJlYW0gaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9O1xufVxuIiwiLyogZ2xvYmFsIE1lZGlhU3RyZWFtVHJhY2sgKi9cbid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBNZWRpYVN0cmVhbVRyYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gTWVkaWFTdHJlYW1UcmFjaztcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gTWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01lZGlhU3RyZWFtVHJhY2sgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9O1xufVxuIiwiLyogZ2xvYmFsIFJUQ0ljZUNhbmRpZGF0ZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIFJUQ0ljZUNhbmRpZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IFJUQ0ljZUNhbmRpZGF0ZTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUlRDSWNlQ2FuZGlkYXRlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUlRDSWNlQ2FuZGlkYXRlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfTtcbn1cbiIsIi8qIGdsb2JhbHMgUlRDRGF0YUNoYW5uZWwsIFJUQ1BlZXJDb25uZWN0aW9uLCBSVENTZXNzaW9uRGVzY3JpcHRpb24gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIENocm9tZVJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IHJlcXVpcmUoJy4uL3J0Y3Nlc3Npb25kZXNjcmlwdGlvbi9jaHJvbWUnKTtcbnZhciBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnR0YXJnZXQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBMYXRjaCA9IHJlcXVpcmUoJy4uL3V0aWwvbGF0Y2gnKTtcbnZhciBNZWRpYVN0cmVhbSA9IHJlcXVpcmUoJy4uL21lZGlhc3RyZWFtJyk7XG52YXIgUlRDUnRwU2VuZGVyU2hpbSA9IHJlcXVpcmUoJy4uL3J0Y3J0cHNlbmRlcicpO1xudmFyIHNkcFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbC9zZHAnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIGlzSU9TQ2hyb21lID0gcmVxdWlyZSgnLi4vdXRpbCcpLmlzSU9TQ2hyb21lO1xuXG52YXIgaXNVbmlmaWVkUGxhbiA9IHNkcFV0aWxzLmdldFNkcEZvcm1hdCgpID09PSAndW5pZmllZCc7XG5cbi8vIE5PVEUobXJvYmVydHMpOiBUaGlzIGNsYXNzIHdyYXBzIENocm9tZSdzIFJUQ1BlZXJDb25uZWN0aW9uIGltcGxlbWVudGF0aW9uLlxuLy8gSXQgcHJvdmlkZXMgc29tZSBmdW5jdGlvbmFsaXR5IG5vdCBjdXJyZW50bHkgcHJlc2VudCBpbiBDaHJvbWUsIG5hbWVseSB0aGVcbi8vIGFiaWxpdGllcyB0b1xuLy9cbi8vICAgMS4gUm9sbGJhY2ssIHBlciB0aGUgd29ya2Fyb3VuZCBzdWdnZXN0ZWQgaGVyZTpcbi8vICAgICAgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTU3MzgjYzNcbi8vXG4vLyAgIDIuIExpc3RlbiBmb3IgdHJhY2sgZXZlbnRzLCBwZXIgdGhlIGFkYXB0ZXIuanMgd29ya2Fyb3VuZC5cbi8vXG4vLyAgIDMuIFNldCBpY2VUcmFuc3BvcnRQb2xpY3kuXG4vL1xuZnVuY3Rpb24gQ2hyb21lUlRDUGVlckNvbm5lY3Rpb24oY29uZmlndXJhdGlvbiwgY29uc3RyYWludHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENocm9tZVJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybiBuZXcgQ2hyb21lUlRDUGVlckNvbm5lY3Rpb24oY29uZmlndXJhdGlvbiwgY29uc3RyYWludHMpO1xuICB9XG5cbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICBjb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbiB8fCB7fTtcbiAgdmFyIG5ld0NvbmZpZ3VyYXRpb24gPSBPYmplY3QuYXNzaWduKGNvbmZpZ3VyYXRpb24uaWNlVHJhbnNwb3J0UG9saWN5XG4gICAgPyB7IGljZVRyYW5zcG9ydHM6IGNvbmZpZ3VyYXRpb24uaWNlVHJhbnNwb3J0UG9saWN5IH1cbiAgICA6IHt9LCBjb25maWd1cmF0aW9uKTtcblxuICB1dGlsLmludGVyY2VwdEV2ZW50KHRoaXMsICdkYXRhY2hhbm5lbCcpO1xuICB1dGlsLmludGVyY2VwdEV2ZW50KHRoaXMsICdzaWduYWxpbmdzdGF0ZWNoYW5nZScpO1xuXG4gIHZhciBzZHBGb3JtYXQgPSBzZHBVdGlscy5nZXRTZHBGb3JtYXQobmV3Q29uZmlndXJhdGlvbi5zZHBTZW1hbnRpY3MpO1xuICB2YXIgcGVlckNvbm5lY3Rpb24gPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24obmV3Q29uZmlndXJhdGlvbiwgY29uc3RyYWludHMpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICBfYXBwbGllZFRyYWNrc1RvU1NSQ3M6IHtcbiAgICAgIHZhbHVlOiBuZXcgTWFwKCksXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgX2xvY2FsU3RyZWFtOiB7XG4gICAgICB2YWx1ZTogbmV3IE1lZGlhU3RyZWFtKClcbiAgICB9LFxuICAgIF9wZWVyQ29ubmVjdGlvbjoge1xuICAgICAgdmFsdWU6IHBlZXJDb25uZWN0aW9uXG4gICAgfSxcbiAgICBfcGVuZGluZ0xvY2FsT2ZmZXI6IHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuICAgIF9wZW5kaW5nUmVtb3RlT2ZmZXI6IHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuICAgIF9yb2xsZWRCYWNrVHJhY2tzVG9TU1JDczoge1xuICAgICAgdmFsdWU6IG5ldyBNYXAoKSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBfc2RwRm9ybWF0OiB7XG4gICAgICB2YWx1ZTogc2RwRm9ybWF0XG4gICAgfSxcbiAgICBfc2VuZGVyczoge1xuICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgIH0sXG4gICAgX3NpZ25hbGluZ1N0YXRlTGF0Y2g6IHtcbiAgICAgIHZhbHVlOiBuZXcgTGF0Y2goKVxuICAgIH0sXG4gICAgX3RyYWNrc1RvU1NSQ3M6IHtcbiAgICAgIHZhbHVlOiBuZXcgTWFwKCksXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgbG9jYWxEZXNjcmlwdGlvbjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nTG9jYWxPZmZlciA/IHRoaXMuX3BlbmRpbmdMb2NhbE9mZmVyIDogcGVlckNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW90ZURlc2NyaXB0aW9uOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdSZW1vdGVPZmZlciA/IHRoaXMuX3BlbmRpbmdSZW1vdGVPZmZlciA6IHBlZXJDb25uZWN0aW9uLnJlbW90ZURlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2lnbmFsaW5nU3RhdGU6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0xvY2FsT2ZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gJ2hhdmUtbG9jYWwtb2ZmZXInO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3BlbmRpbmdSZW1vdGVPZmZlcikge1xuICAgICAgICAgIHJldHVybiAnaGF2ZS1yZW1vdGUtb2ZmZXInO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBwZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdkYXRhY2hhbm5lbCcsIGZ1bmN0aW9uIG9uZGF0YWNoYW5uZWwoZXZlbnQpIHtcbiAgICBzaGltRGF0YUNoYW5uZWwoZXZlbnQuY2hhbm5lbCk7XG4gICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSk7XG5cbiAgcGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignc2lnbmFsaW5nc3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiBvbnNpZ25hbGluZ3N0YXRlY2hhbmdlKCkge1xuICAgIGlmIChwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpIHtcbiAgICAgIHNlbGYuX2FwcGxpZWRUcmFja3NUb1NTUkNzID0gbmV3IE1hcChzZWxmLl90cmFja3NUb1NTUkNzKTtcbiAgICB9XG4gICAgaWYgKCFzZWxmLl9wZW5kaW5nTG9jYWxPZmZlciAmJiAhc2VsZi5fcGVuZGluZ1JlbW90ZU9mZmVyKSB7XG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHBlZXJDb25uZWN0aW9uLm9udHJhY2sgPSBmdW5jdGlvbiBvbnRyYWNrKCkge1xuICAgIC8vIE5PVEUobXJvYmVydHMpOiBhZGFwdGVyLmpzJ3MgXCJ0cmFja1wiIGV2ZW50IHNoaW0gb25seSBraWNrcyBvZmYgaWYgd2Ugc2V0XG4gICAgLy8gdGhlIG9udHJhY2sgcHJvcGVydHkgb2YgdGhlIFJUQ1BlZXJDb25uZWN0aW9uLlxuICB9O1xuXG4gIGlmICh0eXBlb2YgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcGVlckNvbm5lY3Rpb24uYWRkU3RyZWFtKHRoaXMuX2xvY2FsU3RyZWFtKTtcbiAgfVxuICB1dGlsLnByb3h5UHJvcGVydGllcyhSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsIHRoaXMsIHBlZXJDb25uZWN0aW9uKTtcbn1cblxuaW5oZXJpdHMoQ2hyb21lUlRDUGVlckNvbm5lY3Rpb24sIEV2ZW50VGFyZ2V0KTtcblxuaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gTk9URShtbWFsYXZhbGxpKTogVGhpcyBzaGltIHN1cHBvcnRzIG91ciBsaW1pdGVkIGNhc2Ugb2YgYWRkaW5nXG4gIC8vIGFsbCBNZWRpYVN0cmVhbVRyYWNrcyB0byBvbmUgTWVkaWFTdHJlYW0uIEl0IGhhcyBiZWVuIGltcGxlbWVudGVkIHRoaXNcbiAgLy8ga2VlcGluZyBpbiBtaW5kIHRoYXQgdGhpcyBpcyB0byBiZSBtYWludGFpbmVkIG9ubHkgdW50aWwgXCJhZGRUcmFja1wiIGlzXG4gIC8vIHN1cHBvcnRlZCBuYXRpdmVseSBpbiBDaHJvbWUuXG4gIENocm9tZVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciB0cmFjayA9IGFyZ3NbMF07XG4gICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIE1lZGlhU3RyZWFtVHJhY2sgWycgKyB0cmFjay5pZCArICcsICdcbiAgICAgICAgKyB0cmFjay5raW5kICsgJ106IFJUQ1BlZXJDb25uZWN0aW9uIGlzIGNsb3NlZCcpO1xuICAgIH1cblxuICAgIHZhciBzZW5kZXIgPSB0aGlzLl9zZW5kZXJzLmdldCh0cmFjayk7XG4gICAgaWYgKHNlbmRlciAmJiBzZW5kZXIudHJhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBNZWRpYVN0cmVhbVRyYWNrIFsnICsgdHJhY2suaWQgKyAnLCAnXG4gICAgICAgICsgdHJhY2sua2luZCArICddOiBSVENQZWVyQ29ubmVjdGlvbiBhbHJlYWR5IGhhcyBpdCcpO1xuICAgIH1cbiAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5yZW1vdmVTdHJlYW0odGhpcy5fbG9jYWxTdHJlYW0pO1xuICAgIHRoaXMuX2xvY2FsU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5hZGRTdHJlYW0odGhpcy5fbG9jYWxTdHJlYW0pO1xuXG4gICAgc2VuZGVyID0gbmV3IFJUQ1J0cFNlbmRlclNoaW0odHJhY2spO1xuICAgIHRoaXMuX3NlbmRlcnMuc2V0KHRyYWNrLCBzZW5kZXIpO1xuICAgIHJldHVybiBzZW5kZXI7XG4gIH07XG5cbiAgLy8gTk9URShtbWFsYXZhbGxpKTogVGhpcyBzaGltIHN1cHBvcnRzIG91ciBsaW1pdGVkIGNhc2Ugb2YgcmVtb3ZpbmdcbiAgLy8gTWVkaWFTdHJlYW1UcmFja3MgZnJvbSBvbmUgTWVkaWFTdHJlYW0uIEl0IGhhcyBiZWVuIGltcGxlbWVudGVkIHRoaXNcbiAgLy8ga2VlcGluZyBpbiBtaW5kIHRoYXQgdGhpcyBpcyB0byBiZSBtYWludGFpbmVkIG9ubHkgdW50aWwgXCJyZW1vdmVUcmFja1wiIGlzXG4gIC8vIHN1cHBvcnRlZCBuYXRpdmVseSBpbiBDaHJvbWUuXG4gIENocm9tZVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIGlmICh0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlbW92ZSBNZWRpYVN0cmVhbVRyYWNrOiBSVENQZWVyQ29ubmVjdGlvbiBpcyBjbG9zZWQnKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2sgPSBzZW5kZXIudHJhY2s7XG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZW5kZXIgPSB0aGlzLl9zZW5kZXJzLmdldCh0cmFjayk7XG4gICAgaWYgKHNlbmRlciAmJiBzZW5kZXIudHJhY2spIHtcbiAgICAgIHNlbmRlci50cmFjayA9IG51bGw7XG4gICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5yZW1vdmVTdHJlYW0odGhpcy5fbG9jYWxTdHJlYW0pO1xuICAgICAgdGhpcy5fbG9jYWxTdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uYWRkU3RyZWFtKHRoaXMuX2xvY2FsU3RyZWFtKTtcbiAgICB9XG4gIH07XG5cbiAgQ2hyb21lUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3NlbmRlcnMudmFsdWVzKCkpO1xuICB9O1xufSBlbHNlIHtcbiAgQ2hyb21lUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVtb3ZlIE1lZGlhU3RyZWFtVHJhY2s6IFJUQ1BlZXJDb25uZWN0aW9uIGlzIGNsb3NlZCcpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24ucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBOT1RFKG1odXluaCk6IERvIG5vdGhpbmcuIEluIENocm9tZSwgd2lsbCB0aHJvdyBpZiBhICdzZW5kZXIgd2FzIG5vdFxuICAgICAgLy8gY3JlYXRlZCBieSB0aGlzIHBlZXIgY29ubmVjdGlvbicuIFRoaXMgYmVoYXZpb3IgZG9lcyBub3Qgc2VlbSB0byBiZVxuICAgICAgLy8gc3BlYyBjb21wbGlhbnQsIHNvIGEgdGVtcG9yYXJ5IHNoaW0gaXMgaW50cm9kdWNlZC4gQSBidWcgaGFzIGJlZW4gZmlsZWQsXG4gICAgICAvLyBhbmQgaXMgdHJhY2tlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODYwODUzXG4gICAgfVxuICB9O1xufVxuXG5DaHJvbWVSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkge1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgdmFyIHByb21pc2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2hhdmUtcmVtb3RlLW9mZmVyJykge1xuICAgIC8vIE5PVEUobXJvYmVydHMpOiBCZWNhdXNlIHRoZSBDaHJvbWVSVENQZWVyQ29ubmVjdGlvbiBzaW11bGF0ZXMgdGhlXG4gICAgLy8gXCJoYXZlLXJlbW90ZS1vZmZlclwiIHNpZ25hbGluZ1N0YXRlcywgd2Ugb25seSB3YW50IHRvIGludm9rZSB0aGUgdHJ1ZVxuICAgIC8vIGFkZEljZUNhbmRpZGF0ZXMgbWV0aG9kIHdoZW4gdGhlIHJlbW90ZSBkZXNjcmlwdGlvbiBoYXMgYmVlbiBhcHBsaWVkLlxuICAgIHByb21pc2UgPSB0aGlzLl9zaWduYWxpbmdTdGF0ZUxhdGNoLndoZW4oJ2xvdycpLnRoZW4oZnVuY3Rpb24gc2lnbmFsaW5nU3RhdGVzUmVzb2x2ZWQoKSB7XG4gICAgICByZXR1cm4gc2VsZi5fcGVlckNvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcHJvbWlzZSA9IHRoaXMuX3BlZXJDb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICB9XG5cbiAgcmV0dXJuIGFyZ3MubGVuZ3RoID4gMVxuICAgID8gdXRpbC5sZWdhY3lQcm9taXNlKHByb21pc2UsIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgOiBwcm9taXNlO1xufTtcblxuLy8gTk9URShtcm9iZXJ0cyk6IFRoZSBXZWJSVEMgc3BlYyBkb2VzIG5vdCBzcGVjaWZ5IHRoYXQgY2xvc2Ugc2hvdWxkIHRocm93IGFuXG4vLyBFcnJvcjsgaG93ZXZlciwgaW4gQ2hyb21lIGl0IGRvZXMuIFdlIHdvcmthcm91bmQgdGhpcyBieSBjaGVja2luZyB0aGVcbi8vIHNpZ25hbGluZ1N0YXRlIG1hbnVhbGx5LlxuQ2hyb21lUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XG4gIGlmICh0aGlzLnNpZ25hbGluZ1N0YXRlICE9PSAnY2xvc2VkJykge1xuICAgIHRoaXMuX3BlbmRpbmdMb2NhbE9mZmVyID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVtb3RlT2ZmZXIgPSBudWxsO1xuICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8vIE5PVEUobXJvYmVydHMpOiBCZWNhdXNlIHdlIHdvcmthcm91bmQgQ2hyb21lJ3MgbGFjayBvZiByb2xsYmFjayBzdXBwb3J0IGJ5XG4vLyBcImZha2luZ1wiIHNldFJlbW90ZURlc2NyaXB0aW9uLCB3ZSBjYW5ub3QgY3JlYXRlIGFuIGFuc3dlciB1bnRpbCB3ZSBhY3R1YWxseVxuLy8gYXBwbHkgdGhlIHJlbW90ZSBkZXNjcmlwdGlvbi4gVGhpcyBtZWFucywgb25jZSB5b3UgY2FsbCBjcmVhdGVBbnN3ZXIsIHlvdVxuLy8gY2FuIG5vIGxvbmdlciByb2xsYmFjay4gVGhpcyBpcyBhY2NlcHRhYmxlIGZvciBvdXIgdXNlIGNhc2UgYmVjYXVzZSB3ZSB3aWxsXG4vLyBhcHBseSB0aGUgbmV3bHktY3JlYXRlZCBhbnN3ZXIgYWxtb3N0IGltbWVkaWF0ZWx5OyBob3dldmVyLCB0aGlzIG1heSBiZVxuLy8gdW5hY2NlcHRhYmxlIGZvciBvdGhlciB1c2UgY2FzZXMuXG5DaHJvbWVSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gY3JlYXRlQW5zd2VyKCkge1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgdmFyIHByb21pc2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5fcGVuZGluZ1JlbW90ZU9mZmVyKSB7XG4gICAgcHJvbWlzZSA9IHRoaXMuX3BlZXJDb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKHRoaXMuX3BlbmRpbmdSZW1vdGVPZmZlcikudGhlbihmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvblN1Y2NlZWRlZCgpIHtcbiAgICAgIC8vIE5PVEUobXJvYmVydHMpOiBUaGUgc2lnbmFsaW5nU3RhdGVzIGJldHdlZW4gdGhlIENocm9tZVJUQ1BlZXJDb25uZWN0aW9uXG4gICAgICAvLyBhbmQgdGhlIHVuZGVybHlpbmcgUlRDUGVlckNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb24gaGF2ZSBjb252ZXJnZWQuIFdlXG4gICAgICAvLyBjYW4gdW5ibG9jayBhbnkgcGVuZGluZyBjYWxscyB0byBhZGRJY2VDYW5kaWRhdGUgbm93LlxuICAgICAgc2VsZi5fc2lnbmFsaW5nU3RhdGVMYXRjaC5sb3dlcigpO1xuICAgICAgcmV0dXJuIHNlbGYuX3BlZXJDb25uZWN0aW9uLmNyZWF0ZUFuc3dlcigpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gY3JlYXRlQW5zd2VyU3VjY2VlZGVkKGFuc3dlcikge1xuICAgICAgc2VsZi5fcGVuZGluZ1JlbW90ZU9mZmVyID0gbnVsbDtcblxuICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogSWYgY3JlYXRlQW5zd2VyKCkgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHJvbGxpbmcgYmFjaywgdGhlbiB3ZSBub1xuICAgICAgLy8gbG9uZ2VyIG5lZWQgdG8gcmV0YWluIHRoZSByb2xsZWQgYmFjayB0cmFja3MgdG8gU1NSQ3MgTWFwLlxuICAgICAgc2VsZi5fcm9sbGVkQmFja1RyYWNrc1RvU1NSQ3MuY2xlYXIoKTtcblxuICAgICAgcmV0dXJuIG5ldyBDaHJvbWVSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICB0eXBlOiAnYW5zd2VyJyxcbiAgICAgICAgc2RwOiB1cGRhdGVUcmFja0lkc1RvU1NSQ3Moc2VsZi5fc2RwRm9ybWF0LCBzZWxmLl90cmFja3NUb1NTUkNzLCBhbnN3ZXIuc2RwKVxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb25PckNyZWF0ZUFuc3dlckZhaWxlZChlcnJvcikge1xuICAgICAgc2VsZi5fcGVuZGluZ1JlbW90ZU9mZmVyID0gbnVsbDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHByb21pc2UgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKS50aGVuKGZ1bmN0aW9uKGFuc3dlcikge1xuICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogSWYgY3JlYXRlQW5zd2VyKCkgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHJvbGxpbmcgYmFjaywgdGhlbiB3ZSBub1xuICAgICAgLy8gbG9uZ2VyIG5lZWQgdG8gcmV0YWluIHRoZSByb2xsZWQgYmFjayB0cmFja3MgdG8gU1NSQ3MgTWFwLlxuICAgICAgc2VsZi5fcm9sbGVkQmFja1RyYWNrc1RvU1NSQ3MuY2xlYXIoKTtcblxuICAgICAgcmV0dXJuIG5ldyBDaHJvbWVSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICB0eXBlOiAnYW5zd2VyJyxcbiAgICAgICAgc2RwOiB1cGRhdGVUcmFja0lkc1RvU1NSQ3Moc2VsZi5fc2RwRm9ybWF0LCBzZWxmLl90cmFja3NUb1NTUkNzLCBhbnN3ZXIuc2RwKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYXJncy5sZW5ndGggPiAxXG4gICAgPyB1dGlsLmxlZ2FjeVByb21pc2UocHJvbWlzZSwgYXJnc1swXSwgYXJnc1sxXSlcbiAgICA6IHByb21pc2U7XG59O1xuXG5DaHJvbWVSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcigpIHtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHZhciBvcHRpb25zID0gKGFyZ3MubGVuZ3RoID4gMSA/IGFyZ3NbMl0gOiBhcmdzWzBdKSB8fCB7fTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmIChpc0lPU0Nocm9tZSgpKSB7XG4gICAgLy8gTk9URSAoam9tYSk6IEZyb20gU2FmYXJpUlRDUGVlckNvbm5lY3Rpb24gaW4gb3JkZXIgdG8gc3VwcG9ydCBpT1MgQ2hyb21lLlxuICAgIGlmIChvcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gJiYgIXRoaXMuX2F1ZGlvVHJhbnNjZWl2ZXIgJiYgIShpc1VuaWZpZWRQbGFuICYmIGhhc1JlY2VpdmVyc0ZvclRyYWNrc09mS2luZCh0aGlzLCAnYXVkaW8nKSkpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW87XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9hdWRpb1RyYW5zY2VpdmVyID0gaXNVbmlmaWVkUGxhblxuICAgICAgICAgID8gdGhpcy5hZGRUcmFuc2NlaXZlcignYXVkaW8nLCB7IGRpcmVjdGlvbjogJ3JlY3Zvbmx5JyB9KVxuICAgICAgICAgIDogdGhpcy5hZGRUcmFuc2NlaXZlcignYXVkaW8nKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gJiYgIXRoaXMuX3ZpZGVvVHJhbnNjZWl2ZXIgJiYgIShpc1VuaWZpZWRQbGFuICYmIGhhc1JlY2VpdmVyc0ZvclRyYWNrc09mS2luZCh0aGlzLCAndmlkZW8nKSkpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW87XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl92aWRlb1RyYW5zY2VpdmVyID0gaXNVbmlmaWVkUGxhblxuICAgICAgICAgID8gdGhpcy5hZGRUcmFuc2NlaXZlcigndmlkZW8nLCB7IGRpcmVjdGlvbjogJ3JlY3Zvbmx5JyB9KVxuICAgICAgICAgIDogdGhpcy5hZGRUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwcm9taXNlID0gdGhpcy5fcGVlckNvbm5lY3Rpb24uY3JlYXRlT2ZmZXIob3B0aW9ucykudGhlbihmdW5jdGlvbihvZmZlcikge1xuICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IElmIGNyZWF0ZU9mZmVyKCkgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHJvbGxpbmcgYmFjaywgdGhlbiB3ZSBub1xuICAgIC8vIGxvbmdlciBuZWVkIHRvIHJldGFpbiB0aGUgcm9sbGVkIGJhY2sgdHJhY2tzIHRvIFNTUkNzIE1hcC5cbiAgICBzZWxmLl9yb2xsZWRCYWNrVHJhY2tzVG9TU1JDcy5jbGVhcigpO1xuXG4gICAgcmV0dXJuIG5ldyBDaHJvbWVSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgdHlwZTogb2ZmZXIudHlwZSxcbiAgICAgIHNkcDogdXBkYXRlVHJhY2tJZHNUb1NTUkNzKHNlbGYuX3NkcEZvcm1hdCwgc2VsZi5fdHJhY2tzVG9TU1JDcywgb2ZmZXIuc2RwKVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gYXJncy5sZW5ndGggPiAxXG4gICAgPyB1dGlsLmxlZ2FjeVByb21pc2UocHJvbWlzZSwgYXJnc1swXSwgYXJnc1sxXSlcbiAgICA6IHByb21pc2U7XG59O1xuXG5DaHJvbWVSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWwgPSBmdW5jdGlvbiBjcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KSB7XG4gIGRhdGFDaGFubmVsRGljdCA9IHNoaW1EYXRhQ2hhbm5lbEluaXQoZGF0YUNoYW5uZWxEaWN0KTtcbiAgdmFyIGRhdGFDaGFubmVsID0gdGhpcy5fcGVlckNvbm5lY3Rpb24uY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCk7XG4gIHNoaW1EYXRhQ2hhbm5lbChkYXRhQ2hhbm5lbCk7XG4gIHJldHVybiBkYXRhQ2hhbm5lbDtcbn07XG5cbkNocm9tZVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0TG9jYWxEZXNjcmlwdGlvbigpIHtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHZhciBkZXNjcmlwdGlvbiA9IGFyZ3NbMF07XG5cbiAgLy8gTk9URShtbWFsYXZhbGxpKTogSWYgc2V0TG9jYWxEZXNjcmlwdGlvbigpIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciByb2xsaW5nIGJhY2ssXG4gIC8vIHRoZW4gd2UgbmVlZCB0byByZXN0b3JlIHRoZSByb2xsZWQgYmFjayB0cmFja3MgdG8gU1NSQ3MgTWFwLlxuICBpZiAodGhpcy5fcm9sbGVkQmFja1RyYWNrc1RvU1NSQ3Muc2l6ZSA+IDApIHtcbiAgICB0aGlzLl90cmFja3NUb1NTUkNzID0gbmV3IE1hcCh0aGlzLl9yb2xsZWRCYWNrVHJhY2tzVG9TU1JDcyk7XG4gICAgdGhpcy5fcm9sbGVkQmFja1RyYWNrc1RvU1NSQ3MuY2xlYXIoKTtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gc2V0RGVzY3JpcHRpb24odGhpcywgdHJ1ZSwgZGVzY3JpcHRpb24pO1xuICByZXR1cm4gYXJncy5sZW5ndGggPiAxXG4gICAgPyB1dGlsLmxlZ2FjeVByb21pc2UocHJvbWlzZSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICA6IHByb21pc2U7XG59O1xuXG5DaHJvbWVSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHZhciBkZXNjcmlwdGlvbiA9IGFyZ3NbMF07XG5cbiAgLy8gTk9URShtbWFsYXZhbGxpKTogSWYgc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgcm9sbGluZyBiYWNrLFxuICAvLyB0aGVuIHdlIG5vIGxvbmdlciBuZWVkIHRvIHJldGFpbiB0aGUgcm9sbGVkIGJhY2sgdHJhY2tzIHRvIFNTUkNzIE1hcC5cbiAgdGhpcy5fcm9sbGVkQmFja1RyYWNrc1RvU1NSQ3MuY2xlYXIoKTtcblxuICB2YXIgcHJvbWlzZSA9IHNldERlc2NyaXB0aW9uKHRoaXMsIGZhbHNlLCBkZXNjcmlwdGlvbik7XG4gIHJldHVybiBhcmdzLmxlbmd0aCA+IDFcbiAgICA/IHV0aWwubGVnYWN5UHJvbWlzZShwcm9taXNlLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgIDogcHJvbWlzZTtcbn07XG5cbnV0aWwuZGVsZWdhdGVNZXRob2RzKFxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsXG4gIENocm9tZVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSxcbiAgJ19wZWVyQ29ubmVjdGlvbicpO1xuXG4vLyBOT1RFKG1yb2JlcnRzKTogV2Ugd29ya2Fyb3VuZCBDaHJvbWUncyBsYWNrIG9mIHJvbGxiYWNrIHN1cHBvcnQsIHBlciB0aGVcbi8vIHdvcmthcm91bmQgc3VnZ2VzdGVkIGhlcmU6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD01NzM4I2MzXG4vLyBOYW1lbHksIHdlIFwiZmFrZVwiIHNldHRpbmcgdGhlIGxvY2FsIG9yIHJlbW90ZSBkZXNjcmlwdGlvbiBhbmQgaW5zdGVhZCBidWZmZXJcbi8vIGl0LiBJZiB3ZSByZWNlaXZlIG9yIGNyZWF0ZSBhbiBhbnN3ZXIsIHRoZW4gd2Ugd2lsbCBhY3R1YWxseSBhcHBseSB0aGVcbi8vIGRlc2NyaXB0aW9uLiBVbnRpbCB3ZSByZWNlaXZlIG9yIGNyZWF0ZSBhbiBhbnN3ZXIsIHdlIHdpbGwgYmUgYWJsZSB0b1xuLy8gXCJyb2xsYmFja1wiIGJ5IHNpbXBseSBkaXNjYXJkaW5nIHRoZSBidWZmZXIgZGVzY3JpcHRpb24uXG5mdW5jdGlvbiBzZXREZXNjcmlwdGlvbihwZWVyQ29ubmVjdGlvbiwgbG9jYWwsIGRlc2NyaXB0aW9uKSB7XG4gIGZ1bmN0aW9uIHNldFBlbmRpbmdMb2NhbE9mZmVyKG9mZmVyKSB7XG4gICAgaWYgKGxvY2FsKSB7XG4gICAgICBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXIgPSBvZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVlckNvbm5lY3Rpb24uX3BlbmRpbmdSZW1vdGVPZmZlciA9IG9mZmVyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyUGVuZGluZ0xvY2FsT2ZmZXIoKSB7XG4gICAgaWYgKGxvY2FsKSB7XG4gICAgICBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ1JlbW90ZU9mZmVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0xvY2FsT2ZmZXIgPSBsb2NhbCA/IHBlZXJDb25uZWN0aW9uLl9wZW5kaW5nTG9jYWxPZmZlciA6IHBlZXJDb25uZWN0aW9uLl9wZW5kaW5nUmVtb3RlT2ZmZXI7XG4gIHZhciBwZW5kaW5nUmVtb3RlT2ZmZXIgPSBsb2NhbCA/IHBlZXJDb25uZWN0aW9uLl9wZW5kaW5nUmVtb3RlT2ZmZXIgOiBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXI7XG4gIHZhciBpbnRlcm1lZGlhdGVTdGF0ZSA9IGxvY2FsID8gJ2hhdmUtbG9jYWwtb2ZmZXInIDogJ2hhdmUtcmVtb3RlLW9mZmVyJztcbiAgdmFyIHNldExvY2FsRGVzY3JpcHRpb24gPSBsb2NhbCA/ICdzZXRMb2NhbERlc2NyaXB0aW9uJyA6ICdzZXRSZW1vdGVEZXNjcmlwdGlvbic7XG4gIHZhciBwcm9taXNlO1xuXG4gIGlmICghbG9jYWwgJiYgcGVuZGluZ1JlbW90ZU9mZmVyICYmIGRlc2NyaXB0aW9uLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgcHJvbWlzZSA9IHNldFJlbW90ZUFuc3dlcihwZWVyQ29ubmVjdGlvbiwgZGVzY3JpcHRpb24pO1xuICB9IGVsc2UgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICBpZiAocGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09IGludGVybWVkaWF0ZVN0YXRlICYmIHBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJykge1xuICAgICAgLy8gTk9URShtcm9iZXJ0cyk6IEVycm9yIG1lc3NhZ2UgY29waWVkIGZyb20gRmlyZWZveC5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgJyArIChsb2NhbCA/ICdsb2NhbCcgOiAncmVtb3RlJykgK1xuICAgICAgICAnIG9mZmVyIGluIHN0YXRlICcgKyBwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSkpO1xuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgdG8gc2F2ZSB0aGlzIGxvY2FsIG9mZmVyIGluIGNhc2Ugb2YgYSByb2xsYmFjay4gV2UgYWxzbyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBzaWduYWxpbmdTdGF0ZSBiZXR3ZWVuIHRoZSBDaHJvbWVSVENQZWVyQ29ubmVjdGlvblxuICAgIC8vIGFuZCB0aGUgdW5kZXJseWluZyBSVENQZWVyQ29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbiBhcmUgYWJvdXQgdG8gZGl2ZXJnZS5cbiAgICAvLyBJZiBzbywgd2UgbmVlZCB0byBlbnN1cmUgc3Vic2VxdWVudCBjYWxscyB0byBhZGRJY2VDYW5kaWRhdGUgd2lsbCBibG9jay5cbiAgICBpZiAoIXBlbmRpbmdMb2NhbE9mZmVyICYmIHBlZXJDb25uZWN0aW9uLl9zaWduYWxpbmdTdGF0ZUxhdGNoLnN0YXRlID09PSAnbG93Jykge1xuICAgICAgcGVlckNvbm5lY3Rpb24uX3NpZ25hbGluZ1N0YXRlTGF0Y2gucmFpc2UoKTtcbiAgICB9XG4gICAgdmFyIHByZXZpb3VzU2lnbmFsaW5nU3RhdGUgPSBwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZTtcbiAgICBzZXRQZW5kaW5nTG9jYWxPZmZlcih1bndyYXAoZGVzY3JpcHRpb24pKTtcbiAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICAvLyBPbmx5IGRpc3BhdGNoIGEgc2lnbmFsaW5nc3RhdGVjaGFuZ2UgZXZlbnQgaWYgd2UgdHJhbnNpdGlvbmVkLlxuICAgIGlmIChwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSAhPT0gcHJldmlvdXNTaWduYWxpbmdTdGF0ZSkge1xuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIGRpc3BhdGNoU2lnbmFsaW5nU3RhdGVDaGFuZ2VFdmVudCgpIHtcbiAgICAgICAgcGVlckNvbm5lY3Rpb24uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3NpZ25hbGluZ3N0YXRlY2hhbmdlJykpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ3JvbGxiYWNrJykge1xuICAgIGlmIChwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSAhPT0gaW50ZXJtZWRpYXRlU3RhdGUpIHtcbiAgICAgIC8vIE5PVEUobXJvYmVydHMpOiBFcnJvciBtZXNzYWdlIGNvcGllZCBmcm9tIEZpcmVmb3guXG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDYW5ub3Qgcm9sbGJhY2sgJyArXG4gICAgICAgIChsb2NhbCA/ICdsb2NhbCcgOiAncmVtb3RlJykgKyAnIGRlc2NyaXB0aW9uIGluICcgKyBwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXNldCB0aGUgcGVuZGluZyBvZmZlci5cbiAgICAgIGNsZWFyUGVuZGluZ0xvY2FsT2ZmZXIoKTtcblxuICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogV2Ugc3RvcmUgdGhlIHJvbGxlZCBiYWNrIHRyYWNrcyB0byBTU1JDcyBNYXAgaGVyZSBpbiBjYXNlXG4gICAgICAvLyBzZXRMb2NhbERlc2NyaXB0aW9uKCkgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGEgcm9sbGJhY2sgKHdpdGhvdXQgY2FsbGluZ1xuICAgICAgLy8gY3JlYXRlT2ZmZXIoKSBvciBjcmVhdGVBbnN3ZXIoKSksIGluIHdoaWNoIGNhc2UgdGhpcyByb2xsIGJhY2sgaXMgbm90IGR1ZSB0byBhXG4gICAgICAvLyBnbGFyZSBzY2VuYXJpbyBhbmQgdGhpcyBNYXAgc2hvdWxkIGJlIHJlc3RvcmVkLlxuICAgICAgcGVlckNvbm5lY3Rpb24uX3JvbGxlZEJhY2tUcmFja3NUb1NTUkNzID0gbmV3IE1hcChwZWVyQ29ubmVjdGlvbi5fdHJhY2tzVG9TU1JDcyk7XG4gICAgICBwZWVyQ29ubmVjdGlvbi5fdHJhY2tzVG9TU1JDcyA9IG5ldyBNYXAocGVlckNvbm5lY3Rpb24uX2FwcGxpZWRUcmFja3NUb1NTUkNzKTtcblxuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIGRpc3BhdGNoU2lnbmFsaW5nU3RhdGVDaGFuZ2VFdmVudCgpIHtcbiAgICAgICAgcGVlckNvbm5lY3Rpb24uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3NpZ25hbGluZ3N0YXRlY2hhbmdlJykpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb21pc2UgfHwgcGVlckNvbm5lY3Rpb24uX3BlZXJDb25uZWN0aW9uW3NldExvY2FsRGVzY3JpcHRpb25dKHVud3JhcChkZXNjcmlwdGlvbikpO1xufVxuXG5mdW5jdGlvbiBzZXRSZW1vdGVBbnN3ZXIocGVlckNvbm5lY3Rpb24sIGFuc3dlcikge1xuICAvLyBBcHBseSB0aGUgcGVuZGluZyBsb2NhbCBvZmZlci5cbiAgdmFyIHBlbmRpbmdMb2NhbE9mZmVyID0gcGVlckNvbm5lY3Rpb24uX3BlbmRpbmdMb2NhbE9mZmVyO1xuICByZXR1cm4gcGVlckNvbm5lY3Rpb24uX3BlZXJDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24ocGVuZGluZ0xvY2FsT2ZmZXIpLnRoZW4oZnVuY3Rpb24gc2V0TG9jYWxPZmZlclN1Y2NlZWRlZCgpIHtcbiAgICBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXIgPSBudWxsO1xuICAgIHJldHVybiBwZWVyQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIHNldFJlbW90ZUFuc3dlclN1Y2NlZWRlZCgpIHtcbiAgICAvLyBOT1RFKG1yb2JlcnRzKTogVGhlIHNpZ25hbGluZ1N0YXRlcyBiZXR3ZWVuIHRoZSBDaHJvbWVSVENQZWVyQ29ubmVjdGlvblxuICAgIC8vIGFuZCB0aGUgdW5kZXJseWluZyBSVENQZWVyQ29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbiBoYXZlIGNvbnZlcmdlZC4gV2VcbiAgICAvLyBjYW4gdW5ibG9jayBhbnkgcGVuZGluZyBjYWxscyB0byBhZGRJY2VDYW5kaWRhdGUgbm93LlxuICAgIHBlZXJDb25uZWN0aW9uLl9zaWduYWxpbmdTdGF0ZUxhdGNoLmxvd2VyKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFdoZXRoZXIgYSBDaHJvbWVSVENQZWVyQ29ubmVjdGlvbiBoYXMgYW55IFJUQ1J0cFJlY2VpdmVycyhzKSBmb3IgdGhlIGdpdmVuXG4gKiBNZWRpYVN0cmVhbVRyYWNrIGtpbmQuXG4gKiBAcGFyYW0ge0Nocm9tZVJUQ1BlZXJDb25uZWN0aW9ufSBwZWVyQ29ubmVjdGlvblxuICogQHBhcmFtIHsnYXVkaW8nIHwgJ3ZpZGVvJ30ga2luZFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbiBmdW5jdGlvbiBoYXNSZWNlaXZlcnNGb3JUcmFja3NPZktpbmQocGVlckNvbm5lY3Rpb24sIGtpbmQpIHtcbiAgcmV0dXJuICEhcGVlckNvbm5lY3Rpb24uZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgIHJldHVybiB0cmFuc2NlaXZlci5yZWNlaXZlciAmJiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjayAmJiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSBraW5kO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdW53cmFwKGRlc2NyaXB0aW9uKSB7XG4gIGlmIChkZXNjcmlwdGlvbiBpbnN0YW5jZW9mIENocm9tZVJUQ1Nlc3Npb25EZXNjcmlwdGlvbikge1xuICAgIGlmIChkZXNjcmlwdGlvbi5fZGVzY3JpcHRpb24pIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdGlvbi5fZGVzY3JpcHRpb247XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKTtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIG9yIG5vdCB3ZSBuZWVkIHRvIGFwcGx5IG91ciBtYXhQYWNrZXRMaWZlVGltZSBzaGltLiBXZSBhcmVcbiAqIHByZXR0eSBjb25zZXJ2YXRpdmU6IHdlJ2xsIG9ubHkgYXBwbHkgaXQgaWYgdGhlIGxlZ2FjeSBtYXhSZXRyYW5zbWl0VGltZVxuICogcHJvcGVydHkgaXMgYXZhaWxhYmxlIF9hbmRfIHRoZSBzdGFuZGFyZCBtYXhQYWNrZXRMaWZlVGltZSBwcm9wZXJ0eSBpcyBfbm90X1xuICogYXZhaWxhYmxlICh0aGUgdGhpbmtpbmcgYmVpbmcgdGhhdCBDaHJvbWUgd2lsbCBsYW5kIHRoZSBzdGFuZGFyZHMtY29tcGxpYW50XG4gKiBwcm9wZXJ0eSkuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbmVlZHNNYXhQYWNrZXRMaWZlVGltZVNoaW0oKSB7XG4gIHJldHVybiAnbWF4UmV0cmFuc21pdFRpbWUnIGluIFJUQ0RhdGFDaGFubmVsLnByb3RvdHlwZVxuICAgICYmICEoJ21heFBhY2tldExpZmVUaW1lJyBpbiBSVENEYXRhQ2hhbm5lbC5wcm90b3R5cGUpO1xufVxuXG4vKipcbiAqIFNoaW0gYW4gUlRDRGF0YUNoYW5uZWxJbml0IGRpY3Rpb25hcnkgKGlmIG5lY2Vzc2FyeSkuIFRoaXMgZnVuY3Rpb24gcmV0dXJuc1xuICogYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBSVENEYXRhQ2hhbm5lbEluaXQuXG4gKiBAcGFyYW0ge1JUQ0RhdGFDaGFubmVsSW5pdH0gZGF0YUNoYW5uZWxEaWN0XG4gKiBAcmV0dXJucyB7UlRDRGF0YUNoYW5uZWxJbml0fVxuICovXG5mdW5jdGlvbiBzaGltRGF0YUNoYW5uZWxJbml0KGRhdGFDaGFubmVsRGljdCkge1xuICBkYXRhQ2hhbm5lbERpY3QgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhQ2hhbm5lbERpY3QpO1xuICBpZiAobmVlZHNNYXhQYWNrZXRMaWZlVGltZVNoaW0oKSAmJiAnbWF4UGFja2V0TGlmZVRpbWUnIGluIGRhdGFDaGFubmVsRGljdCkge1xuICAgIGRhdGFDaGFubmVsRGljdC5tYXhSZXRyYW5zbWl0VGltZSA9IGRhdGFDaGFubmVsRGljdC5tYXhQYWNrZXRMaWZlVGltZTtcbiAgfVxuICByZXR1cm4gZGF0YUNoYW5uZWxEaWN0O1xufVxuXG4vKipcbiAqIFNoaW0gYW4gUlRDRGF0YUNoYW5uZWwgKGlmIG5lY2Vzc2FyeSkuIFRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGVcbiAqIFJUQ0RhdGFDaGFubmVsLlxuICogQHBhcmFtIHtSVENEYXRhQ2hhbm5lbH0gZGF0YUNoYW5uZWxcbiAqIEByZXR1cm5zIHtSVENEYXRhQ2hhbm5lbH1cbiAqL1xuZnVuY3Rpb24gc2hpbURhdGFDaGFubmVsKGRhdGFDaGFubmVsKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhQ2hhbm5lbCwgJ21heFJldHJhbnNtaXRzJywge1xuICAgIHZhbHVlOiBkYXRhQ2hhbm5lbC5tYXhSZXRyYW5zbWl0cyA9PT0gNjU1MzVcbiAgICAgID8gbnVsbFxuICAgICAgOiBkYXRhQ2hhbm5lbC5tYXhSZXRyYW5zbWl0c1xuICB9KTtcbiAgaWYgKG5lZWRzTWF4UGFja2V0TGlmZVRpbWVTaGltKCkpIHtcbiAgICAvLyBOT1RFKG1yb2JlcnRzKTogV2UgY2FuIHJlbmFtZSBgbWF4UmV0cmFuc21pdFRpbWVgIHRvIGBtYXhQYWNrZXRMaWZlVGltZWAuXG4gICAgLy9cbiAgICAvLyAgIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTY5NjY4MVxuICAgIC8vXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFDaGFubmVsLCAnbWF4UGFja2V0TGlmZVRpbWUnLCB7XG4gICAgICB2YWx1ZTogZGF0YUNoYW5uZWwubWF4UmV0cmFuc21pdFRpbWUgPT09IDY1NTM1XG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IGRhdGFDaGFubmVsLm1heFJldHJhbnNtaXRUaW1lXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFDaGFubmVsO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgbWFwcGluZ3MgZnJvbSBNZWRpYVN0cmVhbVRyYWNrIElEcyB0byBTU1JDcyBhcyBpbmRpY2F0ZWQgYnkgYm90aFxuICogdGhlIE1hcCBmcm9tIE1lZGlhU3RyZWFtVHJhY2sgSURzIHRvIFNTUkNzIGFuZCB0aGUgU0RQIGl0c2VsZi4gVGhpcyBtZXRob2RcbiAqIGVuc3VyZXMgdGhhdCBTU1JDcyBuZXZlciBjaGFuZ2Ugb25jZSBhbm5vdW5jZWQuXG4gKiBAcGFyYW0geydwbGFuYid8J3VuaWZpZWQnfSBzZHBGb3JtYXRcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgU2V0PHN0cmluZz4+fSB0cmFja3NUb1NTUkNzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwIC0gYW4gU0RQIHdob3NlIGZvcm1hdCBpcyBkZXRlcm1pbmVkIGJ5IGBzZHBTZW1hbnRpY3NgXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB1cGRhdGVkU2RwIC0gdXBkYXRlZCBTRFBcbiAqL1xuZnVuY3Rpb24gdXBkYXRlVHJhY2tJZHNUb1NTUkNzKHNkcEZvcm1hdCwgdHJhY2tzVG9TU1JDcywgc2RwKSB7XG4gIHJldHVybiBzZHBGb3JtYXQgPT09ICd1bmlmaWVkJ1xuICAgID8gc2RwVXRpbHMudXBkYXRlVW5pZmllZFBsYW5UcmFja0lkc1RvU1NSQ3ModHJhY2tzVG9TU1JDcywgc2RwKVxuICAgIDogc2RwVXRpbHMudXBkYXRlUGxhbkJUcmFja0lkc1RvU1NSQ3ModHJhY2tzVG9TU1JDcywgc2RwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaHJvbWVSVENQZWVyQ29ubmVjdGlvbjtcbiIsIi8qIGdsb2JhbHMgUlRDUGVlckNvbm5lY3Rpb24gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudHRhcmdldCcpO1xudmFyIEZpcmVmb3hSVENTZXNzaW9uRGVzY3JpcHRpb24gPSByZXF1aXJlKCcuLi9ydGNzZXNzaW9uZGVzY3JpcHRpb24vZmlyZWZveCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIHVwZGF0ZVRyYWNrc1RvU1NSQ3MgPSByZXF1aXJlKCcuLi91dGlsL3NkcCcpLnVwZGF0ZVVuaWZpZWRQbGFuVHJhY2tJZHNUb1NTUkNzO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbi8vIE5PVEUobXJvYmVydHMpOiBUaGlzIGlzIGEgc2hvcnQtbGl2ZWQgd29ya2Fyb3VuZC4gQ2hlY2tpbmcgdGhlIHVzZXIgYWdlbnRcbi8vIHN0cmluZyBtaWdodCBub3QgZml4IGV2ZXJ5IGFmZmVjdGVkIEZpcmVmb3ggaW5zdGFuY2UsIGJ1dCBpdCBzaG91bGQgYmUgZ29vZFxuLy8gZW5vdWdoIGZvciB0aGlzIGJ1Zy5cbnZhciBuZWVkc1dvcmthcm91bmRGb3JCdWcxNDgwMjc3ID0gdHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCdcbiAgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudFxuICAmJiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLzYxLykgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLzYyLykpO1xuXG4vLyBOT1RFKG1yb2JlcnRzKTogVGhpcyBjbGFzcyB3cmFwcyBGaXJlZm94J3MgUlRDUGVlckNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb24uXG4vLyBJdCBwcm92aWRlcyBzb21lIGZ1bmN0aW9uYWxpdHkgbm90IGN1cnJlbnRseSBwcmVzZW50IGluIEZpcmVmb3gsIG5hbWVseSB0aGVcbi8vIGFiaWxpdGllcyB0b1xuLy9cbi8vICAgMS4gQ2FsbCBzZXRMb2NhbERlc2NyaXB0aW9uIGFuZCBzZXRSZW1vdGVEZXNjcmlwdGlvbiB3aXRoIG5ldyBvZmZlcnMgaW5cbi8vICAgICAgc2lnbmFsaW5nU3RhdGVzIFwiaGF2ZS1sb2NhbC1vZmZlclwiIGFuZCBcImhhdmUtcmVtb3RlLW9mZmVyXCIsXG4vLyAgICAgIHJlc3BlY3RpdmVseS5cbi8vXG4vLyAgIDIuIFRoZSBhYmlsaXR5IHRvIGNhbGwgY3JlYXRlT2ZmZXIgaW4gc2lnbmFsaW5nU3RhdGUgXCJoYXZlLWxvY2FsLW9mZmVyXCIuXG4vL1xuLy8gQm90aCBvZiB0aGVzZSBhcmUgaW1wbGVtZW50ZWQgdXNpbmcgcm9sbGJhY2tzIHRvIHdvcmthcm91bmQgdGhlIGZvbGxvd2luZ1xuLy8gYnVnOlxuLy9cbi8vICAgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA3MjM4OFxuLy9cbi8vIFdlIGFsc28gcHJvdmlkZSBhIHdvcmthcm91bmQgZm9yIGEgYnVnIHdoZXJlIEZpcmVmb3ggbWF5IGNoYW5nZSB0aGVcbi8vIHByZXZpb3VzbHktbmVnb3RpYXRlZCBEVExTIHJvbGUgaW4gYW4gYW5zd2VyLCB3aGljaCBicmVha3MgQ2hyb21lOlxuLy9cbi8vICAgICBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjQwODk3XG4vL1xuZnVuY3Rpb24gRmlyZWZveFJUQ1BlZXJDb25uZWN0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZpcmVmb3hSVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm4gbmV3IEZpcmVmb3hSVENQZWVyQ29ubmVjdGlvbihjb25maWd1cmF0aW9uKTtcbiAgfVxuXG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgdXRpbC5pbnRlcmNlcHRFdmVudCh0aGlzLCAnc2lnbmFsaW5nc3RhdGVjaGFuZ2UnKTtcblxuICAvKiBlc2xpbnQgbmV3LWNhcDowICovXG4gIHZhciBwZWVyQ29ubmVjdGlvbiA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihjb25maWd1cmF0aW9uKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgX2luaXRpYWxseU5lZ290aWF0ZWREdGxzUm9sZToge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgX2lzQ2xvc2VkOiB7XG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgX3BlZXJDb25uZWN0aW9uOiB7XG4gICAgICB2YWx1ZTogcGVlckNvbm5lY3Rpb25cbiAgICB9LFxuICAgIF9yb2xsaW5nQmFjazoge1xuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuICAgIF90cmFja3NUb1NTUkNzOiB7XG4gICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgfSxcbiAgICBpY2VHYXRoZXJpbmdTdGF0ZToge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Nsb3NlZCA/ICdjb21wbGV0ZScgOiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5pY2VHYXRoZXJpbmdTdGF0ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxvY2FsRGVzY3JpcHRpb246IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gb3ZlcndyaXRlV2l0aEluaXRpYWxseU5lZ290aWF0ZWREdGxzUm9sZSh0aGlzLl9wZWVyQ29ubmVjdGlvbi5sb2NhbERlc2NyaXB0aW9uLCB0aGlzLl9pbml0aWFsbHlOZWdvdGlhdGVkRHRsc1JvbGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2lnbmFsaW5nU3RhdGU6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDbG9zZWQgPyAnY2xvc2VkJyA6IHRoaXMuX3BlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJldmlvdXNTaWduYWxpbmdTdGF0ZTtcblxuICBwZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdzaWduYWxpbmdzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uIG9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UoKSB7XG4gICAgaWYgKCFzZWxmLl9yb2xsaW5nQmFjayAmJiBzZWxmLnNpZ25hbGluZ1N0YXRlICE9PSBwcmV2aW91c1NpZ25hbGluZ1N0YXRlKSB7XG4gICAgICBwcmV2aW91c1NpZ25hbGluZ1N0YXRlID0gc2VsZi5zaWduYWxpbmdTdGF0ZTtcblxuICAgICAgLy8gTk9URShtbWFsYXZhbGxpKTogSW4gRmlyZWZveCwgJ3NpZ25hbGluZ3N0YXRlY2hhbmdlJyBldmVudCBpc1xuICAgICAgLy8gdHJpZ2dlcmVkIHN5bmNocm9ub3VzbHkgaW4gdGhlIHNhbWUgdGljayBhZnRlclxuICAgICAgLy8gUlRDUGVlckNvbm5lY3Rpb24jY2xvc2UoKSBpcyBjYWxsZWQuIFNvIHdlIG1pbWljIENocm9tZSdzIGJlaGF2aW9yXG4gICAgICAvLyBieSB0cmlnZ2VyaW5nICdzaWduYWxpbmdzdGF0ZWNoYW5nZScgb24gdGhlIG5leHQgdGljay5cbiAgICAgIHZhciBkaXNwYXRjaEV2ZW50VG9TZWxmID0gc2VsZi5kaXNwYXRjaEV2ZW50LmFwcGx5LmJpbmQoc2VsZi5kaXNwYXRjaEV2ZW50LCBzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHNlbGYuX2lzQ2xvc2VkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZGlzcGF0Y2hFdmVudFRvU2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwYXRjaEV2ZW50VG9TZWxmKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB1dGlsLnByb3h5UHJvcGVydGllcyhSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsIHRoaXMsIHBlZXJDb25uZWN0aW9uKTtcbn1cblxuaW5oZXJpdHMoRmlyZWZveFJUQ1BlZXJDb25uZWN0aW9uLCBFdmVudFRhcmdldCk7XG5cbi8vIE5PVEUobW1hbGF2YWxsaSk6IEZpcmVmb3ggdGhyb3dzIGEgVHlwZUVycm9yIHdoZW4gdGhlIFBlZXJDb25uZWN0aW9uJ3Ncbi8vIHByb3RvdHlwZSdzIFwicGVlcklkZW50aXR5XCIgcHJvcGVydHkgaXMgYWNjZXNzZWQuIEluIG9yZGVyIHRvIG92ZXJjb21lXG4vLyB0aGlzLCB3ZSBpZ25vcmUgdGhpcyBwcm9wZXJ0eSB3aGlsZSBkZWxlZ2F0aW5nIG1ldGhvZHMuXG4vLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjM4MTVcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGaXJlZm94UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAncGVlcklkZW50aXR5Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogUHJvbWlzZS5yZXNvbHZlKHtcbiAgICBpZHA6ICcnLFxuICAgIG5hbWU6ICcnXG4gIH0pXG59KTtcblxuaWYgKG5lZWRzV29ya2Fyb3VuZEZvckJ1ZzE0ODAyNzcpIHtcbiAgRmlyZWZveFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgIHZhciB0cmFjayA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2VuZGVyID0gdGhpcy5fcGVlckNvbm5lY3Rpb24uYWRkVHJhY2suYXBwbHkodGhpcy5fcGVlckNvbm5lY3Rpb24sIGFyZ3VtZW50cyk7XG4gICAgc2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgcmV0dXJuIHNlbmRlcjtcbiAgfTtcbn1cblxuRmlyZWZveFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIoKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICB2YXIgcHJvbWlzZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHByb21pc2UgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKS50aGVuKGZ1bmN0aW9uIGNyZWF0ZUFuc3dlclN1Y2NlZWRlZChhbnN3ZXIpIHtcbiAgICBzYXZlSW5pdGlhbGx5TmVnb3RpYXRlZER0bHNSb2xlKHNlbGYsIGFuc3dlcik7XG4gICAgcmV0dXJuIG92ZXJ3cml0ZVdpdGhJbml0aWFsbHlOZWdvdGlhdGVkRHRsc1JvbGUoYW5zd2VyLCBzZWxmLl9pbml0aWFsbHlOZWdvdGlhdGVkRHRsc1JvbGUpO1xuICB9KTtcblxuICByZXR1cm4gdHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbidcbiAgICA/IHV0aWwubGVnYWN5UHJvbWlzZShwcm9taXNlLCBhcmdzWzBdLCBhcmdzWzFdKVxuICAgIDogcHJvbWlzZTtcbn07XG5cbi8vIE5PVEUobXJvYmVydHMpOiBUaGUgV2ViUlRDIHNwZWMgYWxsb3dzIHlvdSB0byBjYWxsIGNyZWF0ZU9mZmVyIGZyb20gYW55XG4vLyBzaWduYWxpbmdTdGF0ZSBvdGhlciB0aGFuIFwiY2xvc2VkXCI7IGhvd2V2ZXIsIEZpcmVmb3ggaGFzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcbi8vIHRoaXMgKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwNzIzODgpLiBXZSB3b3JrYXJvdW5kXG4vLyB0aGlzIGJ5IHJvbGxpbmcgYmFjayBpZiB3ZSBhcmUgaW4gc3RhdGUgXCJoYXZlLWxvY2FsLW9mZmVyXCIgb3Jcbi8vIFwiaGF2ZS1yZW1vdGUtb2ZmZXJcIi4gVGhpcyBpcyBhY2NlcHRhYmxlIGZvciBvdXIgdXNlIGNhc2UgYmVjYXVzZSB3ZSB3aWxsXG4vLyBhcHBseSB0aGUgbmV3bHktY3JlYXRlZCBvZmZlciBhbG1vc3QgaW1tZWRpYXRlbHk7IGhvd2V2ZXIsIHRoaXMgbWF5IGJlXG4vLyB1bmFjY2VwdGFibGUgZm9yIG90aGVyIHVzZSBjYXNlcy5cbkZpcmVmb3hSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcigpIHtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHZhciBvcHRpb25zID0gKGFyZ3MubGVuZ3RoID4gMSA/IGFyZ3NbMl0gOiBhcmdzWzBdKSB8fCB7fTtcbiAgdmFyIHByb21pc2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2hhdmUtbG9jYWwtb2ZmZXInIHx8XG4gICAgICB0aGlzLnNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1yZW1vdGUtb2ZmZXInKSB7XG4gICAgdmFyIGxvY2FsID0gdGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2hhdmUtbG9jYWwtb2ZmZXInO1xuICAgIHByb21pc2UgPSByb2xsYmFjayh0aGlzLCBsb2NhbCwgZnVuY3Rpb24gcm9sbGJhY2tTdWNjZWVkZWQoKSB7XG4gICAgICByZXR1cm4gc2VsZi5jcmVhdGVPZmZlcihvcHRpb25zKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBwcm9taXNlID0gc2VsZi5fcGVlckNvbm5lY3Rpb24uY3JlYXRlT2ZmZXIob3B0aW9ucyk7XG4gIH1cblxuICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKG9mZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlZm94UlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IG9mZmVyLnR5cGUsXG4gICAgICBzZHA6IHVwZGF0ZVRyYWNrc1RvU1NSQ3Moc2VsZi5fdHJhY2tzVG9TU1JDcywgb2ZmZXIuc2RwKVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gYXJncy5sZW5ndGggPiAxXG4gICAgPyB1dGlsLmxlZ2FjeVByb21pc2UocHJvbWlzZSwgYXJnc1swXSwgYXJnc1sxXSlcbiAgICA6IHByb21pc2U7XG59O1xuXG4vLyBOT1RFKG1yb2JlcnRzKTogV2hpbGUgRmlyZWZveCB3aWxsIHJlamVjdCB0aGUgUHJvbWlzZSByZXR1cm5lZCBieVxuLy8gc2V0TG9jYWxEZXNjcmlwdGlvbiB3aGVuIGNhbGxlZCBmcm9tIHNpZ25hbGluZ1N0YXRlIFwiaGF2ZS1sb2NhbC1vZmZlclwiIHdpdGhcbi8vIGFuIGFuc3dlciwgaXQgc3RpbGwgdXBkYXRlcyB0aGUgLmxvY2FsRGVzY3JpcHRpb24gcHJvcGVydHkuIFdlIHdvcmthcm91bmRcbi8vIHRoaXMgYnkgZXhwbGljaXRseSBoYW5kbGluZyB0aGlzIGNhc2UuXG5GaXJlZm94UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgdmFyIGRlc2NyaXB0aW9uID0gYXJnc1swXTtcbiAgdmFyIHByb21pc2U7XG5cbiAgaWYgKGRlc2NyaXB0aW9uICYmIGRlc2NyaXB0aW9uLnR5cGUgPT09ICdhbnN3ZXInICYmIHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLWxvY2FsLW9mZmVyJykge1xuICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgbG9jYWwgYW5zd2VyIGluIHN0YXRlIGhhdmUtbG9jYWwtb2ZmZXInKSk7XG4gIH1cblxuICBpZiAocHJvbWlzZSkge1xuICAgIHJldHVybiBhcmdzLmxlbmd0aCA+IDFcbiAgICAgID8gdXRpbC5sZWdhY3lQcm9taXNlKHByb21pc2UsIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICA6IHByb21pc2U7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLl9wZWVyQ29ubmVjdGlvbiwgYXJncyk7XG59O1xuXG4vLyBOT1RFKG1yb2JlcnRzKTogVGhlIFdlYlJUQyBzcGVjIGFsbG93cyB5b3UgdG8gY2FsbCBzZXRSZW1vdGVEZXNjcmlwdGlvbiB3aXRoXG4vLyBhbiBvZmZlciBtdWx0aXBsZSB0aW1lcyBpbiBzaWduYWxpbmdTdGF0ZSBcImhhdmUtcmVtb3RlLW9mZmVyXCI7IGhvd2V2ZXIsXG4vLyBGaXJlZm94IGhhcyBub3QgeWV0IGltcGxlbWVudGVkIHRoaXMgKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwNzIzODgpLlxuLy8gV2Ugd29ya2Fyb3VuZCB0aGlzIGJ5IHJvbGxpbmcgYmFjayBpZiB3ZSBhcmUgaW4gc3RhdGUgXCJoYXZlLXJlbW90ZS1vZmZlclwiLlxuLy8gVGhpcyBpcyBhY2NlcHRhYmxlIGZvciBvdXIgdXNlIGNhc2U7IGhvd2V2ZXIsIHRoaXMgbWF5IGJlIHVuYWNjZXB0YWJsZSBmb3Jcbi8vIG90aGVyIHVzZSBjYXNlcy5cbi8vXG4vLyBXaGlsZSBGaXJlZm94IHdpbGwgcmVqZWN0IHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IHNldFJlbW90ZURlc2NyaXB0aW9uIHdoZW5cbi8vIGNhbGxlZCBmcm9tIHNpZ25hbGluZ1N0YXRlIFwiaGF2ZS1yZW1vdGUtb2ZmZXJcIiB3aXRoIGFuIGFuc3dlciwgaXQgc2lsbFxuLy8gdXBkYXRlcyB0aGUgLnJlbW90ZURlc2NyaXB0aW9uIHByb3BlcnR5LiBXZSB3b3JrYXJvdW5kIHRoaXMgYnkgZXhwbGljaXRseVxuLy8gaGFuZGxpbmcgdGhpcyBjYXNlLlxuRmlyZWZveFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgdmFyIGRlc2NyaXB0aW9uID0gYXJnc1swXTtcbiAgdmFyIHByb21pc2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoZGVzY3JpcHRpb24gJiYgdGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2hhdmUtcmVtb3RlLW9mZmVyJykge1xuICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQ2Fubm90IHNldCByZW1vdGUgYW5zd2VyIGluIHN0YXRlIGhhdmUtcmVtb3RlLW9mZmVyJykpO1xuICAgIH0gZWxzZSBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgcHJvbWlzZSA9IHJvbGxiYWNrKHRoaXMsIGZhbHNlLCBmdW5jdGlvbiByb2xsYmFja1N1Y2NlZWRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX3BlZXJDb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcHJvbWlzZSkge1xuICAgIHByb21pc2UgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjcmlwdGlvbik7XG4gIH1cblxuICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uU3VjY2VlZGVkKCkge1xuICAgIHNhdmVJbml0aWFsbHlOZWdvdGlhdGVkRHRsc1JvbGUoc2VsZiwgZGVzY3JpcHRpb24sIHRydWUpO1xuICB9KTtcblxuICByZXR1cm4gYXJncy5sZW5ndGggPiAxXG4gICAgPyB1dGlsLmxlZ2FjeVByb21pc2UocHJvbWlzZSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICA6IHByb21pc2U7XG59O1xuXG4vLyBOT1RFKG1yb2JlcnRzKTogVGhlIFdlYlJUQyBzcGVjIHNwZWNpZmllcyB0aGF0IHRoZSBQZWVyQ29ubmVjdGlvbidzIGludGVybmFsXG4vLyBpc0Nsb3NlZCBzbG90IHNob3VsZCBpbW1lZGlhdGVseSBiZSBzZXQgdG8gdHJ1ZTsgaG93ZXZlciwgaW4gRmlyZWZveCBpdFxuLy8gb2NjdXJzIGluIHRoZSBuZXh0IHRpY2suIFdlIHdvcmthcm91bmQgdGhpcyBieSB0cmFja2luZyBpc0Nsb3NlZCBtYW51YWxseS5cbkZpcmVmb3hSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgdGhpcy5faXNDbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gIH1cbn07XG5cbnV0aWwuZGVsZWdhdGVNZXRob2RzKFxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsXG4gIEZpcmVmb3hSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsXG4gICdfcGVlckNvbm5lY3Rpb24nKTtcblxuZnVuY3Rpb24gcm9sbGJhY2socGVlckNvbm5lY3Rpb24sIGxvY2FsLCBvbmNlUm9sbGVkQmFjaykge1xuICB2YXIgc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGxvY2FsID8gJ3NldExvY2FsRGVzY3JpcHRpb24nIDogJ3NldFJlbW90ZURlc2NyaXB0aW9uJztcbiAgcGVlckNvbm5lY3Rpb24uX3JvbGxpbmdCYWNrID0gdHJ1ZTtcbiAgcmV0dXJuIHBlZXJDb25uZWN0aW9uLl9wZWVyQ29ubmVjdGlvbltzZXRMb2NhbERlc2NyaXB0aW9uXShuZXcgRmlyZWZveFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgdHlwZTogJ3JvbGxiYWNrJ1xuICB9KSkudGhlbihvbmNlUm9sbGVkQmFjaykudGhlbihmdW5jdGlvbiBvbmNlUm9sbGVkQmFja1N1Y2NlZWRlZChyZXN1bHQpIHtcbiAgICBwZWVyQ29ubmVjdGlvbi5fcm9sbGluZ0JhY2sgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBmdW5jdGlvbiByb2xsYmFja09yT25jZVJvbGxlZEJhY2tGYWlsZWQoZXJyb3IpIHtcbiAgICBwZWVyQ29ubmVjdGlvbi5fcm9sbGluZ0JhY2sgPSBmYWxzZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSk7XG59XG5cbi8qKlxuICogRXh0cmFjdCB0aGUgaW5pdGlhbGx5IG5lZ290aWF0ZWQgRFRMUyByb2xlIG91dCBvZiBhbiBSVENTZXNzaW9uRGVzY3JpcHRpb24nc1xuICogc2RwIHByb3BlcnR5IGFuZCBzYXZlIGl0IG9uIHRoZSBGaXJlZm94UlRDUGVlckNvbm5lY3Rpb24gaWYgYW5kIG9ubHkgaWZcbiAqXG4gKiAgIDEuIEEgRFRMUyByb2xlIHdhcyBub3QgYWxyZWFkeSBzYXZlZCBvbiB0aGUgRmlyZWZveFJUQ1BlZXJDb25uZWN0aW9uLCBhbmRcbiAqICAgMi4gVGhlIGRlc2NyaXB0aW9uIGlzIGFuIGFuc3dlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGaXJlZm94UlRDUGVlckNvbm5lY3Rpb259IHBlZXJDb25uZWN0aW9uXG4gKiBAcGFyYW0ge1JUQ1Nlc3Npb25EZXNjcmlwdGlvbn0gZGVzY3JpcHRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW90ZT1mYWxzZV0gLSBpZiB0cnVlLCBzYXZlIHRoZSBpbnZlcnNlIG9mIHRoZSBEVExTIHJvbGUsXG4gKiAgIGUuZy4gXCJhY3RpdmVcIiBpbnN0ZWFkIG9mIFwicGFzc2l2ZVwiIGFuZCB2aWNlIHZlcnNhXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBzYXZlSW5pdGlhbGx5TmVnb3RpYXRlZER0bHNSb2xlKHBlZXJDb25uZWN0aW9uLCBkZXNjcmlwdGlvbiwgcmVtb3RlKSB7XG4gIC8vIE5PVEUobXJvYmVydHMpOiBKU0VQIHNwZWNpZmllcyB0aGF0IG9mZmVycyBhbHdheXMgb2ZmZXIgXCJhY3RwYXNzXCIgYXMgdGhlXG4gIC8vIERUTFMgcm9sZS4gV2UgbmVlZCB0byBpbnNwZWN0IGFuc3dlcnMgdG8gZmlndXJlIG91dCB0aGUgbmVnb3RpYXRlZCBEVExTXG4gIC8vIHJvbGUuXG4gIGlmIChwZWVyQ29ubmVjdGlvbi5faW5pdGlhbGx5TmVnb3RpYXRlZER0bHNSb2xlIHx8IGRlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWF0Y2ggPSBkZXNjcmlwdGlvbi5zZHAubWF0Y2goL2E9c2V0dXA6KFthLXpdKykvKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkdGxzUm9sZSA9IG1hdGNoWzFdO1xuICBwZWVyQ29ubmVjdGlvbi5faW5pdGlhbGx5TmVnb3RpYXRlZER0bHNSb2xlID0gcmVtb3RlID8ge1xuICAgIGFjdGl2ZTogJ3Bhc3NpdmUnLFxuICAgIHBhc3NpdmU6ICdhY3RpdmUnXG4gIH1bZHRsc1JvbGVdIDogZHRsc1JvbGU7XG59XG5cbi8qKlxuICogT3ZlcndyaXRlIHRoZSBEVExTIHJvbGUgaW4gdGhlIHNkcCBwcm9wZXJ0eSBvZiBhbiBSVENTZXNzaW9uRGVzY3JpcHRpb24gaWZcbiAqIGFuZCBvbmx5IGlmXG4gKlxuICogICAxLiBUaGUgZGVzY3JpcHRpb24gaXMgYW4gYW5zd2VyLCBhbmRcbiAqICAgMi4gQSBEVExTIHJvbGUgaXMgcHJvdmlkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UlRDU2Vzc2lvbkRlc2NyaXB0aW9ufSBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge3N0cmluZ30gW2R0bHNSb2xlXSAtIG9uZSBvZiBcImFjdGl2ZVwiIG9yIFwicGFzc2l2ZVwiXG4gKiBAcmV0dXJucyB7P1JUQ1Nlc3Npb25EZXNjcmlwdGlvbn0gZGVzY3JpcHRpb25cbiAqL1xuZnVuY3Rpb24gb3ZlcndyaXRlV2l0aEluaXRpYWxseU5lZ290aWF0ZWREdGxzUm9sZShkZXNjcmlwdGlvbiwgZHRsc1JvbGUpIHtcbiAgaWYgKGRlc2NyaXB0aW9uICYmIGRlc2NyaXB0aW9uLnR5cGUgPT09ICdhbnN3ZXInICYmIGR0bHNSb2xlKSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlZm94UlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICBzZHA6IGRlc2NyaXB0aW9uLnNkcC5yZXBsYWNlKC9hPXNldHVwOlthLXpdKy9nLCAnYT1zZXR1cDonICsgZHRsc1JvbGUpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRlc2NyaXB0aW9uO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpcmVmb3hSVENQZWVyQ29ubmVjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICB2YXIgZ3Vlc3NCcm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbCcpLmd1ZXNzQnJvd3NlcjtcbiAgc3dpdGNoIChndWVzc0Jyb3dzZXIoKSkge1xuICAgIGNhc2UgJ2Nocm9tZSc6XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2hyb21lJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmaXJlZm94JzpcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9maXJlZm94Jyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzYWZhcmknOlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NhZmFyaScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gUlRDUGVlckNvbm5lY3Rpb247XG4gICAgICBicmVhaztcbiAgfVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSVENQZWVyQ29ubmVjdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JUQ1BlZXJDb25uZWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfTtcbn1cbiIsIi8qIGdsb2JhbHMgUlRDUGVlckNvbm5lY3Rpb24sIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50dGFyZ2V0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG52YXIgTGF0Y2ggPSByZXF1aXJlKCcuLi91dGlsL2xhdGNoJyk7XG52YXIgc2RwVXRpbHMgPSByZXF1aXJlKCcuLi91dGlsL3NkcCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBpc1VuaWZpZWRQbGFuID0gc2RwVXRpbHMuZ2V0U2RwRm9ybWF0KCkgPT09ICd1bmlmaWVkJztcblxudmFyIHVwZGF0ZVRyYWNrSWRzVG9TU1JDcyA9IGlzVW5pZmllZFBsYW5cbiAgPyBzZHBVdGlscy51cGRhdGVVbmlmaWVkUGxhblRyYWNrSWRzVG9TU1JDc1xuICA6IHNkcFV0aWxzLnVwZGF0ZVBsYW5CVHJhY2tJZHNUb1NTUkNzO1xuXG5mdW5jdGlvbiBTYWZhcmlSVENQZWVyQ29ubmVjdGlvbihjb25maWd1cmF0aW9uKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTYWZhcmlSVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm4gbmV3IFNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICB9XG5cbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICB1dGlsLmludGVyY2VwdEV2ZW50KHRoaXMsICdkYXRhY2hhbm5lbCcpO1xuICB1dGlsLmludGVyY2VwdEV2ZW50KHRoaXMsICdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnKTtcbiAgdXRpbC5pbnRlcmNlcHRFdmVudCh0aGlzLCAnc2lnbmFsaW5nc3RhdGVjaGFuZ2UnKTtcbiAgdXRpbC5pbnRlcmNlcHRFdmVudCh0aGlzLCAndHJhY2snKTtcblxuICB2YXIgcGVlckNvbm5lY3Rpb24gPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oY29uZmlndXJhdGlvbik7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIF9hcHBsaWVkVHJhY2tzVG9TU1JDczoge1xuICAgICAgdmFsdWU6IG5ldyBNYXAoKSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBfYXVkaW9UcmFuc2NlaXZlcjoge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgX2lzQ2xvc2VkOiB7XG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgX3BlZXJDb25uZWN0aW9uOiB7XG4gICAgICB2YWx1ZTogcGVlckNvbm5lY3Rpb25cbiAgICB9LFxuICAgIF9wZW5kaW5nTG9jYWxPZmZlcjoge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgX3BlbmRpbmdSZW1vdGVPZmZlcjoge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgX3JvbGxlZEJhY2tUcmFja3NUb1NTUkNzOiB7XG4gICAgICB2YWx1ZTogbmV3IE1hcCgpLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuICAgIF9zaWduYWxpbmdTdGF0ZUxhdGNoOiB7XG4gICAgICB2YWx1ZTogbmV3IExhdGNoKClcbiAgICB9LFxuICAgIF90cmFja3NUb1NTUkNzOiB7XG4gICAgICB2YWx1ZTogbmV3IE1hcCgpLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuICAgIF92aWRlb1RyYW5zY2VpdmVyOiB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBsb2NhbERlc2NyaXB0aW9uOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdMb2NhbE9mZmVyIHx8IHRoaXMuX3BlZXJDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgfSxcbiAgICBpY2VDb25uZWN0aW9uU3RhdGU6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDbG9zZWQgPyAnY2xvc2VkJyA6IHRoaXMuX3BlZXJDb25uZWN0aW9uLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGljZUdhdGhlcmluZ1N0YXRlOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2xvc2VkID8gJ2NvbXBsZXRlJyA6IHRoaXMuX3BlZXJDb25uZWN0aW9uLmljZUdhdGhlcmluZ1N0YXRlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3RlRGVzY3JpcHRpb246IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ1JlbW90ZU9mZmVyIHx8IHRoaXMuX3BlZXJDb25uZWN0aW9uLnJlbW90ZURlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2lnbmFsaW5nU3RhdGU6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5faXNDbG9zZWQpIHtcbiAgICAgICAgICByZXR1cm4gJ2Nsb3NlZCc7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fcGVuZGluZ0xvY2FsT2ZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gJ2hhdmUtbG9jYWwtb2ZmZXInO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3BlbmRpbmdSZW1vdGVPZmZlcikge1xuICAgICAgICAgIHJldHVybiAnaGF2ZS1yZW1vdGUtb2ZmZXInO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBwZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdkYXRhY2hhbm5lbCcsIGZ1bmN0aW9uIG9uZGF0YWNoYW5uZWwoZXZlbnQpIHtcbiAgICBzaGltRGF0YUNoYW5uZWwoZXZlbnQuY2hhbm5lbCk7XG4gICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSk7XG5cbiAgcGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZnVuY3Rpb24gb25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UoKSB7XG4gICAgaWYgKHNlbGYuX2lzQ2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuZGlzcGF0Y2hFdmVudC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICBwZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdzaWduYWxpbmdzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uIG9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UoKSB7XG4gICAgaWYgKHNlbGYuX2lzQ2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpIHtcbiAgICAgIHNlbGYuX2FwcGxpZWRUcmFja3NUb1NTUkNzID0gbmV3IE1hcChzZWxmLl90cmFja3NUb1NTUkNzKTtcbiAgICB9XG4gICAgaWYgKCFzZWxmLl9wZW5kaW5nTG9jYWxPZmZlciAmJiAhc2VsZi5fcGVuZGluZ1JlbW90ZU9mZmVyKSB7XG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE5PVEUoc3llcnJhcHJhZ2FkYSk6IFRoaXMgZW5zdXJlcyB0aGF0IFNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uJ3MgXCJyZW1vdGVEZXNjcmlwdGlvblwiLCB3aGVuIGFjY2Vzc2VkXG4gIC8vIGluIGFuIFJUQ1RyYWNrRXZlbnQgbGlzdGVuZXIsIHdpbGwgcG9pbnQgdG8gdGhlIHVuZGVybHlpbmcgUlRDUGVlckNvbm5lY3Rpb24nc1xuICAvLyBcInJlbW90ZURlc2NyaXB0aW9uXCIuIEJlZm9yZSB0aGlzIGZpeCwgdGhpcyB3YXMgc3RpbGwgcG9pbnRpbmcgdG8gXCJfcGVuZGluZ1JlbW90ZU9mZmVyXCJcbiAgLy8gZXZlbiB0aG91Z2ggYSBuZXcgcmVtb3RlIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBoYWQgYWxyZWFkeSBiZWVuIGFwcGxpZWQuXG4gIHBlZXJDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgZnVuY3Rpb24gb250cmFjayhldmVudCkge1xuICAgIHNlbGYuX3BlbmRpbmdSZW1vdGVPZmZlciA9IG51bGw7XG4gICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSk7XG5cbiAgdXRpbC5wcm94eVByb3BlcnRpZXMoUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCB0aGlzLCBwZWVyQ29ubmVjdGlvbik7XG59XG5cbmluaGVyaXRzKFNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uLCBFdmVudFRhcmdldCk7XG5cblNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbiBhZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLXJlbW90ZS1vZmZlcicpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmFsaW5nU3RhdGVMYXRjaC53aGVuKCdsb3cnKS50aGVuKGZ1bmN0aW9uIHNpZ25hbGluZ1N0YXRlc1Jlc29sdmVkKCkge1xuICAgICAgcmV0dXJuIHNlbGYuX3BlZXJDb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbn07XG5cblNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gTk9URShtcm9iZXJ0cyk6IEluIGdlbmVyYWwsIHRoaXMgaXMgbm90IHRoZSB3YXkgdG8gZG8gdGhpczsgaG93ZXZlciwgaXQnc1xuICAvLyBnb29kIGVub3VnaCBmb3Igb3VyIGFwcGxpY2F0aW9uLlxuICBpZiAob3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvICYmICF0aGlzLl9hdWRpb1RyYW5zY2VpdmVyICYmICEoaXNVbmlmaWVkUGxhbiAmJiBoYXNSZWNlaXZlcnNGb3JUcmFja3NPZktpbmQodGhpcywgJ2F1ZGlvJykpKSB7XG4gICAgZGVsZXRlIG9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbztcbiAgICB0cnkge1xuICAgICAgdGhpcy5fYXVkaW9UcmFuc2NlaXZlciA9IGlzVW5pZmllZFBsYW5cbiAgICAgICAgPyB0aGlzLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycsIHsgZGlyZWN0aW9uOiAncmVjdm9ubHknIH0pXG4gICAgICAgIDogdGhpcy5hZGRUcmFuc2NlaXZlcignYXVkaW8nKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyAmJiAhdGhpcy5fdmlkZW9UcmFuc2NlaXZlciAmJiAhKGlzVW5pZmllZFBsYW4gJiYgaGFzUmVjZWl2ZXJzRm9yVHJhY2tzT2ZLaW5kKHRoaXMsICd2aWRlbycpKSkge1xuICAgIGRlbGV0ZSBvcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW87XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3ZpZGVvVHJhbnNjZWl2ZXIgPSBpc1VuaWZpZWRQbGFuXG4gICAgICAgID8gdGhpcy5hZGRUcmFuc2NlaXZlcigndmlkZW8nLCB7IGRpcmVjdGlvbjogJ3JlY3Zvbmx5JyB9KVxuICAgICAgICA6IHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVPZmZlcihvcHRpb25zKS50aGVuKGZ1bmN0aW9uKG9mZmVyKSB7XG4gICAgLy8gTk9URShtbWFsYXZhbGxpKTogSWYgY3JlYXRlT2ZmZXIoKSBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgcm9sbGluZyBiYWNrLFxuICAgIC8vIHRoZW4gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gcmV0YWluIHRoZSByb2xsZWQgYmFjayB0cmFja3MgdG8gU1NSQ3MgTWFwLlxuICAgIHNlbGYuX3JvbGxlZEJhY2tUcmFja3NUb1NTUkNzLmNsZWFyKCk7XG5cbiAgICByZXR1cm4gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICB0eXBlOiBvZmZlci50eXBlLFxuICAgICAgc2RwOiB1cGRhdGVUcmFja0lkc1RvU1NSQ3Moc2VsZi5fdHJhY2tzVG9TU1JDcywgb2ZmZXIuc2RwKVxuICAgIH0pO1xuICB9KTtcbn07XG5cblNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIob3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuX3BlbmRpbmdSZW1vdGVPZmZlcikge1xuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbih0aGlzLl9wZW5kaW5nUmVtb3RlT2ZmZXIpLnRoZW4oZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb25TdWNjZWVkZWQoKSB7XG4gICAgICBzZWxmLl9zaWduYWxpbmdTdGF0ZUxhdGNoLmxvd2VyKCk7XG4gICAgICByZXR1cm4gc2VsZi5fcGVlckNvbm5lY3Rpb24uY3JlYXRlQW5zd2VyKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiBjcmVhdGVBbnN3ZXJTdWNjZWVkZWQoYW5zd2VyKSB7XG4gICAgICBzZWxmLl9wZW5kaW5nUmVtb3RlT2ZmZXIgPSBudWxsO1xuXG4gICAgICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBJZiBjcmVhdGVBbnN3ZXIoKSBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgcm9sbGluZyBiYWNrLCB0aGVuIHdlIG5vXG4gICAgICAvLyBsb25nZXIgbmVlZCB0byByZXRhaW4gdGhlIHJvbGxlZCBiYWNrIHRyYWNrcyB0byBTU1JDcyBNYXAuXG4gICAgICBzZWxmLl9yb2xsZWRCYWNrVHJhY2tzVG9TU1JDcy5jbGVhcigpO1xuXG4gICAgICByZXR1cm4gaXNVbmlmaWVkUGxhbiA/IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICB0eXBlOiBhbnN3ZXIudHlwZSxcbiAgICAgICAgc2RwOiB1cGRhdGVUcmFja0lkc1RvU1NSQ3Moc2VsZi5fdHJhY2tzVG9TU1JDcywgYW5zd2VyLnNkcClcbiAgICAgIH0pIDogYW5zd2VyO1xuICAgIH0sIGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uT3JDcmVhdGVBbnN3ZXJGYWlsZWQoZXJyb3IpIHtcbiAgICAgIHNlbGYuX3BlbmRpbmdSZW1vdGVPZmZlciA9IG51bGw7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIob3B0aW9ucykudGhlbihmdW5jdGlvbiBjcmVhdGVBbnN3ZXJTdWNjZWVkZWQoYW5zd2VyKSB7XG4gICAgLy8gTk9URShtbWFsYXZhbGxpKTogSWYgY3JlYXRlQW5zd2VyKCkgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHJvbGxpbmcgYmFjaywgdGhlbiB3ZSBub1xuICAgIC8vIGxvbmdlciBuZWVkIHRvIHJldGFpbiB0aGUgcm9sbGVkIGJhY2sgdHJhY2tzIHRvIFNTUkNzIE1hcC5cbiAgICBzZWxmLl9yb2xsZWRCYWNrVHJhY2tzVG9TU1JDcy5jbGVhcigpO1xuXG4gICAgcmV0dXJuIGlzVW5pZmllZFBsYW4gPyBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGFuc3dlci50eXBlLFxuICAgICAgc2RwOiB1cGRhdGVUcmFja0lkc1RvU1NSQ3Moc2VsZi5fdHJhY2tzVG9TU1JDcywgYW5zd2VyLnNkcClcbiAgICB9KSA6IGFuc3dlcjtcbiAgfSk7XG59O1xuXG5TYWZhcmlSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWwgPSBmdW5jdGlvbiBjcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KSB7XG4gIHZhciBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BlZXJDb25uZWN0aW9uLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBkYXRhQ2hhbm5lbERpY3QpO1xuICBzaGltRGF0YUNoYW5uZWwoZGF0YUNoYW5uZWwpO1xuICByZXR1cm4gZGF0YUNoYW5uZWw7XG59O1xuXG5TYWZhcmlSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgdGhpcy5fcGVlckNvbm5lY3Rpb24ucmVtb3ZlVHJhY2soc2VuZGVyKTtcbn07XG5cblNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0TG9jYWxEZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBJZiBzZXRMb2NhbERlc2NyaXB0aW9uKCkgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHJvbGxpbmcgYmFjayxcbiAgLy8gdGhlbiB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIHJvbGxlZCBiYWNrIHRyYWNrcyB0byBTU1JDcyBNYXAuXG4gIGlmICh0aGlzLl9yb2xsZWRCYWNrVHJhY2tzVG9TU1JDcy5zaXplID4gMCkge1xuICAgIHRoaXMuX3RyYWNrc1RvU1NSQ3MgPSBuZXcgTWFwKHRoaXMuX3JvbGxlZEJhY2tUcmFja3NUb1NTUkNzKTtcbiAgICB0aGlzLl9yb2xsZWRCYWNrVHJhY2tzVG9TU1JDcy5jbGVhcigpO1xuICB9XG4gIHJldHVybiBzZXREZXNjcmlwdGlvbih0aGlzLCB0cnVlLCBkZXNjcmlwdGlvbik7XG59O1xuXG5TYWZhcmlSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBJZiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciByb2xsaW5nIGJhY2ssXG4gIC8vIHRoZW4gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gcmV0YWluIHRoZSByb2xsZWQgYmFjayB0cmFja3MgdG8gU1NSQ3MgTWFwLlxuICB0aGlzLl9yb2xsZWRCYWNrVHJhY2tzVG9TU1JDcy5jbGVhcigpO1xuICByZXR1cm4gc2V0RGVzY3JpcHRpb24odGhpcywgZmFsc2UsIGRlc2NyaXB0aW9uKTtcbn07XG5cblNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICBpZiAodGhpcy5faXNDbG9zZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5faXNDbG9zZWQgPSB0cnVlO1xuICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJykpO1xuICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3NpZ25hbGluZ3N0YXRlY2hhbmdlJykpO1xuICB9KTtcbn07XG5cbnV0aWwuZGVsZWdhdGVNZXRob2RzKFxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsXG4gIFNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSxcbiAgJ19wZWVyQ29ubmVjdGlvbicpO1xuXG5mdW5jdGlvbiBzZXREZXNjcmlwdGlvbihwZWVyQ29ubmVjdGlvbiwgbG9jYWwsIGRlc2NyaXB0aW9uKSB7XG4gIGZ1bmN0aW9uIHNldFBlbmRpbmdMb2NhbE9mZmVyKG9mZmVyKSB7XG4gICAgaWYgKGxvY2FsKSB7XG4gICAgICBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXIgPSBvZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVlckNvbm5lY3Rpb24uX3BlbmRpbmdSZW1vdGVPZmZlciA9IG9mZmVyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyUGVuZGluZ0xvY2FsT2ZmZXIoKSB7XG4gICAgaWYgKGxvY2FsKSB7XG4gICAgICBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ1JlbW90ZU9mZmVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0xvY2FsT2ZmZXIgPSBsb2NhbCA/IHBlZXJDb25uZWN0aW9uLl9wZW5kaW5nTG9jYWxPZmZlciA6IHBlZXJDb25uZWN0aW9uLl9wZW5kaW5nUmVtb3RlT2ZmZXI7XG4gIHZhciBwZW5kaW5nUmVtb3RlT2ZmZXIgPSBsb2NhbCA/IHBlZXJDb25uZWN0aW9uLl9wZW5kaW5nUmVtb3RlT2ZmZXIgOiBwZWVyQ29ubmVjdGlvbi5fcGVuZGluZ0xvY2FsT2ZmZXI7XG4gIHZhciBpbnRlcm1lZGlhdGVTdGF0ZSA9IGxvY2FsID8gJ2hhdmUtbG9jYWwtb2ZmZXInIDogJ2hhdmUtcmVtb3RlLW9mZmVyJztcbiAgdmFyIHNldExvY2FsRGVzY3JpcHRpb24gPSBsb2NhbCA/ICdzZXRMb2NhbERlc2NyaXB0aW9uJyA6ICdzZXRSZW1vdGVEZXNjcmlwdGlvbic7XG5cbiAgaWYgKCFsb2NhbCAmJiBwZW5kaW5nUmVtb3RlT2ZmZXIgJiYgZGVzY3JpcHRpb24udHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICByZXR1cm4gc2V0UmVtb3RlQW5zd2VyKHBlZXJDb25uZWN0aW9uLCBkZXNjcmlwdGlvbik7XG4gIH0gZWxzZSBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykge1xuICAgIGlmIChwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSAhPT0gaW50ZXJtZWRpYXRlU3RhdGUgJiYgcGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUgIT09ICdzdGFibGUnKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDYW5ub3Qgc2V0ICcgKyAobG9jYWwgPyAnbG9jYWwnIDogJ3JlbW90ZScpICtcbiAgICAgICAgJyBvZmZlciBpbiBzdGF0ZSAnICsgcGVlckNvbm5lY3Rpb24uc2lnbmFsaW5nU3RhdGUpKTtcbiAgICB9XG5cbiAgICBpZiAoIXBlbmRpbmdMb2NhbE9mZmVyICYmIHBlZXJDb25uZWN0aW9uLl9zaWduYWxpbmdTdGF0ZUxhdGNoLnN0YXRlID09PSAnbG93Jykge1xuICAgICAgcGVlckNvbm5lY3Rpb24uX3NpZ25hbGluZ1N0YXRlTGF0Y2gucmFpc2UoKTtcbiAgICB9XG4gICAgdmFyIHByZXZpb3VzU2lnbmFsaW5nU3RhdGUgPSBwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZTtcbiAgICBzZXRQZW5kaW5nTG9jYWxPZmZlcihkZXNjcmlwdGlvbik7XG5cbiAgICAvLyBPbmx5IGRpc3BhdGNoIGEgc2lnbmFsaW5nc3RhdGVjaGFuZ2UgZXZlbnQgaWYgd2UgdHJhbnNpdGlvbmVkLlxuICAgIGlmIChwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSAhPT0gcHJldmlvdXNTaWduYWxpbmdTdGF0ZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gZGlzcGF0Y2hTaWduYWxpbmdTdGF0ZUNoYW5nZUV2ZW50KCkge1xuICAgICAgICBwZWVyQ29ubmVjdGlvbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc2lnbmFsaW5nc3RhdGVjaGFuZ2UnKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH0gZWxzZSBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ3JvbGxiYWNrJykge1xuICAgIGlmIChwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSAhPT0gaW50ZXJtZWRpYXRlU3RhdGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0Nhbm5vdCByb2xsYmFjayAnICtcbiAgICAgICAgKGxvY2FsID8gJ2xvY2FsJyA6ICdyZW1vdGUnKSArICcgZGVzY3JpcHRpb24gaW4gJyArIHBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlKSk7XG4gICAgfVxuICAgIGNsZWFyUGVuZGluZ0xvY2FsT2ZmZXIoKTtcblxuICAgIC8vIE5PVEUobW1hbGF2YWxsaSk6IFdlIHN0b3JlIHRoZSByb2xsZWQgYmFjayB0cmFja3MgdG8gU1NSQ3MgTWFwIGhlcmUgaW4gY2FzZVxuICAgIC8vIHNldExvY2FsRGVzY3JpcHRpb24oKSBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXJhIHJvbGxiYWNrICh3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBjcmVhdGVPZmZlcigpIG9yIGNyZWF0ZUFuc3dlcigpKSwgaW4gd2hpY2ggY2FzZSB0aGlzIHJvbGwgYmFjayBpcyBub3QgZHVlIHRvXG4gICAgLy8gYSBnbGFyZSBzY2VuYXJpbyBhbmQgdGhpcyBNYXAgc2hvdWxkIGJlIHJlc3RvcmVkLlxuICAgIHBlZXJDb25uZWN0aW9uLl9yb2xsZWRCYWNrVHJhY2tzVG9TU1JDcyA9IG5ldyBNYXAocGVlckNvbm5lY3Rpb24uX3RyYWNrc1RvU1NSQ3MpO1xuICAgIHBlZXJDb25uZWN0aW9uLl90cmFja3NUb1NTUkNzID0gbmV3IE1hcChwZWVyQ29ubmVjdGlvbi5fYXBwbGllZFRyYWNrc1RvU1NSQ3MpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gZGlzcGF0Y2hTaWduYWxpbmdTdGF0ZUNoYW5nZUV2ZW50KCkge1xuICAgICAgcGVlckNvbm5lY3Rpb24uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3NpZ25hbGluZ3N0YXRlY2hhbmdlJykpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBlZXJDb25uZWN0aW9uLl9wZWVyQ29ubmVjdGlvbltzZXRMb2NhbERlc2NyaXB0aW9uXShkZXNjcmlwdGlvbik7XG59XG5cbmZ1bmN0aW9uIHNldFJlbW90ZUFuc3dlcihwZWVyQ29ubmVjdGlvbiwgYW5zd2VyKSB7XG4gIHZhciBwZW5kaW5nTG9jYWxPZmZlciA9IHBlZXJDb25uZWN0aW9uLl9wZW5kaW5nTG9jYWxPZmZlcjtcbiAgcmV0dXJuIHBlZXJDb25uZWN0aW9uLl9wZWVyQ29ubmVjdGlvbi5zZXRMb2NhbERlc2NyaXB0aW9uKHBlbmRpbmdMb2NhbE9mZmVyKS50aGVuKGZ1bmN0aW9uIHNldExvY2FsT2ZmZXJTdWNjZWVkZWQoKSB7XG4gICAgcGVlckNvbm5lY3Rpb24uX3BlbmRpbmdMb2NhbE9mZmVyID0gbnVsbDtcbiAgICByZXR1cm4gcGVlckNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiBzZXRSZW1vdGVBbnN3ZXJTdWNjZWVkZWQoKSB7XG4gICAgcGVlckNvbm5lY3Rpb24uX3NpZ25hbGluZ1N0YXRlTGF0Y2gubG93ZXIoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogV2hldGhlciBhIFNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uIGhhcyBhbnkgUlRDUnRwUmVjZWl2ZXJzKHMpIGZvciB0aGUgZ2l2ZW5cbiAqIE1lZGlhU3RyZWFtVHJhY2sga2luZC5cbiAqIEBwYXJhbSB7U2FmYXJpUlRDUGVlckNvbm5lY3Rpb259IHBlZXJDb25uZWN0aW9uXG4gKiBAcGFyYW0geydhdWRpbycgfCAndmlkZW8nfSBraW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzUmVjZWl2ZXJzRm9yVHJhY2tzT2ZLaW5kKHBlZXJDb25uZWN0aW9uLCBraW5kKSB7XG4gIHJldHVybiAhIXBlZXJDb25uZWN0aW9uLmdldFRyYW5zY2VpdmVycygpLmZpbmQoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICByZXR1cm4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIgJiYgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sgJiYgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0ga2luZDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2hpbSBhbiBSVENEYXRhQ2hhbm5lbC4gVGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSBSVENEYXRhQ2hhbm5lbC5cbiAqIEBwYXJhbSB7UlRDRGF0YUNoYW5uZWx9IGRhdGFDaGFubmVsXG4gKiBAcmV0dXJucyB7UlRDRGF0YUNoYW5uZWx9XG4gKi9cbmZ1bmN0aW9uIHNoaW1EYXRhQ2hhbm5lbChkYXRhQ2hhbm5lbCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGF0YUNoYW5uZWwsIHtcbiAgICBtYXhQYWNrZXRMaWZlVGltZToge1xuICAgICAgdmFsdWU6IGRhdGFDaGFubmVsLm1heFBhY2tldExpZmVUaW1lID09PSA2NTUzNVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBkYXRhQ2hhbm5lbC5tYXhQYWNrZXRMaWZlVGltZVxuICAgIH0sXG4gICAgbWF4UmV0cmFuc21pdHM6IHtcbiAgICAgIHZhbHVlOiBkYXRhQ2hhbm5lbC5tYXhSZXRyYW5zbWl0cyA9PT0gNjU1MzVcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogZGF0YUNoYW5uZWwubWF4UmV0cmFuc21pdHNcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNhZmFyaVJUQ1BlZXJDb25uZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJUQ1J0cFNlbmRlciBzaGltLlxuICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICogQHByb3BlcnR5IHtNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICovXG5mdW5jdGlvbiBSVENSdHBTZW5kZXJTaGltKHRyYWNrKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICB0cmFjazoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB0cmFjayxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbn1cblxuLy8gTk9URShtbWFsYXZhbGxpKTogQmVjYXVzZSBvZiB0aGUgd2F5IHdlIHdpbGwgYmUgdXNpbmcgdGhpcyBzaGltLCB0aGVyZVxuLy8gYXJlIGEgY291cGxlIG9mIHVzZSBjYXNlcyB0aGF0IHdpbGwgbm90IGJlIGNvdmVyZWQ6XG4vL1xuLy8gLyogQ2FzZSAxICovXG4vLyBjb25zdCBzZW5kZXIgPSBwYy5hZGRUcmFjayh0cmFjayk7XG4vLyBhc3NlcnQuZXF1YWwoc2VuZGVyLnRyYWNrLCB0cmFjayk7XG4vLyBwYy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuLy8gYXNzZXJ0LmVxdWFsKHNlbmRlci50cmFjaywgbnVsbCk7IC8qIEVycm9yICovXG4vL1xuLy8gLyogQ2FzZSAyICovXG4vLyBjb25zdCBzZW5kZXIgPSBwYy5hZGRUcmFjayh0cmFjayk7XG4vLyBjb25zdCBzZW5kZXJzMSA9IG5ldyBTZXQocGMuZ2V0U2VuZGVycygpKTtcbi8vIGFzc2VydChzZW5kZXJzMS5oYXMoc2VuZGVyKSk7XG4vLyBwYy5yZW1vdmVUcmFjayh0cmFjayk7XG4vLyBjb25zdCBzZW5kZXJzMiA9IG5ldyBTZXQocGMuZ2V0U2VuZGVycygpKTtcbi8vIGFzc2VydChzZW5kZXJzMi5oYXMoc2VuZGVyKSk7IC8qIEVycm9yICovXG4vL1xuLy8gRm9yIG5vdywgc2luY2Ugd2Ugb25seSB1c2Ugc2VuZGVycyBmb3IgcGFzc2luZyB0aGVtIHRvIFJUQ1BlZXJDb25uZWN0aW9uI3JlbW92ZVRyYWNrKCksXG4vLyB3ZSB3aWxsIG9taXQgaGFuZGxpbmcgdGhlc2UgdXNlIGNhc2VzIGZvciBub3csIGFuZCByZXZpc2l0IHRoZW0gd2hlbiB3ZSBzdGFydFxuLy8gdXNpbmcgdGhlIFJUQ1J0cFNlbmRlciBBUElzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJUQ1J0cFNlbmRlclNoaW07XG4iLCIvKiBnbG9iYWxzIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGNsYXNzIHdyYXBzIENocm9tZSdzIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBpbXBsZW1lbnRhdGlvbi4gSXQgcHJvdmlkZXNcbi8vIG9uZSBwaWVjZSBvZiBmdW5jdGlvbmFsaXR5IG5vdCBjdXJyZW50bHkgcHJlc2VudCBpbiBDaHJvbWUsIG5hbWVseVxuLy9cbi8vICAgMS4gUm9sbGJhY2sgc3VwcG9ydFxuLy8gICAgICBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NDY3NlxuLy9cbmZ1bmN0aW9uIENocm9tZVJUQ1Nlc3Npb25EZXNjcmlwdGlvbihkZXNjcmlwdGlvbkluaXREaWN0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDaHJvbWVSVENTZXNzaW9uRGVzY3JpcHRpb24pKSB7XG4gICAgcmV0dXJuIG5ldyBDaHJvbWVSVENTZXNzaW9uRGVzY3JpcHRpb24oZGVzY3JpcHRpb25Jbml0RGljdCk7XG4gIH1cblxuICAvLyBJZiB0aGlzIGNvbnN0cnVjdG9yIGlzIGNhbGxlZCB3aXRoIGFuIG9iamVjdCB3aXRoIGEgLnR5cGUgcHJvcGVydHkgc2V0IHRvXG4gIC8vIFwicm9sbGJhY2tcIiwgd2Ugc2hvdWxkIG5vdCBjYWxsIENocm9tZSdzIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBjb25zdHJ1Y3RvcixcbiAgLy8gYmVjYXVzZSB0aGlzIHdvdWxkIHRocm93IGFuIFJUQ1NkcFR5cGUgZXJyb3IuXG4gIHZhciBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uSW5pdERpY3QgJiYgZGVzY3JpcHRpb25Jbml0RGljdC50eXBlID09PSAncm9sbGJhY2snXG4gICAgPyBudWxsXG4gICAgOiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uSW5pdERpY3QpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICBfZGVzY3JpcHRpb246IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNkcDoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBkZXNjcmlwdGlvbiA/IGRlc2NyaXB0aW9uLnNkcCA6IGRlc2NyaXB0aW9uSW5pdERpY3Quc2RwXG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGRlc2NyaXB0aW9uID8gZGVzY3JpcHRpb24udHlwZSA6IGRlc2NyaXB0aW9uSW5pdERpY3QudHlwZVxuICAgIH1cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hyb21lUlRDU2Vzc2lvbkRlc2NyaXB0aW9uO1xuIiwiLyogZ2xvYmFscyBSVENTZXNzaW9uRGVzY3JpcHRpb24gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSVENTZXNzaW9uRGVzY3JpcHRpb247XG4iLCIvKiBnbG9iYWxzIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICB2YXIgZ3Vlc3NCcm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbCcpLmd1ZXNzQnJvd3NlcjtcbiAgc3dpdGNoIChndWVzc0Jyb3dzZXIoKSkge1xuICAgIGNhc2UgJ2Nocm9tZSc6XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2hyb21lJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmaXJlZm94JzpcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9maXJlZm94Jyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBSVENTZXNzaW9uRGVzY3JpcHRpb247XG4gICAgICBicmVhaztcbiAgfVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSVENTZXNzaW9uRGVzY3JpcHRpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSVENTZXNzaW9uRGVzY3JpcHRpb24gaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4vKipcbiAqIEV2ZW50IHRhcmdldC5cbiAqIEBjbGFzc1xuICovXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIF9ldmVudEVtaXR0ZXI6IHtcbiAgICAgIHZhbHVlOiBuZXcgRXZlbnRFbWl0dGVyKClcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGFuIEV2ZW50IHRvIHRoZSB7QGxpbmsgRXZlbnRUYXJnZXR9LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiB0aGlzLl9ldmVudEVtaXR0ZXIuZW1pdChldmVudC50eXBlLCBldmVudCk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBFdmVudCBsaXN0ZW5lciB0byB0aGUge0BsaW5rIEV2ZW50VGFyZ2V0fS5cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRFbWl0dGVyLmFkZExpc3RlbmVyLmFwcGx5KHRoaXMuX2V2ZW50RW1pdHRlciwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIEV2ZW50IGxpc3RlbmVyIHRvIHRoZSB7QGxpbmsgRXZlbnRUYXJnZXR9LlxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIuYXBwbHkodGhpcy5fZXZlbnRFbWl0dGVyLCBhcmd1bWVudHMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGUgYSB7QGxpbmsgRGVmZXJyZWR9LlxuICogQHJldHVybnMge0RlZmVycmVkfVxuICovXG5mdW5jdGlvbiBkZWZlcigpIHtcbiAgdmFyIGRlZmVycmVkID0ge307XG4gIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBkZWZlcnJlZC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICBkZWZlcnJlZC5yZWplY3QgPSByZWplY3Q7XG4gIH0pO1xuICByZXR1cm4gZGVmZXJyZWQ7XG59XG5cbi8qKlxuICogQ29weSBhIG1ldGhvZCBmcm9tIGEgYHNvdXJjZWAgcHJvdG90eXBlIG9udG8gYSBgd3JhcHBlcmAgcHJvdG90eXBlLiBJbnZva2luZ1xuICogdGhlIG1ldGhvZCBvbiB0aGUgYHdyYXBwZXJgIHByb3RvdHlwZSB3aWxsIGludm9rZSB0aGUgY29ycmVzcG9uZGluZyBtZXRob2RcbiAqIG9uIGFuIGluc3RhbmNlIGFjY2Vzc2VkIGJ5IGB0YXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZVxuICogQHBhcmFtIHtvYmplY3R9IHdyYXBwZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBkZWxlZ2F0ZU1ldGhvZChzb3VyY2UsIHdyYXBwZXIsIHRhcmdldCwgbWV0aG9kTmFtZSkge1xuICBpZiAobWV0aG9kTmFtZSBpbiB3cmFwcGVyKSB7XG4gICAgLy8gU2tpcCBhbnkgbWV0aG9kcyBhbHJlYWR5IHNldC5cbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAobWV0aG9kTmFtZS5tYXRjaCgvXm9uW2Etel0rJC8pKSB7XG4gICAgLy8gU2tpcCBFdmVudEhhbmRsZXJzICh0aGVzZSBhcmUgaGFuZGxlZCBpbiB0aGUgY29uc3RydWN0b3IpLlxuICAgIHJldHVybjtcbiAgfVxuXG5cbiAgdmFyIGlzUHJvcGVydHkgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgcHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgbWV0aG9kTmFtZSk7XG4gICAgaXNQcm9wZXJ0eSA9IHByb3BEZXNjICYmICEhcHJvcERlc2MuZ2V0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIGl0cyBva2F5IHRvIGVhdCBmYWlsdXJlIGhlcmUuXG4gIH1cblxuICAvLyBOT1RFKG1wYXR3YXJkaGFuKTpza2lwIHByb3BlcnRpZXMuIHdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gb3ZlcnJpZGluZ1xuICAvLyBmdW5jdGlvbnMuIHdlIGRvIG5vdCBldmVuIHdhbnQgdG8gZXZhbHVhdGUgIGB0eXBlb2Ygc291cmNlW21ldGhvZE5hbWVdYCBmb3IgcHJvcGVydGllc1xuICAvLyBiZWNhdXNlIGdldHRlciB3b3VsZCBnZXQgaW52b2tlZCwgYW5kIHRoZXkgbWlnaHQgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gIC8vIEZvciBleGFtcGxlIFJUQ1BlZXJDb25uZWN0aW9uLnBlZXJJZGVudGl0eSBpcyBhIHByb3BlcnR5IHRoYXQgcmV0dXJucyBhIHByb21pc2UuXG4gIC8vIGNhbGxpbmcgdHlwZW9mIFJUQ1BlZXJDb25uZWN0aW9uLnBlZXJJZGVudGl0eSwgd291bGQgbGVhayBhIHByb21pc2UsIGFuZCBpbiBjYXNlIGl0IHJlamVjdHNcbiAgLy8gd2Ugc2VlIGVycm9ycy5cbiAgaWYgKGlzUHJvcGVydHkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdHlwZTtcbiAgdHJ5IHtcbiAgICB0eXBlID0gdHlwZW9mIHNvdXJjZVttZXRob2ROYW1lXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBOT1RFKG1yb2JlcnRzKTogQXR0ZW1wdGluZyB0byBjaGVjayB0aGUgdHlwZSBvZiBub24tZnVuY3Rpb24gbWVtYmVyc1xuICAgIC8vIG9uIHRoZSBwcm90b3R5cGUgdGhyb3dzIGFuIGVycm9yIGZvciBzb21lIHR5cGVzLlxuICB9XG5cbiAgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBTa2lwIG5vbi1mdW5jdGlvbiBtZW1iZXJzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qIGVzbGludCBuby1sb29wLWZ1bmM6MCAqL1xuICB3cmFwcGVyW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXNbdGFyZ2V0XVttZXRob2ROYW1lXS5hcHBseSh0aGlzW3RhcmdldF0sIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29weSBtZXRob2RzIGZyb20gYSBgc291cmNlYCBwcm90b3R5cGUgb250byBhIGB3cmFwcGVyYCBwcm90b3R5cGUuIEludm9raW5nXG4gKiB0aGUgbWV0aG9kcyBvbiB0aGUgYHdyYXBwZXJgIHByb3RvdHlwZSB3aWxsIGludm9rZSB0aGUgY29ycmVzcG9uZGluZyBtZXRob2RcbiAqIG9uIGFuIGluc3RhbmNlIGFjY2Vzc2VkIGJ5IGB0YXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZVxuICogQHBhcmFtIHtvYmplY3R9IHdyYXBwZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGRlbGVnYXRlTWV0aG9kcyhzb3VyY2UsIHdyYXBwZXIsIHRhcmdldCkge1xuICBmb3IgKHZhciBtZXRob2ROYW1lIGluIHNvdXJjZSkge1xuICAgIGRlbGVnYXRlTWV0aG9kKHNvdXJjZSwgd3JhcHBlciwgdGFyZ2V0LCBtZXRob2ROYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBpdGVtcyBpbiBsaXN0MSB0aGF0IGFyZSBub3QgaW4gbGlzdDIuXG4gKiBAcGFyYW0ge0FycmF5PCo+fE1hcDwqPnxTZXQ8Kj59IGxpc3QxXG4gKiBAcGFyYW0ge0FycmF5PCo+fE1hcDwqPnxTZXQ8Kj59IGxpc3QyXG4gKiBAcmV0dXJucyB7U2V0fVxuICovXG5mdW5jdGlvbiBkaWZmZXJlbmNlKGxpc3QxLCBsaXN0Mikge1xuICBsaXN0MSA9IEFycmF5LmlzQXJyYXkobGlzdDEpID8gbmV3IFNldChsaXN0MSkgOiBuZXcgU2V0KGxpc3QxLnZhbHVlcygpKTtcbiAgbGlzdDIgPSBBcnJheS5pc0FycmF5KGxpc3QyKSA/IG5ldyBTZXQobGlzdDIpIDogbmV3IFNldChsaXN0Mi52YWx1ZXMoKSk7XG5cbiAgdmFyIGRpZmZlcmVuY2UgPSBuZXcgU2V0KCk7XG5cbiAgbGlzdDEuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgaWYgKCFsaXN0Mi5oYXMoaXRlbSkpIHtcbiAgICAgIGRpZmZlcmVuY2UuYWRkKGl0ZW0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRpZmZlcmVuY2U7XG59XG5cbi8qKlxuICogTWFwIGEgbGlzdCB0byBhbiBhcnJheSBvZiBhcnJheXMsIGFuZCByZXR1cm4gdGhlIGZsYXR0ZW5lZCByZXN1bHQuXG4gKiBAcGFyYW0ge0FycmF5PCo+fFNldDwqPnxNYXA8Kj59IGxpc3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKik6IEFycmF5PCo+fSBtYXBGblxuICogQHJldHVybnMgQXJyYXk8Kj5cbiAqL1xuZnVuY3Rpb24gZmxhdE1hcChsaXN0LCBtYXBGbikge1xuICB2YXIgbGlzdEFycmF5ID0gbGlzdCBpbnN0YW5jZW9mIE1hcCB8fCBsaXN0IGluc3RhbmNlb2YgU2V0XG4gICAgPyBBcnJheS5mcm9tKGxpc3QudmFsdWVzKCkpXG4gICAgOiBsaXN0O1xuXG4gIHJldHVybiBsaXN0QXJyYXkucmVkdWNlKGZ1bmN0aW9uKGZsYXR0ZW5lZCwgaXRlbSkge1xuICAgIHZhciBtYXBwZWQgPSBtYXBGbihpdGVtKTtcbiAgICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChtYXBwZWQpO1xuICB9LCBbXSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBicm93c2VyJ3MgdXNlciBhZ2VudCwgaWYgYXZhaWxhYmxlLlxuICogQHJldHVybnMgez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnc3RyaW5nJ1xuICAgID8gbmF2aWdhdG9yLnVzZXJBZ2VudFxuICAgIDogbnVsbDtcbn1cblxuLyoqXG4gKiBHdWVzcyB0aGUgYnJvd3Nlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlckFnZW50PW5hdmlnYXRvci51c2VyQWdlbnRdXG4gKiBAcmV0dXJucyB7P3N0cmluZ30gYnJvd3NlciAtIFwiY2hyb21lXCIsIFwiZmlyZWZveFwiLCBcInNhZmFyaVwiLCBvciBudWxsXG4gKi9cbmZ1bmN0aW9uIGd1ZXNzQnJvd3Nlcih1c2VyQWdlbnQpIHtcbiAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gIH1cbiAgaWYgKC9DaHJvbWV8Q3JpT1MvLnRlc3QodXNlckFnZW50KSkge1xuICAgIHJldHVybiAnY2hyb21lJztcbiAgfVxuICBpZiAoL0ZpcmVmb3h8RnhpT1MvLnRlc3QodXNlckFnZW50KSkge1xuICAgIHJldHVybiAnZmlyZWZveCc7XG4gIH1cbiAgaWYgKC9TYWZhcmkvLnRlc3QodXNlckFnZW50KSkge1xuICAgIHJldHVybiAnc2FmYXJpJztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHdWVzcyB0aGUgYnJvd3NlciB2ZXJzaW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFt1c2VyQWdlbnQ9bmF2aWdhdG9yLnVzZXJBZ2VudF1cbiAqIEByZXR1cm5zIHs/e21ham9yOiBudW1iZXIsIG1pbm9yOiBudW1iZXJ9fVxuICovXG5mdW5jdGlvbiBndWVzc0Jyb3dzZXJWZXJzaW9uKHVzZXJBZ2VudCkge1xuICBpZiAodHlwZW9mIHVzZXJBZ2VudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB1c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnQoKTtcbiAgfVxuICB2YXIgcHJlZml4ID0ge1xuICAgIGNocm9tZTogJ0Nocm9tZXxDcmlPUycsXG4gICAgZmlyZWZveDogJ0ZpcmVmb3h8RnhpT1MnLFxuICAgIHNhZmFyaTogJ1ZlcnNpb24nXG4gIH1bZ3Vlc3NCcm93c2VyKHVzZXJBZ2VudCldO1xuXG4gIGlmICghcHJlZml4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnKCcgKyBwcmVmaXggKyAnKS8oW15cXFxcc10rKScpO1xuICB2YXIgbWF0Y2ggPSAodXNlckFnZW50Lm1hdGNoKHJlZ2V4KSB8fCBbXSlbMl07XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciB2ZXJzaW9ucyA9IG1hdGNoLnNwbGl0KCcuJykubWFwKE51bWJlcik7XG4gIHJldHVybiB7XG4gICAgbWFqb3I6IGlzTmFOKHZlcnNpb25zWzBdKSA/IG51bGwgOiB2ZXJzaW9uc1swXSxcbiAgICBtaW5vcjogaXNOYU4odmVyc2lvbnNbMV0pID8gbnVsbCA6IHZlcnNpb25zWzFdXG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIGlzIGlPUyBDaHJvbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VzZXJBZ2VudD1uYXZpZ2F0b3IudXNlckFnZW50XVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzSU9TQ2hyb21lKHVzZXJBZ2VudCkge1xuICBpZiAodHlwZW9mIHVzZXJBZ2VudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB1c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnQoKTtcbiAgfVxuICByZXR1cm4gKC9Nb2JpLy50ZXN0KHVzZXJBZ2VudCkgJiYgZ3Vlc3NCcm93c2VyKCkgPT09ICdjaHJvbWUnICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KHVzZXJBZ2VudCkpO1xufVxuXG4vKipcbiAqIEludGVyY2VwdCBhbiBldmVudCB0aGF0IG1pZ2h0IG90aGVyd2lzZSBiZSBwcm94aWVkIG9uIGFuIEV2ZW50VGFyZ2V0LlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGludGVyY2VwdEV2ZW50KHRhcmdldCwgdHlwZSkge1xuICB2YXIgY3VycmVudExpc3RlbmVyID0gbnVsbDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJ29uJyArIHR5cGUsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRMaXN0ZW5lcjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24obmV3TGlzdGVuZXIpIHtcbiAgICAgIGlmIChjdXJyZW50TGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbmV3TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY3VycmVudExpc3RlbmVyID0gbmV3TGlzdGVuZXI7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjdXJyZW50TGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudExpc3RlbmVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBmdW5jdGlvbiBmb3IgdHVybmluZyBhIFByb21pc2UgaW50byB0aGUga2luZCByZWZlcmVuY2VkIGluIHRoZVxuICogTGVnYWN5IEludGVyZmFjZSBFeHRlbnNpb25zIHNlY3Rpb24gb2YgdGhlIFdlYlJUQyBzcGVjLlxuICogQHBhcmFtIHtQcm9taXNlPCo+fSBwcm9taXNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uPCo+fSBvblN1Y2Nlc3NcbiAqIEBwYXJhbSB7ZnVuY3Rpb248RXJyb3I+fSBvbkZhaWx1cmVcbiAqIEByZXR1cm5zIHtQcm9taXNlPHVuZGVmaW5lZD59XG4gKi9cbmZ1bmN0aW9uIGxlZ2FjeVByb21pc2UocHJvbWlzZSwgb25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgaWYgKG9uU3VjY2Vzcykge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBvblN1Y2Nlc3MocmVzdWx0KTtcbiAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgb25GYWlsdXJlKGVycm9yKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBNYWtlIGEgdW5pcXVlIElELlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBtYWtlVVVJRCgpIHtcbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMDtcbiAgICB2YXIgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBGb3IgZWFjaCBwcm9wZXJ0eSBuYW1lIG9uIHRoZSBgc291cmNlYCBwcm90b3R5cGUsIGFkZCBnZXR0ZXJzIGFuZC9vciBzZXR0ZXJzXG4gKiB0byBgd3JhcHBlcmAgdGhhdCBwcm94eSB0byBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSB3cmFwcGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBwcm94eVByb3BlcnRpZXMoc291cmNlLCB3cmFwcGVyLCB0YXJnZXQpIHtcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5TmFtZSkge1xuICAgIHByb3h5UHJvcGVydHkoc291cmNlLCB3cmFwcGVyLCB0YXJnZXQsIHByb3BlcnR5TmFtZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEZvciB0aGUgcHJvcGVydHkgbmFtZSBvbiB0aGUgYHNvdXJjZWAgcHJvdG90eXBlLCBhZGQgYSBnZXR0ZXIgYW5kL29yIHNldHRlclxuICogdG8gYHdyYXBwZXJgIHRoYXQgcHJveGllcyB0byBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSB3cmFwcGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBwcm94eVByb3BlcnR5KHNvdXJjZSwgd3JhcHBlciwgdGFyZ2V0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgaWYgKHByb3BlcnR5TmFtZSBpbiB3cmFwcGVyKSB7XG4gICAgLy8gU2tpcCBhbnkgcHJvcGVydGllcyBhbHJlYWR5IHNldC5cbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAocHJvcGVydHlOYW1lLm1hdGNoKC9eb25bYS16XSskLykpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod3JhcHBlciwgcHJvcGVydHlOYW1lLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihwcm9wZXJ0eU5hbWUuc2xpY2UoMiksIGZ1bmN0aW9uKCkge1xuICAgICAgd3JhcHBlci5kaXNwYXRjaEV2ZW50LmFwcGx5KHdyYXBwZXIsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod3JhcHBlciwgcHJvcGVydHlOYW1lLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eU5hbWVdO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBuYXRpdmUgV2ViUlRDIEFQSXMgYXJlIHN1cHBvcnRlZC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBzdXBwb3J0KCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgUlRDUGVlckNvbm5lY3Rpb24gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gRGVmZXJyZWRcbiAqIEBwcm9wZXJ0eSB7UHJvbWlzZX0gcHJvbWlzZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcmVqZWN0XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSByZXNvbHZlXG4gKi9cblxuZXhwb3J0cy5kZWZlciA9IGRlZmVyO1xuZXhwb3J0cy5kZWxlZ2F0ZU1ldGhvZHMgPSBkZWxlZ2F0ZU1ldGhvZHM7XG5leHBvcnRzLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuZXhwb3J0cy5mbGF0TWFwID0gZmxhdE1hcDtcbmV4cG9ydHMuZ3Vlc3NCcm93c2VyID0gZ3Vlc3NCcm93c2VyO1xuZXhwb3J0cy5ndWVzc0Jyb3dzZXJWZXJzaW9uID0gZ3Vlc3NCcm93c2VyVmVyc2lvbjtcbmV4cG9ydHMuaXNJT1NDaHJvbWUgPSBpc0lPU0Nocm9tZTtcbmV4cG9ydHMuaW50ZXJjZXB0RXZlbnQgPSBpbnRlcmNlcHRFdmVudDtcbmV4cG9ydHMubGVnYWN5UHJvbWlzZSA9IGxlZ2FjeVByb21pc2U7XG5leHBvcnRzLm1ha2VVVUlEID0gbWFrZVVVSUQ7XG5leHBvcnRzLnByb3h5UHJvcGVydGllcyA9IHByb3h5UHJvcGVydGllcztcbmV4cG9ydHMuc3VwcG9ydCA9IHN1cHBvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZlciA9IHJlcXVpcmUoJy4vJykuZGVmZXI7XG5cbnZhciBzdGF0ZXMgPSB7XG4gIGhpZ2g6IG5ldyBTZXQoWydsb3cnXSksXG4gIGxvdzogbmV3IFNldChbJ2hpZ2gnXSlcbn07XG5cbi8qKlxuICogQ29uc3RydWN0IGEge0BsaW5rIExhdGNofS5cbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBBIHtAbGluayBMYXRjaH0gaGFzIHR3byBzdGF0ZXMgKFwiaGlnaFwiIGFuZCBcImxvd1wiKSBhbmQgbWV0aG9kcyBmb3JcbiAqIHRyYW5zaXRpb25pbmcgYmV0d2VlbiB0aGVtICh7QGxpbmsgTGF0Y2gjcmFpc2V9IGFuZCB7QGxpbmsgTGF0Y2gjbG93ZXJ9KS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbaW5pdGlhbFN0YXRlPVwibG93XCJdIC0gZWl0aGVyIFwiaGlnaFwiIG9yIFwibG93XCJcbiAqL1xuZnVuY3Rpb24gTGF0Y2goaW5pdGlhbFN0YXRlKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMYXRjaCkpIHtcbiAgICByZXR1cm4gbmV3IExhdGNoKGluaXRpYWxTdGF0ZSk7XG4gIH1cbiAgdmFyIHN0YXRlID0gaW5pdGlhbFN0YXRlIHx8ICdsb3cnO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgX3N0YXRlOiB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgIT09IF9zdGF0ZSkge1xuICAgICAgICAgIHN0YXRlID0gX3N0YXRlO1xuICAgICAgICAgIHZhciB3aGVuRGVmZXJyZWRzID0gdGhpcy5fd2hlbkRlZmVycmVkcy5nZXQoc3RhdGUpO1xuICAgICAgICAgIHdoZW5EZWZlcnJlZHMuZm9yRWFjaChmdW5jdGlvbihkZWZlcnJlZCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICB3aGVuRGVmZXJyZWRzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBfd2hlbkRlZmVycmVkczoge1xuICAgICAgdmFsdWU6IG5ldyBNYXAoW1xuICAgICAgICBbJ2hpZ2gnLCBuZXcgU2V0KCldLFxuICAgICAgICBbJ2xvdycsIG5ldyBTZXQoKV1cbiAgICAgIF0pXG4gICAgfSxcbiAgICBzdGF0ZToge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFRyYW5zaXRpb24gdG8gXCJsb3dcIi5cbiAqIEByZXR1cm5zIHt0aGlzfVxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbkxhdGNoLnByb3RvdHlwZS5sb3dlciA9IGZ1bmN0aW9uIGxvd2VyKCkge1xuICByZXR1cm4gdGhpcy50cmFuc2l0aW9uKCdsb3cnKTtcbn07XG5cbi8qKlxuICogVHJhbnNpdGlvbiB0byBcImhpZ2hcIi5cbiAqIEByZXR1cm5zIHt0aGlzfVxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbkxhdGNoLnByb3RvdHlwZS5yYWlzZSA9IGZ1bmN0aW9uIHJhaXNlKCkge1xuICByZXR1cm4gdGhpcy50cmFuc2l0aW9uKCdoaWdoJyk7XG59O1xuXG4vKipcbiAqIFRyYW5zaXRpb24gdG8gYSBuZXcgc3RhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3U3RhdGVcbiAqIEByZXR1cm5zIHt0aGlzfVxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbkxhdGNoLnByb3RvdHlwZS50cmFuc2l0aW9uID0gZnVuY3Rpb24gdHJhbnNpdGlvbihuZXdTdGF0ZSkge1xuICBpZiAoIXN0YXRlc1t0aGlzLnN0YXRlXS5oYXMobmV3U3RhdGUpKSB7XG4gICAgdGhyb3cgY3JlYXRlVW5yZWFjaGFibGVTdGF0ZUVycm9yKHRoaXMuc3RhdGUsIG5ld1N0YXRlKTtcbiAgfVxuICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHtAbGluayBMYXRjaH0gdHJhbnNpdGlvbnMgdG9cbiAqIHRoZSBzcGVjaWZpZWQgc3RhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RhdGVcbiAqIEByZXR1cm5zIHtQcm9taXNlPHRoaXM+fVxuICovXG5MYXRjaC5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uIHdoZW4oc3RhdGUpIHtcbiAgaWYgKHRoaXMuc3RhdGUgPT09IHN0YXRlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgfVxuICBpZiAoIXN0YXRlc1t0aGlzLnN0YXRlXS5oYXMoc3RhdGUpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNyZWF0ZVVucmVhY2hhYmxlU3RhdGVFcnJvcih0aGlzLnN0YXRlLCBzdGF0ZSkpO1xuICB9XG4gIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gIHRoaXMuX3doZW5EZWZlcnJlZHMuZ2V0KHN0YXRlKS5hZGQoZGVmZXJyZWQpO1xuICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIHVucmVhY2hhYmxlIHN0YXRlIEVycm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGZyb20gLSBzdGF0ZSB0byBiZSB0cmFuc2l0aW9uZWQgZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IHRvIC0gc3RhdGUgdG8gYmUgdHJhbnNpdGlvbmVkIHRvXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVW5yZWFjaGFibGVTdGF0ZUVycm9yKGZyb20sIHRvKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0Nhbm5vdCB0cmFuc2l0aW9uIGZyb20gXCInICsgZnJvbSArICdcIiB0byBcIicgKyB0byArICdcIicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExhdGNoO1xuIiwiLyogZ2xvYmFscyBSVENQZWVyQ29ubmVjdGlvbiwgUlRDUnRwVHJhbnNjZWl2ZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZmxhdE1hcCA9IHJlcXVpcmUoJy4vJykuZmxhdE1hcDtcbnZhciBndWVzc0Jyb3dzZXIgPSByZXF1aXJlKCcuLycpLmd1ZXNzQnJvd3NlcjtcblxuLy8gTk9URShtbWFsYXZhbGxpKTogV2UgY2FjaGUgQ2hyb21lJ3Mgc2RwU2VtYW50aWNzIHN1cHBvcnQgaW4gb3JkZXIgdG8gcHJldmVudFxuLy8gaW5zdGFudGlhdGlvbiBvZiBtb3JlIHRoYW4gb25lIFJUQ1BlZXJDb25uZWN0aW9uLlxudmFyIGlzU2RwU2VtYW50aWNzU3VwcG9ydGVkID0gbnVsbDtcblxuLyoqXG4gKiBDaGVjayBpZiBDaHJvbWUgc3VwcG9ydHMgc3BlY2lmeWluZyBzZHBTZW1hbnRpY3MgZm9yIGFuIFJUQ1BlZXJDb25uZWN0aW9uLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY2hlY2tJZlNkcFNlbWFudGljc0lzU3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIGlzU2RwU2VtYW50aWNzU3VwcG9ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gaXNTZHBTZW1hbnRpY3NTdXBwb3J0ZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NkcFNlbWFudGljc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiBpc1NkcFNlbWFudGljc1N1cHBvcnRlZDtcbiAgfVxuICB0cnkge1xuICAgIG5ldyBSVENQZWVyQ29ubmVjdGlvbih7IHNkcFNlbWFudGljczogJ2ZvbycgfSk7XG4gICAgaXNTZHBTZW1hbnRpY3NTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlzU2RwU2VtYW50aWNzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gaXNTZHBTZW1hbnRpY3NTdXBwb3J0ZWQ7XG59XG5cbi8vIE5PVEUobW1hbGF2YWxsaSk6IFdlIGNhY2hlIENocm9tZSdzIFNEUCBmb3JtYXQgaW4gb3JkZXIgdG8gcHJldmVudFxuLy8gaW5zdGFudGlhdGlvbiBvZiBtb3JlIHRoYW4gb25lIFJUQ1BlZXJDb25uZWN0aW9uLlxudmFyIGNocm9tZVNkcEZvcm1hdCA9IG51bGw7XG5cbi8qKlxuICogR2V0IENocm9tZSdzIGRlZmF1bHQgU0RQIGZvcm1hdC5cbiAqIEByZXR1cm5zIHsncGxhbmInfCd1bmlmaWVkJ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q2hyb21lRGVmYXVsdFNkcEZvcm1hdCgpIHtcbiAgaWYgKCFjaHJvbWVTZHBGb3JtYXQpIHtcbiAgICBpZiAodHlwZW9mIFJUQ1BlZXJDb25uZWN0aW9uICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgJ2FkZFRyYW5zY2VpdmVyJyBpbiBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBSVENQZWVyQ29ubmVjdGlvbigpLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycpO1xuICAgICAgICBjaHJvbWVTZHBGb3JtYXQgPSAndW5pZmllZCc7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNocm9tZVNkcEZvcm1hdCA9ICdwbGFuYic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNocm9tZVNkcEZvcm1hdCA9ICdwbGFuYic7XG4gICAgfVxuICB9XG4gIHJldHVybiBjaHJvbWVTZHBGb3JtYXQ7XG59XG5cbi8qKlxuICogR2V0IENocm9tZSdzIFNEUCBmb3JtYXQuXG4gKiBAcGFyYW0geydwbGFuLWInfCd1bmlmaWVkLXBsYW4nfSBbc2RwU2VtYW50aWNzXVxuICogQHJldHVybnMgeydwbGFuYid8J3VuaWZpZWQnfVxuICovXG5mdW5jdGlvbiBnZXRDaHJvbWVTZHBGb3JtYXQoc2RwU2VtYW50aWNzKSB7XG4gIGlmICghc2RwU2VtYW50aWNzIHx8ICFjaGVja0lmU2RwU2VtYW50aWNzSXNTdXBwb3J0ZWQoKSkge1xuICAgIHJldHVybiBnZXRDaHJvbWVEZWZhdWx0U2RwRm9ybWF0KCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAncGxhbi1iJzogJ3BsYW5iJyxcbiAgICAndW5pZmllZC1wbGFuJzogJ3VuaWZpZWQnXG4gIH1bc2RwU2VtYW50aWNzXTtcbn1cblxuLyoqXG4gKiBHZXQgU2FmYXJpJ3MgZGVmYXVsdCBTRFAgZm9ybWF0LlxuICogQHJldHVybnMgeydwbGFuYid8J3VuaWZpZWQnfVxuICovXG5mdW5jdGlvbiBnZXRTYWZhcmlTZHBGb3JtYXQoKSB7XG4gIHJldHVybiB0eXBlb2YgUlRDUnRwVHJhbnNjZWl2ZXIgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgJ2N1cnJlbnREaXJlY3Rpb24nIGluIFJUQ1J0cFRyYW5zY2VpdmVyLnByb3RvdHlwZVxuICAgICAgPyAndW5pZmllZCdcbiAgICAgIDogJ3BsYW5iJztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IFNEUCBmb3JtYXQuXG4gKiBAcGFyYW0geydwbGFuLWInfCd1bmlmaWVkLXBsYW4nfSBbc2RwU2VtYW50aWNzXVxuICogQHJldHVybnMgeydwbGFuYid8J3VuaWZpZWQnfVxuICovXG5mdW5jdGlvbiBnZXRTZHBGb3JtYXQoc2RwU2VtYW50aWNzKSB7XG4gIHJldHVybiB7XG4gICAgY2hyb21lOiBnZXRDaHJvbWVTZHBGb3JtYXQoc2RwU2VtYW50aWNzKSxcbiAgICBmaXJlZm94OiAndW5pZmllZCcsXG4gICAgc2FmYXJpOiBnZXRTYWZhcmlTZHBGb3JtYXQoKVxuICB9W2d1ZXNzQnJvd3NlcigpXSB8fCBudWxsO1xufVxuXG4vKipcbiAqIE1hdGNoIGEgcGF0dGVybiBhY3Jvc3MgbGluZXMsIHJldHVybmluZyB0aGUgZmlyc3QgY2FwdHVyZSBncm91cCBmb3IgYW55XG4gKiBtYXRjaGVzLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm5cbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lc1xuICogQHJldHVybnMge1NldDxzdHJpbmc+fSBtYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoZXMocGF0dGVybiwgbGluZXMpIHtcbiAgdmFyIG1hdGNoZXMgPSBsaW5lcy5tYXRjaChuZXcgUmVnRXhwKHBhdHRlcm4sICdnbScpKSB8fCBbXTtcbiAgcmV0dXJuIG1hdGNoZXMucmVkdWNlKGZ1bmN0aW9uKHJlc3VsdHMsIGxpbmUpIHtcbiAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKG5ldyBSZWdFeHAocGF0dGVybikpO1xuICAgIHJldHVybiBtYXRjaCA/IHJlc3VsdHMuYWRkKG1hdGNoWzFdKSA6IHJlc3VsdHM7XG4gIH0sIG5ldyBTZXQoKSk7XG59XG5cbi8qKlxuICogR2V0IGEgU2V0IG9mIE1lZGlhU3RyZWFtVHJhY2sgSURzIGZyb20gYW4gU0RQLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHBcbiAqIEByZXR1cm5zIHtTZXQ8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhY2tJZHMocGF0dGVybiwgc2RwKSB7XG4gIHJldHVybiBnZXRNYXRjaGVzKHBhdHRlcm4sIHNkcCk7XG59XG5cbi8qKlxuICogR2V0IGEgU2V0IG9mIE1lZGlhU3RyZWFtVHJhY2sgSURzIGZyb20gYSBQbGFuIEIgU0RQLlxuICogQHBhcmFtIHtzdHJpbmd9IHNkcCAtIFBsYW4gQiBTRFBcbiAqIEByZXR1cm5zIHtTZXQ8c3RyaW5nPn0gdHJhY2tJZHNcbiAqL1xuZnVuY3Rpb24gZ2V0UGxhbkJUcmFja0lkcyhzZHApIHtcbiAgcmV0dXJuIGdldFRyYWNrSWRzKCdeYT1zc3JjOlswLTldKyArbXNpZDouKyArKC4rKSAqJCcsIHNkcCk7XG59XG5cbi8qKlxuICogR2V0IGEgU2V0IG9mIE1lZGlhU3RyZWFtVHJhY2sgSURzIGZyb20gYSBVbmlmaWVkIFBsYW4gU0RQLlxuICogQHBhcmFtIHtzdHJpbmd9IHNkcCAtIFVuaWZpZWQgUGxhbiBTRFBcbiAqIEByZXR1cm5zIHtTZXQ8c3RyaW5nPn0gdHJhY2tJZHNcbiAqL1xuZnVuY3Rpb24gZ2V0VW5pZmllZFBsYW5UcmFja0lkcyhzZHApIHtcbiAgcmV0dXJuIGdldFRyYWNrSWRzKCdeYT1tc2lkOi4rICsoLispICokJywgc2RwKTtcbn1cblxuLyoqXG4gKiBHZXQgYSBTZXQgb2YgU1NSQ3MgZm9yIGEgTWVkaWFTdHJlYW1UcmFjayBmcm9tIGEgUGxhbiBCIFNEUC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHAgLSBQbGFuIEIgU0RQXG4gKiBAcGFyYW0ge3N0cmluZ30gdHJhY2tJZCAtIE1lZGlhU3RyZWFtVHJhY2sgSURcbiAqIEByZXR1cm5zIHtTZXQ8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0UGxhbkJTU1JDcyhzZHAsIHRyYWNrSWQpIHtcbiAgdmFyIHBhdHRlcm4gPSAnXmE9c3NyYzooWzAtOV0rKSArbXNpZDpbXiBdKyArJyArIHRyYWNrSWQgKyAnICokJztcbiAgcmV0dXJuIGdldE1hdGNoZXMocGF0dGVybiwgc2RwKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG09IHNlY3Rpb25zIG9mIGEgcGFydGljdWxhciBraW5kIGFuZCBkaXJlY3Rpb24gZnJvbSBhbiBzZHAuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwIC0gIHNkcCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBba2luZF0gLSBQYXR0ZXJuIGZvciBtYXRjaGluZyBraW5kXG4gKiBAcGFyYW0ge3N0cmluZ30gW2RpcmVjdGlvbl0gLSBQYXR0ZXJuIGZvciBtYXRjaGluZyBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBtZWRpYVNlY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGdldE1lZGlhU2VjdGlvbnMoc2RwLCBraW5kLCBkaXJlY3Rpb24pIHtcbiAga2luZCA9IGtpbmQgfHwgJy4qJztcbiAgZGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8ICcuKic7XG4gIHJldHVybiBzZHAuc3BsaXQoJ1xcclxcbm09Jykuc2xpY2UoMSkubWFwKGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICAgIHJldHVybiAnbT0nICsgbWVkaWFTZWN0aW9uO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gICAgdmFyIGtpbmRQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnbT0nICsga2luZCwgJ2dtJyk7XG4gICAgdmFyIGRpcmVjdGlvblBhdHRlcm4gPSBuZXcgUmVnRXhwKCdhPScgKyBkaXJlY3Rpb24sICdnbScpO1xuICAgIHJldHVybiBraW5kUGF0dGVybi50ZXN0KG1lZGlhU2VjdGlvbikgJiYgZGlyZWN0aW9uUGF0dGVybi50ZXN0KG1lZGlhU2VjdGlvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgU2V0IG9mIFNTUkNzIGFubm91bmNlZCBpbiBhIE1lZGlhU2VjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZWRpYVNlY3Rpb25cbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBzc3Jjc1xuICovXG5mdW5jdGlvbiBnZXRNZWRpYVNlY3Rpb25TU1JDcyhtZWRpYVNlY3Rpb24pIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZ2V0TWF0Y2hlcygnXmE9c3NyYzooWzAtOV0rKSArLiokJywgbWVkaWFTZWN0aW9uKSk7XG59XG5cbi8qKlxuICogR2V0IGEgU2V0IG9mIFNTUkNzIGZvciBhIE1lZGlhU3RyZWFtVHJhY2sgZnJvbSBhIFVuaWZpZWQgUGxhbiBTRFAuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RwIC0gVW5pZmllZCBQbGFuIFNEUFxuICogQHBhcmFtIHtzdHJpbmd9IHRyYWNrSWQgLSBNZWRpYVN0cmVhbVRyYWNrIElEXG4gKiBAcmV0dXJucyB7U2V0PHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldFVuaWZpZWRQbGFuU1NSQ3Moc2RwLCB0cmFja0lkKSB7XG4gIHZhciBtZWRpYVNlY3Rpb25zID0gZ2V0TWVkaWFTZWN0aW9ucyhzZHApO1xuXG4gIHZhciBtc2lkQXR0clJlZ0V4cCA9IG5ldyBSZWdFeHAoJ15hPW1zaWQ6W14gXSsgKycgKyB0cmFja0lkICsgJyAqJCcsICdnbScpO1xuICB2YXIgbWF0Y2hpbmdNZWRpYVNlY3Rpb25zID0gbWVkaWFTZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gICAgcmV0dXJuIG1lZGlhU2VjdGlvbi5tYXRjaChtc2lkQXR0clJlZ0V4cCk7XG4gIH0pO1xuXG4gIHJldHVybiBuZXcgU2V0KGZsYXRNYXAobWF0Y2hpbmdNZWRpYVNlY3Rpb25zLCBnZXRNZWRpYVNlY3Rpb25TU1JDcykpO1xufVxuXG4vKipcbiAqIEdldCBhIE1hcCBmcm9tIE1lZGlhU3RyZWFtVHJhY2sgSURzIHRvIFNTUkNzIGZyb20gYW4gU0RQLlxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpOiBTZXQ8c3RyaW5nPn0gZ2V0VHJhY2tJZHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCBzdHJpbmcpOiBTZXQ8c3RyaW5nPn0gZ2V0U1NSQ3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHAgLSBTRFBcbiAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj59IHRyYWNrSWRzVG9TU1JDc1xuICovXG5mdW5jdGlvbiBnZXRUcmFja0lkc1RvU1NSQ3MoZ2V0VHJhY2tJZHMsIGdldFNTUkNzLCBzZHApIHtcbiAgcmV0dXJuIG5ldyBNYXAoQXJyYXkuZnJvbShnZXRUcmFja0lkcyhzZHApKS5tYXAoZnVuY3Rpb24odHJhY2tJZCkge1xuICAgIHJldHVybiBbdHJhY2tJZCwgZ2V0U1NSQ3Moc2RwLCB0cmFja0lkKV07XG4gIH0pKTtcbn1cblxuLyoqXG4gKiBHZXQgYSBNYXAgZnJvbSBNZWRpYVN0cmVhbVRyYWNrIElEcyB0byBTU1JDcyBmcm9tIGEgUGxhbiBCIFNEUC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHAgLSBQbGFuIEIgU0RQXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgU2V0PHN0cmluZz4+fSB0cmFja0lkc1RvU1NSQ3NcbiAqL1xuZnVuY3Rpb24gZ2V0UGxhbkJUcmFja0lkc1RvU1NSQ3Moc2RwKSB7XG4gIHJldHVybiBnZXRUcmFja0lkc1RvU1NSQ3MoZ2V0UGxhbkJUcmFja0lkcywgZ2V0UGxhbkJTU1JDcywgc2RwKTtcbn1cblxuLyoqXG4gKiBHZXQgYSBNYXAgZnJvbSBNZWRpYVN0cmVhbVRyYWNrIElEcyB0byBTU1JDcyBmcm9tIGEgUGxhbiBCIFNEUC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHAgLSBQbGFuIEIgU0RQXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgU2V0PHN0cmluZz4+fSB0cmFja0lkc1RvU1NSQ3NcbiAqL1xuZnVuY3Rpb24gZ2V0VW5pZmllZFBsYW5UcmFja0lkc1RvU1NSQ3Moc2RwKSB7XG4gIHJldHVybiBnZXRUcmFja0lkc1RvU1NSQ3MoZ2V0VW5pZmllZFBsYW5UcmFja0lkcywgZ2V0VW5pZmllZFBsYW5TU1JDcywgc2RwKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIG1hcHBpbmdzIGZyb20gTWVkaWFTdHJlYW1UcmFjayBJRHMgdG8gU1NSQ3MgYXMgaW5kaWNhdGVkIGJ5IGJvdGhcbiAqIHRoZSBNYXAgZnJvbSBNZWRpYVN0cmVhbVRyYWNrIElEcyB0byBTU1JDcyBhbmQgdGhlIFNEUCBpdHNlbGYuIFRoaXMgbWV0aG9kXG4gKiBlbnN1cmVzIHRoYXQgU1NSQ3MgbmV2ZXIgY2hhbmdlIG9uY2UgYW5ub3VuY2VkLlxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpOiBNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj59IGdldFRyYWNrSWRzVG9TU1JDc1xuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj59IHRyYWNrSWRzVG9TU1JDc1xuICogQHBhcmFtIHtzdHJpbmd9IHNkcCAtIFNEUFxuICogQHJldHVybnMge3N0cmlubmd9IHVwZGF0ZWRTZHAgLSB1cGRhdGVkIFNEUFxuICovXG5mdW5jdGlvbiB1cGRhdGVUcmFja0lkc1RvU1NSQ3MoZ2V0VHJhY2tJZHNUb1NTUkNzLCB0cmFja0lkc1RvU1NSQ3MsIHNkcCkge1xuICB2YXIgbmV3VHJhY2tJZHNUb1NTUkNzID0gZ2V0VHJhY2tJZHNUb1NTUkNzKHNkcCk7XG4gIHZhciBuZXdTU1JDc1RvT2xkU1NSQ3MgPSBuZXcgTWFwKCk7XG5cbiAgLy8gTk9URShtcm9iZXJ0cyk6IEZpcnN0LCB1cGRhdGUgYT1zc3JjIGF0dHJpYnV0ZXMuXG4gIG5ld1RyYWNrSWRzVG9TU1JDcy5mb3JFYWNoKGZ1bmN0aW9uKHNzcmNzLCB0cmFja0lkKSB7XG4gICAgaWYgKCF0cmFja0lkc1RvU1NSQ3MuaGFzKHRyYWNrSWQpKSB7XG4gICAgICB0cmFja0lkc1RvU1NSQ3Muc2V0KHRyYWNrSWQsIHNzcmNzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9sZFNTUkNzID0gQXJyYXkuZnJvbSh0cmFja0lkc1RvU1NSQ3MuZ2V0KHRyYWNrSWQpKTtcbiAgICB2YXIgbmV3U1NSQ3MgPSBBcnJheS5mcm9tKHNzcmNzKTtcbiAgICBvbGRTU1JDcy5mb3JFYWNoKGZ1bmN0aW9uKG9sZFNTUkMsIGkpIHtcbiAgICAgIHZhciBuZXdTU1JDID0gbmV3U1NSQ3NbaV07XG4gICAgICBuZXdTU1JDc1RvT2xkU1NSQ3Muc2V0KG5ld1NTUkMsIG9sZFNTUkMpO1xuICAgICAgdmFyIHBhdHRlcm4gPSAnXmE9c3NyYzonICsgbmV3U1NSQyArICcgKC4qKSQnO1xuICAgICAgdmFyIHJlcGxhY2VtZW50ID0gJ2E9c3NyYzonICsgb2xkU1NSQyArICcgJDEnO1xuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChwYXR0ZXJuLCAnZ20nKSwgcmVwbGFjZW1lbnQpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBOT1RFKG1yb2JlcnRzKTogVGhlbiwgdXBkYXRlIGE9c3NyYy1ncm91cCBhdHRyaWJ1dGVzLlxuICB2YXIgcGF0dGVybiA9ICdeKGE9c3NyYy1ncm91cDpbXiBdKyArKSguKikkJztcbiAgdmFyIG1hdGNoZXMgPSBzZHAubWF0Y2gobmV3IFJlZ0V4cChwYXR0ZXJuLCAnZ20nKSkgfHwgW107XG4gIG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgdmFyIG1hdGNoID0gbGluZS5tYXRjaChuZXcgUmVnRXhwKHBhdHRlcm4pKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcmVmaXggPSBtYXRjaFsxXTtcbiAgICB2YXIgbmV3U1NSQ3MgPSBtYXRjaFsyXTtcbiAgICB2YXIgb2xkU1NSQ3MgPSBuZXdTU1JDcy5zcGxpdCgnICcpLm1hcChmdW5jdGlvbihuZXdTU1JDKSB7XG4gICAgICB2YXIgb2xkU1NSQyA9IG5ld1NTUkNzVG9PbGRTU1JDcy5nZXQobmV3U1NSQyk7XG4gICAgICByZXR1cm4gb2xkU1NSQyA/IG9sZFNTUkMgOiBuZXdTU1JDO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgICBzZHAgPSBzZHAucmVwbGFjZShtYXRjaFswXSwgcHJlZml4ICsgb2xkU1NSQ3MpO1xuICB9KTtcblxuICByZXR1cm4gc2RwO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgbWFwcGluZ3MgZnJvbSBNZWRpYVN0cmVhbVRyYWNrIElEcyB0byBTU1JDcyBhcyBpbmRpY2F0ZWQgYnkgYm90aFxuICogdGhlIE1hcCBmcm9tIE1lZGlhU3RyZWFtVHJhY2sgSURzIHRvIFNTUkNzIGFuZCB0aGUgUGxhbiBCIFNEUCBpdHNlbGYuIFRoaXNcbiAqIG1ldGhvZCBlbnN1cmVzIHRoYXQgU1NSQ3MgbmV2ZXIgY2hhbmdlIG9uY2UgYW5ub3VuY2VkLlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj59IHRyYWNrSWRzVG9TU1JDc1xuICogQHBhcmFtIHtzdHJpbmd9IHNkcCAtIFBsYW4gQiBTRFBcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHVwZGF0ZWRTZHAgLSB1cGRhdGVkIFBsYW4gQiBTRFBcbiAqL1xuZnVuY3Rpb24gdXBkYXRlUGxhbkJUcmFja0lkc1RvU1NSQ3ModHJhY2tJZHNUb1NTUkNzLCBzZHApIHtcbiAgcmV0dXJuIHVwZGF0ZVRyYWNrSWRzVG9TU1JDcyhnZXRQbGFuQlRyYWNrSWRzVG9TU1JDcywgdHJhY2tJZHNUb1NTUkNzLCBzZHApO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgbWFwcGluZ3MgZnJvbSBNZWRpYVN0cmVhbVRyYWNrIElEcyB0byBTU1JDcyBhcyBpbmRpY2F0ZWQgYnkgYm90aFxuICogdGhlIE1hcCBmcm9tIE1lZGlhU3RyZWFtVHJhY2sgSURzIHRvIFNTUkNzIGFuZCB0aGUgUGxhbiBCIFNEUCBpdHNlbGYuIFRoaXNcbiAqIG1ldGhvZCBlbnN1cmVzIHRoYXQgU1NSQ3MgbmV2ZXIgY2hhbmdlIG9uY2UgYW5ub3VuY2VkLlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj59IHRyYWNrSWRzVG9TU1JDc1xuICogQHBhcmFtIHtzdHJpbmd9IHNkcCAtIFBsYW4gQiBTRFBcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHVwZGF0ZWRTZHAgLSB1cGRhdGVkIFBsYW4gQiBTRFBcbiAqL1xuZnVuY3Rpb24gdXBkYXRlVW5pZmllZFBsYW5UcmFja0lkc1RvU1NSQ3ModHJhY2tJZHNUb1NTUkNzLCBzZHApIHtcbiAgcmV0dXJuIHVwZGF0ZVRyYWNrSWRzVG9TU1JDcyhnZXRVbmlmaWVkUGxhblRyYWNrSWRzVG9TU1JDcywgdHJhY2tJZHNUb1NTUkNzLCBzZHApO1xufVxuXG5leHBvcnRzLmdldFNkcEZvcm1hdCA9IGdldFNkcEZvcm1hdDtcbmV4cG9ydHMuZ2V0TWVkaWFTZWN0aW9ucyA9IGdldE1lZGlhU2VjdGlvbnM7XG5leHBvcnRzLmdldFBsYW5CVHJhY2tJZHMgPSBnZXRQbGFuQlRyYWNrSWRzO1xuZXhwb3J0cy5nZXRVbmlmaWVkUGxhblRyYWNrSWRzID0gZ2V0VW5pZmllZFBsYW5UcmFja0lkcztcbmV4cG9ydHMuZ2V0UGxhbkJTU1JDcyA9IGdldFBsYW5CU1NSQ3M7XG5leHBvcnRzLmdldFVuaWZpZWRQbGFuU1NSQ3MgPSBnZXRVbmlmaWVkUGxhblNTUkNzO1xuZXhwb3J0cy51cGRhdGVQbGFuQlRyYWNrSWRzVG9TU1JDcyA9IHVwZGF0ZVBsYW5CVHJhY2tJZHNUb1NTUkNzO1xuZXhwb3J0cy51cGRhdGVVbmlmaWVkUGxhblRyYWNrSWRzVG9TU1JDcyA9IHVwZGF0ZVVuaWZpZWRQbGFuVHJhY2tJZHNUb1NTUkNzO1xuIiwiLy8gICAgICBDb3B5cmlnaHQgKGMpIDIwMTIgTWF0aGlldSBUdXJjb3R0ZVxuLy8gICAgICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnLi9saWIvYmFja29mZicpO1xudmFyIEV4cG9uZW50aWFsQmFja29mZlN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9saWIvc3RyYXRlZ3kvZXhwb25lbnRpYWwnKTtcbnZhciBGaWJvbmFjY2lCYWNrb2ZmU3RyYXRlZ3kgPSByZXF1aXJlKCcuL2xpYi9zdHJhdGVneS9maWJvbmFjY2knKTtcbnZhciBGdW5jdGlvbkNhbGwgPSByZXF1aXJlKCcuL2xpYi9mdW5jdGlvbl9jYWxsLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzLkJhY2tvZmYgPSBCYWNrb2ZmO1xubW9kdWxlLmV4cG9ydHMuRnVuY3Rpb25DYWxsID0gRnVuY3Rpb25DYWxsO1xubW9kdWxlLmV4cG9ydHMuRmlib25hY2NpU3RyYXRlZ3kgPSBGaWJvbmFjY2lCYWNrb2ZmU3RyYXRlZ3k7XG5tb2R1bGUuZXhwb3J0cy5FeHBvbmVudGlhbFN0cmF0ZWd5ID0gRXhwb25lbnRpYWxCYWNrb2ZmU3RyYXRlZ3k7XG5cbi8vIENvbnN0cnVjdHMgYSBGaWJvbmFjY2kgYmFja29mZi5cbm1vZHVsZS5leHBvcnRzLmZpYm9uYWNjaSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEJhY2tvZmYobmV3IEZpYm9uYWNjaUJhY2tvZmZTdHJhdGVneShvcHRpb25zKSk7XG59O1xuXG4vLyBDb25zdHJ1Y3RzIGFuIGV4cG9uZW50aWFsIGJhY2tvZmYuXG5tb2R1bGUuZXhwb3J0cy5leHBvbmVudGlhbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEJhY2tvZmYobmV3IEV4cG9uZW50aWFsQmFja29mZlN0cmF0ZWd5KG9wdGlvbnMpKTtcbn07XG5cbi8vIENvbnN0cnVjdHMgYSBGdW5jdGlvbkNhbGwgZm9yIHRoZSBnaXZlbiBmdW5jdGlvbiBhbmQgYXJndW1lbnRzLlxubW9kdWxlLmV4cG9ydHMuY2FsbCA9IGZ1bmN0aW9uKGZuLCB2YXJncywgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgZm4gPSBhcmdzWzBdO1xuICAgIHZhcmdzID0gYXJncy5zbGljZSgxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgIGNhbGxiYWNrID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25DYWxsKGZuLCB2YXJncywgY2FsbGJhY2spO1xufTtcbiIsIi8vICAgICAgQ29weXJpZ2h0IChjKSAyMDEyIE1hdGhpZXUgVHVyY290dGVcbi8vICAgICAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgcHJlY29uZCA9IHJlcXVpcmUoJ3ByZWNvbmQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vLyBBIGNsYXNzIHRvIGhvbGQgdGhlIHN0YXRlIG9mIGEgYmFja29mZiBvcGVyYXRpb24uIEFjY2VwdHMgYSBiYWNrb2ZmIHN0cmF0ZWd5XG4vLyB0byBnZW5lcmF0ZSB0aGUgYmFja29mZiBkZWxheXMuXG5mdW5jdGlvbiBCYWNrb2ZmKGJhY2tvZmZTdHJhdGVneSkge1xuICAgIGV2ZW50cy5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuYmFja29mZlN0cmF0ZWd5XyA9IGJhY2tvZmZTdHJhdGVneTtcbiAgICB0aGlzLm1heE51bWJlck9mUmV0cnlfID0gLTE7XG4gICAgdGhpcy5iYWNrb2ZmTnVtYmVyXyA9IDA7XG4gICAgdGhpcy5iYWNrb2ZmRGVsYXlfID0gMDtcbiAgICB0aGlzLnRpbWVvdXRJRF8gPSAtMTtcblxuICAgIHRoaXMuaGFuZGxlcnMgPSB7XG4gICAgICAgIGJhY2tvZmY6IHRoaXMub25CYWNrb2ZmXy5iaW5kKHRoaXMpXG4gICAgfTtcbn1cbnV0aWwuaW5oZXJpdHMoQmFja29mZiwgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cbi8vIFNldHMgYSBsaW1pdCwgZ3JlYXRlciB0aGFuIDAsIG9uIHRoZSBtYXhpbXVtIG51bWJlciBvZiBiYWNrb2Zmcy4gQSAnZmFpbCdcbi8vIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCB3aGVuIHRoZSBsaW1pdCBpcyByZWFjaGVkLlxuQmFja29mZi5wcm90b3R5cGUuZmFpbEFmdGVyID0gZnVuY3Rpb24obWF4TnVtYmVyT2ZSZXRyeSkge1xuICAgIHByZWNvbmQuY2hlY2tBcmd1bWVudChtYXhOdW1iZXJPZlJldHJ5ID4gMCxcbiAgICAgICAgJ0V4cGVjdGVkIGEgbWF4aW11bSBudW1iZXIgb2YgcmV0cnkgZ3JlYXRlciB0aGFuIDAgYnV0IGdvdCAlcy4nLFxuICAgICAgICBtYXhOdW1iZXJPZlJldHJ5KTtcblxuICAgIHRoaXMubWF4TnVtYmVyT2ZSZXRyeV8gPSBtYXhOdW1iZXJPZlJldHJ5O1xufTtcblxuLy8gU3RhcnRzIGEgYmFja29mZiBvcGVyYXRpb24uIEFjY2VwdHMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIGxldCB0aGVcbi8vIGxpc3RlbmVycyBrbm93IHdoeSB0aGUgYmFja29mZiBvcGVyYXRpb24gd2FzIHN0YXJ0ZWQuXG5CYWNrb2ZmLnByb3RvdHlwZS5iYWNrb2ZmID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgcHJlY29uZC5jaGVja1N0YXRlKHRoaXMudGltZW91dElEXyA9PT0gLTEsICdCYWNrb2ZmIGluIHByb2dyZXNzLicpO1xuXG4gICAgaWYgKHRoaXMuYmFja29mZk51bWJlcl8gPT09IHRoaXMubWF4TnVtYmVyT2ZSZXRyeV8pIHtcbiAgICAgICAgdGhpcy5lbWl0KCdmYWlsJywgZXJyKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmFja29mZkRlbGF5XyA9IHRoaXMuYmFja29mZlN0cmF0ZWd5Xy5uZXh0KCk7XG4gICAgICAgIHRoaXMudGltZW91dElEXyA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVycy5iYWNrb2ZmLCB0aGlzLmJhY2tvZmZEZWxheV8pO1xuICAgICAgICB0aGlzLmVtaXQoJ2JhY2tvZmYnLCB0aGlzLmJhY2tvZmZOdW1iZXJfLCB0aGlzLmJhY2tvZmZEZWxheV8sIGVycik7XG4gICAgfVxufTtcblxuLy8gSGFuZGxlcyB0aGUgYmFja29mZiB0aW1lb3V0IGNvbXBsZXRpb24uXG5CYWNrb2ZmLnByb3RvdHlwZS5vbkJhY2tvZmZfID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50aW1lb3V0SURfID0gLTE7XG4gICAgdGhpcy5lbWl0KCdyZWFkeScsIHRoaXMuYmFja29mZk51bWJlcl8sIHRoaXMuYmFja29mZkRlbGF5Xyk7XG4gICAgdGhpcy5iYWNrb2ZmTnVtYmVyXysrO1xufTtcblxuLy8gU3RvcHMgYW55IGJhY2tvZmYgb3BlcmF0aW9uIGFuZCByZXNldHMgdGhlIGJhY2tvZmYgZGVsYXkgdG8gaXRzIGluaXRhbCB2YWx1ZS5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5iYWNrb2ZmTnVtYmVyXyA9IDA7XG4gICAgdGhpcy5iYWNrb2ZmU3RyYXRlZ3lfLnJlc2V0KCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElEXyk7XG4gICAgdGhpcy50aW1lb3V0SURfID0gLTE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG4iLCIvLyAgICAgIENvcHlyaWdodCAoYykgMjAxMiBNYXRoaWV1IFR1cmNvdHRlXG4vLyAgICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xudmFyIHByZWNvbmQgPSByZXF1aXJlKCdwcmVjb25kJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIEJhY2tvZmYgPSByZXF1aXJlKCcuL2JhY2tvZmYnKTtcbnZhciBGaWJvbmFjY2lCYWNrb2ZmU3RyYXRlZ3kgPSByZXF1aXJlKCcuL3N0cmF0ZWd5L2ZpYm9uYWNjaScpO1xuXG4vLyBXcmFwcyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiBhIGJhY2tvZmYgbG9vcC5cbmZ1bmN0aW9uIEZ1bmN0aW9uQ2FsbChmbiwgYXJncywgY2FsbGJhY2spIHtcbiAgICBldmVudHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICBwcmVjb25kLmNoZWNrSXNGdW5jdGlvbihmbiwgJ0V4cGVjdGVkIGZuIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgcHJlY29uZC5jaGVja0lzQXJyYXkoYXJncywgJ0V4cGVjdGVkIGFyZ3MgdG8gYmUgYW4gYXJyYXkuJyk7XG4gICAgcHJlY29uZC5jaGVja0lzRnVuY3Rpb24oY2FsbGJhY2ssICdFeHBlY3RlZCBjYWxsYmFjayB0byBiZSBhIGZ1bmN0aW9uLicpO1xuXG4gICAgdGhpcy5mdW5jdGlvbl8gPSBmbjtcbiAgICB0aGlzLmFyZ3VtZW50c18gPSBhcmdzO1xuICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XG4gICAgdGhpcy5sYXN0UmVzdWx0XyA9IFtdO1xuICAgIHRoaXMubnVtUmV0cmllc18gPSAwO1xuXG4gICAgdGhpcy5iYWNrb2ZmXyA9IG51bGw7XG4gICAgdGhpcy5zdHJhdGVneV8gPSBudWxsO1xuICAgIHRoaXMuZmFpbEFmdGVyXyA9IC0xO1xuICAgIHRoaXMucmV0cnlQcmVkaWNhdGVfID0gRnVuY3Rpb25DYWxsLkRFRkFVTFRfUkVUUllfUFJFRElDQVRFXztcblxuICAgIHRoaXMuc3RhdGVfID0gRnVuY3Rpb25DYWxsLlN0YXRlXy5QRU5ESU5HO1xufVxudXRpbC5pbmhlcml0cyhGdW5jdGlvbkNhbGwsIGV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG4vLyBTdGF0ZXMgaW4gd2hpY2ggdGhlIGNhbGwgY2FuIGJlLlxuRnVuY3Rpb25DYWxsLlN0YXRlXyA9IHtcbiAgICAvLyBDYWxsIGlzbid0IHN0YXJ0ZWQgeWV0LlxuICAgIFBFTkRJTkc6IDAsXG4gICAgLy8gQ2FsbCBpcyBpbiBwcm9ncmVzcy5cbiAgICBSVU5OSU5HOiAxLFxuICAgIC8vIENhbGwgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSB3aGljaCBtZWFucyB0aGF0IGVpdGhlciB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICAgIC8vIHJldHVybmVkIHN1Y2Nlc3NmdWxseSBvciB0aGUgbWF4aW1hbCBudW1iZXIgb2YgYmFja29mZnMgd2FzIHJlYWNoZWQuXG4gICAgQ09NUExFVEVEOiAyLFxuICAgIC8vIFRoZSBjYWxsIHdhcyBhYm9ydGVkLlxuICAgIEFCT1JURUQ6IDNcbn07XG5cbi8vIFRoZSBkZWZhdWx0IHJldHJ5IHByZWRpY2F0ZSB3aGljaCBjb25zaWRlcnMgYW55IGVycm9yIGFzIHJldHJpYWJsZS5cbkZ1bmN0aW9uQ2FsbC5ERUZBVUxUX1JFVFJZX1BSRURJQ0FURV8gPSBmdW5jdGlvbihlcnIpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBDaGVja3Mgd2hldGhlciB0aGUgY2FsbCBpcyBwZW5kaW5nLlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZV8gPT0gRnVuY3Rpb25DYWxsLlN0YXRlXy5QRU5ESU5HO1xufTtcblxuLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGNhbGwgaXMgaW4gcHJvZ3Jlc3MuXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLmlzUnVubmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlXyA9PSBGdW5jdGlvbkNhbGwuU3RhdGVfLlJVTk5JTkc7XG59O1xuXG4vLyBDaGVja3Mgd2hldGhlciB0aGUgY2FsbCBpcyBjb21wbGV0ZWQuXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLmlzQ29tcGxldGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVfID09IEZ1bmN0aW9uQ2FsbC5TdGF0ZV8uQ09NUExFVEVEO1xufTtcblxuLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGNhbGwgaXMgYWJvcnRlZC5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuaXNBYm9ydGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVfID09IEZ1bmN0aW9uQ2FsbC5TdGF0ZV8uQUJPUlRFRDtcbn07XG5cbi8vIFNldHMgdGhlIGJhY2tvZmYgc3RyYXRlZ3kgdG8gdXNlLiBDYW4gb25seSBiZSBjYWxsZWQgYmVmb3JlIHRoZSBjYWxsIGlzXG4vLyBzdGFydGVkIG90aGVyd2lzZSBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLnNldFN0cmF0ZWd5ID0gZnVuY3Rpb24oc3RyYXRlZ3kpIHtcbiAgICBwcmVjb25kLmNoZWNrU3RhdGUodGhpcy5pc1BlbmRpbmcoKSwgJ0Z1bmN0aW9uQ2FsbCBpbiBwcm9ncmVzcy4nKTtcbiAgICB0aGlzLnN0cmF0ZWd5XyA9IHN0cmF0ZWd5O1xuICAgIHJldHVybiB0aGlzOyAvLyBSZXR1cm4gdGhpcyBmb3IgY2hhaW5pbmcuXG59O1xuXG4vLyBTZXRzIHRoZSBwcmVkaWNhdGUgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBlcnJvcnNcbi8vIHJldHVybmVkIGZyb20gdGhlIHdyYXBwZWQgZnVuY3Rpb24gc2hvdWxkIGJlIHJldHJpZWQgb3Igbm90LCBlLmcuIGFcbi8vIG5ldHdvcmsgZXJyb3Igd291bGQgYmUgcmV0cmlhYmxlIHdoaWxlIGEgdHlwZSBlcnJvciB3b3VsZCBzdG9wIHRoZVxuLy8gZnVuY3Rpb24gY2FsbC5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUucmV0cnlJZiA9IGZ1bmN0aW9uKHJldHJ5UHJlZGljYXRlKSB7XG4gICAgcHJlY29uZC5jaGVja1N0YXRlKHRoaXMuaXNQZW5kaW5nKCksICdGdW5jdGlvbkNhbGwgaW4gcHJvZ3Jlc3MuJyk7XG4gICAgdGhpcy5yZXRyeVByZWRpY2F0ZV8gPSByZXRyeVByZWRpY2F0ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFJldHVybnMgYWxsIGludGVybWVkaWFyeSByZXN1bHRzIHJldHVybmVkIGJ5IHRoZSB3cmFwcGVkIGZ1bmN0aW9uIHNpbmNlXG4vLyB0aGUgaW5pdGlhbCBjYWxsLlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5nZXRMYXN0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubGFzdFJlc3VsdF8uY29uY2F0KCk7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIHdyYXBwZWQgZnVuY3Rpb24gY2FsbCB3YXMgcmV0cmllZC5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuZ2V0TnVtUmV0cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm51bVJldHJpZXNfO1xufTtcblxuLy8gU2V0cyB0aGUgYmFja29mZiBsaW1pdC5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuZmFpbEFmdGVyID0gZnVuY3Rpb24obWF4TnVtYmVyT2ZSZXRyeSkge1xuICAgIHByZWNvbmQuY2hlY2tTdGF0ZSh0aGlzLmlzUGVuZGluZygpLCAnRnVuY3Rpb25DYWxsIGluIHByb2dyZXNzLicpO1xuICAgIHRoaXMuZmFpbEFmdGVyXyA9IG1heE51bWJlck9mUmV0cnk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIFJldHVybiB0aGlzIGZvciBjaGFpbmluZy5cbn07XG5cbi8vIEFib3J0cyB0aGUgY2FsbC5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc0NvbXBsZXRlZCgpIHx8IHRoaXMuaXNBYm9ydGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1J1bm5pbmcoKSkge1xuICAgICAgICB0aGlzLmJhY2tvZmZfLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZV8gPSBGdW5jdGlvbkNhbGwuU3RhdGVfLkFCT1JURUQ7XG4gICAgdGhpcy5sYXN0UmVzdWx0XyA9IFtuZXcgRXJyb3IoJ0JhY2tvZmYgYWJvcnRlZC4nKV07XG4gICAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICAgIHRoaXMuZG9DYWxsYmFja18oKTtcbn07XG5cbi8vIEluaXRpYXRlcyB0aGUgY2FsbCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvbi4gQWNjZXB0cyBhbiBvcHRpb25hbCBmYWN0b3J5XG4vLyBmdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSB0aGUgYmFja29mZiBpbnN0YW5jZTsgdXNlZCB3aGVuIHRlc3RpbmcuXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oYmFja29mZkZhY3RvcnkpIHtcbiAgICBwcmVjb25kLmNoZWNrU3RhdGUoIXRoaXMuaXNBYm9ydGVkKCksICdGdW5jdGlvbkNhbGwgaXMgYWJvcnRlZC4nKTtcbiAgICBwcmVjb25kLmNoZWNrU3RhdGUodGhpcy5pc1BlbmRpbmcoKSwgJ0Z1bmN0aW9uQ2FsbCBhbHJlYWR5IHN0YXJ0ZWQuJyk7XG5cbiAgICB2YXIgc3RyYXRlZ3kgPSB0aGlzLnN0cmF0ZWd5XyB8fCBuZXcgRmlib25hY2NpQmFja29mZlN0cmF0ZWd5KCk7XG5cbiAgICB0aGlzLmJhY2tvZmZfID0gYmFja29mZkZhY3RvcnkgP1xuICAgICAgICBiYWNrb2ZmRmFjdG9yeShzdHJhdGVneSkgOlxuICAgICAgICBuZXcgQmFja29mZihzdHJhdGVneSk7XG5cbiAgICB0aGlzLmJhY2tvZmZfLm9uKCdyZWFkeScsIHRoaXMuZG9DYWxsXy5iaW5kKHRoaXMsIHRydWUgLyogaXNSZXRyeSAqLykpO1xuICAgIHRoaXMuYmFja29mZl8ub24oJ2ZhaWwnLCB0aGlzLmRvQ2FsbGJhY2tfLmJpbmQodGhpcykpO1xuICAgIHRoaXMuYmFja29mZl8ub24oJ2JhY2tvZmYnLCB0aGlzLmhhbmRsZUJhY2tvZmZfLmJpbmQodGhpcykpO1xuXG4gICAgaWYgKHRoaXMuZmFpbEFmdGVyXyA+IDApIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmXy5mYWlsQWZ0ZXIodGhpcy5mYWlsQWZ0ZXJfKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlXyA9IEZ1bmN0aW9uQ2FsbC5TdGF0ZV8uUlVOTklORztcbiAgICB0aGlzLmRvQ2FsbF8oZmFsc2UgLyogaXNSZXRyeSAqLyk7XG59O1xuXG4vLyBDYWxscyB0aGUgd3JhcHBlZCBmdW5jdGlvbi5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuZG9DYWxsXyA9IGZ1bmN0aW9uKGlzUmV0cnkpIHtcbiAgICBpZiAoaXNSZXRyeSkge1xuICAgICAgICB0aGlzLm51bVJldHJpZXNfKys7XG4gICAgfVxuICAgIHZhciBldmVudEFyZ3MgPSBbJ2NhbGwnXS5jb25jYXQodGhpcy5hcmd1bWVudHNfKTtcbiAgICBldmVudHMuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmFwcGx5KHRoaXMsIGV2ZW50QXJncyk7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5oYW5kbGVGdW5jdGlvbkNhbGxiYWNrXy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZnVuY3Rpb25fLmFwcGx5KG51bGwsIHRoaXMuYXJndW1lbnRzXy5jb25jYXQoY2FsbGJhY2spKTtcbn07XG5cbi8vIENhbGxzIHRoZSB3cmFwcGVkIGZ1bmN0aW9uJ3MgY2FsbGJhY2sgd2l0aCB0aGUgbGFzdCByZXN1bHQgcmV0dXJuZWQgYnkgdGhlXG4vLyB3cmFwcGVkIGZ1bmN0aW9uLlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5kb0NhbGxiYWNrXyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2FsbGJhY2tfLmFwcGx5KG51bGwsIHRoaXMubGFzdFJlc3VsdF8pO1xufTtcblxuLy8gSGFuZGxlcyB3cmFwcGVkIGZ1bmN0aW9uJ3MgY29tcGxldGlvbi4gVGhpcyBtZXRob2QgYWN0cyBhcyBhIHJlcGxhY2VtZW50XG4vLyBmb3IgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZ1bmN0aW9uLlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5oYW5kbGVGdW5jdGlvbkNhbGxiYWNrXyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzQWJvcnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5sYXN0UmVzdWx0XyA9IGFyZ3M7IC8vIFNhdmUgbGFzdCBjYWxsYmFjayBhcmd1bWVudHMuXG4gICAgZXZlbnRzLkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdC5hcHBseSh0aGlzLCBbJ2NhbGxiYWNrJ10uY29uY2F0KGFyZ3MpKTtcblxuICAgIHZhciBlcnIgPSBhcmdzWzBdO1xuICAgIGlmIChlcnIgJiYgdGhpcy5yZXRyeVByZWRpY2F0ZV8oZXJyKSkge1xuICAgICAgICB0aGlzLmJhY2tvZmZfLmJhY2tvZmYoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlXyA9IEZ1bmN0aW9uQ2FsbC5TdGF0ZV8uQ09NUExFVEVEO1xuICAgICAgICB0aGlzLmRvQ2FsbGJhY2tfKCk7XG4gICAgfVxufTtcblxuLy8gSGFuZGxlcyB0aGUgYmFja29mZiBldmVudCBieSByZWVtaXR0aW5nIGl0LlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5oYW5kbGVCYWNrb2ZmXyA9IGZ1bmN0aW9uKG51bWJlciwgZGVsYXksIGVycikge1xuICAgIHRoaXMuZW1pdCgnYmFja29mZicsIG51bWJlciwgZGVsYXksIGVycik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uQ2FsbDtcbiIsIi8vICAgICAgQ29weXJpZ2h0IChjKSAyMDEyIE1hdGhpZXUgVHVyY290dGVcbi8vICAgICAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBwcmVjb25kID0gcmVxdWlyZSgncHJlY29uZCcpO1xuXG52YXIgQmFja29mZlN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9zdHJhdGVneScpO1xuXG4vLyBFeHBvbmVudGlhbCBiYWNrb2ZmIHN0cmF0ZWd5LlxuZnVuY3Rpb24gRXhwb25lbnRpYWxCYWNrb2ZmU3RyYXRlZ3kob3B0aW9ucykge1xuICAgIEJhY2tvZmZTdHJhdGVneS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuYmFja29mZkRlbGF5XyA9IDA7XG4gICAgdGhpcy5uZXh0QmFja29mZkRlbGF5XyA9IHRoaXMuZ2V0SW5pdGlhbERlbGF5KCk7XG4gICAgdGhpcy5mYWN0b3JfID0gRXhwb25lbnRpYWxCYWNrb2ZmU3RyYXRlZ3kuREVGQVVMVF9GQUNUT1I7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZhY3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZWNvbmQuY2hlY2tBcmd1bWVudChvcHRpb25zLmZhY3RvciA+IDEsXG4gICAgICAgICAgICAnRXhwb25lbnRpYWwgZmFjdG9yIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gMSBidXQgZ290ICVzLicsXG4gICAgICAgICAgICBvcHRpb25zLmZhY3Rvcik7XG4gICAgICAgIHRoaXMuZmFjdG9yXyA9IG9wdGlvbnMuZmFjdG9yO1xuICAgIH1cbn1cbnV0aWwuaW5oZXJpdHMoRXhwb25lbnRpYWxCYWNrb2ZmU3RyYXRlZ3ksIEJhY2tvZmZTdHJhdGVneSk7XG5cbi8vIERlZmF1bHQgbXVsdGlwbGljYXRpb24gZmFjdG9yIHVzZWQgdG8gY29tcHV0ZSB0aGUgbmV4dCBiYWNrb2ZmIGRlbGF5IGZyb21cbi8vIHRoZSBjdXJyZW50IG9uZS4gVGhlIHZhbHVlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmcgYSBjdXN0b20gZmFjdG9yIGFzXG4vLyBwYXJ0IG9mIHRoZSBvcHRpb25zLlxuRXhwb25lbnRpYWxCYWNrb2ZmU3RyYXRlZ3kuREVGQVVMVF9GQUNUT1IgPSAyO1xuXG5FeHBvbmVudGlhbEJhY2tvZmZTdHJhdGVneS5wcm90b3R5cGUubmV4dF8gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJhY2tvZmZEZWxheV8gPSBNYXRoLm1pbih0aGlzLm5leHRCYWNrb2ZmRGVsYXlfLCB0aGlzLmdldE1heERlbGF5KCkpO1xuICAgIHRoaXMubmV4dEJhY2tvZmZEZWxheV8gPSB0aGlzLmJhY2tvZmZEZWxheV8gKiB0aGlzLmZhY3Rvcl87XG4gICAgcmV0dXJuIHRoaXMuYmFja29mZkRlbGF5Xztcbn07XG5cbkV4cG9uZW50aWFsQmFja29mZlN0cmF0ZWd5LnByb3RvdHlwZS5yZXNldF8gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJhY2tvZmZEZWxheV8gPSAwO1xuICAgIHRoaXMubmV4dEJhY2tvZmZEZWxheV8gPSB0aGlzLmdldEluaXRpYWxEZWxheSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeHBvbmVudGlhbEJhY2tvZmZTdHJhdGVneTtcbiIsIi8vICAgICAgQ29weXJpZ2h0IChjKSAyMDEyIE1hdGhpZXUgVHVyY290dGVcbi8vICAgICAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIEJhY2tvZmZTdHJhdGVneSA9IHJlcXVpcmUoJy4vc3RyYXRlZ3knKTtcblxuLy8gRmlib25hY2NpIGJhY2tvZmYgc3RyYXRlZ3kuXG5mdW5jdGlvbiBGaWJvbmFjY2lCYWNrb2ZmU3RyYXRlZ3kob3B0aW9ucykge1xuICAgIEJhY2tvZmZTdHJhdGVneS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuYmFja29mZkRlbGF5XyA9IDA7XG4gICAgdGhpcy5uZXh0QmFja29mZkRlbGF5XyA9IHRoaXMuZ2V0SW5pdGlhbERlbGF5KCk7XG59XG51dGlsLmluaGVyaXRzKEZpYm9uYWNjaUJhY2tvZmZTdHJhdGVneSwgQmFja29mZlN0cmF0ZWd5KTtcblxuRmlib25hY2NpQmFja29mZlN0cmF0ZWd5LnByb3RvdHlwZS5uZXh0XyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiYWNrb2ZmRGVsYXkgPSBNYXRoLm1pbih0aGlzLm5leHRCYWNrb2ZmRGVsYXlfLCB0aGlzLmdldE1heERlbGF5KCkpO1xuICAgIHRoaXMubmV4dEJhY2tvZmZEZWxheV8gKz0gdGhpcy5iYWNrb2ZmRGVsYXlfO1xuICAgIHRoaXMuYmFja29mZkRlbGF5XyA9IGJhY2tvZmZEZWxheTtcbiAgICByZXR1cm4gYmFja29mZkRlbGF5O1xufTtcblxuRmlib25hY2NpQmFja29mZlN0cmF0ZWd5LnByb3RvdHlwZS5yZXNldF8gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm5leHRCYWNrb2ZmRGVsYXlfID0gdGhpcy5nZXRJbml0aWFsRGVsYXkoKTtcbiAgICB0aGlzLmJhY2tvZmZEZWxheV8gPSAwO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWJvbmFjY2lCYWNrb2ZmU3RyYXRlZ3k7XG4iLCIvLyAgICAgIENvcHlyaWdodCAoYykgMjAxMiBNYXRoaWV1IFR1cmNvdHRlXG4vLyAgICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGlzRGVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbi8vIEFic3RyYWN0IGNsYXNzIGRlZmluaW5nIHRoZSBza2VsZXRvbiBmb3IgdGhlIGJhY2tvZmYgc3RyYXRlZ2llcy4gQWNjZXB0cyBhblxuLy8gb2JqZWN0IGhvbGRpbmcgdGhlIG9wdGlvbnMgZm9yIHRoZSBiYWNrb2ZmIHN0cmF0ZWd5OlxuLy9cbi8vICAqIGByYW5kb21pc2F0aW9uRmFjdG9yYDogVGhlIHJhbmRvbWlzYXRpb24gZmFjdG9yIHdoaWNoIG11c3QgYmUgYmV0d2VlbiAwXG4vLyAgICAgYW5kIDEgd2hlcmUgMSBlcXVhdGVzIHRvIGEgcmFuZG9taXphdGlvbiBmYWN0b3Igb2YgMTAwJSBhbmQgMCB0byBub1xuLy8gICAgIHJhbmRvbWl6YXRpb24uXG4vLyAgKiBgaW5pdGlhbERlbGF5YDogVGhlIGJhY2tvZmYgaW5pdGlhbCBkZWxheSBpbiBtaWxsaXNlY29uZHMuXG4vLyAgKiBgbWF4RGVsYXlgOiBUaGUgYmFja29mZiBtYXhpbWFsIGRlbGF5IGluIG1pbGxpc2Vjb25kcy5cbmZ1bmN0aW9uIEJhY2tvZmZTdHJhdGVneShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoaXNEZWYob3B0aW9ucy5pbml0aWFsRGVsYXkpICYmIG9wdGlvbnMuaW5pdGlhbERlbGF5IDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbml0aWFsIHRpbWVvdXQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKG9wdGlvbnMubWF4RGVsYXkpICYmIG9wdGlvbnMubWF4RGVsYXkgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIG1heGltYWwgdGltZW91dCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLicpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbERlbGF5XyA9IG9wdGlvbnMuaW5pdGlhbERlbGF5IHx8IDEwMDtcbiAgICB0aGlzLm1heERlbGF5XyA9IG9wdGlvbnMubWF4RGVsYXkgfHwgMTAwMDA7XG5cbiAgICBpZiAodGhpcy5tYXhEZWxheV8gPD0gdGhpcy5pbml0aWFsRGVsYXlfKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIG1heGltYWwgYmFja29mZiBkZWxheSBtdXN0IGJlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dyZWF0ZXIgdGhhbiB0aGUgaW5pdGlhbCBiYWNrb2ZmIGRlbGF5LicpO1xuICAgIH1cblxuICAgIGlmIChpc0RlZihvcHRpb25zLnJhbmRvbWlzYXRpb25GYWN0b3IpICYmXG4gICAgICAgIChvcHRpb25zLnJhbmRvbWlzYXRpb25GYWN0b3IgPCAwIHx8IG9wdGlvbnMucmFuZG9taXNhdGlvbkZhY3RvciA+IDEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJhbmRvbWlzYXRpb24gZmFjdG9yIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLicpO1xuICAgIH1cblxuICAgIHRoaXMucmFuZG9taXNhdGlvbkZhY3Rvcl8gPSBvcHRpb25zLnJhbmRvbWlzYXRpb25GYWN0b3IgfHwgMDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW1hbCBiYWNrb2ZmIGRlbGF5LlxuQmFja29mZlN0cmF0ZWd5LnByb3RvdHlwZS5nZXRNYXhEZWxheSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1heERlbGF5Xztcbn07XG5cbi8vIEdldHMgdGhlIGluaXRpYWwgYmFja29mZiBkZWxheS5cbkJhY2tvZmZTdHJhdGVneS5wcm90b3R5cGUuZ2V0SW5pdGlhbERlbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbERlbGF5Xztcbn07XG5cbi8vIFRlbXBsYXRlIG1ldGhvZCB0aGF0IGNvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBuZXh0IGJhY2tvZmYgZGVsYXkgaW5cbi8vIG1pbGxpc2Vjb25kcy5cbkJhY2tvZmZTdHJhdGVneS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiYWNrb2ZmRGVsYXkgPSB0aGlzLm5leHRfKCk7XG4gICAgdmFyIHJhbmRvbWlzYXRpb25NdWx0aXBsZSA9IDEgKyBNYXRoLnJhbmRvbSgpICogdGhpcy5yYW5kb21pc2F0aW9uRmFjdG9yXztcbiAgICB2YXIgcmFuZG9taXplZERlbGF5ID0gTWF0aC5yb3VuZChiYWNrb2ZmRGVsYXkgKiByYW5kb21pc2F0aW9uTXVsdGlwbGUpO1xuICAgIHJldHVybiByYW5kb21pemVkRGVsYXk7XG59O1xuXG4vLyBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgbmV4dCBiYWNrb2ZmIGRlbGF5LiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5XG4vLyBzdWJjbGFzc2VzLlxuQmFja29mZlN0cmF0ZWd5LnByb3RvdHlwZS5uZXh0XyA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFja29mZlN0cmF0ZWd5Lm5leHRfKCkgdW5pbXBsZW1lbnRlZC4nKTtcbn07XG5cbi8vIFRlbXBsYXRlIG1ldGhvZCB0aGF0IHJlc2V0cyB0aGUgYmFja29mZiBkZWxheSB0byBpdHMgaW5pdGlhbCB2YWx1ZS5cbkJhY2tvZmZTdHJhdGVneS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlc2V0XygpO1xufTtcblxuLy8gUmVzZXRzIHRoZSBiYWNrb2ZmIGRlbGF5IHRvIGl0cyBpbml0aWFsIHZhbHVlLiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5XG4vLyBzdWJjbGFzc2VzLlxuQmFja29mZlN0cmF0ZWd5LnByb3RvdHlwZS5yZXNldF8gPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhY2tvZmZTdHJhdGVneS5yZXNldF8oKSB1bmltcGxlbWVudGVkLicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmU3RyYXRlZ3k7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE1hdGhpZXUgVHVyY290dGVcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2NoZWNrcycpOyIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTWF0aGlldSBUdXJjb3R0ZVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgZXJyb3JzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5mdW5jdGlvbiBmYWlsQ2hlY2soRXhjZXB0aW9uQ29uc3RydWN0b3IsIGNhbGxlZSwgbWVzc2FnZUZvcm1hdCwgZm9ybWF0QXJncykge1xuICAgIG1lc3NhZ2VGb3JtYXQgPSBtZXNzYWdlRm9ybWF0IHx8ICcnO1xuICAgIHZhciBtZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkodGhpcywgW21lc3NhZ2VGb3JtYXRdLmNvbmNhdChmb3JtYXRBcmdzKSk7XG4gICAgdmFyIGVycm9yID0gbmV3IEV4Y2VwdGlvbkNvbnN0cnVjdG9yKG1lc3NhZ2UpO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBjYWxsZWUpO1xuICAgIHRocm93IGVycm9yO1xufVxuXG5mdW5jdGlvbiBmYWlsQXJndW1lbnRDaGVjayhjYWxsZWUsIG1lc3NhZ2UsIGZvcm1hdEFyZ3MpIHtcbiAgICBmYWlsQ2hlY2soZXJyb3JzLklsbGVnYWxBcmd1bWVudEVycm9yLCBjYWxsZWUsIG1lc3NhZ2UsIGZvcm1hdEFyZ3MpO1xufVxuXG5mdW5jdGlvbiBmYWlsU3RhdGVDaGVjayhjYWxsZWUsIG1lc3NhZ2UsIGZvcm1hdEFyZ3MpIHtcbiAgICBmYWlsQ2hlY2soZXJyb3JzLklsbGVnYWxTdGF0ZUVycm9yLCBjYWxsZWUsIG1lc3NhZ2UsIGZvcm1hdEFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5jaGVja0FyZ3VtZW50ID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIGZhaWxBcmd1bWVudENoZWNrKGFyZ3VtZW50cy5jYWxsZWUsIG1lc3NhZ2UsXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jaGVja1N0YXRlID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIGZhaWxTdGF0ZUNoZWNrKGFyZ3VtZW50cy5jYWxsZWUsIG1lc3NhZ2UsXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jaGVja0lzRGVmID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZmFpbEFyZ3VtZW50Q2hlY2soYXJndW1lbnRzLmNhbGxlZSwgbWVzc2FnZSB8fFxuICAgICAgICAnRXhwZWN0ZWQgdmFsdWUgdG8gYmUgZGVmaW5lZCBidXQgd2FzIHVuZGVmaW5lZC4nLFxuICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNoZWNrSXNEZWZBbmROb3ROdWxsID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAvLyBOb3RlIHRoYXQgdW5kZWZpbmVkID09IG51bGwuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZhaWxBcmd1bWVudENoZWNrKGFyZ3VtZW50cy5jYWxsZWUsIG1lc3NhZ2UgfHxcbiAgICAgICAgJ0V4cGVjdGVkIHZhbHVlIHRvIGJlIGRlZmluZWQgYW5kIG5vdCBudWxsIGJ1dCBnb3QgXCInICtcbiAgICAgICAgdHlwZU9mKHZhbHVlKSArICdcIi4nLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbn07XG5cbi8vIEZpeGVkIHZlcnNpb24gb2YgdGhlIHR5cGVPZiBvcGVyYXRvciB3aGljaCByZXR1cm5zICdudWxsJyBmb3IgbnVsbCB2YWx1ZXNcbi8vIGFuZCAnYXJyYXknIGZvciBhcnJheXMuXG5mdW5jdGlvbiB0eXBlT2YodmFsdWUpIHtcbiAgICB2YXIgcyA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAocyA9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiB0eXBlQ2hlY2soZXhwZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZU9mKHZhbHVlKTtcblxuICAgICAgICBpZiAodHlwZSA9PSBleHBlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZhaWxBcmd1bWVudENoZWNrKGFyZ3VtZW50cy5jYWxsZWUsIG1lc3NhZ2UgfHxcbiAgICAgICAgICAgICdFeHBlY3RlZCBcIicgKyBleHBlY3QgKyAnXCIgYnV0IGdvdCBcIicgKyB0eXBlICsgJ1wiLicsXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cy5jaGVja0lzU3RyaW5nID0gdHlwZUNoZWNrKCdzdHJpbmcnKTtcbm1vZHVsZS5leHBvcnRzLmNoZWNrSXNBcnJheSA9IHR5cGVDaGVjaygnYXJyYXknKTtcbm1vZHVsZS5leHBvcnRzLmNoZWNrSXNOdW1iZXIgPSB0eXBlQ2hlY2soJ251bWJlcicpO1xubW9kdWxlLmV4cG9ydHMuY2hlY2tJc0Jvb2xlYW4gPSB0eXBlQ2hlY2soJ2Jvb2xlYW4nKTtcbm1vZHVsZS5leHBvcnRzLmNoZWNrSXNGdW5jdGlvbiA9IHR5cGVDaGVjaygnZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzLmNoZWNrSXNPYmplY3QgPSB0eXBlQ2hlY2soJ29iamVjdCcpO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxMiBNYXRoaWV1IFR1cmNvdHRlXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIElsbGVnYWxBcmd1bWVudEVycm9yKG1lc3NhZ2UpIHtcbiAgICBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG51dGlsLmluaGVyaXRzKElsbGVnYWxBcmd1bWVudEVycm9yLCBFcnJvcik7XG5cbklsbGVnYWxBcmd1bWVudEVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0lsbGVnYWxBcmd1bWVudEVycm9yJztcblxuZnVuY3Rpb24gSWxsZWdhbFN0YXRlRXJyb3IobWVzc2FnZSkge1xuICAgIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cbnV0aWwuaW5oZXJpdHMoSWxsZWdhbFN0YXRlRXJyb3IsIEVycm9yKTtcblxuSWxsZWdhbFN0YXRlRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSWxsZWdhbFN0YXRlRXJyb3InO1xuXG5tb2R1bGUuZXhwb3J0cy5JbGxlZ2FsU3RhdGVFcnJvciA9IElsbGVnYWxTdGF0ZUVycm9yO1xubW9kdWxlLmV4cG9ydHMuSWxsZWdhbEFyZ3VtZW50RXJyb3IgPSBJbGxlZ2FsQXJndW1lbnRFcnJvcjsiLCJtb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn0iLCJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn0iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCJpbXBvcnQgc2V0UHJvdG90eXBlT2YgZnJvbSBcIi4vc2V0UHJvdG90eXBlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufSIsImltcG9ydCBhcnJheVdpdGhvdXRIb2xlcyBmcm9tIFwiLi9hcnJheVdpdGhvdXRIb2xlcy5qc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIjtcbmltcG9ydCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IG5vbkl0ZXJhYmxlU3ByZWFkIGZyb20gXCIuL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn0iLCJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufSIsImltcG9ydCBpc0luQnJvd3NlciBmcm9tICdpcy1pbi1icm93c2VyJztcbmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXknO1xuXG4vLyBFeHBvcnQgamF2YXNjcmlwdCBzdHlsZSBhbmQgY3NzIHN0eWxlIHZlbmRvciBwcmVmaXhlcy5cbnZhciBqcyA9ICcnO1xudmFyIGNzcyA9ICcnO1xudmFyIHZlbmRvciA9ICcnO1xudmFyIGJyb3dzZXIgPSAnJztcbnZhciBpc1RvdWNoID0gaXNJbkJyb3dzZXIgJiYgJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyAvLyBXZSBzaG91bGQgbm90IGRvIGFueXRoaW5nIGlmIHJlcXVpcmVkIHNlcnZlcnNpZGUuXG5cbmlmIChpc0luQnJvd3Nlcikge1xuICAvLyBPcmRlciBtYXR0ZXJzLiBXZSBuZWVkIHRvIGNoZWNrIFdlYmtpdCB0aGUgbGFzdCBvbmUgYmVjYXVzZVxuICAvLyBvdGhlciB2ZW5kb3JzIHVzZSB0byBhZGQgV2Via2l0IHByZWZpeGVzIHRvIHNvbWUgcHJvcGVydGllc1xuICB2YXIganNDc3NNYXAgPSB7XG4gICAgTW96OiAnLW1vei0nLFxuICAgIG1zOiAnLW1zLScsXG4gICAgTzogJy1vLScsXG4gICAgV2Via2l0OiAnLXdlYmtpdC0nXG4gIH07XG5cbiAgdmFyIF9kb2N1bWVudCRjcmVhdGVFbGVtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKSxcbiAgICAgIHN0eWxlID0gX2RvY3VtZW50JGNyZWF0ZUVsZW1lLnN0eWxlO1xuXG4gIHZhciB0ZXN0UHJvcCA9ICdUcmFuc2Zvcm0nO1xuXG4gIGZvciAodmFyIGtleSBpbiBqc0Nzc01hcCkge1xuICAgIGlmIChrZXkgKyB0ZXN0UHJvcCBpbiBzdHlsZSkge1xuICAgICAganMgPSBrZXk7XG4gICAgICBjc3MgPSBqc0Nzc01hcFtrZXldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9IC8vIENvcnJlY3RseSBkZXRlY3QgdGhlIEVkZ2UgYnJvd3Nlci5cblxuXG4gIGlmIChqcyA9PT0gJ1dlYmtpdCcgJiYgJ21zSHlwaGVucycgaW4gc3R5bGUpIHtcbiAgICBqcyA9ICdtcyc7XG4gICAgY3NzID0ganNDc3NNYXAubXM7XG4gICAgYnJvd3NlciA9ICdlZGdlJztcbiAgfSAvLyBDb3JyZWN0bHkgZGV0ZWN0IHRoZSBTYWZhcmkgYnJvd3Nlci5cblxuXG4gIGlmIChqcyA9PT0gJ1dlYmtpdCcgJiYgJy1hcHBsZS10cmFpbGluZy13b3JkJyBpbiBzdHlsZSkge1xuICAgIHZlbmRvciA9ICdhcHBsZSc7XG4gIH1cbn1cbi8qKlxuICogVmVuZG9yIHByZWZpeCBzdHJpbmcgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHR5cGUge3tqczogU3RyaW5nLCBjc3M6IFN0cmluZywgdmVuZG9yOiBTdHJpbmcsIGJyb3dzZXI6IFN0cmluZ319XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxudmFyIHByZWZpeCA9IHtcbiAganM6IGpzLFxuICBjc3M6IGNzcyxcbiAgdmVuZG9yOiB2ZW5kb3IsXG4gIGJyb3dzZXI6IGJyb3dzZXIsXG4gIGlzVG91Y2g6IGlzVG91Y2hcbn07XG5cbi8qKlxuICogVGVzdCBpZiBhIGtleWZyYW1lIGF0LXJ1bGUgc2hvdWxkIGJlIHByZWZpeGVkIG9yIG5vdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2ZW5kb3IgcHJlZml4IHN0cmluZyBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydGVkS2V5ZnJhbWVzKGtleSkge1xuICAvLyBLZXlmcmFtZXMgaXMgYWxyZWFkeSBwcmVmaXhlZC4gZS5nLiBrZXkgPSAnQC13ZWJraXQta2V5ZnJhbWVzIGEnXG4gIGlmIChrZXlbMV0gPT09ICctJykgcmV0dXJuIGtleTsgLy8gTm8gbmVlZCB0byBwcmVmaXggSUUvRWRnZS4gT2xkZXIgYnJvd3NlcnMgd2lsbCBpZ25vcmUgdW5zdXBwb3J0ZWQgcnVsZXMuXG4gIC8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1rZXlmcmFtZXNcblxuICBpZiAocHJlZml4LmpzID09PSAnbXMnKSByZXR1cm4ga2V5O1xuICByZXR1cm4gXCJAXCIgKyBwcmVmaXguY3NzICsgXCJrZXlmcmFtZXNcIiArIGtleS5zdWJzdHIoMTApO1xufVxuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9YXBwZWFyYW5jZVxuXG52YXIgYXBwZWFyZW5jZSA9IHtcbiAgbm9QcmVmaWxsOiBbJ2FwcGVhcmFuY2UnXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3ApIHtcbiAgICBpZiAocHJvcCAhPT0gJ2FwcGVhcmFuY2UnKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ21zJykgcmV0dXJuIFwiLXdlYmtpdC1cIiArIHByb3A7XG4gICAgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9Y29sb3ItYWRqdXN0XG5cbnZhciBjb2xvckFkanVzdCA9IHtcbiAgbm9QcmVmaWxsOiBbJ2NvbG9yLWFkanVzdCddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCkge1xuICAgIGlmIChwcm9wICE9PSAnY29sb3ItYWRqdXN0JykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwcmVmaXguanMgPT09ICdXZWJraXQnKSByZXR1cm4gcHJlZml4LmNzcyArIFwicHJpbnQtXCIgKyBwcm9wO1xuICAgIHJldHVybiBwcm9wO1xuICB9XG59O1xuXG52YXIgcmVnRXhwID0gL1stXFxzXSsoLik/L2c7XG4vKipcbiAqIFJlcGxhY2VzIHRoZSBsZXR0ZXIgd2l0aCB0aGUgY2FwaXRhbCBsZXR0ZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBjXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0b1VwcGVyKG1hdGNoLCBjKSB7XG4gIHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7XG59XG4vKipcbiAqIENvbnZlcnQgZGFzaCBzZXBhcmF0ZWQgc3RyaW5ncyB0byBjYW1lbC1jYXNlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnRXhwLCB0b1VwcGVyKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGRhc2ggc2VwYXJhdGVkIHN0cmluZ3MgdG8gcGFzY2FsIGNhc2VkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhc2NhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIGNhbWVsaXplKFwiLVwiICsgc3RyKTtcbn1cblxuLy8gYnV0IHdlIGNhbiB1c2UgYSBsb25naGFuZCBwcm9wZXJ0eSBpbnN0ZWFkLlxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPW1hc2tcblxudmFyIG1hc2sgPSB7XG4gIG5vUHJlZmlsbDogWydtYXNrJ10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSkge1xuICAgIGlmICghL15tYXNrLy50ZXN0KHByb3ApKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocHJlZml4LmpzID09PSAnV2Via2l0Jykge1xuICAgICAgdmFyIGxvbmdoYW5kID0gJ21hc2staW1hZ2UnO1xuXG4gICAgICBpZiAoY2FtZWxpemUobG9uZ2hhbmQpIGluIHN0eWxlKSB7XG4gICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJlZml4LmpzICsgcGFzY2FsaXplKGxvbmdoYW5kKSBpbiBzdHlsZSkge1xuICAgICAgICByZXR1cm4gcHJlZml4LmNzcyArIHByb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD10ZXh0LW9yaWVudGF0aW9uXG5cbnZhciB0ZXh0T3JpZW50YXRpb24gPSB7XG4gIG5vUHJlZmlsbDogWyd0ZXh0LW9yaWVudGF0aW9uJ10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKHByb3AgIT09ICd0ZXh0LW9yaWVudGF0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByZWZpeC52ZW5kb3IgPT09ICdhcHBsZScgJiYgIXByZWZpeC5pc1RvdWNoKSB7XG4gICAgICByZXR1cm4gcHJlZml4LmNzcyArIHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD10cmFuc2Zvcm1cblxudmFyIHRyYW5zZm9ybSA9IHtcbiAgbm9QcmVmaWxsOiBbJ3RyYW5zZm9ybSddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAocHJvcCAhPT0gJ3RyYW5zZm9ybScpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLnRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9dHJhbnNpdGlvblxuXG52YXIgdHJhbnNpdGlvbiA9IHtcbiAgbm9QcmVmaWxsOiBbJ3RyYW5zaXRpb24nXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKHByb3AgIT09ICd0cmFuc2l0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9d3JpdGluZy1tb2RlXG5cbnZhciB3cml0aW5nTW9kZSA9IHtcbiAgbm9QcmVmaWxsOiBbJ3dyaXRpbmctbW9kZSddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCkge1xuICAgIGlmIChwcm9wICE9PSAnd3JpdGluZy1tb2RlJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ1dlYmtpdCcgfHwgcHJlZml4LmpzID09PSAnbXMnICYmIHByZWZpeC5icm93c2VyICE9PSAnZWRnZScpIHtcbiAgICAgIHJldHVybiBwcmVmaXguY3NzICsgcHJvcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXVzZXItc2VsZWN0XG5cbnZhciB1c2VyU2VsZWN0ID0ge1xuICBub1ByZWZpbGw6IFsndXNlci1zZWxlY3QnXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3ApIHtcbiAgICBpZiAocHJvcCAhPT0gJ3VzZXItc2VsZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ01veicgfHwgcHJlZml4LmpzID09PSAnbXMnIHx8IHByZWZpeC52ZW5kb3IgPT09ICdhcHBsZScpIHtcbiAgICAgIHJldHVybiBwcmVmaXguY3NzICsgcHJvcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPW11bHRpY29sdW1uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcG9zdGNzcy9hdXRvcHJlZml4ZXIvaXNzdWVzLzQ5MVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bvc3Rjc3MvYXV0b3ByZWZpeGVyL2lzc3Vlcy8xNzdcblxudmFyIGJyZWFrUHJvcHNPbGQgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSkge1xuICAgIGlmICghL15icmVhay0vLnRlc3QocHJvcCkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcmVmaXguanMgPT09ICdXZWJraXQnKSB7XG4gICAgICB2YXIganNQcm9wID0gXCJXZWJraXRDb2x1bW5cIiArIHBhc2NhbGl6ZShwcm9wKTtcbiAgICAgIHJldHVybiBqc1Byb3AgaW4gc3R5bGUgPyBwcmVmaXguY3NzICsgXCJjb2x1bW4tXCIgKyBwcm9wIDogZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ01veicpIHtcbiAgICAgIHZhciBfanNQcm9wID0gXCJwYWdlXCIgKyBwYXNjYWxpemUocHJvcCk7XG5cbiAgICAgIHJldHVybiBfanNQcm9wIGluIHN0eWxlID8gXCJwYWdlLVwiICsgcHJvcCA6IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3N0Y3NzL2F1dG9wcmVmaXhlci9pc3N1ZXMvMzI0LlxuXG52YXIgaW5saW5lTG9naWNhbE9sZCA9IHtcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlKSB7XG4gICAgaWYgKCEvXihib3JkZXJ8bWFyZ2lufHBhZGRpbmcpLWlubGluZS8udGVzdChwcm9wKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwcmVmaXguanMgPT09ICdNb3onKSByZXR1cm4gcHJvcDtcbiAgICB2YXIgbmV3UHJvcCA9IHByb3AucmVwbGFjZSgnLWlubGluZScsICcnKTtcbiAgICByZXR1cm4gcHJlZml4LmpzICsgcGFzY2FsaXplKG5ld1Byb3ApIGluIHN0eWxlID8gcHJlZml4LmNzcyArIG5ld1Byb3AgOiBmYWxzZTtcbiAgfVxufTtcblxuLy8gQ2FtZWxpemF0aW9uIGlzIHJlcXVpcmVkIGJlY2F1c2Ugd2UgY2FuJ3QgdGVzdCB1c2luZy5cbi8vIENTUyBzeW50YXggZm9yIGUuZy4gaW4gRkYuXG5cbnZhciB1bnByZWZpeGVkID0ge1xuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUpIHtcbiAgICByZXR1cm4gY2FtZWxpemUocHJvcCkgaW4gc3R5bGUgPyBwcm9wIDogZmFsc2U7XG4gIH1cbn07XG5cbnZhciBwcmVmaXhlZCA9IHtcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlKSB7XG4gICAgdmFyIHBhc2NhbGl6ZWQgPSBwYXNjYWxpemUocHJvcCk7IC8vIFJldHVybiBjdXN0b20gQ1NTIHZhcmlhYmxlIHdpdGhvdXQgcHJlZml4aW5nLlxuXG4gICAgaWYgKHByb3BbMF0gPT09ICctJykgcmV0dXJuIHByb3A7IC8vIFJldHVybiBhbHJlYWR5IHByZWZpeGVkIHZhbHVlIHdpdGhvdXQgcHJlZml4aW5nLlxuXG4gICAgaWYgKHByb3BbMF0gPT09ICctJyAmJiBwcm9wWzFdID09PSAnLScpIHJldHVybiBwcm9wO1xuICAgIGlmIChwcmVmaXguanMgKyBwYXNjYWxpemVkIGluIHN0eWxlKSByZXR1cm4gcHJlZml4LmNzcyArIHByb3A7IC8vIFRyeSB3ZWJraXQgZmFsbGJhY2suXG5cbiAgICBpZiAocHJlZml4LmpzICE9PSAnV2Via2l0JyAmJiBcIldlYmtpdFwiICsgcGFzY2FsaXplZCBpbiBzdHlsZSkgcmV0dXJuIFwiLXdlYmtpdC1cIiArIHByb3A7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9c2Nyb2xsLXNuYXBcblxudmFyIHNjcm9sbFNuYXAgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKHByb3Auc3Vic3RyaW5nKDAsIDExKSAhPT0gJ3Njcm9sbC1zbmFwJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ21zJykge1xuICAgICAgcmV0dXJuIFwiXCIgKyBwcmVmaXguY3NzICsgcHJvcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPW92ZXJzY3JvbGwtYmVoYXZpb3JcblxudmFyIG92ZXJzY3JvbGxCZWhhdmlvciA9IHtcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3ApIHtcbiAgICBpZiAocHJvcCAhPT0gJ292ZXJzY3JvbGwtYmVoYXZpb3InKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocHJlZml4LmpzID09PSAnbXMnKSB7XG4gICAgICByZXR1cm4gcHJlZml4LmNzcyArIFwic2Nyb2xsLWNoYWluaW5nXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbnZhciBwcm9wTWFwID0ge1xuICAnZmxleC1ncm93JzogJ2ZsZXgtcG9zaXRpdmUnLFxuICAnZmxleC1zaHJpbmsnOiAnZmxleC1uZWdhdGl2ZScsXG4gICdmbGV4LWJhc2lzJzogJ2ZsZXgtcHJlZmVycmVkLXNpemUnLFxuICAnanVzdGlmeS1jb250ZW50JzogJ2ZsZXgtcGFjaycsXG4gIG9yZGVyOiAnZmxleC1vcmRlcicsXG4gICdhbGlnbi1pdGVtcyc6ICdmbGV4LWFsaWduJyxcbiAgJ2FsaWduLWNvbnRlbnQnOiAnZmxleC1saW5lLXBhY2snIC8vICdhbGlnbi1zZWxmJyBpcyBoYW5kbGVkIGJ5ICdhbGlnbi1zZWxmJyBwbHVnaW4uXG5cbn07IC8vIFN1cHBvcnQgb2xkIGZsZXggc3BlYyBmcm9tIDIwMTIuXG5cbnZhciBmbGV4MjAxMiA9IHtcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlKSB7XG4gICAgdmFyIG5ld1Byb3AgPSBwcm9wTWFwW3Byb3BdO1xuICAgIGlmICghbmV3UHJvcCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBwcmVmaXguanMgKyBwYXNjYWxpemUobmV3UHJvcCkgaW4gc3R5bGUgPyBwcmVmaXguY3NzICsgbmV3UHJvcCA6IGZhbHNlO1xuICB9XG59O1xuXG52YXIgcHJvcE1hcCQxID0ge1xuICBmbGV4OiAnYm94LWZsZXgnLFxuICAnZmxleC1ncm93JzogJ2JveC1mbGV4JyxcbiAgJ2ZsZXgtZGlyZWN0aW9uJzogWydib3gtb3JpZW50JywgJ2JveC1kaXJlY3Rpb24nXSxcbiAgb3JkZXI6ICdib3gtb3JkaW5hbC1ncm91cCcsXG4gICdhbGlnbi1pdGVtcyc6ICdib3gtYWxpZ24nLFxuICAnZmxleC1mbG93JzogWydib3gtb3JpZW50JywgJ2JveC1kaXJlY3Rpb24nXSxcbiAgJ2p1c3RpZnktY29udGVudCc6ICdib3gtcGFjaydcbn07XG52YXIgcHJvcEtleXMgPSBPYmplY3Qua2V5cyhwcm9wTWFwJDEpO1xuXG52YXIgcHJlZml4Q3NzID0gZnVuY3Rpb24gcHJlZml4Q3NzKHApIHtcbiAgcmV0dXJuIHByZWZpeC5jc3MgKyBwO1xufTsgLy8gU3VwcG9ydCBvbGQgZmxleCBzcGVjIGZyb20gMjAwOS5cblxuXG52YXIgZmxleDIwMDkgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSwgX3JlZikge1xuICAgIHZhciBtdWx0aXBsZSA9IF9yZWYubXVsdGlwbGU7XG5cbiAgICBpZiAocHJvcEtleXMuaW5kZXhPZihwcm9wKSA+IC0xKSB7XG4gICAgICB2YXIgbmV3UHJvcCA9IHByb3BNYXAkMVtwcm9wXTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG5ld1Byb3ApKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXguanMgKyBwYXNjYWxpemUobmV3UHJvcCkgaW4gc3R5bGUgPyBwcmVmaXguY3NzICsgbmV3UHJvcCA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW11bHRpcGxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3UHJvcC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIShwcmVmaXguanMgKyBwYXNjYWxpemUobmV3UHJvcFswXSkgaW4gc3R5bGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdQcm9wLm1hcChwcmVmaXhDc3MpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gcGx1Z2lucyA9IFtcbi8vICAgLi4ucGx1Z2lucyxcbi8vICAgIGJyZWFrUHJvcHNPbGQsXG4vLyAgICBpbmxpbmVMb2dpY2FsT2xkLFxuLy8gICAgdW5wcmVmaXhlZCxcbi8vICAgIHByZWZpeGVkLFxuLy8gICAgc2Nyb2xsU25hcCxcbi8vICAgIGZsZXgyMDEyLFxuLy8gICAgZmxleDIwMDlcbi8vIF1cbi8vIFBsdWdpbnMgd2l0aG91dCAnbm9QcmVmaWxsJyB2YWx1ZSwgZ29pbmcgbGFzdC5cbi8vICdmbGV4LSonIHBsdWdpbnMgc2hvdWxkIGJlIGF0IHRoZSBib3R0b20uXG4vLyAnZmxleDIwMDknIGdvaW5nIGFmdGVyICdmbGV4MjAxMicuXG4vLyAncHJlZml4ZWQnIGdvaW5nIGFmdGVyICd1bnByZWZpeGVkJ1xuXG52YXIgcGx1Z2lucyA9IFthcHBlYXJlbmNlLCBjb2xvckFkanVzdCwgbWFzaywgdGV4dE9yaWVudGF0aW9uLCB0cmFuc2Zvcm0sIHRyYW5zaXRpb24sIHdyaXRpbmdNb2RlLCB1c2VyU2VsZWN0LCBicmVha1Byb3BzT2xkLCBpbmxpbmVMb2dpY2FsT2xkLCB1bnByZWZpeGVkLCBwcmVmaXhlZCwgc2Nyb2xsU25hcCwgb3ZlcnNjcm9sbEJlaGF2aW9yLCBmbGV4MjAxMiwgZmxleDIwMDldO1xudmFyIHByb3BlcnR5RGV0ZWN0b3JzID0gcGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIHAuc3VwcG9ydGVkUHJvcGVydHk7XG59KS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIHAuc3VwcG9ydGVkUHJvcGVydHk7XG59KTtcbnZhciBub1ByZWZpbGwgPSBwbHVnaW5zLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcC5ub1ByZWZpbGw7XG59KS5yZWR1Y2UoZnVuY3Rpb24gKGEsIHApIHtcbiAgYS5wdXNoLmFwcGx5KGEsIF90b0NvbnN1bWFibGVBcnJheShwLm5vUHJlZmlsbCkpO1xuICByZXR1cm4gYTtcbn0sIFtdKTtcblxudmFyIGVsO1xudmFyIGNhY2hlID0ge307XG5cbmlmIChpc0luQnJvd3Nlcikge1xuICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTsgLy8gV2UgdGVzdCBldmVyeSBwcm9wZXJ0eSBvbiB2ZW5kb3IgcHJlZml4IHJlcXVpcmVtZW50LlxuICAvLyBPbmNlIHRlc3RlZCwgcmVzdWx0IGlzIGNhY2hlZC4gSXQgZ2l2ZXMgdXMgdXAgdG8gNzAlIHBlcmYgYm9vc3QuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VsZW1lbnQtc3R5bGUtb2JqZWN0LWFjY2Vzcy12cy1wbGFpbi1vYmplY3RcbiAgLy9cbiAgLy8gUHJlZmlsbCBjYWNoZSB3aXRoIGtub3duIGNzcyBwcm9wZXJ0aWVzIHRvIHJlZHVjZSBhbW91bnQgb2ZcbiAgLy8gcHJvcGVydGllcyB3ZSBuZWVkIHRvIGZlYXR1cmUgdGVzdCBhdCBydW50aW1lLlxuICAvLyBodHRwOi8vZGF2aWR3YWxzaC5uYW1lL3ZlbmRvci1wcmVmaXhcblxuICB2YXIgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICcnKTtcblxuICBmb3IgKHZhciBrZXkkMSBpbiBjb21wdXRlZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBpZiAoIWlzTmFOKGtleSQxKSkgY2FjaGVbY29tcHV0ZWRba2V5JDFdXSA9IGNvbXB1dGVkW2tleSQxXTtcbiAgfSAvLyBQcm9wZXJ0aWVzIHRoYXQgY2Fubm90IGJlIGNvcnJlY3RseSBkZXRlY3RlZCB1c2luZyB0aGVcbiAgLy8gY2FjaGUgcHJlZmlsbCBtZXRob2QuXG5cblxuICBub1ByZWZpbGwuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBkZWxldGUgY2FjaGVbeF07XG4gIH0pO1xufVxuLyoqXG4gKiBUZXN0IGlmIGEgcHJvcGVydHkgaXMgc3VwcG9ydGVkLCByZXR1cm5zIHN1cHBvcnRlZCBwcm9wZXJ0eSB3aXRoIHZlbmRvclxuICogcHJlZml4IGlmIHJlcXVpcmVkLiBSZXR1cm5zIGBmYWxzZWAgaWYgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBkYXNoIHNlcGFyYXRlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7U3RyaW5nfEJvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgLy8gRm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgaWYgKCFlbCkgcmV0dXJuIHByb3A7IC8vIFJlbW92ZSBjYWNoZSBmb3IgYmVuY2htYXJrIHRlc3RzIG9yIHJldHVybiBwcm9wZXJ0eSBmcm9tIHRoZSBjYWNoZS5cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdiZW5jaG1hcmsnICYmIGNhY2hlW3Byb3BdICE9IG51bGwpIHtcbiAgICByZXR1cm4gY2FjaGVbcHJvcF07XG4gIH0gLy8gQ2hlY2sgaWYgJ3RyYW5zaXRpb24nIG9yICd0cmFuc2Zvcm0nIG5hdGl2ZWx5IHN1cHBvcnRlZCBpbiBicm93c2VyLlxuXG5cbiAgaWYgKHByb3AgPT09ICd0cmFuc2l0aW9uJyB8fCBwcm9wID09PSAndHJhbnNmb3JtJykge1xuICAgIG9wdGlvbnNbcHJvcF0gPSBwcm9wIGluIGVsLnN0eWxlO1xuICB9IC8vIEZpbmQgYSBwbHVnaW4gZm9yIGN1cnJlbnQgcHJlZml4IHByb3BlcnR5LlxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0eURldGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlW3Byb3BdID0gcHJvcGVydHlEZXRlY3RvcnNbaV0ocHJvcCwgZWwuc3R5bGUsIG9wdGlvbnMpOyAvLyBCcmVhayBsb29wLCBpZiB2YWx1ZSBmb3VuZC5cblxuICAgIGlmIChjYWNoZVtwcm9wXSkgYnJlYWs7XG4gIH0gLy8gUmVzZXQgc3R5bGVzIGZvciBjdXJyZW50IHByb3BlcnR5LlxuICAvLyBGaXJlZm94IGNhbiBldmVuIHRocm93IGFuIGVycm9yIGZvciBpbnZhbGlkIHByb3BlcnRpZXMsIGUuZy4sIFwiMFwiLlxuXG5cbiAgdHJ5IHtcbiAgICBlbC5zdHlsZVtwcm9wXSA9ICcnO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY2FjaGVbcHJvcF07XG59XG5cbnZhciBjYWNoZSQxID0ge307XG52YXIgdHJhbnNpdGlvblByb3BlcnRpZXMgPSB7XG4gIHRyYW5zaXRpb246IDEsXG4gICd0cmFuc2l0aW9uLXByb3BlcnR5JzogMSxcbiAgJy13ZWJraXQtdHJhbnNpdGlvbic6IDEsXG4gICctd2Via2l0LXRyYW5zaXRpb24tcHJvcGVydHknOiAxXG59O1xudmFyIHRyYW5zUHJvcHNSZWdFeHAgPSAvKF5cXHMqW1xcdy1dKyl8LCAoXFxzKltcXHctXSspKD8hW14oKV0qXFwpKS9nO1xudmFyIGVsJDE7XG4vKipcbiAqIFJldHVybnMgcHJlZml4ZWQgdmFsdWUgdHJhbnNpdGlvbi90cmFuc2Zvcm0gaWYgbmVlZGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtYXRjaFxuICogQHBhcmFtIHtTdHJpbmd9IHAxXG4gKiBAcGFyYW0ge1N0cmluZ30gcDJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHByZWZpeFRyYW5zaXRpb25DYWxsYmFjayhtYXRjaCwgcDEsIHAyKSB7XG4gIGlmIChwMSA9PT0gJ3ZhcicpIHJldHVybiAndmFyJztcbiAgaWYgKHAxID09PSAnYWxsJykgcmV0dXJuICdhbGwnO1xuICBpZiAocDIgPT09ICdhbGwnKSByZXR1cm4gJywgYWxsJztcbiAgdmFyIHByZWZpeGVkVmFsdWUgPSBwMSA/IHN1cHBvcnRlZFByb3BlcnR5KHAxKSA6IFwiLCBcIiArIHN1cHBvcnRlZFByb3BlcnR5KHAyKTtcbiAgaWYgKCFwcmVmaXhlZFZhbHVlKSByZXR1cm4gcDEgfHwgcDI7XG4gIHJldHVybiBwcmVmaXhlZFZhbHVlO1xufVxuXG5pZiAoaXNJbkJyb3dzZXIpIGVsJDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4vKipcbiAqIFJldHVybnMgcHJlZml4ZWQgdmFsdWUgaWYgbmVlZGVkLiBSZXR1cm5zIGBmYWxzZWAgaWYgdmFsdWUgaXMgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfEJvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRlZFZhbHVlKHByb3BlcnR5LCB2YWx1ZSkge1xuICAvLyBGb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICB2YXIgcHJlZml4ZWRWYWx1ZSA9IHZhbHVlO1xuICBpZiAoIWVsJDEgfHwgcHJvcGVydHkgPT09ICdjb250ZW50JykgcmV0dXJuIHZhbHVlOyAvLyBJdCBpcyBhIHN0cmluZyBvciBhIG51bWJlciBhcyBhIHN0cmluZyBsaWtlICcxJy5cbiAgLy8gV2Ugd2FudCBvbmx5IHByZWZpeGFibGUgdmFsdWVzIGhlcmUuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcblxuICBpZiAodHlwZW9mIHByZWZpeGVkVmFsdWUgIT09ICdzdHJpbmcnIHx8ICFpc05hTihwYXJzZUludChwcmVmaXhlZFZhbHVlLCAxMCkpKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkVmFsdWU7XG4gIH0gLy8gQ3JlYXRlIGNhY2hlIGtleSBmb3IgY3VycmVudCB2YWx1ZS5cblxuXG4gIHZhciBjYWNoZUtleSA9IHByb3BlcnR5ICsgcHJlZml4ZWRWYWx1ZTsgLy8gUmVtb3ZlIGNhY2hlIGZvciBiZW5jaG1hcmsgdGVzdHMgb3IgcmV0dXJuIHZhbHVlIGZyb20gY2FjaGUuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnYmVuY2htYXJrJyAmJiBjYWNoZSQxW2NhY2hlS2V5XSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGNhY2hlJDFbY2FjaGVLZXldO1xuICB9IC8vIElFIGNhbiBldmVuIHRocm93IGFuIGVycm9yIGluIHNvbWUgY2FzZXMsIGZvciBlLmcuIHN0eWxlLmNvbnRlbnQgPSAnYmFyJy5cblxuXG4gIHRyeSB7XG4gICAgLy8gVGVzdCB2YWx1ZSBhcyBpdCBpcy5cbiAgICBlbCQxLnN0eWxlW3Byb3BlcnR5XSA9IHByZWZpeGVkVmFsdWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFJldHVybiBmYWxzZSBpZiB2YWx1ZSBub3Qgc3VwcG9ydGVkLlxuICAgIGNhY2hlJDFbY2FjaGVLZXldID0gZmFsc2U7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElmICd0cmFuc2l0aW9uJyBvciAndHJhbnNpdGlvbi1wcm9wZXJ0eScgcHJvcGVydHkuXG5cblxuICBpZiAodHJhbnNpdGlvblByb3BlcnRpZXNbcHJvcGVydHldKSB7XG4gICAgcHJlZml4ZWRWYWx1ZSA9IHByZWZpeGVkVmFsdWUucmVwbGFjZSh0cmFuc1Byb3BzUmVnRXhwLCBwcmVmaXhUcmFuc2l0aW9uQ2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKGVsJDEuc3R5bGVbcHJvcGVydHldID09PSAnJykge1xuICAgIC8vIFZhbHVlIHdpdGggYSB2ZW5kb3IgcHJlZml4LlxuICAgIHByZWZpeGVkVmFsdWUgPSBwcmVmaXguY3NzICsgcHJlZml4ZWRWYWx1ZTsgLy8gSGFyZGNvZGUgdGVzdCB0byBjb252ZXJ0IFwiZmxleFwiIHRvIFwiLW1zLWZsZXhib3hcIiBmb3IgSUUxMC5cblxuICAgIGlmIChwcmVmaXhlZFZhbHVlID09PSAnLW1zLWZsZXgnKSBlbCQxLnN0eWxlW3Byb3BlcnR5XSA9ICctbXMtZmxleGJveCc7IC8vIFRlc3QgcHJlZml4ZWQgdmFsdWUuXG5cbiAgICBlbCQxLnN0eWxlW3Byb3BlcnR5XSA9IHByZWZpeGVkVmFsdWU7IC8vIFJldHVybiBmYWxzZSBpZiB2YWx1ZSBub3Qgc3VwcG9ydGVkLlxuXG4gICAgaWYgKGVsJDEuc3R5bGVbcHJvcGVydHldID09PSAnJykge1xuICAgICAgY2FjaGUkMVtjYWNoZUtleV0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gUmVzZXQgc3R5bGVzIGZvciBjdXJyZW50IHByb3BlcnR5LlxuXG5cbiAgZWwkMS5zdHlsZVtwcm9wZXJ0eV0gPSAnJzsgLy8gV3JpdGUgY3VycmVudCB2YWx1ZSB0byBjYWNoZS5cblxuICBjYWNoZSQxW2NhY2hlS2V5XSA9IHByZWZpeGVkVmFsdWU7XG4gIHJldHVybiBjYWNoZSQxW2NhY2hlS2V5XTtcbn1cblxuZXhwb3J0IHsgcHJlZml4LCBzdXBwb3J0ZWRLZXlmcmFtZXMsIHN1cHBvcnRlZFByb3BlcnR5LCBzdXBwb3J0ZWRWYWx1ZSB9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciwgcHJlZmVyLXRlbXBsYXRlICovXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC9bQS1aXS9nXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vXG52YXIgY2FjaGUgPSB7fVxuXG5mdW5jdGlvbiB0b0h5cGhlbkxvd2VyKG1hdGNoKSB7XG4gIHJldHVybiAnLScgKyBtYXRjaC50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShuYW1lKSB7XG4gIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybiBjYWNoZVtuYW1lXVxuICB9XG5cbiAgdmFyIGhOYW1lID0gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sIHRvSHlwaGVuTG93ZXIpXG4gIHJldHVybiAoY2FjaGVbbmFtZV0gPSBtc1BhdHRlcm4udGVzdChoTmFtZSkgPyAnLScgKyBoTmFtZSA6IGhOYW1lKVxufVxuXG5leHBvcnQgZGVmYXVsdCBoeXBoZW5hdGVTdHlsZU5hbWVcbiIsInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0IHZhciBpc0Jyb3dzZXIgPSAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbmRvdykpID09PSBcIm9iamVjdFwiICYmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihkb2N1bWVudCkpID09PSAnb2JqZWN0JyAmJiBkb2N1bWVudC5ub2RlVHlwZSA9PT0gOTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCcm93c2VyO1xuIiwiaW1wb3J0IGh5cGhlbmF0ZSBmcm9tICdoeXBoZW5hdGUtc3R5bGUtbmFtZSc7XG5cbi8qKlxuICogQ29udmVydCBjYW1lbCBjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBkYXNoIHNlcGFyYXRlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0Q2FzZShzdHlsZSkge1xuICB2YXIgY29udmVydGVkID0ge307XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgIHZhciBrZXkgPSBwcm9wLmluZGV4T2YoJy0tJykgPT09IDAgPyBwcm9wIDogaHlwaGVuYXRlKHByb3ApO1xuICAgIGNvbnZlcnRlZFtrZXldID0gc3R5bGVbcHJvcF07XG4gIH1cblxuICBpZiAoc3R5bGUuZmFsbGJhY2tzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUuZmFsbGJhY2tzKSkgY29udmVydGVkLmZhbGxiYWNrcyA9IHN0eWxlLmZhbGxiYWNrcy5tYXAoY29udmVydENhc2UpO2Vsc2UgY29udmVydGVkLmZhbGxiYWNrcyA9IGNvbnZlcnRDYXNlKHN0eWxlLmZhbGxiYWNrcyk7XG4gIH1cblxuICByZXR1cm4gY29udmVydGVkO1xufVxuLyoqXG4gKiBBbGxvdyBjYW1lbCBjYXNlZCBwcm9wZXJ0eSBuYW1lcyBieSBjb252ZXJ0aW5nIHRoZW0gYmFjayB0byBkYXNoZXJpemVkLlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICovXG5cblxuZnVuY3Rpb24gY2FtZWxDYXNlKCkge1xuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkge1xuICAgICAgLy8gSGFuZGxlIHJ1bGVzIGxpa2UgQGZvbnQtZmFjZSwgd2hpY2ggY2FuIGhhdmUgbXVsdGlwbGUgc3R5bGVzIGluIGFuIGFycmF5XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0eWxlW2luZGV4XSA9IGNvbnZlcnRDYXNlKHN0eWxlW2luZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udmVydENhc2Uoc3R5bGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCwgcnVsZSkge1xuICAgIGlmIChwcm9wLmluZGV4T2YoJy0tJykgPT09IDApIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgaHlwaGVuYXRlZFByb3AgPSBoeXBoZW5hdGUocHJvcCk7IC8vIFRoZXJlIHdhcyBubyBjYW1lbCBjYXNlIGluIHBsYWNlXG5cbiAgICBpZiAocHJvcCA9PT0gaHlwaGVuYXRlZFByb3ApIHJldHVybiB2YWx1ZTtcbiAgICBydWxlLnByb3AoaHlwaGVuYXRlZFByb3AsIHZhbHVlKTsgLy8gQ29yZSB3aWxsIGlnbm9yZSB0aGF0IHByb3BlcnR5IHZhbHVlIHdlIHNldCB0aGUgcHJvcGVyIG9uZSBhYm92ZS5cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYW1lbENhc2U7XG4iLCJpbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuXG4vKipcbiAqIFNldCBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luYWwgcnVsZVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBjbGFzcyBzdHJpbmdcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZsYWcsIGluZGljYXRpbmcgZnVuY3Rpb24gd2FzIHN1Y2Nlc3NmdWxsIG9yIG5vdFxuICovXG5mdW5jdGlvbiByZWdpc3RlckNsYXNzKHJ1bGUsIGNsYXNzTmFtZSkge1xuICAvLyBTa2lwIGZhbHN5IHZhbHVlc1xuICBpZiAoIWNsYXNzTmFtZSkgcmV0dXJuIHRydWU7IC8vIFN1cHBvcnQgYXJyYXkgb2YgY2xhc3MgbmFtZXMgYHtjb21wb3NlczogWydmb28nLCAnYmFyJ119YFxuXG4gIGlmIChBcnJheS5pc0FycmF5KGNsYXNzTmFtZSkpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY2xhc3NOYW1lLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGlzU2V0dGVkID0gcmVnaXN0ZXJDbGFzcyhydWxlLCBjbGFzc05hbWVbaW5kZXhdKTtcbiAgICAgIGlmICghaXNTZXR0ZWQpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBTdXBwb3J0IHNwYWNlIHNlcGFyYXRlZCBjbGFzcyBuYW1lcyBge2NvbXBvc2VzOiAnZm9vIGJhcid9YFxuXG5cbiAgaWYgKGNsYXNzTmFtZS5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgIHJldHVybiByZWdpc3RlckNsYXNzKHJ1bGUsIGNsYXNzTmFtZS5zcGxpdCgnICcpKTtcbiAgfVxuXG4gIHZhciBfcmVmID0gcnVsZS5vcHRpb25zLFxuICAgICAgcGFyZW50ID0gX3JlZi5wYXJlbnQ7IC8vIEl0IGlzIGEgcmVmIHRvIGEgbG9jYWwgcnVsZS5cblxuICBpZiAoY2xhc3NOYW1lWzBdID09PSAnJCcpIHtcbiAgICB2YXIgcmVmUnVsZSA9IHBhcmVudC5nZXRSdWxlKGNsYXNzTmFtZS5zdWJzdHIoMSkpO1xuXG4gICAgaWYgKCFyZWZSdWxlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFJlZmVyZW5jZWQgcnVsZSBpcyBub3QgZGVmaW5lZC4gXFxuXCIgKyBydWxlLnRvU3RyaW5nKCkpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChyZWZSdWxlID09PSBydWxlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIEN5Y2xpYyBjb21wb3NpdGlvbiBkZXRlY3RlZC4gXFxuXCIgKyBydWxlLnRvU3RyaW5nKCkpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHBhcmVudC5jbGFzc2VzW3J1bGUua2V5XSArPSBcIiBcIiArIHBhcmVudC5jbGFzc2VzW3JlZlJ1bGUua2V5XTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHBhcmVudC5jbGFzc2VzW3J1bGUua2V5XSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIENvbnZlcnQgY29tcG9zZSBwcm9wZXJ0eSB0byBhZGRpdGlvbmFsIGNsYXNzLCByZW1vdmUgcHJvcGVydHkgZnJvbSBvcmlnaW5hbCBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtSdWxlfSBydWxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24ganNzQ29tcG9zZSgpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICBpZiAoISgnY29tcG9zZXMnIGluIHN0eWxlKSkgcmV0dXJuIHN0eWxlO1xuICAgIHJlZ2lzdGVyQ2xhc3MocnVsZSwgc3R5bGUuY29tcG9zZXMpOyAvLyBSZW1vdmUgY29tcG9zZXMgcHJvcGVydHkgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wLlxuXG4gICAgZGVsZXRlIHN0eWxlLmNvbXBvc2VzO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGpzc0NvbXBvc2U7XG4iLCJpbXBvcnQgeyBoYXNDU1NUT01TdXBwb3J0IH0gZnJvbSAnanNzJztcblxudmFyIHB4ID0gaGFzQ1NTVE9NU3VwcG9ydCAmJiBDU1MgPyBDU1MucHggOiAncHgnO1xudmFyIG1zID0gaGFzQ1NTVE9NU3VwcG9ydCAmJiBDU1MgPyBDU1MubXMgOiAnbXMnO1xudmFyIHBlcmNlbnQgPSBoYXNDU1NUT01TdXBwb3J0ICYmIENTUyA/IENTUy5wZXJjZW50IDogJyUnO1xuLyoqXG4gKiBHZW5lcmF0ZWQganNzLXBsdWdpbi1kZWZhdWx0LXVuaXQgQ1NTIHByb3BlcnR5IHVuaXRzXG4gKlxuICogQHR5cGUgb2JqZWN0XG4gKi9cblxudmFyIGRlZmF1bHRVbml0cyA9IHtcbiAgLy8gQW5pbWF0aW9uIHByb3BlcnRpZXNcbiAgJ2FuaW1hdGlvbi1kZWxheSc6IG1zLFxuICAnYW5pbWF0aW9uLWR1cmF0aW9uJzogbXMsXG4gIC8vIEJhY2tncm91bmQgcHJvcGVydGllc1xuICAnYmFja2dyb3VuZC1wb3NpdGlvbic6IHB4LFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbi14JzogcHgsXG4gICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknOiBweCxcbiAgJ2JhY2tncm91bmQtc2l6ZSc6IHB4LFxuICAvLyBCb3JkZXIgUHJvcGVydGllc1xuICBib3JkZXI6IHB4LFxuICAnYm9yZGVyLWJvdHRvbSc6IHB4LFxuICAnYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1ib3R0b20td2lkdGgnOiBweCxcbiAgJ2JvcmRlci1sZWZ0JzogcHgsXG4gICdib3JkZXItbGVmdC13aWR0aCc6IHB4LFxuICAnYm9yZGVyLXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLXJpZ2h0JzogcHgsXG4gICdib3JkZXItcmlnaHQtd2lkdGgnOiBweCxcbiAgJ2JvcmRlci10b3AnOiBweCxcbiAgJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci10b3AtcmlnaHQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItdG9wLXdpZHRoJzogcHgsXG4gICdib3JkZXItd2lkdGgnOiBweCxcbiAgJ2JvcmRlci1ibG9jayc6IHB4LFxuICAnYm9yZGVyLWJsb2NrLWVuZCc6IHB4LFxuICAnYm9yZGVyLWJsb2NrLWVuZC13aWR0aCc6IHB4LFxuICAnYm9yZGVyLWJsb2NrLXN0YXJ0JzogcHgsXG4gICdib3JkZXItYmxvY2stc3RhcnQtd2lkdGgnOiBweCxcbiAgJ2JvcmRlci1ibG9jay13aWR0aCc6IHB4LFxuICAnYm9yZGVyLWlubGluZSc6IHB4LFxuICAnYm9yZGVyLWlubGluZS1lbmQnOiBweCxcbiAgJ2JvcmRlci1pbmxpbmUtZW5kLXdpZHRoJzogcHgsXG4gICdib3JkZXItaW5saW5lLXN0YXJ0JzogcHgsXG4gICdib3JkZXItaW5saW5lLXN0YXJ0LXdpZHRoJzogcHgsXG4gICdib3JkZXItaW5saW5lLXdpZHRoJzogcHgsXG4gICdib3JkZXItc3RhcnQtc3RhcnQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItc3RhcnQtZW5kLXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLWVuZC1zdGFydC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1lbmQtZW5kLXJhZGl1cyc6IHB4LFxuICAvLyBNYXJnaW4gcHJvcGVydGllc1xuICBtYXJnaW46IHB4LFxuICAnbWFyZ2luLWJvdHRvbSc6IHB4LFxuICAnbWFyZ2luLWxlZnQnOiBweCxcbiAgJ21hcmdpbi1yaWdodCc6IHB4LFxuICAnbWFyZ2luLXRvcCc6IHB4LFxuICAnbWFyZ2luLWJsb2NrJzogcHgsXG4gICdtYXJnaW4tYmxvY2stZW5kJzogcHgsXG4gICdtYXJnaW4tYmxvY2stc3RhcnQnOiBweCxcbiAgJ21hcmdpbi1pbmxpbmUnOiBweCxcbiAgJ21hcmdpbi1pbmxpbmUtZW5kJzogcHgsXG4gICdtYXJnaW4taW5saW5lLXN0YXJ0JzogcHgsXG4gIC8vIFBhZGRpbmcgcHJvcGVydGllc1xuICBwYWRkaW5nOiBweCxcbiAgJ3BhZGRpbmctYm90dG9tJzogcHgsXG4gICdwYWRkaW5nLWxlZnQnOiBweCxcbiAgJ3BhZGRpbmctcmlnaHQnOiBweCxcbiAgJ3BhZGRpbmctdG9wJzogcHgsXG4gICdwYWRkaW5nLWJsb2NrJzogcHgsXG4gICdwYWRkaW5nLWJsb2NrLWVuZCc6IHB4LFxuICAncGFkZGluZy1ibG9jay1zdGFydCc6IHB4LFxuICAncGFkZGluZy1pbmxpbmUnOiBweCxcbiAgJ3BhZGRpbmctaW5saW5lLWVuZCc6IHB4LFxuICAncGFkZGluZy1pbmxpbmUtc3RhcnQnOiBweCxcbiAgLy8gTWFzayBwcm9wZXJ0aWVzXG4gICdtYXNrLXBvc2l0aW9uLXgnOiBweCxcbiAgJ21hc2stcG9zaXRpb24teSc6IHB4LFxuICAnbWFzay1zaXplJzogcHgsXG4gIC8vIFdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICBoZWlnaHQ6IHB4LFxuICB3aWR0aDogcHgsXG4gICdtaW4taGVpZ2h0JzogcHgsXG4gICdtYXgtaGVpZ2h0JzogcHgsXG4gICdtaW4td2lkdGgnOiBweCxcbiAgJ21heC13aWR0aCc6IHB4LFxuICAvLyBQb3NpdGlvbiBwcm9wZXJ0aWVzXG4gIGJvdHRvbTogcHgsXG4gIGxlZnQ6IHB4LFxuICB0b3A6IHB4LFxuICByaWdodDogcHgsXG4gIGluc2V0OiBweCxcbiAgJ2luc2V0LWJsb2NrJzogcHgsXG4gICdpbnNldC1ibG9jay1lbmQnOiBweCxcbiAgJ2luc2V0LWJsb2NrLXN0YXJ0JzogcHgsXG4gICdpbnNldC1pbmxpbmUnOiBweCxcbiAgJ2luc2V0LWlubGluZS1lbmQnOiBweCxcbiAgJ2luc2V0LWlubGluZS1zdGFydCc6IHB4LFxuICAvLyBTaGFkb3cgcHJvcGVydGllc1xuICAnYm94LXNoYWRvdyc6IHB4LFxuICAndGV4dC1zaGFkb3cnOiBweCxcbiAgLy8gQ29sdW1uIHByb3BlcnRpZXNcbiAgJ2NvbHVtbi1nYXAnOiBweCxcbiAgJ2NvbHVtbi1ydWxlJzogcHgsXG4gICdjb2x1bW4tcnVsZS13aWR0aCc6IHB4LFxuICAnY29sdW1uLXdpZHRoJzogcHgsXG4gIC8vIEZvbnQgYW5kIHRleHQgcHJvcGVydGllc1xuICAnZm9udC1zaXplJzogcHgsXG4gICdmb250LXNpemUtZGVsdGEnOiBweCxcbiAgJ2xldHRlci1zcGFjaW5nJzogcHgsXG4gICd0ZXh0LWRlY29yYXRpb24tdGhpY2tuZXNzJzogcHgsXG4gICd0ZXh0LWluZGVudCc6IHB4LFxuICAndGV4dC1zdHJva2UnOiBweCxcbiAgJ3RleHQtc3Ryb2tlLXdpZHRoJzogcHgsXG4gICd3b3JkLXNwYWNpbmcnOiBweCxcbiAgLy8gTW90aW9uIHByb3BlcnRpZXNcbiAgbW90aW9uOiBweCxcbiAgJ21vdGlvbi1vZmZzZXQnOiBweCxcbiAgLy8gT3V0bGluZSBwcm9wZXJ0aWVzXG4gIG91dGxpbmU6IHB4LFxuICAnb3V0bGluZS1vZmZzZXQnOiBweCxcbiAgJ291dGxpbmUtd2lkdGgnOiBweCxcbiAgLy8gUGVyc3BlY3RpdmUgcHJvcGVydGllc1xuICBwZXJzcGVjdGl2ZTogcHgsXG4gICdwZXJzcGVjdGl2ZS1vcmlnaW4teCc6IHBlcmNlbnQsXG4gICdwZXJzcGVjdGl2ZS1vcmlnaW4teSc6IHBlcmNlbnQsXG4gIC8vIFRyYW5zZm9ybSBwcm9wZXJ0aWVzXG4gICd0cmFuc2Zvcm0tb3JpZ2luJzogcGVyY2VudCxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4teCc6IHBlcmNlbnQsXG4gICd0cmFuc2Zvcm0tb3JpZ2luLXknOiBwZXJjZW50LFxuICAndHJhbnNmb3JtLW9yaWdpbi16JzogcGVyY2VudCxcbiAgLy8gVHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gICd0cmFuc2l0aW9uLWRlbGF5JzogbXMsXG4gICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogbXMsXG4gIC8vIEFsaWdubWVudCBwcm9wZXJ0aWVzXG4gICd2ZXJ0aWNhbC1hbGlnbic6IHB4LFxuICAnZmxleC1iYXNpcyc6IHB4LFxuICAvLyBTb21lIHJhbmRvbSBwcm9wZXJ0aWVzXG4gICdzaGFwZS1tYXJnaW4nOiBweCxcbiAgc2l6ZTogcHgsXG4gIGdhcDogcHgsXG4gIC8vIEdyaWQgcHJvcGVydGllc1xuICBncmlkOiBweCxcbiAgJ2dyaWQtZ2FwJzogcHgsXG4gICdyb3ctZ2FwJzogcHgsXG4gICdncmlkLXJvdy1nYXAnOiBweCxcbiAgJ2dyaWQtY29sdW1uLWdhcCc6IHB4LFxuICAnZ3JpZC10ZW1wbGF0ZS1yb3dzJzogcHgsXG4gICdncmlkLXRlbXBsYXRlLWNvbHVtbnMnOiBweCxcbiAgJ2dyaWQtYXV0by1yb3dzJzogcHgsXG4gICdncmlkLWF1dG8tY29sdW1ucyc6IHB4LFxuICAvLyBOb3QgZXhpc3RpbmcgcHJvcGVydGllcy5cbiAgLy8gVXNlZCB0byBhdm9pZCBpc3N1ZXMgd2l0aCBqc3MtcGx1Z2luLWV4cGFuZCBpbnRlZ3JhdGlvbi5cbiAgJ2JveC1zaGFkb3cteCc6IHB4LFxuICAnYm94LXNoYWRvdy15JzogcHgsXG4gICdib3gtc2hhZG93LWJsdXInOiBweCxcbiAgJ2JveC1zaGFkb3ctc3ByZWFkJzogcHgsXG4gICdmb250LWxpbmUtaGVpZ2h0JzogcHgsXG4gICd0ZXh0LXNoYWRvdy14JzogcHgsXG4gICd0ZXh0LXNoYWRvdy15JzogcHgsXG4gICd0ZXh0LXNoYWRvdy1ibHVyJzogcHhcbn07XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBvYmplY3QgYW5kIGFkZHMgYSBjYW1lbCBjYXNlZCBwcm9wZXJ0eSB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBhZGRDYW1lbENhc2VkVmVyc2lvbihvYmopIHtcbiAgdmFyIHJlZ0V4cCA9IC8oLVthLXpdKS9nO1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShzdHIpIHtcbiAgICByZXR1cm4gc3RyWzFdLnRvVXBwZXJDYXNlKCk7XG4gIH07XG5cbiAgdmFyIG5ld09iaiA9IHt9O1xuXG4gIGZvciAodmFyIF9rZXkgaW4gb2JqKSB7XG4gICAgbmV3T2JqW19rZXldID0gb2JqW19rZXldO1xuICAgIG5ld09ialtfa2V5LnJlcGxhY2UocmVnRXhwLCByZXBsYWNlKV0gPSBvYmpbX2tleV07XG4gIH1cblxuICByZXR1cm4gbmV3T2JqO1xufVxuXG52YXIgdW5pdHMgPSBhZGRDYW1lbENhc2VkVmVyc2lvbihkZWZhdWx0VW5pdHMpO1xuLyoqXG4gKiBSZWN1cnNpdmUgZGVlcCBzdHlsZSBwYXNzaW5nIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaXRlcmF0ZShwcm9wLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlW2ldID0gaXRlcmF0ZShwcm9wLCB2YWx1ZVtpXSwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAocHJvcCA9PT0gJ2ZhbGxiYWNrcycpIHtcbiAgICAgIGZvciAodmFyIGlubmVyUHJvcCBpbiB2YWx1ZSkge1xuICAgICAgICB2YWx1ZVtpbm5lclByb3BdID0gaXRlcmF0ZShpbm5lclByb3AsIHZhbHVlW2lubmVyUHJvcF0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBfaW5uZXJQcm9wIGluIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlW19pbm5lclByb3BdID0gaXRlcmF0ZShwcm9wICsgXCItXCIgKyBfaW5uZXJQcm9wLCB2YWx1ZVtfaW5uZXJQcm9wXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG5cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgdW5pdCA9IG9wdGlvbnNbcHJvcF0gfHwgdW5pdHNbcHJvcF07IC8vIEFkZCB0aGUgdW5pdCBpZiBhdmFpbGFibGUsIGV4Y2VwdCBmb3IgdGhlIHNwZWNpYWwgY2FzZSBvZiAwcHguXG5cbiAgICBpZiAodW5pdCAmJiAhKHZhbHVlID09PSAwICYmIHVuaXQgPT09IHB4KSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB1bml0ID09PSAnZnVuY3Rpb24nID8gdW5pdCh2YWx1ZSkudG9TdHJpbmcoKSA6IFwiXCIgKyB2YWx1ZSArIHVuaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEFkZCB1bml0IHRvIG51bWVyaWMgdmFsdWVzLlxuICovXG5cblxuZnVuY3Rpb24gZGVmYXVsdFVuaXQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIGNhbWVsQ2FzZWRPcHRpb25zID0gYWRkQ2FtZWxDYXNlZFZlcnNpb24ob3B0aW9ucyk7XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICBzdHlsZVtwcm9wXSA9IGl0ZXJhdGUocHJvcCwgc3R5bGVbcHJvcF0sIGNhbWVsQ2FzZWRPcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wKSB7XG4gICAgcmV0dXJuIGl0ZXJhdGUocHJvcCwgdmFsdWUsIGNhbWVsQ2FzZWRPcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlLFxuICAgIG9uQ2hhbmdlVmFsdWU6IG9uQ2hhbmdlVmFsdWVcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdFVuaXQ7XG4iLCIvKipcbiAqIEEgc2NoZW1lIGZvciBjb252ZXJ0aW5nIHByb3BlcnRpZXMgZnJvbSBhcnJheSB0byByZWd1bGFyIHN0eWxlLlxuICogQWxsIHByb3BlcnRpZXMgbGlzdGVkIGJlbG93IHdpbGwgYmUgdHJhbnNmb3JtZWQgdG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IHNwYWNlLlxuICovXG52YXIgcHJvcEFycmF5ID0ge1xuICAnYmFja2dyb3VuZC1zaXplJzogdHJ1ZSxcbiAgJ2JhY2tncm91bmQtcG9zaXRpb24nOiB0cnVlLFxuICBib3JkZXI6IHRydWUsXG4gICdib3JkZXItYm90dG9tJzogdHJ1ZSxcbiAgJ2JvcmRlci1sZWZ0JzogdHJ1ZSxcbiAgJ2JvcmRlci10b3AnOiB0cnVlLFxuICAnYm9yZGVyLXJpZ2h0JzogdHJ1ZSxcbiAgJ2JvcmRlci1yYWRpdXMnOiB0cnVlLFxuICAnYm9yZGVyLWltYWdlJzogdHJ1ZSxcbiAgJ2JvcmRlci13aWR0aCc6IHRydWUsXG4gICdib3JkZXItc3R5bGUnOiB0cnVlLFxuICAnYm9yZGVyLWNvbG9yJzogdHJ1ZSxcbiAgJ2JveC1zaGFkb3cnOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBtYXJnaW46IHRydWUsXG4gIHBhZGRpbmc6IHRydWUsXG4gIG91dGxpbmU6IHRydWUsXG4gICd0cmFuc2Zvcm0tb3JpZ2luJzogdHJ1ZSxcbiAgdHJhbnNmb3JtOiB0cnVlLFxuICB0cmFuc2l0aW9uOiB0cnVlXG4gIC8qKlxuICAgKiBBIHNjaGVtZSBmb3IgY29udmVydGluZyBhcnJheXMgdG8gcmVndWxhciBzdHlsZXMgaW5zaWRlIG9mIG9iamVjdHMuXG4gICAqIEZvciBlLmcuOiBcIntwb3NpdGlvbjogWzAsIDBdfVwiID0+IFwiYmFja2dyb3VuZC1wb3NpdGlvbjogMCAwO1wiLlxuICAgKi9cblxufTtcbnZhciBwcm9wQXJyYXlJbk9iaiA9IHtcbiAgcG9zaXRpb246IHRydWUsXG4gIC8vIGJhY2tncm91bmQtcG9zaXRpb25cbiAgc2l6ZTogdHJ1ZSAvLyBiYWNrZ3JvdW5kLXNpemVcblxuICAvKipcbiAgICogQSBzY2hlbWUgZm9yIHBhcnNpbmcgYW5kIGJ1aWxkaW5nIGNvcnJlY3Qgc3R5bGVzIGZyb20gcGFzc2VkIG9iamVjdHMuXG4gICAqL1xuXG59O1xudmFyIHByb3BPYmogPSB7XG4gIHBhZGRpbmc6IHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfSxcbiAgbWFyZ2luOiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH0sXG4gIGJhY2tncm91bmQ6IHtcbiAgICBhdHRhY2htZW50OiBudWxsLFxuICAgIGNvbG9yOiBudWxsLFxuICAgIGltYWdlOiBudWxsLFxuICAgIHBvc2l0aW9uOiBudWxsLFxuICAgIHJlcGVhdDogbnVsbFxuICB9LFxuICBib3JkZXI6IHtcbiAgICB3aWR0aDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBjb2xvcjogbnVsbFxuICB9LFxuICAnYm9yZGVyLXRvcCc6IHtcbiAgICB3aWR0aDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBjb2xvcjogbnVsbFxuICB9LFxuICAnYm9yZGVyLXJpZ2h0Jzoge1xuICAgIHdpZHRoOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIGNvbG9yOiBudWxsXG4gIH0sXG4gICdib3JkZXItYm90dG9tJzoge1xuICAgIHdpZHRoOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIGNvbG9yOiBudWxsXG4gIH0sXG4gICdib3JkZXItbGVmdCc6IHtcbiAgICB3aWR0aDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBjb2xvcjogbnVsbFxuICB9LFxuICBvdXRsaW5lOiB7XG4gICAgd2lkdGg6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgY29sb3I6IG51bGxcbiAgfSxcbiAgJ2xpc3Qtc3R5bGUnOiB7XG4gICAgdHlwZTogbnVsbCxcbiAgICBwb3NpdGlvbjogbnVsbCxcbiAgICBpbWFnZTogbnVsbFxuICB9LFxuICB0cmFuc2l0aW9uOiB7XG4gICAgcHJvcGVydHk6IG51bGwsXG4gICAgZHVyYXRpb246IG51bGwsXG4gICAgJ3RpbWluZy1mdW5jdGlvbic6IG51bGwsXG4gICAgdGltaW5nRnVuY3Rpb246IG51bGwsXG4gICAgLy8gTmVlZGVkIGZvciBhdm9pZGluZyBjb21pbGF0aW9uIGlzc3VlcyB3aXRoIGpzcy1wbHVnaW4tY2FtZWwtY2FzZVxuICAgIGRlbGF5OiBudWxsXG4gIH0sXG4gIGFuaW1hdGlvbjoge1xuICAgIG5hbWU6IG51bGwsXG4gICAgZHVyYXRpb246IG51bGwsXG4gICAgJ3RpbWluZy1mdW5jdGlvbic6IG51bGwsXG4gICAgdGltaW5nRnVuY3Rpb246IG51bGwsXG4gICAgLy8gTmVlZGVkIHRvIGF2b2lkIGNvbXBpbGF0aW9uIGlzc3VlcyB3aXRoIGpzcy1wbHVnaW4tY2FtZWwtY2FzZVxuICAgIGRlbGF5OiBudWxsLFxuICAgICdpdGVyYXRpb24tY291bnQnOiBudWxsLFxuICAgIGl0ZXJhdGlvbkNvdW50OiBudWxsLFxuICAgIC8vIE5lZWRlZCB0byBhdm9pZCBjb21waWxhdGlvbiBpc3N1ZXMgd2l0aCBqc3MtcGx1Z2luLWNhbWVsLWNhc2VcbiAgICBkaXJlY3Rpb246IG51bGwsXG4gICAgJ2ZpbGwtbW9kZSc6IG51bGwsXG4gICAgZmlsbE1vZGU6IG51bGwsXG4gICAgLy8gTmVlZGVkIHRvIGF2b2lkIGNvbXBpbGF0aW9uIGlzc3VlcyB3aXRoIGpzcy1wbHVnaW4tY2FtZWwtY2FzZVxuICAgICdwbGF5LXN0YXRlJzogbnVsbCxcbiAgICBwbGF5U3RhdGU6IG51bGwgLy8gTmVlZGVkIHRvIGF2b2lkIGNvbXBpbGF0aW9uIGlzc3VlcyB3aXRoIGpzcy1wbHVnaW4tY2FtZWwtY2FzZVxuXG4gIH0sXG4gICdib3gtc2hhZG93Jzoge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBibHVyOiAwLFxuICAgIHNwcmVhZDogMCxcbiAgICBjb2xvcjogbnVsbCxcbiAgICBpbnNldDogbnVsbFxuICB9LFxuICAndGV4dC1zaGFkb3cnOiB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIGJsdXI6IG51bGwsXG4gICAgY29sb3I6IG51bGxcbiAgfVxuICAvKipcbiAgICogQSBzY2hlbWUgZm9yIGNvbnZlcnRpbmcgbm9uLXN0YW5kYXJ0IHByb3BlcnRpZXMgaW5zaWRlIG9iamVjdC5cbiAgICogRm9yIGUuZy46IGluY2x1ZGUgJ2JvcmRlci1yYWRpdXMnIHByb3BlcnR5IGluc2lkZSAnYm9yZGVyJyBvYmplY3QuXG4gICAqL1xuXG59O1xudmFyIGN1c3RvbVByb3BPYmogPSB7XG4gIGJvcmRlcjoge1xuICAgIHJhZGl1czogJ2JvcmRlci1yYWRpdXMnLFxuICAgIGltYWdlOiAnYm9yZGVyLWltYWdlJyxcbiAgICB3aWR0aDogJ2JvcmRlci13aWR0aCcsXG4gICAgc3R5bGU6ICdib3JkZXItc3R5bGUnLFxuICAgIGNvbG9yOiAnYm9yZGVyLWNvbG9yJ1xuICB9LFxuICAnYm9yZGVyLWJvdHRvbSc6IHtcbiAgICB3aWR0aDogJ2JvcmRlci1ib3R0b20td2lkdGgnLFxuICAgIHN0eWxlOiAnYm9yZGVyLWJvdHRvbS1zdHlsZScsXG4gICAgY29sb3I6ICdib3JkZXItYm90dG9tLWNvbG9yJ1xuICB9LFxuICAnYm9yZGVyLXRvcCc6IHtcbiAgICB3aWR0aDogJ2JvcmRlci10b3Atd2lkdGgnLFxuICAgIHN0eWxlOiAnYm9yZGVyLXRvcC1zdHlsZScsXG4gICAgY29sb3I6ICdib3JkZXItdG9wLWNvbG9yJ1xuICB9LFxuICAnYm9yZGVyLWxlZnQnOiB7XG4gICAgd2lkdGg6ICdib3JkZXItbGVmdC13aWR0aCcsXG4gICAgc3R5bGU6ICdib3JkZXItbGVmdC1zdHlsZScsXG4gICAgY29sb3I6ICdib3JkZXItbGVmdC1jb2xvcidcbiAgfSxcbiAgJ2JvcmRlci1yaWdodCc6IHtcbiAgICB3aWR0aDogJ2JvcmRlci1yaWdodC13aWR0aCcsXG4gICAgc3R5bGU6ICdib3JkZXItcmlnaHQtc3R5bGUnLFxuICAgIGNvbG9yOiAnYm9yZGVyLXJpZ2h0LWNvbG9yJ1xuICB9LFxuICBiYWNrZ3JvdW5kOiB7XG4gICAgc2l6ZTogJ2JhY2tncm91bmQtc2l6ZScsXG4gICAgaW1hZ2U6ICdiYWNrZ3JvdW5kLWltYWdlJ1xuICB9LFxuICBmb250OiB7XG4gICAgc3R5bGU6ICdmb250LXN0eWxlJyxcbiAgICB2YXJpYW50OiAnZm9udC12YXJpYW50JyxcbiAgICB3ZWlnaHQ6ICdmb250LXdlaWdodCcsXG4gICAgc3RyZXRjaDogJ2ZvbnQtc3RyZXRjaCcsXG4gICAgc2l6ZTogJ2ZvbnQtc2l6ZScsXG4gICAgZmFtaWx5OiAnZm9udC1mYW1pbHknLFxuICAgIGxpbmVIZWlnaHQ6ICdsaW5lLWhlaWdodCcsXG4gICAgLy8gTmVlZGVkIHRvIGF2b2lkIGNvbXBpbGF0aW9uIGlzc3VlcyB3aXRoIGpzcy1wbHVnaW4tY2FtZWwtY2FzZVxuICAgICdsaW5lLWhlaWdodCc6ICdsaW5lLWhlaWdodCdcbiAgfSxcbiAgZmxleDoge1xuICAgIGdyb3c6ICdmbGV4LWdyb3cnLFxuICAgIGJhc2lzOiAnZmxleC1iYXNpcycsXG4gICAgZGlyZWN0aW9uOiAnZmxleC1kaXJlY3Rpb24nLFxuICAgIHdyYXA6ICdmbGV4LXdyYXAnLFxuICAgIGZsb3c6ICdmbGV4LWZsb3cnLFxuICAgIHNocmluazogJ2ZsZXgtc2hyaW5rJ1xuICB9LFxuICBhbGlnbjoge1xuICAgIHNlbGY6ICdhbGlnbi1zZWxmJyxcbiAgICBpdGVtczogJ2FsaWduLWl0ZW1zJyxcbiAgICBjb250ZW50OiAnYWxpZ24tY29udGVudCdcbiAgfSxcbiAgZ3JpZDoge1xuICAgICd0ZW1wbGF0ZS1jb2x1bW5zJzogJ2dyaWQtdGVtcGxhdGUtY29sdW1ucycsXG4gICAgdGVtcGxhdGVDb2x1bW5zOiAnZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zJyxcbiAgICAndGVtcGxhdGUtcm93cyc6ICdncmlkLXRlbXBsYXRlLXJvd3MnLFxuICAgIHRlbXBsYXRlUm93czogJ2dyaWQtdGVtcGxhdGUtcm93cycsXG4gICAgJ3RlbXBsYXRlLWFyZWFzJzogJ2dyaWQtdGVtcGxhdGUtYXJlYXMnLFxuICAgIHRlbXBsYXRlQXJlYXM6ICdncmlkLXRlbXBsYXRlLWFyZWFzJyxcbiAgICB0ZW1wbGF0ZTogJ2dyaWQtdGVtcGxhdGUnLFxuICAgICdhdXRvLWNvbHVtbnMnOiAnZ3JpZC1hdXRvLWNvbHVtbnMnLFxuICAgIGF1dG9Db2x1bW5zOiAnZ3JpZC1hdXRvLWNvbHVtbnMnLFxuICAgICdhdXRvLXJvd3MnOiAnZ3JpZC1hdXRvLXJvd3MnLFxuICAgIGF1dG9Sb3dzOiAnZ3JpZC1hdXRvLXJvd3MnLFxuICAgICdhdXRvLWZsb3cnOiAnZ3JpZC1hdXRvLWZsb3cnLFxuICAgIGF1dG9GbG93OiAnZ3JpZC1hdXRvLWZsb3cnLFxuICAgIHJvdzogJ2dyaWQtcm93JyxcbiAgICBjb2x1bW46ICdncmlkLWNvbHVtbicsXG4gICAgJ3Jvdy1zdGFydCc6ICdncmlkLXJvdy1zdGFydCcsXG4gICAgcm93U3RhcnQ6ICdncmlkLXJvdy1zdGFydCcsXG4gICAgJ3Jvdy1lbmQnOiAnZ3JpZC1yb3ctZW5kJyxcbiAgICByb3dFbmQ6ICdncmlkLXJvdy1lbmQnLFxuICAgICdjb2x1bW4tc3RhcnQnOiAnZ3JpZC1jb2x1bW4tc3RhcnQnLFxuICAgIGNvbHVtblN0YXJ0OiAnZ3JpZC1jb2x1bW4tc3RhcnQnLFxuICAgICdjb2x1bW4tZW5kJzogJ2dyaWQtY29sdW1uLWVuZCcsXG4gICAgY29sdW1uRW5kOiAnZ3JpZC1jb2x1bW4tZW5kJyxcbiAgICBhcmVhOiAnZ3JpZC1hcmVhJyxcbiAgICBnYXA6ICdncmlkLWdhcCcsXG4gICAgJ3Jvdy1nYXAnOiAnZ3JpZC1yb3ctZ2FwJyxcbiAgICByb3dHYXA6ICdncmlkLXJvdy1nYXAnLFxuICAgICdjb2x1bW4tZ2FwJzogJ2dyaWQtY29sdW1uLWdhcCcsXG4gICAgY29sdW1uR2FwOiAnZ3JpZC1jb2x1bW4tZ2FwJ1xuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuXG4vKipcbiAqIE1hcCB2YWx1ZXMgYnkgZ2l2ZW4gcHJvcC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiB2YWx1ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5hbCBwcm9wZXJ0eVxuICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpbmFsIHJ1bGVcbiAqIEByZXR1cm4ge1N0cmluZ30gbWFwcGVkIHZhbHVlc1xuICovXG5mdW5jdGlvbiBtYXBWYWx1ZXNCeVByb3AodmFsdWUsIHByb3AsIHJ1bGUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBvYmplY3RUb0FycmF5KGl0ZW0sIHByb3AsIHJ1bGUsIGZhbHNlLCB0cnVlKTtcbiAgfSk7XG59XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgdG8gbmVzdGVkIGFycmF5LCBpZiBuZWVkZWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHByb2Nlc3NBcnJheSh2YWx1ZSwgcHJvcCwgc2NoZW1lLCBydWxlKSB7XG4gIGlmIChzY2hlbWVbcHJvcF0gPT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkgcmV0dXJuIHByb2Nlc3NBcnJheSh2YWx1ZVswXSwgcHJvcCwgc2NoZW1lLCBydWxlKTtcblxuICBpZiAodHlwZW9mIHZhbHVlWzBdID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXBWYWx1ZXNCeVByb3AodmFsdWUsIHByb3AsIHJ1bGUpO1xuICB9XG5cbiAgcmV0dXJuIFt2YWx1ZV07XG59XG4vKipcbiAqIENvbnZlcnQgb2JqZWN0IHRvIGFycmF5LlxuICovXG5cblxuZnVuY3Rpb24gb2JqZWN0VG9BcnJheSh2YWx1ZSwgcHJvcCwgcnVsZSwgaXNGYWxsYmFjaywgaXNJbkFycmF5KSB7XG4gIGlmICghKHByb3BPYmpbcHJvcF0gfHwgY3VzdG9tUHJvcE9ialtwcm9wXSkpIHJldHVybiBbXTtcbiAgdmFyIHJlc3VsdCA9IFtdOyAvLyBDaGVjayBpZiBleGlzdHMgYW55IG5vbi1zdGFuZGFyZCBwcm9wZXJ0eVxuXG4gIGlmIChjdXN0b21Qcm9wT2JqW3Byb3BdKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdmFsdWUgPSBjdXN0b21Qcm9wc1RvU3R5bGUodmFsdWUsIHJ1bGUsIGN1c3RvbVByb3BPYmpbcHJvcF0sIGlzRmFsbGJhY2spO1xuICB9IC8vIFBhc3MgdGhyb3VnaHQgYWxsIHN0YW5kYXJ0IHByb3BzXG5cblxuICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGJhc2VQcm9wIGluIHByb3BPYmpbcHJvcF0pIHtcbiAgICAgIGlmICh2YWx1ZVtiYXNlUHJvcF0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbYmFzZVByb3BdKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHByb3BBcnJheUluT2JqW2Jhc2VQcm9wXSA9PT0gbnVsbCA/IHZhbHVlW2Jhc2VQcm9wXSA6IHZhbHVlW2Jhc2VQcm9wXS5qb2luKCcgJykpO1xuICAgICAgICB9IGVsc2UgcmVzdWx0LnB1c2godmFsdWVbYmFzZVByb3BdKTtcblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gQWRkIGRlZmF1bHQgdmFsdWUgZnJvbSBwcm9wcyBjb25maWcuXG5cblxuICAgICAgaWYgKHByb3BPYmpbcHJvcF1bYmFzZVByb3BdICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocHJvcE9ialtwcm9wXVtiYXNlUHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzdWx0Lmxlbmd0aCB8fCBpc0luQXJyYXkpIHJldHVybiByZXN1bHQ7XG4gIHJldHVybiBbcmVzdWx0XTtcbn1cbi8qKlxuICogQ29udmVydCBjdXN0b20gcHJvcGVydGllcyB2YWx1ZXMgdG8gc3R5bGVzIGFkZGluZyB0aGVtIHRvIHJ1bGUgZGlyZWN0bHlcbiAqL1xuXG5cbmZ1bmN0aW9uIGN1c3RvbVByb3BzVG9TdHlsZSh2YWx1ZSwgcnVsZSwgY3VzdG9tUHJvcHMsIGlzRmFsbGJhY2spIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBjdXN0b21Qcm9wcykge1xuICAgIHZhciBwcm9wTmFtZSA9IGN1c3RvbVByb3BzW3Byb3BdOyAvLyBJZiBjdXJyZW50IHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeSBpbiBydWxlIC0gYWRkIG5ldyBvbmVcblxuICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcF0gIT09ICd1bmRlZmluZWQnICYmIChpc0ZhbGxiYWNrIHx8ICFydWxlLnByb3AocHJvcE5hbWUpKSkge1xuICAgICAgdmFyIF9zdHlsZURldGVjdG9yO1xuXG4gICAgICB2YXIgYXBwZW5kZWRWYWx1ZSA9IHN0eWxlRGV0ZWN0b3IoKF9zdHlsZURldGVjdG9yID0ge30sIF9zdHlsZURldGVjdG9yW3Byb3BOYW1lXSA9IHZhbHVlW3Byb3BdLCBfc3R5bGVEZXRlY3RvciksIHJ1bGUpW3Byb3BOYW1lXTsgLy8gQWRkIHN0eWxlIGRpcmVjdGx5IGluIHJ1bGVcblxuICAgICAgaWYgKGlzRmFsbGJhY2spIHJ1bGUuc3R5bGUuZmFsbGJhY2tzW3Byb3BOYW1lXSA9IGFwcGVuZGVkVmFsdWU7ZWxzZSBydWxlLnN0eWxlW3Byb3BOYW1lXSA9IGFwcGVuZGVkVmFsdWU7XG4gICAgfSAvLyBEZWxldGUgY29udmVydGVkIHByb3BlcnR5IHRvIGF2b2lkIGRvdWJsZSBjb252ZXJ0aW5nXG5cblxuICAgIGRlbGV0ZSB2YWx1ZVtwcm9wXTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogRGV0ZWN0IGlmIGEgc3R5bGUgbmVlZHMgdG8gYmUgY29udmVydGVkLlxuICovXG5cblxuZnVuY3Rpb24gc3R5bGVEZXRlY3RvcihzdHlsZSwgcnVsZSwgaXNGYWxsYmFjaykge1xuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vIENoZWNrIGRvdWJsZSBhcnJheXMgdG8gYXZvaWQgcmVjdXJzaW9uLlxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgICAgICBpZiAocHJvcCA9PT0gJ2ZhbGxiYWNrcycpIHtcbiAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3R5bGUuZmFsbGJhY2tzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgc3R5bGUuZmFsbGJhY2tzW2luZGV4XSA9IHN0eWxlRGV0ZWN0b3Ioc3R5bGUuZmFsbGJhY2tzW2luZGV4XSwgcnVsZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZVtwcm9wXSA9IHByb2Nlc3NBcnJheSh2YWx1ZSwgcHJvcCwgcHJvcEFycmF5LCBydWxlKTsgLy8gQXZvaWQgY3JlYXRpbmcgcHJvcGVydGllcyB3aXRoIGVtcHR5IHZhbHVlc1xuXG4gICAgICAgIGlmICghc3R5bGVbcHJvcF0ubGVuZ3RoKSBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcCA9PT0gJ2ZhbGxiYWNrcycpIHtcbiAgICAgICAgc3R5bGUuZmFsbGJhY2tzID0gc3R5bGVEZXRlY3RvcihzdHlsZS5mYWxsYmFja3MsIHJ1bGUsIHRydWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVbcHJvcF0gPSBvYmplY3RUb0FycmF5KHZhbHVlLCBwcm9wLCBydWxlLCBpc0ZhbGxiYWNrKTsgLy8gQXZvaWQgY3JlYXRpbmcgcHJvcGVydGllcyB3aXRoIGVtcHR5IHZhbHVlc1xuXG4gICAgICBpZiAoIXN0eWxlW3Byb3BdLmxlbmd0aCkgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgIH0gLy8gTWF5YmUgYSBjb21wdXRlZCB2YWx1ZSByZXN1bHRpbmcgaW4gYW4gZW1wdHkgc3RyaW5nXG4gICAgZWxzZSBpZiAoc3R5bGVbcHJvcF0gPT09ICcnKSBkZWxldGUgc3R5bGVbcHJvcF07XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG4vKipcbiAqIEFkZHMgcG9zc2liaWxpdHkgdG8gd3JpdGUgZXhwYW5kZWQgc3R5bGVzLlxuICovXG5cblxuZnVuY3Rpb24ganNzRXhwYW5kKCkge1xuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIGlmICghc3R5bGUgfHwgcnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHtcbiAgICAgIC8vIFBhc3MgcnVsZXMgb25lIGJ5IG9uZSBhbmQgcmVmb3JtYXQgdGhlbVxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0eWxlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzdHlsZVtpbmRleF0gPSBzdHlsZURldGVjdG9yKHN0eWxlW2luZGV4XSwgcnVsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVEZXRlY3RvcihzdHlsZSwgcnVsZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBqc3NFeHBhbmQ7XG4iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmopO1xufTtcblxudmFyIHZhbHVlTnMgPSBcImV4dGVuZEN1cnJWYWx1ZVwiICsgRGF0ZS5ub3coKTtcblxuZnVuY3Rpb24gbWVyZ2VFeHRlbmQoc3R5bGUsIHJ1bGUsIHNoZWV0LCBuZXdTdHlsZSkge1xuICB2YXIgZXh0ZW5kVHlwZSA9IHR5cGVvZiBzdHlsZS5leHRlbmQ7IC8vIEV4dGVuZCB1c2luZyBhIHJ1bGUgbmFtZS5cblxuICBpZiAoZXh0ZW5kVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXNoZWV0KSByZXR1cm47XG4gICAgdmFyIHJlZlJ1bGUgPSBzaGVldC5nZXRSdWxlKHN0eWxlLmV4dGVuZCk7XG4gICAgaWYgKCFyZWZSdWxlKSByZXR1cm47XG5cbiAgICBpZiAocmVmUnVsZSA9PT0gcnVsZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBBIHJ1bGUgdHJpZXMgdG8gZXh0ZW5kIGl0c2VsZiBcXG5cIiArIHJ1bGUudG9TdHJpbmcoKSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IHJlZlJ1bGUub3B0aW9ucy5wYXJlbnQ7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB2YXIgb3JpZ2luYWxTdHlsZSA9IHBhcmVudC5ydWxlcy5yYXdbc3R5bGUuZXh0ZW5kXTtcbiAgICAgIGV4dGVuZChvcmlnaW5hbFN0eWxlLCBydWxlLCBzaGVldCwgbmV3U3R5bGUpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSAvLyBFeHRlbmQgdXNpbmcgYW4gYXJyYXkuXG5cblxuICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZS5leHRlbmQpKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0eWxlLmV4dGVuZC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBzaW5nbGVFeHRlbmQgPSBzdHlsZS5leHRlbmRbaW5kZXhdO1xuICAgICAgdmFyIHNpbmdsZVN0eWxlID0gdHlwZW9mIHNpbmdsZUV4dGVuZCA9PT0gJ3N0cmluZycgPyBfZXh0ZW5kcyh7fSwgc3R5bGUsIHtcbiAgICAgICAgZXh0ZW5kOiBzaW5nbGVFeHRlbmRcbiAgICAgIH0pIDogc3R5bGUuZXh0ZW5kW2luZGV4XTtcbiAgICAgIGV4dGVuZChzaW5nbGVTdHlsZSwgcnVsZSwgc2hlZXQsIG5ld1N0eWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gLy8gRXh0ZW5kIGlzIGEgc3R5bGUgb2JqZWN0LlxuXG5cbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZS5leHRlbmQpIHtcbiAgICBpZiAocHJvcCA9PT0gJ2V4dGVuZCcpIHtcbiAgICAgIGV4dGVuZChzdHlsZS5leHRlbmQuZXh0ZW5kLCBydWxlLCBzaGVldCwgbmV3U3R5bGUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KHN0eWxlLmV4dGVuZFtwcm9wXSkpIHtcbiAgICAgIGlmICghKHByb3AgaW4gbmV3U3R5bGUpKSBuZXdTdHlsZVtwcm9wXSA9IHt9O1xuICAgICAgZXh0ZW5kKHN0eWxlLmV4dGVuZFtwcm9wXSwgcnVsZSwgc2hlZXQsIG5ld1N0eWxlW3Byb3BdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIG5ld1N0eWxlW3Byb3BdID0gc3R5bGUuZXh0ZW5kW3Byb3BdO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlUmVzdChzdHlsZSwgcnVsZSwgc2hlZXQsIG5ld1N0eWxlKSB7XG4gIC8vIENvcHkgYmFzZSBzdHlsZS5cbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgIGlmIChwcm9wID09PSAnZXh0ZW5kJykgY29udGludWU7XG5cbiAgICBpZiAoaXNPYmplY3QobmV3U3R5bGVbcHJvcF0pICYmIGlzT2JqZWN0KHN0eWxlW3Byb3BdKSkge1xuICAgICAgZXh0ZW5kKHN0eWxlW3Byb3BdLCBydWxlLCBzaGVldCwgbmV3U3R5bGVbcHJvcF0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KHN0eWxlW3Byb3BdKSkge1xuICAgICAgbmV3U3R5bGVbcHJvcF0gPSBleHRlbmQoc3R5bGVbcHJvcF0sIHJ1bGUsIHNoZWV0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIG5ld1N0eWxlW3Byb3BdID0gc3R5bGVbcHJvcF07XG4gIH1cbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgZXh0ZW5kIHN0eWxlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dGVuZChzdHlsZSwgcnVsZSwgc2hlZXQsIG5ld1N0eWxlKSB7XG4gIGlmIChuZXdTdHlsZSA9PT0gdm9pZCAwKSB7XG4gICAgbmV3U3R5bGUgPSB7fTtcbiAgfVxuXG4gIG1lcmdlRXh0ZW5kKHN0eWxlLCBydWxlLCBzaGVldCwgbmV3U3R5bGUpO1xuICBtZXJnZVJlc3Qoc3R5bGUsIHJ1bGUsIHNoZWV0LCBuZXdTdHlsZSk7XG4gIHJldHVybiBuZXdTdHlsZTtcbn1cbi8qKlxuICogSGFuZGxlIGBleHRlbmRgIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGpzc0V4dGVuZCgpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKCdleHRlbmQnIGluIHN0eWxlKSByZXR1cm4gZXh0ZW5kKHN0eWxlLCBydWxlLCBzaGVldCk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCwgcnVsZSkge1xuICAgIGlmIChwcm9wICE9PSAnZXh0ZW5kJykgcmV0dXJuIHZhbHVlOyAvLyBWYWx1ZSBpcyBlbXB0eSwgcmVtb3ZlIHByb3BlcnRpZXMgc2V0IHByZXZpb3VzbHkuXG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgZm9yICh2YXIga2V5IGluIHJ1bGVbdmFsdWVOc10pIHtcbiAgICAgICAgcnVsZS5wcm9wKGtleSwgbnVsbCk7XG4gICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBGbG93IGNvbXBsYWlucyBiZWNhdXNlIHRoZXJlIGlzIG5vIGluZGV4ZXIgcHJvcGVydHkgaW4gU3R5bGVSdWxlXG5cblxuICAgICAgcnVsZVt2YWx1ZU5zXSA9IG51bGw7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWluLXJoc10gVGhpcyB3aWxsIGJlIGFuIG9iamVjdFxuICAgICAgZm9yICh2YXIgX2tleSBpbiB2YWx1ZSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIFRoaXMgd2lsbCBiZSBhbiBvYmplY3RcbiAgICAgICAgcnVsZS5wcm9wKF9rZXksIHZhbHVlW19rZXldKTtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIEZsb3cgY29tcGxhaW5zIGJlY2F1c2UgdGhlcmUgaXMgbm8gaW5kZXhlciBwcm9wZXJ0eSBpbiBTdHlsZVJ1bGVcblxuXG4gICAgICBydWxlW3ZhbHVlTnNdID0gdmFsdWU7XG4gICAgfSAvLyBNYWtlIHN1cmUgd2UgZG9uJ3Qgc2V0IHRoZSB2YWx1ZSBpbiB0aGUgY29yZS5cblxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSxcbiAgICBvbkNoYW5nZVZhbHVlOiBvbkNoYW5nZVZhbHVlXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGpzc0V4dGVuZDtcbiIsImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCB7IFJ1bGVMaXN0IH0gZnJvbSAnanNzJztcblxudmFyIGF0ID0gJ0BnbG9iYWwnO1xudmFyIGF0UHJlZml4ID0gJ0BnbG9iYWwgJztcblxudmFyIEdsb2JhbENvbnRhaW5lclJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxDb250YWluZXJSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2dsb2JhbCc7XG4gICAgdGhpcy5hdCA9IGF0O1xuICAgIHRoaXMucnVsZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIHNlbGVjdG9yIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQoc2VsZWN0b3IsIHN0eWxlc1tzZWxlY3Rvcl0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBHbG9iYWxDb250YWluZXJSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0UnVsZSA9IGZ1bmN0aW9uIGdldFJ1bGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLCBydW4gcGx1Z2lucy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlLCBvcHRpb25zKTtcbiAgICBpZiAocnVsZSkgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIEdsb2JhbENvbnRhaW5lclJ1bGU7XG59KCk7XG5cbnZhciBHbG9iYWxQcmVmaXhlZFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxQcmVmaXhlZFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdnbG9iYWwnO1xuICAgIHRoaXMuYXQgPSBhdDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5ydWxlID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzZWxlY3RvciA9IGtleS5zdWJzdHIoYXRQcmVmaXgubGVuZ3RoKTtcbiAgICB0aGlzLnJ1bGUgPSBvcHRpb25zLmpzcy5jcmVhdGVSdWxlKHNlbGVjdG9yLCBzdHlsZSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gR2xvYmFsUHJlZml4ZWRSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJ1bGUgPyB0aGlzLnJ1bGUudG9TdHJpbmcob3B0aW9ucykgOiAnJztcbiAgfTtcblxuICByZXR1cm4gR2xvYmFsUHJlZml4ZWRSdWxlO1xufSgpO1xuXG52YXIgc2VwYXJhdG9yUmVnRXhwID0gL1xccyosXFxzKi9nO1xuXG5mdW5jdGlvbiBhZGRTY29wZShzZWxlY3Rvciwgc2NvcGUpIHtcbiAgdmFyIHBhcnRzID0gc2VsZWN0b3Iuc3BsaXQoc2VwYXJhdG9yUmVnRXhwKTtcbiAgdmFyIHNjb3BlZCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBzY29wZWQgKz0gc2NvcGUgKyBcIiBcIiArIHBhcnRzW2ldLnRyaW0oKTtcbiAgICBpZiAocGFydHNbaSArIDFdKSBzY29wZWQgKz0gJywgJztcbiAgfVxuXG4gIHJldHVybiBzY29wZWQ7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU5lc3RlZEdsb2JhbENvbnRhaW5lclJ1bGUocnVsZSwgc2hlZXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBydWxlLm9wdGlvbnMsXG4gICAgICBzdHlsZSA9IHJ1bGUuc3R5bGU7XG4gIHZhciBydWxlcyA9IHN0eWxlID8gc3R5bGVbYXRdIDogbnVsbDtcbiAgaWYgKCFydWxlcykgcmV0dXJuO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gcnVsZXMpIHtcbiAgICBzaGVldC5hZGRSdWxlKG5hbWUsIHJ1bGVzW25hbWVdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2VsZWN0b3I6IGFkZFNjb3BlKG5hbWUsIHJ1bGUuc2VsZWN0b3IpXG4gICAgfSkpO1xuICB9XG5cbiAgZGVsZXRlIHN0eWxlW2F0XTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUHJlZml4ZWRHbG9iYWxSdWxlKHJ1bGUsIHNoZWV0KSB7XG4gIHZhciBvcHRpb25zID0gcnVsZS5vcHRpb25zLFxuICAgICAgc3R5bGUgPSBydWxlLnN0eWxlO1xuXG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICBpZiAocHJvcFswXSAhPT0gJ0AnIHx8IHByb3Auc3Vic3RyKDAsIGF0Lmxlbmd0aCkgIT09IGF0KSBjb250aW51ZTtcbiAgICB2YXIgc2VsZWN0b3IgPSBhZGRTY29wZShwcm9wLnN1YnN0cihhdC5sZW5ndGgpLCBydWxlLnNlbGVjdG9yKTtcbiAgICBzaGVldC5hZGRSdWxlKHNlbGVjdG9yLCBzdHlsZVtwcm9wXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNlbGVjdG9yOiBzZWxlY3RvclxuICAgIH0pKTtcbiAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gIH1cbn1cbi8qKlxuICogQ29udmVydCBuZXN0ZWQgcnVsZXMgdG8gc2VwYXJhdGUsIHJlbW92ZSB0aGVtIGZyb20gb3JpZ2luYWwgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGpzc0dsb2JhbCgpIHtcbiAgZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucykge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAobmFtZSA9PT0gYXQpIHtcbiAgICAgIHJldHVybiBuZXcgR2xvYmFsQ29udGFpbmVyUnVsZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChuYW1lWzBdID09PSAnQCcgJiYgbmFtZS5zdWJzdHIoMCwgYXRQcmVmaXgubGVuZ3RoKSA9PT0gYXRQcmVmaXgpIHtcbiAgICAgIHJldHVybiBuZXcgR2xvYmFsUHJlZml4ZWRSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC50eXBlID09PSAnZ2xvYmFsJyB8fCBwYXJlbnQub3B0aW9ucy5wYXJlbnQgJiYgcGFyZW50Lm9wdGlvbnMucGFyZW50LnR5cGUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgIG9wdGlvbnMuc2NvcGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2NvcGVkID09PSBmYWxzZSkge1xuICAgICAgb3B0aW9ucy5zZWxlY3RvciA9IG5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJyB8fCAhc2hlZXQpIHJldHVybjtcbiAgICBoYW5kbGVOZXN0ZWRHbG9iYWxDb250YWluZXJSdWxlKHJ1bGUsIHNoZWV0KTtcbiAgICBoYW5kbGVQcmVmaXhlZEdsb2JhbFJ1bGUocnVsZSwgc2hlZXQpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvbkNyZWF0ZVJ1bGU6IG9uQ3JlYXRlUnVsZSxcbiAgICBvblByb2Nlc3NSdWxlOiBvblByb2Nlc3NSdWxlXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGpzc0dsb2JhbDtcbiIsImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5cbnZhciBzZXBhcmF0b3JSZWdFeHAgPSAvXFxzKixcXHMqL2c7XG52YXIgcGFyZW50UmVnRXhwID0gLyYvZztcbnZhciByZWZSZWdFeHAgPSAvXFwkKFtcXHctXSspL2c7XG4vKipcbiAqIENvbnZlcnQgbmVzdGVkIHJ1bGVzIHRvIHNlcGFyYXRlLCByZW1vdmUgdGhlbSBmcm9tIG9yaWdpbmFsIHN0eWxlcy5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24ganNzTmVzdGVkKCkge1xuICAvLyBHZXQgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciAkcmVmIHJlcGxhY2VtZW50LlxuICBmdW5jdGlvbiBnZXRSZXBsYWNlUmVmKGNvbnRhaW5lciwgc2hlZXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBrZXkpIHtcbiAgICAgIHZhciBydWxlID0gY29udGFpbmVyLmdldFJ1bGUoa2V5KSB8fCBzaGVldCAmJiBzaGVldC5nZXRSdWxlKGtleSk7XG5cbiAgICAgIGlmIChydWxlKSB7XG4gICAgICAgIHJ1bGUgPSBydWxlO1xuICAgICAgICByZXR1cm4gcnVsZS5zZWxlY3RvcjtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBDb3VsZCBub3QgZmluZCB0aGUgcmVmZXJlbmNlZCBydWxlIFxcXCJcIiArIGtleSArIFwiXFxcIiBpbiBcXFwiXCIgKyAoY29udGFpbmVyLm9wdGlvbnMubWV0YSB8fCBjb250YWluZXIudG9TdHJpbmcoKSkgKyBcIlxcXCIuXCIpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZVBhcmVudFJlZnMobmVzdGVkUHJvcCwgcGFyZW50UHJvcCkge1xuICAgIHZhciBwYXJlbnRTZWxlY3RvcnMgPSBwYXJlbnRQcm9wLnNwbGl0KHNlcGFyYXRvclJlZ0V4cCk7XG4gICAgdmFyIG5lc3RlZFNlbGVjdG9ycyA9IG5lc3RlZFByb3Auc3BsaXQoc2VwYXJhdG9yUmVnRXhwKTtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcmVudCA9IHBhcmVudFNlbGVjdG9yc1tpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuZXN0ZWRTZWxlY3RvcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG5lc3RlZCA9IG5lc3RlZFNlbGVjdG9yc1tqXTtcbiAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9ICcsICc7IC8vIFJlcGxhY2UgYWxsICYgYnkgdGhlIHBhcmVudCBvciBwcmVmaXggJiB3aXRoIHRoZSBwYXJlbnQuXG5cbiAgICAgICAgcmVzdWx0ICs9IG5lc3RlZC5pbmRleE9mKCcmJykgIT09IC0xID8gbmVzdGVkLnJlcGxhY2UocGFyZW50UmVnRXhwLCBwYXJlbnQpIDogcGFyZW50ICsgXCIgXCIgKyBuZXN0ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMocnVsZSwgY29udGFpbmVyLCBwcmV2T3B0aW9ucykge1xuICAgIC8vIE9wdGlvbnMgaGFzIGJlZW4gYWxyZWFkeSBjcmVhdGVkLCBub3cgd2Ugb25seSBpbmNyZWFzZSBpbmRleC5cbiAgICBpZiAocHJldk9wdGlvbnMpIHJldHVybiBfZXh0ZW5kcyh7fSwgcHJldk9wdGlvbnMsIHtcbiAgICAgIGluZGV4OiBwcmV2T3B0aW9ucy5pbmRleCArIDEgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgICB9KTtcbiAgICB2YXIgbmVzdGluZ0xldmVsID0gcnVsZS5vcHRpb25zLm5lc3RpbmdMZXZlbDtcbiAgICBuZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWwgPT09IHVuZGVmaW5lZCA/IDEgOiBuZXN0aW5nTGV2ZWwgKyAxO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgcnVsZS5vcHRpb25zLCB7XG4gICAgICBuZXN0aW5nTGV2ZWw6IG5lc3RpbmdMZXZlbCxcbiAgICAgIGluZGV4OiBjb250YWluZXIuaW5kZXhPZihydWxlKSArIDEgLy8gV2UgZG9uJ3QgbmVlZCB0aGUgcGFyZW50IG5hbWUgdG8gYmUgc2V0IG9wdGlvbnMgZm9yIGNobGlkLlxuXG4gICAgfSk7XG5cbiAgICBkZWxldGUgb3B0aW9ucy5uYW1lO1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuICAgIHZhciBzdHlsZVJ1bGUgPSBydWxlO1xuICAgIHZhciBjb250YWluZXIgPSBzdHlsZVJ1bGUub3B0aW9ucy5wYXJlbnQ7XG4gICAgdmFyIG9wdGlvbnM7XG4gICAgdmFyIHJlcGxhY2VSZWY7XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICB2YXIgaXNOZXN0ZWQgPSBwcm9wLmluZGV4T2YoJyYnKSAhPT0gLTE7XG4gICAgICB2YXIgaXNOZXN0ZWRDb25kaXRpb25hbCA9IHByb3BbMF0gPT09ICdAJztcbiAgICAgIGlmICghaXNOZXN0ZWQgJiYgIWlzTmVzdGVkQ29uZGl0aW9uYWwpIGNvbnRpbnVlO1xuICAgICAgb3B0aW9ucyA9IGdldE9wdGlvbnMoc3R5bGVSdWxlLCBjb250YWluZXIsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoaXNOZXN0ZWQpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gcmVwbGFjZVBhcmVudFJlZnMocHJvcCwgc3R5bGVSdWxlLnNlbGVjdG9yKTsgLy8gTGF6aWx5IGNyZWF0ZSB0aGUgcmVmIHJlcGxhY2VyIGZ1bmN0aW9uIGp1c3Qgb25jZSBmb3JcbiAgICAgICAgLy8gYWxsIG5lc3RlZCBydWxlcyB3aXRoaW4gdGhlIHNoZWV0LlxuXG4gICAgICAgIGlmICghcmVwbGFjZVJlZikgcmVwbGFjZVJlZiA9IGdldFJlcGxhY2VSZWYoY29udGFpbmVyLCBzaGVldCk7IC8vIFJlcGxhY2UgYWxsICRyZWZzLlxuXG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShyZWZSZWdFeHAsIHJlcGxhY2VSZWYpO1xuICAgICAgICBjb250YWluZXIuYWRkUnVsZShzZWxlY3Rvciwgc3R5bGVbcHJvcF0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXN0ZWRDb25kaXRpb25hbCkge1xuICAgICAgICAvLyBQbGFjZSBjb25kaXRpb25hbCByaWdodCBhZnRlciB0aGUgcGFyZW50IHJ1bGUgdG8gZW5zdXJlIHJpZ2h0IG9yZGVyaW5nLlxuICAgICAgICBjb250YWluZXIuYWRkUnVsZShwcm9wLCB7fSwgb3B0aW9ucykgLy8gRmxvdyBleHBlY3RzIG1vcmUgb3B0aW9ucyBidXQgdGhleSBhcmVuJ3QgcmVxdWlyZWRcbiAgICAgICAgLy8gQW5kIGZsb3cgZG9lc24ndCBrbm93IHRoaXMgd2lsbCBhbHdheXMgYmUgYSBTdHlsZVJ1bGUgd2hpY2ggaGFzIHRoZSBhZGRSdWxlIG1ldGhvZFxuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdXG4gICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICAuYWRkUnVsZShzdHlsZVJ1bGUua2V5LCBzdHlsZVtwcm9wXSwge1xuICAgICAgICAgIHNlbGVjdG9yOiBzdHlsZVJ1bGUuc2VsZWN0b3JcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBqc3NOZXN0ZWQ7XG4iLCIvKipcbiAqIFNvcnQgcHJvcHMgYnkgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBqc3NQcm9wc1NvcnQoKSB7XG4gIHZhciBzb3J0ID0gZnVuY3Rpb24gc29ydChwcm9wMCwgcHJvcDEpIHtcbiAgICBpZiAocHJvcDAubGVuZ3RoID09PSBwcm9wMS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBwcm9wMCA+IHByb3AxID8gMSA6IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wMC5sZW5ndGggLSBwcm9wMS5sZW5ndGg7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcbiAgICAgIHZhciBuZXdTdHlsZSA9IHt9O1xuICAgICAgdmFyIHByb3BzID0gT2JqZWN0LmtleXMoc3R5bGUpLnNvcnQoc29ydCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3U3R5bGVbcHJvcHNbaV1dID0gc3R5bGVbcHJvcHNbaV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3U3R5bGU7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBqc3NQcm9wc1NvcnQ7XG4iLCJpbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IHsgY3JlYXRlUnVsZSB9IGZyb20gJ2pzcyc7XG5cbnZhciBub3cgPSBEYXRlLm5vdygpO1xudmFyIGZuVmFsdWVzTnMgPSBcImZuVmFsdWVzXCIgKyBub3c7XG52YXIgZm5SdWxlTnMgPSBcImZuU3R5bGVcIiArICsrbm93O1xuXG52YXIgZnVuY3Rpb25QbHVnaW4gPSBmdW5jdGlvbiBmdW5jdGlvblBsdWdpbigpIHtcbiAgcmV0dXJuIHtcbiAgICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIGRlY2wgIT09ICdmdW5jdGlvbicpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHJ1bGUgPSBjcmVhdGVSdWxlKG5hbWUsIHt9LCBvcHRpb25zKTtcbiAgICAgIHJ1bGVbZm5SdWxlTnNdID0gZGVjbDtcbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0sXG4gICAgb25Qcm9jZXNzU3R5bGU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGV4dHJhY3QgZnVuY3Rpb24gdmFsdWVzIGZyb20gdGhlIGRlY2xhcmF0aW9uLCBzbyB0aGF0IHdlIGNhbiBrZWVwIGNvcmUgdW5hd2FyZSBvZiB0aGVtLlxuICAgICAgLy8gV2UgbmVlZCB0byBkbyB0aGF0IG9ubHkgb25jZS5cbiAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gZXh0cmFjdCBmdW5jdGlvbnMgb24gZWFjaCBzdHlsZSB1cGRhdGUsIHNpbmNlIHRoaXMgY2FuIGhhcHBlbiBvbmx5IG9uY2UuXG4gICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IGZ1bmN0aW9uIHZhbHVlcyBpbnNpZGUgb2YgZnVuY3Rpb24gcnVsZXMuXG4gICAgICBpZiAoZm5WYWx1ZXNOcyBpbiBydWxlIHx8IGZuUnVsZU5zIGluIHJ1bGUpIHJldHVybiBzdHlsZTtcbiAgICAgIHZhciBmblZhbHVlcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSBjb250aW51ZTtcbiAgICAgICAgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgICAgICBmblZhbHVlc1twcm9wXSA9IHZhbHVlO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuXG4gICAgICBydWxlW2ZuVmFsdWVzTnNdID0gZm5WYWx1ZXM7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcbiAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdHlsZVJ1bGUgPSBydWxlOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICAgICAgdmFyIGZuUnVsZSA9IHN0eWxlUnVsZVtmblJ1bGVOc107IC8vIElmIHdlIGhhdmUgYSBzdHlsZSBmdW5jdGlvbiwgdGhlIGVudGlyZSBydWxlIGlzIGR5bmFtaWMgYW5kIHN0eWxlIG9iamVjdFxuICAgICAgLy8gd2lsbCBiZSByZXR1cm5lZCBmcm9tIHRoYXQgZnVuY3Rpb24uXG5cbiAgICAgIGlmIChmblJ1bGUpIHtcbiAgICAgICAgLy8gRW1wdHkgb2JqZWN0IHdpbGwgcmVtb3ZlIGFsbCBjdXJyZW50bHkgZGVmaW5lZCBwcm9wc1xuICAgICAgICAvLyBpbiBjYXNlIGZ1bmN0aW9uIHJ1bGUgcmV0dXJucyBhIGZhbHN5IHZhbHVlLlxuICAgICAgICBzdHlsZVJ1bGUuc3R5bGUgPSBmblJ1bGUoZGF0YSkgfHwge307XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZVJ1bGUuc3R5bGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGVSdWxlLnN0eWxlW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdbSlNTXSBGdW5jdGlvbiB2YWx1ZXMgaW5zaWRlIGZ1bmN0aW9uIHJ1bGVzIGFyZSBub3Qgc3VwcG9ydGVkLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgdmFyIGZuVmFsdWVzID0gc3R5bGVSdWxlW2ZuVmFsdWVzTnNdOyAvLyBJZiB3ZSBoYXZlIGEgZm4gdmFsdWVzIG1hcCwgaXQgaXMgYSBydWxlIHdpdGggZnVuY3Rpb24gdmFsdWVzLlxuXG4gICAgICBpZiAoZm5WYWx1ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgX3Byb3AgaW4gZm5WYWx1ZXMpIHtcbiAgICAgICAgICBzdHlsZVJ1bGUucHJvcChfcHJvcCwgZm5WYWx1ZXNbX3Byb3BdKGRhdGEpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uUGx1Z2luO1xuIiwiaW1wb3J0ICQkb2JzZXJ2YWJsZSBmcm9tICdzeW1ib2wtb2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBjcmVhdGVSdWxlIH0gZnJvbSAnanNzJztcblxudmFyIGlzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIGlzT2JzZXJ2YWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWVbJCRvYnNlcnZhYmxlXSAmJiB2YWx1ZSA9PT0gdmFsdWVbJCRvYnNlcnZhYmxlXSgpO1xufTtcblxudmFyIG9ic2VydmFibGVQbHVnaW4gPSBmdW5jdGlvbiBvYnNlcnZhYmxlUGx1Z2luKHVwZGF0ZU9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIWlzT2JzZXJ2YWJsZShkZWNsKSkgcmV0dXJuIG51bGw7IC8vIENhc3QgYGRlY2xgIHRvIGBPYnNlcnZhYmxlYCwgc2luY2UgaXQgcGFzc2VkIHRoZSB0eXBlIGd1YXJkLlxuXG4gICAgICB2YXIgc3R5bGUkID0gZGVjbDtcbiAgICAgIHZhciBydWxlID0gY3JlYXRlUnVsZShuYW1lLCB7fSwgb3B0aW9ucyk7IC8vIFRPRE9cbiAgICAgIC8vIENhbGwgYHN0cmVhbS5zdWJzY3JpYmUoKWAgcmV0dXJucyBhIHN1YnNjcmlwdGlvbiwgd2hpY2ggc2hvdWxkIGJlIGV4cGxpY2l0bHlcbiAgICAgIC8vIHVuc3Vic2NyaWJlZCBmcm9tIHdoZW4gd2Uga25vdyB0aGlzIHNoZWV0IGlzIG5vIGxvbmdlciBuZWVkZWQuXG5cbiAgICAgIHN0eWxlJC5zdWJzY3JpYmUoZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgICAgICBydWxlLnByb3AocHJvcCwgc3R5bGVbcHJvcF0sIHVwZGF0ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0sXG4gICAgb25Qcm9jZXNzUnVsZTogZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgICBpZiAocnVsZSAmJiBydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybjtcbiAgICAgIHZhciBzdHlsZVJ1bGUgPSBydWxlO1xuICAgICAgdmFyIHN0eWxlID0gc3R5bGVSdWxlLnN0eWxlO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcm9wKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuICAgICAgICBpZiAoIWlzT2JzZXJ2YWJsZSh2YWx1ZSkpIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICAgICAgdmFsdWUuc3Vic2NyaWJlKHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KG5leHRWYWx1ZSkge1xuICAgICAgICAgICAgc3R5bGVSdWxlLnByb3AocHJvcCwgbmV4dFZhbHVlLCB1cGRhdGVPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgICB2YXIgX3JldCA9IF9sb29wKHByb3ApO1xuXG4gICAgICAgIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG9ic2VydmFibGVQbHVnaW47XG4iLCJpbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuXG52YXIgc2VtaVdpdGhObCA9IC87XFxuLztcblxuLyoqXG4gKiBOYWl2ZSBDU1MgcGFyc2VyLlxuICogLSBTdXBwb3J0cyBvbmx5IHJ1bGUgYm9keSAobm8gc2VsZWN0b3JzKVxuICogLSBSZXF1aXJlcyBzZW1pY29sb24gYW5kIG5ldyBsaW5lIGFmdGVyIHRoZSB2YWx1ZSAoZXhjZXB0IG9mIGxhc3QgbGluZSlcbiAqIC0gTm8gbmVzdGVkIHJ1bGVzIHN1cHBvcnRcbiAqL1xudmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2UoY3NzVGV4dCkge1xuICB2YXIgc3R5bGUgPSB7fTtcbiAgdmFyIHNwbGl0ID0gY3NzVGV4dC5zcGxpdChzZW1pV2l0aE5sKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlY2wgPSAoc3BsaXRbaV0gfHwgJycpLnRyaW0oKTtcbiAgICBpZiAoIWRlY2wpIGNvbnRpbnVlO1xuICAgIHZhciBjb2xvbkluZGV4ID0gZGVjbC5pbmRleE9mKCc6Jyk7XG5cbiAgICBpZiAoY29sb25JbmRleCA9PT0gLTEpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gTWFsZm9ybWVkIENTUyBzdHJpbmcgXFxcIlwiICsgZGVjbCArIFwiXFxcIlwiKSA6IHZvaWQgMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wID0gZGVjbC5zdWJzdHIoMCwgY29sb25JbmRleCkudHJpbSgpO1xuICAgIHZhciB2YWx1ZSA9IGRlY2wuc3Vic3RyKGNvbG9uSW5kZXggKyAxKS50cmltKCk7XG4gICAgc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnZhciBvblByb2Nlc3NSdWxlID0gZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gIGlmICh0eXBlb2YgcnVsZS5zdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gV2UgY2FuIHNhZmVseSBhc3N1bWUgdGhhdCBydWxlIGhhcyB0aGUgc3R5bGUgcHJvcGVydHlcbiAgICBydWxlLnN0eWxlID0gcGFyc2UocnVsZS5zdHlsZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRlbXBsYXRlUGx1Z2luKCkge1xuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1J1bGU6IG9uUHJvY2Vzc1J1bGVcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVQbHVnaW47XG4iLCJpbXBvcnQgeyBzdXBwb3J0ZWRLZXlmcmFtZXMsIHN1cHBvcnRlZFZhbHVlLCBzdXBwb3J0ZWRQcm9wZXJ0eSB9IGZyb20gJ2Nzcy12ZW5kb3InO1xuaW1wb3J0IHsgdG9Dc3NWYWx1ZSB9IGZyb20gJ2pzcyc7XG5cbi8qKlxuICogQWRkIHZlbmRvciBwcmVmaXggdG8gYSBwcm9wZXJ0eSBuYW1lIHdoZW4gbmVlZGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24ganNzVmVuZG9yUHJlZml4ZXIoKSB7XG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICB2YXIgYXRSdWxlID0gcnVsZTtcbiAgICAgIGF0UnVsZS5hdCA9IHN1cHBvcnRlZEtleWZyYW1lcyhhdFJ1bGUuYXQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWZpeFN0eWxlKHN0eWxlKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG5cbiAgICAgIGlmIChwcm9wID09PSAnZmFsbGJhY2tzJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBzdHlsZVtwcm9wXSA9IHZhbHVlLm1hcChwcmVmaXhTdHlsZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlUHJvcCA9IGZhbHNlO1xuICAgICAgdmFyIHN1cHBvcnRlZFByb3AgPSBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKTtcbiAgICAgIGlmIChzdXBwb3J0ZWRQcm9wICYmIHN1cHBvcnRlZFByb3AgIT09IHByb3ApIGNoYW5nZVByb3AgPSB0cnVlO1xuICAgICAgdmFyIGNoYW5nZVZhbHVlID0gZmFsc2U7XG4gICAgICB2YXIgc3VwcG9ydGVkVmFsdWUkMSA9IHN1cHBvcnRlZFZhbHVlKHN1cHBvcnRlZFByb3AsIHRvQ3NzVmFsdWUodmFsdWUpKTtcbiAgICAgIGlmIChzdXBwb3J0ZWRWYWx1ZSQxICYmIHN1cHBvcnRlZFZhbHVlJDEgIT09IHZhbHVlKSBjaGFuZ2VWYWx1ZSA9IHRydWU7XG5cbiAgICAgIGlmIChjaGFuZ2VQcm9wIHx8IGNoYW5nZVZhbHVlKSB7XG4gICAgICAgIGlmIChjaGFuZ2VQcm9wKSBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgICAgIHN0eWxlW3N1cHBvcnRlZFByb3AgfHwgcHJvcF0gPSBzdXBwb3J0ZWRWYWx1ZSQxIHx8IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuICAgIHJldHVybiBwcmVmaXhTdHlsZShzdHlsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZFZhbHVlKHByb3AsIHRvQ3NzVmFsdWUodmFsdWUpKSB8fCB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzUnVsZTogb25Qcm9jZXNzUnVsZSxcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBqc3NWZW5kb3JQcmVmaXhlcjtcbiIsImltcG9ydCBmdW5jdGlvbnMgZnJvbSAnanNzLXBsdWdpbi1ydWxlLXZhbHVlLWZ1bmN0aW9uJztcbmltcG9ydCBvYnNlcnZhYmxlIGZyb20gJ2pzcy1wbHVnaW4tcnVsZS12YWx1ZS1vYnNlcnZhYmxlJztcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICdqc3MtcGx1Z2luLXRlbXBsYXRlJztcbmltcG9ydCBnbG9iYWwgZnJvbSAnanNzLXBsdWdpbi1nbG9iYWwnO1xuaW1wb3J0IGV4dGVuZCBmcm9tICdqc3MtcGx1Z2luLWV4dGVuZCc7XG5pbXBvcnQgbmVzdGVkIGZyb20gJ2pzcy1wbHVnaW4tbmVzdGVkJztcbmltcG9ydCBjb21wb3NlIGZyb20gJ2pzcy1wbHVnaW4tY29tcG9zZSc7XG5pbXBvcnQgY2FtZWxDYXNlIGZyb20gJ2pzcy1wbHVnaW4tY2FtZWwtY2FzZSc7XG5pbXBvcnQgZGVmYXVsdFVuaXQgZnJvbSAnanNzLXBsdWdpbi1kZWZhdWx0LXVuaXQnO1xuaW1wb3J0IGV4cGFuZCBmcm9tICdqc3MtcGx1Z2luLWV4cGFuZCc7XG5pbXBvcnQgdmVuZG9yUHJlZml4ZXIgZnJvbSAnanNzLXBsdWdpbi12ZW5kb3ItcHJlZml4ZXInO1xuaW1wb3J0IHByb3BzU29ydCBmcm9tICdqc3MtcGx1Z2luLXByb3BzLXNvcnQnO1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGx1Z2luczogW2Z1bmN0aW9ucygpLCBvYnNlcnZhYmxlKG9wdGlvbnMub2JzZXJ2YWJsZSksIHRlbXBsYXRlKCksIGdsb2JhbCgpLCBleHRlbmQoKSwgbmVzdGVkKCksIGNvbXBvc2UoKSwgY2FtZWxDYXNlKCksIGRlZmF1bHRVbml0KG9wdGlvbnMuZGVmYXVsdFVuaXQpLCBleHBhbmQoKSwgdmVuZG9yUHJlZml4ZXIoKSwgcHJvcHNTb3J0KCldXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGU7XG4iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgaXNJbkJyb3dzZXIgZnJvbSAnaXMtaW4tYnJvd3Nlcic7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyc7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgX2Fzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQnO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnO1xuXG52YXIgcGxhaW5PYmplY3RDb25zdHJ1cmN0b3IgPSB7fS5jb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIGNsb25lU3R5bGUoc3R5bGUpIHtcbiAgaWYgKHN0eWxlID09IG51bGwgfHwgdHlwZW9mIHN0eWxlICE9PSAnb2JqZWN0JykgcmV0dXJuIHN0eWxlO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHJldHVybiBzdHlsZS5tYXAoY2xvbmVTdHlsZSk7XG4gIGlmIChzdHlsZS5jb25zdHJ1Y3RvciAhPT0gcGxhaW5PYmplY3RDb25zdHJ1cmN0b3IpIHJldHVybiBzdHlsZTtcbiAgdmFyIG5ld1N0eWxlID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZSkge1xuICAgIG5ld1N0eWxlW25hbWVdID0gY2xvbmVTdHlsZShzdHlsZVtuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3R5bGU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcnVsZSBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIG5hbWUgPSAndW5uYW1lZCc7XG4gIH1cblxuICB2YXIganNzID0gb3B0aW9ucy5qc3M7XG4gIHZhciBkZWNsQ29weSA9IGNsb25lU3R5bGUoZGVjbCk7XG4gIHZhciBydWxlID0ganNzLnBsdWdpbnMub25DcmVhdGVSdWxlKG5hbWUsIGRlY2xDb3B5LCBvcHRpb25zKTtcbiAgaWYgKHJ1bGUpIHJldHVybiBydWxlOyAvLyBJdCBpcyBhbiBhdC1ydWxlIGFuZCBpdCBoYXMgbm8gaW5zdGFuY2UuXG5cbiAgaWYgKG5hbWVbMF0gPT09ICdAJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gVW5rbm93biBydWxlIFwiICsgbmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGpvaW4gPSBmdW5jdGlvbiBqb2luKHZhbHVlLCBieSkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIFJlbW92ZSAhaW1wb3J0YW50IGZyb20gdGhlIHZhbHVlLCBpdCB3aWxsIGJlIHJlYWRkZWQgbGF0ZXIuXG4gICAgaWYgKHZhbHVlW2ldID09PSAnIWltcG9ydGFudCcpIGJyZWFrO1xuICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSBieTtcbiAgICByZXN1bHQgKz0gdmFsdWVbaV07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhcnJheSB2YWx1ZXMgdG8gc3RyaW5nLlxuICpcbiAqIGBtYXJnaW46IFtbJzVweCcsICcxMHB4J11dYCA+IGBtYXJnaW46IDVweCAxMHB4O2BcbiAqIGBib3JkZXI6IFsnMXB4JywgJzJweCddYCA+IGBib3JkZXI6IDFweCwgMnB4O2BcbiAqIGBtYXJnaW46IFtbJzVweCcsICcxMHB4J10sICchaW1wb3J0YW50J11gID4gYG1hcmdpbjogNXB4IDEwcHggIWltcG9ydGFudDtgXG4gKiBgY29sb3I6IFsncmVkJywgIWltcG9ydGFudF1gID4gYGNvbG9yOiByZWQgIWltcG9ydGFudDtgXG4gKi9cbnZhciB0b0Nzc1ZhbHVlID0gZnVuY3Rpb24gdG9Dc3NWYWx1ZSh2YWx1ZSwgaWdub3JlSW1wb3J0YW50KSB7XG4gIGlmIChpZ25vcmVJbXBvcnRhbnQgPT09IHZvaWQgMCkge1xuICAgIGlnbm9yZUltcG9ydGFudCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICB2YXIgY3NzVmFsdWUgPSAnJzsgLy8gU3VwcG9ydCBzcGFjZSBzZXBhcmF0ZWQgdmFsdWVzIHZpYSBgW1snNXB4JywgJzEwcHgnXV1gLlxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSA9PT0gJyFpbXBvcnRhbnQnKSBicmVhaztcbiAgICAgIGlmIChjc3NWYWx1ZSkgY3NzVmFsdWUgKz0gJywgJztcbiAgICAgIGNzc1ZhbHVlICs9IGpvaW4odmFsdWVbaV0sICcgJyk7XG4gICAgfVxuICB9IGVsc2UgY3NzVmFsdWUgPSBqb2luKHZhbHVlLCAnLCAnKTsgLy8gQWRkICFpbXBvcnRhbnQsIGJlY2F1c2UgaXQgd2FzIGlnbm9yZWQuXG5cblxuICBpZiAoIWlnbm9yZUltcG9ydGFudCAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJyFpbXBvcnRhbnQnKSB7XG4gICAgY3NzVmFsdWUgKz0gJyAhaW1wb3J0YW50JztcbiAgfVxuXG4gIHJldHVybiBjc3NWYWx1ZTtcbn07XG5cbi8qKlxuICogSW5kZW50IGEgc3RyaW5nLlxuICogaHR0cDovL2pzcGVyZi5jb20vYXJyYXktam9pbi12cy1mb3JcbiAqL1xuZnVuY3Rpb24gaW5kZW50U3RyKHN0ciwgaW5kZW50KSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaW5kZW50OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ICs9ICcgICc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICsgc3RyO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFJ1bGUgdG8gQ1NTIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQ3NzKHNlbGVjdG9yLCBzdHlsZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAoIXN0eWxlKSByZXR1cm4gcmVzdWx0O1xuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkaW5kZW50ID0gX29wdGlvbnMuaW5kZW50LFxuICAgICAgaW5kZW50ID0gX29wdGlvbnMkaW5kZW50ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkaW5kZW50O1xuICB2YXIgZmFsbGJhY2tzID0gc3R5bGUuZmFsbGJhY2tzO1xuICBpZiAoc2VsZWN0b3IpIGluZGVudCsrOyAvLyBBcHBseSBmYWxsYmFja3MgZmlyc3QuXG5cbiAgaWYgKGZhbGxiYWNrcykge1xuICAgIC8vIEFycmF5IHN5bnRheCB7ZmFsbGJhY2tzOiBbe3Byb3A6IHZhbHVlfV19XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmFsbGJhY2tzKSkge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGZhbGxiYWNrcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGZhbGxiYWNrID0gZmFsbGJhY2tzW2luZGV4XTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGZhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZmFsbGJhY2tbcHJvcF07XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGluZGVudFN0cihwcm9wICsgXCI6IFwiICsgdG9Dc3NWYWx1ZSh2YWx1ZSkgKyBcIjtcIiwgaW5kZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2JqZWN0IHN5bnRheCB7ZmFsbGJhY2tzOiB7cHJvcDogdmFsdWV9fVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gZmFsbGJhY2tzKSB7XG4gICAgICAgIHZhciBfdmFsdWUgPSBmYWxsYmFja3NbX3Byb3BdO1xuXG4gICAgICAgIGlmIChfdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICByZXN1bHQgKz0gaW5kZW50U3RyKF9wcm9wICsgXCI6IFwiICsgdG9Dc3NWYWx1ZShfdmFsdWUpICsgXCI7XCIsIGluZGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcDIgaW4gc3R5bGUpIHtcbiAgICB2YXIgX3ZhbHVlMiA9IHN0eWxlW19wcm9wMl07XG5cbiAgICBpZiAoX3ZhbHVlMiAhPSBudWxsICYmIF9wcm9wMiAhPT0gJ2ZhbGxiYWNrcycpIHtcbiAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSAnXFxuJztcbiAgICAgIHJlc3VsdCArPSBpbmRlbnRTdHIoX3Byb3AyICsgXCI6IFwiICsgdG9Dc3NWYWx1ZShfdmFsdWUyKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgIH1cbiAgfSAvLyBBbGxvdyBlbXB0eSBzdHlsZSBpbiB0aGlzIGNhc2UsIGJlY2F1c2UgcHJvcGVydGllcyB3aWxsIGJlIGFkZGVkIGR5bmFtaWNhbGx5LlxuXG5cbiAgaWYgKCFyZXN1bHQgJiYgIW9wdGlvbnMuYWxsb3dFbXB0eSkgcmV0dXJuIHJlc3VsdDsgLy8gV2hlbiBydWxlIGlzIGJlaW5nIHN0cmluZ2lmaWVkIGJlZm9yZSBzZWxlY3RvciB3YXMgZGVmaW5lZC5cblxuICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gcmVzdWx0O1xuICBpbmRlbnQtLTtcbiAgaWYgKHJlc3VsdCkgcmVzdWx0ID0gXCJcXG5cIiArIHJlc3VsdCArIFwiXFxuXCI7XG4gIHJldHVybiBpbmRlbnRTdHIoc2VsZWN0b3IgKyBcIiB7XCIgKyByZXN1bHQsIGluZGVudCkgKyBpbmRlbnRTdHIoJ30nLCBpbmRlbnQpO1xufVxuXG52YXIgZXNjYXBlUmVnZXggPSAvKFtbXFxdLiMqJD48K349fF46KCksXCInYFxcc10pL2c7XG52YXIgbmF0aXZlRXNjYXBlID0gdHlwZW9mIENTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgQ1NTLmVzY2FwZTtcbnZhciBlc2NhcGUgPSAoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gbmF0aXZlRXNjYXBlID8gbmF0aXZlRXNjYXBlKHN0cikgOiBzdHIucmVwbGFjZShlc2NhcGVSZWdleCwgJ1xcXFwkMScpO1xufSk7XG5cbnZhciBCYXNlU3R5bGVSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZVN0eWxlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ3N0eWxlJztcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLnJlbmRlcmVyID0gdm9pZCAwO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdmFyIHNoZWV0ID0gb3B0aW9ucy5zaGVldCxcbiAgICAgICAgUmVuZGVyZXIgPSBvcHRpb25zLlJlbmRlcmVyO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIGlmIChzaGVldCkgdGhpcy5yZW5kZXJlciA9IHNoZWV0LnJlbmRlcmVyO2Vsc2UgaWYgKFJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgYSBzdHlsZSBwcm9wZXJ0eS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gQmFzZVN0eWxlUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnByb3AgPSBmdW5jdGlvbiBwcm9wKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgLy8gSXQncyBhIGdldHRlci5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuc3R5bGVbbmFtZV07IC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoZSB2YWx1ZSBoYXMgbm90IGNoYW5nZWQuXG5cbiAgICB2YXIgZm9yY2UgPSBvcHRpb25zID8gb3B0aW9ucy5mb3JjZSA6IGZhbHNlO1xuICAgIGlmICghZm9yY2UgJiYgdGhpcy5zdHlsZVtuYW1lXSA9PT0gdmFsdWUpIHJldHVybiB0aGlzO1xuICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMucHJvY2VzcyAhPT0gZmFsc2UpIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uQ2hhbmdlVmFsdWUodmFsdWUsIG5hbWUsIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBpc0VtcHR5ID0gbmV3VmFsdWUgPT0gbnVsbCB8fCBuZXdWYWx1ZSA9PT0gZmFsc2U7XG4gICAgdmFyIGlzRGVmaW5lZCA9IG5hbWUgaW4gdGhpcy5zdHlsZTsgLy8gVmFsdWUgaXMgZW1wdHkgYW5kIHdhc24ndCBkZWZpbmVkIGJlZm9yZS5cblxuICAgIGlmIChpc0VtcHR5ICYmICFpc0RlZmluZWQgJiYgIWZvcmNlKSByZXR1cm4gdGhpczsgLy8gV2UgYXJlIGdvaW5nIHRvIHJlbW92ZSB0aGlzIHZhbHVlLlxuXG4gICAgdmFyIHJlbW92ZSA9IGlzRW1wdHkgJiYgaXNEZWZpbmVkO1xuICAgIGlmIChyZW1vdmUpIGRlbGV0ZSB0aGlzLnN0eWxlW25hbWVdO2Vsc2UgdGhpcy5zdHlsZVtuYW1lXSA9IG5ld1ZhbHVlOyAvLyBSZW5kZXJhYmxlIGlzIGRlZmluZWQgaWYgU3R5bGVTaGVldCBvcHRpb24gYGxpbmtgIGlzIHRydWUuXG5cbiAgICBpZiAodGhpcy5yZW5kZXJhYmxlICYmIHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIGlmIChyZW1vdmUpIHRoaXMucmVuZGVyZXIucmVtb3ZlUHJvcGVydHkodGhpcy5yZW5kZXJhYmxlLCBuYW1lKTtlbHNlIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5yZW5kZXJhYmxlLCBuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBpZiAoc2hlZXQgJiYgc2hlZXQuYXR0YWNoZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdbSlNTXSBSdWxlIGlzIG5vdCBsaW5rZWQuIE1pc3Npbmcgc2hlZXQgb3B0aW9uIFwibGluazogdHJ1ZVwiLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBCYXNlU3R5bGVSdWxlO1xufSgpO1xudmFyIFN0eWxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2VTdHlsZVJ1bGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3R5bGVSdWxlLCBfQmFzZVN0eWxlUnVsZSk7XG5cbiAgZnVuY3Rpb24gU3R5bGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlU3R5bGVSdWxlLmNhbGwodGhpcywga2V5LCBzdHlsZSwgb3B0aW9ucykgfHwgdGhpcztcbiAgICBfdGhpcy5zZWxlY3RvclRleHQgPSB2b2lkIDA7XG4gICAgX3RoaXMuaWQgPSB2b2lkIDA7XG4gICAgX3RoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB2YXIgc2VsZWN0b3IgPSBvcHRpb25zLnNlbGVjdG9yLFxuICAgICAgICBzY29wZWQgPSBvcHRpb25zLnNjb3BlZCxcbiAgICAgICAgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBnZW5lcmF0ZUlkID0gb3B0aW9ucy5nZW5lcmF0ZUlkO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBfdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcbiAgICB9IGVsc2UgaWYgKHNjb3BlZCAhPT0gZmFsc2UpIHtcbiAgICAgIF90aGlzLmlkID0gZ2VuZXJhdGVJZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgc2hlZXQpO1xuICAgICAgX3RoaXMuc2VsZWN0b3JUZXh0ID0gXCIuXCIgKyBlc2NhcGUoX3RoaXMuaWQpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0IHNlbGVjdG9yIHN0cmluZy5cbiAgICogQXR0ZW50aW9uOiB1c2UgdGhpcyB3aXRoIGNhdXRpb24uIE1vc3QgYnJvd3NlcnMgZGlkbid0IGltcGxlbWVudFxuICAgKiBzZWxlY3RvclRleHQgc2V0dGVyLCBzbyB0aGlzIG1heSByZXN1bHQgaW4gcmVyZW5kZXJpbmcgb2YgZW50aXJlIFN0eWxlIFNoZWV0LlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8yID0gU3R5bGVSdWxlLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQXBwbHkgcnVsZSB0byBhbiBlbGVtZW50IGlubGluZS5cbiAgICovXG4gIF9wcm90bzIuYXBwbHlUbyA9IGZ1bmN0aW9uIGFwcGx5VG8ocmVuZGVyYWJsZSkge1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG5cbiAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgIHZhciBqc29uID0gdGhpcy50b0pTT04oKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBqc29uKSB7XG4gICAgICAgIHJlbmRlcmVyLnNldFByb3BlcnR5KHJlbmRlcmFibGUsIHByb3AsIGpzb25bcHJvcF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bGUuXG4gICAqIEZhbGxiYWNrcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICogVXNlZnVsIGZvciBpbmxpbmUgc3R5bGVzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzIudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHZhciBqc29uID0ge307XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3R5bGVbcHJvcF07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykganNvbltwcm9wXSA9IHZhbHVlO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSBqc29uW3Byb3BdID0gdG9Dc3NWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG4gICAgdmFyIGxpbmsgPSBzaGVldCA/IHNoZWV0Lm9wdGlvbnMubGluayA6IGZhbHNlO1xuICAgIHZhciBvcHRzID0gbGluayA/IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBhbGxvd0VtcHR5OiB0cnVlXG4gICAgfSkgOiBvcHRpb25zO1xuICAgIHJldHVybiB0b0Nzcyh0aGlzLnNlbGVjdG9yVGV4dCwgdGhpcy5zdHlsZSwgb3B0cyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFN0eWxlUnVsZSwgW3tcbiAgICBrZXk6IFwic2VsZWN0b3JcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzZWxlY3Rvcikge1xuICAgICAgaWYgKHNlbGVjdG9yID09PSB0aGlzLnNlbGVjdG9yVGV4dCkgcmV0dXJuO1xuICAgICAgdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgcmVuZGVyYWJsZSA9IHRoaXMucmVuZGVyYWJsZTtcbiAgICAgIGlmICghcmVuZGVyYWJsZSB8fCAhcmVuZGVyZXIpIHJldHVybjtcbiAgICAgIHZhciBoYXNDaGFuZ2VkID0gcmVuZGVyZXIuc2V0U2VsZWN0b3IocmVuZGVyYWJsZSwgc2VsZWN0b3IpOyAvLyBJZiBzZWxlY3RvciBzZXR0ZXIgaXMgbm90IGltcGxlbWVudGVkLCByZXJlbmRlciB0aGUgcnVsZS5cblxuICAgICAgaWYgKCFoYXNDaGFuZ2VkKSB7XG4gICAgICAgIHJlbmRlcmVyLnJlcGxhY2VSdWxlKHJlbmRlcmFibGUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc2VsZWN0b3Igc3RyaW5nLlxuICAgICAqL1xuICAgICxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9yVGV4dDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3R5bGVSdWxlO1xufShCYXNlU3R5bGVSdWxlKTtcbnZhciBwbHVnaW5TdHlsZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKG5hbWVbMF0gPT09ICdAJyB8fCBvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdHlsZVJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyA9IHtcbiAgaW5kZW50OiAxLFxuICBjaGlsZHJlbjogdHJ1ZVxufTtcbnZhciBhdFJlZ0V4cCA9IC9AKFtcXHctXSspLztcbi8qKlxuICogQ29uZGl0aW9uYWwgcnVsZSBmb3IgQG1lZGlhLCBAc3VwcG9ydHNcbiAqL1xuXG52YXIgQ29uZGl0aW9uYWxSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29uZGl0aW9uYWxSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2NvbmRpdGlvbmFsJztcbiAgICB0aGlzLmF0ID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMucXVlcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5ydWxlcyA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB2YXIgYXRNYXRjaCA9IGtleS5tYXRjaChhdFJlZ0V4cCk7XG4gICAgdGhpcy5hdCA9IGF0TWF0Y2ggPyBhdE1hdGNoWzFdIDogJ3Vua25vd24nOyAvLyBLZXkgbWlnaHQgY29udGFpbiBhIHVuaXF1ZSBzdWZmaXggaW4gY2FzZSB0aGUgYG5hbWVgIHBhc3NlZCBieSB1c2VyIHdhcyBkdXBsaWNhdGUuXG5cbiAgICB0aGlzLnF1ZXJ5ID0gb3B0aW9ucy5uYW1lIHx8IFwiQFwiICsgdGhpcy5hdDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZXNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBDb25kaXRpb25hbFJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRSdWxlID0gZnVuY3Rpb24gZ2V0UnVsZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuaW5kZXhPZihydWxlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLCBydW4gcGx1Z2lucy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBudWxsO1xuICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnQgPT0gbnVsbCkgb3B0aW9ucy5pbmRlbnQgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zLmluZGVudDtcbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PSBudWxsKSBvcHRpb25zLmNoaWxkcmVuID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucy5jaGlsZHJlbjtcblxuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMucXVlcnkgKyBcIiB7fVwiO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNoaWxkcmVuID8gdGhpcy5xdWVyeSArIFwiIHtcXG5cIiArIGNoaWxkcmVuICsgXCJcXG59XCIgOiAnJztcbiAgfTtcblxuICByZXR1cm4gQ29uZGl0aW9uYWxSdWxlO1xufSgpO1xudmFyIGtleVJlZ0V4cCA9IC9AbWVkaWF8QHN1cHBvcnRzXFxzKy87XG52YXIgcGx1Z2luQ29uZGl0aW9uYWxSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBrZXlSZWdFeHAudGVzdChrZXkpID8gbmV3IENvbmRpdGlvbmFsUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxID0ge1xuICBpbmRlbnQ6IDEsXG4gIGNoaWxkcmVuOiB0cnVlXG59O1xudmFyIG5hbWVSZWdFeHAgPSAvQGtleWZyYW1lc1xccysoW1xcdy1dKykvO1xuLyoqXG4gKiBSdWxlIGZvciBAa2V5ZnJhbWVzXG4gKi9cblxudmFyIEtleWZyYW1lc1J1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBLZXlmcmFtZXNSdWxlKGtleSwgZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2tleWZyYW1lcyc7XG4gICAgdGhpcy5hdCA9ICdAa2V5ZnJhbWVzJztcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLnJ1bGVzID0gdm9pZCAwO1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdm9pZCAwO1xuICAgIHZhciBuYW1lTWF0Y2ggPSBrZXkubWF0Y2gobmFtZVJlZ0V4cCk7XG5cbiAgICBpZiAobmFtZU1hdGNoICYmIG5hbWVNYXRjaFsxXSkge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZU1hdGNoWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5hbWUgPSAnbm9uYW1lJztcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gQmFkIGtleWZyYW1lcyBuYW1lIFwiICsga2V5KSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB0aGlzLmtleSA9IHRoaXMudHlwZSArIFwiLVwiICsgdGhpcy5uYW1lO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIHNjb3BlZCA9IG9wdGlvbnMuc2NvcGVkLFxuICAgICAgICBzaGVldCA9IG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBvcHRpb25zLmdlbmVyYXRlSWQ7XG4gICAgdGhpcy5pZCA9IHNjb3BlZCA9PT0gZmFsc2UgPyB0aGlzLm5hbWUgOiBlc2NhcGUoZ2VuZXJhdGVJZCh0aGlzLCBzaGVldCkpO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gZnJhbWVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBmcmFtZXNbbmFtZV0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBLZXlmcmFtZXNSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMkMTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnQgPT0gbnVsbCkgb3B0aW9ucy5pbmRlbnQgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEuaW5kZW50O1xuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09IG51bGwpIG9wdGlvbnMuY2hpbGRyZW4gPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEuY2hpbGRyZW47XG5cbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0ICsgXCIgXCIgKyB0aGlzLmlkICsgXCIge31cIjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIGlmIChjaGlsZHJlbikgY2hpbGRyZW4gPSBcIlxcblwiICsgY2hpbGRyZW4gKyBcIlxcblwiO1xuICAgIHJldHVybiB0aGlzLmF0ICsgXCIgXCIgKyB0aGlzLmlkICsgXCIge1wiICsgY2hpbGRyZW4gKyBcIn1cIjtcbiAgfTtcblxuICByZXR1cm4gS2V5ZnJhbWVzUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAkMSA9IC9Aa2V5ZnJhbWVzXFxzKy87XG52YXIgcmVmUmVnRXhwID0gL1xcJChbXFx3LV0rKS9nO1xuXG52YXIgZmluZFJlZmVyZW5jZWRLZXlmcmFtZSA9IGZ1bmN0aW9uIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBrZXlmcmFtZXMpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKHJlZlJlZ0V4cCwgZnVuY3Rpb24gKG1hdGNoLCBuYW1lKSB7XG4gICAgICBpZiAobmFtZSBpbiBrZXlmcmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIGtleWZyYW1lc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBSZWZlcmVuY2VkIGtleWZyYW1lcyBydWxlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQuXCIpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG4vKipcbiAqIFJlcGxhY2UgdGhlIHJlZmVyZW5jZSBmb3IgYSBhbmltYXRpb24gbmFtZS5cbiAqL1xuXG5cbnZhciByZXBsYWNlUmVmID0gZnVuY3Rpb24gcmVwbGFjZVJlZihzdHlsZSwgcHJvcCwga2V5ZnJhbWVzKSB7XG4gIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuICB2YXIgcmVmS2V5ZnJhbWUgPSBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbHVlLCBrZXlmcmFtZXMpO1xuXG4gIGlmIChyZWZLZXlmcmFtZSAhPT0gdmFsdWUpIHtcbiAgICBzdHlsZVtwcm9wXSA9IHJlZktleWZyYW1lO1xuICB9XG59O1xuXG52YXIgcGx1Z2luID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIGZyYW1lcywgb3B0aW9ucykge1xuICAgIHJldHVybiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXlSZWdFeHAkMS50ZXN0KGtleSkgPyBuZXcgS2V5ZnJhbWVzUnVsZShrZXksIGZyYW1lcywgb3B0aW9ucykgOiBudWxsO1xuICB9LFxuICAvLyBBbmltYXRpb24gbmFtZSByZWYgcmVwbGFjZXIuXG4gIG9uUHJvY2Vzc1N0eWxlOiBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSwgc2hlZXQpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnIHx8ICFzaGVldCkgcmV0dXJuIHN0eWxlO1xuICAgIGlmICgnYW5pbWF0aW9uLW5hbWUnIGluIHN0eWxlKSByZXBsYWNlUmVmKHN0eWxlLCAnYW5pbWF0aW9uLW5hbWUnLCBzaGVldC5rZXlmcmFtZXMpO1xuICAgIGlmICgnYW5pbWF0aW9uJyBpbiBzdHlsZSkgcmVwbGFjZVJlZihzdHlsZSwgJ2FuaW1hdGlvbicsIHNoZWV0LmtleWZyYW1lcyk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuICBvbkNoYW5nZVZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbCwgcHJvcCwgcnVsZSkge1xuICAgIHZhciBzaGVldCA9IHJ1bGUub3B0aW9ucy5zaGVldDtcblxuICAgIGlmICghc2hlZXQpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICBjYXNlICdhbmltYXRpb24nOlxuICAgICAgICByZXR1cm4gZmluZFJlZmVyZW5jZWRLZXlmcmFtZSh2YWwsIHNoZWV0LmtleWZyYW1lcyk7XG5cbiAgICAgIGNhc2UgJ2FuaW1hdGlvbi1uYW1lJzpcbiAgICAgICAgcmV0dXJuIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBzaGVldC5rZXlmcmFtZXMpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIEtleWZyYW1lUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2VTdHlsZVJ1bGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoS2V5ZnJhbWVSdWxlLCBfQmFzZVN0eWxlUnVsZSk7XG5cbiAgZnVuY3Rpb24gS2V5ZnJhbWVSdWxlKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9CYXNlU3R5bGVSdWxlLmNhbGwuYXBwbHkoX0Jhc2VTdHlsZVJ1bGUsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gS2V5ZnJhbWVSdWxlLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG4gICAgdmFyIGxpbmsgPSBzaGVldCA/IHNoZWV0Lm9wdGlvbnMubGluayA6IGZhbHNlO1xuICAgIHZhciBvcHRzID0gbGluayA/IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBhbGxvd0VtcHR5OiB0cnVlXG4gICAgfSkgOiBvcHRpb25zO1xuICAgIHJldHVybiB0b0Nzcyh0aGlzLmtleSwgdGhpcy5zdHlsZSwgb3B0cyk7XG4gIH07XG5cbiAgcmV0dXJuIEtleWZyYW1lUnVsZTtcbn0oQmFzZVN0eWxlUnVsZSk7XG52YXIgcGx1Z2luS2V5ZnJhbWVSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucGFyZW50ICYmIG9wdGlvbnMucGFyZW50LnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICByZXR1cm4gbmV3IEtleWZyYW1lUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxudmFyIEZvbnRGYWNlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZvbnRGYWNlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2ZvbnQtZmFjZSc7XG4gICAgdGhpcy5hdCA9ICdAZm9udC1mYWNlJztcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBGb250RmFjZVJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnN0eWxlKSkge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5zdHlsZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3RyICs9IHRvQ3NzKHRoaXMuYXQsIHRoaXMuc3R5bGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVbaW5kZXggKyAxXSkgc3RyICs9ICdcXG4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiB0b0Nzcyh0aGlzLmF0LCB0aGlzLnN0eWxlLCBvcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gRm9udEZhY2VSdWxlO1xufSgpO1xudmFyIGtleVJlZ0V4cCQyID0gL0Bmb250LWZhY2UvO1xudmFyIHBsdWdpbkZvbnRGYWNlUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBrZXlSZWdFeHAkMi50ZXN0KGtleSkgPyBuZXcgRm9udEZhY2VSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIDogbnVsbDtcbiAgfVxufTtcblxudmFyIFZpZXdwb3J0UnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZpZXdwb3J0UnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ3ZpZXdwb3J0JztcbiAgICB0aGlzLmF0ID0gJ0B2aWV3cG9ydCc7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gVmlld3BvcnRSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRvQ3NzKHRoaXMua2V5LCB0aGlzLnN0eWxlLCBvcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gVmlld3BvcnRSdWxlO1xufSgpO1xudmFyIHBsdWdpblZpZXdwb3J0UnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBrZXkgPT09ICdAdmlld3BvcnQnIHx8IGtleSA9PT0gJ0AtbXMtdmlld3BvcnQnID8gbmV3IFZpZXdwb3J0UnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBTaW1wbGVSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2ltcGxlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ3NpbXBsZSc7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG5cbiAgdmFyIF9wcm90byA9IFNpbXBsZVJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy52YWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3RyICs9IHRoaXMua2V5ICsgXCIgXCIgKyB0aGlzLnZhbHVlW2luZGV4XSArIFwiO1wiO1xuICAgICAgICBpZiAodGhpcy52YWx1ZVtpbmRleCArIDFdKSBzdHIgKz0gJ1xcbic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMua2V5ICsgXCIgXCIgKyB0aGlzLnZhbHVlICsgXCI7XCI7XG4gIH07XG5cbiAgcmV0dXJuIFNpbXBsZVJ1bGU7XG59KCk7XG52YXIga2V5c01hcCA9IHtcbiAgJ0BjaGFyc2V0JzogdHJ1ZSxcbiAgJ0BpbXBvcnQnOiB0cnVlLFxuICAnQG5hbWVzcGFjZSc6IHRydWVcbn07XG52YXIgcGx1Z2luU2ltcGxlUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBrZXkgaW4ga2V5c01hcCA/IG5ldyBTaW1wbGVSdWxlKGtleSwgdmFsdWUsIG9wdGlvbnMpIDogbnVsbDtcbiAgfVxufTtcblxudmFyIHBsdWdpbnMgPSBbcGx1Z2luU3R5bGVSdWxlLCBwbHVnaW5Db25kaXRpb25hbFJ1bGUsIHBsdWdpbiwgcGx1Z2luS2V5ZnJhbWVSdWxlLCBwbHVnaW5Gb250RmFjZVJ1bGUsIHBsdWdpblZpZXdwb3J0UnVsZSwgcGx1Z2luU2ltcGxlUnVsZV07XG5cbnZhciBkZWZhdWx0VXBkYXRlT3B0aW9ucyA9IHtcbiAgcHJvY2VzczogdHJ1ZVxufTtcbnZhciBmb3JjZVVwZGF0ZU9wdGlvbnMgPSB7XG4gIGZvcmNlOiB0cnVlLFxuICBwcm9jZXNzOiB0cnVlXG4gIC8qKlxuICAgKiBDb250YWlucyBydWxlcyBvYmplY3RzIGFuZCBhbGxvd3MgYWRkaW5nL3JlbW92aW5nIGV0Yy5cbiAgICogSXMgdXNlZCBmb3IgZS5nLiBieSBgU3R5bGVTaGVldGAgb3IgYENvbmRpdGlvbmFsUnVsZWAuXG4gICAqL1xuXG59O1xuXG52YXIgUnVsZUxpc3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvLyBSdWxlcyByZWdpc3RyeSBmb3IgYWNjZXNzIGJ5IC5nZXQoKSBtZXRob2QuXG4gIC8vIEl0IGNvbnRhaW5zIHRoZSBzYW1lIHJ1bGUgcmVnaXN0ZXJlZCBieSBuYW1lIGFuZCBieSBzZWxlY3Rvci5cbiAgLy8gT3JpZ2luYWwgc3R5bGVzIG9iamVjdC5cbiAgLy8gVXNlZCB0byBlbnN1cmUgY29ycmVjdCBydWxlcyBvcmRlci5cbiAgZnVuY3Rpb24gUnVsZUxpc3Qob3B0aW9ucykge1xuICAgIHRoaXMubWFwID0ge307XG4gICAgdGhpcy5yYXcgPSB7fTtcbiAgICB0aGlzLmluZGV4ID0gW107XG4gICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGFzc2VzID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ZnJhbWVzID0gdm9pZCAwO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jbGFzc2VzID0gb3B0aW9ucy5jbGFzc2VzO1xuICAgIHRoaXMua2V5ZnJhbWVzID0gb3B0aW9ucy5rZXlmcmFtZXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgcmVnaXN0ZXIgcnVsZS5cbiAgICpcbiAgICogV2lsbCBub3QgcmVuZGVyIGFmdGVyIFN0eWxlIFNoZWV0IHdhcyByZW5kZXJlZCB0aGUgZmlyc3QgdGltZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gUnVsZUxpc3QucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQobmFtZSwgZGVjbCwgcnVsZU9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMkb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcGFyZW50ID0gX3RoaXMkb3B0aW9ucy5wYXJlbnQsXG4gICAgICAgIHNoZWV0ID0gX3RoaXMkb3B0aW9ucy5zaGVldCxcbiAgICAgICAganNzID0gX3RoaXMkb3B0aW9ucy5qc3MsXG4gICAgICAgIFJlbmRlcmVyID0gX3RoaXMkb3B0aW9ucy5SZW5kZXJlcixcbiAgICAgICAgZ2VuZXJhdGVJZCA9IF90aGlzJG9wdGlvbnMuZ2VuZXJhdGVJZCxcbiAgICAgICAgc2NvcGVkID0gX3RoaXMkb3B0aW9ucy5zY29wZWQ7XG5cbiAgICB2YXIgb3B0aW9ucyA9IF9leHRlbmRzKHtcbiAgICAgIGNsYXNzZXM6IHRoaXMuY2xhc3NlcyxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgc2hlZXQ6IHNoZWV0LFxuICAgICAganNzOiBqc3MsXG4gICAgICBSZW5kZXJlcjogUmVuZGVyZXIsXG4gICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkLFxuICAgICAgc2NvcGVkOiBzY29wZWQsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAga2V5ZnJhbWVzOiB0aGlzLmtleWZyYW1lcyxcbiAgICAgIHNlbGVjdG9yOiB1bmRlZmluZWRcbiAgICB9LCBydWxlT3B0aW9ucyk7IC8vIFdoZW4gdXNlciB1c2VzIC5jcmVhdGVTdHlsZVNoZWV0KCksIGR1cGxpY2F0ZSBuYW1lcyBhcmUgbm90IHBvc3NpYmxlLCBidXRcbiAgICAvLyBgc2hlZXQuYWRkUnVsZSgpYCBvcGVucyB0aGUgZG9vciBmb3IgYW55IGR1cGxpY2F0ZSBydWxlIG5hbWUuIFdoZW4gdGhpcyBoYXBwZW5zXG4gICAgLy8gd2UgbmVlZCB0byBtYWtlIHRoZSBrZXkgdW5pcXVlIHdpdGhpbiB0aGlzIFJ1bGVMaXN0IGluc3RhbmNlIHNjb3BlLlxuXG5cbiAgICB2YXIga2V5ID0gbmFtZTtcblxuICAgIGlmIChuYW1lIGluIHRoaXMucmF3KSB7XG4gICAgICBrZXkgPSBuYW1lICsgXCItZFwiICsgdGhpcy5jb3VudGVyKys7XG4gICAgfSAvLyBXZSBuZWVkIHRvIHNhdmUgdGhlIG9yaWdpbmFsIGRlY2wgYmVmb3JlIGNyZWF0aW5nIHRoZSBydWxlXG4gICAgLy8gYmVjYXVzZSBjYWNoZSBwbHVnaW4gbmVlZHMgdG8gdXNlIGl0IGFzIGEga2V5IHRvIHJldHVybiBhIGNhY2hlZCBydWxlLlxuXG5cbiAgICB0aGlzLnJhd1trZXldID0gZGVjbDtcblxuICAgIGlmIChrZXkgaW4gdGhpcy5jbGFzc2VzKSB7XG4gICAgICAvLyBFLmcuIHJ1bGVzIGluc2lkZSBvZiBAbWVkaWEgY29udGFpbmVyXG4gICAgICBvcHRpb25zLnNlbGVjdG9yID0gXCIuXCIgKyBlc2NhcGUodGhpcy5jbGFzc2VzW2tleV0pO1xuICAgIH1cblxuICAgIHZhciBydWxlID0gY3JlYXRlUnVsZShrZXksIGRlY2wsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5yZWdpc3RlcihydWxlKTtcbiAgICB2YXIgaW5kZXggPSBvcHRpb25zLmluZGV4ID09PSB1bmRlZmluZWQgPyB0aGlzLmluZGV4Lmxlbmd0aCA6IG9wdGlvbnMuaW5kZXg7XG4gICAgdGhpcy5pbmRleC5zcGxpY2UoaW5kZXgsIDAsIHJ1bGUpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcFtuYW1lXTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHJ1bGUpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXIocnVsZSk7XG4gICAgZGVsZXRlIHRoaXMucmF3W3J1bGUua2V5XTtcbiAgICB0aGlzLmluZGV4LnNwbGljZSh0aGlzLmluZGV4LmluZGV4T2YocnVsZSksIDEpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXguaW5kZXhPZihydWxlKTtcbiAgfVxuICAvKipcbiAgICogUnVuIGBvblByb2Nlc3NSdWxlKClgIHBsdWdpbnMgb24gZXZlcnkgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgdmFyIHBsdWdpbnMgPSB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnM7IC8vIFdlIG5lZWQgdG8gY2xvbmUgYXJyYXkgYmVjYXVzZSBpZiB3ZSBtb2RpZnkgdGhlIGluZGV4IHNvbWV3aGVyZSBlbHNlIGR1cmluZyBhIGxvb3BcbiAgICAvLyB3ZSBlbmQgdXAgd2l0aCB2ZXJ5IGhhcmQtdG8tdHJhY2stZG93biBzaWRlIGVmZmVjdHMuXG5cbiAgICB0aGlzLmluZGV4LnNsaWNlKDApLmZvckVhY2gocGx1Z2lucy5vblByb2Nlc3NSdWxlLCBwbHVnaW5zKTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBydWxlIGluIGAubWFwYCwgYC5jbGFzc2VzYCBhbmQgYC5rZXlmcmFtZXNgIG1hcHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIocnVsZSkge1xuICAgIHRoaXMubWFwW3J1bGUua2V5XSA9IHJ1bGU7XG5cbiAgICBpZiAocnVsZSBpbnN0YW5jZW9mIFN0eWxlUnVsZSkge1xuICAgICAgdGhpcy5tYXBbcnVsZS5zZWxlY3Rvcl0gPSBydWxlO1xuICAgICAgaWYgKHJ1bGUuaWQpIHRoaXMuY2xhc3Nlc1tydWxlLmtleV0gPSBydWxlLmlkO1xuICAgIH0gZWxzZSBpZiAocnVsZSBpbnN0YW5jZW9mIEtleWZyYW1lc1J1bGUgJiYgdGhpcy5rZXlmcmFtZXMpIHtcbiAgICAgIHRoaXMua2V5ZnJhbWVzW3J1bGUubmFtZV0gPSBydWxlLmlkO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVW5yZWdpc3RlciBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyKHJ1bGUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbcnVsZS5rZXldO1xuXG4gICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBTdHlsZVJ1bGUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm1hcFtydWxlLnNlbGVjdG9yXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNsYXNzZXNbcnVsZS5rZXldO1xuICAgIH0gZWxzZSBpZiAocnVsZSBpbnN0YW5jZW9mIEtleWZyYW1lc1J1bGUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmtleWZyYW1lc1tydWxlLm5hbWVdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBmdW5jdGlvbiB2YWx1ZXMgd2l0aCBhIG5ldyBkYXRhLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIGRhdGE7XG4gICAgdmFyIG9wdGlvbnM7XG5cbiAgICBpZiAodHlwZW9mIChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTsgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLXR1cGxlLWluZGV4XVxuXG4gICAgICBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdOyAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtdHVwbGUtaW5kZXhdXG5cbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07IC8vICRGbG93Rml4TWVbaW52YWxpZC10dXBsZS1pbmRleF1cblxuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXTtcbiAgICAgIG5hbWUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB0aGlzLnVwZGF0ZU9uZSh0aGlzLm1hcFtuYW1lXSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmluZGV4Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB0aGlzLnVwZGF0ZU9uZSh0aGlzLmluZGV4W2luZGV4XSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlIHBsdWdpbnMsIHVwZGF0ZSBydWxlIHByb3BzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUocnVsZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VXBkYXRlT3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkb3B0aW9uczIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHBsdWdpbnMgPSBfdGhpcyRvcHRpb25zMi5qc3MucGx1Z2lucyxcbiAgICAgICAgc2hlZXQgPSBfdGhpcyRvcHRpb25zMi5zaGVldDsgLy8gSXQgaXMgYSBydWxlcyBjb250YWluZXIgbGlrZSBmb3IgZS5nLiBDb25kaXRpb25hbFJ1bGUuXG5cbiAgICBpZiAocnVsZS5ydWxlcyBpbnN0YW5jZW9mIFJ1bGVMaXN0KSB7XG4gICAgICBydWxlLnJ1bGVzLnVwZGF0ZShkYXRhLCBvcHRpb25zKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVSdWxlID0gcnVsZTtcbiAgICB2YXIgc3R5bGUgPSBzdHlsZVJ1bGUuc3R5bGU7XG4gICAgcGx1Z2lucy5vblVwZGF0ZShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucyk7IC8vIFdlIHJlbHkgb24gYSBuZXcgYHN0eWxlYCByZWYgaW4gY2FzZSBpdCB3YXMgbXV0YXRlZCBkdXJpbmcgb25VcGRhdGUgaG9vay5cblxuICAgIGlmIChvcHRpb25zLnByb2Nlc3MgJiYgc3R5bGUgJiYgc3R5bGUgIT09IHN0eWxlUnVsZS5zdHlsZSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBydW4gdGhlIHBsdWdpbnMgaW4gY2FzZSBuZXcgYHN0eWxlYCByZWxpZXMgb24gc3ludGF4IHBsdWdpbnMuXG4gICAgICBwbHVnaW5zLm9uUHJvY2Vzc1N0eWxlKHN0eWxlUnVsZS5zdHlsZSwgc3R5bGVSdWxlLCBzaGVldCk7IC8vIFVwZGF0ZSBhbmQgYWRkIHByb3BzLlxuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlUnVsZS5zdHlsZSkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gc3R5bGVSdWxlLnN0eWxlW3Byb3BdO1xuICAgICAgICB2YXIgcHJldlZhbHVlID0gc3R5bGVbcHJvcF07IC8vIFdlIG5lZWQgdG8gdXNlIGBmb3JjZTogdHJ1ZWAgYmVjYXVzZSBgcnVsZS5zdHlsZWAgaGFzIGJlZW4gdXBkYXRlZCBkdXJpbmcgb25VcGRhdGUgaG9vaywgc28gYHJ1bGUucHJvcCgpYCB3aWxsIG5vdCB1cGRhdGUgdGhlIENTU09NIHJ1bGUuXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgY29tcGFyaXNvbiB0byBhdm9pZCB1bm5lZWRlZCBgcnVsZS5wcm9wKClgIGNhbGxzLCBzaW5jZSB3ZSBoYXZlIHRoZSBvbGQgYHN0eWxlYCBvYmplY3QgaGVyZS5cblxuICAgICAgICBpZiAobmV4dFZhbHVlICE9PSBwcmV2VmFsdWUpIHtcbiAgICAgICAgICBzdHlsZVJ1bGUucHJvcChwcm9wLCBuZXh0VmFsdWUsIGZvcmNlVXBkYXRlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVtb3ZlIHByb3BzLlxuXG5cbiAgICAgIGZvciAodmFyIF9wcm9wIGluIHN0eWxlKSB7XG4gICAgICAgIHZhciBfbmV4dFZhbHVlID0gc3R5bGVSdWxlLnN0eWxlW19wcm9wXTtcbiAgICAgICAgdmFyIF9wcmV2VmFsdWUgPSBzdHlsZVtfcHJvcF07IC8vIFdlIG5lZWQgdG8gdXNlIGBmb3JjZTogdHJ1ZWAgYmVjYXVzZSBgcnVsZS5zdHlsZWAgaGFzIGJlZW4gdXBkYXRlZCBkdXJpbmcgb25VcGRhdGUgaG9vaywgc28gYHJ1bGUucHJvcCgpYCB3aWxsIG5vdCB1cGRhdGUgdGhlIENTU09NIHJ1bGUuXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgY29tcGFyaXNvbiB0byBhdm9pZCB1bm5lZWRlZCBgcnVsZS5wcm9wKClgIGNhbGxzLCBzaW5jZSB3ZSBoYXZlIHRoZSBvbGQgYHN0eWxlYCBvYmplY3QgaGVyZS5cblxuICAgICAgICBpZiAoX25leHRWYWx1ZSA9PSBudWxsICYmIF9uZXh0VmFsdWUgIT09IF9wcmV2VmFsdWUpIHtcbiAgICAgICAgICBzdHlsZVJ1bGUucHJvcChfcHJvcCwgbnVsbCwgZm9yY2VVcGRhdGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udmVydCBydWxlcyB0byBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG4gICAgdmFyIGxpbmsgPSBzaGVldCA/IHNoZWV0Lm9wdGlvbnMubGluayA6IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuaW5kZXgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMuaW5kZXhbaW5kZXhdO1xuICAgICAgdmFyIGNzcyA9IHJ1bGUudG9TdHJpbmcob3B0aW9ucyk7IC8vIE5vIG5lZWQgdG8gcmVuZGVyIGFuIGVtcHR5IHJ1bGUuXG5cbiAgICAgIGlmICghY3NzICYmICFsaW5rKSBjb250aW51ZTtcbiAgICAgIGlmIChzdHIpIHN0ciArPSAnXFxuJztcbiAgICAgIHN0ciArPSBjc3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICByZXR1cm4gUnVsZUxpc3Q7XG59KCk7XG5cbnZhciBTdHlsZVNoZWV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3R5bGVTaGVldChzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXBsb3llZCA9IHZvaWQgMDtcbiAgICB0aGlzLmF0dGFjaGVkID0gdm9pZCAwO1xuICAgIHRoaXMucnVsZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5yZW5kZXJlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlmcmFtZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5xdWV1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXBsb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xhc3NlcyA9IHt9O1xuICAgIHRoaXMua2V5ZnJhbWVzID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNoZWV0OiB0aGlzLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgY2xhc3NlczogdGhpcy5jbGFzc2VzLFxuICAgICAga2V5ZnJhbWVzOiB0aGlzLmtleWZyYW1lc1xuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMuUmVuZGVyZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgb3B0aW9ucy5SZW5kZXJlcih0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KHRoaXMub3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGVzW25hbWVdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoIHJlbmRlcmFibGUgdG8gdGhlIHJlbmRlciB0cmVlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBTdHlsZVNoZWV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYXR0YWNoID0gZnVuY3Rpb24gYXR0YWNoKCkge1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5hdHRhY2goKTtcbiAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTsgLy8gT3JkZXIgaXMgaW1wb3J0YW50LCBiZWNhdXNlIHdlIGNhbid0IHVzZSBpbnNlcnRSdWxlIEFQSSBpZiBzdHlsZSBlbGVtZW50IGlzIG5vdCBhdHRhY2hlZC5cblxuICAgIGlmICghdGhpcy5kZXBsb3llZCkgdGhpcy5kZXBsb3koKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHJlbmRlcmFibGUgZnJvbSByZW5kZXIgdHJlZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgIGlmICghdGhpcy5hdHRhY2hlZCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHRoaXMucmVuZGVyZXIuZGV0YWNoKCk7XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBydWxlIHRvIHRoZSBjdXJyZW50IHN0eWxlc2hlZXQuXG4gICAqIFdpbGwgaW5zZXJ0IGEgcnVsZSBhbHNvIGFmdGVyIHRoZSBzdHlsZXNoZWV0IGhhcyBiZWVuIHJlbmRlcmVkIGZpcnN0IHRpbWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGUgPSBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlOyAvLyBQbHVnaW5zIGNhbiBjcmVhdGUgcnVsZXMuXG4gICAgLy8gSW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIHJpZ2h0IG9yZGVyLCB3ZSBuZWVkIHRvIHF1ZXVlIGFsbCBgLmFkZFJ1bGVgIGNhbGxzLFxuICAgIC8vIHdoaWNoIGhhcHBlbiBhZnRlciB0aGUgZmlyc3QgYHJ1bGVzLmFkZCgpYCBjYWxsLlxuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgIXF1ZXVlKSB0aGlzLnF1ZXVlID0gW107XG4gICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBkZWNsLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBudWxsO1xuICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICghdGhpcy5kZXBsb3llZCkgcmV0dXJuIHJ1bGU7IC8vIERvbid0IGluc2VydCBydWxlIGRpcmVjdGx5IGlmIHRoZXJlIGlzIG5vIHN0cmluZ2lmaWVkIHZlcnNpb24geWV0LlxuICAgICAgLy8gSXQgd2lsbCBiZSBpbnNlcnRlZCBhbGwgdG9nZXRoZXIgd2hlbiAuYXR0YWNoIGlzIGNhbGxlZC5cblxuICAgICAgaWYgKHF1ZXVlKSBxdWV1ZS5wdXNoKHJ1bGUpO2Vsc2Uge1xuICAgICAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG5cbiAgICAgICAgaWYgKHRoaXMucXVldWUpIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlLmZvckVhY2godGhpcy5pbnNlcnRSdWxlLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLnF1ZXVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9IC8vIFdlIGNhbid0IGFkZCBydWxlcyB0byBhIGRldGFjaGVkIHN0eWxlIG5vZGUuXG4gICAgLy8gV2Ugd2lsbCByZWRlcGxveSB0aGUgc2hlZXQgb25jZSB1c2VyIHdpbGwgYXR0YWNoIGl0LlxuXG5cbiAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBydWxlIGludG8gdGhlIFN0eWxlU2hlZXRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmluc2VydFJ1bGUocnVsZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIGFkZCBydWxlcy5cbiAgICogV2lsbCByZW5kZXIgYWxzbyBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGVzID0gZnVuY3Rpb24gYWRkUnVsZXMoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGFkZGVkID0gW107XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLmFkZFJ1bGUobmFtZSwgc3R5bGVzW25hbWVdLCBvcHRpb25zKTtcbiAgICAgIGlmIChydWxlKSBhZGRlZC5wdXNoKHJ1bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRlZDtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZSBieSBuYW1lLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRSdWxlID0gZnVuY3Rpb24gZ2V0UnVsZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBydWxlIGJ5IG5hbWUuXG4gICAqIFJldHVybnMgYHRydWVgOiBpZiBydWxlIGhhcyBiZWVuIGRlbGV0ZWQgZnJvbSB0aGUgRE9NLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZWxldGVSdWxlID0gZnVuY3Rpb24gZGVsZXRlUnVsZShuYW1lKSB7XG4gICAgdmFyIHJ1bGUgPSB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcgPyBuYW1lIDogdGhpcy5ydWxlcy5nZXQobmFtZSk7XG5cbiAgICBpZiAoIXJ1bGUgfHwgLy8gU3R5bGUgc2hlZXQgd2FzIGNyZWF0ZWQgd2l0aG91dCBsaW5rOiB0cnVlIGFuZCBhdHRhY2hlZCwgaW4gdGhpcyBjYXNlIHdlXG4gICAgLy8gd29uJ3QgYmUgYWJsZSB0byByZW1vdmUgdGhlIENTUyBydWxlIGZyb20gdGhlIERPTS5cbiAgICB0aGlzLmF0dGFjaGVkICYmICFydWxlLnJlbmRlcmFibGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnJlbW92ZShydWxlKTtcblxuICAgIGlmICh0aGlzLmF0dGFjaGVkICYmIHJ1bGUucmVuZGVyYWJsZSAmJiB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5kZWxldGVSdWxlKHJ1bGUucmVuZGVyYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBEZXBsb3kgcHVyZSBDU1Mgc3RyaW5nIHRvIGEgcmVuZGVyYWJsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVwbG95ID0gZnVuY3Rpb24gZGVwbG95KCkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmRlcGxveSgpO1xuICAgIHRoaXMuZGVwbG95ZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIHZhbHVlcyB3aXRoIGEgbmV3IGRhdGEuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMkcnVsZXM7XG5cbiAgICAoX3RoaXMkcnVsZXMgPSB0aGlzLnJ1bGVzKS51cGRhdGUuYXBwbHkoX3RoaXMkcnVsZXMsIGFyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBhIHNpbmdsZSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUocnVsZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMucnVsZXMudXBkYXRlT25lKHJ1bGUsIGRhdGEsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHJ1bGVzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbnZhciBQbHVnaW5zUmVnaXN0cnkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbHVnaW5zUmVnaXN0cnkoKSB7XG4gICAgdGhpcy5wbHVnaW5zID0ge1xuICAgICAgaW50ZXJuYWw6IFtdLFxuICAgICAgZXh0ZXJuYWw6IFtdXG4gICAgfTtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gdm9pZCAwO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBsdWdpbnNSZWdpc3RyeS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIENhbGwgYG9uQ3JlYXRlUnVsZWAgaG9va3MgYW5kIHJldHVybiBhbiBvYmplY3QgaWYgcmV0dXJuZWQgYnkgYSBob29rLlxuICAgKi9cbiAgX3Byb3RvLm9uQ3JlYXRlUnVsZSA9IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uQ3JlYXRlUnVsZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJlZ2lzdHJ5Lm9uQ3JlYXRlUnVsZVtpXShuYW1lLCBkZWNsLCBvcHRpb25zKTtcbiAgICAgIGlmIChydWxlKSByZXR1cm4gcnVsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzUnVsZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uUHJvY2Vzc1J1bGUgPSBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUpIHtcbiAgICBpZiAocnVsZS5pc1Byb2Nlc3NlZCkgcmV0dXJuO1xuICAgIHZhciBzaGVldCA9IHJ1bGUub3B0aW9ucy5zaGVldDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NSdWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1J1bGVbaV0ocnVsZSwgc2hlZXQpO1xuICAgIH1cblxuICAgIGlmIChydWxlLnN0eWxlKSB0aGlzLm9uUHJvY2Vzc1N0eWxlKHJ1bGUuc3R5bGUsIHJ1bGUsIHNoZWV0KTtcbiAgICBydWxlLmlzUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzU3R5bGVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NTdHlsZSA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBydWxlLnN0eWxlID0gdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTdHlsZVtpXShydWxlLnN0eWxlLCBydWxlLCBzaGVldCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvblByb2Nlc3NTaGVldGAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uUHJvY2Vzc1NoZWV0ID0gZnVuY3Rpb24gb25Qcm9jZXNzU2hlZXQoc2hlZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU2hlZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU2hlZXRbaV0oc2hlZXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25VcGRhdGVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblVwZGF0ZSA9IGZ1bmN0aW9uIG9uVXBkYXRlKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5Lm9uVXBkYXRlW2ldKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uQ2hhbmdlVmFsdWVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vbkNoYW5nZVZhbHVlID0gZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCwgcnVsZSkge1xuICAgIHZhciBwcm9jZXNzZWRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uQ2hhbmdlVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb2Nlc3NlZFZhbHVlID0gdGhpcy5yZWdpc3RyeS5vbkNoYW5nZVZhbHVlW2ldKHByb2Nlc3NlZFZhbHVlLCBwcm9wLCBydWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvY2Vzc2VkVmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgcGx1Z2luLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51c2UgPSBmdW5jdGlvbiB1c2UobmV3UGx1Z2luLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcXVldWU6ICdleHRlcm5hbCdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHBsdWdpbnMgPSB0aGlzLnBsdWdpbnNbb3B0aW9ucy5xdWV1ZV07IC8vIEF2b2lkcyBhcHBseWluZyBzYW1lIHBsdWdpbiB0d2ljZSwgYXQgbGVhc3QgYmFzZWQgb24gcmVmLlxuXG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihuZXdQbHVnaW4pICE9PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBsdWdpbnMucHVzaChuZXdQbHVnaW4pO1xuICAgIHRoaXMucmVnaXN0cnkgPSBbXS5jb25jYXQodGhpcy5wbHVnaW5zLmV4dGVybmFsLCB0aGlzLnBsdWdpbnMuaW50ZXJuYWwpLnJlZHVjZShmdW5jdGlvbiAocmVnaXN0cnksIHBsdWdpbikge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwbHVnaW4pIHtcbiAgICAgICAgaWYgKG5hbWUgaW4gcmVnaXN0cnkpIHtcbiAgICAgICAgICByZWdpc3RyeVtuYW1lXS5wdXNoKHBsdWdpbltuYW1lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBVbmtub3duIGhvb2sgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIikgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICAgIH0sIHtcbiAgICAgIG9uQ3JlYXRlUnVsZTogW10sXG4gICAgICBvblByb2Nlc3NSdWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1N0eWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1NoZWV0OiBbXSxcbiAgICAgIG9uQ2hhbmdlVmFsdWU6IFtdLFxuICAgICAgb25VcGRhdGU6IFtdXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFBsdWdpbnNSZWdpc3RyeTtcbn0oKTtcblxuLyoqXG4gKiBTaGVldHMgcmVnaXN0cnkgdG8gYWNjZXNzIHRoZW0gYWxsIGF0IG9uZSBwbGFjZS5cbiAqL1xudmFyIFNoZWV0c1JlZ2lzdHJ5ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hlZXRzUmVnaXN0cnkoKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNoZWV0c1JlZ2lzdHJ5LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoc2hlZXQpIHtcbiAgICB2YXIgcmVnaXN0cnkgPSB0aGlzLnJlZ2lzdHJ5O1xuICAgIHZhciBpbmRleCA9IHNoZWV0Lm9wdGlvbnMuaW5kZXg7XG4gICAgaWYgKHJlZ2lzdHJ5LmluZGV4T2Yoc2hlZXQpICE9PSAtMSkgcmV0dXJuO1xuXG4gICAgaWYgKHJlZ2lzdHJ5Lmxlbmd0aCA9PT0gMCB8fCBpbmRleCA+PSB0aGlzLmluZGV4KSB7XG4gICAgICByZWdpc3RyeS5wdXNoKHNoZWV0KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZpbmQgYSBwb3NpdGlvbi5cblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlZ2lzdHJ5W2ldLm9wdGlvbnMuaW5kZXggPiBpbmRleCkge1xuICAgICAgICByZWdpc3RyeS5zcGxpY2UoaSwgMCwgc2hlZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXNldCB0aGUgcmVnaXN0cnkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHNoZWV0KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5yZWdpc3RyeS5pbmRleE9mKHNoZWV0KTtcbiAgICB0aGlzLnJlZ2lzdHJ5LnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgYWxsIGF0dGFjaGVkIHNoZWV0cyB0byBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBhdHRhY2hlZCA9IF9yZWYuYXR0YWNoZWQsXG4gICAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJhdHRhY2hlZFwiXSk7XG5cbiAgICB2YXIgY3NzID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzaGVldCA9IHRoaXMucmVnaXN0cnlbaV07XG5cbiAgICAgIGlmIChhdHRhY2hlZCAhPSBudWxsICYmIHNoZWV0LmF0dGFjaGVkICE9PSBhdHRhY2hlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNzcykgY3NzICs9ICdcXG4nO1xuICAgICAgY3NzICs9IHNoZWV0LnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBjc3M7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFNoZWV0c1JlZ2lzdHJ5LCBbe1xuICAgIGtleTogXCJpbmRleFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBoaWdoZXN0IGluZGV4IG51bWJlci5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5Lmxlbmd0aCA9PT0gMCA/IDAgOiB0aGlzLnJlZ2lzdHJ5W3RoaXMucmVnaXN0cnkubGVuZ3RoIC0gMV0ub3B0aW9ucy5pbmRleDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hlZXRzUmVnaXN0cnk7XG59KCk7XG5cbi8qKlxuICogVGhpcyBpcyBhIGdsb2JhbCBzaGVldHMgcmVnaXN0cnkuIE9ubHkgRG9tUmVuZGVyZXIgd2lsbCBhZGQgc2hlZXRzIHRvIGl0LlxuICogT24gdGhlIHNlcnZlciBvbmUgc2hvdWxkIHVzZSBhbiBvd24gU2hlZXRzUmVnaXN0cnkgaW5zdGFuY2UgYW5kIGFkZCB0aGVcbiAqIHNoZWV0cyB0byBpdCwgYmVjYXVzZSB5b3UgbmVlZCB0byBtYWtlIHN1cmUgdG8gY3JlYXRlIGEgbmV3IHJlZ2lzdHJ5IGZvclxuICogZWFjaCByZXF1ZXN0IGluIG9yZGVyIHRvIG5vdCBsZWFrIHNoZWV0cyBhY3Jvc3MgcmVxdWVzdHMuXG4gKi9cblxudmFyIHJlZ2lzdHJ5ID0gbmV3IFNoZWV0c1JlZ2lzdHJ5KCk7XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbi8qKlxuICogTm93IHRoYXQgYGdsb2JhbFRoaXNgIGlzIGF2YWlsYWJsZSBvbiBtb3N0IHBsYXRmb3Jtc1xuICogKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL2dsb2JhbFRoaXMjYnJvd3Nlcl9jb21wYXRpYmlsaXR5KVxuICogd2UgY2hlY2sgZm9yIGBnbG9iYWxUaGlzYCBmaXJzdC4gYGdsb2JhbFRoaXNgIGlzIG5lY2Vzc2FyeSBmb3IganNzXG4gKiB0byBydW4gaW4gQWdvcmljJ3Mgc2VjdXJlIHZlcnNpb24gb2YgSmF2YVNjcmlwdCAoU0VTKS4gVW5kZXIgU0VTLFxuICogYGdsb2JhbFRoaXNgIGV4aXN0cywgYnV0IGB3aW5kb3dgLCBgc2VsZmAsIGFuZCBgRnVuY3Rpb24oJ3JldHVyblxuICogdGhpcycpKClgIGFyZSBhbGwgdW5kZWZpbmVkIGZvciBzZWN1cml0eSByZWFzb25zLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG4gKi9cbnZhciBnbG9iYWxUaGlzJDEgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT09IE1hdGggPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBucyA9ICcyZjFhY2M2YzNhNjA2YjA4MmU1ZWVmNWU1NDQxNGZmYic7XG5pZiAoZ2xvYmFsVGhpcyQxW25zXSA9PSBudWxsKSBnbG9iYWxUaGlzJDFbbnNdID0gMDsgLy8gQnVuZGxlIG1heSBjb250YWluIG11bHRpcGxlIEpTUyB2ZXJzaW9ucyBhdCB0aGUgc2FtZSB0aW1lLiBJbiBvcmRlciB0byBpZGVudGlmeVxuLy8gdGhlIGN1cnJlbnQgdmVyc2lvbiB3aXRoIGp1c3Qgb25lIHNob3J0IG51bWJlciBhbmQgdXNlIGl0IGZvciBjbGFzc2VzIGdlbmVyYXRpb25cbi8vIHdlIHVzZSBhIGNvdW50ZXIuIEFsc28gaXQgaXMgbW9yZSBhY2N1cmF0ZSwgYmVjYXVzZSB1c2VyIGNhbiBtYW51YWxseSByZWV2YWx1YXRlXG4vLyB0aGUgbW9kdWxlLlxuXG52YXIgbW9kdWxlSWQgPSBnbG9iYWxUaGlzJDFbbnNdKys7XG5cbnZhciBtYXhSdWxlcyA9IDFlMTA7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyB1bmlxdWUgY2xhc3MgbmFtZXMgYmFzZWQgb24gY291bnRlcnMuXG4gKiBXaGVuIG5ldyBnZW5lcmF0b3IgZnVuY3Rpb24gaXMgY3JlYXRlZCwgcnVsZSBjb3VudGVyIGlzIHJlc2V0ZWQuXG4gKiBXZSBuZWVkIHRvIHJlc2V0IHRoZSBydWxlIGNvdW50ZXIgZm9yIFNTUiBmb3IgZWFjaCByZXF1ZXN0LlxuICovXG52YXIgY3JlYXRlR2VuZXJhdGVJZCA9IGZ1bmN0aW9uIGNyZWF0ZUdlbmVyYXRlSWQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHJ1bGVDb3VudGVyID0gMDtcblxuICB2YXIgZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uIGdlbmVyYXRlSWQocnVsZSwgc2hlZXQpIHtcbiAgICBydWxlQ291bnRlciArPSAxO1xuXG4gICAgaWYgKHJ1bGVDb3VudGVyID4gbWF4UnVsZXMpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gWW91IG1pZ2h0IGhhdmUgYSBtZW1vcnkgbGVhay4gUnVsZSBjb3VudGVyIGlzIGF0IFwiICsgcnVsZUNvdW50ZXIgKyBcIi5cIikgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGpzc0lkID0gJyc7XG4gICAgdmFyIHByZWZpeCA9ICcnO1xuXG4gICAgaWYgKHNoZWV0KSB7XG4gICAgICBpZiAoc2hlZXQub3B0aW9ucy5jbGFzc05hbWVQcmVmaXgpIHtcbiAgICAgICAgcHJlZml4ID0gc2hlZXQub3B0aW9ucy5jbGFzc05hbWVQcmVmaXg7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGVldC5vcHRpb25zLmpzcy5pZCAhPSBudWxsKSB7XG4gICAgICAgIGpzc0lkID0gU3RyaW5nKHNoZWV0Lm9wdGlvbnMuanNzLmlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5taW5pZnkpIHtcbiAgICAgIC8vIFVzaW5nIFwiY1wiIGJlY2F1c2UgYSBudW1iZXIgY2FuJ3QgYmUgdGhlIGZpcnN0IGNoYXIgaW4gYSBjbGFzcyBuYW1lLlxuICAgICAgcmV0dXJuIFwiXCIgKyAocHJlZml4IHx8ICdjJykgKyBtb2R1bGVJZCArIGpzc0lkICsgcnVsZUNvdW50ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeCArIHJ1bGUua2V5ICsgXCItXCIgKyBtb2R1bGVJZCArIChqc3NJZCA/IFwiLVwiICsganNzSWQgOiAnJykgKyBcIi1cIiArIHJ1bGVDb3VudGVyO1xuICB9O1xuXG4gIHJldHVybiBnZW5lcmF0ZUlkO1xufTtcblxuLyoqXG4gKiBDYWNoZSB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3QgdGltZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAqL1xudmFyIG1lbW9pemUgPSBmdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gIHZhciB2YWx1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXZhbHVlKSB2YWx1ZSA9IGZuKCk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufTtcblxuLyoqXG4gKiBHZXQgYSBzdHlsZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xudmFyIGdldFByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0eVZhbHVlKGNzc1J1bGUsIHByb3ApIHtcbiAgdHJ5IHtcbiAgICAvLyBTdXBwb3J0IENTU1RPTS5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgcmV0dXJuIGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXAuZ2V0KHByb3ApO1xuICAgIH1cblxuICAgIHJldHVybiBjc3NSdWxlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElFIG1heSB0aHJvdyBpZiBwcm9wZXJ0eSBpcyB1bmtub3duLlxuICAgIHJldHVybiAnJztcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgYSBzdHlsZSBwcm9wZXJ0eS5cbiAqL1xudmFyIHNldFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJvcGVydHkoY3NzUnVsZSwgcHJvcCwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgY3NzVmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY3NzVmFsdWUgPSB0b0Nzc1ZhbHVlKHZhbHVlLCB0cnVlKTtcblxuICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnIWltcG9ydGFudCcpIHtcbiAgICAgICAgY3NzUnVsZS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBjc3NWYWx1ZSwgJ2ltcG9ydGFudCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIFN1cHBvcnQgQ1NTVE9NLlxuXG5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcC5zZXQocHJvcCwgY3NzVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjc3NSdWxlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIGNzc1ZhbHVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElFIG1heSB0aHJvdyBpZiBwcm9wZXJ0eSBpcyB1bmtub3duLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBzdHlsZSBwcm9wZXJ0eS5cbiAqL1xudmFyIHJlbW92ZVByb3BlcnR5ID0gZnVuY3Rpb24gcmVtb3ZlUHJvcGVydHkoY3NzUnVsZSwgcHJvcCkge1xuICB0cnkge1xuICAgIC8vIFN1cHBvcnQgQ1NTVE9NLlxuICAgIGlmIChjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwKSB7XG4gICAgICBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLmRlbGV0ZShwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3NzUnVsZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gRE9NRXhjZXB0aW9uIFxcXCJcIiArIGVyci5tZXNzYWdlICsgXCJcXFwiIHdhcyB0aHJvd24uIFRyaWVkIHRvIHJlbW92ZSBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wICsgXCJcXFwiLlwiKSA6IHZvaWQgMDtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIHNlbGVjdG9yLlxuICovXG52YXIgc2V0U2VsZWN0b3IgPSBmdW5jdGlvbiBzZXRTZWxlY3Rvcihjc3NSdWxlLCBzZWxlY3RvclRleHQpIHtcbiAgY3NzUnVsZS5zZWxlY3RvclRleHQgPSBzZWxlY3RvclRleHQ7IC8vIFJldHVybiBmYWxzZSBpZiBzZXR0ZXIgd2FzIG5vdCBzdWNjZXNzZnVsLlxuICAvLyBDdXJyZW50bHkgd29ya3MgaW4gY2hyb21lIG9ubHkuXG5cbiAgcmV0dXJuIGNzc1J1bGUuc2VsZWN0b3JUZXh0ID09PSBzZWxlY3RvclRleHQ7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBgaGVhZGAgZWxlbWVudCB1cG9uIHRoZSBmaXJzdCBjYWxsIGFuZCBjYWNoZXMgaXQuXG4gKiBXZSBhc3N1bWUgaXQgY2FuJ3QgYmUgbnVsbC5cbiAqL1xuXG5cbnZhciBnZXRIZWFkID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkJyk7XG59KTtcbi8qKlxuICogRmluZCBhdHRhY2hlZCBzaGVldCB3aXRoIGFuIGluZGV4IGhpZ2hlciB0aGFuIHRoZSBwYXNzZWQgb25lLlxuICovXG5cbmZ1bmN0aW9uIGZpbmRIaWdoZXJTaGVldChyZWdpc3RyeSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNoZWV0ID0gcmVnaXN0cnlbaV07XG5cbiAgICBpZiAoc2hlZXQuYXR0YWNoZWQgJiYgc2hlZXQub3B0aW9ucy5pbmRleCA+IG9wdGlvbnMuaW5kZXggJiYgc2hlZXQub3B0aW9ucy5pbnNlcnRpb25Qb2ludCA9PT0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludCkge1xuICAgICAgcmV0dXJuIHNoZWV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBGaW5kIGF0dGFjaGVkIHNoZWV0IHdpdGggdGhlIGhpZ2hlc3QgaW5kZXguXG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kSGlnaGVzdFNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSByZWdpc3RyeS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBzaGVldCA9IHJlZ2lzdHJ5W2ldO1xuXG4gICAgaWYgKHNoZWV0LmF0dGFjaGVkICYmIHNoZWV0Lm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPT09IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQpIHtcbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRmluZCBhIGNvbW1lbnQgd2l0aCBcImpzc1wiIGluc2lkZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRDb21tZW50Tm9kZSh0ZXh0KSB7XG4gIHZhciBoZWFkID0gZ2V0SGVhZCgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBoZWFkLmNoaWxkTm9kZXNbaV07XG5cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZS50cmltKCkgPT09IHRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmQgYSBub2RlIGJlZm9yZSB3aGljaCB3ZSBjYW4gaW5zZXJ0IHRoZSBzaGVldC5cbiAqL1xuZnVuY3Rpb24gZmluZFByZXZOb2RlKG9wdGlvbnMpIHtcbiAgdmFyIHJlZ2lzdHJ5JDEgPSByZWdpc3RyeS5yZWdpc3RyeTtcblxuICBpZiAocmVnaXN0cnkkMS5sZW5ndGggPiAwKSB7XG4gICAgLy8gVHJ5IHRvIGluc2VydCBiZWZvcmUgdGhlIG5leHQgaGlnaGVyIHNoZWV0LlxuICAgIHZhciBzaGVldCA9IGZpbmRIaWdoZXJTaGVldChyZWdpc3RyeSQxLCBvcHRpb25zKTtcblxuICAgIGlmIChzaGVldCAmJiBzaGVldC5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFyZW50OiBzaGVldC5yZW5kZXJlci5lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICAgIG5vZGU6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnRcbiAgICAgIH07XG4gICAgfSAvLyBPdGhlcndpc2UgaW5zZXJ0IGFmdGVyIHRoZSBsYXN0IGF0dGFjaGVkLlxuXG5cbiAgICBzaGVldCA9IGZpbmRIaWdoZXN0U2hlZXQocmVnaXN0cnkkMSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoc2hlZXQgJiYgc2hlZXQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogc2hlZXQucmVuZGVyZXIuZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBzaGVldC5yZW5kZXJlci5lbGVtZW50Lm5leHRTaWJsaW5nXG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBUcnkgdG8gZmluZCBhIGNvbW1lbnQgcGxhY2Vob2xkZXIgaWYgcmVnaXN0cnkgaXMgZW1wdHkuXG5cblxuICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuXG4gIGlmIChpbnNlcnRpb25Qb2ludCAmJiB0eXBlb2YgaW5zZXJ0aW9uUG9pbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGNvbW1lbnQgPSBmaW5kQ29tbWVudE5vZGUoaW5zZXJ0aW9uUG9pbnQpO1xuXG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogY29tbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBjb21tZW50Lm5leHRTaWJsaW5nXG4gICAgICB9O1xuICAgIH0gLy8gSWYgdXNlciBzcGVjaWZpZXMgYW4gaW5zZXJ0aW9uIHBvaW50IGFuZCBpdCBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgZG9jdW1lbnQgLVxuICAgIC8vIGJhZCBzcGVjaWZpY2l0eSBpc3N1ZXMgbWF5IGFwcGVhci5cblxuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBJbnNlcnRpb24gcG9pbnQgXFxcIlwiICsgaW5zZXJ0aW9uUG9pbnQgKyBcIlxcXCIgbm90IGZvdW5kLlwiKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogSW5zZXJ0IHN0eWxlIGVsZW1lbnQgaW50byB0aGUgRE9NLlxuICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGUoc3R5bGUsIG9wdGlvbnMpIHtcbiAgdmFyIGluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcbiAgdmFyIG5leHROb2RlID0gZmluZFByZXZOb2RlKG9wdGlvbnMpO1xuXG4gIGlmIChuZXh0Tm9kZSAhPT0gZmFsc2UgJiYgbmV4dE5vZGUucGFyZW50KSB7XG4gICAgbmV4dE5vZGUucGFyZW50Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dE5vZGUubm9kZSk7XG4gICAgcmV0dXJuO1xuICB9IC8vIFdvcmtzIHdpdGggaWZyYW1lcyBhbmQgYW55IG5vZGUgdHlwZXMuXG5cblxuICBpZiAoaW5zZXJ0aW9uUG9pbnQgJiYgdHlwZW9mIGluc2VydGlvblBvaW50Lm5vZGVUeXBlID09PSAnbnVtYmVyJykge1xuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQxMzI4NzI4L2ZvcmNlLWNhc3RpbmctaW4tZmxvd1xuICAgIHZhciBpbnNlcnRpb25Qb2ludEVsZW1lbnQgPSBpbnNlcnRpb25Qb2ludDtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGluc2VydGlvblBvaW50RWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLmluc2VydEJlZm9yZShzdHlsZSwgaW5zZXJ0aW9uUG9pbnRFbGVtZW50Lm5leHRTaWJsaW5nKTtlbHNlIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdbSlNTXSBJbnNlcnRpb24gcG9pbnQgaXMgbm90IGluIHRoZSBET00uJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cbi8qKlxuICogUmVhZCBqc3Mgbm9uY2Ugc2V0dGluZyBmcm9tIHRoZSBwYWdlIGlmIHRoZSB1c2VyIGhhcyBzZXQgaXQuXG4gKi9cblxuXG52YXIgZ2V0Tm9uY2UgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW3Byb3BlcnR5PVwiY3NwLW5vbmNlXCJdJyk7XG4gIHJldHVybiBub2RlID8gbm9kZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSA6IG51bGw7XG59KTtcblxudmFyIF9pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShjb250YWluZXIsIHJ1bGUsIGluZGV4KSB7XG4gIHRyeSB7XG4gICAgaWYgKCdpbnNlcnRSdWxlJyBpbiBjb250YWluZXIpIHtcbiAgICAgIHZhciBjID0gY29udGFpbmVyO1xuICAgICAgYy5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICB9IC8vIEtleWZyYW1lcyBydWxlLlxuICAgIGVsc2UgaWYgKCdhcHBlbmRSdWxlJyBpbiBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIF9jID0gY29udGFpbmVyO1xuXG4gICAgICAgIF9jLmFwcGVuZFJ1bGUocnVsZSk7XG4gICAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gXCIgKyBlcnIubWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5lci5jc3NSdWxlc1tpbmRleF07XG59O1xuXG52YXIgZ2V0VmFsaWRSdWxlSW5zZXJ0aW9uSW5kZXggPSBmdW5jdGlvbiBnZXRWYWxpZFJ1bGVJbnNlcnRpb25JbmRleChjb250YWluZXIsIGluZGV4KSB7XG4gIHZhciBtYXhJbmRleCA9IGNvbnRhaW5lci5jc3NSdWxlcy5sZW5ndGg7IC8vIEluIGNhc2UgcHJldmlvdXMgaW5zZXJ0aW9uIGZhaWxzLCBwYXNzZWQgaW5kZXggbWlnaHQgYmUgd3JvbmdcblxuICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fCBpbmRleCA+IG1heEluZGV4KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmV0dXJuIG1heEluZGV4O1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufTtcblxudmFyIGNyZWF0ZVN0eWxlID0gZnVuY3Rpb24gY3JlYXRlU3R5bGUoKSB7XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7IC8vIFdpdGhvdXQgaXQsIElFIHdpbGwgaGF2ZSBhIGJyb2tlbiBzb3VyY2Ugb3JkZXIgc3BlY2lmaWNpdHkgaWYgd2VcbiAgLy8gaW5zZXJ0IHJ1bGVzIGFmdGVyIHdlIGluc2VydCB0aGUgc3R5bGUgdGFnLlxuICAvLyBJdCBzZWVtcyB0byBraWNrLW9mZiB0aGUgc291cmNlIG9yZGVyIHNwZWNpZmljaXR5IGFsZ29yaXRobS5cblxuICBlbC50ZXh0Q29udGVudCA9ICdcXG4nO1xuICByZXR1cm4gZWw7XG59O1xuXG52YXIgRG9tUmVuZGVyZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvLyBIVE1MU3R5bGVFbGVtZW50IG5lZWRzIGZpeGluZyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjY5NlxuICAvLyBXaWxsIGJlIGVtcHR5IGlmIGxpbms6IHRydWUgb3B0aW9uIGlzIG5vdCBzZXQsIGJlY2F1c2VcbiAgLy8gaXQgaXMgb25seSBmb3IgdXNlIHRvZ2V0aGVyIHdpdGggaW5zZXJ0UnVsZSBBUEkuXG4gIGZ1bmN0aW9uIERvbVJlbmRlcmVyKHNoZWV0KSB7XG4gICAgdGhpcy5nZXRQcm9wZXJ0eVZhbHVlID0gZ2V0UHJvcGVydHlWYWx1ZTtcbiAgICB0aGlzLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XG4gICAgdGhpcy5yZW1vdmVQcm9wZXJ0eSA9IHJlbW92ZVByb3BlcnR5O1xuICAgIHRoaXMuc2V0U2VsZWN0b3IgPSBzZXRTZWxlY3RvcjtcbiAgICB0aGlzLmVsZW1lbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5zaGVldCA9IHZvaWQgMDtcbiAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcbiAgICB0aGlzLmNzc1J1bGVzID0gW107XG4gICAgLy8gVGhlcmUgaXMgbm8gc2hlZXQgd2hlbiB0aGUgcmVuZGVyZXIgaXMgdXNlZCBmcm9tIGEgc3RhbmRhbG9uZSBTdHlsZVJ1bGUuXG4gICAgaWYgKHNoZWV0KSByZWdpc3RyeS5hZGQoc2hlZXQpO1xuICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcblxuICAgIHZhciBfcmVmID0gdGhpcy5zaGVldCA/IHRoaXMuc2hlZXQub3B0aW9ucyA6IHt9LFxuICAgICAgICBtZWRpYSA9IF9yZWYubWVkaWEsXG4gICAgICAgIG1ldGEgPSBfcmVmLm1ldGEsXG4gICAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50IHx8IGNyZWF0ZVN0eWxlKCk7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1qc3MnLCAnJyk7XG4gICAgaWYgKG1lZGlhKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgICBpZiAobWV0YSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1tZXRhJywgbWV0YSk7XG4gICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcbiAgICBpZiAobm9uY2UpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgc3R5bGUgZWxlbWVudCBpbnRvIHJlbmRlciB0cmVlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBEb21SZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmF0dGFjaCA9IGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICAvLyBJbiB0aGUgY2FzZSB0aGUgZWxlbWVudCBub2RlIGlzIGV4dGVybmFsIGFuZCBpdCBpcyBhbHJlYWR5IGluIHRoZSBET00uXG4gICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnROb2RlIHx8ICF0aGlzLnNoZWV0KSByZXR1cm47XG4gICAgaW5zZXJ0U3R5bGUodGhpcy5lbGVtZW50LCB0aGlzLnNoZWV0Lm9wdGlvbnMpOyAvLyBXaGVuIHJ1bGVzIGFyZSBpbnNlcnRlZCB1c2luZyBgaW5zZXJ0UnVsZWAgQVBJLCBhZnRlciBgc2hlZXQuZGV0YWNoKCkuYXR0YWNoKClgXG4gICAgLy8gbW9zdCBicm93c2VycyBjcmVhdGUgYSBuZXcgQ1NTU3R5bGVTaGVldCwgZXhjZXB0IG9mIGFsbCBJRXMuXG5cbiAgICB2YXIgZGVwbG95ZWQgPSBCb29sZWFuKHRoaXMuc2hlZXQgJiYgdGhpcy5zaGVldC5kZXBsb3llZCk7XG5cbiAgICBpZiAodGhpcy5oYXNJbnNlcnRlZFJ1bGVzICYmIGRlcGxveWVkKSB7XG4gICAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVwbG95KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgc3R5bGUgZWxlbWVudCBmcm9tIHJlbmRlciB0cmVlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgaWYgKCF0aGlzLnNoZWV0KSByZXR1cm47XG4gICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpOyAvLyBJbiB0aGUgbW9zdCBicm93c2VycywgcnVsZXMgaW5zZXJ0ZWQgdXNpbmcgaW5zZXJ0UnVsZSgpIEFQSSB3aWxsIGJlIGxvc3Qgd2hlbiBzdHlsZSBlbGVtZW50IGlzIHJlbW92ZWQuXG4gICAgLy8gVGhvdWdoIElFIHdpbGwga2VlcCB0aGVtIGFuZCB3ZSBuZWVkIGEgY29uc2lzdGVudCBiZWhhdmlvci5cblxuICAgIGlmICh0aGlzLnNoZWV0Lm9wdGlvbnMubGluaykge1xuICAgICAgdGhpcy5jc3NSdWxlcyA9IFtdO1xuICAgICAgdGhpcy5lbGVtZW50LnRleHRDb250ZW50ID0gJ1xcbic7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmplY3QgQ1NTIHN0cmluZyBpbnRvIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlcGxveSA9IGZ1bmN0aW9uIGRlcGxveSgpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLnNoZWV0O1xuICAgIGlmICghc2hlZXQpIHJldHVybjtcblxuICAgIGlmIChzaGVldC5vcHRpb25zLmxpbmspIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZXMoc2hlZXQucnVsZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudCA9IFwiXFxuXCIgKyBzaGVldC50b1N0cmluZygpICsgXCJcXG5cIjtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IFJ1bGVMaXN0IGludG8gYW4gZWxlbWVudC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZXMgPSBmdW5jdGlvbiBpbnNlcnRSdWxlcyhydWxlcywgbmF0aXZlUGFyZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5pbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGVzLmluZGV4W2ldLCBpLCBuYXRpdmVQYXJlbnQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IGEgcnVsZSBpbnRvIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUsIGluZGV4LCBuYXRpdmVQYXJlbnQpIHtcbiAgICBpZiAobmF0aXZlUGFyZW50ID09PSB2b2lkIDApIHtcbiAgICAgIG5hdGl2ZVBhcmVudCA9IHRoaXMuZWxlbWVudC5zaGVldDtcbiAgICB9XG5cbiAgICBpZiAocnVsZS5ydWxlcykge1xuICAgICAgdmFyIHBhcmVudCA9IHJ1bGU7XG4gICAgICB2YXIgbGF0ZXN0TmF0aXZlUGFyZW50ID0gbmF0aXZlUGFyZW50O1xuXG4gICAgICBpZiAocnVsZS50eXBlID09PSAnY29uZGl0aW9uYWwnIHx8IHJ1bGUudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgICAgdmFyIF9pbnNlcnRpb25JbmRleCA9IGdldFZhbGlkUnVsZUluc2VydGlvbkluZGV4KG5hdGl2ZVBhcmVudCwgaW5kZXgpOyAvLyBXZSBuZWVkIHRvIHJlbmRlciB0aGUgY29udGFpbmVyIHdpdGhvdXQgY2hpbGRyZW4gZmlyc3QuXG5cblxuICAgICAgICBsYXRlc3ROYXRpdmVQYXJlbnQgPSBfaW5zZXJ0UnVsZShuYXRpdmVQYXJlbnQsIHBhcmVudC50b1N0cmluZyh7XG4gICAgICAgICAgY2hpbGRyZW46IGZhbHNlXG4gICAgICAgIH0pLCBfaW5zZXJ0aW9uSW5kZXgpO1xuXG4gICAgICAgIGlmIChsYXRlc3ROYXRpdmVQYXJlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWZDc3NSdWxlKHJ1bGUsIF9pbnNlcnRpb25JbmRleCwgbGF0ZXN0TmF0aXZlUGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnNlcnRSdWxlcyhwYXJlbnQucnVsZXMsIGxhdGVzdE5hdGl2ZVBhcmVudCk7XG4gICAgICByZXR1cm4gbGF0ZXN0TmF0aXZlUGFyZW50O1xuICAgIH1cblxuICAgIHZhciBydWxlU3RyID0gcnVsZS50b1N0cmluZygpO1xuICAgIGlmICghcnVsZVN0cikgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBpbnNlcnRpb25JbmRleCA9IGdldFZhbGlkUnVsZUluc2VydGlvbkluZGV4KG5hdGl2ZVBhcmVudCwgaW5kZXgpO1xuXG4gICAgdmFyIG5hdGl2ZVJ1bGUgPSBfaW5zZXJ0UnVsZShuYXRpdmVQYXJlbnQsIHJ1bGVTdHIsIGluc2VydGlvbkluZGV4KTtcblxuICAgIGlmIChuYXRpdmVSdWxlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyA9IHRydWU7XG4gICAgdGhpcy5yZWZDc3NSdWxlKHJ1bGUsIGluc2VydGlvbkluZGV4LCBuYXRpdmVSdWxlKTtcbiAgICByZXR1cm4gbmF0aXZlUnVsZTtcbiAgfTtcblxuICBfcHJvdG8ucmVmQ3NzUnVsZSA9IGZ1bmN0aW9uIHJlZkNzc1J1bGUocnVsZSwgaW5kZXgsIGNzc1J1bGUpIHtcbiAgICBydWxlLnJlbmRlcmFibGUgPSBjc3NSdWxlOyAvLyBXZSBvbmx5IHdhbnQgdG8gcmVmZXJlbmNlIHRoZSB0b3AgbGV2ZWwgcnVsZXMsIGRlbGV0ZVJ1bGUgQVBJIGRvZXNuJ3Qgc3VwcG9ydCByZW1vdmluZyBuZXN0ZWQgcnVsZXNcbiAgICAvLyBsaWtlIHJ1bGVzIGluc2lkZSBtZWRpYSBxdWVyaWVzIG9yIGtleWZyYW1lc1xuXG4gICAgaWYgKHJ1bGUub3B0aW9ucy5wYXJlbnQgaW5zdGFuY2VvZiBTdHlsZVNoZWV0KSB7XG4gICAgICB0aGlzLmNzc1J1bGVzW2luZGV4XSA9IGNzc1J1bGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZWxldGVSdWxlID0gZnVuY3Rpb24gZGVsZXRlUnVsZShjc3NSdWxlKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5lbGVtZW50LnNoZWV0O1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihjc3NSdWxlKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgc2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XG4gICAgdGhpcy5jc3NSdWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBDU1MgUnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YoY3NzUnVsZSkge1xuICAgIHJldHVybiB0aGlzLmNzc1J1bGVzLmluZGV4T2YoY3NzUnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IENTUyBydWxlIGFuZCByZXBsYWNlIHRoZSBleGlzdGluZyBvbmUuXG4gICAqXG4gICAqIE9ubHkgdXNlZCBmb3Igc29tZSBvbGQgYnJvd3NlcnMgYmVjYXVzZSB0aGV5IGNhbid0IHNldCBhIHNlbGVjdG9yLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBsYWNlUnVsZSA9IGZ1bmN0aW9uIHJlcGxhY2VSdWxlKGNzc1J1bGUsIHJ1bGUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuZWxlbWVudC5zaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICB0aGlzLmNzc1J1bGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgcnVsZXMgZWxlbWVudHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFJ1bGVzID0gZnVuY3Rpb24gZ2V0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zaGVldC5jc3NSdWxlcztcbiAgfTtcblxuICByZXR1cm4gRG9tUmVuZGVyZXI7XG59KCk7XG5cbnZhciBpbnN0YW5jZUNvdW50ZXIgPSAwO1xuXG52YXIgSnNzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSnNzKG9wdGlvbnMpIHtcbiAgICB0aGlzLmlkID0gaW5zdGFuY2VDb3VudGVyKys7XG4gICAgdGhpcy52ZXJzaW9uID0gXCIxMC43LjFcIjtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgUGx1Z2luc1JlZ2lzdHJ5KCk7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgaWQ6IHtcbiAgICAgICAgbWluaWZ5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGNyZWF0ZUdlbmVyYXRlSWQ6IGNyZWF0ZUdlbmVyYXRlSWQsXG4gICAgICBSZW5kZXJlcjogaXNJbkJyb3dzZXIgPyBEb21SZW5kZXJlciA6IG51bGwsXG4gICAgICBwbHVnaW5zOiBbXVxuICAgIH07XG4gICAgdGhpcy5nZW5lcmF0ZUlkID0gY3JlYXRlR2VuZXJhdGVJZCh7XG4gICAgICBtaW5pZnk6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucGx1Z2lucy51c2UocGx1Z2luc1tpXSwge1xuICAgICAgICBxdWV1ZTogJ2ludGVybmFsJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXR1cChvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUHJlcGFyZXMgdmFyaW91cyBvcHRpb25zLCBhcHBsaWVzIHBsdWdpbnMuXG4gICAqIFNob3VsZCBub3QgYmUgdXNlZCB0d2ljZSBvbiB0aGUgc2FtZSBpbnN0YW5jZSwgYmVjYXVzZSB0aGVyZSBpcyBubyBwbHVnaW5zXG4gICAqIGRlZHVwbGljYXRpb24gbG9naWMuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEpzcy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldHVwID0gZnVuY3Rpb24gc2V0dXAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCA9IG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmlkID0gX2V4dGVuZHMoe30sIHRoaXMub3B0aW9ucy5pZCwgb3B0aW9ucy5pZCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCB8fCBvcHRpb25zLmlkKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlSWQgPSB0aGlzLm9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCh0aGlzLm9wdGlvbnMuaWQpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluc2VydGlvblBvaW50ICE9IG51bGwpIHRoaXMub3B0aW9ucy5pbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG5cbiAgICBpZiAoJ1JlbmRlcmVyJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuUmVuZGVyZXIgPSBvcHRpb25zLlJlbmRlcmVyO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcblxuXG4gICAgaWYgKG9wdGlvbnMucGx1Z2lucykgdGhpcy51c2UuYXBwbHkodGhpcywgb3B0aW9ucy5wbHVnaW5zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgU3R5bGUgU2hlZXQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNyZWF0ZVN0eWxlU2hlZXQgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZVNoZWV0KHN0eWxlcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgICBpbmRleCA9IF9vcHRpb25zLmluZGV4O1xuXG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGluZGV4ID0gcmVnaXN0cnkuaW5kZXggPT09IDAgPyAwIDogcmVnaXN0cnkuaW5kZXggKyAxO1xuICAgIH1cblxuICAgIHZhciBzaGVldCA9IG5ldyBTdHlsZVNoZWV0KHN0eWxlcywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIGpzczogdGhpcyxcbiAgICAgIGdlbmVyYXRlSWQ6IG9wdGlvbnMuZ2VuZXJhdGVJZCB8fCB0aGlzLmdlbmVyYXRlSWQsXG4gICAgICBpbnNlcnRpb25Qb2ludDogdGhpcy5vcHRpb25zLmluc2VydGlvblBvaW50LFxuICAgICAgUmVuZGVyZXI6IHRoaXMub3B0aW9ucy5SZW5kZXJlcixcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0pKTtcbiAgICB0aGlzLnBsdWdpbnMub25Qcm9jZXNzU2hlZXQoc2hlZXQpO1xuICAgIHJldHVybiBzaGVldDtcbiAgfVxuICAvKipcbiAgICogRGV0YWNoIHRoZSBTdHlsZSBTaGVldCBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHJlZ2lzdHJ5LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZW1vdmVTdHlsZVNoZWV0ID0gZnVuY3Rpb24gcmVtb3ZlU3R5bGVTaGVldChzaGVldCkge1xuICAgIHNoZWV0LmRldGFjaCgpO1xuICAgIHJlZ2lzdHJ5LnJlbW92ZShzaGVldCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJ1bGUgd2l0aG91dCBhIFN0eWxlIFNoZWV0LlxuICAgKiBbRGVwcmVjYXRlZF0gd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNyZWF0ZVJ1bGUgPSBmdW5jdGlvbiBjcmVhdGVSdWxlJDEobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoc3R5bGUgPT09IHZvaWQgMCkge1xuICAgICAgc3R5bGUgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgLy8gRW5hYmxlIHJ1bGUgd2l0aG91dCBuYW1lIGZvciBpbmxpbmUgc3R5bGVzLlxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVSdWxlKHVuZGVmaW5lZCwgbmFtZSwgc3R5bGUpO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV1cblxuXG4gICAgdmFyIHJ1bGVPcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBqc3M6IHRoaXMsXG4gICAgICBSZW5kZXJlcjogdGhpcy5vcHRpb25zLlJlbmRlcmVyXG4gICAgfSk7XG5cbiAgICBpZiAoIXJ1bGVPcHRpb25zLmdlbmVyYXRlSWQpIHJ1bGVPcHRpb25zLmdlbmVyYXRlSWQgPSB0aGlzLmdlbmVyYXRlSWQ7XG4gICAgaWYgKCFydWxlT3B0aW9ucy5jbGFzc2VzKSBydWxlT3B0aW9ucy5jbGFzc2VzID0ge307XG4gICAgaWYgKCFydWxlT3B0aW9ucy5rZXlmcmFtZXMpIHJ1bGVPcHRpb25zLmtleWZyYW1lcyA9IHt9O1xuXG4gICAgdmFyIHJ1bGUgPSBjcmVhdGVSdWxlKG5hbWUsIHN0eWxlLCBydWxlT3B0aW9ucyk7XG5cbiAgICBpZiAocnVsZSkgdGhpcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHBsdWdpbi4gUGFzc2VkIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCB3aXRoIGEgcnVsZSBpbnN0YW5jZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXNlID0gZnVuY3Rpb24gdXNlKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIF90aGlzLnBsdWdpbnMudXNlKHBsdWdpbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEpzcztcbn0oKTtcblxuLyoqXG4gKiBFeHRyYWN0cyBhIHN0eWxlcyBvYmplY3Qgd2l0aCBvbmx5IHByb3BzIHRoYXQgY29udGFpbiBmdW5jdGlvbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldER5bmFtaWNTdHlsZXMoc3R5bGVzKSB7XG4gIHZhciB0byA9IG51bGw7XG5cbiAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgIHZhciB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICghdG8pIHRvID0ge307XG4gICAgICB0b1trZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhciBleHRyYWN0ZWQgPSBnZXREeW5hbWljU3R5bGVzKHZhbHVlKTtcblxuICAgICAgaWYgKGV4dHJhY3RlZCkge1xuICAgICAgICBpZiAoIXRvKSB0byA9IHt9O1xuICAgICAgICB0b1trZXldID0gZXh0cmFjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBTaGVldHNNYW5hZ2VyIGlzIGxpa2UgYSBXZWFrTWFwIHdoaWNoIGlzIGRlc2lnbmVkIHRvIGNvdW50IFN0eWxlU2hlZXRcbiAqIGluc3RhbmNlcyBhbmQgYXR0YWNoL2RldGFjaCBhdXRvbWF0aWNhbGx5LlxuICovXG52YXIgU2hlZXRzTWFuYWdlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNoZWV0c01hbmFnZXIoKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuc2hlZXRzID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTaGVldHNNYW5hZ2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuc2hlZXRzLmdldChrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS5zaGVldDtcbiAgfTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKGtleSwgc2hlZXQpIHtcbiAgICBpZiAodGhpcy5zaGVldHMuaGFzKGtleSkpIHJldHVybjtcbiAgICB0aGlzLmxlbmd0aCsrO1xuICAgIHRoaXMuc2hlZXRzLnNldChrZXksIHtcbiAgICAgIHNoZWV0OiBzaGVldCxcbiAgICAgIHJlZnM6IDBcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubWFuYWdlID0gZnVuY3Rpb24gbWFuYWdlKGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuc2hlZXRzLmdldChrZXkpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBpZiAoZW50cnkucmVmcyA9PT0gMCkge1xuICAgICAgICBlbnRyeS5zaGVldC5hdHRhY2goKTtcbiAgICAgIH1cblxuICAgICAgZW50cnkucmVmcysrO1xuICAgICAgcmV0dXJuIGVudHJ5LnNoZWV0O1xuICAgIH1cblxuICAgIHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gU2hlZXRzTWFuYWdlcjogY2FuJ3QgZmluZCBzaGVldCB0byBtYW5hZ2VcIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICBfcHJvdG8udW5tYW5hZ2UgPSBmdW5jdGlvbiB1bm1hbmFnZShrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLnNoZWV0cy5nZXQoa2V5KTtcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgaWYgKGVudHJ5LnJlZnMgPiAwKSB7XG4gICAgICAgIGVudHJ5LnJlZnMtLTtcbiAgICAgICAgaWYgKGVudHJ5LnJlZnMgPT09IDApIGVudHJ5LnNoZWV0LmRldGFjaCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCBcIlNoZWV0c01hbmFnZXI6IGNhbid0IGZpbmQgc2hlZXQgdG8gdW5tYW5hZ2VcIik7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTaGVldHNNYW5hZ2VyLCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoZWV0c01hbmFnZXI7XG59KCk7XG5cbi8qKlxuICogQSBiZXR0ZXIgYWJzdHJhY3Rpb24gb3ZlciBDU1MuXG4gKlxuICogQGNvcHlyaWdodCBPbGVnIElzb25lbiAoU2xvYm9kc2tvaSkgLyBJc29uZW4gMjAxNC1wcmVzZW50XG4gKiBAd2Vic2l0ZSBodHRwczovL2dpdGh1Yi5jb20vY3NzaW5qcy9qc3NcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbi8qKlxuICogRXhwb3J0IGEgY29uc3RhbnQgaW5kaWNhdGluZyBpZiB0aGlzIGJyb3dzZXIgaGFzIENTU1RPTSBzdXBwb3J0LlxuICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxOC8wMy9jc3NvbVxuICovXG52YXIgaGFzQ1NTVE9NU3VwcG9ydCA9IHR5cGVvZiBDU1MgPT09ICdvYmplY3QnICYmIENTUyAhPSBudWxsICYmICdudW1iZXInIGluIENTUztcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBKc3MuXG4gKi9cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSnNzKG9wdGlvbnMpO1xufTtcbi8qKlxuICogQSBnbG9iYWwgSnNzIGluc3RhbmNlLlxuICovXG5cbnZhciBqc3MgPSBjcmVhdGUoKTtcblxuZXhwb3J0IGRlZmF1bHQganNzO1xuZXhwb3J0IHsgUnVsZUxpc3QsIFNoZWV0c01hbmFnZXIsIFNoZWV0c1JlZ2lzdHJ5LCBjcmVhdGUsIGNyZWF0ZUdlbmVyYXRlSWQsIGNyZWF0ZVJ1bGUsIGdldER5bmFtaWNTdHlsZXMsIGhhc0NTU1RPTVN1cHBvcnQsIHJlZ2lzdHJ5IGFzIHNoZWV0cywgdG9Dc3NWYWx1ZSB9O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBwb255ZmlsbCBmcm9tICcuL3BvbnlmaWxsLmpzJztcblxudmFyIHJvb3Q7XG5cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBtb2R1bGU7XG59IGVsc2Uge1xuICByb290ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn1cblxudmFyIHJlc3VsdCA9IHBvbnlmaWxsKHJvb3QpO1xuZXhwb3J0IGRlZmF1bHQgcmVzdWx0O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRTeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFpc1Byb2R1Y3Rpb24pIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRleHQgPSBcIldhcm5pbmc6IFwiICsgbWVzc2FnZTtcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2Fybih0ZXh0KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhyb3cgRXJyb3IodGV4dCk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3YXJuaW5nO1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYiwgbnVsbCwgcmV0KSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLCByZWosIGNiKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWxNb2R1bGUpIHtcblx0aWYgKCFvcmlnaW5hbE1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHR2YXIgbW9kdWxlID0gT2JqZWN0LmNyZWF0ZShvcmlnaW5hbE1vZHVsZSk7XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiZXhwb3J0c1wiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCIvLyBpbXBvcnQgKiBhcyBWaWRlbyBmcm9tICd0d2lsaW8tdmlkZW8nO1xuaW1wb3J0IFZpZGVvIGZyb20gJ3R3aWxpby12aWRlbyc7XG5pbXBvcnQgeyBkZW1vIH0gZnJvbSAnLi9kZW1vJztcblxuZGVtbyhWaWRlbywgZG9jdW1lbnQuYm9keSk7XG5cblxuXG4iLCJleHBvcnQgaW50ZXJmYWNlIElCdXR0b24ge1xuICBidG46IEhUTUxCdXR0b25FbGVtZW50LFxuICBzaG93OiAodmlzaWJsZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgdGV4dDogKG5ld1RleHQ6IHN0cmluZykgPT4gdm9pZDtcbiAgY2xpY2s6ICgpID0+IHZvaWQ7XG4gIGVuYWJsZTogKCkgPT4gdm9pZDtcbiAgZGlzYWJsZTogKCkgPT4gdm9pZDtcbn07XG5cbmltcG9ydCBqc3MgZnJvbSAnLi4vanNzJ1xuXG4vLyBDcmVhdGUgeW91ciBzdHlsZS5cbmNvbnN0IHN0eWxlID0ge1xuICBidXR0b246IHtcbiAgICBoZWlnaHQ6ICcyZW0nLFxuICAgIG1hcmdpbjogJzJweCcsXG4gIH0sXG59XG4vLyBDb21waWxlIHN0eWxlcywgYXBwbHkgcGx1Z2lucy5cbmNvbnN0IHNoZWV0ID0ganNzLmNyZWF0ZVN0eWxlU2hlZXQoc3R5bGUpXG5zaGVldC5hdHRhY2goKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJ1dHRvbih0ZXh0OiBzdHJpbmcsIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIG9uQ2xpY2s6ICgpID0+IHZvaWQpOiBJQnV0dG9uIHtcbiAgY29uc3QgYnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJykgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gIGJ0bi5jbGFzc0xpc3QuYWRkKHNoZWV0LmNsYXNzZXMuYnV0dG9uKTtcbiAgYnRuLmlubmVySFRNTCA9IHRleHQ7XG4gIGJ0bi5vbmNsaWNrID0gb25DbGljaztcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGJ0bik7XG4gIHJldHVybiB7XG4gICAgYnRuLFxuICAgIHNob3c6ICh2aXNpYmxlOiBib29sZWFuKSA9PiB7IGJ0bi5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA/ICdpbmxpbmUtYmxvY2snIDogJ25vbmUnOyB9LFxuICAgIHRleHQ6IChuZXdUZXh0OiBzdHJpbmcpID0+IHsgYnRuLmlubmVySFRNTCA9IG5ld1RleHQ7IH0sXG4gICAgY2xpY2s6ICgpID0+IG9uQ2xpY2soKSxcbiAgICBlbmFibGU6ICgpID0+IHsgYnRuLmRpc2FibGVkID0gZmFsc2U7IH0sXG4gICAgZGlzYWJsZTogKCkgPT4geyBidG4uZGlzYWJsZWQgPSB0cnVlOyB9XG4gIH07XG59XG5cbiIsImltcG9ydCB7IGNyZWF0ZUJ1dHRvbiB9IGZyb20gJy4vYnV0dG9uJztcbmltcG9ydCB7IGNyZWF0ZURpdiB9IGZyb20gJy4vY3JlYXRlRGl2JztcblxuaW1wb3J0IGpzcyBmcm9tICcuLi9qc3MnXG5cbi8vIENyZWF0ZSB5b3VyIHN0eWxlLlxuY29uc3Qgc3R5bGUgPSB7XG4gIHJvb21IZWFkZXJEaXY6IHtcbiAgICBhbGw6ICdmbGV4J1xuICB9LFxuICBkaXNwbGF5Q29udGVudHM6IHtcbiAgICBkaXNwbGF5OiAnY29udGVudHMnXG4gIH0sXG4gIGxlZ2VuZFN0eWxlOiB7XG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICd0ZXh0LWFsaWduJzogJ2xlZnQnLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICBjb2xvcjogJ3doaXRlJyxcbiAgICBwYWRkaW5nOiBcIjNweCA2cHhcIlxuICB9LFxuICBub25Db2xsYXBzZWRTdHlsZToge1xuICAgIC8vIGJvcmRlcjogJ25vbmUnLFxuICAgIHBhZGRpbmc6IDAsXG4gIH0sXG4gIGNvbGxhcHNlZFN0eWxlOiB7XG4gICAgYm9yZGVyOiAnbm9uZScsXG4gICAgcGFkZGluZzogMCxcbiAgfVxufVxuLy8gQ29tcGlsZSBzdHlsZXMsIGFwcGx5IHBsdWdpbnMuXG5jb25zdCBzaGVldCA9IGpzcy5jcmVhdGVTdHlsZVNoZWV0KHN0eWxlKVxuc2hlZXQuYXR0YWNoKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb2xsYXBzaWJsZURpdl8xKHsgY29udGFpbmVyLCBoZWFkZXJUZXh0LCBkaXZDbGFzcyB9IDoge1xuICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICBoZWFkZXJUZXh0OiBzdHJpbmcsXG4gIGRpdkNsYXNzOiBzdHJpbmdbXSB8IHN0cmluZ1xufSkgOiB7IGlubmVyRGl2OiBIVE1MRGl2RWxlbWVudCwgb3V0ZXJEaXY6IEhUTUxEaXZFbGVtZW50IH0ge1xuICBjb25zdCBjb2xsYXBzaWJsZURpdiA9IGNyZWF0ZURpdihjb250YWluZXIsIFsnY29sbGFwc2libGUnXSk7XG4gIGNvbnN0IGhlYWRlckRpdiA9IGNyZWF0ZURpdihjb2xsYXBzaWJsZURpdiwgc2hlZXQuY2xhc3Nlcy5yb29tSGVhZGVyRGl2KTtcbiAgY29uc3QgaW5uZXJEaXYgPSBjcmVhdGVEaXYoY29sbGFwc2libGVEaXYsIGRpdkNsYXNzKTtcbiAgbGV0IGRpc3BsYXkgPSAnbm9uZSc7XG4gIGNvbnN0IHNob3dIaWRlQnV0dG9uID0gY3JlYXRlQnV0dG9uKGAtICR7aGVhZGVyVGV4dH1gLCBoZWFkZXJEaXYsICgpID0+IHtcbiAgICBpZiAoaW5uZXJEaXYuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICBpbm5lckRpdi5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcbiAgICAgIHNob3dIaWRlQnV0dG9uLnRleHQoYC0gJHtoZWFkZXJUZXh0fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNwbGF5ID0gaW5uZXJEaXYuc3R5bGUuZGlzcGxheTtcbiAgICAgIGlubmVyRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBzaG93SGlkZUJ1dHRvbi50ZXh0KGArICR7aGVhZGVyVGV4dH1gKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlubmVyRGl2LFxuICAgIG91dGVyRGl2OiBjb2xsYXBzaWJsZURpdlxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29sbGFwc2libGVEaXZfMih7IGNvbnRhaW5lciwgaGVhZGVyVGV4dCwgZGl2Q2xhc3MsIHN0YXJ0SGlkZGVuID0gZmFsc2UgfSA6IHtcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgaGVhZGVyVGV4dDogc3RyaW5nLFxuICBkaXZDbGFzczogc3RyaW5nW10gfCBzdHJpbmcsXG4gIHN0YXJ0SGlkZGVuPzogYm9vbGVhblxufSkgOiB7IGlubmVyRGl2OiBIVE1MRGl2RWxlbWVudCwgb3V0ZXJEaXY6IEhUTUxGaWVsZFNldEVsZW1lbnQgfSB7XG5cbiAgLy8gTk9URTogb24gc2FmYXJpIC0gaWYgdGhlIGZpZWxkc2V0IGlzIHN0eWxlZCB3aXRoIGRpc3BsYXk6ZmxleCwgdGhlIGxlZ2VuZCBvbkNsaWNrIGRvZXMgbm90IHdvcmsuXG4gIC8vIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBkaXNwbGF5IGZsZXggZnJvbSB0aGVcbiAgY29uc3QgZGl2Q2xhc3NlcyA9IEFycmF5LmlzQXJyYXkoZGl2Q2xhc3MpID8gWy4uLmRpdkNsYXNzLCBzaGVldC5jbGFzc2VzLm5vbkNvbGxhcHNlZFN0eWxlXSA6IFtkaXZDbGFzcywgc2hlZXQuY2xhc3Nlcy5ub25Db2xsYXBzZWRTdHlsZV07XG4gIGNvbnN0IHsgZmllbGRzZXQ6IGNvbGxhcHNpYmxlRGl2LCBsZWdlbmQgfSA9IGNyZWF0ZUZpZWxkU2V0KHsgY29udGFpbmVyLCBoZWFkZXJUZXh0LCBkaXZDbGFzc2VzLCBsZWdlbmRDbGFzc2VzOiBbc2hlZXQuY2xhc3Nlcy5sZWdlbmRTdHlsZV19KTtcblxuXG4gIGxldCBpbm5lckRpdkRpc3BsYXlTdHlsZSA9ICdub25lJztcbiAgbGVnZW5kLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdtYWthcmFuZDogY2xpY2snKTtcbiAgICBpZiAoaW5uZXJEaXYuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAvLyBzaG93XG4gICAgICBpbm5lckRpdi5zdHlsZS5kaXNwbGF5ID0gaW5uZXJEaXZEaXNwbGF5U3R5bGU7XG4gICAgICBjb2xsYXBzaWJsZURpdi5jbGFzc0xpc3QucmVtb3ZlKHNoZWV0LmNsYXNzZXMuY29sbGFwc2VkU3R5bGUpO1xuICAgICAgY29sbGFwc2libGVEaXYuY2xhc3NMaXN0LmFkZCguLi5kaXZDbGFzc2VzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoaWRlXG4gICAgICBpbm5lckRpdkRpc3BsYXlTdHlsZSA9IGlubmVyRGl2LnN0eWxlLmRpc3BsYXk7XG4gICAgICBpbm5lckRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgY29sbGFwc2libGVEaXYuY2xhc3NMaXN0LnJlbW92ZSguLi5kaXZDbGFzc2VzKTtcbiAgICAgIGNvbGxhcHNpYmxlRGl2LmNsYXNzTGlzdC5hZGQoc2hlZXQuY2xhc3Nlcy5jb2xsYXBzZWRTdHlsZSk7XG4gICAgfVxuICB9KVxuICBjb25zdCBpbm5lckRpdiA9IGNyZWF0ZURpdihjb2xsYXBzaWJsZURpdiwgW3NoZWV0LmNsYXNzZXMuZGlzcGxheUNvbnRlbnRzXSk7XG4gIGlubmVyRGl2RGlzcGxheVN0eWxlID0gaW5uZXJEaXYuc3R5bGUuZGlzcGxheTtcbiAgaWYgKHN0YXJ0SGlkZGVuKSB7XG4gICAgbGVnZW5kLmNsaWNrKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpbm5lckRpdixcbiAgICBvdXRlckRpdjogY29sbGFwc2libGVEaXZcbiAgfTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29sbGFwc2libGVEaXYoeyBjb250YWluZXIsIGhlYWRlclRleHQsIGRpdkNsYXNzLCBzdGFydEhpZGRlbiA9IGZhbHNlIH0gOiB7XG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gIGhlYWRlclRleHQ6IHN0cmluZyxcbiAgZGl2Q2xhc3M6IHN0cmluZ1tdIHwgc3RyaW5nLFxuICBzdGFydEhpZGRlbj86IGJvb2xlYW5cbn0pIDogeyBpbm5lckRpdjogSFRNTERpdkVsZW1lbnQsIG91dGVyRGl2OiBIVE1MRmllbGRTZXRFbGVtZW50IH0ge1xuXG4gIC8vIE5PVEU6IG9uIHNhZmFyaSAtIGlmIHRoZSBmaWVsZHNldCBpcyBzdHlsZWQgd2l0aCBkaXNwbGF5OmZsZXgsIHRoZSBsZWdlbmQgb25DbGljayBkb2VzIG5vdCB3b3JrLlxuICAvLyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgZGlzcGxheSBmbGV4IGZyb20gdGhlXG4gIGNvbnN0IGRpdkNsYXNzZXMgPSBBcnJheS5pc0FycmF5KGRpdkNsYXNzKSA/IFsuLi5kaXZDbGFzc10gOiBbZGl2Q2xhc3MsIHNoZWV0LmNsYXNzZXMubm9uQ29sbGFwc2VkU3R5bGVdO1xuICBjb25zdCB7IGZpZWxkc2V0OiBjb2xsYXBzaWJsZURpdiwgbGVnZW5kIH0gPSBjcmVhdGVGaWVsZFNldCh7IGNvbnRhaW5lciwgaGVhZGVyVGV4dDogYC0gJHtoZWFkZXJUZXh0fWAsIGRpdkNsYXNzZXM6W3NoZWV0LmNsYXNzZXMubm9uQ29sbGFwc2VkU3R5bGVdLCBsZWdlbmRDbGFzc2VzOiBbc2hlZXQuY2xhc3Nlcy5sZWdlbmRTdHlsZV19KTtcblxuXG4gIGxldCBpbm5lckRpdkRpc3BsYXlTdHlsZSA9ICdub25lJztcbiAgbGVnZW5kLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIGlmIChpbm5lckRpdi5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgIC8vIHNob3dcbiAgICAgIGlubmVyRGl2LnN0eWxlLmRpc3BsYXkgPSBpbm5lckRpdkRpc3BsYXlTdHlsZTtcbiAgICAgIGNvbGxhcHNpYmxlRGl2LmNsYXNzTGlzdC5yZW1vdmUoc2hlZXQuY2xhc3Nlcy5jb2xsYXBzZWRTdHlsZSk7XG4gICAgICBjb2xsYXBzaWJsZURpdi5jbGFzc0xpc3QuYWRkKHNoZWV0LmNsYXNzZXMubm9uQ29sbGFwc2VkU3R5bGUpO1xuICAgICAgbGVnZW5kLmlubmVySFRNTCA9IGAtICR7aGVhZGVyVGV4dH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoaWRlXG4gICAgICBpbm5lckRpdkRpc3BsYXlTdHlsZSA9IGlubmVyRGl2LnN0eWxlLmRpc3BsYXk7XG4gICAgICBpbm5lckRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgY29sbGFwc2libGVEaXYuY2xhc3NMaXN0LnJlbW92ZShzaGVldC5jbGFzc2VzLm5vbkNvbGxhcHNlZFN0eWxlKTtcbiAgICAgIGNvbGxhcHNpYmxlRGl2LmNsYXNzTGlzdC5hZGQoc2hlZXQuY2xhc3Nlcy5jb2xsYXBzZWRTdHlsZSk7XG4gICAgICBsZWdlbmQuaW5uZXJIVE1MID0gYCsgJHtoZWFkZXJUZXh0fWA7XG4gICAgfVxuICB9KVxuICBjb25zdCBpbm5lckRpdiA9IGNyZWF0ZURpdihjb2xsYXBzaWJsZURpdiwgZGl2Q2xhc3Nlcyk7XG4gIGlubmVyRGl2RGlzcGxheVN0eWxlID0gaW5uZXJEaXYuc3R5bGUuZGlzcGxheTtcbiAgaWYgKHN0YXJ0SGlkZGVuKSB7XG4gICAgbGVnZW5kLmNsaWNrKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpbm5lckRpdixcbiAgICBvdXRlckRpdjogY29sbGFwc2libGVEaXZcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpZWxkU2V0KHsgY29udGFpbmVyLCBoZWFkZXJUZXh0LCBkaXZDbGFzc2VzLCBsZWdlbmRDbGFzc2VzID0gW10gfSA6IHtcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgaGVhZGVyVGV4dDogc3RyaW5nLFxuICBkaXZDbGFzc2VzOiBzdHJpbmdbXSxcbiAgbGVnZW5kQ2xhc3Nlcz86IHN0cmluZ1tdLFxufSk6IHsgZmllbGRzZXQ6IEhUTUxGaWVsZFNldEVsZW1lbnQ7IGxlZ2VuZDogSFRNTExlZ2VuZEVsZW1lbnQ7IH0gIHtcbiAgY29uc3QgZmllbGRzZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpO1xuICBjb25zdCBsZWdlbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGVnZW5kXCIpO1xuICBsZWdlbmQuaW5uZXJIVE1MID0gaGVhZGVyVGV4dDtcbiAgbGVnZW5kLmNsYXNzTGlzdC5hZGQoLi4ubGVnZW5kQ2xhc3Nlcyk7XG4gIGZpZWxkc2V0LmFwcGVuZENoaWxkKGxlZ2VuZCk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWVsZHNldCk7XG4gIGZpZWxkc2V0LmNsYXNzTGlzdC5hZGQoLi4uZGl2Q2xhc3Nlcyk7XG4gIHJldHVybiB7IGZpZWxkc2V0LCBsZWdlbmQgfTtcbn1cblxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4vY3JlYXRlRWxlbWVudCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEaXYoY29udGFpbmVyOiBIVE1MRWxlbWVudCwgZGl2Q2xhc3M6IHN0cmluZ1tdIHwgc3RyaW5nLCBpZD86IHN0cmluZyk6IEhUTUxEaXZFbGVtZW50IHtcbiAgZGl2Q2xhc3MgPSBBcnJheS5pc0FycmF5KGRpdkNsYXNzKSA/IGRpdkNsYXNzIDogW2RpdkNsYXNzXTtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoeyBjb250YWluZXIsIHR5cGU6ICdkaXYnLCBjbGFzc05hbWVzOiBkaXZDbGFzcywgaWQgfSkgYXMgSFRNTERpdkVsZW1lbnQ7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh7IGNvbnRhaW5lciwgdHlwZSwgaWQsIGNsYXNzTmFtZXMsIHN0eWxlLCBpbm5lckh0bWwgfToge1xuICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICB0eXBlOiBzdHJpbmcsXG4gIGlkPzogc3RyaW5nXG4gIGNsYXNzTmFtZXM/OiBzdHJpbmdbXSxcbiAgc3R5bGU/OiBzdHJpbmcsXG4gIGlubmVySHRtbD86IHN0cmluZyxcbn0pOiBIVE1MRWxlbWVudCB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgaWYgKGlkKSB7XG4gICAgZWwuaWQgPSBpZDtcbiAgfVxuICBpZiAoY2xhc3NOYW1lcykge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3NOYW1lcyk7XG4gIH1cblxuICBpZiAoc3R5bGUpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgc3R5bGUpO1xuICB9XG5cbiAgaWYgKGlubmVySHRtbCkge1xuICAgIGVsLmlubmVySFRNTCA9IGlubmVySHRtbDtcbiAgfVxuXG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gIHJldHVybiBlbDtcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuL2NyZWF0ZUVsZW1lbnQnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGFiZWxlZENoZWNrYm94KHsgY29udGFpbmVyLCBsYWJlbFRleHQsIGlkIH0gOiB7XG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gIGxhYmVsVGV4dDogc3RyaW5nLFxuICBpZDogc3RyaW5nLFxufSk6IEhUTUxJbnB1dEVsZW1lbnQge1xuICBjb25zdCBjaGVja2JveCA9IGNyZWF0ZUVsZW1lbnQoeyBjb250YWluZXIsIHR5cGU6ICdpbnB1dCcsIGlkIH0pIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gIGNoZWNrYm94LnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuXG4gIGNvbnN0IGxhYmVsID0gY3JlYXRlRWxlbWVudCh7IGNvbnRhaW5lciwgdHlwZTogJ2xhYmVsJywgaW5uZXJIdG1sOiBsYWJlbFRleHR9KTtcbiAgbGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCBpZCk7XG4gIHJldHVybiBjaGVja2JveDtcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuL2NyZWF0ZUVsZW1lbnQnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGFiZWxlZElucHV0KHsgY29udGFpbmVyLCBsYWJlbFRleHQsIHBsYWNlSG9sZGVyLCBpbml0aWFsVmFsdWUsIGxhYmVsQ2xhc3NlcyA9IFtdLCBpbnB1dFR5cGUgPSAnaW5wdXQnLCBpbnB1dENsYXNzZXMgPSBbXSB9OiB7XG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gIGxhYmVsVGV4dDogc3RyaW5nIHwgSFRNTEVsZW1lbnQsXG4gIHBsYWNlSG9sZGVyOiBzdHJpbmcsXG4gIGluaXRpYWxWYWx1ZT86IHN0cmluZyxcbiAgbGFiZWxDbGFzc2VzPzogc3RyaW5nW10sXG4gIGlucHV0VHlwZT86IHN0cmluZyxcbiAgaW5wdXRDbGFzc2VzPzpzdHJpbmdbXVxufSkgOiBIVE1MSW5wdXRFbGVtZW50IHtcbiAgbGV0IGlkZW50aXR5TGFiZWwgPSBudWxsO1xuICBpZiAodHlwZW9mIGxhYmVsVGV4dCA9PT0gJ3N0cmluZycpICB7XG4gICAgaWRlbnRpdHlMYWJlbCA9IGNyZWF0ZUVsZW1lbnQoeyBjb250YWluZXIsIHR5cGU6ICdsYWJlbCcsIGNsYXNzTmFtZXM6IGxhYmVsQ2xhc3NlcywgaW5uZXJIdG1sOiBsYWJlbFRleHQgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWRlbnRpdHlMYWJlbCA9IGxhYmVsVGV4dDtcbiAgfVxuXG5cbiAgY29uc3QgaW5wdXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudCh7IGNvbnRhaW5lciwgdHlwZTogaW5wdXRUeXBlLCBjbGFzc05hbWVzOiBpbnB1dENsYXNzZXMgfSkgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgaW5wdXRFbGVtZW50LnBsYWNlaG9sZGVyID0gcGxhY2VIb2xkZXI7XG4gIGlmIChpbml0aWFsVmFsdWUpIHtcbiAgICBpbnB1dEVsZW1lbnQudmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIH1cblxuICByZXR1cm4gaW5wdXRFbGVtZW50O1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4vY3JlYXRlRWxlbWVudCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaW5rKHsgY29udGFpbmVyLCBsaW5rVGV4dCwgbGlua1VybCwgbmV3VGFiID0gZmFsc2UgfSA6IHtcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgbGlua1RleHQ6IHN0cmluZyxcbiAgbGlua1VybDogc3RyaW5nLFxuICBuZXdUYWI/IDogYm9vbGVhblxufSkgOiBIVE1MQW5jaG9yRWxlbWVudCB7XG4gIHZhciBhID0gY3JlYXRlRWxlbWVudCh7IGNvbnRhaW5lciwgdHlwZTogJ2EnIH0pIGFzIEhUTUxBbmNob3JFbGVtZW50O1xuICBhLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmtUZXh0KSk7XG4gIGEudGl0bGUgPSBsaW5rVGV4dDtcbiAgYS5ocmVmID0gbGlua1VybDtcbiAgaWYgKG5ld1RhYikge1xuICAgIGEudGFyZ2V0ID0gJ19ibGFuayc7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG4iLCJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb24oeyBpZCwgY29udGFpbmVyLCBvcHRpb25zID0gWydkb2cnLCAnY2F0JywgJ3BhcnJvdCcsICdyYWJiaXQnXSwgdGl0bGUgPSAnUGV0cycsIGxhYmVsQ2xhc3NlcyA9IFtdLCBvbkNoYW5nZSA9ICgpID0+IHsgfSB9OiB7XG4gIGlkPzogc3RyaW5nLFxuICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICBvcHRpb25zOiBzdHJpbmdbXSxcbiAgdGl0bGU6IHN0cmluZyxcbiAgbGFiZWxDbGFzc2VzPzogc3RyaW5nW10sXG4gIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xufSkge1xuICBjb25zdCBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgaWYgKGlkKSB7XG4gICAgc2VsZWN0LmlkID0gaWQ7XG4gIH1cblxuICBmb3IgKGNvbnN0IHZhbCBvZiBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgb3B0aW9uLnZhbHVlID0gdmFsO1xuICAgIG9wdGlvbi50ZXh0ID0gdmFsO1xuICAgIHNlbGVjdC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICB9XG5cbiAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICBsYWJlbC5pbm5lckhUTUwgPSB0aXRsZTtcbiAgbGFiZWwuaHRtbEZvciA9IHNlbGVjdC5pZDtcbiAgbGFiZWwuY2xhc3NMaXN0LmFkZCguLi5sYWJlbENsYXNzZXMpO1xuXG4gIHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG5cbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKS5hcHBlbmRDaGlsZChzZWxlY3QpO1xuICByZXR1cm4ge1xuICAgIHNlbGVjdCxcbiAgICBnZXRWYWx1ZTogKCkgPT4geyByZXR1cm4gc2VsZWN0LnZhbHVlOyB9LFxuICAgIHNldFZhbHVlOiAodmFsdWU6IHN0cmluZykgPT4geyBzZWxlY3QudmFsdWUgPSB2YWx1ZTsgLyogbm90IGlmIHRoZSB2YWx1ZSBpcyBub3Qgb25lIG9mIHRoZSBvcHRpb25zIHRoZW4gYSBibGFuayB2YWx1ZSBnZXRzIHNlbGVjdGVkICovIH1cbiAgfTtcbn1cbiIsImxldCBhdWRpb0NvbnRleHQ6IEF1ZGlvQ29udGV4dCB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXVkaW9Db250ZXh0KCk6IEF1ZGlvQ29udGV4dCB7XG4gIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgYXVkaW9Db250ZXh0ID0gdHlwZW9mIEF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gbmV3IEF1ZGlvQ29udGV4dCgpXG4gICAgICA6IG5ldyAod2luZG93IGFzIGFueSkud2Via2l0QXVkaW9Db250ZXh0KCk7XG5cbiAgfVxuICBpZiAoIWF1ZGlvQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSBhdWRpb0NvbnRleHQnKTtcbiAgfVxuXG4gIHJldHVybiBhdWRpb0NvbnRleHQ7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0Qm9vbGVhblVybFBhcmFtKHBhcmFtTmFtZTogc3RyaW5nLCBkZWZhdWx0VmFsdWU6IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgaWYgKHVybFBhcmFtcy5oYXMocGFyYW1OYW1lKSkge1xuICAgIGNvbnN0IHBhcmFtVmFsdWUgPSB1cmxQYXJhbXMuZ2V0KHBhcmFtTmFtZSk7XG4gICAgaWYgKHBhcmFtVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIGlmIChwYXJhbVZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gd2hlbiB1cmw9d3d3LmZvby5jb20/YXV0b0pvaW4mYmFyXG4gICAgICAvLyB1cmxQYXJhbXMuZ2V0KCdhdXRvSm9pbicpIHJldHVybnMgJydcbiAgICAgIC8vID9hdXRvSm9pbiZmb28gc2hvdWxkIHJldHVybiBhdXRvSm9pbiA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFwYXJhbVZhbHVlIHx8IHBhcmFtVmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ZhbHNlJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cblxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4vY3JlYXRlRWxlbWVudCc7XG5cbmltcG9ydCBqc3MgZnJvbSAnLi4vanNzJ1xuXG4vLyBDcmVhdGUgeW91ciBzdHlsZS5cbmNvbnN0IHN0eWxlID0ge1xuICBsYWJlbGVkU3RhdDoge1xuICAgIGJhY2tncm91bmQ6ICdzb2xpZCBncmVlbiAycHgnLFxuICAgIG1hcmdpbjogJzJweCdcbiAgfSxcbn1cbi8vIENvbXBpbGUgc3R5bGVzLCBhcHBseSBwbHVnaW5zLlxuY29uc3Qgc2hlZXQgPSBqc3MuY3JlYXRlU3R5bGVTaGVldChzdHlsZSlcbnNoZWV0LmF0dGFjaCgpO1xuXG5leHBvcnQgaW50ZXJmYWNlIElMYWJlbGVkU3RhdCB7XG4gIHNldFRleHQ6ICh0ZXh0OiBzdHJpbmcpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGFiZWxlZFN0YXQoeyBjb250YWluZXIsIGxhYmVsLCBpZCwgdmFsdWVNYXBwZXIgfSA6IHtcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgbGFiZWw6IHN0cmluZyxcbiAgaWQ/IDogc3RyaW5nLFxuICB2YWx1ZU1hcHBlcj86ICh0ZXh0OiBzdHJpbmcpID0+IHN0cmluZ3x1bmRlZmluZWRcbn0pIHtcbiAgY29uc3QgY2xhc3NOYW1lcyA9IFtzaGVldC5jbGFzc2VzLmxhYmVsZWRTdGF0XTtcbiAgY29uc3QgZWwgPSBjcmVhdGVFbGVtZW50KHtjb250YWluZXIsIHR5cGU6ICdwJywgaWQsIGNsYXNzTmFtZXMgfSk7XG4gIGxldCBsYXN0Q2xhc3M6IHN0cmluZ3x1bmRlZmluZWQ7XG4gIHJldHVybiB7XG4gICAgZWxlbWVudDogZWwsXG4gICAgc2V0TGFiZWw6IChuZXdMYWJlbDogc3RyaW5nKSA9PiB7XG4gICAgICBsYWJlbCA9IG5ld0xhYmVsO1xuICAgIH0sXG4gICAgc2V0VGV4dDogKHRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgaWYgKGxhc3RDbGFzcykge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGxhc3RDbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGVsLnRleHRDb250ZW50ID0gbGFiZWwgKyAnOiAnICsgdGV4dDtcblxuICAgICAgaWYgKHZhbHVlTWFwcGVyKSB7XG4gICAgICAgIGxhc3RDbGFzcyA9IHZhbHVlTWFwcGVyKHRleHQpO1xuICAgICAgICBpZiAobGFzdENsYXNzKSB7XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChsYXN0Q2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuaW1wb3J0IHsgY3JlYXRlQnV0dG9uIH0gZnJvbSAnLi9idXR0b24nO1xuXG5pbXBvcnQganNzIGZyb20gJy4uL2pzcydcblxuLy8gQ3JlYXRlIHlvdXIgc3R5bGUuXG5jb25zdCBzdHlsZSA9IHtcbiAgbG9nRGl2OiB7XG4gICAgaGVpZ2h0OiAnMTVlbScsXG4gICAgcGFkZGluZzogJzEuNWVtJyxcbiAgICAnbWluLWhlaWdodCc6ICcxMDAlJyxcbiAgICAnbWF4LWhlaWdodCc6ICcxMDAlJyxcbiAgICAnbWFyZ2luLXRvcCc6ICczLjEyNWVtJyxcbiAgICAndGV4dC1hbGlnbic6ICdsZWZ0JyxcbiAgICAnb3ZlcmZsb3cteSc6ICdzY3JvbGwnLFxuICB9LFxuICBsb2dQOiB7XG4gICAgY29sb3I6ICcjNjg2ODY1JyxcbiAgICB3aWR0aDogJzkwJScsXG4gICAgJ2ZvbnQtZmFtaWx5JzogJ1xcJ1NoYXJlIFRlY2ggTW9ub1xcJywgXFwnQ291cmllciBOZXdcXCcsIENvdXJpZXIsIGZpeGVkLXdpZHRoJyxcbiAgICAnZm9udC1zaXplJzogJzEuMjVlbScsXG4gICAgJ2xpbmUtaGVpZ2h0JzogJzEuMjVlbScsXG4gICAgJ21hcmdpbi1sZWZ0JzogJzFlbScsXG4gICAgJ3RleHQtaW5kZW50JzogJy0xLjI1ZW0nLFxuXG4gICAgfVxufVxuLy8gQ29tcGlsZSBzdHlsZXMsIGFwcGx5IHBsdWdpbnMuXG5jb25zdCBzaGVldCA9IGpzcy5jcmVhdGVTdHlsZVNoZWV0KHN0eWxlKVxuc2hlZXQuYXR0YWNoKCk7XG5cbmxldCBsb2dDbGVhckJ0bjogeyBidG46IEhUTUxCdXR0b25FbGVtZW50OyBzaG93OiAodmlzaWJsZTogYm9vbGVhbikgPT4gdm9pZDsgdGV4dDogKG5ld1RleHQ6IHN0cmluZykgPT4gdm9pZDsgY2xpY2s6ICgpID0+IHZvaWQ7IGVuYWJsZTogKCkgPT4gdm9pZDsgZGlzYWJsZTogKCkgPT4gdm9pZDsgfTtcbmxldCByZWFsTG9nRGl2OiBIVE1MRGl2RWxlbWVudDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMb2cobG9nRGl2PyA6IEhUTUxFbGVtZW50KSB7XG4gIGlmICghbG9nQ2xlYXJCdG4pIHtcbiAgICBpZiAoIWxvZ0Rpdikge1xuICAgICAgbG9nRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBsb2dEaXYuY2xhc3NMaXN0LmFkZChzaGVldC5jbGFzc2VzLmxvZ0Rpdik7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxvZ0Rpdik7XG4gICAgfVxuICAgIGxvZ0NsZWFyQnRuID0gY3JlYXRlQnV0dG9uKCdjbGVhciBsb2cnLCBsb2dEaXYsICgpID0+IHtcbiAgICAgIHJlYWxMb2dEaXYuaW5uZXJIVE1MID0gJyc7XG4gICAgfSk7XG5cbiAgICByZWFsTG9nRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbG9nRGl2LmFwcGVuZENoaWxkKHJlYWxMb2dEaXYpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2coLi4uYXJnczogYW55W10pIHtcbiAgY3JlYXRlTG9nKCk7XG4gIGNvbnN0IG1lc3NhZ2UgPSBhcmdzLm1hcChhcmcgPT4gU3RyaW5nKGFyZykpLmpvaW4oJywgJyk7XG4gIHJlYWxMb2dEaXYuaW5uZXJIVE1MICs9ICc8cD4nICsgbWVzc2FnZSAgKyAnPC9wPic7XG4gIHJlYWxMb2dEaXYuc2Nyb2xsVG9wID0gcmVhbExvZ0Rpdi5zY3JvbGxIZWlnaHQ7XG4gIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xufVxuIiwiaW1wb3J0IHsgZ2V0QXVkaW9Db250ZXh0IH0gZnJvbSAnLi9nZXRBdWRpb0NvbnRleHQnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuXG5pbnRlcmZhY2UgTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZSBleHRlbmRzIEF1ZGlvTm9kZSB7XG4gIHN0cmVhbTogTWVkaWFTdHJlYW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzeW50aGV0aWNBdWRpbygpIHtcbiAgY29uc3QgYXVkaW9Db250ZXh0ID0gZ2V0QXVkaW9Db250ZXh0KCk7XG4gIGNvbnN0IG9zY2lsbGF0b3IgPSBhdWRpb0NvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuICBjb25zdCBkc3QgPSBvc2NpbGxhdG9yLmNvbm5lY3QoYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKSkgYXMgTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZTtcbiAgb3NjaWxsYXRvci5zdGFydCgpO1xuICBjb25zdCB0cmFjayA9IGRzdC5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXTtcbiAgY29uc3Qgb3JpZ2luYWxTdG9wID0gdHJhY2suc3RvcDtcbiAgdHJhY2suc3RvcCA9ICgpID0+IHtcbiAgICBvcmlnaW5hbFN0b3AuY2FsbCh0cmFjayk7XG4gIH07XG4gIHJldHVybiB0cmFjaztcbn1cbiIsImludGVyZmFjZSBDYW52YXNFbGVtZW50IGV4dGVuZHMgSFRNTENhbnZhc0VsZW1lbnQge1xuICBjYXB0dXJlU3RyZWFtKGZyYW1lUmF0ZT86IG51bWJlcik6IE1lZGlhU3RyZWFtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ludGhldGljVmlkZW8oeyB3aWR0aCA9IDY0MCwgaGVpZ2h0ID0gNDgwLCB3b3JkID0gJ2hlbGxvJyB9ID0ge30pIHtcblxuICBjb25zdCBjYW52YXMgPSBPYmplY3QuYXNzaWduKFxuICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLCB7IHdpZHRoLCBoZWlnaHQgfVxuICApIGFzIENhbnZhc0VsZW1lbnQ7XG5cbiAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgY3R4LmZpbGxTdHlsZSA9ICdncmVlbic7XG4gIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAvLyBjb25zdCB3b3JkV2lkdGggPSBjdHgubWVhc3VyZVRleHQod29yZCkud2lkdGg7XG4gIGxldCByID0gMDtcbiAgbGV0IGkgPSAwO1xuICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICByICs9IE1hdGguUEkgLyAxODA7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZShjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMik7XG4gICAgY3R4LnJvdGF0ZShyKTtcbiAgICBjdHguZm9udCA9ICczMHB4IFZlcmRhbmEnO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjdHguZmlsbFRleHQoYCR7d29yZH0tJHtpfWAsIDAsIDApO1xuICAgIGkrKztcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHN0cmVhbSA9IGNhbnZhcy5jYXB0dXJlU3RyZWFtKDEwKTtcbiAgY29uc3QgdHJhY2sgPSAgc3RyZWFtLmdldFRyYWNrcygpWzBdO1xuICBjb25zdCBvcmlnaW5hbFN0b3AgPSB0cmFjay5zdG9wO1xuICB0cmFjay5zdG9wID0gKCkgPT4ge1xuICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgIG9yaWdpbmFsU3RvcC5jYWxsKHRyYWNrKTtcbiAgfTtcbiAgcmV0dXJuIHRyYWNrO1xufVxuIiwiaW1wb3J0IHsgZ2V0QXVkaW9Db250ZXh0IH0gZnJvbSAnLi9nZXRBdWRpb0NvbnRleHQnO1xuY29uc3QgRkZUX1NJWkUgPSA1MTI7XG5cbmltcG9ydCBqc3MgZnJvbSAnLi4vanNzJ1xuXG4vLyBDcmVhdGUgeW91ciBzdHlsZS5cbmNvbnN0IHN0eWxlID0ge1xuICBiYWNrZ3JvdW5kX2dyYXk6IHtcbiAgICBiYWNrZ3JvdW5kOiAnI2JiYmJiYidcbiAgfVxufVxuLy8gQ29tcGlsZSBzdHlsZXMsIGFwcGx5IHBsdWdpbnMuXG5jb25zdCBzaGVldCA9IGpzcy5jcmVhdGVTdHlsZVNoZWV0KHN0eWxlKVxuc2hlZXQuYXR0YWNoKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXZlZm9ybSh7IHdpZHRoID0gMjAwLCBoZWlnaHQgPSAxNTAsIG1lZGlhU3RyZWFtIH06IHsgbWVkaWFTdHJlYW06IE1lZGlhU3RyZWFtLCB3aWR0aD86IG51bWJlciwgaGVpZ2h0PzogbnVtYmVyIH0pIHtcbiAgbGV0IHN0b3BwZWQgPSBmYWxzZTtcbiAgY29uc3QgY2FudmFzID0gT2JqZWN0LmFzc2lnbihkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSwgeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICBjYW52YXMuY2xhc3NMaXN0LmFkZChzaGVldC5jbGFzc2VzLmJhY2tncm91bmRfZ3JheSk7XG5cbiAgLy8gVG8gbWFuaXB1bGF0ZSB0aGUgY2FudmFzLCB3ZSB1c2UgaXRzIGNvbnRleHQuIFRoZSBjYW52YXMgcmVmZXJzIHRvIHRoZSBET00gZWxlbWVudCBpdHNlbGYsXG4gIC8vIHdoaWxlIHRoZSBjYW52YXMgcmVmZXJzIHRvIHRoZSB1bmRlcmx5aW5nIGltcGxlbWVudGF0aW9uIHdoaWNoIGNhbiBiZSBkcmF3biB0by5cbiAgY29uc3QgY2FudmFzQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgY2FudmFzQ29udGV4dC5saW5lV2lkdGggPSA0O1xuICBjYW52YXNDb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYigwLCAwLCAwKSc7XG5cbiAgLy8gV2Ugd2lsbCBnZXQgdGhlIGZyZXF1ZW5jeSBkYXRhIGJ5IHVzaW5nIGFuIEFuYWx5c2VyTm9kZSwgYSBmZWF0dXJlIG9mIHRoZSBBdWRpb0NvbnRleHQgQVBJcy5cbiAgY29uc3QgYXVkaW9Db250ZXh0ID0gZ2V0QXVkaW9Db250ZXh0KCk7XG4gIGNvbnN0IGFuYWx5c2VyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG5cbiAgLy8gVGhlIEZGVCAoZmFzdCBmb3VyaWVyIHRyYW5zZm9ybSkgdGFrZXMgYSBzaXplIHBhcmFtZXRlciwgd2hpY2ggZGV0ZXJtaW5lcyBob3cgbWFueSBmcmVxdWVuY3lcbiAgLy8gYmlucyB0aGUgYXVkaW8gaXMgZGlzc2VjdGVkIGludG8uIEVhY2ggZnJhbWUsIHdlIHdpbGwgYW5hbHl6ZSB0aGUgYXVkaW8sIGFuZCBBbmFseXNlck5vZGVcbiAgLy8gd2lsbCB1cGRhdGUgb3VyIGJ1ZmZlciBhcnJheS4gV2UgY2FuIHRoZW4gaW5zcGVjdCB0aGUgYXJyYXkgdG8gc2VlIGFuZCByZW5kZXIgdGhlIHNwZWNpZmljXG4gIC8vIGRhdGEgdmFsdWVzLlxuICBhbmFseXNlci5mZnRTaXplID0gRkZUX1NJWkU7XG4gIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBVaW50OEFycmF5KGFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50KTtcblxuICBmdW5jdGlvbiByZW5kZXJGcmFtZSgpIHtcbiAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlckxlbmd0aCA9IGFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50O1xuICAgIGNvbnN0IGNhbnZhc0N0eCA9IGNhbnZhc0NvbnRleHQ7XG5cbiAgICAvLyBBc2sgdGhlIGJyb3dzZXIgdG8gcnVuIHRoaXMgZnVuY3Rpb24gYWdhaW4gb24gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLiBUaGUgZnJhbWVzXG4gICAgLy8gZHJhd24gcGVyIHNlY29uZCBoZXJlIGRlcGVuZCBvbiBicm93c2VyLCBidXQgZ2VuZXJhbGx5IHRoaXMgaXMgMzAgb3IgNjAgZnBzLlxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJGcmFtZSk7XG5cbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgZnJlcXVlbmN5IGRhdGEgZnJvbSB0aGUgYXVkaW8gc3RyZWFtLlxuICAgIGFuYWx5c2VyLmdldEJ5dGVUaW1lRG9tYWluRGF0YShkYXRhQXJyYXkpO1xuXG4gICAgLy8gUmVzZXQgdGhlIGNhbnZhc1xuICAgIGNhbnZhc0N0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjYW52YXNDdHguYmVnaW5QYXRoKCk7XG5cbiAgICAvLyBFYWNoIGJ5dGUgb2YgZnJlcXVlbmN5IHdpbGwgYmUgZHJhd24gdG8gdGhlIGNhbnZhcywgc28gZWFjaCBieXRlIG9mIGZyZXF1ZW5jeSByZXByZXNlbnRzXG4gICAgLy8gYSBjZXJ0YWluIHNsaWNlIG9mIHRoZSBmdWxsIHdpZHRoIG9mIHRoZSBjYW52YXMuXG4gICAgdmFyIHNsaWNlV2lkdGggPSB3aWR0aCAvIGJ1ZmZlckxlbmd0aDtcblxuICAgIC8vIEZvciBlYWNoIGJ5dGUgb2YgZnJlcXVlbmN5LCBkcmF3IGEgc2xpY2UgdG8gdGhlIGNhbnZhcy4gVG9nZXRoZXIsIHRoZSBjYW52YXMgd2lsbCBiZVxuICAgIC8vIGNvdmVyZWQgYnkgdGhlIHJlc3VsdGluZyBzbGljZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgIHZhciB4ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlckxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdiA9IGRhdGFBcnJheVtpXSAvIDEyOC4wO1xuICAgICAgdiAqPSB2O1xuICAgICAgdmFyIHkgPSB2ICogaGVpZ2h0IC8gMjtcblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgY2FudmFzQ3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhc0N0eC5saW5lVG8oeCwgeSk7XG4gICAgICB9XG5cbiAgICAgIHggKz0gc2xpY2VXaWR0aDtcbiAgICB9XG5cbiAgICAvLyBFbmQgdGhlIGxpbmUgYXQgdGhlIG1pZGRsZSByaWdodCwgYW5kIGRyYXcgdGhlIGxpbmUuXG4gICAgY2FudmFzQ3R4LmxpbmVUbyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgLyAyKTtcbiAgICBjYW52YXNDdHguc3Ryb2tlKCk7XG4gIH1cblxuICBhdWRpb0NvbnRleHQucmVzdW1lKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAvLyBDcmVhdGUgYSBuZXcgYXVkaW8gc291cmNlIGZvciB0aGUgcGFzc2VkIHN0cmVhbSwgYW5kIGNvbm5lY3QgaXQgdG8gdGhlIGFuYWx5c2VyLlxuICAgIGNvbnN0IGF1ZGlvU291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG1lZGlhU3RyZWFtKTtcbiAgICBhdWRpb1NvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgICAgLy8gU3RhcnQgdGhlIHJlbmRlciBsb29wXG4gICAgcmVuZGVyRnJhbWUoKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBlbGVtZW50OiBjYW52YXMsXG4gICAgc3RvcDogKCk6IHZvaWQgPT4ge1xuICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbmltcG9ydCB7IGNyZWF0ZUJ1dHRvbiwgSUJ1dHRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9idXR0b24nO1xuaW1wb3J0IHsgY3JlYXRlRGl2IH0gZnJvbSAnLi9jb21wb25lbnRzL2NyZWF0ZURpdic7XG5pbXBvcnQgeyBzeW50aGV0aWNBdWRpbyB9IGZyb20gJy4vY29tcG9uZW50cy9zeW50aGV0aWNhdWRpbyc7XG5pbXBvcnQgeyBzeW50aGV0aWNWaWRlbyB9ICBmcm9tICcuL2NvbXBvbmVudHMvc3ludGhldGljdmlkZW8nO1xuXG5pbXBvcnQgeyBnZXRCb29sZWFuVXJsUGFyYW0gfSBmcm9tICcuL2NvbXBvbmVudHMvZ2V0Qm9vbGVhblVybFBhcmFtJztcbmltcG9ydCB7IGdldERldmljZVNlbGVjdGlvbk9wdGlvbnMgfSBmcm9tICcuL2dldERldmljZVNlbGVjdGlvbk9wdGlvbnMnO1xuaW1wb3J0IHsgSVJlbmRlcmVkTG9jYWxUcmFjaywgcmVuZGVyTG9jYWxUcmFjayB9IGZyb20gJy4vcmVuZGVyTG9jYWxUcmFjayc7XG5pbXBvcnQgeyBSb29tLCBMb2NhbFRyYWNrLCBMb2NhbEF1ZGlvVHJhY2ssIExvY2FsVmlkZW9UcmFjaywgVHJhY2sgfSBmcm9tICd0d2lsaW8tdmlkZW8nO1xuXG5pbXBvcnQganNzIGZyb20gJy4vanNzJ1xuXG50eXBlIGxvY2FsVHJhY2sgPSBMb2NhbEF1ZGlvVHJhY2sgfCBMb2NhbFZpZGVvVHJhY2s7XG5cbi8vIENyZWF0ZSB5b3VyIHN0eWxlLlxuY29uc3Qgc3R5bGUgPSB7XG4gIGxvY2FsVHJhY2tzRGl2OiB7XG4gICAgd2lkdGg6ICdpbmhlcml0JyxcbiAgfSxcbiAgdHJhY2tSZW5kZXJzOiB7XG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICdmbGV4LXdyYXAnOiAnd3JhcCcsXG4gIH0sXG4gIHRyYWNrQnV0dG9uc0NvbnRhaW5lcjoge1xuICAgICd0ZXh0LWFsaWduJzogJ2xlZnQnLFxuICAgICdkaXNwbGF5JzogJ2ZsZXgnLFxuICAgICdmbGV4LWZsb3cnOiAncm93IHdyYXAnXG4gIH1cblxufVxuLy8gQ29tcGlsZSBzdHlsZXMsIGFwcGx5IHBsdWdpbnMuXG5jb25zdCBzaGVldCA9IGpzcy5jcmVhdGVTdHlsZVNoZWV0KHN0eWxlKVxuc2hlZXQuYXR0YWNoKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMb2NhbFRyYWNrc0NvbnRyb2xzKHsgYnV0dG9uQ29udGFpbmVyLCBjb250YWluZXIsIHJvb21zLCBWaWRlbywgbG9jYWxUcmFja3MsIHNob3VsZEF1dG9BdHRhY2gsIHNob3VsZEF1dG9QdWJsaXNoIH0gOiB7XG4gIGJ1dHRvbkNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQsIC8vIHBhcmVudCBmb3IgY29udHJvbCBidXR0b25zXG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIC8vIHBhcmVudCBmb3IgdHJhY2tzLlxuICByb29tczogUm9vbVtdLFxuICBWaWRlbzogdHlwZW9mIGltcG9ydCgndHdpbGlvLXZpZGVvJyksXG4gIGxvY2FsVHJhY2tzOiBMb2NhbFRyYWNrW10sXG4gIHNob3VsZEF1dG9BdHRhY2g6ICgpID0+IGJvb2xlYW4sXG4gIHNob3VsZEF1dG9QdWJsaXNoOiAoKSA9PiBib29sZWFuXG59KSB7XG4gIGxldCBudW1iZXIgPSAwO1xuICBjb25zdCBhdXRvQXVkaW8gPSBnZXRCb29sZWFuVXJsUGFyYW0oJ2F1dG9BdWRpbycsIGZhbHNlKTtcbiAgY29uc3QgYXV0b1ZpZGVvID0gZ2V0Qm9vbGVhblVybFBhcmFtKCdhdXRvVmlkZW8nLCBmYWxzZSk7XG5cbiAgY29uc3QgbG9jYWxUcmFja0J1dHRvbnNDb250YWluZXIgPSBjcmVhdGVEaXYoYnV0dG9uQ29udGFpbmVyLCBzaGVldC5jbGFzc2VzLnRyYWNrQnV0dG9uc0NvbnRhaW5lcik7XG4gIGNvbnN0IGxvY2FsVHJhY2tzQ29udGFpbmVyID0gY3JlYXRlRGl2KGNvbnRhaW5lciwgc2hlZXQuY2xhc3Nlcy50cmFja1JlbmRlcnMpO1xuXG4gIGNvbnN0IHJlbmRlcmVkVHJhY2tzID0gbmV3IE1hcDxMb2NhbFRyYWNrLCBJUmVuZGVyZWRMb2NhbFRyYWNrPigpO1xuICBmdW5jdGlvbiByZW5kZXJMb2NhbFRyYWNrMih0cmFjazogTG9jYWxBdWRpb1RyYWNrIHwgTG9jYWxWaWRlb1RyYWNrLCB2aWRlb0RldmljZXM6IE1lZGlhRGV2aWNlSW5mb1tdID0gW10pIHtcbiAgICBsb2NhbFRyYWNrcy5wdXNoKHRyYWNrKTtcbiAgICByZW5kZXJlZFRyYWNrcy5zZXQodHJhY2ssIHJlbmRlckxvY2FsVHJhY2soe1xuICAgICAgY29udGFpbmVyOiBsb2NhbFRyYWNrc0NvbnRhaW5lcixcbiAgICAgIHJvb21zLFxuICAgICAgdHJhY2ssXG4gICAgICB2aWRlb0RldmljZXMsXG4gICAgICBhdXRvQXR0YWNoOiBzaG91bGRBdXRvQXR0YWNoKCksXG4gICAgICBhdXRvUHVibGlzaDogc2hvdWxkQXV0b1B1Ymxpc2goKSxcbiAgICAgIG9uQ2xvc2VkOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbG9jYWxUcmFja3MuaW5kZXhPZih0cmFjayk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgbG9jYWxUcmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJlZFRyYWNrcy5kZWxldGUodHJhY2spO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclN0YW5kQWxvbmVNZWRpYVN0cmVhbVRyYWNrKHsgbXNUcmFjaywgYXV0b0F0dGFjaCA9IHRydWUgfSA6IHsgbXNUcmFjazogTWVkaWFTdHJlYW1UcmFjaywgYXV0b0F0dGFjaDogYm9vbGVhbiB9KSB7XG4gICAgY29uc3QgbG9jYWxUcmFjayA9IG1zVHJhY2sua2luZCA9PT0gJ3ZpZGVvJyA/XG4gICAgICBuZXcgVmlkZW8uTG9jYWxWaWRlb1RyYWNrKG1zVHJhY2ssIHsgbG9nTGV2ZWw6ICd3YXJuJywgbmFtZTogJ215LXZpZGVvJywgd29ya2Fyb3VuZFdlYktpdEJ1ZzEyMDg1MTY6IGZhbHNlIH0pIDpcbiAgICAgIG5ldyBWaWRlby5Mb2NhbEF1ZGlvVHJhY2sobXNUcmFjaywgeyBsb2dMZXZlbDogJ3dhcm4nLCBuYW1lOiAnbXktYXVkaW8nLCB3b3JrYXJvdW5kV2ViS2l0QnVnMTIwODUxNjogZmFsc2UgfSk7XG4gICAgcmVuZGVyTG9jYWxUcmFjayh7IGNvbnRhaW5lcjogbG9jYWxUcmFja3NDb250YWluZXIsIHJvb21zOiBbXSwgdHJhY2s6IGxvY2FsVHJhY2ssIHZpZGVvRGV2aWNlczogW10sIGF1dG9BdHRhY2gsIGF1dG9QdWJsaXNoOiBmYWxzZSwgb25DbG9zZWQ6ICgpID0+IHsgfSB9KTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBjb25zdCBidG5QcmV2aWV3QXVkaW8gPSBjcmVhdGVCdXR0b24oJysgTG9jYWwgQXVkaW8nLCBsb2NhbFRyYWNrQnV0dG9uc0NvbnRhaW5lciwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHRoaXNUcmFja05hbWUgPSAnbWljLScgKyBudW1iZXIrKztcbiAgICBjb25zdCBsb2NhbFRyYWNrID0gYXdhaXQgVmlkZW8uY3JlYXRlTG9jYWxBdWRpb1RyYWNrKHsgbG9nTGV2ZWw6ICd3YXJuJywgbmFtZTogdGhpc1RyYWNrTmFtZSB9KTtcbiAgICByZW5kZXJMb2NhbFRyYWNrMihsb2NhbFRyYWNrKTtcbiAgfSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGNvbnN0IGJ0blN5bnRoZXRpY0F1ZGlvID0gY3JlYXRlQnV0dG9uKCcrIFN5bnRoZXRpYyBBdWRpbycsIGxvY2FsVHJhY2tCdXR0b25zQ29udGFpbmVyLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgdGhpc1RyYWNrTmFtZSA9ICdBdWRpby0nICsgbnVtYmVyKys7XG4gICAgY29uc3QgbXNUcmFjayA9IGF3YWl0IHN5bnRoZXRpY0F1ZGlvKCk7XG4gICAgY29uc3QgbG9jYWxUcmFjayA9IG5ldyBWaWRlby5Mb2NhbEF1ZGlvVHJhY2sobXNUcmFjaywgeyBsb2dMZXZlbDogJ3dhcm4nLCBuYW1lOiB0aGlzVHJhY2tOYW1lIH0pO1xuICAgIHJlbmRlckxvY2FsVHJhY2syKGxvY2FsVHJhY2spO1xuICB9KTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgY29uc3QgYnRuUHJldmlld1ZpZGVvID0gY3JlYXRlQnV0dG9uKCcrIExvY2FsIFZpZGVvJywgbG9jYWxUcmFja0J1dHRvbnNDb250YWluZXIsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB0aGlzVHJhY2tOYW1lID0gJ2NhbWVyYS0nICsgbnVtYmVyKys7XG4gICAgY29uc3QgbG9jYWxUcmFjayA9IGF3YWl0IFZpZGVvLmNyZWF0ZUxvY2FsVmlkZW9UcmFjayh7IHdpZHRoOiAxMjgwLCBoZWlnaHQ6IDcyMCwgbG9nTGV2ZWw6ICd3YXJuJywgbmFtZTogdGhpc1RyYWNrTmFtZSB9KTtcbiAgICByZW5kZXJMb2NhbFRyYWNrMihsb2NhbFRyYWNrKTtcbiAgfSk7XG5cblxuICBjb25zdCBidG5TeW50aGV0aWNWaWRlbyA9IGNyZWF0ZUJ1dHRvbignKyBTeW50aGV0aWMgVmlkZW8nLCBsb2NhbFRyYWNrQnV0dG9uc0NvbnRhaW5lciwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHRoaXNUcmFja05hbWUgPSAnVi0nICsgbnVtYmVyKys7XG4gICAgY29uc3QgbXNUcmFjayA9IGF3YWl0IHN5bnRoZXRpY1ZpZGVvKHsgd2lkdGg6IDY0MCwgaGVpZ2h0OiAzNjAsIHdvcmQ6IHRoaXNUcmFja05hbWUgfSk7XG4gICAgY29uc3QgbG9jYWxUcmFjayA9IG5ldyBWaWRlby5Mb2NhbFZpZGVvVHJhY2sobXNUcmFjaywgeyBsb2dMZXZlbDogJ3dhcm4nLCBuYW1lOiB0aGlzVHJhY2tOYW1lIH0pO1xuICAgIHJlbmRlckxvY2FsVHJhY2syKGxvY2FsVHJhY2spO1xuICB9KTtcblxuICBjb25zdCBidG5TY3JlZW5TaGFyZSA9IGNyZWF0ZUJ1dHRvbignKyBTY3JlZW4gU2hhcmUnLCBsb2NhbFRyYWNrQnV0dG9uc0NvbnRhaW5lciwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHRoaXNUcmFja05hbWUgPSAnc2NyZWVuLScgKyBudW1iZXIrKztcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc2NyZWVuU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoe1xuICAgICAgdmlkZW86IHsgd2lkdGg6IDE5MjAsIGhlaWdodDogMTA4MCwgZnJhbWVSYXRlOiAxNSB9XG4gICAgfSk7XG4gICAgY29uc3QgbG9jYWxUcmFjayA9IG5ldyBWaWRlby5Mb2NhbFZpZGVvVHJhY2soc2NyZWVuU3RyZWFtLmdldFRyYWNrcygpWzBdLCB7IGxvZ0xldmVsOiAnd2FybicsIG5hbWU6IHRoaXNUcmFja05hbWUgfSk7XG4gICAgcmVuZGVyTG9jYWxUcmFjazIobG9jYWxUcmFjayk7XG4gIH0pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBjb25zdCBlbnVtZXJhdGVCdG4gPSBjcmVhdGVCdXR0b24oJ0VudW1lcmF0ZSBDYW1lcmFzJywgbG9jYWxUcmFja0J1dHRvbnNDb250YWluZXIsIGFzeW5jICgpID0+IHtcbiAgICBlbnVtZXJhdGVCdG4uZGlzYWJsZSgpO1xuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBnZXREZXZpY2VTZWxlY3Rpb25PcHRpb25zKCk7XG4gICAgZGV2aWNlcy52aWRlb2lucHV0LmZvckVhY2goKGRldmljZSwgaSwgdmlkZW9EZXZpY2VzKSA9PiB7XG4gICAgICBjcmVhdGVCdXR0b24oZGV2aWNlLmxhYmVsLCBsb2NhbFRyYWNrQnV0dG9uc0NvbnRhaW5lciwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB2aWRlb0NvbnN0cmFpbnRzID0ge1xuICAgICAgICAgIGRldmljZUlkOiB7IGV4YWN0OiBkZXZpY2UuZGV2aWNlSWQgfSxcbiAgICAgICAgICAvLyBoZWlnaHQ6IDQ4MCwgd2lkdGg6IDY0MCwgZnJhbWVSYXRlOiAyNFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0aGlzVHJhY2tOYW1lID0gJ2NhbWVyYS0nICsgbnVtYmVyKys7XG4gICAgICAgIGNvbnN0IGxvY2FsVHJhY2sgPSBhd2FpdCBWaWRlby5jcmVhdGVMb2NhbFZpZGVvVHJhY2soeyBsb2dMZXZlbDogJ3dhcm4nLCBuYW1lOiB0aGlzVHJhY2tOYW1lLCAuLi52aWRlb0NvbnN0cmFpbnRzIH0pO1xuXG4gICAgICAgIHJlbmRlckxvY2FsVHJhY2syKGxvY2FsVHJhY2ssIHZpZGVvRGV2aWNlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKGF1dG9BdWRpbykge1xuICAgIGJ0blByZXZpZXdBdWRpby5jbGljaygpO1xuICB9XG4gIGlmIChhdXRvVmlkZW8pIHtcbiAgICBidG5QcmV2aWV3VmlkZW8uY2xpY2soKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcm9vbUFkZGVkOiAocm9vbTogUm9vbSkgID0+IHtcbiAgICAgIHJlbmRlcmVkVHJhY2tzLmZvckVhY2goKHJlbmRlcmVkVHJhY2sgPT4gcmVuZGVyZWRUcmFjay5yb29tQWRkZWQocm9vbSkpKTtcbiAgICB9LFxuICAgIHJvb21SZW1vdmVkOiAocm9vbTogUm9vbSkgPT4ge1xuICAgICAgcmVuZGVyZWRUcmFja3MuZm9yRWFjaCgocmVuZGVyZWRUcmFjayA9PiByZW5kZXJlZFRyYWNrLnJvb21SZW1vdmVkKHJvb20pKSk7XG4gICAgfSxcbiAgICByZW5kZXJTdGFuZEFsb25lTWVkaWFTdHJlYW1UcmFjayxcbiAgfTtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbmltcG9ydCB7IHJhbmRvbU5hbWUsIHJhbmRvbVBhcnRpY2lwYW50TmFtZSwgcmFuZG9tUm9vbU5hbWUgfSBmcm9tICAnLi9yYW5kb21OYW1lJztcbmltcG9ydCB7IGNyZWF0ZUJ1dHRvbiwgSUJ1dHRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9idXR0b24nO1xuaW1wb3J0IHsgY3JlYXRlRGl2IH0gZnJvbSAnLi9jb21wb25lbnRzL2NyZWF0ZURpdic7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2NyZWF0ZUVsZW1lbnQnO1xuaW1wb3J0IHsgY3JlYXRlTGFiZWxlZENoZWNrYm94IH0gZnJvbSAnLi9jb21wb25lbnRzL2NyZWF0ZUxhYmVsZWRDaGVja2JveCc7XG5pbXBvcnQgeyBjcmVhdGVMYWJlbGVkSW5wdXQgfSBmcm9tICcuL2NvbXBvbmVudHMvY3JlYXRlTGFiZWxlZElucHV0JztcbmltcG9ydCB7IGNyZWF0ZUxpbmsgfSBmcm9tICcuL2NvbXBvbmVudHMvY3JlYXRlTGluayc7XG5pbXBvcnQgeyBjcmVhdGVTZWxlY3Rpb24gfSBmcm9tICcuL2NvbXBvbmVudHMvY3JlYXRlU2VsZWN0aW9uJztcbmltcG9ydCB7IGdldEJvb2xlYW5VcmxQYXJhbSB9IGZyb20gJy4vY29tcG9uZW50cy9nZXRCb29sZWFuVXJsUGFyYW0nO1xuaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi9jb21wb25lbnRzL2xvZyc7XG5pbXBvcnQgeyBMb2csIExvY2FsVHJhY2ssIFJvb20sIExvY2FsRGF0YVRyYWNrIH0gZnJvbSAndHdpbGlvLXZpZGVvJztcblxuaW1wb3J0IGpzcyBmcm9tICcuL2pzcydcbmltcG9ydCB7IGNyZWF0ZUNvbGxhcHNpYmxlRGl2IH0gZnJvbSAnLi9jb21wb25lbnRzL2NyZWF0ZUNvbGxhcHNpYmxlRGl2JztcbmltcG9ydCB7IGdldFJlc3RDcmVkcywgUkVTVF9DUkVERU5USUFMUyB9IGZyb20gJy4vZ2V0Q3JlZHMnO1xuXG4vKlxuWW91IGNhbiBvdmVycmlkZSBhbnkgb2YgdGhlIFNEUCBmdW5jdGlvbiBieSBzcGVjaWZ5aW5nIGEgY29uc29sZSBvdmVycmlkZSBsaWtlIGEgb25lIGJlbG93IGJlZm9yZSBjb25uZWN0aW5nIHRvIHRoZSByb29tOlxud2luZG93LnNkcFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChvdmVycmlkZSwgZGVzY3JpcHRpb24sIHBjKSB7XG4gIGNvbnNvbGUubG9nKGBvdmVycmlkaW5nICR7b3ZlcnJpZGV9IGZvciAke2Rlc2NyaXB0aW9uLnR5cGV9ICBvZiBsZW5ndGggJHtkZXNjcmlwdGlvbi5zZHAubGVuZ3RofSBpbiBwZWVyQ29ubmVjdGlvbjpgLCAgcGMgKTtcbiAgcmV0dXJuIGRlc2NyaXB0aW9uO1xufVxuKi9cblxubGV0IG92ZXJyaWRlc1NldCA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBMb2NhbERlc2NyaXB0aW9uT3ZlcnJpZGUoKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgdHJhbnNmb3JtID0gd2luZG93LnNkcFRyYW5zZm9ybTtcbiAgaWYgKCFvdmVycmlkZXNTZXQgJiYgdHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG92ZXJyaWRlc1NldCA9IHRydWU7XG4gICAgY29uc3Qgb3JpZ1NldExvY2FsRGVzY3JpcHRpb24gPSBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcbiAgICBjb25zdCBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPSBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gICAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICAgIGNvbnN0IG9yaWdDcmVhdGVBbnN3ZXIgPSBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyO1xuICAgIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0TG9jYWxEZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgICAgcmV0dXJuIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uLmNhbGwodGhpcywgdHJhbnNmb3JtKCdzZXRMb2NhbERlc2NyaXB0aW9uJywgZGVzY3JpcHRpb24sIHRoaXMpKTtcbiAgICB9O1xuICAgIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmNhbGwodGhpcywgdHJhbnNmb3JtKCdzZXRSZW1vdGVEZXNjcmlwdGlvbicsIGRlc2NyaXB0aW9uLCB0aGlzKSk7XG4gICAgfTtcbiAgICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmNhbGwodGhpcywgb3B0aW9ucykudGhlbigob2ZmZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbikgPT4ge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtKCdjcmVhdGVPZmZlcicsIG9mZmVyLCB0aGlzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uIGNyZWF0ZUFuc3dlcihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3JpZ0NyZWF0ZUFuc3dlci5jYWxsKHRoaXMsIG9wdGlvbnMpLnRoZW4oKGFuc3dlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm0oJ2NyZWF0ZUFuc3dlcicsIGFuc3dlciwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59XG5cbi8vIENyZWF0ZSB5b3VyIHN0eWxlLlxuY29uc3Qgc3R5bGUgPSB7XG4gIHJvb21Db250cm9sczoge1xuICAgIHdpZHRoOiAnMzAwcHgnLFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBwYWRkaW5nOiAnNXB4JyxcbiAgICAvLyBib3JkZXI6ICdzb2xpZCBibGFjayAxcHgnLFxuICAgICdmbGV4LWRpcmVjdGlvbic6ICdjb2x1bW4nLFxuICAgICdmbGV4LXdyYXAnOiAnd3JhcCcsXG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnI2ZmZicsXG4gIH0sXG4gIG1vcmVSb29tQ29udHJvbHM6IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgcGFkZGluZzogJzVweCcsXG4gICAgLy8gYm9yZGVyOiAnc29saWQgYmxhY2sgMXB4JyxcbiAgICAnZmxleC1kaXJlY3Rpb24nOiAnY29sdW1uJyxcbiAgICAnZmxleC13cmFwJzogJ3dyYXAnLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNmZmYnLFxuICB9LFxuICByb29tQ29udHJvbHNJbnB1dDoge1xuICAgIHBhZGRpbmc6ICcwLjVlbScsXG4gICAgJ3RleHQtYWxpZ24nOiAnY2VudGVyJyxcbiAgfSxcbiAgcm9vbUNvbnRyb2xzTGFiZWw6IHtcbiAgICAnbWFyZ2luLXRvcCc6ICcxMHB4JyxcbiAgICAnbWFyZ2luLXJpZ2h0JzogJzEwcHgnLFxuICB9LFxuICByb29tQ29udHJvbHNCdXR0b246IHtcbiAgICAndGV4dC1hbGlnbic6ICdjZW50ZXInXG4gIH0sXG4gIGpvaW5Sb29tQnV0dG9uOiB7XG4gICAgaGVpZ2h0OiAnM2VtJyxcbiAgfSxcbiAgY29udHJvbE9wdGlvbnM6IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgJ2ZsZXgtZmxvdyc6ICdyb3cgd3JhcCcsXG4gICAgJ21hcmdpbi10b3AnOiAnMTBweCcsXG4gICAgJ2p1c3RpZnktY29udGVudCc6ICdjZW50ZXInLFxuICAgICdhbGlnbi1pdGVtcyc6ICdjZW50ZXInLFxuICB9XG59XG4vLyBDb21waWxlIHN0eWxlcywgYXBwbHkgcGx1Z2lucy5cbmNvbnN0IHNoZWV0ID0ganNzLmNyZWF0ZVN0eWxlU2hlZXQoc3R5bGUpXG5zaGVldC5hdHRhY2goKTtcblxuZnVuY3Rpb24gaGFuZGxlU0RLTG9ncyhsb2dnZXI6IExvZy5Mb2dnZXIpIHtcbiAgbGV0IGxvY2FsRGF0YVRyYWNrOiBMb2NhbERhdGFUcmFja3xudWxsID0gbnVsbDtcbiAgbGV0IGxvY2FsSWRlbnRpdHk6IHN0cmluZ3xudWxsID0gbnVsbDtcbiAgY29uc3Qgb3JpZ2luYWxGYWN0b3J5ID0gbG9nZ2VyLm1ldGhvZEZhY3Rvcnk7XG4gIGxvZ2dlci5tZXRob2RGYWN0b3J5ID0gZnVuY3Rpb24obWV0aG9kTmFtZTogc3RyaW5nLCBsZXZlbDogTG9nLkxvZ0xldmVsTnVtYmVycywgbG9nZ2VyTmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgbWV0aG9kID0gb3JpZ2luYWxGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZVRpbWU6IERhdGUsIGxvZ0xldmVsOiBzdHJpbmcsIGNvbXBvbmVudDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcsIGRhdGE6IGFueSkge1xuICAgICAgbWV0aG9kKGRhdGVUaW1lLCBsb2dMZXZlbCwgY29tcG9uZW50LCBtZXNzYWdlLCBkYXRhKTtcbiAgICAgIGlmIChsb2NhbERhdGFUcmFjaykge1xuICAgICAgICBsb2NhbERhdGFUcmFjay5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBsb2NhbElkZW50aXR5LFxuICAgICAgICAgIGRhdGVUaW1lLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIGRhdGFcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgZm9yIHNpZ25hbGluZyBldmVudHMgdGhhdCBwcmV2aW91c2x5IHVzZWQgdG8gYmVcbiAgICAgIC8vIGVtaXR0ZWQgb24gKG5vdyBkZXByZWNhdGVkKSBldmVudExpc3RlbmVyXG4gICAgICAvLyB0aGV5IGFyZSBmaXJlZCB3aXRoIG1lc3NhZ2UgPSBgZXZlbnRgLCBhbmQgZ3JvdXAgPT0gYHNpZ25hbGluZ2BcbiAgICAgIGlmIChtZXNzYWdlID09PSAnZXZlbnQnICYmIGRhdGEuZ3JvdXAgPT09ICdzaWduYWxpbmcnKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBtYWthcmFuZCBFdmVudExpc3RlbmVyQVBJIHwgJHtkYXRhLm5hbWV9YCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3Mgc2VuZGluZyBsb2dzIHRvIGRhdGEgY2hhbm5lbC5cbiAgcmV0dXJuIHtcbiAgICBzZXRMb2NhbERhdGFUcmFjazogKGRhdGFUcmFjazogTG9jYWxEYXRhVHJhY2ssIGlkZW50aXR5OiBzdHJpbmcgKSA9PiB7XG4gICAgICBsb2NhbERhdGFUcmFjayA9IGRhdGFUcmFjaztcbiAgICAgIGxvY2FsSWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUm9vbUNvbnRyb2wge1xuICBzaG91bGRBdXRvQXR0YWNoOiAoKSA9PiBib29sZWFuLFxuICBzaG91bGRBdXRvUHVibGlzaDogKCkgPT4gYm9vbGVhbixcbiAgZ2V0Um9vbUNvbnRyb2xzRGl2OiAoKSA9PiBIVE1MRGl2RWxlbWVudFxuICBnZXRSb29tQ3JlZGVudGlhbHM6ICgpID0+IFByb21pc2U8eyB0b2tlbjogc3RyaW5nLCBlbnZpcm9ubWVudDogc3RyaW5nIH0+XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm9vbUNvbnRyb2xzKFxuICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICBWaWRlbzogdHlwZW9mIGltcG9ydCgndHdpbGlvLXZpZGVvJyksXG4gIGxvY2FsVHJhY2tzOiBMb2NhbFRyYWNrW10sXG4gIHJvb21Kb2luZWQ6IChyb29tOiBSb29tLCBsb2dnZXI6IExvZy5Mb2dnZXIsIHJlc3RDcmVkczogUkVTVF9DUkVERU5USUFMUyB8IG51bGwpID0+IHZvaWRcbik6IElSb29tQ29udHJvbCB7XG4gIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG5cbiAgY29uc3QgeyBpbm5lckRpdiwgb3V0ZXJEaXYgfSA9IGNyZWF0ZUNvbGxhcHNpYmxlRGl2KHsgY29udGFpbmVyLCBoZWFkZXJUZXh0OiAnQ29udHJvbHMnLCBkaXZDbGFzczogc2hlZXQuY2xhc3Nlcy5yb29tQ29udHJvbHMgfSk7XG4gIGNyZWF0ZUVsZW1lbnQoeyBjb250YWluZXI6IGlubmVyRGl2LCB0eXBlOiAnaDMnLCBpZDogJ3R3aWxpb1ZpZGVvVmVyc2lvbicsIGlubmVySHRtbDogJ1R3aWxpby1WaWRlb0AnICsgVmlkZW8udmVyc2lvbiB9KTtcblxuICBjb25zdCBsb2NhbElkZW50aXR5ID0gY3JlYXRlTGFiZWxlZElucHV0KHtcbiAgICBjb250YWluZXI6IGlubmVyRGl2LFxuICAgIGxhYmVsVGV4dDogJ0lkZW50aXR5OiAnLFxuICAgIHBsYWNlSG9sZGVyOiAnRW50ZXIgaWRlbnRpdHkgb3IgcmFuZG9tIG9uZSB3aWxsIGJlIGdlbmVyYXRlZCcsXG4gICAgbGFiZWxDbGFzc2VzOiBbc2hlZXQuY2xhc3Nlcy5yb29tQ29udHJvbHNMYWJlbF0sXG4gICAgaW5wdXRDbGFzc2VzOiBbc2hlZXQuY2xhc3Nlcy5yb29tQ29udHJvbHNJbnB1dF1cbiAgfSk7XG5cbiAgY29uc3Qgcm9vbU5hbWVJbnB1dCA9IGNyZWF0ZUxhYmVsZWRJbnB1dCh7XG4gICAgY29udGFpbmVyOiBpbm5lckRpdixcbiAgICBsYWJlbFRleHQ6ICdSb29tOiAnLFxuICAgIHBsYWNlSG9sZGVyOiAnRW50ZXIgcm9vbSBuYW1lIG9yIHJhbmRvbSBuYW1lIHdpbGwgYmUgZ2VuZXJhdGVkJyxcbiAgICBsYWJlbENsYXNzZXM6IFtzaGVldC5jbGFzc2VzLnJvb21Db250cm9sc0xhYmVsXSxcbiAgICBpbnB1dENsYXNzZXM6IFtzaGVldC5jbGFzc2VzLnJvb21Db250cm9sc0lucHV0XVxuICB9KTtcblxuICBjb25zdCB7IGlubmVyRGl2OiBtb3JlT3B0aW9uc0RpdiB9ID0gY3JlYXRlQ29sbGFwc2libGVEaXYoeyBjb250YWluZXI6IGlubmVyRGl2LCBoZWFkZXJUZXh0OiAnTW9yZS4uLicsIGRpdkNsYXNzOiBzaGVldC5jbGFzc2VzLm1vcmVSb29tQ29udHJvbHMsIHN0YXJ0SGlkZGVuOiB0cnVlIH0pO1xuXG5cblxuICBjb25zdCB0b3BvbG9neVNlbGVjdCA9IGNyZWF0ZVNlbGVjdGlvbih7XG4gICAgaWQ6ICd0b3BvbG9neScsXG4gICAgY29udGFpbmVyOiBtb3JlT3B0aW9uc0RpdixcbiAgICBvcHRpb25zOiBbJ2dyb3VwLXNtYWxsJywgJ3BlZXItdG8tcGVlcicsICdncm91cCcsICdnbyddLFxuICAgIHRpdGxlOiAndG9wb2xvZ3knLFxuICAgIGxhYmVsQ2xhc3NlczogW3NoZWV0LmNsYXNzZXMucm9vbUNvbnRyb2xzTGFiZWxdLFxuICAgIG9uQ2hhbmdlOiAoKSA9PiBsb2coJ3RvcG9sb2d5IGNoYW5nZTonLCB0b3BvbG9neVNlbGVjdC5nZXRWYWx1ZSgpKVxuICB9KTtcblxuICBsZXQgZXh0cmFDb25uZWN0T3B0aW9uczogeyB2YWx1ZTogc3RyaW5nOyB9O1xuICBjb25zdCBlbnZTZWxlY3QgPSBjcmVhdGVTZWxlY3Rpb24oe1xuICAgIGlkOiAnZW52JyxcbiAgICBjb250YWluZXI6IG1vcmVPcHRpb25zRGl2LFxuICAgIG9wdGlvbnM6IFsnZGV2JywgJ3N0YWdlJywgJ3Byb2QnXSxcbiAgICB0aXRsZTogJ2VudicsXG4gICAgbGFiZWxDbGFzc2VzOiBbc2hlZXQuY2xhc3Nlcy5yb29tQ29udHJvbHNMYWJlbF0sXG4gICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgIGNvbnN0IG5ld0VudiA9IGVudlNlbGVjdC5nZXRWYWx1ZSgpO1xuICAgICAgaWYgKG5ld0VudiA9PT0gJ2RldicpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIGNvbnN0IGRldk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgeyB3c1NlcnZlcjogJ3dzczovL3VzMi52c3MuZGV2LnR3aWxpby5jb20vc2lnbmFsaW5nJyB9KTtcbiAgICAgICAgZXh0cmFDb25uZWN0T3B0aW9ucy52YWx1ZSA9IHVybFBhcmFtcy5nZXQoJ2Nvbm5lY3RPcHRpb25zJykgfHwgSlNPTi5zdHJpbmdpZnkoZGV2T3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBsb2coJ2VudiBjaGFuZ2U6JywgbmV3RW52KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vXG4gIC8vIFRPRE86IGJlc2lkZXMgc2VydmVyIGFsc28gYWxsb3cgdG8gdXNlIHRva2VuIGNyZWF0ZWQgZnJvbTogJ2h0dHBzOi8vd3d3LnR3aWxpby5jb20vY29uc29sZS92aWRlby9wcm9qZWN0L3Rlc3RpbmctdG9vbHMnXG4gIGNvbnN0IGxhYmVsVGV4dCA9IGNyZWF0ZUxpbmsoeyBjb250YWluZXI6IG1vcmVPcHRpb25zRGl2LCBsaW5rVGV4dDogJ1NlcnZlclVybCcsIGxpbmtVcmw6ICdodHRwczovL2dpdGh1Yi5jb20vbWFrYXJhbmRwMC90d2lsaW8tdmlkZW8tYXBpI3VzYWdlJywgbmV3VGFiOiB0cnVlIH0pO1xuICBsYWJlbFRleHQuY2xhc3NMaXN0LmFkZChzaGVldC5jbGFzc2VzLnJvb21Db250cm9sc0xhYmVsKTtcbiAgY29uc3QgdG9rZW5TZXJ2ZXJVcmxJbnB1dCA9IGNyZWF0ZUxhYmVsZWRJbnB1dCh7XG4gICAgY29udGFpbmVyOiBtb3JlT3B0aW9uc0RpdixcbiAgICBsYWJlbFRleHQsXG4gICAgcGxhY2VIb2xkZXI6ICdFbnRlciBzZXJ2ZXIgdXJsJyxcbiAgICBsYWJlbENsYXNzZXM6IFtzaGVldC5jbGFzc2VzLnJvb21Db250cm9sc0xhYmVsXSxcbiAgICBpbnB1dENsYXNzZXM6IFtzaGVldC5jbGFzc2VzLnJvb21Db250cm9sc0lucHV0XVxuICB9KTtcblxuICBleHRyYUNvbm5lY3RPcHRpb25zID0gY3JlYXRlTGFiZWxlZElucHV0KHtcbiAgICBjb250YWluZXI6IG1vcmVPcHRpb25zRGl2LFxuICAgIGxhYmVsVGV4dDogJ0Nvbm5lY3RPcHRpb25zOiAnLFxuICAgIHBsYWNlSG9sZGVyOiAnY29ubmVjdE9wdGlvbnMgYXMganNvbiBoZXJlJyxcbiAgICBsYWJlbENsYXNzZXM6IFtzaGVldC5jbGFzc2VzLnJvb21Db250cm9sc0xhYmVsXSxcbiAgICBpbnB1dFR5cGU6ICd0ZXh0YXJlYSdcbiAgfSk7XG5cbiAgY29uc3QgbWF4UGFydGljaXBhbnRzSW5wdXQgPSBjcmVhdGVMYWJlbGVkSW5wdXQoe1xuICAgIGNvbnRhaW5lcjogbW9yZU9wdGlvbnNEaXYsXG4gICAgbGFiZWxUZXh0OiAnTWF4UGFydGljaXBhbnRzOiAnLFxuICAgIHBsYWNlSG9sZGVyOiAnb3B0aW9uYWwgKDUxKyBtYWtlcyBsYXJnZSByb29tKV0nLFxuICAgIGxhYmVsQ2xhc3NlczogW3NoZWV0LmNsYXNzZXMucm9vbUNvbnRyb2xzTGFiZWxdLFxuICAgIGlucHV0Q2xhc3NlczogW3NoZWV0LmNsYXNzZXMucm9vbUNvbnRyb2xzSW5wdXRdXG4gIH0pO1xuXG5cbiAgY29uc3QgY29udHJvbE9wdGlvbnNEaXYgPSBjcmVhdGVEaXYobW9yZU9wdGlvbnNEaXYsIHNoZWV0LmNsYXNzZXMuY29udHJvbE9wdGlvbnMsICdjb250cm9sLW9wdGlvbnMnKTtcblxuICAvLyBjb250YWluZXIsIGxhYmVsVGV4dCwgaWRcbiAgY29uc3QgYXV0b1B1Ymxpc2ggPSBjcmVhdGVMYWJlbGVkQ2hlY2tib3goeyBjb250YWluZXI6IGNvbnRyb2xPcHRpb25zRGl2LCBsYWJlbFRleHQ6ICdBdXRvIFB1Ymxpc2gnLCBpZDogJ2F1dG9QdWJsaXNoJyB9KTtcbiAgY29uc3QgYXV0b0F0dGFjaCA9IGNyZWF0ZUxhYmVsZWRDaGVja2JveCh7IGNvbnRhaW5lcjogY29udHJvbE9wdGlvbnNEaXYsIGxhYmVsVGV4dDogJ0F1dG8gQXR0YWNoJywgaWQ6ICdhdXRvQXR0YWNoJyB9KTtcbiAgY29uc3QgYXV0b0pvaW4gPSBjcmVhdGVMYWJlbGVkQ2hlY2tib3goeyBjb250YWluZXI6IGNvbnRyb2xPcHRpb25zRGl2LCBsYWJlbFRleHQ6ICdBdXRvIEpvaW4nLCBpZDogJ2F1dG9Kb2luJyB9KTtcbiAgY29uc3QgYXV0b1JlY29yZCA9IGNyZWF0ZUxhYmVsZWRDaGVja2JveCh7IGNvbnRhaW5lcjogY29udHJvbE9wdGlvbnNEaXYsIGxhYmVsVGV4dDogJ1JlY29yZCBQYXJ0aWNpcGFudCcsIGlkOiAncmVjb3JkUGFydGljaXBhbnQnIH0pO1xuICBjb25zdCBleHRyYUluZm8gPSBjcmVhdGVMYWJlbGVkQ2hlY2tib3goeyBjb250YWluZXI6IGNvbnRyb2xPcHRpb25zRGl2LCBsYWJlbFRleHQ6ICdleHRyYSBJbmZvJywgaWQ6ICdleHRyYUluZm8nIH0pO1xuICBjb25zdCBzZW5kTG9ncyA9IGNyZWF0ZUxhYmVsZWRDaGVja2JveCh7IGNvbnRhaW5lcjogY29udHJvbE9wdGlvbnNEaXYsIGxhYmVsVGV4dDogJ3NlbmQgbG9ncycsIGlkOiAnc2VuZExvZ3MnIH0pO1xuXG4gIC8vIHByb2Nlc3MgcGFyYW1ldGVycy5cbiAgcm9vbU5hbWVJbnB1dC52YWx1ZSA9IHVybFBhcmFtcy5nZXQoJ3Jvb20nKSB8fCByYW5kb21Sb29tTmFtZSgpO1xuICBsb2NhbElkZW50aXR5LnZhbHVlID0gdXJsUGFyYW1zLmdldCgnaWRlbnRpdHknKSB8fCByYW5kb21QYXJ0aWNpcGFudE5hbWUoKTsgLy8gcmFuZG9tTmFtZSgpO1xuICB0b2tlblNlcnZlclVybElucHV0LnZhbHVlID0gdXJsUGFyYW1zLmdldCgnc2VydmVyJykgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCc7XG4gIG1heFBhcnRpY2lwYW50c0lucHV0LnZhbHVlID0gdXJsUGFyYW1zLmdldCgnbWF4UGFydGljaXBhbnRzJykgfHwgJyc7XG5cbiAgLy8gZm9yIHdvcmtpbmcgd2l0aCBkZXYgZW52IHVzZTpcbiAgLy8gY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7IHdzU2VydmVyOiBcIndzczovL3VzMi52c3MuZGV2LnR3aWxpby5jb20vc2lnbmFsaW5nXCIgfTtcbiAgLy8gZm9yIHNpbXVsY2FzdCB1c2U6XG4gIC8vIHsgcHJlZmVycmVkVmlkZW9Db2RlY3M6IFsgeyBjb2RlYzogXCJWUDhcIiwgXCJzaW11bGNhc3RcIjogdHJ1ZSB9XSB9XG4gIC8vIGNvbnN0IGRlZmF1bHRPcHRpb25zID0geyBuZXR3b3JrUXVhbGl0eTogeyBsb2NhbDogMywgcmVtb3RlOiAwIH0gfTtcbiAgLy8gY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8vICAgXCJwcmVmZXJyZWRWaWRlb0NvZGVjc1wiOiBbe1wiY29kZWNcIjpcIkgyNjRcIn1dLFxuICAvLyAgIFwiaWNlVHJhbnNwb3J0UG9saWN5XCIgOiBcInJlbGF5XCJcbiAgLy8gfTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbmV0d29ya1F1YWxpdHk6IHsgbG9jYWw6IDEsIHJlbW90ZTogMCB9LFxuICAgIGRvbWluYW50U3BlYWtlcjogdHJ1ZSxcbiAgICBwcmVmZXJyZWRBdWRpb0NvZGVjczogW3sgY29kZWM6ICdvcHVzJywgZHR4OiBmYWxzZSB9XSxcbiAgICBwcmVmZXJyZWRWaWRlb0NvZGVjczogWyB7IGNvZGVjOiBcIlZQOFwiLCBcInNpbXVsY2FzdFwiOiB0cnVlIH1dLFxuICAgIGJhbmR3aWR0aFByb2ZpbGU6IHtcbiAgICAgIHZpZGVvOiB7XG4gICAgICAgIGNsaWVudFRyYWNrU3dpdGNoT2ZmQ29udHJvbDogJ21hbnVhbCcsXG4gICAgICAgIGNvbnRlbnRQcmVmZXJlbmNlc01vZGU6ICdtYW51YWwnLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBleHRyYUNvbm5lY3RPcHRpb25zLnZhbHVlID0gdXJsUGFyYW1zLmdldCgnY29ubmVjdE9wdGlvbnMnKSB8fCBKU09OLnN0cmluZ2lmeShkZWZhdWx0T3B0aW9ucywgbnVsbCwgNCk7XG4gIGF1dG9Kb2luLmNoZWNrZWQgPSB1cmxQYXJhbXMuaGFzKCdyb29tJykgJiYgdXJsUGFyYW1zLmhhcygnYXV0b0pvaW4nKTtcbiAgYXV0b0F0dGFjaC5jaGVja2VkID0gZ2V0Qm9vbGVhblVybFBhcmFtKCdhdXRvQXR0YWNoJywgdHJ1ZSk7XG4gIGF1dG9QdWJsaXNoLmNoZWNrZWQgPSBnZXRCb29sZWFuVXJsUGFyYW0oJ2F1dG9QdWJsaXNoJywgdHJ1ZSk7XG4gIGF1dG9SZWNvcmQuY2hlY2tlZCA9IGdldEJvb2xlYW5VcmxQYXJhbSgncmVjb3JkJywgZmFsc2UpO1xuICBleHRyYUluZm8uY2hlY2tlZCA9IGdldEJvb2xlYW5VcmxQYXJhbSgnZXh0cmFJbmZvJywgZmFsc2UpO1xuICBzZW5kTG9ncy5jaGVja2VkID0gZ2V0Qm9vbGVhblVybFBhcmFtKCdzZW5kTG9ncycsIGZhbHNlKTtcbiAgdG9wb2xvZ3lTZWxlY3Quc2V0VmFsdWUodXJsUGFyYW1zLmdldCgndG9wb2xvZ3knKSB8fCAnZ3JvdXAtc21hbGwnKTtcbiAgZW52U2VsZWN0LnNldFZhbHVlKHVybFBhcmFtcy5nZXQoJ2VudicpIHx8ICdwcm9kJyk7XG5cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0Um9vbUNyZWRlbnRpYWxzKCk6IFByb21pc2U8e3Rva2VuOiBzdHJpbmcsIGVudmlyb25tZW50OiBzdHJpbmd9PiB7XG4gICAgY29uc3QgaWRlbnRpdHkgPSBsb2NhbElkZW50aXR5LnZhbHVlIHx8IHJhbmRvbVBhcnRpY2lwYW50TmFtZSgpOyAvLyByYW5kb21OYW1lKCk7XG4gICAgbGV0IHRva2VuU2VydmVyVXJsID0gdG9rZW5TZXJ2ZXJVcmxJbnB1dC52YWx1ZTtcbiAgICBjb25zdCB0b3BvbG9neSA9IHRvcG9sb2d5U2VsZWN0LmdldFZhbHVlKCk7XG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSBlbnZTZWxlY3QuZ2V0VmFsdWUoKTtcbiAgICBjb25zdCByb29tTmFtZSA9IHJvb21OYW1lSW5wdXQudmFsdWU7XG4gICAgY29uc3QgcmVjb3JkUGFydGljaXBhbnRzT25Db25uZWN0ID0gYXV0b1JlY29yZC5jaGVja2VkID8gJ3RydWUnOiAnZmFsc2UnO1xuXG4gICAgbGV0IHVybCA9IG5ldyBVUkwodG9rZW5TZXJ2ZXJVcmwgKyAnL3Rva2VuJyk7XG4gICAgbGV0IG1heFBhcnRpY2lwYW50cyA9IG1heFBhcnRpY2lwYW50c0lucHV0LnZhbHVlO1xuXG4gICAgY29uc3QgdG9rZW5PcHRpb25zID0geyBlbnZpcm9ubWVudCwgdG9wb2xvZ3ksIHJvb21OYW1lLCBpZGVudGl0eSwgcmVjb3JkUGFydGljaXBhbnRzT25Db25uZWN0LCBtYXhQYXJ0aWNpcGFudHMgfTtcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyBUb2tlbiBGb3I6ICcsIHRva2VuT3B0aW9ucyk7XG4gICAgdXJsLnNlYXJjaCA9IChuZXcgVVJMU2VhcmNoUGFyYW1zKHRva2VuT3B0aW9ucykpLnRvU3RyaW5nKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCkpO1xuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHRva2VuUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiB7IHRva2VuOiB0b2tlblJlc3BvbnNlLnRva2VuLCAgZW52aXJvbm1lbnQgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIG9idGFpbiB0b2tlbiBmcm9tICR7dXJsfSwgU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmZXRjaGluZyB0b2tlbiAke3VybH0sICR7ZXgubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBqb2luUm9vbSh0b2tlbjogc3RyaW5nLCByZXN0Q3JlZHM6IFJFU1RfQ1JFREVOVElBTFMgfCBudWxsKSB7XG4gICAgY29uc3Qgcm9vbU5hbWUgPSByb29tTmFtZUlucHV0LnZhbHVlO1xuICAgIGlmICghcm9vbU5hbWUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hbGVydFxuICAgICAgYWxlcnQoJ1BsZWFzZSBlbnRlciBhIHJvb20gbmFtZS4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgYWRkaXRpb25hbENvbm5lY3RPcHRpb25zID0ge307XG4gICAgaWYgKGV4dHJhQ29ubmVjdE9wdGlvbnMudmFsdWUgIT09ICcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhZGRpdGlvbmFsQ29ubmVjdE9wdGlvbnMgPSBKU09OLnBhcnNlKGV4dHJhQ29ubmVjdE9wdGlvbnMudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2ZhaWxlZCB0byBwYXJzZSBhZGRpdGlvbmFsIGNvbm5lY3Qgb3B0aW9ucy4nLCBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxvZ2dlck5hbWUgPSBgWyR7bG9jYWxJZGVudGl0eS52YWx1ZX1dOmA7XG4gICAgY29uc3QgbG9nZ2VyID0gVmlkZW8uTG9nZ2VyLmdldExvZ2dlcihsb2dnZXJOYW1lKTtcblxuICAgIGNvbnN0IHB1Ymxpc2hMb2dzQXNEYXRhID0gc2VuZExvZ3MuY2hlY2tlZDtcblxuICAgIGNvbnN0IGxvZ1Byb2Nlc3NvciA9IGhhbmRsZVNES0xvZ3MobG9nZ2VyKTtcbiAgICBjb25zdCBjb25uZWN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbG9nZ2VyTmFtZSxcbiAgICAgIHRyYWNrczogYXV0b1B1Ymxpc2guY2hlY2tlZCA/IGxvY2FsVHJhY2tzIDogW10sXG4gICAgICBuYW1lOiByb29tTmFtZSxcbiAgICAgIGVudmlyb25tZW50OiBlbnZTZWxlY3QuZ2V0VmFsdWUoKVxuICAgIH0sIGFkZGl0aW9uYWxDb25uZWN0T3B0aW9ucyk7XG4gICAgLy8gSm9pbiB0aGUgUm9vbSB3aXRoIHRoZSB0b2tlbiBmcm9tIHRoZSBzZXJ2ZXIgYW5kIHRoZVxuICAgIC8vIExvY2FsUGFydGljaXBhbnQncyBUcmFja3MuXG4gICAgbG9nKGBKb2luaW5nIHJvb20gJHtyb29tTmFtZX0gd2l0aCAke0pTT04uc3RyaW5naWZ5KGNvbm5lY3RPcHRpb25zLCBudWxsLCAyKX0gJHthdXRvUHVibGlzaC5jaGVja2VkID8gJ3dpdGgnIDogJ3dpdGhvdXQnfSAke2xvY2FsVHJhY2tzLmxlbmd0aH0gbG9jYWxUcmFja3NgKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByb29tID0gYXdhaXQgVmlkZW8uY29ubmVjdCh0b2tlbiwgY29ubmVjdE9wdGlvbnMpO1xuICAgICAgcm9vbUpvaW5lZChyb29tLCBsb2dnZXIsIHJlc3RDcmVkcyk7XG4gICAgICBsb2NhbElkZW50aXR5LnZhbHVlID0gcmFuZG9tUGFydGljaXBhbnROYW1lKCk7IC8vIHJhbmRvbU5hbWUoKTtcbiAgICAgIGlmIChwdWJsaXNoTG9nc0FzRGF0YSkge1xuICAgICAgICBjb25zdCBsb2NhbERhdGFUcmFjayA9IG5ldyBWaWRlby5Mb2NhbERhdGFUcmFjaygpO1xuICAgICAgICBhd2FpdCByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKGxvY2FsRGF0YVRyYWNrKTtcbiAgICAgICAgbG9nUHJvY2Vzc29yLnNldExvY2FsRGF0YVRyYWNrKGxvY2FsRGF0YVRyYWNrLCBsb2dnZXJOYW1lKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nKCdDb3VsZCBub3QgY29ubmVjdCB0byBUd2lsaW86ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgY29uc3QgYnRuSm9pbiA9IGNyZWF0ZUJ1dHRvbignSm9pbicsIGlubmVyRGl2LCBhc3luYyAoKSA9PiB7XG4gICAgc2V0dXBMb2NhbERlc2NyaXB0aW9uT3ZlcnJpZGUoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW4gPSAoYXdhaXQgZ2V0Um9vbUNyZWRlbnRpYWxzKCkpLnRva2VuO1xuICAgICAgbGV0IHJlc3RDcmVkczogUkVTVF9DUkVERU5USUFMUyB8IG51bGwgPSAgbnVsbDtcbiAgICAgIGlmIChleHRyYUluZm8uY2hlY2tlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3RDcmVkcyA9IGF3YWl0IGdldFJlc3RDcmVkcyhlbnZTZWxlY3QuZ2V0VmFsdWUoKSwgdG9rZW5TZXJ2ZXJVcmxJbnB1dC52YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKHJlc3RFcnJvcikge1xuICAgICAgICAgIGxvZygnZmFpbGVkIHRvIGdldCByZXN0IGNyZWRlbnRpYWxzOicsIHJlc3RFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBqb2luUm9vbSh0b2tlbiwgcmVzdENyZWRzKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgbG9nKCdGYWlsZWQ6ICcsIGV4KTtcbiAgICB9XG4gIH0pO1xuICBidG5Kb2luLmJ0bi5jbGFzc0xpc3QuYWRkKHNoZWV0LmNsYXNzZXMuam9pblJvb21CdXR0b24pO1xuXG4gIGlmIChhdXRvSm9pbi5jaGVja2VkKSB7XG4gICAgYnRuSm9pbi5jbGljaygpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzaG91bGRBdXRvQXR0YWNoOiAoKSA9PiBhdXRvQXR0YWNoLmNoZWNrZWQsXG4gICAgc2hvdWxkQXV0b1B1Ymxpc2g6ICgpID0+IGF1dG9QdWJsaXNoLmNoZWNrZWQsXG4gICAgZ2V0Um9vbUNvbnRyb2xzRGl2OiAoKSA9PiBpbm5lckRpdixcbiAgICBnZXRSb29tQ3JlZGVudGlhbHMsXG4gIH07XG59XG5cblxuIiwiaW1wb3J0IHsgc2hlZXRzIH0gZnJvbSAnanNzJztcbmltcG9ydCB7IEF1ZGlvVHJhY2ssIExvY2FsQXVkaW9UcmFjaywgTG9jYWxWaWRlb1RyYWNrLCBSZW1vdGVBdWRpb1RyYWNrLCBSZW1vdGVWaWRlb1RyYWNrLCBWaWRlb1RyYWNrIH0gZnJvbSAndHdpbGlvLXZpZGVvJztcbmltcG9ydCB7IGNyZWF0ZUNvbGxhcHNpYmxlRGl2IH0gZnJvbSAnLi9jb21wb25lbnRzL2NyZWF0ZUNvbGxhcHNpYmxlRGl2JztcbmltcG9ydCB7IGNyZWF0ZURpdiB9IGZyb20gJy4vY29tcG9uZW50cy9jcmVhdGVEaXYnO1xuaW1wb3J0IHsgSUxhYmVsZWRTdGF0LCBjcmVhdGVMYWJlbGVkU3RhdCB9IGZyb20gJy4vY29tcG9uZW50cy9sYWJlbGVkc3RhdCc7XG5pbXBvcnQganNzIGZyb20gJy4vanNzJ1xuXG4vLyBDcmVhdGUgeW91ciBzdHlsZS5cbmNvbnN0IHN0eWxlID0ge1xuICBiYWNrZ3JvdW5kX3JlZDoge1xuICAgIGJhY2tncm91bmQ6ICdyZWQnLFxuICB9LFxuICBiYWNrZ3JvdW5kX2dyZWVuOiB7XG4gICAgYmFja2dyb3VuZDogJ2xpZ2h0Z3JlZW4nLFxuICB9LFxuICBiYWNrZ3JvdW5kX3llbGxvdzoge1xuICAgIGJhY2tncm91bmQ6ICd5ZWxsb3cnLFxuICB9LFxuICBhdWRpb1RyYWNrOiB7XG4gICAgYmFja2dyb3VuZDogJ2xpZ2h0Y29yYWwnLFxuICB9LFxuICB2aWRlb1RyYWNrOiB7XG4gICAgYmFja2dyb3VuZDogJ2xpZ2h0Ymx1ZSdcbiAgfVxufVxuLy8gQ29tcGlsZSBzdHlsZXMsIGFwcGx5IHBsdWdpbnMuXG5jb25zdCBzaGVldCA9IGpzcy5jcmVhdGVTdHlsZVNoZWV0KHN0eWxlKVxuc2hlZXQuYXR0YWNoKCk7XG5cbnR5cGUgZnVuY3Rpb25SZXR1cm5pbmdTdHJpbmcgPSAoKSA9PiBzdHJpbmc7XG50eXBlIHN0cmluZ09yRm4gPSBzdHJpbmd8ZnVuY3Rpb25SZXR1cm5pbmdTdHJpbmc7XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3ModHJhY2s6IExvY2FsQXVkaW9UcmFjayB8IExvY2FsVmlkZW9UcmFjayB8IFJlbW90ZUF1ZGlvVHJhY2sgfCBSZW1vdGVWaWRlb1RyYWNrKSB7XG4gIGlmICh0cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjaykge1xuICAgIHJldHVybiAnTG9jYWxBdWRpb1RyYWNrJ1xuICB9IGVsc2UgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSB7XG4gICAgcmV0dXJuICdMb2NhbFZpZGVvVHJhY2snXG4gIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgIHJldHVybiAnUmVtb3RlQXVkaW9UcmFjayc7XG4gIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gJ3ZpZGVvJykge1xuICAgIHJldHVybiAnUmVtb3RlVmlkZW9UcmFjayc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICd1bmtub3duJztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVHJhY2tTdGF0cyh0cmFjazogTG9jYWxBdWRpb1RyYWNrIHwgTG9jYWxWaWRlb1RyYWNrIHwgUmVtb3RlQXVkaW9UcmFjayB8IFJlbW90ZVZpZGVvVHJhY2ssIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpIHtcbiAgbGV0IG91dGVyRGl2OiBIVE1MRmllbGRTZXRFbGVtZW50O1xuICAoeyBpbm5lckRpdjogY29udGFpbmVyLCBvdXRlckRpdiB9ID0gY3JlYXRlQ29sbGFwc2libGVEaXYoeyBjb250YWluZXIsIGhlYWRlclRleHQ6ICdUcmFjayBEZXRhaWxzJywgc3RhcnRIaWRkZW46IHRydWUsIGRpdkNsYXNzOiBbXSB9KSk7XG4gIC8vIGNvbnRhaW5lciA9IGNyZWF0ZURpdihjb250YWluZXIsICd0cmFja1N0YXRzJyk7XG5cbiAgZnVuY3Rpb24gaXNWaWRlb1RyYWNrKHRyYWNrOiBBdWRpb1RyYWNrIHwgVmlkZW9UcmFjayk6IHRyYWNrIGlzIFZpZGVvVHJhY2sge1xuICAgIHJldHVybiB0cmFjay5raW5kID09PSAndmlkZW8nO1xuICB9XG5cbiAgY3JlYXRlTGFiZWxlZFN0YXQoe1xuICAgIGNvbnRhaW5lcixcbiAgICBsYWJlbDogJ2NsYXNzJ1xuICB9KS5zZXRUZXh0KGdldENsYXNzKHRyYWNrKSk7XG5cbiAgY29uc3QgcmVhZHlTdGF0ZSA9IGNyZWF0ZUxhYmVsZWRTdGF0KHtcbiAgICBjb250YWluZXIsXG4gICAgbGFiZWw6ICdyZWFkeVN0YXRlJyxcbiAgICB2YWx1ZU1hcHBlcjogKHRleHQ6IHN0cmluZykgPT4gdGV4dCA9PT0gJ2VuZGVkJyA/IHNoZWV0LmNsYXNzZXMuYmFja2dyb3VuZF9yZWQgOiB1bmRlZmluZWRcbiAgfSk7XG5cbiAgY29uc3QgZW5hYmxlZCA9IGNyZWF0ZUxhYmVsZWRTdGF0KHtcbiAgICBjb250YWluZXIsXG4gICAgbGFiZWw6ICdlbmFibGVkJyxcbiAgICB2YWx1ZU1hcHBlcjogKHRleHQ6IHN0cmluZykgPT4gdGV4dCA9PT0gJ2ZhbHNlJyA/IHNoZWV0LmNsYXNzZXMuYmFja2dyb3VuZF95ZWxsb3cgOiB1bmRlZmluZWRcbiAgfSk7XG5cbiAgY29uc3QgbXV0ZWQgPSBjcmVhdGVMYWJlbGVkU3RhdCh7XG4gICAgY29udGFpbmVyLFxuICAgIGxhYmVsOiAnbXV0ZWQnLFxuICAgIHZhbHVlTWFwcGVyOiAodGV4dDogc3RyaW5nKSA9PiB0ZXh0ID09PSAndHJ1ZScgPyBzaGVldC5jbGFzc2VzLmJhY2tncm91bmRfeWVsbG93IDogdW5kZWZpbmVkXG4gIH0pO1xuXG4gIGxldCBkaW1lbnNpb25zOiBJTGFiZWxlZFN0YXQ7XG4gIGxldCBmcHM6IElMYWJlbGVkU3RhdDtcblxuICBpZiAoaXNWaWRlb1RyYWNrKHRyYWNrKSkge1xuICAgIGRpbWVuc2lvbnMgPSBjcmVhdGVMYWJlbGVkU3RhdCh7IGNvbnRhaW5lciwgbGFiZWw6ICdkaW1lbnNpb25zJyB9KTtcbiAgICB0cmFjay5vbignZGltZW5zaW9uc0NoYW5nZWQnLCAoKSA9PiB1cGRhdGVTdGF0cygpKTtcbiAgICBmcHMgPSBjcmVhdGVMYWJlbGVkU3RhdCh7IGNvbnRhaW5lciwgbGFiZWw6ICdGUFMnIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIHdvcmthcm91bmRCYWNrZ3JvdW5kTm9pc2VXaGVuTXV0ZWQodHJhY2sgYXMgUmVtb3RlQXVkaW9UcmFjayk7XG4gIH1cblxuICBjb25zdCBzdGFydGVkID0gY3JlYXRlTGFiZWxlZFN0YXQoe1xuICAgIGNvbnRhaW5lcixcbiAgICBsYWJlbDogJ1RyYWNrLnN0YXJ0ZWQnLFxuICAgIHZhbHVlTWFwcGVyOiAodGV4dDogc3RyaW5nKSA9PiB0ZXh0ID09PSAnZmFsc2UnID8gc2hlZXQuY2xhc3Nlcy5iYWNrZ3JvdW5kX3llbGxvdyA6IHVuZGVmaW5lZFxuICB9KTtcblxuICBjb25zdCB0cmFja0VuYWJsZWQgPSBjcmVhdGVMYWJlbGVkU3RhdCh7XG4gICAgY29udGFpbmVyLFxuICAgIGxhYmVsOiAnVHJhY2suZW5hYmxlZCcsXG4gICAgdmFsdWVNYXBwZXI6ICh0ZXh0OiBzdHJpbmcpID0+IHRleHQgPT09ICdmYWxzZScgPyBzaGVldC5jbGFzc2VzLmJhY2tncm91bmRfeWVsbG93IDogdW5kZWZpbmVkXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGxpc3Rlbk9uTVNUcmFjayhtc1RyYWNrOiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgbXNUcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsICgpID0+IHVwZGF0ZVN0YXRzKCkpO1xuICAgIG1zVHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbXV0ZScsICgpID0+IHVwZGF0ZVN0YXRzKCkpO1xuICAgIG1zVHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgKCkgPT4gdXBkYXRlU3RhdHMoKSk7XG4gIH1cblxuICB0cmFjay5vbignZGlzYWJsZWQnLCAoKSA9PiB1cGRhdGVTdGF0cygpKTtcbiAgdHJhY2sub24oJ2VuYWJsZWQnLCAoKSA9PiB1cGRhdGVTdGF0cygpKTtcbiAgdHJhY2sub24oJ3N0b3BwZWQnLCAoKSA9PiB1cGRhdGVTdGF0cygpKTtcbiAgdHJhY2sub24oJ3N0YXJ0ZWQnLCAoKSA9PiB7XG4gICAgdXBkYXRlU3RhdHMoKTtcbiAgICBsaXN0ZW5Pbk1TVHJhY2sodHJhY2subWVkaWFTdHJlYW1UcmFjayk7XG4gIH0pO1xuXG5cblxuICBmdW5jdGlvbiB1cGRhdGVTdGF0cygpIHtcbiAgICByZWFkeVN0YXRlLnNldFRleHQodHJhY2subWVkaWFTdHJlYW1UcmFjay5yZWFkeVN0YXRlKTtcbiAgICBlbmFibGVkLnNldFRleHQoYCR7dHJhY2subWVkaWFTdHJlYW1UcmFjay5lbmFibGVkfWApO1xuICAgIHN0YXJ0ZWQuc2V0VGV4dChgJHt0cmFjay5pc1N0YXJ0ZWR9YCk7XG4gICAgbXV0ZWQuc2V0VGV4dChgJHt0cmFjay5tZWRpYVN0cmVhbVRyYWNrLm11dGVkfWApO1xuICAgIHRyYWNrRW5hYmxlZC5zZXRUZXh0KGAke3RyYWNrLmlzRW5hYmxlZH1gKTtcblxuICAgIGlmIChpc1ZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRyYWNrLmRpbWVuc2lvbnM7XG4gICAgICBkaW1lbnNpb25zLnNldFRleHQoYHcke3dpZHRofSB4IGgke2hlaWdodH1gKTtcblxuICAgICAgY29uc3QgZnJhbWVSYXRlID0gdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmZyYW1lUmF0ZTtcbiAgICAgIGNvbnN0IGZyYW1lUmF0ZVRleHQgPSB0eXBlb2YgZnJhbWVSYXRlID09PSAnbnVtYmVyJyA/IFN0cmluZyhNYXRoLnJvdW5kKGZyYW1lUmF0ZSkpIDogJzAnO1xuICAgICAgZnBzLnNldFRleHQoZnJhbWVSYXRlVGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgdXBkYXRlU3RhdHMgfTtcbn1cblxuXG5cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hdG9taWMtdXBkYXRlcyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuLyogZXNsaW50LWRpc2FibGUgcXVvdGVzICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IFJvb20sIExvZ2dlciwgTG9jYWxUcmFjaywgVHdpbGlvRXJyb3J9IGZyb20gJ3R3aWxpby12aWRlbyc7XG5pbXBvcnQgeyBjcmVhdGVMb2csIGxvZyB9IGZyb20gJy4vY29tcG9uZW50cy9sb2cnO1xuaW1wb3J0IHsgY3JlYXRlQ29sbGFwc2libGVEaXYsIGNyZWF0ZUZpZWxkU2V0IH0gZnJvbSAnLi9jb21wb25lbnRzL2NyZWF0ZUNvbGxhcHNpYmxlRGl2JztcbmltcG9ydCB7IGNyZWF0ZURpdiB9IGZyb20gJy4vY29tcG9uZW50cy9jcmVhdGVEaXYnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYWxUcmFja3NDb250cm9scyB9IGZyb20gJy4vY3JlYXRlTG9jYWxUcmFja3NDb250cm9scyc7XG5pbXBvcnQgeyBjcmVhdGVSb29tQ29udHJvbHMgfSBmcm9tICcuL2NyZWF0ZVJvb21Db250cm9scyc7XG5pbXBvcnQgeyByZW5kZXJSb29tIH0gZnJvbSAnLi9yZW5kZXJSb29tJztcbmltcG9ydCBqc3MgZnJvbSAnLi9qc3MnXG5pbXBvcnQgeyBjcmVhdGVMaW5rIH0gZnJvbSAnLi9jb21wb25lbnRzL2NyZWF0ZUxpbmsnO1xuaW1wb3J0IHsgUkVTVF9DUkVERU5USUFMUyB9IGZyb20gJy4vZ2V0Q3JlZHMnO1xuaW1wb3J0IHsgc2V0dXBQcmVmbGlnaHQgfSBmcm9tICcuL3NldHVwUHJlZmxpZ2h0JztcbmltcG9ydCB7IGNyZWF0ZUJ1dHRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9idXR0b24nO1xuXG4vLyBpbXBvcnQgeyBtYWluIH0gZnJvbSAnLi4vLi4vbWFrYXJhbmRwMC5naXRodWIuaW8vcGNkZW1vL2VzNi9wY2RlbW8nO1xuXG4vLyBDcmVhdGUgeW91ciBzdHlsZS5cbmNvbnN0IHN0eWxlID0ge1xuICBtYWluRGl2OiB7XG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGhlaWdodDogJ2F1dG8nLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgYm9yZGVyOiAnc29saWQgcmVkIDFweCcsXG4gICAgcGFkZGluZzogJzJweCcsXG4gICAgJ2JveC1zaXppbmcnOiAnYm9yZGVyLWJveCcsXG4gICAgJ2p1c3RpZnktY29udGVudCc6ICdmbGV4LXN0YXJ0JyxcbiAgICAnZmxleC13cmFwJzogJ3dyYXAnLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNmZmYnLFxuICAgICd0ZXh0LWFsaWduJzogJ2NlbnRlcicsXG4gIH0sXG4gIGxvY2FsQ29udHJvbHM6IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjZmZmJyxcbiAgfVxufVxuLy8gQ29tcGlsZSBzdHlsZXMsIGFwcGx5IHBsdWdpbnMuXG5jb25zdCBzaGVldCA9IGpzcy5jcmVhdGVTdHlsZVNoZWV0KHN0eWxlKVxuc2hlZXQuYXR0YWNoKCk7XG5cbmZ1bmN0aW9uIGNoZWNrVmlzaWJpbGl0eSgpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICBsb2coYGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9ICR7ZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlfWApO1xuICAgIGNvbnNvbGUubG9nKCdtYWthcmFuZDogZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID0gJywgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlKTtcbiAgfSk7XG59XG5cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIHBjZGVtbyhWaWRlbzogdHlwZW9mIGltcG9ydCgndHdpbGlvLXZpZGVvJyksIGNvbnRhaW5lckRpdjogSFRNTEVsZW1lbnQpIHtcbi8vICAgbWFpbihjb250YWluZXJEaXYpO1xuLy8gfVxuXG5leHBvcnQgZnVuY3Rpb24gZGVtbyhWaWRlbzogdHlwZW9mIGltcG9ydCgndHdpbGlvLXZpZGVvJyksIGNvbnRhaW5lckRpdjogSFRNTEVsZW1lbnQpIHtcbiAgLy8gbGluayB0byBzb3VyY2UgY29kZVxuICBjcmVhdGVMaW5rKHsgY29udGFpbmVyOiBjb250YWluZXJEaXYsIGxpbmtUZXh0OiAnVHdpbGlvLVZpZGVvLUFQSS1EZW1vJywgbGlua1VybDogJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYWthcmFuZHAwL3R3aWxpby12aWRlby1hcGknLCBuZXdUYWI6IHRydWUgfSk7XG5cbiAgY29uc3QgeyBmaWVsZHNldDogY29udGFpbmVyIH0gPSBjcmVhdGVGaWVsZFNldCh7IGNvbnRhaW5lcjogY29udGFpbmVyRGl2LCBoZWFkZXJUZXh0OiAnJywgZGl2Q2xhc3NlczogW3NoZWV0LmNsYXNzZXMubWFpbkRpdl0gfSk7XG4gIGNyZWF0ZUxvZyhjb250YWluZXJEaXYpO1xuICBsb2coXCJWZXJzaW9uOiBcIiwgVmlkZW8udmVyc2lvbik7XG4gIGxvZyhcIklzU3VwcG9ydGVkOiBcIiwgVmlkZW8uaXNTdXBwb3J0ZWQpO1xuICBsb2coXCJVc2VyQWdlbnQ6IFwiLCBuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICBjb25zdCBsb2NhbFRyYWNrczogTG9jYWxUcmFja1tdID0gW107XG4gIGNvbnN0IHJvb21zOiBSb29tW10gPSBbXTtcbiAgLy8gY2hlY2tWaXNpYmlsaXR5KCk7XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuX1R3aWxpb1ZpZGVvID0geyBWaWRlbywgcm9vbXMgfTtcbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cucm9vbXMgPSByb29tcztcbiAgY29uc3QgIHsgc2hvdWxkQXV0b0F0dGFjaCwgc2hvdWxkQXV0b1B1Ymxpc2gsIGdldFJvb21Db250cm9sc0RpdiwgZ2V0Um9vbUNyZWRlbnRpYWxzIH0gPSBjcmVhdGVSb29tQ29udHJvbHMoXG4gICAgY29udGFpbmVyLFxuICAgIFZpZGVvLFxuICAgIGxvY2FsVHJhY2tzLFxuICAgIHJvb21Kb2luZWQsXG4gICk7XG5cbiAgY29uc3QgYnV0dG9uQ29udGFpbmVyID0gZ2V0Um9vbUNvbnRyb2xzRGl2KCk7XG4gIGNvbnN0IHsgcm9vbUFkZGVkLCByb29tUmVtb3ZlZCwgcmVuZGVyU3RhbmRBbG9uZU1lZGlhU3RyZWFtVHJhY2sgfSA9IGNyZWF0ZUxvY2FsVHJhY2tzQ29udHJvbHMoe1xuICAgIGJ1dHRvbkNvbnRhaW5lcixcbiAgICBjb250YWluZXIsXG4gICAgVmlkZW8sXG4gICAgbG9jYWxUcmFja3MsXG4gICAgcm9vbXMsXG4gICAgc2hvdWxkQXV0b0F0dGFjaCxcbiAgICBzaG91bGRBdXRvUHVibGlzaCxcbiAgfSk7XG5cblxuICBjcmVhdGVCdXR0b24oJ3NldHVwUHJlZmxpZ2h0JywgYnV0dG9uQ29udGFpbmVyLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgY3JlZHMgPSBhd2FpdCBnZXRSb29tQ3JlZGVudGlhbHMoKTtcbiAgICBzZXR1cFByZWZsaWdodCh7XG4gICAgICBjb250YWluZXI6IGJ1dHRvbkNvbnRhaW5lcixcbiAgICAgIHRva2VuOiBjcmVkcy50b2tlbixcbiAgICAgIFZpZGVvLFxuICAgICAgZW52aXJvbm1lbnQ6IGNyZWRzLmVudmlyb25tZW50LFxuICAgICAgcmVuZGVyTVNUcmFjazogbXNUcmFjayA9PiByZW5kZXJTdGFuZEFsb25lTWVkaWFTdHJlYW1UcmFjayh7IG1zVHJhY2ssIGF1dG9BdHRhY2g6IHNob3VsZEF1dG9BdHRhY2goKX0pXG4gICAgfSlcbiAgfSk7XG5cbiAgLy8gU3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCFcbiAgZnVuY3Rpb24gcm9vbUpvaW5lZChyb29tOiBSb29tLCBsb2dnZXIgOiB0eXBlb2YgTG9nZ2VyLCByZXN0Q3JlZHM6IFJFU1RfQ1JFREVOVElBTFMgfCBudWxsKSB7XG4gICAgbG9nZ2VyID0gbG9nZ2VyIHx8IFZpZGVvLkxvZ2dlci5nZXRMb2dnZXIoJ3R3aWxpby12aWRlbycpO1xuICAgIHJvb21zLnB1c2gocm9vbSk7XG4gICAgcm9vbUFkZGVkKHJvb20pO1xuICAgIGxvZyhgSm9pbmVkICR7cm9vbS5zaWR9IGFzIFwiJHtyb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHl9XCJgKTtcbiAgICByZW5kZXJSb29tKHsgcm9vbSwgY29udGFpbmVyLCBzaG91bGRBdXRvQXR0YWNoLCByZXN0Q3JlZHMsIGxvZ2dlciB9KTtcbiAgICByb29tLm9uKCdkaXNjb25uZWN0ZWQnLCAoXywgZXJyKSA9PiB7XG4gICAgICBsb2coYExlZnQgJHtyb29tLnNpZH0gYXMgXCIke3Jvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eX1cImApO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2coJ0Vycm9yOicsIGVycik7XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleCA9IHJvb21zLmluZGV4T2Yocm9vbSk7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICByb29tcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgcm9vbVJlbW92ZWQocm9vbSk7XG4gICAgfSk7XG4gIH1cbn1cblxuXG4iLCJleHBvcnQgdHlwZSBSRVNUX0NSRURFTlRJQUxTID0ge1xuICBzaWduaW5nS2V5U2VjcmV0OnN0cmluZyxcbiAgc2lnbmluZ0tleVNpZDogc3RyaW5nLFxuICByZXN0VXJsOiBzdHJpbmdcbiAgcmVzdFVybE5vQ3JlZHM6IHN0cmluZ1xufTtcblxuLy8gcmV0dXJucyBjcmVkZW50aWFscyB0byBiZSB1c2VkIGZvciByZXN0IGNhbGxzLlxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJlc3RDcmVkcyhlbnZpcm9ubWVudDogc3RyaW5nLCBzZXJ2ZXJVcmw6IHN0cmluZyk6IFByb21pc2U8UkVTVF9DUkVERU5USUFMUz4ge1xuICBjb25zdCB7IHByb3RvY29sLCBob3N0IH0gPSB3aW5kb3cubG9jYXRpb247XG4gIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gIGxldCB1cmwgPSBuZXcgVVJMKHNlcnZlclVybCArICcvZ2V0Q3JlZHMnKTtcbiAgdXJsLnNlYXJjaCA9IChuZXcgVVJMU2VhcmNoUGFyYW1zKHsgZW52aXJvbm1lbnQgfSkpLnRvU3RyaW5nKCk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCkpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCBqc29uUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgLy8gYWRkIHJlc3RVcmwgdG8gdGhlIHJlc3BvbnNlLlxuICAgIGNvbnN0IGNyZWRlbnRpYWxzQXQgPSBgJHtqc29uUmVzcG9uc2Uuc2lnbmluZ0tleVNpZH06JHtqc29uUmVzcG9uc2Uuc2lnbmluZ0tleVNlY3JldH1AYDtcbiAgICBqc29uUmVzcG9uc2UucmVzdFVybCA9IGVudmlyb25tZW50ID09PSAncHJvZCcgPyBgaHR0cHM6Ly8ke2NyZWRlbnRpYWxzQXR9dmlkZW8udHdpbGlvLmNvbWAgOiBgaHR0cHM6Ly8ke2NyZWRlbnRpYWxzQXR9dmlkZW8uJHtlbnZpcm9ubWVudH0udHdpbGlvLmNvbWA7O1xuICAgIGpzb25SZXNwb25zZS5yZXN0VXJsTm9DcmVkcyA9IGVudmlyb25tZW50ID09PSAncHJvZCcgPyAnaHR0cHM6Ly92aWRlby50d2lsaW8uY29tJyA6IGBodHRwczovL3ZpZGVvLiR7ZW52aXJvbm1lbnR9LnR3aWxpby5jb21gXG4gICAgcmV0dXJuIGpzb25SZXNwb25zZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBvYnRhaW4gY3JlZHMgZnJvbSBmcm9tICR7dXJsfSwgU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbn1cbiIsIlxuZXhwb3J0IGZ1bmN0aW9uIGdldERldmljZXNPZktpbmQoZGV2aWNlSW5mb3M6IE1lZGlhRGV2aWNlSW5mb1tdLCBraW5kOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGRldmljZUluZm9zLmZpbHRlcihmdW5jdGlvbihkZXZpY2VJbmZvKSB7XG4gICAgcmV0dXJuIGRldmljZUluZm8ua2luZCA9PT0ga2luZDtcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbnN1cmVNZWRpYVBlcm1pc3Npb25zKCkge1xuICBjb25zdCBkZXZpY2VzID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gIGNvbnN0IHNob3VsZEFza0Zvck1lZGlhUGVybWlzc2lvbnMgPSBkZXZpY2VzLmV2ZXJ5KGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICByZXR1cm4gIShkZXZpY2UuZGV2aWNlSWQgJiYgZGV2aWNlLmxhYmVsKTtcbiAgfSk7XG4gIGlmIChzaG91bGRBc2tGb3JNZWRpYVBlcm1pc3Npb25zKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgYXVkaW86IHRydWUsIHZpZGVvOiB0cnVlIH0pLnRoZW4oZnVuY3Rpb24gKG1lZGlhU3RyZWFtKSB7XG4gICAgICBtZWRpYVN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBEZXZpY2VTZWxlY3Rpb25PcHRpb25zID0ge1xuICBhdWRpb2lucHV0OiBNZWRpYURldmljZUluZm9bXTtcbiAgYXVkaW9vdXRwdXQ6IE1lZGlhRGV2aWNlSW5mb1tdO1xuICB2aWRlb2lucHV0OiBNZWRpYURldmljZUluZm9bXTtcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZXZpY2VTZWxlY3Rpb25PcHRpb25zKCk6IFByb21pc2U8RGV2aWNlU2VsZWN0aW9uT3B0aW9ucz4ge1xuICAvLyBiZWZvcmUgY2FsbGluZyBlbnVtZXJhdGVEZXZpY2VzLCBnZXQgbWVkaWEgcGVybWlzc2lvbnMgKC5nZXRVc2VyTWVkaWEpXG4gIC8vIHcvbyBtZWRpYSBwZXJtaXNzaW9ucywgYnJvd3NlcnMgZG8gbm90IHJldHVybiBkZXZpY2UgSWRzIGFuZC9vciBsYWJlbHMuXG4gIGF3YWl0IGVuc3VyZU1lZGlhUGVybWlzc2lvbnMoKTtcbiAgY29uc3QgZGV2aWNlSW5mb3MgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgcmV0dXJuIHtcbiAgICBhdWRpb2lucHV0OiBnZXREZXZpY2VzT2ZLaW5kKGRldmljZUluZm9zLCAnYXVkaW9pbnB1dCcpLFxuICAgIGF1ZGlvb3V0cHV0OiBnZXREZXZpY2VzT2ZLaW5kKGRldmljZUluZm9zLCAnYXVkaW9vdXRwdXQnKSxcbiAgICB2aWRlb2lucHV0OiBnZXREZXZpY2VzT2ZLaW5kKGRldmljZUluZm9zLCAndmlkZW9pbnB1dCcpLFxuICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQgKi9cbi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbi8qIGVzbGludC1kaXNhYmxlIHF1b3RlcyAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IGpzcyBmcm9tICdqc3MnO1xuaW1wb3J0IHByZXNldCBmcm9tICdqc3MtcHJlc2V0LWRlZmF1bHQnO1xuXG5qc3Muc2V0dXAocHJlc2V0KCkpO1xuZXhwb3J0IGRlZmF1bHQganNzO1xuXG4iLCJleHBvcnQgZnVuY3Rpb24gcmFuZG9tSXRlbTxUPihhcnJheTogVFtdKSB7XG4gIHZhciByYW5kb21JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFycmF5Lmxlbmd0aCk7XG4gIHJldHVybiBhcnJheVtyYW5kb21JbmRleF07XG59XG4iLCJpbXBvcnQgeyByYW5kb21JdGVtIH0gZnJvbSAnLi9yYW5kb21JdGVtJztcblxubGV0IGNhbGxOdW1iZXIgPSAwO1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVBhcnRpY2lwYW50TmFtZSgpOiBzdHJpbmcge1xuICBjb25zdCBuYW1lcyA9IFsnQWxpY2UnLCAnQm9iJywgJ0NoYXJsaWUnLCAnRGVsdGEnLCAnRWNobycsICdGb3hUcm90JywgJ0dvbGYnLCAnSG90ZWwnLCAnSW5kaWEnLFxuICAgICdKdWxpZXQnLCAnS2lsbycsICdMaW1hJywgJ01pa2UnLCAnTm92ZW1iZXInLCAnT3NjYXInLCAnUGFwYScsICdRdWViZWMnLCAnUm9tZW8nLCAnU2llcnJhJyxcbiAgICAnVGFuZ28nLCAnVW5pZm9ybScsICdWaWN0b3InLCAnV2hpc2tleScsICdYLXJheScsICdZYW5rZWUnLCAnWnVsdSddO1xuXG4gICAgbGV0IHBpY2sgPSBuYW1lc1tjYWxsTnVtYmVyXTtcbiAgICBjYWxsTnVtYmVyID0gKGNhbGxOdW1iZXIrMSkgJSAyNjtcbiAgICByZXR1cm4gcGljaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbU5hbWUoKSB7XG4gIHZhciBBREpFQ1RJVkVTID0gW1xuICAgICdBYnJhc2l2ZScsICdCcmFzaCcsICdDYWxsb3VzJywgJ0RhZnQnLCAnRWNjZW50cmljJywgJ0ZpbmVzdCcsICdHb2xkZW4nLFxuICAgICdIb2x5JywgJ0lnbm9taW5pb3VzJywgJ0pvbHRlZCcsICdLaWxsZXInLCAnTHVzY2lvdXMnLCAnTXVzaHknLCAnTmFzdHknLFxuICAgICdPbGRTY2hvb2wnLCAnUG9tcG91cycsICdRdWlldCcsICdSb3dkeScsICdTbmVha3knLCAnVGF3ZHJ5JyxcbiAgICAnVW5pcXVlJywgJ1ZpdmFjaW91cycsICdXaWNrZWQnLCAnWGVub3Bob2JpYycsICdZYXduaW5nJywgJ1plc3R5J1xuICBdO1xuXG4gIHZhciBGSVJTVF9OQU1FUyA9IFtcbiAgICAnQW5uYScsICdCb2JieScsICdDYW1lcm9uJywgJ0Rhbm55JywgJ0VtbWV0dCcsICdGcmlkYScsICdHcmFjaWUnLCAnSGFubmFoJyxcbiAgICAnSXNhYWMnLCAnSmVubmEnLCAnS2VuZHJhJywgJ0xhbmRvbicsICdNdWZhc2EnLCAnTmF0ZScsICdPd2VuJywgJ1Blbm55JyxcbiAgICAnUXVpbmN5JywgJ1J1ZGR5JywgJ1NhbWFudGhhJywgJ1RhbW15JywgJ1VseXNzZXMnLCAnVmljdG9yaWEnLCAnV2VuZHknLFxuICAgICdYYW5kZXInLCAnWW9sYW5kYScsICdaZWxkYSdcbiAgXTtcblxuICB2YXIgTEFTVF9OQU1FUyA9IFtcbiAgICAnQW5jaG9yYWdlJywgJ0JlcmxpbicsICdDdWNhbW9uZ2EnLCAnRGF2ZW5wb3J0JywgJ0Vzc2V4JywgJ0ZyZXNubycsXG4gICAgJ0d1bnNpZ2h0JywgJ0hhbm92ZXInLCAnSW5kaWFuYXBvbGlzJywgJ0phbWVzdG93bicsICdLYW5lJywgJ0xpYmVydHknLFxuICAgICdNaW5uZWFwb2xpcycsICdOZXZpcycsICdPYWtsYW5kJywgJ1BvcnRsYW5kJywgJ1F1YW50aWNvJywgJ1JhbGVpZ2gnLFxuICAgICdTYWludFBhdWwnLCAnVHVsc2EnLCAnVXRpY2EnLCAnVmFpbCcsICdXYXJzYXcnLCAnWGlhb0ppbicsICdZYWxlJyxcbiAgICAnWmltbWVybWFuJ1xuICBdO1xuICByZXR1cm4gcmFuZG9tSXRlbShBREpFQ1RJVkVTKSArXG4gICAgcmFuZG9tSXRlbShGSVJTVF9OQU1FUykgK1xuICAgIHJhbmRvbUl0ZW0oTEFTVF9OQU1FUyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21Sb29tTmFtZSgpIHtcbiAgdmFyIFBMQUNFUyA9IFtcbiAgICAnQWdyYScsICdCZXJsaW4nLCAnQ3VjYW1vbmdhJywgJ0RhdmVucG9ydCcsICdFc3NleCcsICdGcmVzbm8nLFxuICAgICdHdW5zaWdodCcsICdIYW5vdmVyJywgJ0luZG9yZScsICdKYW1lc3Rvd24nLCAnS2Fsd2EnLCAnTGliZXJ0eScsXG4gICAgJ01hZHJhcycsICdOZXZpcycsICdPYWtsYW5kJywgJ1BvcnRsYW5kJywgJ1F1YW50aWNvJywgJ1JlZG1vbmQnLFxuICAgICdTZWF0dGxlJywgJ1RoYW5lJywgJ1V0aWNhJywgJ1ZhaWwnLCAnV2Fyc2F3JywgJ1hpYW9KaW4nLCAnWWFsZScsXG4gICAgJ1ppbW1lcm1hbidcbiAgXTtcblxuICB2YXIgQ09VTlRSSUVTID0gW1xuICAgICdBdXN0cmlhJywgJ0JyYXppbCcsICdDaGluYScsICdEZW5tYXJrJywgJ0VneXB0JywgJ0ZyYW5jZScsXG4gICAgJ0doYW5hJywgJ0hvbGxhbmQnLCAnSW5kaWEnLCAnSmFtYWljYScsICdLZW55YScsICdMaWJ5YScsXG4gICAgJ01leGljbycsICdOZXBhbCcsICdPbWFuJywgJ1BlcnUnLCAnUWF0YXInLCAnUnVzc2lhJyxcbiAgICAnU3BhaW4nLCAnVHVya2V5JywgJ1VnYW5kYScsICdWaWV0bmFtJywgJ1dhbGVzJywgJ1hpYW5iZWknLCAnWWVtZW4nLFxuICAgICdaYW1iaWEnXG4gIF07XG5cblxuICByZXR1cm4gcmFuZG9tSXRlbShQTEFDRVMpICtcbiAgICByYW5kb21JdGVtKENPVU5UUklFUyk7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5pbXBvcnQgeyBjcmVhdGVCdXR0b24sIElCdXR0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvYnV0dG9uJztcbmltcG9ydCB7IGNyZWF0ZURpdiB9IGZyb20gJy4vY29tcG9uZW50cy9jcmVhdGVEaXYnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4vY29tcG9uZW50cy9jcmVhdGVFbGVtZW50JztcbmltcG9ydCB7IGNyZWF0ZUxhYmVsZWRTdGF0LCBJTGFiZWxlZFN0YXQgfSBmcm9tICcuL2NvbXBvbmVudHMvbGFiZWxlZHN0YXQnO1xuaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi9jb21wb25lbnRzL2xvZyc7XG5pbXBvcnQgeyByZW5kZXJUcmFjayB9IGZyb20gJy4vcmVuZGVyVHJhY2snO1xuaW1wb3J0IHsgUm9vbSwgTG9jYWxBdWRpb1RyYWNrLCBMb2NhbFZpZGVvVHJhY2ssIFRyYWNrLCBMb2NhbFRyYWNrUHVibGljYXRpb24sIExvY2FsVmlkZW9UcmFja1N0YXRzLCBMb2NhbEF1ZGlvVHJhY2tTdGF0cyB9IGZyb20gJ3R3aWxpby12aWRlbyc7XG5cbmltcG9ydCBqc3MgZnJvbSAnLi9qc3MnXG5pbXBvcnQgeyBjcmVhdGVDb2xsYXBzaWJsZURpdiB9IGZyb20gJy4vY29tcG9uZW50cy9jcmVhdGVDb2xsYXBzaWJsZURpdic7XG5pbXBvcnQgeyByZW5kZXJMb2NhbFRyYWNrU3RhdHMgfSBmcm9tICcuL3JlbmRlckxvY2FsVHJhY2tTdGF0cyc7XG5jb25zdCByb3VuZCA9IChudW06IG51bWJlcikgPT4gTWF0aC5yb3VuZCgobnVtICsgTnVtYmVyLkVQU0lMT04pICogMTApIC8gMTA7XG4vLyBDcmVhdGUgeW91ciBzdHlsZS5cbmNvbnN0IHN0eWxlID0ge1xuICBiYWNrZ3JvdW5kX2dyYXk6IHtcbiAgICBiYWNrZ3JvdW5kOiAnZ3JheScsXG4gIH0sXG4gIGJhY2tncm91bmRfZ3JlZW46IHtcbiAgICBiYWNrZ3JvdW5kOiAnbGlnaHRncmVlbicsXG4gIH0sXG4gIGxvY2FsVHJhY2tDb250cm9sczoge1xuICAgIC8qIHNpbmNlIGl0IGF0dGFjaGVzIHRvIHRyYWNrIGNvbnRhaW5lciAqL1xuICAgIC8qIGRvZXMgbm90IG5lZWQgdG9wIGJvcmRlciAqL1xuICAgICdib3JkZXItYm90dG9tJzogJ3NvbGlkIDFweCBibGFjaycsXG4gICAgJ2JvcmRlci1sZWZ0JzogJ3NvbGlkIDFweCBibGFjaycsXG4gICAgJ2JvcmRlci1yaWdodCc6ICdzb2xpZCAxcHggYmxhY2snLFxuICB9LFxuICBsb2NhbFRyYWNrQ29udGFpbmVyOiB7XG4gICAgcmVzaXplOiAnYm90aCcsXG4gICAgLy8gYm9yZGVyOiAnc29saWQgMXB4IGJsYWNrJyxcbiAgICBvdmVyZmxvdzogJ2F1dG8nLFxuICAgICdvdmVyZmxvdy15JzogJ3Njcm9sbCcsXG4gICAgLy8gcGFkZGluZzogJzVweCcsXG4gICAgd2lkdGg6ICczMDBweCdcbiAgfVxufVxuLy8gQ29tcGlsZSBzdHlsZXMsIGFwcGx5IHBsdWdpbnMuXG5jb25zdCBzaGVldCA9IGpzcy5jcmVhdGVTdHlsZVNoZWV0KHN0eWxlKVxuc2hlZXQuYXR0YWNoKCk7XG5cblxuY29uc3QgcHVibGlzaENvbnRyb2xzID0gbmV3IE1hcDxUcmFjay5TSUQsIE1hcDxSb29tLCBJUHVibGlzaENvbnRyb2w+PigpO1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUxvY2FsVHJhY2tTdGF0cyhyb29tOiBSb29tLCB0cmFja1N0YXRzOiBMb2NhbFZpZGVvVHJhY2tTdGF0c1tdfExvY2FsQXVkaW9UcmFja1N0YXRzW10pIHtcbiAgaWYgKHRyYWNrU3RhdHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHRyYWNrUHVibGlzaENvbnRyb2xzID0gcHVibGlzaENvbnRyb2xzLmdldCh0cmFja1N0YXRzWzBdLnRyYWNrSWQpO1xuICAgIGlmICh0cmFja1B1Ymxpc2hDb250cm9scykge1xuICAgICAgY29uc3QgcHVibGlzaENvbnRyb2wgPSB0cmFja1B1Ymxpc2hDb250cm9scy5nZXQocm9vbSk7XG4gICAgICBpZiAocHVibGlzaENvbnRyb2wpIHtcbiAgICAgICAgcHVibGlzaENvbnRyb2wudXBkYXRlTG9jYWxUcmFja1N0YXRzKHRyYWNrU3RhdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbnR5cGUgSVB1Ymxpc2hDb250cm9sID0ge1xuICB1blB1Ymxpc2hCdG46IElCdXR0b247XG4gIHN0b3BSZW5kZXJpbmc6ICgpID0+IHZvaWQ7XG4gIHVwZGF0ZUxvY2FsVHJhY2tTdGF0czogKHRyYWNrU3RhdHM6IExvY2FsVmlkZW9UcmFja1N0YXRzW118TG9jYWxBdWRpb1RyYWNrU3RhdHNbXSkgPT4gdm9pZFxufVxuXG4vLyBjcmVhdGVzIGJ1dHRvbnMgdG8gcHVibGlzaCB1bnB1Ymxpc2ggdHJhY2sgaW4gYSBnaXZlbiByb29tLlxuZnVuY3Rpb24gY3JlYXRlUm9vbVB1Ymxpc2hDb250cm9scyhjb250YWluZXI6IEhUTUxFbGVtZW50LCByb29tOiBSb29tLCB0cmFjazogTG9jYWxBdWRpb1RyYWNrIHwgTG9jYWxWaWRlb1RyYWNrLCBzaG91bGRBdXRvUHVibGlzaDogYm9vbGVhbik6IElQdWJsaXNoQ29udHJvbCB7XG4gIGNvbnRhaW5lciA9IGNyZWF0ZURpdihjb250YWluZXIsIHNoZWV0LmNsYXNzZXMubG9jYWxUcmFja0NvbnRyb2xzLCAnbG9jYWxUcmFja0NvbnRyb2xzJyk7XG4gIGNvbnN0IHJvb21TaWQgPSBjcmVhdGVFbGVtZW50KHsgY29udGFpbmVyLCB0eXBlOiAnaDgnLCBjbGFzc05hbWVzOiBbJ3Jvb21IZWFkZXInXSwgaW5uZXJIdG1sOiByb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgfSk7XG5cbiAgbGV0IHByaW9yaXR5QnV0dG9uczogSUJ1dHRvbltdID0gW107XG4gIGxldCB1blB1Ymxpc2hCdG46IElCdXR0b247XG4gIGxldCBwdWJsaXNoQnRuOiBJQnV0dG9uO1xuICBsZXQgcHJpb3JpdHk6IElMYWJlbGVkU3RhdDtcbiAgbGV0IHRyYWNrUHVibGljYXRpb246IExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IG51bGwgPSBBcnJheS5mcm9tKHJvb20ubG9jYWxQYXJ0aWNpcGFudC50cmFja3MudmFsdWVzKCkpLmZpbmQodHJhY2tQdWIgPT4gdHJhY2tQdWIudHJhY2sgPT09IHRyYWNrKSB8fCBudWxsO1xuICBjb25zdCB1cGRhdGVDb250cm9scyA9ICgpID0+IHtcbiAgICAvLyBzaG93IHByaW9yaXR5IGJ1dHRvbnMgb25seSB3aGVuIHRyYWNrUHVibGljYXRpb24gaXMgYXZhaWxhYmxlLlxuICAgIHByaW9yaXR5QnV0dG9ucy5mb3JFYWNoKHByaUJ1dHRvbiA9PiBwcmlCdXR0b24uc2hvdyghIXRyYWNrUHVibGljYXRpb24pKVxuICAgIHB1Ymxpc2hCdG4uc2hvdyghdHJhY2tQdWJsaWNhdGlvbik7XG4gICAgdW5QdWJsaXNoQnRuLnNob3coISF0cmFja1B1YmxpY2F0aW9uKTtcbiAgICBwcmlvcml0eS5zZXRUZXh0KGAke3RyYWNrUHVibGljYXRpb24/LnByaW9yaXR5fWApO1xuICB9O1xuXG4gIGxldCBsb2NhbFRyYWNrU3RhdFJlbmRlciA9IHJlbmRlckxvY2FsVHJhY2tTdGF0cyhjb250YWluZXIpO1xuICBwdWJsaXNoQnRuID0gY3JlYXRlQnV0dG9uKCdwdWJsaXNoJywgY29udGFpbmVyLCBhc3luYyAoKSA9PiB7XG4gICAgcHVibGlzaEJ0bi5kaXNhYmxlKCk7XG4gICAgaWYgKCF0cmFja1B1YmxpY2F0aW9uKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hdG9taWMtdXBkYXRlc1xuICAgICAgdHJhY2tQdWJsaWNhdGlvbiA9IGF3YWl0IHJvb20ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sodHJhY2spO1xuICAgICAgdXBkYXRlQ29udHJvbHMoKTtcbiAgICB9XG4gICAgcHVibGlzaEJ0bi5lbmFibGUoKTtcbiAgfSk7XG5cbiAgdW5QdWJsaXNoQnRuID0gY3JlYXRlQnV0dG9uKCd1bnB1Ymxpc2gnLCBjb250YWluZXIsICgpID0+IHtcbiAgICBpZiAodHJhY2tQdWJsaWNhdGlvbikge1xuICAgICAgdHJhY2tQdWJsaWNhdGlvbi51bnB1Ymxpc2goKTtcbiAgICAgIHRyYWNrUHVibGljYXRpb24gPSBudWxsO1xuICAgICAgbG9jYWxUcmFja1N0YXRSZW5kZXIuc3RvcFJlbmRlcmluZygpO1xuICAgICAgdXBkYXRlQ29udHJvbHMoKTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgcHJpb3JpdHkgPSBjcmVhdGVMYWJlbGVkU3RhdCh7XG4gICAgY29udGFpbmVyLFxuICAgIGxhYmVsOiAncHVibGlzaCBwcmlvcml0eSdcbiAgfSk7XG5cbiAgLy8gc2V0IHB1Ymxpc2ggcHJpb3JpdHkuXG4gIFsnaGlnaCcsICdzdGFuZGFyZCcsICdsb3cnXS5mb3JFYWNoKHByaW9yaXR5VGV4dCA9PiB7XG4gICAgY29uc3QgYnV0dG9uID0gY3JlYXRlQnV0dG9uKHByaW9yaXR5VGV4dCwgY29udGFpbmVyLCAoKSA9PiB7XG4gICAgICB0cmFja1B1YmxpY2F0aW9uPy5zZXRQcmlvcml0eShwcmlvcml0eVRleHQgYXMgVHJhY2suUHJpb3JpdHkpO1xuICAgICAgdXBkYXRlQ29udHJvbHMoKTtcbiAgICB9KTtcbiAgICBwcmlvcml0eUJ1dHRvbnMucHVzaChidXR0b24pO1xuICB9KVxuXG4gIHVwZGF0ZUNvbnRyb2xzKCk7XG5cbiAgaWYgKHNob3VsZEF1dG9QdWJsaXNoKSB7XG4gICAgcHVibGlzaEJ0bi5jbGljaygpO1xuICB9XG5cblxuICByZXR1cm4ge1xuICAgIHVuUHVibGlzaEJ0bixcbiAgICB1cGRhdGVMb2NhbFRyYWNrU3RhdHM6ICh0cmFja1N0YXRzOiBMb2NhbFZpZGVvVHJhY2tTdGF0c1tdfExvY2FsQXVkaW9UcmFja1N0YXRzW10pID0+IHtcbiAgICAgIGlmICh0cmFja1B1YmxpY2F0aW9uICYmIHRyYWNrUHVibGljYXRpb24udHJhY2tTaWQgPT09IHRyYWNrU3RhdHNbMF0udHJhY2tTaWQpIHtcbiAgICAgICAgbG9jYWxUcmFja1N0YXRSZW5kZXIudXBkYXRlTG9jYWxUcmFja1N0YXRzKHRyYWNrU3RhdHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RvcFJlbmRlcmluZzogKCkgPT4ge1xuICAgICAgbG9jYWxUcmFja1N0YXRSZW5kZXIuc3RvcFJlbmRlcmluZygpO1xuICAgICAgY29udGFpbmVyLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUmVuZGVyZWRMb2NhbFRyYWNrIHtcbiAgcm9vbUFkZGVkOiAocm9vbTogUm9vbSkgPT4gdm9pZDtcbiAgcm9vbVJlbW92ZWQ6IChyb29tOiBSb29tKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTG9jYWxUcmFjayh7IHJvb21zLCB0cmFjaywgY29udGFpbmVyLCBhdXRvQXR0YWNoLCBhdXRvUHVibGlzaCwgb25DbG9zZWQsIHZpZGVvRGV2aWNlcyA9IFtdIH06IHtcbiAgcm9vbXM6IFJvb21bXSxcbiAgdHJhY2s6IExvY2FsQXVkaW9UcmFjayB8IExvY2FsVmlkZW9UcmFjayxcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgYXV0b0F0dGFjaDogYm9vbGVhbixcbiAgYXV0b1B1Ymxpc2g6IGJvb2xlYW4sXG4gIG9uQ2xvc2VkOiAoKSA9PiB2b2lkLFxuICB2aWRlb0RldmljZXM6IE1lZGlhRGV2aWNlSW5mb1tdXG59KTogSVJlbmRlcmVkTG9jYWxUcmFjayB7XG4gIGNvbnN0IHsgaW5uZXJEaXY6IGxvY2FsVHJhY2tDb250YWluZXIsIG91dGVyRGl2IH0gPSBjcmVhdGVDb2xsYXBzaWJsZURpdih7IGNvbnRhaW5lciwgaGVhZGVyVGV4dDogJ0xvY2FsVHJhY2snLCBkaXZDbGFzczogc2hlZXQuY2xhc3Nlcy5sb2NhbFRyYWNrQ29udGFpbmVyIH0pO1xuICBjb25zdCB7IHN0b3BSZW5kZXJpbmcgfSA9IHJlbmRlclRyYWNrKHsgdHJhY2ssIGNvbnRhaW5lcjogbG9jYWxUcmFja0NvbnRhaW5lciwgYXV0b0F0dGFjaCB9KTtcblxuICBjb25zdCBsb2NhbFRyYWNrQ29udHJvbHMgPSBjcmVhdGVEaXYobG9jYWxUcmFja0NvbnRhaW5lciwgc2hlZXQuY2xhc3Nlcy5sb2NhbFRyYWNrQ29udHJvbHMpO1xuICBjcmVhdGVCdXR0b24oJ2Rpc2FibGUnLCBsb2NhbFRyYWNrQ29udHJvbHMsICgpID0+IHRyYWNrLmRpc2FibGUoKSk7XG4gIGNyZWF0ZUJ1dHRvbignZW5hYmxlJywgbG9jYWxUcmFja0NvbnRyb2xzLCAoKSA9PiB0cmFjay5lbmFibGUoKSk7XG4gIGNyZWF0ZUJ1dHRvbignc3RvcCcsIGxvY2FsVHJhY2tDb250cm9scywgKCkgPT4ge1xuICAgIGxvZygnc3RvcHBpbmcgdHJhY2snKTtcbiAgICB0cmFjay5zdG9wKCk7XG4gICAgbG9nKCdkb25lIHN0b3BwaW5nIHRyYWNrJyk7XG4gIH0pO1xuXG4gIGNyZWF0ZUJ1dHRvbigncmVzdGFydCcsIGxvY2FsVHJhY2tDb250cm9scywgKCkgPT4ge1xuICAgIHRyYWNrLnJlc3RhcnQoKS5jYXRjaCgoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ3RyYWNrLnJlc3RhcnQgZmFpbGVkJywgZXJyKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgdmlkZW9EZXZpY2VzLmZvckVhY2goZGV2aWNlID0+IHtcbiAgICBjcmVhdGVCdXR0b24oYHJlc3RhcnQ6ICR7ZGV2aWNlLmxhYmVsfWAsIGxvY2FsVHJhY2tDb250cm9scywgKCkgPT4ge1xuICAgICAgY29uc3QgdmlkZW9Db25zdHJhaW50cyA9IHtcbiAgICAgICAgZGV2aWNlSWQ6IHsgZXhhY3Q6IGRldmljZS5kZXZpY2VJZCB9LFxuICAgICAgfTtcbiAgICAgIGNvbnNvbGUubG9nKCdjYWxsaW5nIHJlc3RhcnQgd2l0aDogJywgdmlkZW9Db25zdHJhaW50cyk7XG4gICAgICB0cmFjay5yZXN0YXJ0KHZpZGVvQ29uc3RyYWludHMpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCd0cmFjay5yZXN0YXJ0IGZhaWxlZCcsIGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgY29uc3QgdHJhY2tQdWJsaXNoQ29udHJvbHMgPSBuZXcgTWFwPFJvb20sIElQdWJsaXNoQ29udHJvbD4oKTtcbiAgcHVibGlzaENvbnRyb2xzLnNldCh0cmFjay5pZCwgdHJhY2tQdWJsaXNoQ29udHJvbHMpO1xuXG4gIC8vIGZvciBleGlzdGluZyByb29tcywgcHVibGlzaCB0cmFjayBpZiBzaG91bGRBdXRvUHVibGlzaFxuICByb29tcy5mb3JFYWNoKChyb29tOiBSb29tKSA9PiB7XG4gICAgdHJhY2tQdWJsaXNoQ29udHJvbHMuc2V0KHJvb20sIGNyZWF0ZVJvb21QdWJsaXNoQ29udHJvbHMobG9jYWxUcmFja0NvbnRhaW5lciwgcm9vbSwgdHJhY2ssIGF1dG9QdWJsaXNoKSk7XG4gIH0pO1xuXG4gIGNvbnN0IHJvb21BZGRlZCA9IChyb29tOiBSb29tKSA9PiB7XG4gICAgaWYgKCF0cmFja1B1Ymxpc2hDb250cm9scy5nZXQocm9vbSkpIHtcbiAgICAgIC8vIGZvciBhbnkgcm9vbXMgdGhhdCBhcmUgam9pbmVkIGFmdGVyIHRyYWNrIC0gZG8gbm90IGF1dG8gcHVibGlzaCxcbiAgICAgIC8vIGFzIHJvb20gc3RhcnRzIG9mIGl0aCB0cmFja3MgZGVwZW5kaW5nIG9uIGF1dG8gcHVibGlzaC5cbiAgICAgIHRyYWNrUHVibGlzaENvbnRyb2xzLnNldChyb29tLCBjcmVhdGVSb29tUHVibGlzaENvbnRyb2xzKGxvY2FsVHJhY2tDb250YWluZXIsIHJvb20sIHRyYWNrLCBmYWxzZSkpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByb29tUmVtb3ZlZCA9IChyb29tOiBSb29tKSA9PiB7XG4gICAgY29uc3Qgcm9vbVB1Ymxpc2hDb250cm9sID0gdHJhY2tQdWJsaXNoQ29udHJvbHMuZ2V0KHJvb20pO1xuICAgIGlmIChyb29tUHVibGlzaENvbnRyb2wpIHtcbiAgICAgIHJvb21QdWJsaXNoQ29udHJvbC5zdG9wUmVuZGVyaW5nKCk7XG4gICAgICB0cmFja1B1Ymxpc2hDb250cm9scy5kZWxldGUocm9vbSk7XG4gICAgfVxuICB9O1xuXG4gIGNyZWF0ZUJ1dHRvbignY2xvc2UnLCBsb2NhbFRyYWNrQ29udHJvbHMsICgpID0+IHtcbiAgICB0cmFja1B1Ymxpc2hDb250cm9scy5mb3JFYWNoKChyb29tUHVibGlzaENvbnRyb2w6IElQdWJsaXNoQ29udHJvbCwgcm9vbTogUm9vbSkgPT4ge1xuICAgICAgcm9vbVB1Ymxpc2hDb250cm9sLnVuUHVibGlzaEJ0bi5jbGljaygpO1xuICAgICAgcm9vbVB1Ymxpc2hDb250cm9sLnN0b3BSZW5kZXJpbmcoKTtcbiAgICAgIHRyYWNrUHVibGlzaENvbnRyb2xzLmRlbGV0ZShyb29tKTtcbiAgICB9KVxuICAgIHN0b3BSZW5kZXJpbmcoKTtcbiAgICB0cmFjay5zdG9wKCk7XG4gICAgLy8gbG9jYWxUcmFja0NvbnRhaW5lci5yZW1vdmUoKTtcbiAgICBvdXRlckRpdi5yZW1vdmUoKTtcbiAgICBvbkNsb3NlZCgpO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHJvb21BZGRlZCxcbiAgICByb29tUmVtb3ZlZFxuICB9O1xufVxuIiwiaW1wb3J0IHsgTG9jYWxBdWRpb1RyYWNrU3RhdHMsIExvY2FsVmlkZW9UcmFja1N0YXRzIH0gZnJvbSAndHdpbGlvLXZpZGVvJztcbmltcG9ydCB7IGNyZWF0ZUxhYmVsZWRTdGF0IH0gZnJvbSAnLi9jb21wb25lbnRzL2xhYmVsZWRzdGF0JztcbmltcG9ydCBqc3MgZnJvbSAnLi9qc3MnXG5cblxuLy8gQ3JlYXRlIHlvdXIgc3R5bGUuXG5jb25zdCBzdHlsZSA9IHtcbiAgYmFja2dyb3VuZF9ncmF5OiB7XG4gICAgYmFja2dyb3VuZDogJ2dyYXknLFxuICB9LFxuICBiYWNrZ3JvdW5kX2dyZWVuOiB7XG4gICAgYmFja2dyb3VuZDogJ2xpZ2h0Z3JlZW4nLFxuICB9LFxuICBsb2NhbFRyYWNrQ29udHJvbHM6IHtcbiAgICAvKiBzaW5jZSBpdCBhdHRhY2hlcyB0byB0cmFjayBjb250YWluZXIgKi9cbiAgICAvKiBkb2VzIG5vdCBuZWVkIHRvcCBib3JkZXIgKi9cbiAgICAnYm9yZGVyLWJvdHRvbSc6ICdzb2xpZCAxcHggYmxhY2snLFxuICAgICdib3JkZXItbGVmdCc6ICdzb2xpZCAxcHggYmxhY2snLFxuICAgICdib3JkZXItcmlnaHQnOiAnc29saWQgMXB4IGJsYWNrJyxcbiAgfSxcbiAgbG9jYWxUcmFja0NvbnRhaW5lcjoge1xuICAgIHJlc2l6ZTogJ2JvdGgnLFxuICAgIC8vIGJvcmRlcjogJ3NvbGlkIDFweCBibGFjaycsXG4gICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAnb3ZlcmZsb3cteSc6ICdzY3JvbGwnLFxuICAgIC8vIHBhZGRpbmc6ICc1cHgnLFxuICAgIHdpZHRoOiAnMzAwcHgnXG4gIH1cbn1cblxuLy8gQ29tcGlsZSBzdHlsZXMsIGFwcGx5IHBsdWdpbnMuXG5jb25zdCBzaGVldCA9IGpzcy5jcmVhdGVTdHlsZVNoZWV0KHN0eWxlKVxuc2hlZXQuYXR0YWNoKCk7XG5cblxudHlwZSBJU1NSQ1JlbmRlciA9IHtcbiAgc3NyYzogc3RyaW5nO1xuICBzdG9wUmVuZGVyaW5nOiAoKSA9PiB2b2lkO1xuICB1cGRhdGU6ICh0cmFja1N0YXRzOiBMb2NhbEF1ZGlvVHJhY2tTdGF0c3xMb2NhbFZpZGVvVHJhY2tTdGF0cykgPT4gdm9pZDtcbn07XG5cbmZ1bmN0aW9uIHJlbmRlclNTUkMoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IElTU1JDUmVuZGVyIHtcbiAgbGV0IHNzcmM6IHN0cmluZyA9IFwidW5rbm93blwiO1xuICBsZXQgcHJldmlvdXNUaW1lID0gMDtcbiAgbGV0IHByZXZpb3VzQnl0ZXMgPSAwO1xuICBjb25zdCBzdGF0RGlzcGxheSA9IGNyZWF0ZUxhYmVsZWRTdGF0KHtcbiAgICBjb250YWluZXIsXG4gICAgbGFiZWw6ICdzZW50IChrYnBzKScsXG4gICAgdmFsdWVNYXBwZXI6ICh0ZXh0OiBzdHJpbmcpID0+IHRleHQgPT09ICcwJyA/IHNoZWV0LmNsYXNzZXMuYmFja2dyb3VuZF9ncmF5IDogc2hlZXQuY2xhc3Nlcy5iYWNrZ3JvdW5kX2dyZWVuXG4gIH0pO1xuICBzdGF0RGlzcGxheS5zZXRUZXh0KCcwJyk7XG5cbiAgZnVuY3Rpb24gaXNWaWRlb1RyYWNrU3RhdHModHJhY2s6IExvY2FsQXVkaW9UcmFja1N0YXRzfExvY2FsVmlkZW9UcmFja1N0YXRzKTogdHJhY2sgaXMgTG9jYWxWaWRlb1RyYWNrU3RhdHMge1xuICAgIHJldHVybiAnZGltZW5zaW9ucycgaW4gdHJhY2sgfHwgJ2ZyYW1lUmF0ZScgaW4gdHJhY2s7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNzcmMsXG4gICAgc3RvcFJlbmRlcmluZzogKCkgPT4ge1xuICAgICAgc3RhdERpc3BsYXkuZWxlbWVudC5yZW1vdmUoKTtcbiAgICB9LFxuICAgIHVwZGF0ZToodHJhY2tTdGF0czogTG9jYWxBdWRpb1RyYWNrU3RhdHN8TG9jYWxWaWRlb1RyYWNrU3RhdHMpID0+IHtcbiAgICAgIHNzcmMgPSB0cmFja1N0YXRzLnNzcmM7XG4gICAgICBpZiAoaXNWaWRlb1RyYWNrU3RhdHModHJhY2tTdGF0cykpIHtcbiAgICAgICAgaWYgKHRyYWNrU3RhdHMuZGltZW5zaW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdHJhY2tTdGF0cy5kaW1lbnNpb25zO1xuICAgICAgICAgIGNvbnN0IGZyYW1lUmF0ZSA9IHRyYWNrU3RhdHMuZnJhbWVSYXRlIHx8IDA7XG4gICAgICAgICAgc3RhdERpc3BsYXkuc2V0TGFiZWwoYCR7d2lkdGh9eCR7aGVpZ2h0fXgke2ZyYW1lUmF0ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IG5ld0J5dGVzU2VudCA9IHRyYWNrU3RhdHMuYnl0ZXNTZW50fHwwO1xuICAgICAgbGV0IG5ld1RpbWVzdGFtcCA9IHRyYWNrU3RhdHMudGltZXN0YW1wO1xuICAgICAgY29uc3Qgcm91bmQgPSAobnVtOiBudW1iZXIpID0+IE1hdGgucm91bmQoKG51bSArIE51bWJlci5FUFNJTE9OKSAqIDEwKSAvIDEwO1xuICAgICAgY29uc3Qga0JpdHNQZXJTZWNvbmQgPSByb3VuZCgobmV3Qnl0ZXNTZW50IC0gcHJldmlvdXNCeXRlcykgLyAobmV3VGltZXN0YW1wIC0gcHJldmlvdXNUaW1lKSkgKiAxMDtcbiAgICAgIHN0YXREaXNwbGF5LnNldFRleHQoa0JpdHNQZXJTZWNvbmQudG9TdHJpbmcoKSk7XG4gICAgICBwcmV2aW91c1RpbWUgPSBuZXdUaW1lc3RhbXA7XG4gICAgICBwcmV2aW91c0J5dGVzID0gbmV3Qnl0ZXNTZW50O1xuICAgIH1cbiAgfTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTG9jYWxUcmFja1N0YXRzKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpIHtcbiAgbGV0IHNzcmNEaXNwbGF5TWFwOiBNYXA8c3RyaW5nLCBJU1NSQ1JlbmRlcj4gPSBuZXcgTWFwKCk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlTG9jYWxUcmFja1N0YXRzOiAodHJhY2tTdGF0czogTG9jYWxWaWRlb1RyYWNrU3RhdHNbXXxMb2NhbEF1ZGlvVHJhY2tTdGF0c1tdKSA9PiB7XG4gICAgICB0cmFja1N0YXRzLmZvckVhY2godHJhY2tTdGF0ID0+IHtcbiAgICAgICAgY29uc3Qgc3NyY1JlbmRlciA9IHNzcmNEaXNwbGF5TWFwLmdldCh0cmFja1N0YXQuc3NyYyk7XG4gICAgICAgIGlmIChzc3JjUmVuZGVyKSB7XG4gICAgICAgICAgc3NyY1JlbmRlci51cGRhdGUodHJhY2tTdGF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzc3JjUmVuZGVyID0gcmVuZGVyU1NSQyhjb250YWluZXIpO1xuICAgICAgICAgIHNzcmNSZW5kZXIudXBkYXRlKHRyYWNrU3RhdCk7XG4gICAgICAgICAgc3NyY0Rpc3BsYXlNYXAuc2V0KHRyYWNrU3RhdC5zc3JjLCBzc3JjUmVuZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzdG9wUmVuZGVyaW5nOigpID0+IHtcbiAgICAgIHNzcmNEaXNwbGF5TWFwLmZvckVhY2goc3NyY1JlbmRlcmVyID0+IHNzcmNSZW5kZXJlci5zdG9wUmVuZGVyaW5nKCkpO1xuICAgICAgc3NyY0Rpc3BsYXlNYXAuY2xlYXIoKTtcbiAgICB9XG4gIH1cbn0iLCJpbXBvcnQgeyBSZW1vdGVBdWRpb1RyYWNrLCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLCBSZW1vdGVWaWRlb1RyYWNrIH0gZnJvbSAnLi4vLi4vLi4vd29yay90d2lsaW8tdmlkZW8uanMvdHNkZWYnO1xuaW1wb3J0IHsgY3JlYXRlQnV0dG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL2J1dHRvbic7XG5pbXBvcnQgeyBjcmVhdGVEaXYgfSBmcm9tICcuL2NvbXBvbmVudHMvY3JlYXRlRGl2JztcbmltcG9ydCB7IGNyZWF0ZUxhYmVsZWRTdGF0LCBJTGFiZWxlZFN0YXQgfSBmcm9tICcuL2NvbXBvbmVudHMvbGFiZWxlZHN0YXQnO1xuaW1wb3J0IHsgcmVuZGVyVHJhY2sgfSBmcm9tICcuL3JlbmRlclRyYWNrJztcblxuaW1wb3J0IGpzcyBmcm9tICcuL2pzcydcbi8vIENyZWF0ZSB5b3VyIHN0eWxlLlxuY29uc3Qgc3R5bGUgPSB7XG4gIGJhY2tncm91bmRfZ3JheToge1xuICAgIGJhY2tncm91bmQ6ICdncmF5JyxcbiAgfSxcbiAgYmFja2dyb3VuZF95ZWxsb3c6IHtcbiAgICBiYWNrZ3JvdW5kOiAneWVsbG93JyxcbiAgfSxcbiAgYmFja2dyb3VuZF9ncmVlbjoge1xuICAgIGJhY2tncm91bmQ6ICdsaWdodGdyZWVuJyxcbiAgfSxcbiAgYmFja2dyb3VuZF9yZWQ6IHtcbiAgICBiYWNrZ3JvdW5kOiAncmVkJyxcbiAgfSxcbiAgcmVtb3RlVHJhY2tDb250cm9sczoge1xuICAgIC8qIHNpbmNlIGl0IGF0dGFjaGVzIHRvIHRyYWNrIGNvbnRhaW5lciAqL1xuICAgIC8qIGRvZXMgbm90IG5lZWQgdG9wIGJvcmRlciAqL1xuICAgIC8vICdib3JkZXItYm90dG9tJzogJ3NvbGlkIDFweCBibGFjaycsXG4gICAgLy8gJ2JvcmRlci1sZWZ0JzogJ3NvbGlkIDFweCBibGFjaycsXG4gICAgLy8gJ2JvcmRlci1yaWdodCc6ICdzb2xpZCAxcHggYmxhY2snLFxuICB9XG59XG4vLyBDb21waWxlIHN0eWxlcywgYXBwbHkgcGx1Z2lucy5cbmNvbnN0IHNoZWV0ID0ganNzLmNyZWF0ZVN0eWxlU2hlZXQoc3R5bGUpXG5zaGVldC5hdHRhY2goKTtcblxuZXhwb3J0IHR5cGUgSVJlbmRlcmVkUmVtb3RlTWVkaWFUcmFjayA9IHtcbiAgc2V0Qnl0ZXNSZWNlaXZlZDogKGJ5dGVzUmVjZWl2ZWQ6IG51bWJlciwgdGltZXN0YW1wOiBudW1iZXIpID0+IHZvaWQ7XG4gIHNldEZQUzogKGZwczogbnVtYmVyKSA9PiB2b2lkO1xuICBzZXRBdWRpb0xldmVsOiAoYXVkaW9MZXZlbDogbnVtYmVyKSA9PiB2b2lkO1xuICBzdG9wUmVuZGVyaW5nOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyUmVtb3RlTWVkaWFUcmFjayh0cmFjazogUmVtb3RlQXVkaW9UcmFjayB8IFJlbW90ZVZpZGVvVHJhY2ssIHRyYWNrUHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIGF1dG9BdHRhY2g6IGJvb2xlYW4pOiBJUmVuZGVyZWRSZW1vdGVNZWRpYVRyYWNrIHtcbiAgbGV0IHRyYWNrRlBTOiBJTGFiZWxlZFN0YXQ7XG4gIGxldCB0cmFja0F1ZGlvTGV2ZWw6IElMYWJlbGVkU3RhdDtcbiAgY29uc3QgdmlkZW9UcmFjayA9IHRyYWNrLmtpbmQgPT09ICd2aWRlbycgPyB0cmFjayBhcyBSZW1vdGVWaWRlb1RyYWNrIDogbnVsbDtcbiAgY29uc3QgcmVuZGVyZWRUcmFjayA9IHJlbmRlclRyYWNrKHsgdHJhY2ssIGNvbnRhaW5lciwgYXV0b0F0dGFjaCB9KTtcbiAgY29uc3QgdHJhY2tCeXRlc0RpdiA9IGNyZWF0ZURpdihjb250YWluZXIsIHNoZWV0LmNsYXNzZXMucmVtb3RlVHJhY2tDb250cm9scywgJ3JlbW90ZVRyYWNrQ29udHJvbHMnKTtcbiAgY29uc3Qgc3RhdEJ5dGVzID0gY3JlYXRlTGFiZWxlZFN0YXQoe1xuICAgIGNvbnRhaW5lcjogdHJhY2tCeXRlc0RpdixcbiAgICBsYWJlbDogJ3JlY2VpdmVkIGticHMnLFxuICAgIHZhbHVlTWFwcGVyOiAodGV4dDogc3RyaW5nKSA9PiB0ZXh0ID09PSAnMCcgPyBzaGVldC5jbGFzc2VzLmJhY2tncm91bmRfeWVsbG93IDogdW5kZWZpbmVkXG4gIH0pO1xuICBzdGF0Qnl0ZXMuc2V0VGV4dCgnMCcpO1xuICBpZiAodmlkZW9UcmFjaykge1xuICAgIHRyYWNrRlBTID0gY3JlYXRlTGFiZWxlZFN0YXQoe1xuICAgICAgY29udGFpbmVyOiB0cmFja0J5dGVzRGl2LFxuICAgICAgbGFiZWw6ICdmcHMnLFxuICAgICAgdmFsdWVNYXBwZXI6ICh0ZXh0OiBzdHJpbmcpID0+IHRleHQgPT09ICcwJyA/IHNoZWV0LmNsYXNzZXMuYmFja2dyb3VuZF95ZWxsb3cgOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0cmFja0F1ZGlvTGV2ZWwgPSBjcmVhdGVMYWJlbGVkU3RhdCh7XG4gICAgICBjb250YWluZXI6IHRyYWNrQnl0ZXNEaXYsXG4gICAgICBsYWJlbDogJ2F1ZGlvTGV2ZWwnLFxuICAgICAgdmFsdWVNYXBwZXI6ICh0ZXh0OiBzdHJpbmcpID0+IHRleHQgPT09ICcwJyA/IHNoZWV0LmNsYXNzZXMuYmFja2dyb3VuZF95ZWxsb3cgOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHB1Ymxpc2hlclByaW9yaXR5ID0gY3JlYXRlTGFiZWxlZFN0YXQoeyBjb250YWluZXI6IHRyYWNrQnl0ZXNEaXYsIGxhYmVsOiAncHVibGlzaGVyIHByaW9yaXR5JyB9KTtcbiAgcHVibGlzaGVyUHJpb3JpdHkuc2V0VGV4dChgJHt0cmFja1B1YmxpY2F0aW9uLnB1Ymxpc2hQcmlvcml0eX1gKTtcbiAgdHJhY2tQdWJsaWNhdGlvbi5vbigncHVibGlzaFByaW9yaXR5Q2hhbmdlZCcsICgpID0+IHtcbiAgICBwdWJsaXNoZXJQcmlvcml0eS5zZXRUZXh0KGAke3RyYWNrUHVibGljYXRpb24ucHVibGlzaFByaW9yaXR5fWApO1xuICB9KTtcblxuICBjb25zdCBzd2l0Y2hPZmZTdGF0ZSA9IGNyZWF0ZUxhYmVsZWRTdGF0KHtcbiAgICBjb250YWluZXI6IHRyYWNrQnl0ZXNEaXYsXG4gICAgbGFiZWw6ICdTd2l0Y2hlZCcsXG4gICAgdmFsdWVNYXBwZXI6ICh0ZXh0OiBzdHJpbmcpID0+IHRleHQgPT09ICdPZmYnID8gc2hlZXQuY2xhc3Nlcy5iYWNrZ3JvdW5kX3llbGxvdyA6IHVuZGVmaW5lZFxuICB9KTtcblxuICBjb25zdCB1cGRhdGVTd2l0Y2hPZmZTdGF0ZSA9ICgpID0+IHN3aXRjaE9mZlN0YXRlLnNldFRleHQodHJhY2suaXNTd2l0Y2hlZE9mZiA/ICdPZmYnIDogJ09uJyk7XG4gIHRyYWNrLm9uKCdzd2l0Y2hlZE9mZicsIHVwZGF0ZVN3aXRjaE9mZlN0YXRlKTtcbiAgdHJhY2sub24oJ3N3aXRjaGVkT24nLCB1cGRhdGVTd2l0Y2hPZmZTdGF0ZSk7XG4gIHVwZGF0ZVN3aXRjaE9mZlN0YXRlKCk7XG5cbiAgLy8gYnV0dG9ucyB0byBzZXQgc3Vic2NyaWJlciBwcmlvcml0eS5cbiAgY29uc3QgcHJpb3JpdHkgPSBjcmVhdGVMYWJlbGVkU3RhdCh7IGNvbnRhaW5lcjogdHJhY2tCeXRlc0RpdiwgbGFiZWw6ICdzdWJzY3JpYmVyIHByaW9yaXR5JyB9KTtcbiAgcHJpb3JpdHkuc2V0VGV4dChgJHt0cmFjay5wcmlvcml0eX1gKTtcbiAgY3JlYXRlQnV0dG9uKCdIaWdoJywgdHJhY2tCeXRlc0RpdiwgKCkgPT4ge1xuICAgIHRyYWNrLnNldFByaW9yaXR5KCdoaWdoJyk7XG4gICAgcHJpb3JpdHkuc2V0VGV4dChgJHt0cmFjay5wcmlvcml0eX1gKTtcbiAgfSk7XG4gIGNyZWF0ZUJ1dHRvbignU3RhbmRhcmQnLCB0cmFja0J5dGVzRGl2LCAoKSA9PiB7XG4gICAgdHJhY2suc2V0UHJpb3JpdHkoJ3N0YW5kYXJkJyk7XG4gICAgcHJpb3JpdHkuc2V0VGV4dChgJHt0cmFjay5wcmlvcml0eX1gKTtcbiAgfSk7XG4gIGNyZWF0ZUJ1dHRvbignTG93JywgdHJhY2tCeXRlc0RpdiwgKCkgPT4ge1xuICAgIHRyYWNrLnNldFByaW9yaXR5KCdsb3cnKTtcbiAgICBwcmlvcml0eS5zZXRUZXh0KGAke3RyYWNrLnByaW9yaXR5fWApO1xuICB9KTtcbiAgY3JlYXRlQnV0dG9uKCdOdWxsJywgdHJhY2tCeXRlc0RpdiwgKCkgPT4ge1xuICAgIHRyYWNrLnNldFByaW9yaXR5KG51bGwpO1xuICAgIHByaW9yaXR5LnNldFRleHQoYCR7dHJhY2sucHJpb3JpdHl9YCk7XG4gIH0pO1xuXG4gIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgY29uc3QgcmVuZGVySGludCA9IGNyZWF0ZUxhYmVsZWRTdGF0KHsgY29udGFpbmVyOiB0cmFja0J5dGVzRGl2LCBsYWJlbDogJ3JlbmRlckhpbnQnIH0pO1xuICAgIHJlbmRlckhpbnQuc2V0VGV4dChgbm9uZWApO1xuICAgIGNyZWF0ZUJ1dHRvbignc3dpdGNoT2ZmJywgdHJhY2tCeXRlc0RpdiwgKCkgPT4ge1xuICAgICAgdmlkZW9UcmFjay5zd2l0Y2hPZmYoKTtcbiAgICAgIHJlbmRlckhpbnQuc2V0VGV4dChgb2ZmYCk7XG4gICAgfSk7XG4gICAgY3JlYXRlQnV0dG9uKCdzd2l0Y2hPbicsIHRyYWNrQnl0ZXNEaXYsICgpID0+IHtcbiAgICAgIHZpZGVvVHJhY2suc3dpdGNoT24oKTtcbiAgICAgIHJlbmRlckhpbnQuc2V0VGV4dChgb25gKTtcbiAgICB9KTtcbiAgICBjcmVhdGVCdXR0b24oJzE2MHgxMjAnLCB0cmFja0J5dGVzRGl2LCAoKSA9PiB7XG4gICAgICBjb25zdCByZW5kZXJEaW1lbnNpb25zID0geyB3aWR0aDogIDE2MCwgaGVpZ2h0OiAxMjAgfTtcbiAgICAgIHZpZGVvVHJhY2suc2V0Q29udGVudFByZWZlcmVuY2VzKHsgcmVuZGVyRGltZW5zaW9ucyB9KTtcbiAgICAgIHJlbmRlckhpbnQuc2V0VGV4dChgcmVuZGVyRGltZW5zaW9ucz0xNjB4MTIwYCk7XG4gICAgfSk7XG4gICAgY3JlYXRlQnV0dG9uKCcxMjgweDcyMCcsIHRyYWNrQnl0ZXNEaXYsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlbmRlckRpbWVuc2lvbnMgPSB7IHdpZHRoOiAxMjgwLCBoZWlnaHQ6IDcyMCB9O1xuICAgICAgdmlkZW9UcmFjay5zZXRDb250ZW50UHJlZmVyZW5jZXMoeyByZW5kZXJEaW1lbnNpb25zIH0pO1xuICAgICAgcmVuZGVySGludC5zZXRUZXh0KGByZW5kZXJEaW1lbnNpb25zPTEyODB4NzIwYCk7XG4gICAgfSk7XG4gIH1cblxuICBsZXQgcHJldmlvdXNCeXRlcyA9IDA7XG4gIGxldCBwcmV2aW91c1RpbWUgPSAwO1xuICByZXR1cm4ge1xuICAgIHNldEJ5dGVzUmVjZWl2ZWQ6IChieXRlc1JlY2VpdmVkOiBudW1iZXIsIHRpbWVTdGFtcDogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoc3RhdEJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IHJvdW5kID0gKG51bTogbnVtYmVyKSA9PiBNYXRoLnJvdW5kKChudW0gKyBOdW1iZXIuRVBTSUxPTikgKiAxMCkgLyAxMDtcbiAgICAgICAgY29uc3Qga0JpdHNQZXJTZWNvbmQgPSByb3VuZCgoYnl0ZXNSZWNlaXZlZCAtIHByZXZpb3VzQnl0ZXMpIC8gKHRpbWVTdGFtcCAtIHByZXZpb3VzVGltZSkpICogMTA7XG4gICAgICAgIHByZXZpb3VzQnl0ZXMgPSBieXRlc1JlY2VpdmVkO1xuICAgICAgICBwcmV2aW91c1RpbWUgPSB0aW1lU3RhbXA7XG4gICAgICAgIHN0YXRCeXRlcy5zZXRUZXh0KGtCaXRzUGVyU2Vjb25kLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0RlBTOiAoZnBzOiBudW1iZXIpID0+IHtcbiAgICAgIHRyYWNrRlBTLnNldFRleHQoZnBzLnRvU3RyaW5nKCkpO1xuICAgIH0sXG4gICAgc2V0QXVkaW9MZXZlbDogKGF1ZGlvTGV2ZWw6IG51bWJlcikgPT4ge1xuICAgICAgdHJhY2tBdWRpb0xldmVsLnNldFRleHQoYXVkaW9MZXZlbC50b1N0cmluZygpKTtcbiAgICB9LFxuICAgIHN0b3BSZW5kZXJpbmc6ICgpID0+IHtcbiAgICAgIHJlbmRlcmVkVHJhY2suc3RvcFJlbmRlcmluZygpO1xuICAgICAgdHJhY2tCeXRlc0Rpdi5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVEaXYgfSBmcm9tICcuL2NvbXBvbmVudHMvY3JlYXRlRGl2JztcbmltcG9ydCB7XG4gIFJlbW90ZVBhcnRpY2lwYW50LFxuICBSb29tLFxuICBUcmFja1xufSBmcm9tICd0d2lsaW8tdmlkZW8nO1xuaW1wb3J0IHsgY3JlYXRlSGVhZGVyIH0gZnJvbSAnLi9jcmVhdGVIZWFkZXInO1xuaW1wb3J0IHsgSVJlbmRlcmVkUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiwgcmVuZGVyUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiB9IGZyb20gXCIuL3JlbmRlclJlbW90ZVRyYWNrUHVibGljYXRpb25cIjtcblxuZXhwb3J0IHR5cGUgSVJlbmRlcmVkUmVtb3RlUGFydGljaXBhbnQgPSB7XG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gIHVwZGF0ZVN0YXRzOiAoeyB0cmFja1NpZCwgYnl0ZXNSZWNlaXZlZCwgYXVkaW9MZXZlbCwgdGltZXN0YW1wIH0gOiB7IHRyYWNrU2lkOiBzdHJpbmcsIGJ5dGVzUmVjZWl2ZWQ6IG51bWJlciwgYXVkaW9MZXZlbDogbnVtYmVyfG51bGwsIHRpbWVzdGFtcDogbnVtYmVyLCBmcHM6IG51bWJlcnxudWxsIH0pID0+IHZvaWQ7XG4gIHN0b3BSZW5kZXJpbmc6ICgpID0+IHZvaWQ7XG59XG5cbmltcG9ydCBqc3MgZnJvbSAnLi9qc3MnXG5pbXBvcnQgeyBjcmVhdGVMYWJlbGVkU3RhdCB9IGZyb20gJy4vY29tcG9uZW50cy9sYWJlbGVkc3RhdCc7XG5pbXBvcnQgeyBSRVNUX0NSRURFTlRJQUxTIH0gZnJvbSAnLi9nZXRDcmVkcyc7XG5pbXBvcnQgeyBjcmVhdGVCdXR0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvYnV0dG9uJztcbmltcG9ydCB7IGNyZWF0ZUNvbGxhcHNpYmxlRGl2IH0gZnJvbSAnLi9jb21wb25lbnRzL2NyZWF0ZUNvbGxhcHNpYmxlRGl2Jztcbi8vIENyZWF0ZSB5b3VyIHN0eWxlLlxuY29uc3Qgc3R5bGUgPSB7XG4gIGJhY2tncm91bmRfZ3JheToge1xuICAgIGJhY2tncm91bmQ6ICdncmF5JyxcbiAgfSxcbiAgYmFja2dyb3VuZF95ZWxsb3c6IHtcbiAgICBiYWNrZ3JvdW5kOiAneWVsbG93JyxcbiAgfSxcbiAgYmFja2dyb3VuZF9ncmVlbjoge1xuICAgIGJhY2tncm91bmQ6ICdsaWdodGdyZWVuJyxcbiAgfSxcbiAgYmFja2dyb3VuZF9yZWQ6IHtcbiAgICBiYWNrZ3JvdW5kOiAncmVkJyxcbiAgfSxcbiAgcmVtb3RlUGFydGljaXBhbnRzOiB7XG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGhlaWdodDogJ2F1dG8nLFxuICAgIG1hcmdpbjogJ2F1dG8nLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgJ2p1c3RpZnktY29udGVudCc6ICdmbGV4LXN0YXJ0JyxcbiAgICAnZmxleC13cmFwJzogJ3dyYXAnLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNmZmYnLFxuICAgICd0ZXh0LWFsaWduJzogJ2NlbnRlcicsXG4gIH0sXG4gIHJvb21Db250YWluZXI6IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgbWFyZ2luOiAnNXB4JyxcbiAgICAnZmxleC1kaXJlY3Rpb24nOiAnY29sdW1uJyxcbiAgICAvLyBib3JkZXI6ICdzb2xpZCBibGFjayAxcHgnLFxuICB9LFxuICByZW1vdGVUcmFja0NvbnRyb2xzOiB7XG4gICAgLyogc2luY2UgaXQgYXR0YWNoZXMgdG8gdHJhY2sgY29udGFpbmVyICovXG4gICAgLyogZG9lcyBub3QgbmVlZCB0b3AgYm9yZGVyICovXG4gICAgJ2JvcmRlci1ib3R0b20nOiAnc29saWQgMXB4IGJsYWNrJyxcbiAgICAnYm9yZGVyLWxlZnQnOiAnc29saWQgMXB4IGJsYWNrJyxcbiAgICAnYm9yZGVyLXJpZ2h0JzogJ3NvbGlkIDFweCBibGFjaycsXG4gIH0sXG4gIHBhcnRpY2lwYW50RGl2OiB7XG4gICAgbWFyZ2luOiAnMnB4JyxcbiAgICAvLyBib3JkZXI6ICdzb2xpZCAxcHggYmxhY2snXG4gIH0sXG4gIHBhcnRpY2lwYW50TWVkaWFEaXY6IHtcbiAgICBwYWRkaW5nOiAnNXB4JyxcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgJ2ZsZXgtd3JhcCc6ICd3cmFwJ1xuICB9LFxuICBwdWJsaWNhdGlvbjoge1xuICAgIHBhZGRpbmc6ICc1cHgnXG4gIH1cbn1cbi8vIENvbXBpbGUgc3R5bGVzLCBhcHBseSBwbHVnaW5zLlxuY29uc3Qgc2hlZXQgPSBqc3MuY3JlYXRlU3R5bGVTaGVldChzdHlsZSlcbnNoZWV0LmF0dGFjaCgpO1xuXG5mdW5jdGlvbiByZW1vdGVQYXJ0aWNpcGFudFJlc3RBUEkocGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50LCBjb250YWluZXI6IEhUTUxFbGVtZW50LCByb29tOiBSb29tLCByZXN0Q3JlZHM6IFJFU1RfQ1JFREVOVElBTFMpIHtcbiAgY3JlYXRlQnV0dG9uKCdjb3B5IGV4Y2x1ZGUgcGFydGljaXBhbnQnLCBjb250YWluZXIsICgpID0+IHtcbiAgICBjb25zdCBjb21tYW5kID0gYGN1cmwgLVggUE9TVCAnJHtyZXN0Q3JlZHMucmVzdFVybH0vdjEvUm9vbXMvJHtyb29tLnNpZH0vUGFydGljaXBhbnRzLyR7cm9vbS5sb2NhbFBhcnRpY2lwYW50LnNpZH0vU3Vic2NyaWJlUnVsZXMnIFxcXG4gICAgLXUgJyR7cmVzdENyZWRzLnNpZ25pbmdLZXlTaWR9OiR7cmVzdENyZWRzLnNpZ25pbmdLZXlTZWNyZXR9JyBcXFxuICAgIC1IIFwiQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiBcXFxuICAgIC1kICdSdWxlcz1be1widHlwZVwiOiBcImluY2x1ZGVcIiwgXCJhbGxcIjogdHJ1ZX0se1widHlwZVwiOiBcImV4Y2x1ZGVcIiwgXCJwdWJsaXNoZXJcIjogXCIke3BhcnRpY2lwYW50LnNpZH1cIn1dJ2A7XG4gICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoY29tbWFuZCk7XG4gIH0pO1xuXG4gIGNyZWF0ZUJ1dHRvbignZXhjbHVkZSBwYXJ0aWNpcGFudCcsIGNvbnRhaW5lciwgYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmZXRjaFJlc3VsdCA9IGF3YWl0IGZldGNoKGAke3Jlc3RDcmVkcy5yZXN0VXJsTm9DcmVkc30vdjEvUm9vbXMvJHtyb29tLnNpZH0vUGFydGljaXBhbnRzLyR7cm9vbS5sb2NhbFBhcnRpY2lwYW50LnNpZH0vU3Vic2NyaWJlUnVsZXNgLCB7XG4gICAgICAgIGJvZHk6IGBSdWxlcz1be1widHlwZVwiOiBcImluY2x1ZGVcIiwgXCJhbGxcIjogdHJ1ZX0se1widHlwZVwiOiBcImV4Y2x1ZGVcIiwgXCJwdWJsaXNoZXJcIjogXCIke3BhcnRpY2lwYW50LnNpZH1cIn1dYCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiYXV0aG9yaXphdGlvblwiOiAnQmFzaWMgJyArIGJ0b2EocmVzdENyZWRzLnNpZ25pbmdLZXlTaWQgKyBcIjpcIiArIHJlc3RDcmVkcy5zaWduaW5nS2V5U2VjcmV0KSxcbiAgICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgICAgICAgIFwic2VjLWZldGNoLW1vZGVcIjogXCJjb3JzXCIsXG4gICAgICAgICAgXCJzZWMtZmV0Y2gtc2l0ZVwiOiBcImNyb3NzLXNpdGVcIlxuICAgICAgICB9LFxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiXG4gICAgICB9KTtcbiAgICAgIGlmIChmZXRjaFJlc3VsdC5vaykge1xuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgZmV0Y2hSZXN1bHQuanNvbigpO1xuICAgICAgICBjb25zb2xlLmxvZygnZmV0Y2hSZXN1bHQuanNvbiA9ICcsIGpzb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBleGNsdWRlIHBhcnRpY2lwYW50OiAnLCBmZXRjaFJlc3VsdCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZSBwYXJ0aWNpcGFudCBlcnJvcicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGZldGNoOicsIGV4KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoOiAnICsgZXgpO1xuICAgIH1cbiAgfSk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclJlbW90ZVBhcnRpY2lwYW50KHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCwgY29udGFpbmVyOiBIVE1MRWxlbWVudCwgcm9vbTogUm9vbSwgcmVzdENyZWRzOiBSRVNUX0NSRURFTlRJQUxTIHwgbnVsbCwgc2hvdWxkQXV0b0F0dGFjaDogKCkgPT4gYm9vbGVhbik6IElSZW5kZXJlZFJlbW90ZVBhcnRpY2lwYW50IHtcblxuICBsZXQgb3V0ZXJEaXY6IEhUTUxGaWVsZFNldEVsZW1lbnQ7XG4gICh7IGlubmVyRGl2OiBjb250YWluZXIsIG91dGVyRGl2IH0gPSBjcmVhdGVDb2xsYXBzaWJsZURpdih7IGNvbnRhaW5lciwgaGVhZGVyVGV4dDogcGFydGljaXBhbnQuaWRlbnRpdHksIGRpdkNsYXNzOiBzaGVldC5jbGFzc2VzLnBhcnRpY2lwYW50RGl2fSkpXG4gIC8vIGNvbnRhaW5lciA9IGNyZWF0ZURpdihjb250YWluZXIsIHNoZWV0LmNsYXNzZXMucGFydGljaXBhbnREaXYsIGBwYXJ0aWNpcGFudENvbnRhaW5lci0ke3BhcnRpY2lwYW50LmlkZW50aXR5fWApO1xuICAvLyBjcmVhdGVMYWJlbGVkU3RhdCh7IGNvbnRhaW5lciwgbGFiZWw6ICdjbGFzcycgfSkuc2V0VGV4dCgnUmVtb3RlUGFydGljaXBhbnQnKTtcbiAgLy8gY3JlYXRlTGFiZWxlZFN0YXQoeyBjb250YWluZXIsIGxhYmVsOiAnaWRlbnRpdHknIH0pLnNldFRleHQocGFydGljaXBhbnQuaWRlbnRpdHkpO1xuICBjcmVhdGVMYWJlbGVkU3RhdCh7IGNvbnRhaW5lciwgbGFiZWw6ICdzaWQnIH0pLnNldFRleHQocGFydGljaXBhbnQuc2lkKTtcblxuICBpZiAocmVzdENyZWRzICE9PSBudWxsKSB7XG4gICAgcmVtb3RlUGFydGljaXBhbnRSZXN0QVBJKHBhcnRpY2lwYW50LCBjb250YWluZXIsIHJvb20sIHJlc3RDcmVkcyk7XG4gIH1cbiAgY29uc3QgcGFydGljaXBhbnRNZWRpYSA9IGNyZWF0ZURpdihjb250YWluZXIsIHNoZWV0LmNsYXNzZXMucGFydGljaXBhbnRNZWRpYURpdik7XG4gIGNvbnN0IHJlbmRlcmVkUHVibGljYXRpb25zID0gbmV3IE1hcDxUcmFjay5TSUQsIElSZW5kZXJlZFJlbW90ZVRyYWNrUHVibGljYXRpb24+KCk7XG4gIHBhcnRpY2lwYW50LnRyYWNrcy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcbiAgICBjb25zdCByZW5kZXJlZCA9IHJlbmRlclJlbW90ZVRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24sIHBhcnRpY2lwYW50TWVkaWEsIHNob3VsZEF1dG9BdHRhY2goKSk7XG4gICAgcmVuZGVyZWRQdWJsaWNhdGlvbnMuc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCByZW5kZXJlZCk7XG4gIH0pO1xuXG4gIHBhcnRpY2lwYW50Lm9uKCd0cmFja1B1Ymxpc2hlZCcsIHB1YmxpY2F0aW9uID0+IHtcbiAgICBjb25zdCByZW5kZXJlZCA9IHJlbmRlclJlbW90ZVRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24sIHBhcnRpY2lwYW50TWVkaWEsIHNob3VsZEF1dG9BdHRhY2goKSk7XG4gICAgcmVuZGVyZWRQdWJsaWNhdGlvbnMuc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCByZW5kZXJlZCk7XG4gIH0pO1xuICBwYXJ0aWNpcGFudC5vbigndHJhY2tVbnB1Ymxpc2hlZCcsIHB1YmxpY2F0aW9uID0+IHtcbiAgICBjb25zdCByZW5kZXJlZCA9IHJlbmRlcmVkUHVibGljYXRpb25zLmdldChwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgaWYgKHJlbmRlcmVkKSB7XG4gICAgICByZW5kZXJlZC5zdG9wUmVuZGVyaW5nKCk7XG4gICAgICByZW5kZXJlZFB1YmxpY2F0aW9ucy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY29udGFpbmVyLFxuICAgIHVwZGF0ZVN0YXRzOiAoeyB0cmFja1NpZCwgYnl0ZXNSZWNlaXZlZCwgdGltZXN0YW1wLCBmcHMsIGF1ZGlvTGV2ZWwgfTogeyB0cmFja1NpZDogc3RyaW5nOyBieXRlc1JlY2VpdmVkOiBudW1iZXI7IHRpbWVzdGFtcDogbnVtYmVyOyBhdWRpb0xldmVsOiBudW1iZXJ8bnVsbCwgZnBzOiBudW1iZXJ8bnVsbH0pID0+IHtcbiAgICAgIHJlbmRlcmVkUHVibGljYXRpb25zLmZvckVhY2goKHJlbmRlcmVkVHJhY2twdWJsaWNhdGlvbjogSVJlbmRlcmVkUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiwgcmVuZGVyZWRUcmFja1NpZDogVHJhY2suU0lEKSA9PiB7XG4gICAgICAgIGlmICh0cmFja1NpZCA9PT0gcmVuZGVyZWRUcmFja1NpZCkge1xuICAgICAgICAgIHJlbmRlcmVkVHJhY2twdWJsaWNhdGlvbi5zZXRCeXRlc1JlY2VpdmVkKGJ5dGVzUmVjZWl2ZWQsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgaWYgKGZwcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RyYWNrRlBTOiAnLCBmcHMpXG4gICAgICAgICAgICByZW5kZXJlZFRyYWNrcHVibGljYXRpb24uc2V0RlBTKGZwcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdWRpb0xldmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZW5kZXJlZFRyYWNrcHVibGljYXRpb24uc2V0QXVkaW9MZXZlbChhdWRpb0xldmVsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzdG9wUmVuZGVyaW5nOiAoKSA9PiB7XG4gICAgICByZW5kZXJlZFB1YmxpY2F0aW9ucy5mb3JFYWNoKChyZW5kZXJlZFRyYWNrcHVibGljYXRpb246IElSZW5kZXJlZFJlbW90ZVRyYWNrUHVibGljYXRpb24sIHJlbmRlcmVkVHJhY2tTaWQ6IFRyYWNrLlNJRCkgPT4ge1xuICAgICAgICByZW5kZXJlZFRyYWNrcHVibGljYXRpb24uc3RvcFJlbmRlcmluZygpO1xuICAgICAgICByZW5kZXJlZFB1YmxpY2F0aW9ucy5kZWxldGUocmVuZGVyZWRUcmFja1NpZCk7XG4gICAgICB9KTtcbiAgICAgIC8vIGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgIG91dGVyRGl2LnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7IGNyZWF0ZURpdiB9IGZyb20gJy4vY29tcG9uZW50cy9jcmVhdGVEaXYnO1xuaW1wb3J0IHsgY3JlYXRlTGFiZWxlZFN0YXQgfSBmcm9tICcuL2NvbXBvbmVudHMvbGFiZWxlZHN0YXQnO1xuaW1wb3J0IHsgbG9nIGFzIGxvZzIgfSBmcm9tICcuL2NvbXBvbmVudHMvbG9nJztcbmltcG9ydCB7XG4gIExvY2FsQXVkaW9UcmFjayxcbiAgTG9jYWxWaWRlb1RyYWNrLFxuICBSZW1vdGVBdWRpb1RyYWNrLFxuICBSZW1vdGVWaWRlb1RyYWNrLFxuICBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG59IGZyb20gJ3R3aWxpby12aWRlbyc7XG5cbmltcG9ydCB7IElSZW5kZXJlZFJlbW90ZU1lZGlhVHJhY2ssIHJlbmRlclJlbW90ZU1lZGlhVHJhY2sgfSBmcm9tICcuL3JlbmRlclJlbW90ZU1lZGlhVHJhY2snO1xuXG5pbXBvcnQganNzIGZyb20gJy4vanNzJ1xuLy8gQ3JlYXRlIHlvdXIgc3R5bGUuXG5jb25zdCBzdHlsZSA9IHtcbiAgYmFja2dyb3VuZF9ncmF5OiB7XG4gICAgYmFja2dyb3VuZDogJ2dyYXknLFxuICB9LFxuICBiYWNrZ3JvdW5kX3llbGxvdzoge1xuICAgIGJhY2tncm91bmQ6ICd5ZWxsb3cnLFxuICB9LFxuICBiYWNrZ3JvdW5kX2dyZWVuOiB7XG4gICAgYmFja2dyb3VuZDogJ2xpZ2h0Z3JlZW4nLFxuICB9LFxuICBiYWNrZ3JvdW5kX3JlZDoge1xuICAgIGJhY2tncm91bmQ6ICdyZWQnLFxuICB9LFxuICBwdWJsaWNhdGlvbjoge1xuICAgIGJvcmRlcjogJ3NvbGlkIDFweCBibGFjaycsXG4gICAgcmVzaXplOiAnYm90aCcsXG4gICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAnb3ZlcmZsb3cteSc6ICdzY3JvbGwnLFxuICAgIHdpZHRoOiAnMzAwcHgnLFxuICB9XG59XG4vLyBDb21waWxlIHN0eWxlcywgYXBwbHkgcGx1Z2lucy5cbmNvbnN0IHNoZWV0ID0ganNzLmNyZWF0ZVN0eWxlU2hlZXQoc3R5bGUpXG5zaGVldC5hdHRhY2goKTtcblxuXG5leHBvcnQgdHlwZSBJUmVuZGVyZWRSZW1vdGVUcmFja1B1YmxpY2F0aW9uID0ge1xuICBzZXRCeXRlc1JlY2VpdmVkOiAoYnl0ZXNSZWNlaXZlZDogbnVtYmVyLCB0aW1lc3RhbXA6IG51bWJlcikgPT4gdm9pZDtcbiAgc2V0RlBTOiAoZnBzOiBudW1iZXIpID0+IHZvaWQ7XG4gIHNldEF1ZGlvTGV2ZWw6IChhdWRpb0xldmVsOiBudW1iZXIpID0+IHZvaWQ7XG4gIHRyYWNrUHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb247XG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gIHN0b3BSZW5kZXJpbmc6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJSZW1vdGVUcmFja1B1YmxpY2F0aW9uKHRyYWNrUHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIGF1dG9BdHRhY2g6IGJvb2xlYW4pOiBJUmVuZGVyZWRSZW1vdGVUcmFja1B1YmxpY2F0aW9uIHtcbiAgY29uc3QgdHJhY2tDb250YWluZXJJZCA9ICd0cmFja1B1YmxpY2F0aW9uXycgKyB0cmFja1B1YmxpY2F0aW9uLnRyYWNrU2lkO1xuICBjb250YWluZXIgPSBjcmVhdGVEaXYoY29udGFpbmVyLCBzaGVldC5jbGFzc2VzLnB1YmxpY2F0aW9uLCB0cmFja0NvbnRhaW5lcklkKTtcbiAgY3JlYXRlTGFiZWxlZFN0YXQoeyBjb250YWluZXIsIGxhYmVsOiAnY2xhc3MnIH0pLnNldFRleHQoJ1JlbW90ZVRyYWNrUHVibGljYXRpb24nKTtcbiAgY3JlYXRlTGFiZWxlZFN0YXQoeyBjb250YWluZXIsIGxhYmVsOiAna2luZCcgfSkuc2V0VGV4dCh0cmFja1B1YmxpY2F0aW9uLmtpbmQpO1xuICBjcmVhdGVMYWJlbGVkU3RhdCh7IGNvbnRhaW5lciwgbGFiZWw6ICd0cmFja1NpZCcgfSkuc2V0VGV4dCh0cmFja1B1YmxpY2F0aW9uLnRyYWNrU2lkKTtcblxuICBsZXQgcmVuZGVyZWRUcmFjazogSVJlbmRlcmVkUmVtb3RlTWVkaWFUcmFjayB8IG51bGw7XG4gIGZ1bmN0aW9uIGNhblJlbmRlclRyYWNrKHRyYWNrOiBhbnkpOiB0cmFjayBpcyBMb2NhbEF1ZGlvVHJhY2sgfCBMb2NhbFZpZGVvVHJhY2sgfCBSZW1vdGVBdWRpb1RyYWNrIHwgUmVtb3RlVmlkZW9UcmFjayB7XG4gICAgcmV0dXJuIHRyYWNrO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUmVtb3RlRGF0YVRyYWNrKCkge1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tQdWJsaWNhdGlvbi50cmFjaztcbiAgICB0cmFjaz8ub24oJ21lc3NhZ2UnLCBtZXNzYWdlID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKEpTT04ucGFyc2UobWVzc2FnZSBhcyBzdHJpbmcpKTsgLy8geyB4OiA8bnVtYmVyPiwgeTogPG51bWJlcj4gfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUmVtb3RlVHJhY2soKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja1B1YmxpY2F0aW9uLnRyYWNrO1xuICAgIGlmICh0cmFja1B1YmxpY2F0aW9uLmtpbmQgPT09ICdkYXRhJykge1xuICAgICAgcmVuZGVyUmVtb3RlRGF0YVRyYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjYW5SZW5kZXJUcmFjayh0cmFjaykpIHtcbiAgICAgICAgcmVuZGVyZWRUcmFjayA9IHJlbmRlclJlbW90ZU1lZGlhVHJhY2sodHJhY2ssIHRyYWNrUHVibGljYXRpb24sIGNvbnRhaW5lciwgYXV0b0F0dGFjaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NhblJlbmRlciByZXR1cm5lZCBmYWxzZSBmb3IgJywgdHJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgaWYgKHRyYWNrUHVibGljYXRpb24uaXNTdWJzY3JpYmVkKSB7XG4gICAgcmVuZGVyUmVtb3RlVHJhY2soKTtcbiAgfVxuXG4gIHRyYWNrUHVibGljYXRpb24ub24oJ3N1YnNjcmliZWQnLCBmdW5jdGlvbiAodHJhY2spIHtcbiAgICBsb2cyKGBTdWJzY3JpYmVkIHRvICR7dHJhY2tQdWJsaWNhdGlvbi5raW5kfToke3RyYWNrLm5hbWV9YCk7XG4gICAgcmVuZGVyUmVtb3RlVHJhY2soKTtcbiAgfSk7XG5cbiAgdHJhY2tQdWJsaWNhdGlvbi5vbigndW5zdWJzY3JpYmVkJywgKCkgPT4ge1xuICAgIHJlbmRlcmVkVHJhY2s/LnN0b3BSZW5kZXJpbmcoKTtcbiAgICByZW5kZXJlZFRyYWNrID0gbnVsbDtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRCeXRlc1JlY2VpdmVkOiAoYnl0ZXNSZWNlaXZlZDogbnVtYmVyLCB0aW1lU3RhbXA6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKHJlbmRlcmVkVHJhY2spIHtcbiAgICAgICAgcmVuZGVyZWRUcmFjay5zZXRCeXRlc1JlY2VpdmVkKGJ5dGVzUmVjZWl2ZWQsIHRpbWVTdGFtcCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRGUFM6IChmcHM6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKHJlbmRlcmVkVHJhY2spIHtcbiAgICAgICAgcmVuZGVyZWRUcmFjay5zZXRGUFMoZnBzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldEF1ZGlvTGV2ZWw6IChhdWRpb0xldmVsOiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChyZW5kZXJlZFRyYWNrKSB7XG4gICAgICAgIHJlbmRlcmVkVHJhY2suc2V0QXVkaW9MZXZlbChhdWRpb0xldmVsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRyYWNrUHVibGljYXRpb24sXG4gICAgY29udGFpbmVyLFxuICAgIHN0b3BSZW5kZXJpbmc6ICgpID0+IHtcbiAgICAgIGlmIChyZW5kZXJlZFRyYWNrKSB7XG4gICAgICAgIHJlbmRlcmVkVHJhY2suc3RvcFJlbmRlcmluZygpO1xuICAgICAgICByZW5kZXJlZFRyYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5pbXBvcnQgeyBjcmVhdGVCdXR0b24gfSBmcm9tICcuL2NvbXBvbmVudHMvYnV0dG9uJztcbmltcG9ydCB7IGNyZWF0ZURpdiB9IGZyb20gJy4vY29tcG9uZW50cy9jcmVhdGVEaXYnO1xuaW1wb3J0IHsgY3JlYXRlTGFiZWxlZFN0YXQgfSBmcm9tICcuL2NvbXBvbmVudHMvbGFiZWxlZHN0YXQnO1xuaW1wb3J0IHsgY3JlYXRlTGluayB9IGZyb20gJy4vY29tcG9uZW50cy9jcmVhdGVMaW5rJztcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy9jcmVhdGVTZWxlY3Rpb24nO1xuaW1wb3J0IHsgUkVTVF9DUkVERU5USUFMUyB9IGZyb20gJy4vZ2V0Q3JlZHMnO1xuaW1wb3J0IHsgbG9nIGFzIGxvZzIgfSBmcm9tICcuL2NvbXBvbmVudHMvbG9nJztcbmltcG9ydCB7IHVwZGF0ZUxvY2FsVHJhY2tTdGF0cyB9IGZyb20gJy4vcmVuZGVyTG9jYWxUcmFjayc7XG5pbXBvcnQge1xuICBMb2csXG4gIFJvb20sXG4gIExvY2FsVmlkZW9UcmFja1N0YXRzLFxuICBSZW1vdGVBdWRpb1RyYWNrU3RhdHMsXG4gIFJlbW90ZVZpZGVvVHJhY2tTdGF0cyxcbiAgUGFydGljaXBhbnQsXG4gIFRyYWNrXG59IGZyb20gJ3R3aWxpby12aWRlbyc7XG5pbXBvcnQgeyBJUmVuZGVyZWRSZW1vdGVQYXJ0aWNpcGFudCwgcmVuZGVyUmVtb3RlUGFydGljaXBhbnQgfSBmcm9tICcuL3JlbmRlclJlbW90ZVBhcnRpY2lwYW50JztcbmltcG9ydCBqc3MgZnJvbSAnLi9qc3MnXG5pbXBvcnQgeyBjcmVhdGVDb2xsYXBzaWJsZURpdiB9IGZyb20gJy4vY29tcG9uZW50cy9jcmVhdGVDb2xsYXBzaWJsZURpdic7XG4vLyBDcmVhdGUgeW91ciBzdHlsZS5cbmNvbnN0IHN0eWxlID0ge1xuICBiYWNrZ3JvdW5kX2dyYXk6IHtcbiAgICBiYWNrZ3JvdW5kOiAnZ3JheScsXG4gIH0sXG4gIGJhY2tncm91bmRfeWVsbG93OiB7XG4gICAgYmFja2dyb3VuZDogJ3llbGxvdycsXG4gIH0sXG4gIGJhY2tncm91bmRfZ3JlZW46IHtcbiAgICBiYWNrZ3JvdW5kOiAnbGlnaHRncmVlbicsXG4gIH0sXG4gIGJhY2tncm91bmRfcmVkOiB7XG4gICAgYmFja2dyb3VuZDogJ3JlZCcsXG4gIH0sXG4gIHJlbW90ZVBhcnRpY2lwYW50czoge1xuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICBtYXJnaW46ICdhdXRvJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgICdqdXN0aWZ5LWNvbnRlbnQnOiAnZmxleC1zdGFydCcsXG4gICAgJ2ZsZXgtd3JhcCc6ICd3cmFwJyxcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjZmZmJyxcbiAgICAndGV4dC1hbGlnbic6ICdjZW50ZXInLFxuICB9LFxuICByb29tQ29udGFpbmVyOiB7XG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIG1hcmdpbjogJzVweCcsXG4gICAgJ2ZsZXgtZGlyZWN0aW9uJzogJ2NvbHVtbicsXG4gICAgLy8gYm9yZGVyOiAnc29saWQgYmxhY2sgMXB4JyxcbiAgfSxcbiAgcmVtb3RlVHJhY2tDb250cm9sczoge1xuICAgIC8qIHNpbmNlIGl0IGF0dGFjaGVzIHRvIHRyYWNrIGNvbnRhaW5lciAqL1xuICAgIC8qIGRvZXMgbm90IG5lZWQgdG9wIGJvcmRlciAqL1xuICAgICdib3JkZXItYm90dG9tJzogJ3NvbGlkIDFweCBibGFjaycsXG4gICAgJ2JvcmRlci1sZWZ0JzogJ3NvbGlkIDFweCBibGFjaycsXG4gICAgJ2JvcmRlci1yaWdodCc6ICdzb2xpZCAxcHggYmxhY2snLFxuICB9LFxuICBwYXJ0aWNpcGFudERpdjoge1xuICAgIG1hcmdpbjogJzJweCcsXG4gIH0sXG4gIHBhcnRpY2lwYW50TWVkaWFEaXY6IHtcbiAgICBwYWRkaW5nOiAnNXB4JyxcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgJ2ZsZXgtd3JhcCc6ICd3cmFwJ1xuICB9LFxuICByb29tSGVhZGVyRGl2OiB7XG4gICAgZGlzcGxheTogJ2ZsZXgnXG4gIH0sXG4gIHB1YmxpY2F0aW9uOiB7XG4gICAgcGFkZGluZzogJzVweCdcbiAgfSxcbiAgY29sbGFwc2libGVBcmVhOiB7XG4gICAgYWxsOidpbmhlcml0J1xuICB9XG59XG4vLyBDb21waWxlIHN0eWxlcywgYXBwbHkgcGx1Z2lucy5cbmNvbnN0IHNoZWV0ID0ganNzLmNyZWF0ZVN0eWxlU2hlZXQoc3R5bGUpXG5zaGVldC5hdHRhY2goKTtcblxuXG5hc3luYyBmdW5jdGlvbiByZW5kZXJFeHRyYVJvb21JbmZvcm1hdGlvbih7IHJvb20sIGNvbnRhaW5lciwgcmVzdENyZWRzIH06XG4gIHtcbiAgICByb29tOiBSb29tLFxuICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gICAgcmVzdENyZWRzOiBSRVNUX0NSRURFTlRJQUxTLFxuICB9KSB7XG4gIGNvbnN0IGNyZWRlbnRpYWxzQXQgPSBgJHtyZXN0Q3JlZHMuc2lnbmluZ0tleVNpZH06JHtyZXN0Q3JlZHMuc2lnbmluZ0tleVNlY3JldH1AYDtcbiAgY29uc3QgYmFzZVVybCA9IHJlc3RDcmVkcy5yZXN0VXJsO1xuXG4gIGNyZWF0ZUxpbmsoeyBjb250YWluZXIsIGxpbmtUZXh0OiAnUmVjb3JkaW5nUnVsZXMnLCBsaW5rVXJsOiBgJHtiYXNlVXJsfS92MS9Sb29tcy8ke3Jvb20uc2lkfS9SZWNvcmRpbmdSdWxlc2AsIG5ld1RhYjogdHJ1ZSB9KTtcblxuICBjcmVhdGVCdXR0b24oJ2NvcHkgc3RhcnQgcmVjb3JkaW5nJywgY29udGFpbmVyLCAoKSA9PiB7XG4gICAgY29uc3QgY29tbWFuZCA9IGBjdXJsIC1YIFBPU1QgJyR7YmFzZVVybH0vdjEvUm9vbXMvJHtyb29tLnNpZH0vUmVjb3JkaW5nUnVsZXMnIFxcXG4gICAgLXUgJyR7cmVzdENyZWRzLnNpZ25pbmdLZXlTaWR9OiR7cmVzdENyZWRzLnNpZ25pbmdLZXlTZWNyZXR9JyBcXFxuICAgIC1IIFwiQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiBcXFxuICAgIC1kICdSdWxlcz1be1widHlwZVwiOiBcImluY2x1ZGVcIiwgXCJhbGxcIjogXCJ0cnVlXCJ9XSdgO1xuICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KGNvbW1hbmQpO1xuICB9KTtcblxuICBjcmVhdGVCdXR0b24oJ2NvcHkgc3RvcCByZWNvcmRpbmcnLCBjb250YWluZXIsICgpID0+IHtcbiAgICBjb25zdCBjb21tYW5kID0gYGN1cmwgLVggUE9TVCAnJHtiYXNlVXJsfS92MS9Sb29tcy8ke3Jvb20uc2lkfS9SZWNvcmRpbmdSdWxlcycgXFxcbiAgICAtdSAnJHtyZXN0Q3JlZHMuc2lnbmluZ0tleVNpZH06JHtyZXN0Q3JlZHMuc2lnbmluZ0tleVNlY3JldH0nIFxcXG4gICAgLUggXCJDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiIFxcXG4gICAgLWQgJ1J1bGVzPVt7XCJ0eXBlXCI6IFwiZXhjbHVkZVwiLCBcImFsbFwiOiBcInRydWVcIn1dJ2A7XG4gICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoY29tbWFuZCk7XG4gIH0pO1xuXG5cbiAgY3JlYXRlTGluayh7IGNvbnRhaW5lciwgbGlua1RleHQ6IGAvdjEvUm9vbXMvJHtyb29tLnNpZH1gLCBsaW5rVXJsOiBgJHtiYXNlVXJsfS92MS9Sb29tcy8ke3Jvb20uc2lkfWAsIG5ld1RhYjogdHJ1ZSB9KTtcblxuICAvLyB0aGlzIHdvcmtzLlxuICAvLyBjcmVhdGVCdXR0b24oJ2ZldGNoIHJvb20nLCByb29tSGVhZGVyRGl2LCBhc3luYyAoKSA9PiB7XG4gIC8vICAgdHJ5IHtcbiAgLy8gICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgLy8gICAgIGhlYWRlcnMuYXBwZW5kKCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBidG9hKGNyZWRzLnNpZ25pbmdLZXlTaWQgKyAnOicgKyBjcmVkcy5zaWduaW5nS2V5U2VjcmV0KSk7XG4gIC8vICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaChgJHtiYXNlVXJsTm9DcmVkZW50aWFsc30vdjEvUm9vbXMvJHtyb29tLnNpZH1gLCB7IGhlYWRlcnMgfSk7XG4gIC8vICAgICBsb2cocmVzdWx0KTtcbiAgLy8gICB9IGNhdGNoIChlKSB7XG4gIC8vICAgICBsb2coJ0Vycm9yIGZldGNoaW5nOiAnLCBlKTtcbiAgLy8gICB9XG4gIC8vIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50TG9nZ2VyTGV2ZWxBc1N0cmluZyhsb2dnZXI6IExvZy5Mb2dnZXIpOiBzdHJpbmcge1xuICBjb25zdCBjdXJyZW50TGV2ZWwgPSBsb2dnZXIuZ2V0TGV2ZWwoKTtcbiAgY29uc29sZS5sb2coJ2xvZ2dlciBjdXJyZW50TGV2ZWwgPSAnLCBjdXJyZW50TGV2ZWwpO1xuICBjb25zdCBsZXZlbE51bVRvU3RyaW5nID0gbmV3IE1hcDxudW1iZXIsIHN0cmluZz4oKSA7XG4gIGxldmVsTnVtVG9TdHJpbmcuc2V0KGxvZ2dlci5sZXZlbHMuVFJBQ0UsICdUUkFDRScpO1xuICBsZXZlbE51bVRvU3RyaW5nLnNldChsb2dnZXIubGV2ZWxzLkRFQlVHLCAnREVCVUcnKTtcbiAgbGV2ZWxOdW1Ub1N0cmluZy5zZXQobG9nZ2VyLmxldmVscy5JTkZPLCAnSU5GTycpO1xuICBsZXZlbE51bVRvU3RyaW5nLnNldChsb2dnZXIubGV2ZWxzLldBUk4sICdXQVJOJyk7XG4gIGxldmVsTnVtVG9TdHJpbmcuc2V0KGxvZ2dlci5sZXZlbHMuRVJST1IsICdFUlJPUicpO1xuICBsZXZlbE51bVRvU3RyaW5nLnNldChsb2dnZXIubGV2ZWxzLlNJTEVOVCwgJ1NJTEVOVCcpO1xuICBjb25zdCBjdXJyZW50TGV2ZWxTdHIgPSBsZXZlbE51bVRvU3RyaW5nLmdldChjdXJyZW50TGV2ZWwpIGFzIHN0cmluZztcbiAgcmV0dXJuIGN1cnJlbnRMZXZlbFN0cjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmRlclJvb21EZXRhaWxzKHsgcm9vbSwgY29udGFpbmVyLCByZXN0Q3JlZHMsIGxvZ2dlciB9OiB7XG4gIHJvb206IFJvb20sXG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gIHJlc3RDcmVkczogUkVTVF9DUkVERU5USUFMU3xudWxsLFxuICBsb2dnZXI6IExvZy5Mb2dnZXJcbn0pIHtcbiAgY29uc3QgeyBpbm5lckRpdiwgb3V0ZXJEaXY6IGNvbGxhcHNpYmxlIH0gID0gY3JlYXRlQ29sbGFwc2libGVEaXYoeyBjb250YWluZXIsIGhlYWRlclRleHQ6IGBSb29tIERldGFpbHNgLCBkaXZDbGFzczogc2hlZXQuY2xhc3Nlcy5yb29tQ29udGFpbmVyLCBzdGFydEhpZGRlbjogdHJ1ZSB9KTtcbiAgY29udGFpbmVyID0gaW5uZXJEaXY7XG4gIGNvbnN0IG9wdGlvbnMgID0gT2JqZWN0LmtleXMobG9nZ2VyLmxldmVscyk7XG4gIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGdldEN1cnJlbnRMb2dnZXJMZXZlbEFzU3RyaW5nKGxvZ2dlcik7XG4gIGNvbnN0IGxvZ0xldmVsU2VsZWN0ID0gY3JlYXRlU2VsZWN0aW9uKHtcbiAgICBpZDogJ2xvZ0xldmVsJyxcbiAgICBjb250YWluZXIsXG4gICAgb3B0aW9ucyxcbiAgICB0aXRsZTogJ2xvZ0xldmVsJyxcbiAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgbG9nMihgc2V0dGluZyBsb2dMZXZlbDogJHtsb2dMZXZlbFNlbGVjdC5nZXRWYWx1ZSgpfSBmb3IgJHtyb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHl9IGluICR7cm9vbS5zaWR9YCk7XG4gICAgICBsb2dnZXIuc2V0TGV2ZWwobG9nTGV2ZWxTZWxlY3QuZ2V0VmFsdWUoKSBhcyBMb2cuTG9nTGV2ZWxEZXNjKTtcbiAgICB9XG4gIH0pO1xuXG4gIGxvZ0xldmVsU2VsZWN0LnNldFZhbHVlKGN1cnJlbnRMZXZlbCk7XG5cbiAgaWYgKHJlc3RDcmVkcyAhPT0gbnVsbCkge1xuICAgIHJlbmRlckV4dHJhUm9vbUluZm9ybWF0aW9uKHsgcm9vbSwgY29udGFpbmVyLCByZXN0Q3JlZHMgfSk7XG4gIH1cblxuICBjcmVhdGVMYWJlbGVkU3RhdCh7IGNvbnRhaW5lciwgbGFiZWw6ICdyb29tLnNpZCcgfSkuc2V0VGV4dChyb29tLnNpZCk7XG4gIGNyZWF0ZUxhYmVsZWRTdGF0KHsgY29udGFpbmVyLCBsYWJlbDogJ2xvY2FsUGFydGljaXBhbnQuc2lkJyB9KS5zZXRUZXh0KHJvb20ubG9jYWxQYXJ0aWNpcGFudC5zaWQpO1xuXG4gIGNvbnN0IHJvb21TdGF0ZSA9IGNyZWF0ZUxhYmVsZWRTdGF0KHtcbiAgICBjb250YWluZXIsXG4gICAgbGFiZWw6ICdzdGF0ZScsXG4gICAgdmFsdWVNYXBwZXI6ICh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgIHN3aXRjaCh0ZXh0KSB7XG4gICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6IHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgJ3JlY29ubmVjdGluZyc6IHJldHVybiBzaGVldC5jbGFzc2VzLmJhY2tncm91bmRfeWVsbG93O1xuICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOiByZXR1cm4gc2hlZXQuY2xhc3Nlcy5iYWNrZ3JvdW5kX3JlZDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gc2hlZXQuY2xhc3Nlcy5iYWNrZ3JvdW5kX3JlZDtcbiAgICAgIH1cbiAgIH1cbiAgfSk7XG4gIGNvbnN0IHJlY29yZGluZyA9IGNyZWF0ZUxhYmVsZWRTdGF0KHtcbiAgICBjb250YWluZXIsXG4gICAgbGFiZWw6ICdpc1JlY29yZGluZycsXG4gICAgdmFsdWVNYXBwZXI6ICh0ZXh0OiBzdHJpbmcpID0+IHRleHQgPT09ICd0cnVlJyA/IHNoZWV0LmNsYXNzZXMuYmFja2dyb3VuZF9yZWQgOiB1bmRlZmluZWRcbiAgfSk7XG5cbiAgY29uc3QgZG9taW5hbnRTcGVha2VyID0gY3JlYXRlTGFiZWxlZFN0YXQoeyBjb250YWluZXIsIGxhYmVsOiAnZG9taW5hbnRTcGVha2VyJyB9KTtcbiAgY29uc3QgdXBkYXRlRG9taW5hbnRTcGVha2VyID0gKCkgPT4gZG9taW5hbnRTcGVha2VyLnNldFRleHQocm9vbS5kb21pbmFudFNwZWFrZXIgPyByb29tLmRvbWluYW50U3BlYWtlci5pZGVudGl0eSA6ICdub25lJyk7XG4gIHJvb20ub24oJ2RvbWluYW50U3BlYWtlckNoYW5nZWQnLCB1cGRhdGVEb21pbmFudFNwZWFrZXIpO1xuICB1cGRhdGVEb21pbmFudFNwZWFrZXIoKTtcblxuICBjb25zdCBuZXR3b3JrUXVhbGl0eSA9IGNyZWF0ZUxhYmVsZWRTdGF0KHtcbiAgICBjb250YWluZXIsXG4gICAgbGFiZWw6ICdsb2NhbFBhcnRpY2lwYW50Lm5ldHdvcmtRdWFsaXR5TGV2ZWwnLFxuICAgIHZhbHVlTWFwcGVyOiAodGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICBzd2l0Y2godGV4dCkge1xuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICByZXR1cm4gc2hlZXQuY2xhc3Nlcy5iYWNrZ3JvdW5kX2dyYXk7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICByZXR1cm4gc2hlZXQuY2xhc3Nlcy5iYWNrZ3JvdW5kX3JlZDtcbiAgICAgICAgY2FzZSAnMic6XG4gICAgICAgIGNhc2UgJzMnOlxuICAgICAgICAgICAgcmV0dXJuIHNoZWV0LmNsYXNzZXMuYmFja2dyb3VuZF95ZWxsb3c7XG4gICAgICAgIGNhc2UgJzQnOlxuICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBzaGVldC5jbGFzc2VzLmJhY2tncm91bmRfcmVkO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgdXBkYXRlTmV0d29ya1F1YWxpdHkgPSAoKSA9PiBuZXR3b3JrUXVhbGl0eS5zZXRUZXh0KGAke3Jvb20ubG9jYWxQYXJ0aWNpcGFudC5uZXR3b3JrUXVhbGl0eUxldmVsfWApO1xuICByb29tLmxvY2FsUGFydGljaXBhbnQuYWRkTGlzdGVuZXIoJ25ldHdvcmtRdWFsaXR5TGV2ZWxDaGFuZ2VkJywgdXBkYXRlTmV0d29ya1F1YWxpdHkpO1xuXG4gIGNvbnN0IHVwZGF0ZVJlY29yZGluZ1N0YXRlID0gKCkgPT4gcmVjb3JkaW5nLnNldFRleHQoYCR7cm9vbS5pc1JlY29yZGluZ31gKTtcbiAgY29uc3QgdXBkYXRlUm9vbVN0YXRlID0gKCkgPT4gcm9vbVN0YXRlLnNldFRleHQocm9vbS5zdGF0ZSk7XG5cbiAgY29uc3QgbW9zU2NvcmUgPSBjcmVhdGVMYWJlbGVkU3RhdCh7XG4gICAgY29udGFpbmVyLFxuICAgIGxhYmVsOiAnbW9zJyxcbiAgfSk7XG4gIG1vc1Njb3JlLnNldFRleHQoJ251bGwnKTtcblxuICBjb25zdCB1cGRhdGVNb3MgPSAoKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG1vcyA9IHJvb20ubW9zU2NvcmU7XG4gICAgY29uc29sZS5sb2coJ3Jvb20ubW9zU2NvcmU6ICcsIG1vcyk7XG4gICAgbW9zU2NvcmUuc2V0VGV4dChgJHttb3N9YCk7XG4gIH07XG4gIHJvb20uYWRkTGlzdGVuZXIoJ21vc1Njb3JlQ2hhbmdlZCcsIHVwZGF0ZU1vcyk7XG4gIHJvb20uYWRkTGlzdGVuZXIoJ2Rpc2Nvbm5lY3RlZCcsIHVwZGF0ZVJvb21TdGF0ZSk7XG4gIHJvb20uYWRkTGlzdGVuZXIoJ3JlY29ubmVjdGVkJywgdXBkYXRlUm9vbVN0YXRlKTtcbiAgcm9vbS5hZGRMaXN0ZW5lcigncmVjb25uZWN0aW5nJywgdXBkYXRlUm9vbVN0YXRlKTtcbiAgcm9vbS5hZGRMaXN0ZW5lcigncmVjb3JkaW5nU3RhcnRlZCcsICgpID0+IHtcbiAgICBsb2cyKCdyZWNvcmRpbmdTdGFydGVkJyk7XG4gICAgdXBkYXRlUmVjb3JkaW5nU3RhdGUoKTtcbiAgfSk7XG4gIHJvb20uYWRkTGlzdGVuZXIoJ3JlY29yZGluZ1N0b3BwZWQnLCAoKSA9PiB7XG4gICAgbG9nMigncmVjb3JkaW5nU3RvcHBlZCcpO1xuICAgIHVwZGF0ZVJlY29yZGluZ1N0YXRlKCk7XG4gIH0pO1xuICB1cGRhdGVSb29tU3RhdGUoKTtcbiAgdXBkYXRlUmVjb3JkaW5nU3RhdGUoKTtcbiAgdXBkYXRlTmV0d29ya1F1YWxpdHkoKTtcblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuZGVyUm9vbSh7IHJvb20sIGNvbnRhaW5lciwgc2hvdWxkQXV0b0F0dGFjaCwgcmVzdENyZWRzLCBsb2dnZXIgfToge1xuICByb29tOiBSb29tLFxuICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICBzaG91bGRBdXRvQXR0YWNoOiAoKSA9PiBib29sZWFuLFxuICByZXN0Q3JlZHM6IFJFU1RfQ1JFREVOVElBTFN8bnVsbCxcbiAgbG9nZ2VyOiBMb2cuTG9nZ2VyXG59KSB7XG5cbiAgY29uc3QgeyBpbm5lckRpdiwgb3V0ZXJEaXY6IGNvbGxhcHNpYmxlIH0gID0gY3JlYXRlQ29sbGFwc2libGVEaXYoeyBjb250YWluZXIsIGhlYWRlclRleHQ6IHJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSwgZGl2Q2xhc3M6IHNoZWV0LmNsYXNzZXMucm9vbUNvbnRhaW5lciB9KTtcbiAgY29udGFpbmVyID0gaW5uZXJEaXY7XG4gIC8vIGNyZWF0ZUxhYmVsZWRTdGF0KHsgY29udGFpbmVyLCBsYWJlbDogJ2NsYXNzJyB9KS5zZXRUZXh0KCdSb29tJyk7XG5cbiAgcmVuZGVyUm9vbURldGFpbHMoeyByb29tLCBjb250YWluZXIsIHJlc3RDcmVkcywgbG9nZ2VyfSk7XG4gIGNvbnN0IGJ0bkRpc2Nvbm5lY3QgPSBjcmVhdGVCdXR0b24oJ2Rpc2Nvbm5lY3QnLCBjb250YWluZXIsICgpID0+IHtcbiAgICByb29tLmRpc2Nvbm5lY3QoKTtcbiAgICBjb2xsYXBzaWJsZS5yZW1vdmUoKTtcbiAgfSk7XG5cbiAgY29uc3QgaXNEaXNjb25uZWN0ZWQgPSByb29tLnN0YXRlID09PSAnZGlzY29ubmVjdGVkJztcblxuICAvLyBXaGVuIHdlIGFyZSBhYm91dCB0byB0cmFuc2l0aW9uIGF3YXkgZnJvbSB0aGlzIHBhZ2UsIGRpc2Nvbm5lY3RcbiAgLy8gZnJvbSB0aGUgcm9vbSwgaWYgam9pbmVkLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgKCkgPT4gcm9vbS5kaXNjb25uZWN0KCkpO1xuXG4gIGJ0bkRpc2Nvbm5lY3Quc2hvdyghaXNEaXNjb25uZWN0ZWQpO1xuXG4gIGNvbnN0IHJlbmRlcmVkUGFydGljaXBhbnRzID0gbmV3IE1hcDxQYXJ0aWNpcGFudC5TSUQsIElSZW5kZXJlZFJlbW90ZVBhcnRpY2lwYW50PigpO1xuICBjb25zdCByZW1vdGVQYXJ0aWNpcGFudHNDb250YWluZXIgPSBjcmVhdGVEaXYoY29udGFpbmVyLCBzaGVldC5jbGFzc2VzLnJlbW90ZVBhcnRpY2lwYW50cywgJ3JlbW90ZS1wYXJ0aWNpcGFudHMnKTtcbiAgcm9vbS5wYXJ0aWNpcGFudHMuZm9yRWFjaChwYXJ0aWNpcGFudCA9PiB7XG4gICAgcmVuZGVyZWRQYXJ0aWNpcGFudHMuc2V0KHBhcnRpY2lwYW50LnNpZCwgcmVuZGVyUmVtb3RlUGFydGljaXBhbnQocGFydGljaXBhbnQsIHJlbW90ZVBhcnRpY2lwYW50c0NvbnRhaW5lciwgcm9vbSwgcmVzdENyZWRzLCBzaG91bGRBdXRvQXR0YWNoKSk7XG4gIH0pO1xuXG4gIC8vIFdoZW4gYSBQYXJ0aWNpcGFudCBqb2lucyB0aGUgUm9vbSwgbG9nIHRoZSBldmVudC5cbiAgcm9vbS5vbigncGFydGljaXBhbnRDb25uZWN0ZWQnLCBwYXJ0aWNpcGFudCA9PiB7XG4gICAgcmVuZGVyZWRQYXJ0aWNpcGFudHMuc2V0KHBhcnRpY2lwYW50LnNpZCwgcmVuZGVyUmVtb3RlUGFydGljaXBhbnQocGFydGljaXBhbnQsIHJlbW90ZVBhcnRpY2lwYW50c0NvbnRhaW5lciwgcm9vbSwgcmVzdENyZWRzLCBzaG91bGRBdXRvQXR0YWNoKSk7XG4gIH0pO1xuXG4gIC8vIFdoZW4gYSBQYXJ0aWNpcGFudCBsZWF2ZXMgdGhlIFJvb20sIGRldGFjaCBpdHMgVHJhY2tzLlxuICByb29tLm9uKCdwYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCcsIHBhcnRpY2lwYW50ID0+IHtcbiAgICBjb25zdCByZW5kZXJlZCA9IHJlbmRlcmVkUGFydGljaXBhbnRzLmdldChwYXJ0aWNpcGFudC5zaWQpO1xuICAgIGlmIChyZW5kZXJlZCkge1xuICAgICAgcmVuZGVyZWQuc3RvcFJlbmRlcmluZygpO1xuICAgICAgcmVuZGVyZWRQYXJ0aWNpcGFudHMuZGVsZXRlKHBhcnRpY2lwYW50LnNpZCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgc3RhdFVwZGF0ZXIgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdFJlcG9ydHMgPSBhd2FpdCByb29tLmdldFN0YXRzKCk7XG4gICAgc3RhdFJlcG9ydHMuZm9yRWFjaChzdGF0UmVwb3J0ID0+IHtcbiAgICAgIC8vIHN0YXRSZXBvcnQubG9jYWxWaWRlb1RyYWNrU3RhdHMsIGNhbiBoYXZlIG11bHRpcGxlIGVudHJpZXMgZm9yIGEgbG9jYWwgdmlkZW8gdHJhY2tzIHdoZW4gc2ltdWxjYXN0IGlzIGVuYWJsZWQuXG4gICAgICAvLyBmb2xkIHRoZW0gaW50byBzaW5nbGUgZW50cnkuXG4gICAgICBjb25zdCB2aWRlb1RyYWNrU3RhdHMgPSBuZXcgTWFwPHN0cmluZywgTG9jYWxWaWRlb1RyYWNrU3RhdHNbXT4oKTtcbiAgICAgIHN0YXRSZXBvcnQubG9jYWxWaWRlb1RyYWNrU3RhdHMuZm9yRWFjaCgodHJhY2tTdGF0OiBMb2NhbFZpZGVvVHJhY2tTdGF0cykgPT4ge1xuICAgICAgICBsZXQgc3RhdEFycmF5ID0gdmlkZW9UcmFja1N0YXRzLmdldCh0cmFja1N0YXQudHJhY2tTaWQpO1xuICAgICAgICBpZiAoc3RhdEFycmF5KSB7XG4gICAgICAgICAgc3RhdEFycmF5LnB1c2godHJhY2tTdGF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2aWRlb1RyYWNrU3RhdHMuc2V0KHRyYWNrU3RhdC50cmFja1NpZCwgW3RyYWNrU3RhdF0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgQXJyYXkuZnJvbSh2aWRlb1RyYWNrU3RhdHMudmFsdWVzKCkpLmZvckVhY2goc3RhdEFycmF5ID0+IHVwZGF0ZUxvY2FsVHJhY2tTdGF0cyhyb29tLCBzdGF0QXJyYXkpKTtcblxuICAgICAgLy8geyByb29tLCB0cmFja0lkLCB0cmFja1NpZCwgYnl0ZXNTZW50LCB0aW1lc3RhbXAgfVxuICAgICAgc3RhdFJlcG9ydC5sb2NhbEF1ZGlvVHJhY2tTdGF0cy5mb3JFYWNoKGxvY2FsQXVkaW9UcmFja1N0YXRzID0+IHVwZGF0ZUxvY2FsVHJhY2tTdGF0cyhyb29tLCBbbG9jYWxBdWRpb1RyYWNrU3RhdHNdKSk7XG5cbiAgICAgIHN0YXRSZXBvcnQucmVtb3RlQXVkaW9UcmFja1N0YXRzLmZvckVhY2goKHRyYWNrU3RhdDogUmVtb3RlQXVkaW9UcmFja1N0YXRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdHJhY2tTaWQsIHRpbWVzdGFtcCwgYXVkaW9MZXZlbCB9ID0gdHJhY2tTdGF0O1xuICAgICAgICBjb25zdCBieXRlc1JlY2VpdmVkID0gdHJhY2tTdGF0LmJ5dGVzUmVjZWl2ZWQgfHwgMDtcbiAgICAgICAgcmVuZGVyZWRQYXJ0aWNpcGFudHMuZm9yRWFjaCgocmVuZGVyZWRQYXJ0aWNpcGFudDogSVJlbmRlcmVkUmVtb3RlUGFydGljaXBhbnQsIHBhcnRpY2lwYW50U2lkOiBQYXJ0aWNpcGFudC5TSUQpID0+IHtcbiAgICAgICAgICByZW5kZXJlZFBhcnRpY2lwYW50LnVwZGF0ZVN0YXRzKHsgdHJhY2tTaWQsIGJ5dGVzUmVjZWl2ZWQsIHRpbWVzdGFtcCwgYXVkaW9MZXZlbCwgZnBzOiBudWxsIH0pO1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBzdGF0UmVwb3J0LnJlbW90ZVZpZGVvVHJhY2tTdGF0cy5mb3JFYWNoKCh0cmFja1N0YXQ6IFJlbW90ZVZpZGVvVHJhY2tTdGF0cykgPT4ge1xuICAgICAgICBjb25zdCB7IHRyYWNrU2lkLCB0aW1lc3RhbXAsIGZyYW1lUmF0ZSB9ID0gdHJhY2tTdGF0O1xuICAgICAgICBjb25zdCBieXRlc1JlY2VpdmVkID0gdHJhY2tTdGF0LmJ5dGVzUmVjZWl2ZWQgfHwgMDtcbiAgICAgICAgcmVuZGVyZWRQYXJ0aWNpcGFudHMuZm9yRWFjaCgocmVuZGVyZWRQYXJ0aWNpcGFudDogSVJlbmRlcmVkUmVtb3RlUGFydGljaXBhbnQsIHBhcnRpY2lwYW50U2lkOiBQYXJ0aWNpcGFudC5TSUQpID0+IHtcbiAgICAgICAgICByZW5kZXJlZFBhcnRpY2lwYW50LnVwZGF0ZVN0YXRzKHsgdHJhY2tTaWQsIGJ5dGVzUmVjZWl2ZWQsIHRpbWVzdGFtcCwgYXVkaW9MZXZlbDogbnVsbCwgZnBzOiBmcmFtZVJhdGUgfSk7XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9KVxuICB9LCAxMDAwKTtcblxuICAvLyBPbmNlIHRoZSBMb2NhbFBhcnRpY2lwYW50IGxlYXZlcyB0aGUgcm9vbSwgZGV0YWNoIHRoZSBUcmFja3NcbiAgLy8gb2YgYWxsIFBhcnRpY2lwYW50cywgaW5jbHVkaW5nIHRoYXQgb2YgdGhlIExvY2FsUGFydGljaXBhbnQuXG4gIHJvb20ub24oJ2Rpc2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICBjbGVhckludGVydmFsKHN0YXRVcGRhdGVyKTtcbiAgICByZW5kZXJlZFBhcnRpY2lwYW50cy5mb3JFYWNoKChyZW5kZXJlZFBhcnRpY2lwYW50OiBJUmVuZGVyZWRSZW1vdGVQYXJ0aWNpcGFudCwgcGFydGljaXBhbnRTaWQ6IFBhcnRpY2lwYW50LlNJRCkgPT4ge1xuICAgICAgcmVuZGVyZWRQYXJ0aWNpcGFudC5zdG9wUmVuZGVyaW5nKCk7XG4gICAgICByZW5kZXJlZFBhcnRpY2lwYW50cy5kZWxldGUocGFydGljaXBhbnRTaWQpO1xuICAgIH0pO1xuICB9KTtcbn1cbiIsImltcG9ydCB7IHdhdmVmb3JtIH0gZnJvbSAnLi9jb21wb25lbnRzL3dhdmVmb3JtJztcbmltcG9ydCB7IGNyZWF0ZUJ1dHRvbiB9IGZyb20gJy4vY29tcG9uZW50cy9idXR0b24nO1xuaW1wb3J0IHsgY3JlYXRlRGl2IH0gZnJvbSAnLi9jb21wb25lbnRzL2NyZWF0ZURpdic7XG5pbXBvcnQgeyBjcmVhdGVMYWJlbGVkU3RhdCB9IGZyb20gJy4vY29tcG9uZW50cy9sYWJlbGVkc3RhdCc7XG5pbXBvcnQgeyBjcmVhdGVUcmFja1N0YXRzIH0gZnJvbSAnLi9jcmVhdGVUcmFja1N0YXRzJztcbmltcG9ydCB7IEF1ZGlvVHJhY2ssIFZpZGVvVHJhY2ssIFJlbW90ZVZpZGVvVHJhY2ssIFJlbW90ZUF1ZGlvVHJhY2ssIExvY2FsQXVkaW9UcmFjaywgTG9jYWxWaWRlb1RyYWNrIH0gZnJvbSAndHdpbGlvLXZpZGVvJztcblxuaW1wb3J0IGpzcyBmcm9tICcuL2pzcydcblxuLy8gQ3JlYXRlIHlvdXIgc3R5bGUuXG5jb25zdCBzdHlsZSA9IHtcbiAgYmFja2dyb3VuZF95ZWxsb3c6IHtcbiAgICBiYWNrZ3JvdW5kOiAneWVsbG93J1xuICB9LFxuICB0cmFja0NvbnRhaW5lcjoge1xuICAgIC8vIGJvcmRlcjogJ3NvbGlkIDFweCBibGFjaycsXG4gICAgcGFkZGluZzogJzVweCcsXG4gIH0sXG4gIHZpZGVvRWxlbWVudDoge1xuICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgJ21heC13aWR0aCc6ICcxMDAlICFpbXBvcnRhbnQnLFxuICAgICdtYXgtaGVpZ2h0JzogJzgwJSAhaW1wb3J0YW50J1xuICB9XG59XG4vLyBDb21waWxlIHN0eWxlcywgYXBwbHkgcGx1Z2lucy5cbmNvbnN0IHNoZWV0ID0ganNzLmNyZWF0ZVN0eWxlU2hlZXQoc3R5bGUpXG5zaGVldC5hdHRhY2goKTtcblxuLyoqXG4gKiBBdHRhY2ggdGhlIEF1ZGlvVHJhY2sgdG8gdGhlIEhUTUxBdWRpb0VsZW1lbnQgYW5kIHN0YXJ0IHRoZSBXYXZlZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaEF1ZGlvVHJhY2sodHJhY2s6IEF1ZGlvVHJhY2ssIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpIHtcbiAgY29uc3QgYXVkaW9FbGVtZW50ID0gY29udGFpbmVyLmFwcGVuZENoaWxkKHRyYWNrLmF0dGFjaCgpKTtcbiAgY29uc3Qgd2F2ZSA9IHdhdmVmb3JtKHsgbWVkaWFTdHJlYW06IGF1ZGlvRWxlbWVudC5zcmNPYmplY3QgYXMgTWVkaWFTdHJlYW0sIHdpZHRoOiAyMDAsIGhlaWdodDogMTUwIH0pXG4gIGNvbnN0IGNhbnZhc0NvbnRhaW5lciA9IGNyZWF0ZURpdihjb250YWluZXIsICdjYW52YXNDb250YWluZXInKTtcbiAgY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHdhdmUuZWxlbWVudCk7XG5cbiAgcmV0dXJuIHtcbiAgICBtZWRpYUVsZW1lbnQ6IGF1ZGlvRWxlbWVudCxcbiAgICBzdG9wOiAoKTogdm9pZCA9PiB7IHdhdmUuc3RvcCgpIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoVmlkZW9UcmFjayh0cmFjazogVmlkZW9UcmFjaywgY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xuICBjb25zdCB2aWRlb0VsZW1lbnQgPSB0cmFjay5hdHRhY2goKTtcbiAgdmlkZW9FbGVtZW50LmNsYXNzTGlzdC5hZGQoc2hlZXQuY2xhc3Nlcy52aWRlb0VsZW1lbnQpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQodmlkZW9FbGVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICBtZWRpYUVsZW1lbnQ6IHZpZGVvRWxlbWVudCxcbiAgICBzdG9wOiAoKTogdm9pZCA9PiB7fVxuICB9XG59XG5cbi8vIEF0dGFjaCB0aGUgVHJhY2sgdG8gdGhlIERPTS5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJUcmFjayh7IHRyYWNrLCBjb250YWluZXIsIGF1dG9BdHRhY2ggfSA6IHtcbiAgdHJhY2s6IExvY2FsQXVkaW9UcmFjayB8IExvY2FsVmlkZW9UcmFjayB8IFJlbW90ZUF1ZGlvVHJhY2sgfCBSZW1vdGVWaWRlb1RyYWNrLFxuICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICBhdXRvQXR0YWNoOiBib29sZWFuXG59KSB7XG5cbiAgY29uc3QgdHJhY2tDb250YWluZXIgPSBjcmVhdGVEaXYoY29udGFpbmVyLCBzaGVldC5jbGFzc2VzLnRyYWNrQ29udGFpbmVyKTtcbiAgY29uc3QgeyB1cGRhdGVTdGF0cyB9ID0gY3JlYXRlVHJhY2tTdGF0cyh0cmFjaywgdHJhY2tDb250YWluZXIpO1xuXG4gIGNvbnN0IGNvbnRyb2xDb250YWluZXIgPSBjcmVhdGVEaXYodHJhY2tDb250YWluZXIsICd0cmFja0NvbnRyb2xzJyk7XG5cbiAgY3JlYXRlQnV0dG9uKCd1cGRhdGUnLCBjb250cm9sQ29udGFpbmVyLCAoKSA9PiB1cGRhdGVTdGF0cygpKTtcblxuICBsZXQgbWVkaWFDb250cm9sczogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgbGV0IHN0b3BNZWRpYVJlbmRlciA9ICgpID0+IHt9O1xuICBjb25zdCBhdHRhY2hEZXRhY2hCdG4gPSBjcmVhdGVCdXR0b24oJ2F0dGFjaCcsIGNvbnRyb2xDb250YWluZXIsICgpID0+IHtcbiAgICBpZiAobWVkaWFDb250cm9scykge1xuICAgICAgLy8gdHJhY2sgaXMgYWxyZWFkeSBhdHRhY2hlZC5cbiAgICAgIHRyYWNrLmRldGFjaCgpLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpO1xuICAgICAgbWVkaWFDb250cm9scy5yZW1vdmUoKTtcbiAgICAgIG1lZGlhQ29udHJvbHMgPSBudWxsO1xuICAgICAgYXR0YWNoRGV0YWNoQnRuLnRleHQoJ2F0dGFjaCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0cmFjayBpcyBkZXRhY2hlZC5cbiAgICAgIG1lZGlhQ29udHJvbHMgPSBjcmVhdGVEaXYodHJhY2tDb250YWluZXIsICdtZWRpYUNvbnRyb2xzJyk7XG4gICAgICBjb25zdCBtZWRpYVJlbmRlcmVyID0gdHJhY2sua2luZCA9PT0gJ2F1ZGlvJyA/IGF0dGFjaEF1ZGlvVHJhY2sodHJhY2ssIG1lZGlhQ29udHJvbHMpOiBhdHRhY2hWaWRlb1RyYWNrKHRyYWNrLCBtZWRpYUNvbnRyb2xzKTtcbiAgICAgIGNvbnN0IGF1ZGlvVmlkZW9FbGVtZW50ID0gbWVkaWFSZW5kZXJlci5tZWRpYUVsZW1lbnQ7XG4gICAgICBzdG9wTWVkaWFSZW5kZXIgPSAoKSA9PiBtZWRpYVJlbmRlcmVyLnN0b3A7XG5cbiAgICAgIGNyZWF0ZUJ1dHRvbigncGF1c2UnLCBtZWRpYUNvbnRyb2xzLCAoKSA9PiBhdWRpb1ZpZGVvRWxlbWVudD8ucGF1c2UoKSk7XG4gICAgICBjcmVhdGVCdXR0b24oJ3BsYXknLCBtZWRpYUNvbnRyb2xzLCAoKSA9PiBhdWRpb1ZpZGVvRWxlbWVudD8ucGxheSgpKTtcbiAgICAgIGNyZWF0ZUJ1dHRvbigndXBkYXRlJywgbWVkaWFDb250cm9scywgKCkgPT4gdXBkYXRlTWVkaWFFbGVtZW50U3RhdGUoKSk7XG4gICAgICBjb25zdCBpc1BsYXlpbmcgPSBjcmVhdGVMYWJlbGVkU3RhdCh7XG4gICAgICAgIGNvbnRhaW5lcjogbWVkaWFDb250cm9scyxcbiAgICAgICAgbGFiZWw6ICdwbGF5aW5nJyxcbiAgICAgICAgdmFsdWVNYXBwZXI6ICh0ZXh0OiBzdHJpbmcpID0+IHRleHQgPT09ICdmYWxzZScgPyBzaGVldC5jbGFzc2VzLmJhY2tncm91bmRfeWVsbG93IDogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHZvbHVtZSA9IGNyZWF0ZUxhYmVsZWRTdGF0KHtcbiAgICAgICAgY29udGFpbmVyOiBtZWRpYUNvbnRyb2xzLFxuICAgICAgICBsYWJlbDogJ3ZvbHVtZSdcbiAgICAgIH0pO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWlubmVyLWRlY2xhcmF0aW9uc1xuICAgICAgY29uc3QgdXBkYXRlTWVkaWFFbGVtZW50U3RhdGUgPSAoKSA9PiB7XG4gICAgICAgIGlzUGxheWluZy5zZXRUZXh0KGAkeyFhdWRpb1ZpZGVvRWxlbWVudD8ucGF1c2VkfWApO1xuICAgICAgICB2b2x1bWUuc2V0VGV4dChgJHthdWRpb1ZpZGVvRWxlbWVudD8udm9sdW1lfWApO1xuICAgICAgfVxuXG4gICAgICBhdWRpb1ZpZGVvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsICgpID0+IHVwZGF0ZU1lZGlhRWxlbWVudFN0YXRlKCkpO1xuICAgICAgYXVkaW9WaWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGxheScsICgpID0+IHVwZGF0ZU1lZGlhRWxlbWVudFN0YXRlKCkpO1xuICAgICAgYXR0YWNoRGV0YWNoQnRuLnRleHQoJ2RldGFjaCcpO1xuICAgICAgdXBkYXRlTWVkaWFFbGVtZW50U3RhdGUoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChhdXRvQXR0YWNoKSB7XG4gICAgYXR0YWNoRGV0YWNoQnRuLmNsaWNrKCk7XG4gIH1cbiAgdXBkYXRlU3RhdHMoKTtcbiAgcmV0dXJuIHtcbiAgICB0cmFja0NvbnRhaW5lcixcbiAgICB0cmFjayxcbiAgICB1cGRhdGVTdGF0cyxcbiAgICBzdG9wUmVuZGVyaW5nOiAoKSA9PiB7XG4gICAgICB0cmFjay5kZXRhY2goKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBlbGVtZW50LnJlbW92ZSgpXG4gICAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgdHJhY2tDb250YWluZXIucmVtb3ZlKCk7XG4gICAgICBzdG9wTWVkaWFSZW5kZXIoKTtcbiAgICB9XG4gIH07XG59XG5cblxuIiwiaW1wb3J0IHsgY3JlYXRlQnV0dG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL2J1dHRvbic7XG5pbXBvcnQgeyBsb2cgfSBmcm9tICcuL2NvbXBvbmVudHMvbG9nJztcbmltcG9ydCB7IFByZWZsaWdodFRlc3QsIFByZWZsaWdodFRlc3RSZXBvcnQgfSBmcm9tICd0d2lsaW8tdmlkZW8nO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBQcmVmbGlnaHQoeyBjb250YWluZXIsIHRva2VuLCBWaWRlbywgZW52aXJvbm1lbnQsIHJlbmRlck1TVHJhY2sgfSA6XG4gIHtcbiAgICBjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgVmlkZW86IHR5cGVvZiBpbXBvcnQoJ3R3aWxpby12aWRlbycpLFxuICAgIGVudmlyb25tZW50OiBzdHJpbmdcbiAgICByZW5kZXJNU1RyYWNrOiAodHJhY2s6IE1lZGlhU3RyZWFtVHJhY2spID0+IHZvaWRcbiAgfSkge1xuICBjb25zdCBydW5QcmVmbGlnaHQgPSBWaWRlby5ydW5QcmVmbGlnaHQ7XG4gIGxldCBwcmVmbGlnaHRUZXN0OiBQcmVmbGlnaHRUZXN0IHwgbnVsbCA9IG51bGw7XG4gIGNvbnN0IGZsaWdodEJ0biA9IGNyZWF0ZUJ1dHRvbigncnVuUHJlZmxpZ2h0JywgY29udGFpbmVyLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKHByZWZsaWdodFRlc3QpIHtcbiAgICAgIC8vIHN0b3Agb24gZ29pbmcgcHJlZmxpZ2h0IHRlc3RcbiAgICAgIHByZWZsaWdodFRlc3Quc3RvcCgpO1xuICAgICAgZmxpZ2h0QnRuLnRleHQoJ3J1blByZWZsaWdodCcpO1xuICAgICAgcHJlZmxpZ2h0VGVzdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsaWdodEJ0bi50ZXh0KCdzdG9wJyk7XG4gICAgICBjb25zdCBsb2dnZXIgPSBWaWRlby5Mb2dnZXIuZ2V0TG9nZ2VyKCd0d2lsaW8tdmlkZW8nKTtcbiAgICAgIGxvZ2dlci5zZXRMZXZlbCgnREVCVUcnKTtcbiAgICAgIGNvbnNvbGUubG9nKCdzdGFydGluZyBydW5QcmVmbGlnaHQnKTtcbiAgICAgIHByZWZsaWdodFRlc3QgPSBydW5QcmVmbGlnaHQodG9rZW4sIHsgZHVyYXRpb246IDEwMDAwLCBlbnZpcm9ubWVudCB9KTtcbiAgICAgIGNvbnN0IGRlZmVycmVkOiB7IHJlamVjdD86IChlOiBFcnJvcikgPT4gdm9pZDsgcmVzb2x2ZT86IChyZXBvcnQ6IGFueSkgPT4gdm9pZDsgcHJvbWlzZT86IFByb21pc2U8YW55PjsgfSA9IHt9O1xuICAgICAgZGVmZXJyZWQucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdCA9IHJlamVjdDtcbiAgICAgIH0pO1xuXG4gICAgICBwcmVmbGlnaHRUZXN0Lm9uKCdwcm9ncmVzcycsIChwcm9ncmVzczogc3RyaW5nKSA9PiB7XG4gICAgICAgIGxvZygncHJlZmxpZ2h0IHByb2dyZXNzOicsIHByb2dyZXNzKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcmVmbGlnaHRUZXN0Lm9uKCdmYWlsZWQnLCAoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgIGxvZygncHJlZmxpZ2h0IGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgY29uc29sZS5lcnJvcigncHJlZmxpZ2h0IGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0ICYmIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgcHJlZmxpZ2h0VGVzdC5vbignY29tcGxldGVkJywgKHJlcG9ydDogUHJlZmxpZ2h0VGVzdFJlcG9ydCkgPT4ge1xuICAgICAgICBsb2coXCJUZXN0IGNvbXBsZXRlZCBpbiBcIiArIHJlcG9ydC50ZXN0VGltaW5nLmR1cmF0aW9uICsgXCIgbWlsbGlzZWNvbmRzLlwiKTtcbiAgICAgICAgbG9nKFwiIEl0IHRvb2sgXCIgKyByZXBvcnQubmV0d29ya1RpbWluZy5jb25uZWN0Py5kdXJhdGlvbiArIFwiIG1pbGxpc2Vjb25kcyB0byBjb25uZWN0XCIpO1xuICAgICAgICBsb2coXCIgSXQgdG9vayBcIiArIHJlcG9ydC5uZXR3b3JrVGltaW5nLm1lZGlhPy5kdXJhdGlvbiArIFwiIG1pbGxpc2Vjb25kcyB0byByZWNlaXZlIG1lZGlhXCIpO1xuICAgICAgICBsb2coJ3ByZWZsaWdodCBjb21wbGV0ZWQ6JywgcmVwb3J0KTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSAmJiBkZWZlcnJlZC5yZXNvbHZlKHJlcG9ydCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcHJlZmxpZ2h0VGVzdC5vbignZGVidWcnLCBwYXlsb2FkID0+IHtcbiAgICAgICAgaWYgKHBheWxvYWQubG9jYWxUcmFja3MpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnZ290IGRlYnVnIGxvY2FsVHJhY2tzOicsIHBheWxvYWQubG9jYWxUcmFja3MpO1xuICAgICAgICAgIHBheWxvYWQubG9jYWxUcmFja3MuZm9yRWFjaCgodHJhY2s6IE1lZGlhU3RyZWFtVHJhY2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1zVHJhY2sgPSB0cmFjayBhcyBNZWRpYVN0cmVhbVRyYWNrO1xuICAgICAgICAgICAgcmVuZGVyTVNUcmFjayhtc1RyYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXlsb2FkLnJlbW90ZVRyYWNrcykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdnb3QgZGVidWcgcmVtb3RlVHJhY2tzOicsIHBheWxvYWQucmVtb3RlVHJhY2tzKTtcbiAgICAgICAgICBwYXlsb2FkLnJlbW90ZVRyYWNrcy5mb3JFYWNoKCh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbXNUcmFjayA9IHRyYWNrIGFzIE1lZGlhU3RyZWFtVHJhY2s7XG4gICAgICAgICAgICByZW5kZXJNU1RyYWNrKG1zVHJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICB9KTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=